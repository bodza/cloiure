package cloiure.lang;

import cloiure.asm.Opcodes;

public class Intrinsics implements Opcodes
{
    private static Object[] oa(Object... arr)
    {
        return arr;
    }

    static IPersistentMap ops = RT.map(
            "public static double cloiure.lang.Numbers.add(double,double)", DADD,
            "public static long cloiure.lang.Numbers.and(long,long)", LAND,
            "public static long cloiure.lang.Numbers.or(long,long)", LOR,
            "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
            "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
            "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
            "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
            "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
            "public static double cloiure.lang.Numbers.minus(double)", DNEG,
            "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
            "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
            "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
            "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
            "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
            "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
            "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
            "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
            "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
            "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

            "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
            "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
            "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
            "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
            "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
            "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
            "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
            "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
            "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

            "public static double cloiure.lang.RT.doubleCast(long)", L2D,
            "public static double cloiure.lang.RT.doubleCast(double)", NOP,
            "public static double cloiure.lang.RT.doubleCast(float)", F2D,
            "public static double cloiure.lang.RT.doubleCast(int)", I2D,
            "public static double cloiure.lang.RT.doubleCast(short)", I2D,
            "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
            "public static long cloiure.lang.RT.longCast(long)", NOP,
            "public static long cloiure.lang.RT.longCast(short)", I2L,
            "public static long cloiure.lang.RT.longCast(byte)", I2L,
            "public static long cloiure.lang.RT.longCast(int)", I2L,
            "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
            "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
            "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
            "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    );

    // map to instructions terminated with comparator for branch to false
    static IPersistentMap preds = RT.map(
            "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
            "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
            "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
            "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
            "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
            "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
            "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
            "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
            "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
            "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
            "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
            "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

            "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
            "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
            "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
            "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
            "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
            "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    );
}
