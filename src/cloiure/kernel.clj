(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(defmacro cond-let [x y & w]
    (let [x (if (vector? x) x [`_# x]) z (when (seq w) `(cond-let ~@w))]
        `(if-let ~x ~y ~z)))

(def % rem)
(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(import
    [java.io FileNotFoundException InputStreamReader IOException LineNumberReader OutputStreamWriter PrintWriter PushbackReader Reader #_StringReader StringWriter Writer]
  #_[java.lang Character Class Exception IllegalArgumentException IllegalStateException Integer Number NumberFormatException Object RuntimeException String StringBuilder Throwable UnsupportedOperationException]
    [java.lang.ref Reference ReferenceQueue SoftReference WeakReference]
    [java.lang.reflect Array Constructor Field InvocationHandler #_Method Modifier]
    [java.math BigDecimal BigInteger MathContext]
    [java.net JarURLConnection URL URLClassLoader URLConnection]
    [java.nio ByteBuffer]
    [java.nio.charset Charset]
    [java.security AccessController PrivilegedAction]
    [java.util AbstractCollection AbstractSet ArrayList Arrays Collection Comparator EmptyStackException HashMap HashSet IdentityHashMap Iterator LinkedList List Map Map$Entry NoSuchElementException Queue Set Stack TreeMap]
    [java.util.concurrent Callable ConcurrentHashMap ConcurrentMap CountDownLatch Executor ExecutorService Executors ThreadFactory TimeUnit]
    [java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicLong AtomicReference]
    [java.util.concurrent.locks ReentrantReadWriteLock]
    [java.util.regex Matcher Pattern]
    [cloiure.asm Attribute ByteVector ClassVisitor ClassWriter FieldVisitor Label MethodVisitor Opcodes Type]
    [cloiure.asm.commons GeneratorAdapter Method]
)

(declare AFn'new AFn'applyToHelper)
(declare AFunction'init AFunction'new)
(declare ActionQueue'init ActionQueue'new)
(declare AgentAction'init AgentAction'new AgentAction''execute AgentAction'doRun)
(declare Agent'sendThreadPoolCounter Agent'sendOffThreadPoolCounter Agent'createThreadFactory Agent'nested Agent'shutdown Agent'init Agent'new-1 Agent'new-2 Agent''setState Agent''getError Agent''setErrorMode Agent''getErrorMode Agent''setErrorHandler Agent''getErrorHandler Agent''restart Agent''dispatch Agent'dispatchAction Agent''enqueue Agent''getQueueCount Agent'releasePendingSends)
(declare AMapEntry'new AMapEntry''asVector)
(declare KeySeq'create KeySeq'createFromMap KeySeq'init KeySeq'new-2 KeySeq'new-3)
(declare ValSeq'create ValSeq'createFromMap ValSeq'init ValSeq'new-2 ValSeq'new-3)
(declare APersistentMap'init APersistentMap'new APersistentMap'mapEquals APersistentMap'mapHash APersistentMap'mapHasheq APersistentMap'MAKE_ENTRY APersistentMap'MAKE_KEY APersistentMap'MAKE_VAL APersistentMap''containsValue APersistentMap''keySet APersistentMap''values)
(declare APersistentSet'init APersistentSet'new APersistentSet'setEquals)
(declare VSeq'init VSeq'new-2 VSeq'new-3)
(declare RSeq'init RSeq'new-2 RSeq'new-3)
(declare SubVector'init SubVector'new)
(declare APersistentVector'init APersistentVector'new APersistentVector'doEquals APersistentVector'doEquiv)
(declare ARef'init ARef'new-0 ARef'new-1 ARef''validate-2 ARef''validate-3 ARef''notifyWatches)
(declare AReference'init AReference'new-0 AReference'new-1)
(declare ArityException'init ArityException'new-2 ArityException'new-3)
(declare ArrayChunk'init ArrayChunk'new-1 ArrayChunk'new-2 ArrayChunk'new-3)
(declare ArrayIter_int'new)
(declare ArrayIter_float'new)
(declare ArrayIter_double'new)
(declare ArrayIter_long'new)
(declare ArrayIter_byte'new)
(declare ArrayIter_char'new)
(declare ArrayIter_short'new)
(declare ArrayIter_boolean'new)
(declare ArrayIter'EMPTY_ITERATOR ArrayIter'create-0 ArrayIter'create-1 ArrayIter'createFromObject ArrayIter'new)
(declare ArraySeq_int'init ArraySeq_int'new)
(declare ArraySeq_float'init ArraySeq_float'new)
(declare ArraySeq_double'init ArraySeq_double'new)
(declare ArraySeq_long'init ArraySeq_long'new)
(declare ArraySeq_byte'init ArraySeq_byte'new)
(declare ArraySeq_char'init ArraySeq_char'new)
(declare ArraySeq_short'init ArraySeq_short'new)
(declare ArraySeq_boolean'init ArraySeq_boolean'new)
(declare ArraySeq'create-0 ArraySeq'create-1 ArraySeq'createFromObject ArraySeq'init ArraySeq'new-2 ArraySeq'new-3)
(declare ASeq'init ASeq'new-1 ASeq'new-0)
(declare Atom'init Atom'new-1 Atom'new-2)
(declare ATransientMap'new ATransientMap''conj ATransientMap'NOT_FOUND)
(declare ATransientSet'init ATransientSet'new)
(declare BigInt'init BigInt'new BigInt'fromBigInteger BigInt'fromLong BigInt''toBigInteger BigInt''toBigDecimal BigInt''intValue BigInt''longValue BigInt''floatValue BigInt''doubleValue BigInt''byteValue BigInt''shortValue BigInt'valueOf BigInt''bitLength BigInt''add BigInt''multiply BigInt''quotient BigInt''remainder BigInt''lt)
(declare Binding'init Binding'new-1 Binding'new-2)
(declare Box'init Box'new)
(declare ChunkBuffer'init ChunkBuffer'new ChunkBuffer''add ChunkBuffer''chunk)
(declare ChunkedCons'init ChunkedCons'new-3 ChunkedCons'new-2)
(declare UntypedExpr'new)
(declare DefParser'new)
(declare DefExpr'bindRootMethod DefExpr'setTagMethod DefExpr'setMetaMethod DefExpr'setDynamicMethod DefExpr'internVar DefExpr'init DefExpr'new DefExpr''includesExplicitMetadata)
(declare AssignParser'new)
(declare AssignExpr'init AssignExpr'new)
(declare VarExpr'getMethod VarExpr'setMethod VarExpr'init VarExpr'new)
(declare TheVarParser'new)
(declare TheVarExpr'init TheVarExpr'new)
(declare KeywordExpr'init KeywordExpr'new)
(declare ImportParser'new)
(declare ImportExpr'forNameMethod ImportExpr'importClassMethod ImportExpr'derefMethod ImportExpr'init ImportExpr'new)
(declare LiteralExpr'new)
(declare HostParser'new)
(declare HostExpr'new HostExpr'BOOLEAN_TYPE HostExpr'CHAR_TYPE HostExpr'INTEGER_TYPE HostExpr'LONG_TYPE HostExpr'FLOAT_TYPE HostExpr'DOUBLE_TYPE HostExpr'SHORT_TYPE HostExpr'BYTE_TYPE HostExpr'NUMBER_TYPE HostExpr'charValueMethod HostExpr'booleanValueMethod HostExpr'charValueOfMethod HostExpr'intValueOfMethod HostExpr'longValueOfMethod HostExpr'floatValueOfMethod HostExpr'doubleValueOfMethod HostExpr'shortValueOfMethod HostExpr'byteValueOfMethod HostExpr'intValueMethod HostExpr'longValueMethod HostExpr'floatValueMethod HostExpr'doubleValueMethod HostExpr'byteValueMethod HostExpr'shortValueMethod HostExpr'fromIntMethod HostExpr'fromLongMethod HostExpr'fromDoubleMethod HostExpr'emitBoxReturn HostExpr'emitUnboxArg HostExpr'maybeClass HostExpr'maybeSpecialTag HostExpr'tagToClass)
(declare FieldExpr'new)
(declare InstanceFieldExpr'invokeNoArgInstanceMember InstanceFieldExpr'setInstanceFieldMethod InstanceFieldExpr'init InstanceFieldExpr'new)
(declare StaticFieldExpr'init StaticFieldExpr'new)
(declare MethodExpr'new MethodExpr'emitArgsAsArray MethodExpr'emitTypedArgs)
(declare InstanceMethodExpr'invokeInstanceMethodMethod InstanceMethodExpr'init InstanceMethodExpr'new)
(declare StaticMethodExpr'forNameMethod StaticMethodExpr'invokeStaticMethodMethod StaticMethodExpr'init StaticMethodExpr'new StaticMethodExpr''canEmitIntrinsicPredicate StaticMethodExpr''emitIntrinsicPredicate)
(declare UnresolvedVarExpr'init UnresolvedVarExpr'new)
(declare NumberExpr'init NumberExpr'new NumberExpr'parse)
(declare ConstantParser'new)
(declare ConstantExpr'init ConstantExpr'new)
(declare NilExpr'new)
(declare BooleanExpr'init BooleanExpr'new)
(declare StringExpr'init StringExpr'new)
(declare MonitorEnterParser'new)
(declare MonitorEnterExpr'init MonitorEnterExpr'new)
(declare MonitorExitParser'new)
(declare MonitorExitExpr'init MonitorExitExpr'new)
(declare CatchClause'init CatchClause'new)
(declare TryParser'new)
(declare TryExpr'init TryExpr'new)
(declare ThrowParser'new)
(declare ThrowExpr'init ThrowExpr'new)
(declare NewParser'new)
(declare NewExpr'invokeConstructorMethod NewExpr'forNameMethod NewExpr'init NewExpr'new)
(declare MetaExpr'IOBJ_TYPE MetaExpr'withMetaMethod MetaExpr'init MetaExpr'new)
(declare IfParser'new)
(declare IfExpr'init IfExpr'new IfExpr''doEmit)
(declare EmptyExpr'HASHMAP_TYPE EmptyExpr'HASHSET_TYPE EmptyExpr'VECTOR_TYPE EmptyExpr'IVECTOR_TYPE EmptyExpr'TUPLE_TYPE EmptyExpr'LIST_TYPE EmptyExpr'EMPTY_LIST_TYPE EmptyExpr'init EmptyExpr'new)
(declare ListExpr'arrayToListMethod ListExpr'init ListExpr'new)
(declare MapExpr'mapMethod MapExpr'mapUniqueKeysMethod MapExpr'init MapExpr'new MapExpr'parse)
(declare SetExpr'setMethod SetExpr'init SetExpr'new SetExpr'parse)
(declare VectorExpr'vectorMethod VectorExpr'init VectorExpr'new VectorExpr'parse)
(declare KeywordInvokeExpr'ILOOKUP_TYPE KeywordInvokeExpr'init KeywordInvokeExpr'new)
(declare InstanceOfExpr'init InstanceOfExpr'new)
(declare StaticInvokeExpr'init StaticInvokeExpr'new StaticInvokeExpr'parse)
(declare InvokeExpr'init InvokeExpr'new InvokeExpr''emitProto InvokeExpr''emitArgsAndCall InvokeExpr'parse)
(declare FnExpr'aFnType FnExpr'restFnType FnExpr'init FnExpr'new FnExpr'parse FnExpr''isVariadic FnExpr''emitForDefn)
(declare ObjExpr'CONST_PREFIX ObjExpr'voidctor ObjExpr'DYNAMIC_CLASSLOADER_TYPE ObjExpr'getClassMethod ObjExpr'getClassLoaderMethod ObjExpr'getConstantsMethod ObjExpr'readStringMethod ObjExpr'ILOOKUP_SITE_TYPE ObjExpr'ILOOKUP_THUNK_TYPE ObjExpr'KEYWORD_LOOKUPSITE_TYPE ObjExpr'init ObjExpr'new ObjExpr'trimGenID ObjExpr''ctorTypes ObjExpr''compile ObjExpr''emitKeywordCallsites ObjExpr''emitListAsObjectArray ObjExpr''emitValue ObjExpr''emitConstants ObjExpr''isMutable ObjExpr''isVolatile ObjExpr''isDeftype ObjExpr''emitClearCloses ObjExpr''getCompiledClass ObjExpr''emitLetFnInits ObjExpr''emitAssignLocal ObjExpr''emitLocal ObjExpr''emitUnboxedLocal ObjExpr''emitVar ObjExpr'varGetMethod ObjExpr'varGetRawMethod ObjExpr''emitVarValue ObjExpr''emitKeyword ObjExpr''emitConstant ObjExpr''constantName ObjExpr''siteName ObjExpr''siteNameStatic ObjExpr''thunkName ObjExpr''cachedClassName ObjExpr''cachedVarName ObjExpr''varCallsiteName ObjExpr''thunkNameStatic ObjExpr''constantType)
(declare PathNode'init PathNode'new)
(declare FnMethod'init FnMethod'new FnMethod'classChar FnMethod'primInterface FnMethod'parse FnMethod''doEmitStatic FnMethod''doEmitPrim FnMethod''doEmit FnMethod''isVariadic)
(declare ObjMethod'init ObjMethod'new ObjMethod'emitBody ObjMethod''emitClearLocals ObjMethod''emitClearLocalsOld ObjMethod''emitClearThis)
(declare LocalBinding'init LocalBinding'new LocalBinding''getPrimitiveType)
(declare LocalBindingExpr'init LocalBindingExpr'new)
(declare BodyParser'new)
(declare BodyExpr'init BodyExpr'new BodyExpr''lastExpr)
(declare BindingInit'init BindingInit'new)
(declare LetFnParser'new)
(declare LetFnExpr'init LetFnExpr'new)
(declare LetParser'new)
(declare LetExpr'init LetExpr'new LetExpr''doEmit)
(declare RecurParser'new)
(declare RecurExpr'init RecurExpr'new)
(declare CompilerException'init CompilerException'new)
(declare DeftypeParser'new)
(declare ReifyParser'new)
(declare NewInstanceExpr'init NewInstanceExpr'new NewInstanceExpr'build NewInstanceExpr'compileStub NewInstanceExpr'interfaceNames NewInstanceExpr'slashname NewInstanceExpr'msig NewInstanceExpr'considerMethod NewInstanceExpr'gatherMethods-2m NewInstanceExpr'gatherMethods-2s)
(declare NewInstanceMethod'init NewInstanceMethod'new NewInstanceMethod'msig NewInstanceMethod'parse NewInstanceMethod'findMethodsWithNameAndArity NewInstanceMethod'findMethodsWithName)
(declare MethodParamExpr'init MethodParamExpr'new)
(declare CaseParser'new)
(declare CaseExpr'NUMBER_TYPE CaseExpr'intValueMethod CaseExpr'hashMethod CaseExpr'hashCodeMethod CaseExpr'equivMethod CaseExpr'init CaseExpr'new CaseExpr''doEmit CaseExpr''isShiftMasked CaseExpr''emitShiftMask CaseExpr''emitExprForInts CaseExpr''emitThenForInts CaseExpr''emitExprForHashes CaseExpr''emitThenForHashes CaseExpr'emitExpr)
(declare Compiler'COMPILE_STUB_PREFIX Compiler'MAX_POSITIONAL_ARITY Compiler'CLASS_TYPE Compiler'OBJECT_TYPE Compiler'BOOLEAN_OBJECT_TYPE Compiler'THROWABLE_TYPE Compiler'KEYWORD_TYPE Compiler'VAR_TYPE Compiler'SYMBOL_TYPE Compiler'IFN_TYPE Compiler'AFUNCTION_TYPE Compiler'RT_TYPE Compiler'NUMBERS_TYPE Compiler'NS_TYPE Compiler'UTIL_TYPE Compiler'REFLECTOR_TYPE Compiler'IPERSISTENTMAP_TYPE Compiler'IOBJ_TYPE Compiler'TUPLE_TYPE Compiler'createTupleMethods Compiler'ARG_TYPES Compiler'EXCEPTION_TYPES Compiler'lineDeref Compiler'columnDeref Compiler'isSpecial Compiler'inTailCall Compiler'resolveSymbol Compiler'maybePrimitiveType Compiler'maybeJavaClass Compiler'subsumes Compiler'getTypeStringForArgs Compiler'getMatchingParams Compiler'DEMUNGE_MAP Compiler'DEMUNGE_PATTERN Compiler'munge Compiler'demunge Compiler'clearPathRoot Compiler'registerLocal Compiler'getAndIncLocalNum Compiler'analyze-2 Compiler'analyze-3 Compiler'isMacro Compiler'isInline Compiler'namesStaticMember Compiler'preserveTag Compiler'MACRO_CHECK Compiler'MACRO_CHECK_LOADING Compiler'MACRO_CHECK_LOCK Compiler'ensureMacroCheck Compiler'checkSpecs Compiler'macroexpand1 Compiler'macroexpand Compiler'analyzeSeq Compiler'eval-1 Compiler'eval-2 Compiler'registerConstant Compiler'registerKeyword Compiler'registerKeywordCallsite Compiler'registerProtocolCallsite Compiler'registerVarCallsite Compiler'fwdPath Compiler'commonPath Compiler'analyzeSymbol Compiler'destubClassName Compiler'getType Compiler'resolve-2 Compiler'resolve-1 Compiler'namespaceFor-1 Compiler'namespaceFor-2 Compiler'resolveIn Compiler'maybeResolveIn Compiler'lookupVar-3 Compiler'lookupVar-2 Compiler'registerVar Compiler'currentNS Compiler'closeOver Compiler'referenceLocal Compiler'tagOf Compiler'consumeWhitespaces Compiler'load Compiler'pushNS Compiler'pushNSandLoader Compiler'getLookupThunk Compiler'inty Compiler'retType Compiler'primClass-1s Compiler'tagClass Compiler'primClass-1c Compiler'boxClass Compiler'emptyVarCallSites)
(declare Cons'init Cons'new-2 Cons'new-3)
(declare Cycle'init Cycle'new-3 Cycle'new-5 Cycle'create Cycle''current)
(declare Delay'init Delay'new Delay'force)
(declare DynamicClassLoader'classCache DynamicClassLoader'RQ DynamicClassLoader'init DynamicClassLoader'new DynamicClassLoader'findInMemoryClass DynamicClassLoader''registerConstants DynamicClassLoader''getConstants)
(declare ExceptionInfo'init ExceptionInfo'new-2 ExceptionInfo'new-3)
(declare Intrinsics'oa)
(declare Iterate'UNREALIZED_SEED Iterate'init Iterate'new-3 Iterate'new-5 Iterate'create)
(declare IteratorSeqState'init IteratorSeqState'new)
(declare IteratorSeq'create IteratorSeq'init IteratorSeq'new-1 IteratorSeq'new-3)
(declare Keyword'TABLE Keyword'RQ Keyword'intern Keyword'init Keyword'new Keyword'find Keyword'find-2 Keyword'find-1 Keyword''throwArity)
(declare KeywordLookupSite'init KeywordLookupSite'new KeywordLookupSite''ilookupThunk KeywordLookupSite''install)
(declare LazilyPersistentVector'createOwning LazilyPersistentVector'fcount LazilyPersistentVector'create)
(declare LazySeq'init LazySeq'new-1 LazySeq'new-2 LazySeq''sval)
(declare LineNumberingPushbackReader'newline LineNumberingPushbackReader'init LineNumberingPushbackReader'new-1 LineNumberingPushbackReader'new-2 LineNumberingPushbackReader''getLineNumber LineNumberingPushbackReader''setLineNumber LineNumberingPushbackReader''getColumnNumber LineNumberingPushbackReader''readLine LineNumberingPushbackReader''atLineStart)
(declare LispReaderException'init LispReaderException'new)
(declare RegexReader'new)
(declare StringReader'new)
(declare CommentReader'new)
(declare DiscardReader'new)
(declare NamespaceMapReader'new)
(declare SymbolicValueReader'new)
(declare WrappingReader'new)
(declare VarReader'new)
(declare DispatchReader'new)
(declare FnReader'new)
(declare ArgReader'new)
(declare MetaReader'new)
(declare SyntaxQuoteReader'new SyntaxQuoteReader'syntaxQuote SyntaxQuoteReader'sqExpandList SyntaxQuoteReader'flattenMap)
(declare UnquoteReader'new)
(declare CharacterReader'new)
(declare ListReader'new)
(declare VectorReader'new)
(declare MapReader'new)
(declare SetReader'new)
(declare UnmatchedDelimiterReader'new)
(declare LispReader'macros LispReader'dispatchMacros LispReader'symbolPat LispReader'intPat LispReader'ratioPat LispReader'floatPat LispReader'isWhitespace LispReader'unread LispReader'read1 LispReader'read-1 LispReader'read-4 LispReader'read-5 LispReader'ensurePending LispReader'read-7 LispReader'readToken LispReader'readNumber LispReader'readUnicodeChar-4 LispReader'readUnicodeChar-5 LispReader'interpretToken LispReader'matchSymbol LispReader'matchNumber LispReader'getMacro LispReader'isMacro LispReader'isTerminatingMacro LispReader'garg LispReader'registerArg LispReader'isUnquoteSplicing LispReader'isUnquote LispReader'READ_EOF LispReader'READ_FINISHED LispReader'readDelimitedList)
(declare RetryEx'new)
(declare AbortException'new)
(declare LockingTransactionInfo'init LockingTransactionInfo'new LockingTransactionInfo''running)
(declare CFn'init CFn'new)
(declare Notify'init Notify'new)
(declare LockingTransaction'RETRY_LIMIT LockingTransaction'LOCK_WAIT_MSECS LockingTransaction'BARGE_WAIT_NANOS LockingTransaction'RUNNING LockingTransaction'COMMITTING LockingTransaction'RETRY LockingTransaction'KILLED LockingTransaction'COMMITTED LockingTransaction'transaction LockingTransaction'lastPoint LockingTransaction'init LockingTransaction'new LockingTransaction''getReadPoint LockingTransaction''getCommitPoint LockingTransaction''stop LockingTransaction''tryWriteLock LockingTransaction''lock LockingTransaction''blockAndBail LockingTransaction''releaseIfEnsured LockingTransaction''abort LockingTransaction''bargeTimeElapsed LockingTransaction''barge LockingTransaction'getEx LockingTransaction'isRunning LockingTransaction'getRunning LockingTransaction'runInTransaction LockingTransaction''run LockingTransaction''enqueue LockingTransaction''doGet LockingTransaction''doSet LockingTransaction''doEnsure LockingTransaction''doCommute)
(declare LongChunk'init LongChunk'new LongChunk''first)
(declare LongRange'CHUNK_SIZE LongRange'positiveStep LongRange'negativeStep LongRange'init LongRange'new-4 LongRange'new-6 LongRange'new-7 LongRange'create-1 LongRange'create-2 LongRange'create-3 LongRange''forceChunk LongRange''steppingCount LongRange''rangeCount)
(declare MapEntry'create MapEntry'init MapEntry'new)
(declare Entry'init Entry'new)
(declare MethodImplCache'init MethodImplCache'new-2 MethodImplCache'new-5 MethodImplCache'new-3 MethodImplCache''fnFor MethodImplCache''findFnFor)
(declare MultiFn'init MultiFn'new MultiFn''reset MultiFn''addMethod MultiFn''removeMethod MultiFn''preferMethod MultiFn''prefers MultiFn''isA MultiFn''dominates MultiFn''resetCache MultiFn''getMethod MultiFn''getFn MultiFn''findAndCacheBestMethod)
(declare Murmur3'seed Murmur3'C1 Murmur3'C2 Murmur3'hashInt Murmur3'hashLong Murmur3'hashUnencodedChars Murmur3'mixCollHash Murmur3'hashOrdered Murmur3'hashUnordered Murmur3'mixK1 Murmur3'mixH1 Murmur3'fmix)
(declare Namespace'namespaces Namespace'init Namespace'new Namespace'all Namespace''getName Namespace''getMappings Namespace''warnOrFailOnReplace Namespace''intern Namespace''referenceVar Namespace'areDifferentInstancesOfSameClassName Namespace''referenceClass Namespace''unmap Namespace''importClass-2 Namespace''importClass-3 Namespace''refer Namespace'findOrCreate Namespace'remove Namespace'find Namespace''getMapping Namespace''findInternedVar Namespace''getAliases Namespace''lookupAlias Namespace''addAlias Namespace''removeAlias)
(declare OpsP'new)
(declare LongOps'new LongOps'gcd)
(declare DoubleOps'new)
(declare RatioOps'new RatioOps'normalizeRet)
(declare BigIntOps'new)
(declare BigDecimalOps'new)
(declare Numbers'isZero-1o Numbers'isPos-1o Numbers'isNeg-1o Numbers'minus-1o Numbers'minusP-1o Numbers'inc-1o Numbers'incP-1o Numbers'dec-1o Numbers'decP-1o Numbers'add-2oo Numbers'addP-2oo Numbers'minus-2oo Numbers'minusP-2oo Numbers'multiply-2oo Numbers'multiplyP-2oo Numbers'divide-2oo Numbers'quotient-2oo Numbers'remainder-2oo Numbers'quotient-2dd Numbers'remainder-2dd Numbers'equiv-2oo Numbers'equiv-2nn Numbers'equal Numbers'lt-2oo Numbers'lte-2oo Numbers'gt-2oo Numbers'gte-2oo Numbers'compare Numbers'toBigInt Numbers'toBigInteger Numbers'toBigDecimal Numbers'toRatio Numbers'rationalize Numbers'reduceBigInt Numbers'divide-2ii Numbers'shiftLeftInt Numbers'shiftLeft-2oo Numbers'shiftLeft-2ol Numbers'shiftLeft-2lo Numbers'shiftLeft-2ll Numbers'shiftRightInt Numbers'shiftRight-2oo Numbers'shiftRight-2ol Numbers'shiftRight-2lo Numbers'shiftRight-2ll Numbers'unsignedShiftRightInt Numbers'unsignedShiftRight-2oo Numbers'unsignedShiftRight-2ol Numbers'unsignedShiftRight-2lo Numbers'unsignedShiftRight-2ll Numbers'ops Numbers'hasheqFrom Numbers'hasheq Numbers'category Numbers'bitOpsCast Numbers'float_array-2 Numbers'float_array-1 Numbers'double_array-2 Numbers'double_array-1 Numbers'int_array-2 Numbers'int_array-1 Numbers'long_array-2 Numbers'long_array-1 Numbers'short_array-2 Numbers'short_array-1 Numbers'char_array-2 Numbers'char_array-1 Numbers'byte_array-2 Numbers'byte_array-1 Numbers'boolean_array-2 Numbers'boolean_array-1 Numbers'booleans Numbers'bytes Numbers'chars Numbers'shorts Numbers'floats Numbers'doubles Numbers'ints Numbers'longs Numbers'num-1o Numbers'num-1f Numbers'num-1d Numbers'add-2dd Numbers'addP-2dd Numbers'minus-2dd Numbers'minusP-2dd Numbers'minus-1d Numbers'minusP-1d Numbers'inc-1d Numbers'incP-1d Numbers'dec-1d Numbers'decP-1d Numbers'multiply-2dd Numbers'multiplyP-2dd Numbers'divide-2dd Numbers'equiv-2dd Numbers'lt-2dd Numbers'lte-2dd Numbers'gt-2dd Numbers'gte-2dd Numbers'isPos-1d Numbers'isNeg-1d Numbers'isZero-1d Numbers'throwIntOverflow Numbers'unchecked_int_add Numbers'unchecked_int_subtract Numbers'unchecked_int_negate Numbers'unchecked_int_inc Numbers'unchecked_int_dec Numbers'unchecked_int_multiply Numbers'not-1o Numbers'not-1l Numbers'and-2oo Numbers'and-2ol Numbers'and-2lo Numbers'and-2ll Numbers'or-2oo Numbers'or-2ol Numbers'or-2lo Numbers'or-2ll Numbers'xor-2oo Numbers'xor-2ol Numbers'xor-2lo Numbers'xor-2ll Numbers'andNot-2oo Numbers'andNot-2ol Numbers'andNot-2lo Numbers'andNot-2ll Numbers'clearBit-2oo Numbers'clearBit-2ol Numbers'clearBit-2lo Numbers'clearBit-2ll Numbers'setBit-2oo Numbers'setBit-2ol Numbers'setBit-2lo Numbers'setBit-2ll Numbers'flipBit-2oo Numbers'flipBit-2ol Numbers'flipBit-2lo Numbers'flipBit-2ll Numbers'testBit-2oo Numbers'testBit-2ol Numbers'testBit-2lo Numbers'testBit-2ll Numbers'unchecked_int_divide Numbers'unchecked_int_remainder Numbers'num-1l Numbers'unchecked_add-2ll Numbers'unchecked_minus-2ll Numbers'unchecked_multiply-2ll Numbers'unchecked_minus-1l Numbers'unchecked_inc-1l Numbers'unchecked_dec-1l Numbers'unchecked_add-2oo Numbers'unchecked_minus-2oo Numbers'unchecked_multiply-2oo Numbers'unchecked_minus-1o Numbers'unchecked_inc-1o Numbers'unchecked_dec-1o Numbers'unchecked_add-2dd Numbers'unchecked_minus-2dd Numbers'unchecked_multiply-2dd Numbers'unchecked_minus-1d Numbers'unchecked_inc-1d Numbers'unchecked_dec-1d Numbers'unchecked_add-2do Numbers'unchecked_minus-2do Numbers'unchecked_multiply-2do Numbers'unchecked_add-2od Numbers'unchecked_minus-2od Numbers'unchecked_multiply-2od Numbers'unchecked_add-2dl Numbers'unchecked_minus-2dl Numbers'unchecked_multiply-2dl Numbers'unchecked_add-2ld Numbers'unchecked_minus-2ld Numbers'unchecked_multiply-2ld Numbers'unchecked_add-2lo Numbers'unchecked_minus-2lo Numbers'unchecked_multiply-2lo Numbers'unchecked_add-2ol Numbers'unchecked_minus-2ol Numbers'unchecked_multiply-2ol Numbers'quotient-2do Numbers'quotient-2od Numbers'quotient-2lo Numbers'quotient-2ol Numbers'quotient-2dl Numbers'quotient-2ld Numbers'remainder-2do Numbers'remainder-2od Numbers'remainder-2lo Numbers'remainder-2ol Numbers'remainder-2dl Numbers'remainder-2ld Numbers'add-2ll Numbers'addP-2ll Numbers'minus-2ll Numbers'minusP-2ll Numbers'minus-1l Numbers'minusP-1l Numbers'inc-1l Numbers'dec-1l Numbers'incP-1l Numbers'decP-1l Numbers'multiply-2ll Numbers'multiplyP-2ll Numbers'quotient-2ll Numbers'remainder-2ll Numbers'equiv-2ll Numbers'lt-2ll Numbers'lte-2ll Numbers'gt-2ll Numbers'gte-2ll Numbers'isPos-1l Numbers'isNeg-1l Numbers'isZero-1l Numbers'add-2lo Numbers'add-2ol Numbers'addP-2lo Numbers'addP-2ol Numbers'add-2do Numbers'add-2od Numbers'add-2dl Numbers'add-2ld Numbers'addP-2do Numbers'addP-2od Numbers'addP-2dl Numbers'addP-2ld Numbers'minus-2lo Numbers'minus-2ol Numbers'minusP-2lo Numbers'minusP-2ol Numbers'minus-2do Numbers'minus-2od Numbers'minus-2dl Numbers'minus-2ld Numbers'minusP-2do Numbers'minusP-2od Numbers'minusP-2dl Numbers'minusP-2ld Numbers'multiply-2lo Numbers'multiply-2ol Numbers'multiplyP-2lo Numbers'multiplyP-2ol Numbers'multiply-2do Numbers'multiply-2od Numbers'multiply-2dl Numbers'multiply-2ld Numbers'multiplyP-2do Numbers'multiplyP-2od Numbers'multiplyP-2dl Numbers'multiplyP-2ld Numbers'divide-2lo Numbers'divide-2ol Numbers'divide-2do Numbers'divide-2od Numbers'divide-2dl Numbers'divide-2ld Numbers'divide-2ll Numbers'lt-2lo Numbers'lt-2ol Numbers'lt-2do Numbers'lt-2od Numbers'lt-2dl Numbers'lt-2ld Numbers'lte-2lo Numbers'lte-2ol Numbers'lte-2do Numbers'lte-2od Numbers'lte-2dl Numbers'lte-2ld Numbers'gt-2lo Numbers'gt-2ol Numbers'gt-2do Numbers'gt-2od Numbers'gt-2dl Numbers'gt-2ld Numbers'gte-2lo Numbers'gte-2ol Numbers'gte-2do Numbers'gte-2od Numbers'gte-2dl Numbers'gte-2ld Numbers'equiv-2lo Numbers'equiv-2ol Numbers'equiv-2do Numbers'equiv-2od Numbers'equiv-2dl Numbers'equiv-2ld Numbers'isNaN Numbers'max-2ll Numbers'max-2dd Numbers'max-2ld Numbers'max-2dl Numbers'max-2lo Numbers'max-2ol Numbers'max-2do Numbers'max-2od Numbers'max-2oo Numbers'min-2ll Numbers'min-2dd Numbers'min-2ld Numbers'min-2dl Numbers'min-2lo Numbers'min-2ol Numbers'min-2do Numbers'min-2od Numbers'min-2oo)
(declare MSeq'init MSeq'new-2 MSeq'new-3)
(declare MIter'new)
(declare TransientArrayMap'init TransientArrayMap'new TransientArrayMap''indexOf)
(declare PersistentArrayMap'HASHTABLE_THRESHOLD PersistentArrayMap'create PersistentArrayMap'init PersistentArrayMap'new-0 PersistentArrayMap''create PersistentArrayMap''createHT PersistentArrayMap'createWithCheck PersistentArrayMap'createAsIfByAssoc PersistentArrayMap'new-1 PersistentArrayMap'new-2 PersistentArrayMap''capacity PersistentArrayMap''indexOfObject PersistentArrayMap''indexOf PersistentArrayMap'equalKey)
(declare TransientHashMap'init TransientHashMap'new-1 TransientHashMap'new-5)
(declare HSeq'create-1 HSeq'create-4 HSeq'init HSeq'new)
(declare HIter'new)
(declare ArrayNode'init ArrayNode'new ArrayNode'foldTasks ArrayNode''ensureEditable ArrayNode''editAndSet ArrayNode''pack)
(declare BitmapIndexedNode'init BitmapIndexedNode'new BitmapIndexedNode''index BitmapIndexedNode''ensureEditable BitmapIndexedNode''editAndSet-4 BitmapIndexedNode''editAndSet-6 BitmapIndexedNode''editAndRemovePair)
(declare HashCollisionNode'init HashCollisionNode'new HashCollisionNode''findIndex HashCollisionNode''ensureEditable-2 HashCollisionNode''ensureEditable-4 HashCollisionNode''editAndSet-4 HashCollisionNode''editAndSet-6)
(declare NodeIter'new)
(declare NodeSeq'init NodeSeq'new-2 NodeSeq'create-1 NodeSeq'kvreduce NodeSeq'create-3 NodeSeq'new-4)
(declare PersistentHashMap'NOT_FOUND PersistentHashMap'create-1m PersistentHashMap'create-1a PersistentHashMap'createWithCheck-1a PersistentHashMap'create-1s PersistentHashMap'createWithCheck-1s PersistentHashMap'create-2 PersistentHashMap'init PersistentHashMap'new-4 PersistentHashMap'new-5 PersistentHashMap'hash PersistentHashMap'EMPTY_ITER PersistentHashMap''iterator PersistentHashMap''fold PersistentHashMap'mask PersistentHashMap'cloneAndSet-3 PersistentHashMap'cloneAndSet-5 PersistentHashMap'removePair PersistentHashMap'createNode-6 PersistentHashMap'createNode-7 PersistentHashMap'bitpos)
(declare TransientHashSet'new)
(declare PersistentHashSet'create-1a PersistentHashSet'create-1l PersistentHashSet'create-1s PersistentHashSet'createWithCheck-1a PersistentHashSet'createWithCheck-1l PersistentHashSet'createWithCheck-1s PersistentHashSet'init PersistentHashSet'new)
(declare Primordial'new Primordial'invokeStatic)
(declare EmptyList'new EmptyList'hasheq)
(declare PersistentList'init PersistentList'new-1 PersistentList'new-4 PersistentList'create)
(declare QSeq'init QSeq'new-2 QSeq'new-3)
(declare PersistentQueue'init PersistentQueue'new)
(declare TNode'init TNode'new)
(declare Black'new)
(declare BlackVal'init BlackVal'new)
(declare BlackBranch'init BlackBranch'new)
(declare BlackBranchVal'init BlackBranchVal'new)
(declare Red'new)
(declare RedVal'init RedVal'new)
(declare RedBranch'init RedBranch'new)
(declare RedBranchVal'init RedBranchVal'new)
(declare TSeq'init TSeq'new-2 TSeq'new-3 TSeq'new-4 TSeq'create TSeq'push)
(declare NodeIterator'new)
(declare PersistentTreeMap'create-1m PersistentTreeMap'init PersistentTreeMap'new-0 PersistentTreeMap'new-1 PersistentTreeMap'new-2 PersistentTreeMap'new-4m PersistentTreeMap'create-1s PersistentTreeMap'create-2 PersistentTreeMap''reverseIterator PersistentTreeMap''keys PersistentTreeMap''vals PersistentTreeMap''minKey PersistentTreeMap''min PersistentTreeMap''maxKey PersistentTreeMap''max PersistentTreeMap''depth-1 PersistentTreeMap''depth-2 PersistentTreeMap''capacity PersistentTreeMap''doCompare PersistentTreeMap''add PersistentTreeMap''remove PersistentTreeMap'append PersistentTreeMap'balanceLeftDel PersistentTreeMap'balanceRightDel PersistentTreeMap'leftBalance PersistentTreeMap'rightBalance PersistentTreeMap''replace PersistentTreeMap'new-4c PersistentTreeMap'red PersistentTreeMap'black)
(declare PersistentTreeSet'create-1 PersistentTreeSet'create-2 PersistentTreeSet'init PersistentTreeSet'new)
(declare VNode'init VNode'new-2 VNode'new-1)
(declare ChunkedSeq'init ChunkedSeq'new-3 ChunkedSeq'new-5 ChunkedSeq'new-4)
(declare TransientVector'init TransientVector'new-4 TransientVector'new-1 TransientVector''ensureEditable-1 TransientVector''ensureEditable-2 TransientVector'editableRoot TransientVector'editableTail TransientVector''pushTail TransientVector''tailoff TransientVector''arrayFor TransientVector''editableArrayFor TransientVector'NOT_FOUND TransientVector''doAssoc TransientVector''popTail)
(declare PersistentVector'NOEDIT PersistentVector'EMPTY_NODE PersistentVector'TRANSIENT_VECTOR_CONJ PersistentVector'adopt PersistentVector'create-1r PersistentVector'create-1s PersistentVector'create-1l PersistentVector'create-1i PersistentVector'create-1a PersistentVector'init PersistentVector'new-4 PersistentVector'new-5 PersistentVector''tailoff PersistentVector''arrayFor PersistentVector'doAssoc PersistentVector''pushTail PersistentVector'newPath PersistentVector''chunkedSeq PersistentVector''popTail)
(declare ProxyHandler'init ProxyHandler'new)
(declare Range'CHUNK_SIZE Range'positiveStep Range'negativeStep Range'init Range'new-4 Range'new-6 Range'new-7 Range'create-1 Range'create-2 Range'create-3 Range''forceChunk)
(declare Ratio'init Ratio'new Ratio''intValue Ratio''longValue Ratio''floatValue Ratio''doubleValue Ratio''decimalValue-1 Ratio''decimalValue-2 Ratio''bigIntegerValue)
(declare Reduced'init Reduced'new)
(declare RefTVal'init RefTVal'new-3 RefTVal'new-2)
(declare Ref'ids Ref'init Ref'new-1 Ref'new-2 Ref''getMinHistory Ref''setMinHistory Ref''getMaxHistory Ref''setMaxHistory Ref''currentVal Ref''set Ref''commute Ref''alter Ref''touch Ref''isBound Ref''trimHistory Ref''getHistoryCount Ref''histCount Ref''fn)
(declare Reflector'invokeInstanceMethod Reflector'getCauseOrElse Reflector'noMethodReport Reflector'invokeMatchingMethod Reflector'getAsMethodOfPublicBase Reflector'isMatch Reflector'invokeConstructor Reflector'invokeStaticMethodVariadic Reflector'invokeStaticMethod-3s Reflector'invokeStaticMethod-3c Reflector'getStaticField-2s Reflector'getStaticField-2c Reflector'setStaticField-3s Reflector'setStaticField-3c Reflector'getInstanceField Reflector'setInstanceField Reflector'invokeNoArgInstanceMember Reflector'invokeInstanceMember-2 Reflector'invokeInstanceMember-3o Reflector'invokeInstanceMember-3a Reflector'getField Reflector'getMethods Reflector'boxArg Reflector'boxArgs Reflector'paramArgTypeMatch Reflector'isCongruent Reflector'prepRet)
(declare Repeat'INFINITE Repeat'init Repeat'new-2 Repeat'new-3 Repeat'create-1 Repeat'create-2)
(declare RestFn'new RestFn'ontoArrayPrepend RestFn'findKey)
(declare RT'BOOLEANS_CLASS RT'BYTES_CLASS RT'SHORTS_CLASS RT'CHARS_CLASS RT'INTS_CLASS RT'LONGS_CLASS RT'FLOATS_CLASS RT'DOUBLES_CLASS RT'OBJECTS_CLASS)
(declare RT'T RT'F RT'LOADER_SUFFIX RT'UTF8 RT'inNamespace RT'bootNamespace RT'errPrintWriter RT'EMPTY_ARRAY RT'ID RT'CHECK_SPEC_ASSERTS RT'INSTRUMENT_MACROS RT'CHECK_SPECS RT'keyword RT'var RT'loadResourceScript RT'lastModified RT'load-1 RT'load-2 RT'nextID RT'CHUNK_SIZE RT'chunkIteratorSeq RT'seq RT'seqFrom RT'canSeq RT'iter RT'seqOrElse RT'keys RT'vals RT'meta RT'count RT'conj RT'cons RT'first RT'second RT'third RT'fourth RT'next RT'more RT'peek RT'pop RT'get-2 RT'getFrom-2 RT'get-3 RT'getFrom-3 RT'assoc RT'contains RT'find RT'findKey RT'dissoc RT'nth-2 RT'nth-3 RT'assocN RT'hasTag RT'box-1o RT'box-1c RT'box-1z RT'box-1Z RT'box-1b RT'box-1s RT'box-1i RT'box-1l RT'box-1f RT'box-1d RT'charCast-1o RT'charCast-1b RT'charCast-1s RT'charCast-1c RT'charCast-1i RT'charCast-1l RT'charCast-1f RT'charCast-1d RT'booleanCast-1o RT'booleanCast-1b RT'byteCast-1o RT'byteCast-1b RT'byteCast-1s RT'byteCast-1i RT'byteCast-1l RT'byteCast-1f RT'byteCast-1d RT'shortCast-1o RT'shortCast-1b RT'shortCast-1s RT'shortCast-1i RT'shortCast-1l RT'shortCast-1f RT'shortCast-1d RT'intCast-1o RT'intCast-1b RT'intCast-1s RT'intCast-1c RT'intCast-1i RT'intCast-1l RT'intCast-1f RT'intCast-1d RT'longCast-1o RT'longCast-1b RT'longCast-1s RT'longCast-1i RT'longCast-1l RT'longCast-1f RT'longCast-1d RT'floatCast-1o RT'floatCast-1b RT'floatCast-1s RT'floatCast-1i RT'floatCast-1l RT'floatCast-1f RT'floatCast-1d RT'doubleCast-1o RT'doubleCast-1b RT'doubleCast-1s RT'doubleCast-1i RT'doubleCast-1l RT'doubleCast-1f RT'doubleCast-1d RT'uncheckedByteCast-1o RT'uncheckedByteCast-1b RT'uncheckedByteCast-1s RT'uncheckedByteCast-1i RT'uncheckedByteCast-1l RT'uncheckedByteCast-1f RT'uncheckedByteCast-1d RT'uncheckedShortCast-1o RT'uncheckedShortCast-1b RT'uncheckedShortCast-1s RT'uncheckedShortCast-1i RT'uncheckedShortCast-1l RT'uncheckedShortCast-1f RT'uncheckedShortCast-1d RT'uncheckedCharCast-1o RT'uncheckedCharCast-1b RT'uncheckedCharCast-1s RT'uncheckedCharCast-1c RT'uncheckedCharCast-1i RT'uncheckedCharCast-1l RT'uncheckedCharCast-1f RT'uncheckedCharCast-1d RT'uncheckedIntCast-1o RT'uncheckedIntCast-1b RT'uncheckedIntCast-1s RT'uncheckedIntCast-1c RT'uncheckedIntCast-1i RT'uncheckedIntCast-1l RT'uncheckedIntCast-1f RT'uncheckedIntCast-1d RT'uncheckedLongCast-1o RT'uncheckedLongCast-1b RT'uncheckedLongCast-1s RT'uncheckedLongCast-1i RT'uncheckedLongCast-1l RT'uncheckedLongCast-1f RT'uncheckedLongCast-1d RT'uncheckedFloatCast-1o RT'uncheckedFloatCast-1b RT'uncheckedFloatCast-1s RT'uncheckedFloatCast-1i RT'uncheckedFloatCast-1l RT'uncheckedFloatCast-1f RT'uncheckedFloatCast-1d RT'uncheckedDoubleCast-1o RT'uncheckedDoubleCast-1b RT'uncheckedDoubleCast-1s RT'uncheckedDoubleCast-1i RT'uncheckedDoubleCast-1l RT'uncheckedDoubleCast-1f RT'uncheckedDoubleCast-1d RT'map RT'mapUniqueKeys RT'set RT'vector RT'subvec RT'list-0 RT'list-1 RT'list-2 RT'list-3 RT'list-4 RT'list-5 RT'listStar-2 RT'listStar-3 RT'listStar-4 RT'listStar-5 RT'listStar-6 RT'arrayToList RT'object_array RT'toArray RT'seqToArray RT'seqToPassedArray RT'seqToTypedArray-1 RT'seqToTypedArray-2 RT'length RT'boundedLength RT'readRet RT'readChar RT'peekChar RT'getLineNumber RT'getColumnNumber RT'getLineNumberingReader RT'isLineNumberingReader RT'isReduced RT'printString RT'readString RT'print RT'printInnerSeq RT'makeClassLoader RT'baseLoader RT'resourceAsStream RT'getResource RT'classForName-3 RT'classForName-1 RT'classForNameNonLoading RT'loadClassForName RT'aget_boolean RT'aget_byte RT'aget_short RT'aget_char RT'aget_int RT'aget_long RT'aget_float RT'aget_double RT'aget_object RT'aset_boolean RT'aset_byte RT'aset_short RT'aset_char RT'aset_int RT'aset_long RT'aset_float RT'aset_double RT'aset_object RT'alength_boolean RT'alength_byte RT'alength_short RT'alength_char RT'alength_int RT'alength_long RT'alength_float RT'alength_double RT'alength_object RT'aclone_boolean RT'aclone_byte RT'aclone_short RT'aclone_char RT'aclone_int RT'aclone_long RT'aclone_float RT'aclone_double RT'aclone_object)
(declare SeqIterator'new)
(declare StringSeq'create StringSeq'init StringSeq'new)
(declare Symbol'create-2 Symbol'create-1 Symbol'intern Symbol'init Symbol'new-2 Symbol'new-3)
(declare MultiIterator'new)
(declare TransformerIterator'NONE TransformerIterator'new TransformerIterator'create TransformerIterator'createMulti)
(declare Tuple'MAX_SIZE Tuple'create)
(declare Util'equiv-2oo Util'equivNull Util'equivEquals Util'equivNumber Util'equivColl Util'equivPred Util'equiv-2ll Util'equiv-2ol Util'equiv-2lo Util'equiv-2dd Util'equiv-2od Util'equiv-2do Util'equiv-2bb Util'equiv-2ob Util'equiv-2bo Util'equiv-2cc Util'pcequiv Util'equals Util'identical Util'classOf Util'compare Util'hash Util'hasheq Util'hashCombine Util'isPrimitive Util'isInteger Util'clearCache)
(declare TBox'init TBox'new)
(declare Unbound'init Unbound'new)
(declare Frame'init Frame'new)
(declare Var'dvals Var'rev Var'getThreadBindingFrame Var'resetThreadBindingFrame Var'intern Var'internPrivate Var'find Var'create Var'init Var'new Var''setDynamic-1 Var''setDynamic-2 Var''isDynamic Var''isBound Var''get Var''alter Var''set Var''setMeta Var''setMacro Var''isMacro Var''isPublic Var''getRawRoot Var''getTag Var''setTag Var''hasRoot Var''bindRoot Var''swapRoot Var''unbindRoot Var''commuteRoot Var''alterRoot Var'pushThreadBindings Var'popThreadBindings Var'getThreadBindings Var''getThreadBinding Var''fn)
(declare Volatile'init Volatile'new Volatile''reset)

(declare ActionQueue'EMPTY)
(declare Agent'CONTINUE Agent'FAIL Agent'pooledExecutor Agent'soloExecutor)
(declare BigInt'ZERO BigInt'ONE)
(declare ConstantParser'formKey)
(declare InvokeExpr'onKey InvokeExpr'methodMapKey)
(declare NewInstanceMethod'dummyThis)
(declare CaseExpr'compactKey CaseExpr'sparseKey CaseExpr'hashIdentityKey CaseExpr'hashEquivKey CaseExpr'intKey)
(declare Compiler'DEF Compiler'LOOP Compiler'RECUR Compiler'IF Compiler'LET Compiler'LETFN Compiler'DO Compiler'FN Compiler'FNONCE Compiler'QUOTE Compiler'THE_VAR Compiler'DOT Compiler'ASSIGN Compiler'TRY Compiler'CATCH Compiler'FINALLY Compiler'THROW Compiler'MONITOR_ENTER Compiler'MONITOR_EXIT Compiler'IMPORT Compiler'DEFTYPE Compiler'CASE Compiler'CLASS Compiler'NEW Compiler'THIS Compiler'REIFY Compiler'LIST Compiler'HASHMAP Compiler'VECTOR Compiler'IDENTITY Compiler'_AMP_ Compiler'ISEQ Compiler'loadNs Compiler'inlineKey Compiler'inlineAritiesKey Compiler'volatileKey Compiler'implementsKey Compiler'protocolKey Compiler'onKey Compiler'dynamicKey Compiler'redefKey Compiler'NS Compiler'IN_NS Compiler'specials Compiler'LOCAL_ENV Compiler'LOOP_LOCALS Compiler'LOOP_LABEL Compiler'CONSTANTS Compiler'CONSTANT_IDS Compiler'KEYWORD_CALLSITES Compiler'PROTOCOL_CALLSITES Compiler'VAR_CALLSITES Compiler'KEYWORDS Compiler'VARS Compiler'METHOD Compiler'IN_CATCH_FINALLY Compiler'METHOD_RETURN_CONTEXT Compiler'NO_RECUR Compiler'LOADER Compiler'INSTANCE Compiler'LINE Compiler'COLUMN Compiler'NEXT_LOCAL_NUM Compiler'RET_LOCAL_NUM Compiler'COMPILE_STUB_SYM Compiler'COMPILE_STUB_CLASS Compiler'CLEAR_PATH Compiler'CLEAR_ROOT Compiler'CLEAR_SITES Compiler'NIL_EXPR Compiler'TRUE_EXPR Compiler'FALSE_EXPR Compiler'CHAR_MAP)
(declare Intrinsics'ops Intrinsics'preds)
(declare SymbolicValueReader'specials)
(declare LispReader'QUOTE LispReader'THE_VAR LispReader'UNQUOTE LispReader'UNQUOTE_SPLICING LispReader'CONCAT LispReader'SEQ LispReader'LIST LispReader'APPLY LispReader'HASHMAP LispReader'HASHSET LispReader'VECTOR LispReader'WITH_META LispReader'META LispReader'DEREF LispReader'GENSYM_ENV LispReader'ARG_ENV LispReader'OPT_EOF LispReader'EOFTHROW)
(declare MultiFn'assoc MultiFn'dissoc MultiFn'isa MultiFn'parents)
(declare BigDecimalOps'MATH_CONTEXT)
(declare Numbers'LONG_OPS Numbers'DOUBLE_OPS Numbers'RATIO_OPS Numbers'BIGINT_OPS Numbers'BIGDECIMAL_OPS)
(declare PersistentArrayMap'EMPTY)
(declare BitmapIndexedNode'EMPTY)
(declare PersistentHashMap'EMPTY)
(declare PersistentHashSet'EMPTY)
(declare EmptyList'HASHEQ)
(declare PersistentList'creator PersistentList'EMPTY)
(declare PersistentQueue'EMPTY)
(declare PersistentTreeMap'EMPTY)
(declare PersistentTreeSet'EMPTY)
(declare PersistentVector'EMPTY)
(declare RT'DEFAULT_IMPORTS RT'CLOIURE_NS RT'IN RT'OUT RT'ERR RT'TAG_KEY RT'AGENT RT'ASSERT RT'MATH_CONTEXT RT'LINE_KEY RT'COLUMN_KEY RT'DECLARED_KEY RT'DOC_KEY RT'IN_NAMESPACE RT'NAMESPACE RT'IDENTICAL RT'CURRENT_NS RT'FLUSH_ON_NEWLINE RT'PRINT_READABLY RT'WARN_ON_REFLECTION RT'ALLOW_UNRESOLVED_VARS RT'IN_NS_VAR RT'NS_VAR RT'FN_LOADER_VAR RT'PRINT_INITIALIZED RT'PR_ON RT'DEFAULT_COMPARATOR)
(declare Frame'TOP)
(declare Var'privateKey Var'privateMeta Var'macroKey Var'nameKey Var'nsKey)
(declare main'CLOIURE_MAIN main'REQUIRE main'MAIN)

(defmacro interface! [name [& sups] & sigs]
    (let [tag- #(or (:tag (meta %)) Object)
          sig- (fn [[name [this & args]]] (vector name (vec (map tag- args)) (tag- name) (map meta args)))
          cname (with-meta (symbol (str (namespace-munge *ns*) "." name)) (meta name))]
        `(do
            (gen-interface :name ~cname :extends ~(vec (map resolve sups)) :methods ~(vec (map sig- sigs)))
            (import ~cname)
        )
    )
)
(defmacro class! [& _] `(interface! ~@_))

(java-ns cloiure.lang.IFn
    (interface! L []
        #_abstract
        (#_"long" invokePrim [#_"L" this])
    )

    (interface! D []
        #_abstract
        (#_"double" invokePrim [#_"D" this])
    )

    (interface! OL []
        #_abstract
        (#_"long" invokePrim [#_"OL" this, #_"Object" arg0])
    )

    (interface! OD []
        #_abstract
        (#_"double" invokePrim [#_"OD" this, #_"Object" arg0])
    )

    (interface! LO []
        #_abstract
        (#_"Object" invokePrim [#_"LO" this, #_"long" arg0])
    )

    (interface! LL []
        #_abstract
        (#_"long" invokePrim [#_"LL" this, #_"long" arg0])
    )

    (interface! LD []
        #_abstract
        (#_"double" invokePrim [#_"LD" this, #_"long" arg0])
    )

    (interface! DO []
        #_abstract
        (#_"Object" invokePrim [#_"DO" this, #_"double" arg0])
    )

    (interface! DL []
        #_abstract
        (#_"long" invokePrim [#_"DL" this, #_"double" arg0])
    )

    (interface! DD []
        #_abstract
        (#_"double" invokePrim [#_"DD" this, #_"double" arg0])
    )

    (interface! OOL []
        #_abstract
        (#_"long" invokePrim [#_"OOL" this, #_"Object" arg0, #_"Object" arg1])
    )

    (interface! OOD []
        #_abstract
        (#_"double" invokePrim [#_"OOD" this, #_"Object" arg0, #_"Object" arg1])
    )

    (interface! OLO []
        #_abstract
        (#_"Object" invokePrim [#_"OLO" this, #_"Object" arg0, #_"long" arg1])
    )

    (interface! OLL []
        #_abstract
        (#_"long" invokePrim [#_"OLL" this, #_"Object" arg0, #_"long" arg1])
    )

    (interface! OLD []
        #_abstract
        (#_"double" invokePrim [#_"OLD" this, #_"Object" arg0, #_"long" arg1])
    )

    (interface! ODO []
        #_abstract
        (#_"Object" invokePrim [#_"ODO" this, #_"Object" arg0, #_"double" arg1])
    )

    (interface! ODL []
        #_abstract
        (#_"long" invokePrim [#_"ODL" this, #_"Object" arg0, #_"double" arg1])
    )

    (interface! ODD []
        #_abstract
        (#_"double" invokePrim [#_"ODD" this, #_"Object" arg0, #_"double" arg1])
    )

    (interface! LOO []
        #_abstract
        (#_"Object" invokePrim [#_"LOO" this, #_"long" arg0, #_"Object" arg1])
    )

    (interface! LOL []
        #_abstract
        (#_"long" invokePrim [#_"LOL" this, #_"long" arg0, #_"Object" arg1])
    )

    (interface! LOD []
        #_abstract
        (#_"double" invokePrim [#_"LOD" this, #_"long" arg0, #_"Object" arg1])
    )

    (interface! LLO []
        #_abstract
        (#_"Object" invokePrim [#_"LLO" this, #_"long" arg0, #_"long" arg1])
    )

    (interface! LLL []
        #_abstract
        (#_"long" invokePrim [#_"LLL" this, #_"long" arg0, #_"long" arg1])
    )

    (interface! LLD []
        #_abstract
        (#_"double" invokePrim [#_"LLD" this, #_"long" arg0, #_"long" arg1])
    )

    (interface! LDO []
        #_abstract
        (#_"Object" invokePrim [#_"LDO" this, #_"long" arg0, #_"double" arg1])
    )

    (interface! LDL []
        #_abstract
        (#_"long" invokePrim [#_"LDL" this, #_"long" arg0, #_"double" arg1])
    )

    (interface! LDD []
        #_abstract
        (#_"double" invokePrim [#_"LDD" this, #_"long" arg0, #_"double" arg1])
    )

    (interface! DOO []
        #_abstract
        (#_"Object" invokePrim [#_"DOO" this, #_"double" arg0, #_"Object" arg1])
    )

    (interface! DOL []
        #_abstract
        (#_"long" invokePrim [#_"DOL" this, #_"double" arg0, #_"Object" arg1])
    )

    (interface! DOD []
        #_abstract
        (#_"double" invokePrim [#_"DOD" this, #_"double" arg0, #_"Object" arg1])
    )

    (interface! DLO []
        #_abstract
        (#_"Object" invokePrim [#_"DLO" this, #_"double" arg0, #_"long" arg1])
    )

    (interface! DLL []
        #_abstract
        (#_"long" invokePrim [#_"DLL" this, #_"double" arg0, #_"long" arg1])
    )

    (interface! DLD []
        #_abstract
        (#_"double" invokePrim [#_"DLD" this, #_"double" arg0, #_"long" arg1])
    )

    (interface! DDO []
        #_abstract
        (#_"Object" invokePrim [#_"DDO" this, #_"double" arg0, #_"double" arg1])
    )

    (interface! DDL []
        #_abstract
        (#_"long" invokePrim [#_"DDL" this, #_"double" arg0, #_"double" arg1])
    )

    (interface! DDD []
        #_abstract
        (#_"double" invokePrim [#_"DDD" this, #_"double" arg0, #_"double" arg1])
    )

    (interface! OOOL []
        #_abstract
        (#_"long" invokePrim [#_"OOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! OOOD []
        #_abstract
        (#_"double" invokePrim [#_"OOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! OOLO []
        #_abstract
        (#_"Object" invokePrim [#_"OOLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! OOLL []
        #_abstract
        (#_"long" invokePrim [#_"OOLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! OOLD []
        #_abstract
        (#_"double" invokePrim [#_"OOLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! OODO []
        #_abstract
        (#_"Object" invokePrim [#_"OODO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! OODL []
        #_abstract
        (#_"long" invokePrim [#_"OODL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! OODD []
        #_abstract
        (#_"double" invokePrim [#_"OODD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! OLOO []
        #_abstract
        (#_"Object" invokePrim [#_"OLOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! OLOL []
        #_abstract
        (#_"long" invokePrim [#_"OLOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! OLOD []
        #_abstract
        (#_"double" invokePrim [#_"OLOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! OLLO []
        #_abstract
        (#_"Object" invokePrim [#_"OLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! OLLL []
        #_abstract
        (#_"long" invokePrim [#_"OLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! OLLD []
        #_abstract
        (#_"double" invokePrim [#_"OLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! OLDO []
        #_abstract
        (#_"Object" invokePrim [#_"OLDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! OLDL []
        #_abstract
        (#_"long" invokePrim [#_"OLDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! OLDD []
        #_abstract
        (#_"double" invokePrim [#_"OLDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! ODOO []
        #_abstract
        (#_"Object" invokePrim [#_"ODOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! ODOL []
        #_abstract
        (#_"long" invokePrim [#_"ODOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! ODOD []
        #_abstract
        (#_"double" invokePrim [#_"ODOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! ODLO []
        #_abstract
        (#_"Object" invokePrim [#_"ODLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! ODLL []
        #_abstract
        (#_"long" invokePrim [#_"ODLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! ODLD []
        #_abstract
        (#_"double" invokePrim [#_"ODLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! ODDO []
        #_abstract
        (#_"Object" invokePrim [#_"ODDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! ODDL []
        #_abstract
        (#_"long" invokePrim [#_"ODDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! ODDD []
        #_abstract
        (#_"double" invokePrim [#_"ODDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! LOOO []
        #_abstract
        (#_"Object" invokePrim [#_"LOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! LOOL []
        #_abstract
        (#_"long" invokePrim [#_"LOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! LOOD []
        #_abstract
        (#_"double" invokePrim [#_"LOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! LOLO []
        #_abstract
        (#_"Object" invokePrim [#_"LOLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! LOLL []
        #_abstract
        (#_"long" invokePrim [#_"LOLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! LOLD []
        #_abstract
        (#_"double" invokePrim [#_"LOLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! LODO []
        #_abstract
        (#_"Object" invokePrim [#_"LODO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! LODL []
        #_abstract
        (#_"long" invokePrim [#_"LODL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! LODD []
        #_abstract
        (#_"double" invokePrim [#_"LODD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! LLOO []
        #_abstract
        (#_"Object" invokePrim [#_"LLOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! LLOL []
        #_abstract
        (#_"long" invokePrim [#_"LLOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! LLOD []
        #_abstract
        (#_"double" invokePrim [#_"LLOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! LLLO []
        #_abstract
        (#_"Object" invokePrim [#_"LLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! LLLL []
        #_abstract
        (#_"long" invokePrim [#_"LLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! LLLD []
        #_abstract
        (#_"double" invokePrim [#_"LLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! LLDO []
        #_abstract
        (#_"Object" invokePrim [#_"LLDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! LLDL []
        #_abstract
        (#_"long" invokePrim [#_"LLDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! LLDD []
        #_abstract
        (#_"double" invokePrim [#_"LLDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! LDOO []
        #_abstract
        (#_"Object" invokePrim [#_"LDOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! LDOL []
        #_abstract
        (#_"long" invokePrim [#_"LDOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! LDOD []
        #_abstract
        (#_"double" invokePrim [#_"LDOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! LDLO []
        #_abstract
        (#_"Object" invokePrim [#_"LDLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! LDLL []
        #_abstract
        (#_"long" invokePrim [#_"LDLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! LDLD []
        #_abstract
        (#_"double" invokePrim [#_"LDLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! LDDO []
        #_abstract
        (#_"Object" invokePrim [#_"LDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! LDDL []
        #_abstract
        (#_"long" invokePrim [#_"LDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! LDDD []
        #_abstract
        (#_"double" invokePrim [#_"LDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! DOOO []
        #_abstract
        (#_"Object" invokePrim [#_"DOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! DOOL []
        #_abstract
        (#_"long" invokePrim [#_"DOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! DOOD []
        #_abstract
        (#_"double" invokePrim [#_"DOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (interface! DOLO []
        #_abstract
        (#_"Object" invokePrim [#_"DOLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! DOLL []
        #_abstract
        (#_"long" invokePrim [#_"DOLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! DOLD []
        #_abstract
        (#_"double" invokePrim [#_"DOLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (interface! DODO []
        #_abstract
        (#_"Object" invokePrim [#_"DODO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! DODL []
        #_abstract
        (#_"long" invokePrim [#_"DODL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! DODD []
        #_abstract
        (#_"double" invokePrim [#_"DODD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (interface! DLOO []
        #_abstract
        (#_"Object" invokePrim [#_"DLOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! DLOL []
        #_abstract
        (#_"long" invokePrim [#_"DLOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! DLOD []
        #_abstract
        (#_"double" invokePrim [#_"DLOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (interface! DLLO []
        #_abstract
        (#_"Object" invokePrim [#_"DLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! DLLL []
        #_abstract
        (#_"long" invokePrim [#_"DLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! DLLD []
        #_abstract
        (#_"double" invokePrim [#_"DLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
    )

    (interface! DLDO []
        #_abstract
        (#_"Object" invokePrim [#_"DLDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! DLDL []
        #_abstract
        (#_"long" invokePrim [#_"DLDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! DLDD []
        #_abstract
        (#_"double" invokePrim [#_"DLDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
    )

    (interface! DDOO []
        #_abstract
        (#_"Object" invokePrim [#_"DDOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! DDOL []
        #_abstract
        (#_"long" invokePrim [#_"DDOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! DDOD []
        #_abstract
        (#_"double" invokePrim [#_"DDOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (interface! DDLO []
        #_abstract
        (#_"Object" invokePrim [#_"DDLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! DDLL []
        #_abstract
        (#_"long" invokePrim [#_"DDLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! DDLD []
        #_abstract
        (#_"double" invokePrim [#_"DDLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
    )

    (interface! DDDO []
        #_abstract
        (#_"Object" invokePrim [#_"DDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! DDDL []
        #_abstract
        (#_"long" invokePrim [#_"DDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! DDDD []
        #_abstract
        (#_"double" invokePrim [#_"DDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
    )

    (interface! OOOOL []
        #_abstract
        (#_"long" invokePrim [#_"OOOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! OOOOD []
        #_abstract
        (#_"double" invokePrim [#_"OOOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! OOOLO []
        #_abstract
        (#_"Object" invokePrim [#_"OOOLO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! OOOLL []
        #_abstract
        (#_"long" invokePrim [#_"OOOLL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! OOOLD []
        #_abstract
        (#_"double" invokePrim [#_"OOOLD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! OOODO []
        #_abstract
        (#_"Object" invokePrim [#_"OOODO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! OOODL []
        #_abstract
        (#_"long" invokePrim [#_"OOODL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! OOODD []
        #_abstract
        (#_"double" invokePrim [#_"OOODD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! OOLOO []
        #_abstract
        (#_"Object" invokePrim [#_"OOLOO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! OOLOL []
        #_abstract
        (#_"long" invokePrim [#_"OOLOL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! OOLOD []
        #_abstract
        (#_"double" invokePrim [#_"OOLOD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! OOLLO []
        #_abstract
        (#_"Object" invokePrim [#_"OOLLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! OOLLL []
        #_abstract
        (#_"long" invokePrim [#_"OOLLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! OOLLD []
        #_abstract
        (#_"double" invokePrim [#_"OOLLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! OOLDO []
        #_abstract
        (#_"Object" invokePrim [#_"OOLDO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! OOLDL []
        #_abstract
        (#_"long" invokePrim [#_"OOLDL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! OOLDD []
        #_abstract
        (#_"double" invokePrim [#_"OOLDD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! OODOO []
        #_abstract
        (#_"Object" invokePrim [#_"OODOO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! OODOL []
        #_abstract
        (#_"long" invokePrim [#_"OODOL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! OODOD []
        #_abstract
        (#_"double" invokePrim [#_"OODOD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! OODLO []
        #_abstract
        (#_"Object" invokePrim [#_"OODLO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! OODLL []
        #_abstract
        (#_"long" invokePrim [#_"OODLL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! OODLD []
        #_abstract
        (#_"double" invokePrim [#_"OODLD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! OODDO []
        #_abstract
        (#_"Object" invokePrim [#_"OODDO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! OODDL []
        #_abstract
        (#_"long" invokePrim [#_"OODDL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! OODDD []
        #_abstract
        (#_"double" invokePrim [#_"OODDD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! OLOOO []
        #_abstract
        (#_"Object" invokePrim [#_"OLOOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! OLOOL []
        #_abstract
        (#_"long" invokePrim [#_"OLOOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! OLOOD []
        #_abstract
        (#_"double" invokePrim [#_"OLOOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! OLOLO []
        #_abstract
        (#_"Object" invokePrim [#_"OLOLO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! OLOLL []
        #_abstract
        (#_"long" invokePrim [#_"OLOLL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! OLOLD []
        #_abstract
        (#_"double" invokePrim [#_"OLOLD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! OLODO []
        #_abstract
        (#_"Object" invokePrim [#_"OLODO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! OLODL []
        #_abstract
        (#_"long" invokePrim [#_"OLODL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! OLODD []
        #_abstract
        (#_"double" invokePrim [#_"OLODD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! OLLOO []
        #_abstract
        (#_"Object" invokePrim [#_"OLLOO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! OLLOL []
        #_abstract
        (#_"long" invokePrim [#_"OLLOL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! OLLOD []
        #_abstract
        (#_"double" invokePrim [#_"OLLOD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! OLLLO []
        #_abstract
        (#_"Object" invokePrim [#_"OLLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! OLLLL []
        #_abstract
        (#_"long" invokePrim [#_"OLLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! OLLLD []
        #_abstract
        (#_"double" invokePrim [#_"OLLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! OLLDO []
        #_abstract
        (#_"Object" invokePrim [#_"OLLDO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! OLLDL []
        #_abstract
        (#_"long" invokePrim [#_"OLLDL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! OLLDD []
        #_abstract
        (#_"double" invokePrim [#_"OLLDD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! OLDOO []
        #_abstract
        (#_"Object" invokePrim [#_"OLDOO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! OLDOL []
        #_abstract
        (#_"long" invokePrim [#_"OLDOL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! OLDOD []
        #_abstract
        (#_"double" invokePrim [#_"OLDOD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! OLDLO []
        #_abstract
        (#_"Object" invokePrim [#_"OLDLO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! OLDLL []
        #_abstract
        (#_"long" invokePrim [#_"OLDLL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! OLDLD []
        #_abstract
        (#_"double" invokePrim [#_"OLDLD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! OLDDO []
        #_abstract
        (#_"Object" invokePrim [#_"OLDDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! OLDDL []
        #_abstract
        (#_"long" invokePrim [#_"OLDDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! OLDDD []
        #_abstract
        (#_"double" invokePrim [#_"OLDDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! ODOOO []
        #_abstract
        (#_"Object" invokePrim [#_"ODOOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! ODOOL []
        #_abstract
        (#_"long" invokePrim [#_"ODOOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! ODOOD []
        #_abstract
        (#_"double" invokePrim [#_"ODOOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! ODOLO []
        #_abstract
        (#_"Object" invokePrim [#_"ODOLO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! ODOLL []
        #_abstract
        (#_"long" invokePrim [#_"ODOLL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! ODOLD []
        #_abstract
        (#_"double" invokePrim [#_"ODOLD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! ODODO []
        #_abstract
        (#_"Object" invokePrim [#_"ODODO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! ODODL []
        #_abstract
        (#_"long" invokePrim [#_"ODODL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! ODODD []
        #_abstract
        (#_"double" invokePrim [#_"ODODD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! ODLOO []
        #_abstract
        (#_"Object" invokePrim [#_"ODLOO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! ODLOL []
        #_abstract
        (#_"long" invokePrim [#_"ODLOL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! ODLOD []
        #_abstract
        (#_"double" invokePrim [#_"ODLOD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! ODLLO []
        #_abstract
        (#_"Object" invokePrim [#_"ODLLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! ODLLL []
        #_abstract
        (#_"long" invokePrim [#_"ODLLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! ODLLD []
        #_abstract
        (#_"double" invokePrim [#_"ODLLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! ODLDO []
        #_abstract
        (#_"Object" invokePrim [#_"ODLDO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! ODLDL []
        #_abstract
        (#_"long" invokePrim [#_"ODLDL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! ODLDD []
        #_abstract
        (#_"double" invokePrim [#_"ODLDD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! ODDOO []
        #_abstract
        (#_"Object" invokePrim [#_"ODDOO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! ODDOL []
        #_abstract
        (#_"long" invokePrim [#_"ODDOL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! ODDOD []
        #_abstract
        (#_"double" invokePrim [#_"ODDOD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! ODDLO []
        #_abstract
        (#_"Object" invokePrim [#_"ODDLO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! ODDLL []
        #_abstract
        (#_"long" invokePrim [#_"ODDLL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! ODDLD []
        #_abstract
        (#_"double" invokePrim [#_"ODDLD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! ODDDO []
        #_abstract
        (#_"Object" invokePrim [#_"ODDDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! ODDDL []
        #_abstract
        (#_"long" invokePrim [#_"ODDDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! ODDDD []
        #_abstract
        (#_"double" invokePrim [#_"ODDDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LOOOO []
        #_abstract
        (#_"Object" invokePrim [#_"LOOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LOOOL []
        #_abstract
        (#_"long" invokePrim [#_"LOOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LOOOD []
        #_abstract
        (#_"double" invokePrim [#_"LOOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LOOLO []
        #_abstract
        (#_"Object" invokePrim [#_"LOOLO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LOOLL []
        #_abstract
        (#_"long" invokePrim [#_"LOOLL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LOOLD []
        #_abstract
        (#_"double" invokePrim [#_"LOOLD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LOODO []
        #_abstract
        (#_"Object" invokePrim [#_"LOODO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LOODL []
        #_abstract
        (#_"long" invokePrim [#_"LOODL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LOODD []
        #_abstract
        (#_"double" invokePrim [#_"LOODD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LOLOO []
        #_abstract
        (#_"Object" invokePrim [#_"LOLOO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LOLOL []
        #_abstract
        (#_"long" invokePrim [#_"LOLOL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LOLOD []
        #_abstract
        (#_"double" invokePrim [#_"LOLOD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LOLLO []
        #_abstract
        (#_"Object" invokePrim [#_"LOLLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LOLLL []
        #_abstract
        (#_"long" invokePrim [#_"LOLLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LOLLD []
        #_abstract
        (#_"double" invokePrim [#_"LOLLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LOLDO []
        #_abstract
        (#_"Object" invokePrim [#_"LOLDO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LOLDL []
        #_abstract
        (#_"long" invokePrim [#_"LOLDL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LOLDD []
        #_abstract
        (#_"double" invokePrim [#_"LOLDD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LODOO []
        #_abstract
        (#_"Object" invokePrim [#_"LODOO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LODOL []
        #_abstract
        (#_"long" invokePrim [#_"LODOL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LODOD []
        #_abstract
        (#_"double" invokePrim [#_"LODOD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LODLO []
        #_abstract
        (#_"Object" invokePrim [#_"LODLO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LODLL []
        #_abstract
        (#_"long" invokePrim [#_"LODLL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LODLD []
        #_abstract
        (#_"double" invokePrim [#_"LODLD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LODDO []
        #_abstract
        (#_"Object" invokePrim [#_"LODDO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LODDL []
        #_abstract
        (#_"long" invokePrim [#_"LODDL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LODDD []
        #_abstract
        (#_"double" invokePrim [#_"LODDD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LLOOO []
        #_abstract
        (#_"Object" invokePrim [#_"LLOOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LLOOL []
        #_abstract
        (#_"long" invokePrim [#_"LLOOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LLOOD []
        #_abstract
        (#_"double" invokePrim [#_"LLOOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LLOLO []
        #_abstract
        (#_"Object" invokePrim [#_"LLOLO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LLOLL []
        #_abstract
        (#_"long" invokePrim [#_"LLOLL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LLOLD []
        #_abstract
        (#_"double" invokePrim [#_"LLOLD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LLODO []
        #_abstract
        (#_"Object" invokePrim [#_"LLODO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LLODL []
        #_abstract
        (#_"long" invokePrim [#_"LLODL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LLODD []
        #_abstract
        (#_"double" invokePrim [#_"LLODD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LLLOO []
        #_abstract
        (#_"Object" invokePrim [#_"LLLOO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LLLOL []
        #_abstract
        (#_"long" invokePrim [#_"LLLOL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LLLOD []
        #_abstract
        (#_"double" invokePrim [#_"LLLOD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LLLLO []
        #_abstract
        (#_"Object" invokePrim [#_"LLLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LLLLL []
        #_abstract
        (#_"long" invokePrim [#_"LLLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LLLLD []
        #_abstract
        (#_"double" invokePrim [#_"LLLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LLLDO []
        #_abstract
        (#_"Object" invokePrim [#_"LLLDO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LLLDL []
        #_abstract
        (#_"long" invokePrim [#_"LLLDL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LLLDD []
        #_abstract
        (#_"double" invokePrim [#_"LLLDD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LLDOO []
        #_abstract
        (#_"Object" invokePrim [#_"LLDOO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LLDOL []
        #_abstract
        (#_"long" invokePrim [#_"LLDOL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LLDOD []
        #_abstract
        (#_"double" invokePrim [#_"LLDOD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LLDLO []
        #_abstract
        (#_"Object" invokePrim [#_"LLDLO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LLDLL []
        #_abstract
        (#_"long" invokePrim [#_"LLDLL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LLDLD []
        #_abstract
        (#_"double" invokePrim [#_"LLDLD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LLDDO []
        #_abstract
        (#_"Object" invokePrim [#_"LLDDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LLDDL []
        #_abstract
        (#_"long" invokePrim [#_"LLDDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LLDDD []
        #_abstract
        (#_"double" invokePrim [#_"LLDDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LDOOO []
        #_abstract
        (#_"Object" invokePrim [#_"LDOOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LDOOL []
        #_abstract
        (#_"long" invokePrim [#_"LDOOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LDOOD []
        #_abstract
        (#_"double" invokePrim [#_"LDOOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! LDOLO []
        #_abstract
        (#_"Object" invokePrim [#_"LDOLO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LDOLL []
        #_abstract
        (#_"long" invokePrim [#_"LDOLL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LDOLD []
        #_abstract
        (#_"double" invokePrim [#_"LDOLD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! LDODO []
        #_abstract
        (#_"Object" invokePrim [#_"LDODO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LDODL []
        #_abstract
        (#_"long" invokePrim [#_"LDODL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LDODD []
        #_abstract
        (#_"double" invokePrim [#_"LDODD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! LDLOO []
        #_abstract
        (#_"Object" invokePrim [#_"LDLOO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LDLOL []
        #_abstract
        (#_"long" invokePrim [#_"LDLOL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LDLOD []
        #_abstract
        (#_"double" invokePrim [#_"LDLOD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! LDLLO []
        #_abstract
        (#_"Object" invokePrim [#_"LDLLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LDLLL []
        #_abstract
        (#_"long" invokePrim [#_"LDLLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LDLLD []
        #_abstract
        (#_"double" invokePrim [#_"LDLLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! LDLDO []
        #_abstract
        (#_"Object" invokePrim [#_"LDLDO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LDLDL []
        #_abstract
        (#_"long" invokePrim [#_"LDLDL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LDLDD []
        #_abstract
        (#_"double" invokePrim [#_"LDLDD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! LDDOO []
        #_abstract
        (#_"Object" invokePrim [#_"LDDOO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LDDOL []
        #_abstract
        (#_"long" invokePrim [#_"LDDOL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LDDOD []
        #_abstract
        (#_"double" invokePrim [#_"LDDOD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! LDDLO []
        #_abstract
        (#_"Object" invokePrim [#_"LDDLO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LDDLL []
        #_abstract
        (#_"long" invokePrim [#_"LDDLL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LDDLD []
        #_abstract
        (#_"double" invokePrim [#_"LDDLD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! LDDDO []
        #_abstract
        (#_"Object" invokePrim [#_"LDDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LDDDL []
        #_abstract
        (#_"long" invokePrim [#_"LDDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! LDDDD []
        #_abstract
        (#_"double" invokePrim [#_"LDDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DOOOO []
        #_abstract
        (#_"Object" invokePrim [#_"DOOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DOOOL []
        #_abstract
        (#_"long" invokePrim [#_"DOOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DOOOD []
        #_abstract
        (#_"double" invokePrim [#_"DOOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DOOLO []
        #_abstract
        (#_"Object" invokePrim [#_"DOOLO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DOOLL []
        #_abstract
        (#_"long" invokePrim [#_"DOOLL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DOOLD []
        #_abstract
        (#_"double" invokePrim [#_"DOOLD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DOODO []
        #_abstract
        (#_"Object" invokePrim [#_"DOODO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DOODL []
        #_abstract
        (#_"long" invokePrim [#_"DOODL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DOODD []
        #_abstract
        (#_"double" invokePrim [#_"DOODD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DOLOO []
        #_abstract
        (#_"Object" invokePrim [#_"DOLOO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DOLOL []
        #_abstract
        (#_"long" invokePrim [#_"DOLOL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DOLOD []
        #_abstract
        (#_"double" invokePrim [#_"DOLOD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DOLLO []
        #_abstract
        (#_"Object" invokePrim [#_"DOLLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DOLLL []
        #_abstract
        (#_"long" invokePrim [#_"DOLLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DOLLD []
        #_abstract
        (#_"double" invokePrim [#_"DOLLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DOLDO []
        #_abstract
        (#_"Object" invokePrim [#_"DOLDO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DOLDL []
        #_abstract
        (#_"long" invokePrim [#_"DOLDL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DOLDD []
        #_abstract
        (#_"double" invokePrim [#_"DOLDD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DODOO []
        #_abstract
        (#_"Object" invokePrim [#_"DODOO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DODOL []
        #_abstract
        (#_"long" invokePrim [#_"DODOL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DODOD []
        #_abstract
        (#_"double" invokePrim [#_"DODOD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DODLO []
        #_abstract
        (#_"Object" invokePrim [#_"DODLO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DODLL []
        #_abstract
        (#_"long" invokePrim [#_"DODLL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DODLD []
        #_abstract
        (#_"double" invokePrim [#_"DODLD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DODDO []
        #_abstract
        (#_"Object" invokePrim [#_"DODDO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DODDL []
        #_abstract
        (#_"long" invokePrim [#_"DODDL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DODDD []
        #_abstract
        (#_"double" invokePrim [#_"DODDD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DLOOO []
        #_abstract
        (#_"Object" invokePrim [#_"DLOOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DLOOL []
        #_abstract
        (#_"long" invokePrim [#_"DLOOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DLOOD []
        #_abstract
        (#_"double" invokePrim [#_"DLOOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DLOLO []
        #_abstract
        (#_"Object" invokePrim [#_"DLOLO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DLOLL []
        #_abstract
        (#_"long" invokePrim [#_"DLOLL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DLOLD []
        #_abstract
        (#_"double" invokePrim [#_"DLOLD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DLODO []
        #_abstract
        (#_"Object" invokePrim [#_"DLODO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DLODL []
        #_abstract
        (#_"long" invokePrim [#_"DLODL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DLODD []
        #_abstract
        (#_"double" invokePrim [#_"DLODD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DLLOO []
        #_abstract
        (#_"Object" invokePrim [#_"DLLOO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DLLOL []
        #_abstract
        (#_"long" invokePrim [#_"DLLOL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DLLOD []
        #_abstract
        (#_"double" invokePrim [#_"DLLOD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DLLLO []
        #_abstract
        (#_"Object" invokePrim [#_"DLLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DLLLL []
        #_abstract
        (#_"long" invokePrim [#_"DLLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DLLLD []
        #_abstract
        (#_"double" invokePrim [#_"DLLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DLLDO []
        #_abstract
        (#_"Object" invokePrim [#_"DLLDO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DLLDL []
        #_abstract
        (#_"long" invokePrim [#_"DLLDL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DLLDD []
        #_abstract
        (#_"double" invokePrim [#_"DLLDD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DLDOO []
        #_abstract
        (#_"Object" invokePrim [#_"DLDOO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DLDOL []
        #_abstract
        (#_"long" invokePrim [#_"DLDOL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DLDOD []
        #_abstract
        (#_"double" invokePrim [#_"DLDOD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DLDLO []
        #_abstract
        (#_"Object" invokePrim [#_"DLDLO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DLDLL []
        #_abstract
        (#_"long" invokePrim [#_"DLDLL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DLDLD []
        #_abstract
        (#_"double" invokePrim [#_"DLDLD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DLDDO []
        #_abstract
        (#_"Object" invokePrim [#_"DLDDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DLDDL []
        #_abstract
        (#_"long" invokePrim [#_"DLDDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DLDDD []
        #_abstract
        (#_"double" invokePrim [#_"DLDDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DDOOO []
        #_abstract
        (#_"Object" invokePrim [#_"DDOOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DDOOL []
        #_abstract
        (#_"long" invokePrim [#_"DDOOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DDOOD []
        #_abstract
        (#_"double" invokePrim [#_"DDOOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (interface! DDOLO []
        #_abstract
        (#_"Object" invokePrim [#_"DDOLO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DDOLL []
        #_abstract
        (#_"long" invokePrim [#_"DDOLL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DDOLD []
        #_abstract
        (#_"double" invokePrim [#_"DDOLD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (interface! DDODO []
        #_abstract
        (#_"Object" invokePrim [#_"DDODO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DDODL []
        #_abstract
        (#_"long" invokePrim [#_"DDODL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DDODD []
        #_abstract
        (#_"double" invokePrim [#_"DDODD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (interface! DDLOO []
        #_abstract
        (#_"Object" invokePrim [#_"DDLOO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DDLOL []
        #_abstract
        (#_"long" invokePrim [#_"DDLOL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DDLOD []
        #_abstract
        (#_"double" invokePrim [#_"DDLOD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (interface! DDLLO []
        #_abstract
        (#_"Object" invokePrim [#_"DDLLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DDLLL []
        #_abstract
        (#_"long" invokePrim [#_"DDLLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DDLLD []
        #_abstract
        (#_"double" invokePrim [#_"DDLLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (interface! DDLDO []
        #_abstract
        (#_"Object" invokePrim [#_"DDLDO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DDLDL []
        #_abstract
        (#_"long" invokePrim [#_"DDLDL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DDLDD []
        #_abstract
        (#_"double" invokePrim [#_"DDLDD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (interface! DDDOO []
        #_abstract
        (#_"Object" invokePrim [#_"DDDOO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DDDOL []
        #_abstract
        (#_"long" invokePrim [#_"DDDOL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DDDOD []
        #_abstract
        (#_"double" invokePrim [#_"DDDOD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (interface! DDDLO []
        #_abstract
        (#_"Object" invokePrim [#_"DDDLO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DDDLL []
        #_abstract
        (#_"long" invokePrim [#_"DDDLL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DDDLD []
        #_abstract
        (#_"double" invokePrim [#_"DDDLD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (interface! DDDDO []
        #_abstract
        (#_"Object" invokePrim [#_"DDDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DDDDL []
        #_abstract
        (#_"long" invokePrim [#_"DDDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (interface! DDDDD []
        #_abstract
        (#_"double" invokePrim [#_"DDDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

;;;
 ; IFn provides complete access to invoking any of Cloiure's APIs.
 ; You can also access any other library written in Cloiure, after
 ; adding either its source or compiled form to the classpath.
 ;;
    (interface! IFn [Callable Runnable]
        #_abstract
        (#_"Object" invoke [#_"IFn" this])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7])
        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18])

        #_abstract
        (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

        #_abstract
    #_(#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

        #_abstract
    #_(#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" #_arg19, #_"Object" #_arg20 & #_"Object..." args])

        #_abstract
        (#_"Object" applyTo [#_"IFn" this, #_"ISeq" args])
    )
)

(java-ns cloiure.lang.Fn
    (interface! Fn []
    )
)

(java-ns cloiure.lang.Sequential
    (interface! Sequential []
    )
)

(java-ns cloiure.lang.Seqable
    (interface! Seqable []
        #_abstract
        (#_"ISeq" seq [#_"Seqable" this])
    )
)

(java-ns cloiure.lang.Reversible
    (interface! Reversible []
        #_abstract
        (#_"ISeq" rseq [#_"Reversible" this])
    )
)

(java-ns cloiure.lang.Sorted
    (interface! Sorted []
        #_abstract
        (#_"Comparator" comparator [#_"Sorted" this])
        #_abstract
        (#_"Object" entryKey [#_"Sorted" this, #_"Object" entry])
        #_abstract
        (#_"ISeq" seq [#_"Sorted" this, #_"boolean" ascending])
        #_abstract
        (#_"ISeq" seqFrom [#_"Sorted" this, #_"Object" key, #_"boolean" ascending])
    )
)

(java-ns cloiure.lang.Counted
    (interface! Counted []
        #_abstract
        (#_"int" count [#_"Counted" this])
    )
)

(java-ns cloiure.lang.IPersistentCollection
    (interface! IPersistentCollection [Seqable]
        #_abstract
        (#_"int" count [#_"IPersistentCollection" this])
        #_abstract
        (#_"IPersistentCollection" cons [#_"IPersistentCollection" this, #_"Object" o])
        #_abstract
        (#_"IPersistentCollection" empty [#_"IPersistentCollection" this])
        #_abstract
        (#_"boolean" equiv [#_"IPersistentCollection" this, #_"Object" o])
    )
)

(java-ns cloiure.lang.ISeq
    (interface! ISeq [IPersistentCollection]
        #_abstract
        (#_"Object" first [#_"ISeq" this])
        #_abstract
        (#_"ISeq" next [#_"ISeq" this])
        #_abstract
        (#_"ISeq" more [#_"ISeq" this])
        #_abstract
        (#_"ISeq" cons [#_"ISeq" this, #_"Object" o])
    )
)

(java-ns cloiure.lang.IAtom
    (interface! IAtom []
        #_abstract
        (#_"Object" swap [#_"IAtom" this, #_"IFn" f])
        #_abstract
        (#_"Object" swap [#_"IAtom" this, #_"IFn" f, #_"Object" arg])
        #_abstract
        (#_"Object" swap [#_"IAtom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
        #_abstract
        (#_"Object" swap [#_"IAtom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
        #_abstract
        (#_"boolean" compareAndSet [#_"IAtom" this, #_"Object" oldv, #_"Object" newv])
        #_abstract
        (#_"Object" reset [#_"IAtom" this, #_"Object" newval])
    )
)

(java-ns cloiure.lang.IAtom2
    (interface! IAtom2 [IAtom]
        #_abstract
        (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f])
        #_abstract
        (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f, #_"Object" arg])
        #_abstract
        (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
        #_abstract
        (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
        #_abstract
        (#_"IPersistentVector" resetVals [#_"IAtom2" this, #_"Object" newv])
    )
)

(java-ns cloiure.lang.IBlockingDeref
    (interface! IBlockingDeref []
        #_abstract
        (#_"Object" deref [#_"IBlockingDeref" this, #_"long" ms, #_"Object" timeoutValue])
    )
)

(java-ns cloiure.lang.IDeref
    (interface! IDeref []
        #_abstract
        (#_"Object" deref [#_"IDeref" this])
    )
)

(java-ns cloiure.lang.IRef
    (interface! IRef [IDeref]
        #_abstract
        (#_"void" setValidator [#_"IRef" this, #_"IFn" vf])
        #_abstract
        (#_"IFn" getValidator [#_"IRef" this])
        #_abstract
        (#_"IPersistentMap" getWatches [#_"IRef" this])
        #_abstract
        (#_"IRef" addWatch [#_"IRef" this, #_"Object" key, #_"IFn" callback])
        #_abstract
        (#_"IRef" removeWatch [#_"IRef" this, #_"Object" key])
    )
)

(java-ns cloiure.lang.IEditableCollection
    (interface! IEditableCollection []
        #_abstract
        (#_"ITransientCollection" asTransient [#_"IEditableCollection" this])
    )
)

(java-ns cloiure.lang.IExceptionInfo
    (interface! IExceptionInfo []
        #_abstract
        (#_"IPersistentMap" getData [#_"IExceptionInfo" this])
    )
)

(java-ns cloiure.lang.IHashEq
    (interface! IHashEq []
        #_abstract
        (#_"int" hasheq [#_"IHashEq" this])
    )
)

(java-ns cloiure.lang.MapEquivalence
    (interface! MapEquivalence []
    )
)

(java-ns cloiure.lang.IKeywordLookup
    (interface! IKeywordLookup []
        #_abstract
        (#_"ILookupThunk" getLookupThunk [#_"IKeywordLookup" this, #_"Keyword" k])
    )
)

(java-ns cloiure.lang.ILookup
    (interface! ILookup []
        #_abstract
        (#_"Object" valAt [#_"ILookup" this, #_"Object" key])
        #_abstract
        (#_"Object" valAt [#_"ILookup" this, #_"Object" key, #_"Object" notFound])
    )
)

(java-ns cloiure.lang.ILookupSite
    (interface! ILookupSite []
        #_abstract
        (#_"ILookupThunk" fault [#_"ILookupSite" this, #_"Object" target])
    )
)

(java-ns cloiure.lang.ILookupThunk
    (interface! ILookupThunk []
        #_abstract
        (#_"Object" get [#_"ILookupThunk" this, #_"Object" target])
    )
)

(java-ns cloiure.lang.IMapEntry
    (interface! IMapEntry [Map$Entry]
        #_abstract
        (#_"Object" key [#_"IMapEntry" this])
        #_abstract
        (#_"Object" val [#_"IMapEntry" this])
    )
)

(java-ns cloiure.lang.IMapIterable
    (interface! IMapIterable []
        #_abstract
        (#_"Iterator" keyIterator [#_"IMapIterable" this])
        #_abstract
        (#_"Iterator" valIterator [#_"IMapIterable" this])
    )
)

(java-ns cloiure.lang.Named
    (interface! Named []
        #_abstract
        (#_"String" getNamespace [#_"Named" this])
        #_abstract
        (#_"String" getName [#_"Named" this])
    )
)

(java-ns cloiure.lang.IMeta
    (interface! IMeta []
        #_abstract
        (#_"IPersistentMap" meta [#_"IMeta" this])
    )
)

(java-ns cloiure.lang.IObj
    (interface! IObj [IMeta]
        #_abstract
        (#_"IObj" withMeta [#_"IObj" this, #_"IPersistentMap" meta])
    )
)

(java-ns cloiure.lang.IReference
    (interface! IReference [IMeta]
        #_abstract
        (#_"IPersistentMap" alterMeta [#_"IReference" this, #_"IFn" alter, #_"ISeq" args])
        #_abstract
        (#_"IPersistentMap" resetMeta [#_"IReference" this, #_"IPersistentMap" m])
    )
)

(java-ns cloiure.lang.Settable
    (interface! Settable []
        #_abstract
        (#_"Object" doSet [#_"Settable" this, #_"Object" val])
        #_abstract
        (#_"Object" doReset [#_"Settable" this, #_"Object" val])
    )
)

(java-ns cloiure.lang.Indexed
    (interface! Indexed [Counted]
        #_abstract
        (#_"Object" nth [#_"Indexed" this, #_"int" i])
        #_abstract
        (#_"Object" nth [#_"Indexed" this, #_"int" i, #_"Object" notFound])
    )
)

(java-ns cloiure.lang.IndexedSeq
    (interface! IndexedSeq [ISeq Sequential Counted]
        #_abstract
        (#_"int" index [#_"IndexedSeq" this])
    )
)

(java-ns cloiure.lang.IChunk
    (interface! IChunk [Indexed]
        #_abstract
        (#_"IChunk" dropFirst [#_"IChunk" this])
        #_abstract
        (#_"Object" reduce [#_"IChunk" this, #_"IFn" f, #_"Object" start])
    )
)

(java-ns cloiure.lang.IChunkedSeq
    (interface! IChunkedSeq [ISeq Sequential]
        #_abstract
        (#_"IChunk" chunkedFirst [#_"IChunkedSeq" this])
        #_abstract
        (#_"ISeq" chunkedNext [#_"IChunkedSeq" this])
        #_abstract
        (#_"ISeq" chunkedMore [#_"IChunkedSeq" this])
    )
)

(java-ns cloiure.lang.IPending
    (interface! IPending []
        #_abstract
        (#_"boolean" isRealized [#_"IPending" this])
    )
)

(java-ns cloiure.lang.Associative
    (interface! Associative [IPersistentCollection ILookup]
        #_abstract
        (#_"boolean" containsKey [#_"Associative" this, #_"Object" key])
        #_abstract
        (#_"IMapEntry" entryAt [#_"Associative" this, #_"Object" key])
        #_abstract
        (#_"Associative" assoc [#_"Associative" this, #_"Object" key, #_"Object" val])
    )
)

(java-ns cloiure.lang.IPersistentMap
    (interface! IPersistentMap [Iterable Associative Counted]
        #_abstract
        (#_"IPersistentMap" assoc [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
        #_abstract
        (#_"IPersistentMap" assocEx [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
        #_abstract
        (#_"IPersistentMap" without [#_"IPersistentMap" this, #_"Object" key])
    )
)

(java-ns cloiure.lang.IPersistentSet
    (interface! IPersistentSet [IPersistentCollection Counted]
        #_abstract
        (#_"IPersistentSet" disjoin [#_"IPersistentSet" this, #_"Object" key])
        #_abstract
        (#_"boolean" contains [#_"IPersistentSet" this, #_"Object" key])
        #_abstract
        (#_"Object" get [#_"IPersistentSet" this, #_"Object" key])
    )
)

(java-ns cloiure.lang.IPersistentStack
    (interface! IPersistentStack [IPersistentCollection]
        #_abstract
        (#_"Object" peek [#_"IPersistentStack" this])
        #_abstract
        (#_"IPersistentStack" pop [#_"IPersistentStack" this])
    )
)

(java-ns cloiure.lang.IPersistentList
    (interface! IPersistentList [Sequential IPersistentStack]
    )
)

(java-ns cloiure.lang.IPersistentVector
    (interface! IPersistentVector [Associative Sequential IPersistentStack Reversible Indexed]
        #_abstract
        (#_"int" length [#_"IPersistentVector" this])
        #_abstract
        (#_"IPersistentVector" assocN [#_"IPersistentVector" this, #_"int" i, #_"Object" val])
        #_abstract
        (#_"IPersistentVector" cons [#_"IPersistentVector" this, #_"Object" o])
    )
)

(java-ns cloiure.lang.IReduceInit
    (interface! IReduceInit []
        #_abstract
        (#_"Object" reduce [#_"IReduceInit" this, #_"IFn" f, #_"Object" start])
    )
)

(java-ns cloiure.lang.IReduce
    (interface! IReduce [IReduceInit]
        #_abstract
        (#_"Object" reduce [#_"IReduce" this, #_"IFn" f])
    )
)

(java-ns cloiure.lang.IKVReduce
    (interface! IKVReduce []
        #_abstract
        (#_"Object" kvreduce [#_"IKVReduce" this, #_"IFn" f, #_"Object" r])
    )
)

(java-ns cloiure.lang.ITransientCollection
    (interface! ITransientCollection []
        #_abstract
        (#_"ITransientCollection" conj [#_"ITransientCollection" this, #_"Object" val])
        #_abstract
        (#_"IPersistentCollection" persistent [#_"ITransientCollection" this])
    )
)

(java-ns cloiure.lang.ITransientAssociative
    (interface! ITransientAssociative [ITransientCollection ILookup]
        #_abstract
        (#_"ITransientAssociative" assoc [#_"ITransientAssociative" this, #_"Object" key, #_"Object" val])
    )
)

(java-ns cloiure.lang.ITransientAssociative2
    (interface! ITransientAssociative2 [ITransientAssociative]
        #_abstract
        (#_"boolean" containsKey [#_"ITransientAssociative2" this, #_"Object" key])
        #_abstract
        (#_"IMapEntry" entryAt [#_"ITransientAssociative2" this, #_"Object" key])
    )
)

(java-ns cloiure.lang.ITransientMap
    (interface! ITransientMap [ITransientAssociative Counted]
        #_abstract
        (#_"ITransientMap" assoc [#_"ITransientMap" this, #_"Object" key, #_"Object" val])
        #_abstract
        (#_"ITransientMap" without [#_"ITransientMap" this, #_"Object" key])
        #_abstract
        (#_"IPersistentMap" persistent [#_"ITransientMap" this])
    )
)

(java-ns cloiure.lang.ITransientSet
    (interface! ITransientSet [ITransientCollection Counted]
        #_abstract
        (#_"ITransientSet" disjoin [#_"ITransientSet" this, #_"Object" key])
        #_abstract
        (#_"boolean" contains [#_"ITransientSet" this, #_"Object" key])
        #_abstract
        (#_"Object" get [#_"ITransientSet" this, #_"Object" key])
    )
)

(java-ns cloiure.lang.ITransientVector
    (interface! ITransientVector [ITransientAssociative Indexed]
        #_abstract
        (#_"ITransientVector" assocN [#_"ITransientVector" this, #_"int" i, #_"Object" val])
        #_abstract
        (#_"ITransientVector" pop [#_"ITransientVector" this])
    )
)

(java-ns cloiure.lang.Numbers
    (interface! Ops []
        #_abstract
        (#_"Ops" combine [#_"Ops" this, #_"Ops" y])
        #_abstract
        (#_"Ops" opsWithLong [#_"Ops" this, #_"LongOps" x])
        #_abstract
        (#_"Ops" opsWithDouble [#_"Ops" this, #_"DoubleOps" x])
        #_abstract
        (#_"Ops" opsWithRatio [#_"Ops" this, #_"RatioOps" x])
        #_abstract
        (#_"Ops" opsWithBigInt [#_"Ops" this, #_"BigIntOps" x])
        #_abstract
        (#_"Ops" opsWithBigDecimal [#_"Ops" this, #_"BigDecimalOps" x])
        #_abstract
        (#_"boolean" isZero [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"boolean" isPos [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"boolean" isNeg [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" add [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" addP [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" multiply [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" multiplyP [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" divide [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" quotient [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" remainder [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" equiv [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" lt [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" lte [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" gte [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" negate [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" negateP [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" inc [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" incP [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" dec [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" decP [#_"Ops" this, #_"Number" x])
    )
)

(java-ns cloiure.lang.PersistentHashMap
    (interface! INode []
        #_abstract
        (#_"INode" assoc [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
        #_abstract
        (#_"INode" without [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
        #_abstract
        (#_"IMapEntry" find [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
        #_abstract
        (#_"Object" find [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound])
        #_abstract
        (#_"ISeq" nodeSeq [#_"INode" this])
        #_abstract
        (#_"INode" assoc [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
        #_abstract
        (#_"INode" without [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf])
        #_abstract
        (#_"Object" kvreduce [#_"INode" this, #_"IFn" f, #_"Object" r])
        #_abstract
        (#_"Object" fold [#_"INode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin])
        ;; returns the result of (f [k v]) for each iterated element
        #_abstract
        (#_"Iterator" iterator [#_"INode" this, #_"IFn" f])
    )
)

(java-ns cloiure.lang.Range
    (interface! RangeBoundsCheck []
        #_abstract
        (#_"boolean" exceededBounds [#_"RangeBoundsCheck" this, #_"Object" val])
    )
)

(java-ns cloiure.lang.LongRange
    (interface! LongRangeBoundsCheck []
        #_abstract
        (#_"boolean" exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" val])
    )
)

(java-ns cloiure.lang.Util
    (interface! EquivPred []
        #_abstract
        (#_"boolean" equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2])
    )
)

(java-ns cloiure.lang.IType
    (interface! IType []
    )
)

(java-ns cloiure.lang.IProxy
    (interface! IProxy []
        #_abstract
        (#_"void" __initCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" m])
        #_abstract
        (#_"void" __updateCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" m])
        #_abstract
        (#_"IPersistentMap" __getCloiureFnMappings [#_"IProxy" this])
    )
)

(java-ns cloiure.lang.Compiler
    (interface! Expr []
        #_abstract
        (#_"Object" eval [#_"Expr" this])
        #_abstract
        (#_"void" emit [#_"Expr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
        #_abstract
        (#_"boolean" hasJavaClass [#_"Expr" this])
        #_abstract
        (#_"Class" getJavaClass [#_"Expr" this])
    )

    (interface! IParser []
        #_abstract
        (#_"Expr" parse [#_"IParser" this, #_"Context" context, #_"Object" form])
    )

    (interface! AssignableExpr []
        #_abstract
        (#_"Object" evalAssign [#_"AssignableExpr" this, #_"Expr" val])
        #_abstract
        (#_"void" emitAssign [#_"AssignableExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val])
    )

    (interface! MaybePrimitiveExpr [Expr]
        #_abstract
        (#_"boolean" canEmitPrimitive [#_"MaybePrimitiveExpr" this])
        #_abstract
        (#_"void" emitUnboxed [#_"MaybePrimitiveExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
    )
)

(java-ns cloiure.lang.AFn
    #_abstract
    (class! AFn [IFn]
        #_abstract
        (#_"Object" throwArity [#_"AFn" this, #_"int" n])
    )
)

(java-ns cloiure.lang.AFunction
    #_abstract
    (class! AFunction [#_"AFn" IObj Comparator Fn])
)

(java-ns cloiure.lang.RestFn
    #_abstract
    (class! RestFn [#_"AFunction"]
        #_abstract
        (#_"int" getRequiredArity [#_"RestFn" this])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" args])
        #_abstract
        (#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" args])
        #_abstract
      #_(#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" args])
        #_abstract
      #_(#_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object" args])
    )
)

(java-ns cloiure.lang.ASeq
    #_abstract
    (class! ASeq [IObj ISeq Sequential List IHashEq])
)

(java-ns cloiure.lang.LazySeq
    (class! LazySeq [IObj ISeq Sequential List IPending IHashEq])
)

(java-ns cloiure.lang.APersistentMap
    (class! KeySeq [#_"ASeq"])
    (class! ValSeq [#_"ASeq"])
    #_abstract
    (class! APersistentMap [#_"AFn" IPersistentMap Map Iterable MapEquivalence IHashEq])
)

(java-ns cloiure.lang.APersistentSet
    #_abstract
    (class! APersistentSet [#_"AFn" IPersistentSet Collection Set IHashEq])
)

(java-ns cloiure.lang.APersistentVector
    (class! VSeq [#_"ASeq" IndexedSeq IReduce])
    (class! RSeq [#_"ASeq" IndexedSeq Counted])
    #_abstract
    (class! APersistentVector [#_"AFn" IPersistentVector Iterable List Comparable IHashEq]
        #_abstract
        (#_"Iterator" rangedIterator [#_"APersistentVector" this, #_"int" start, #_"int" end])
    )
    (class! SubVector [#_"APersistentVector" IObj])
)

(java-ns cloiure.lang.AMapEntry
    #_abstract
    (class! AMapEntry [#_"APersistentVector" IMapEntry])
)

(java-ns cloiure.lang.AReference
    (class! AReference [IReference])
)

(java-ns cloiure.lang.ARef
    #_abstract
    (class! ARef [#_"AReference" IRef])
)

(java-ns cloiure.lang.Agent
    (class! ActionQueue [])
    (class! AgentAction [Runnable])
    (class! Agent [#_"ARef"])
)

(java-ns cloiure.lang.ArityException
    (class! ArityException [#_"IllegalArgumentException"])
)

(java-ns cloiure.lang.ArrayChunk
    (class! ArrayChunk [IChunk])
)

(java-ns cloiure.lang.ArraySeq
    (class! ArraySeq_int [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_float [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_double [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_long [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_byte [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_char [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_short [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq_boolean [#_"ASeq" IndexedSeq IReduce])
    (class! ArraySeq [#_"ASeq" IndexedSeq IReduce])
)

(java-ns cloiure.lang.Atom
    (class! Atom [#_"ARef" IAtom2])
)

(java-ns cloiure.lang.ATransientMap
    #_abstract
    (class! ATransientMap [#_"AFn" ITransientMap ITransientAssociative2]
        #_abstract
        (#_"void" ensureEditable [#_"ATransientMap" this])
        #_abstract
        (#_"ITransientMap" doAssoc [#_"ATransientMap" this, #_"Object" key, #_"Object" val])
        #_abstract
        (#_"ITransientMap" doWithout [#_"ATransientMap" this, #_"Object" key])
        #_abstract
        (#_"Object" doValAt [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound])
        #_abstract
        (#_"int" doCount [#_"ATransientMap" this])
        #_abstract
        (#_"IPersistentMap" doPersistent [#_"ATransientMap" this])
    )
)

(java-ns cloiure.lang.ATransientSet
    #_abstract
    (class! ATransientSet [#_"AFn" ITransientSet])
)

(java-ns cloiure.lang.BigInt
    (class! BigInt [#_"Number" IHashEq])
)

(java-ns cloiure.lang.Binding
    (class! Binding #_"<T>" [])
)

(java-ns cloiure.lang.Box
    (class! Box [])
)

(java-ns cloiure.lang.ChunkBuffer
    (class! ChunkBuffer [Counted])
)

(java-ns cloiure.lang.ChunkedCons
    (class! ChunkedCons [#_"ASeq" IChunkedSeq])
)

(java-ns cloiure.lang.Compiler
    #_stateless
    (class! Recur [])
    #_abstract
    (class! UntypedExpr [Expr])
    (class! DefExpr [Expr])
    (class! AssignExpr [Expr])
    (class! VarExpr [Expr AssignableExpr])
    (class! TheVarExpr [Expr])
    (class! ImportExpr [Expr])
    #_abstract
    (class! LiteralExpr [Expr]
        #_abstract
        (#_"Object" val [#_"LiteralExpr" this])
    )
    (class! KeywordExpr [#_"LiteralExpr"])
    #_abstract
    (class! HostExpr [Expr MaybePrimitiveExpr])
    #_abstract
    (class! FieldExpr [#_"HostExpr"])
    (class! InstanceFieldExpr [#_"FieldExpr" AssignableExpr])
    (class! StaticFieldExpr [#_"FieldExpr" AssignableExpr])
    #_abstract
    (class! MethodExpr [#_"HostExpr"])
    (class! InstanceMethodExpr [#_"MethodExpr"])
    (class! StaticMethodExpr [#_"MethodExpr"])
    (class! UnresolvedVarExpr [Expr])
    (class! NumberExpr [#_"LiteralExpr" MaybePrimitiveExpr])
    (class! ConstantExpr [#_"LiteralExpr"])
    (class! NilExpr [#_"LiteralExpr"])
    (class! BooleanExpr [#_"LiteralExpr"])
    (class! StringExpr [#_"LiteralExpr"])
    (class! MonitorEnterExpr [#_"UntypedExpr"])
    (class! MonitorExitExpr [#_"UntypedExpr"])
    (class! CatchClause [])
    (class! TryExpr [Expr])
    (class! ThrowExpr [#_"UntypedExpr"])
    (class! NewExpr [Expr])
    (class! MetaExpr [Expr])
    (class! IfExpr [Expr MaybePrimitiveExpr])
    (class! EmptyExpr [Expr])
    (class! ListExpr [Expr])
    (class! MapExpr [Expr])
    (class! SetExpr [Expr])
    (class! VectorExpr [Expr])
    (class! KeywordInvokeExpr [Expr])
    (class! InstanceOfExpr [Expr MaybePrimitiveExpr])
    (class! StaticInvokeExpr [Expr MaybePrimitiveExpr])
    (class! InvokeExpr [Expr])
    (class! ObjExpr [Expr]
        #_abstract
        (#_"void" emitStatics [#_"ObjExpr" this, #_"ClassVisitor" gen])
        #_abstract
        (#_"void" emitMethods [#_"ObjExpr" this, #_"ClassVisitor" gen])
        #_abstract
        (#_"boolean" supportsMeta [#_"ObjExpr" this])
    )
    (class! FnExpr [#_"ObjExpr"])
    (class! PathNode [])
    #_abstract
    (class! ObjMethod []
        #_abstract
        (#_"int" numParams [#_"ObjMethod" this])
        #_abstract
        (#_"String" getMethodName [#_"ObjMethod" this])
        #_abstract
        (#_"Type" getReturnType [#_"ObjMethod" this])
        #_abstract
        (#_"Type[]" getArgTypes [#_"ObjMethod" this])
    )
    (class! FnMethod [#_"ObjMethod"])
    (class! LocalBinding [])
    (class! LocalBindingExpr [Expr MaybePrimitiveExpr AssignableExpr])
    (class! BodyExpr [Expr MaybePrimitiveExpr])
    (class! BindingInit [])
    (class! LetFnExpr [Expr])
    (class! LetExpr [Expr MaybePrimitiveExpr])
    (class! RecurExpr [Expr MaybePrimitiveExpr])
    (class! CompilerException [#_"RuntimeException"])
    (class! NewInstanceExpr [#_"ObjExpr"])
    (class! NewInstanceMethod [#_"ObjMethod"])
    (class! MethodParamExpr [Expr MaybePrimitiveExpr])
    (class! CaseExpr [Expr MaybePrimitiveExpr])
)

(java-ns cloiure.lang.Cons
    (class! Cons [#_"ASeq"])
)

(java-ns cloiure.lang.Cycle
    (class! Cycle [#_"ASeq" IReduce IPending])
)

(java-ns cloiure.lang.Delay
    (class! Delay [IDeref IPending])
)

(java-ns cloiure.lang.DynamicClassLoader
    (class! DynamicClassLoader [#_"URLClassLoader"])
)

(java-ns cloiure.lang.ExceptionInfo
    (class! ExceptionInfo [#_"RuntimeException" IExceptionInfo])
)

(java-ns cloiure.lang.Iterate
    (class! Iterate [#_"ASeq" IReduce IPending])
)

(java-ns cloiure.lang.IteratorSeq
    (class! IteratorSeqState [])
    (class! IteratorSeq [#_"ASeq"])
)

(java-ns cloiure.lang.Keyword
    (class! Keyword [IFn Comparable Named IHashEq])
)

(java-ns cloiure.lang.KeywordLookupSite
    (class! KeywordLookupSite [ILookupSite ILookupThunk])
)

(java-ns cloiure.lang.LineNumberingPushbackReader
    (class! LineNumberingPushbackReader [#_"PushbackReader"])
)

(java-ns cloiure.lang.LispReader
    (class! LispReaderException [#_"RuntimeException"])
)

(java-ns cloiure.lang.LockingTransaction
    (class! RetryEx [#_"Error"])
    (class! AbortException [#_"Exception"])
    (class! LockingTransactionInfo [])
    (class! CFn [])
    (class! Notify [])
    (class! LockingTransaction [])
)

(java-ns cloiure.lang.LongRange
    (class! LongChunk [IChunk])
    (class! LongRange [#_"ASeq" Counted IChunkedSeq IReduce])
)

(java-ns cloiure.lang.MapEntry
    (class! MapEntry [#_"AMapEntry"])
)

(java-ns cloiure.lang.MethodImplCache
    (class! Entry [])
    (class! MethodImplCache [])
)

(java-ns cloiure.lang.MultiFn
    (class! MultiFn [#_"AFn"])
)

(java-ns cloiure.lang.Namespace
    (class! Namespace [#_"AReference"])
)

(java-ns cloiure.lang.Numbers
    #_abstract
    (class! OpsP [Ops])
    (class! LongOps [Ops])
    (class! DoubleOps [#_"OpsP"])
    (class! RatioOps [#_"OpsP"])
    (class! BigIntOps [#_"OpsP"])
    (class! BigDecimalOps [#_"OpsP"])
    #_stateless
    (class! Numbers [])
)

(java-ns cloiure.lang.PersistentArrayMap
    (class! MSeq [#_"ASeq" Counted])
    (class! TransientArrayMap [#_"ATransientMap"])
    (class! PersistentArrayMap [#_"APersistentMap" IObj IEditableCollection IMapIterable IKVReduce])
)

(java-ns cloiure.lang.PersistentHashMap
    (class! TransientHashMap [#_"ATransientMap"])
    (class! HSeq [#_"ASeq"])
    (class! ArrayNode [INode])
    (class! BitmapIndexedNode [INode])
    (class! HashCollisionNode [INode])
    (class! NodeSeq [#_"ASeq"])
    (class! PersistentHashMap [#_"APersistentMap" IEditableCollection IObj IMapIterable IKVReduce])
)

(java-ns cloiure.lang.PersistentHashSet
    (class! TransientHashSet [#_"ATransientSet"])
    (class! PersistentHashSet [#_"APersistentSet" IObj IEditableCollection])
)

(java-ns cloiure.lang.PersistentList
    (class! Primordial [#_"RestFn"])
    (class! EmptyList [IObj IPersistentList List ISeq Counted IHashEq])
    (class! PersistentList [#_"ASeq" IPersistentList IReduce List Counted])
)

(java-ns cloiure.lang.PersistentQueue
    (class! QSeq [#_"ASeq"])
    (class! PersistentQueue [IObj IPersistentList Collection Counted IHashEq])
)

(java-ns cloiure.lang.PersistentTreeMap
    #_abstract
    (class! TNode [#_"AMapEntry"]
        #_abstract
        (#_"TNode" left [#_"TNode" this])
        #_abstract
        (#_"TNode" right [#_"TNode" this])
        #_abstract
        (#_"TNode" addLeft [#_"TNode" this, #_"TNode" ins])
        #_abstract
        (#_"TNode" addRight [#_"TNode" this, #_"TNode" ins])
        #_abstract
        (#_"TNode" removeLeft [#_"TNode" this, #_"TNode" del])
        #_abstract
        (#_"TNode" removeRight [#_"TNode" this, #_"TNode" del])
        #_abstract
        (#_"TNode" blacken [#_"TNode" this])
        #_abstract
        (#_"TNode" redden [#_"TNode" this])
        #_abstract
        (#_"TNode" balanceLeft [#_"TNode" this, #_"TNode" parent])
        #_abstract
        (#_"TNode" balanceRight [#_"TNode" this, #_"TNode" parent])
        #_abstract
        (#_"TNode" replace [#_"TNode" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right])
    )
    (class! Black [#_"TNode"])
    (class! BlackVal [#_"Black"])
    (class! BlackBranch [#_"Black"])
    (class! BlackBranchVal [#_"BlackBranch"])
    (class! Red [#_"TNode"])
    (class! RedVal [#_"Red"])
    (class! RedBranch [#_"Red"])
    (class! RedBranchVal [#_"RedBranch"])
    (class! TSeq [#_"ASeq"])
    (class! PersistentTreeMap [#_"APersistentMap" IObj Reversible Sorted IKVReduce])
)

(java-ns cloiure.lang.PersistentTreeSet
    (class! PersistentTreeSet [#_"APersistentSet" IObj Reversible Sorted])
)

(java-ns cloiure.lang.PersistentVector
    (class! VNode [])
    (class! ChunkedSeq [#_"ASeq" IChunkedSeq Counted])
    (class! TransientVector [#_"AFn" ITransientVector ITransientAssociative2 Counted])
    (class! PersistentVector [#_"APersistentVector" IObj IEditableCollection IReduce IKVReduce])
)

(java-ns cloiure.lang.ProxyHandler
    (class! ProxyHandler [InvocationHandler])
)

(java-ns cloiure.lang.Range
    (class! Range [#_"ASeq" IChunkedSeq IReduce])
)

(java-ns cloiure.lang.Ratio
    (class! Ratio [#_"Number" Comparable])
)

(java-ns cloiure.lang.Reduced
    (class! Reduced [IDeref])
)

(java-ns cloiure.lang.Ref
    (class! RefTVal [])
    (class! Ref [#_"ARef" IFn Comparable #_"<Ref>" IRef])
)

(java-ns cloiure.lang.Reflector
    #_stateless
    (class! Reflector [])
)

(java-ns cloiure.lang.Repeat
    (class! Repeat [#_"ASeq" IReduce])
)

(java-ns cloiure.lang.RT
    #_stateless
    (class! RT [])
)

(java-ns cloiure.lang.StringSeq
    (class! StringSeq [#_"ASeq" IndexedSeq])
)

(java-ns cloiure.lang.Symbol
    (class! Symbol [#_"AFn" IObj Comparable Named IHashEq])
)

(java-ns cloiure.lang.Tuple
    #_stateless
    (class! Tuple [])
)

(java-ns cloiure.lang.Util
    #_stateless
    (class! Util [])
)

(java-ns cloiure.lang.Var
    (class! TBox [])
    (class! Unbound [#_"AFn"])
    (class! Frame [])
    (class! Var [#_"ARef" IFn IRef Settable])
)

(java-ns cloiure.lang.Volatile
    (class! Volatile [IDeref])
)

(java-ns cloiure.lang.AFn

(class-ns AFn
    (defn #_"AFn" AFn'new []
        (hash-map)
    )

    #_foreign
    (defn #_"Object" call---AFn [#_"AFn" this]
        (.invoke this)
    )

    #_foreign
    (defn #_"void" run---AFn [#_"AFn" this]
        (.invoke this)
        nil
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--AFn [#_"AFn" this]
        (.throwArity this, 0)
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--AFn [#_"AFn" this, #_"Object" arg1]
        (.throwArity this, 1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2]
        (.throwArity this, 2)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.throwArity this, 3)
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.throwArity this, 4)
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.throwArity this, 5)
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.throwArity this, 6)
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.throwArity this, 7)
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.throwArity this, 8)
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.throwArity this, 9)
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.throwArity this, 10)
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.throwArity this, 11)
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.throwArity this, 12)
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.throwArity this, 13)
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.throwArity this, 14)
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.throwArity this, 15)
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.throwArity this, 16)
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.throwArity this, 17)
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.throwArity this, 18)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.throwArity this, 19)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.throwArity this, 20)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.throwArity this, 21)
    )

    #_override
    (defn #_"Object" IFn'''applyTo--AFn [#_"AFn" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )

    (defn #_"Object" AFn'applyToHelper [#_"IFn" ifn, #_"ISeq" args]
        (case (RT'boundedLength args, 20)
            0
                (.invoke ifn)
            1
                (.invoke ifn, (.first args))
            2
                (.invoke ifn, (.first args),
                    (.first (.next args))
                )
            3
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            4
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            5
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            6
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            7
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            8
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            9
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            10
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            11
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            12
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            13
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            14
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            15
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            16
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            17
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            18
                (.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            19
              #_(.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            20
              #_(.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (.next args))
                )
            #_else
              #_(.invoke ifn, (.first args),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (.first (ยง ass args (.next args))),
                    (RT'seqToArray (.next args))
                )
        )
    )

    #_override
    (defn #_"Object" AFn'''throwArity--AFn [#_"AFn" this, #_"int" n]
        (throw (ArityException'new-2 n, (Compiler'demunge (.getSimpleName (.getClass this)))))
    )
)
)

(java-ns cloiure.lang.AFunction

(class-ns AFunction
    (defn- #_"AFunction" AFunction'init []
        (hash-map
            #_volatile
            #_"MethodImplCache" :__methodImplCache nil
        )
    )

    (defn #_"AFunction" AFunction'new []
        (merge (AFn'new) (AFunction'init))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--AFunction [#_"AFunction" this]
        nil
    )

    #_override
    (defn #_"IObj" IObj'''withMeta--AFunction [#_"AFunction" this, #_"IPersistentMap" meta]
        (ยง proxy RestFn()
            #_override
            (defn #_"Object" RestFn'''doInvoke-2--RestFn [#_"RestFn" this, #_"Object" args]
                (.applyTo (ยง this AFunction), (cast ISeq args))
            )

            #_override
            (defn #_"IPersistentMap" IMeta'''meta--RestFn [#_"RestFn" this]
                meta
            )

            #_override
            (defn #_"IObj" IObj'''withMeta--RestFn [#_"RestFn" this, #_"IPersistentMap" meta]
                (.withMeta (ยง this AFunction), meta)
            )

            #_override
            (defn #_"int" RestFn'''getRequiredArity--RestFn [#_"RestFn" this]
                0
            )
        )
    )

    #_foreign
    (defn #_"int" compare---AFunction [#_"AFunction" this, #_"Object" o1, #_"Object" o2]
        (let [#_"Object" o (.invoke this, o1, o2)]
            (if (instance? Boolean o)
                (cond (RT'booleanCast-1o o) -1 (RT'booleanCast-1o (.invoke this, o2, o1)) 1 :else 0)
                (.intValue (cast Number o))
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

(class-ns RestFn
    (defn #_"RestFn" RestFn'new []
        (AFunction'new)
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-2--RestFn [#_"RestFn" this, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-3--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-4--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-5--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-6--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-7--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-8--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-9--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-10--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-11--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-12--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-13--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-14--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-15--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-16--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-17--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-18--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-19--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-20--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" args]
        nil
    )

    #_override
  #_(defn #_"Object" RestFn'''doInvoke-21--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" args]
        nil
    )

    #_override
  #_(defn #_"Object" RestFn'''doInvoke-22--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" IFn'''applyTo--RestFn [#_"RestFn" this, #_"ISeq" args]
        (when (< (.getRequiredArity this) (RT'boundedLength args, (.getRequiredArity this))) => (AFn'applyToHelper this, args)
            (case (.getRequiredArity this)
                0
                    (.doInvoke this, args)
                1
                    (.doInvoke this, (.first args),
                        (.next args)
                    )
                2
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                3
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                4
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                5
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                6
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                7
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                8
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                9
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                10
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                11
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                12
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                13
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                14
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                15
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                16
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                17
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                18
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                19
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                20
                    (.doInvoke this, (.first args),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.first (ยง ass args (.next args))),
                        (.next args)
                    )
                (.throwArity this, -1)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--RestFn [#_"RestFn" this]
        (case (.getRequiredArity this)
            0
                (.doInvoke this, nil)
            (do
                (.throwArity this, 0)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--RestFn [#_"RestFn" this, #_"Object" arg1]
        (case (.getRequiredArity this)
            0
                (.doInvoke this, (ArraySeq'create-1 arg1))
            1
                (.doInvoke this, arg1, nil)
            (do
                (.throwArity this, 1)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2))
            2
                (.doInvoke this, arg1, arg2, nil)
            (do
                (.throwArity this, 2)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3))
            3
                (.doInvoke this, arg1, arg2, arg3, nil)
            (do
                (.throwArity this, 3)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4, nil)
            (do
                (.throwArity this, 4)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, nil)
            (do
                (.throwArity this, 5)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, nil)
            (do
                (.throwArity this, 6)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, nil)
            (do
                (.throwArity this, 7)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, nil)
            (do
                (.throwArity this, 8)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, nil)
            (do
                (.throwArity this, 9)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, nil)
            (do
                (.throwArity this, 10)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, nil)
            (do
                (.throwArity this, 11)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, nil)
            (do
                (.throwArity this, 12)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, nil)
            (do
                (.throwArity this, 13)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, nil)
            (do
                (.throwArity this, 14)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14, arg15))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14, arg15))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14, arg15))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14, arg15))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14, arg15))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14, arg15))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (ArraySeq'create-1 arg15))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, nil)
            (do
                (.throwArity this, 15)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14, arg15, arg16))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14, arg15, arg16))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14, arg15, arg16))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14, arg15, arg16))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14, arg15, arg16))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (ArraySeq'create-1 arg15, arg16))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                    (ArraySeq'create-1 arg16))
            16
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, nil)
            (do
                (.throwArity this, 16)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14, arg15, arg16, arg17))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14, arg15, arg16, arg17))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14, arg15, arg16, arg17))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14, arg15, arg16, arg17))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (ArraySeq'create-1 arg15, arg16, arg17))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                    (ArraySeq'create-1 arg16, arg17))
            16
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16,
                    (ArraySeq'create-1 arg17))
            17
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, nil)
            (do
                (.throwArity this, 17)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14, arg15, arg16, arg17, arg18))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14, arg15, arg16, arg17, arg18))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14, arg15, arg16, arg17, arg18))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (ArraySeq'create-1 arg15, arg16, arg17, arg18))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                    (ArraySeq'create-1 arg16, arg17, arg18))
            16
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16,
                    (ArraySeq'create-1 arg17, arg18))
            17
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
                    (ArraySeq'create-1 arg18))
            18
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, nil)
            (do
                (.throwArity this, 18)
            )
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14, arg15, arg16, arg17, arg18, arg19))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14, arg15, arg16, arg17, arg18, arg19))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (ArraySeq'create-1 arg15, arg16, arg17, arg18, arg19))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                    (ArraySeq'create-1 arg16, arg17, arg18, arg19))
            16
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16,
                    (ArraySeq'create-1 arg17, arg18, arg19))
            17
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
                    (ArraySeq'create-1 arg18, arg19))
            18
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18,
                    (ArraySeq'create-1 arg19))
            19
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, nil)
            (do
                (.throwArity this, 19)
            )
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            1
                (.doInvoke this, arg1,
                    (ArraySeq'create-1 arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            2
                (.doInvoke this, arg1, arg2,
                    (ArraySeq'create-1 arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (ArraySeq'create-1 arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (ArraySeq'create-1 arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (ArraySeq'create-1 arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (ArraySeq'create-1 arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (ArraySeq'create-1 arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (ArraySeq'create-1 arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (ArraySeq'create-1 arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (ArraySeq'create-1 arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (ArraySeq'create-1 arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (ArraySeq'create-1 arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (ArraySeq'create-1 arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (ArraySeq'create-1 arg15, arg16, arg17, arg18, arg19, arg20))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                    (ArraySeq'create-1 arg16, arg17, arg18, arg19, arg20))
            16
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16,
                    (ArraySeq'create-1 arg17, arg18, arg19, arg20))
            17
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
                    (ArraySeq'create-1 arg18, arg19, arg20))
            18
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18,
                    (ArraySeq'create-1 arg19, arg20))
            19
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19,
                    (ArraySeq'create-1 arg20))
            20
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, nil)
            (do
                (.throwArity this, 20)
            )
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (RestFn'ontoArrayPrepend args, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            1
                (.doInvoke this, arg1,
                    (RestFn'ontoArrayPrepend args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            2
                (.doInvoke this, arg1, arg2,
                    (RestFn'ontoArrayPrepend args, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            3
                (.doInvoke this, arg1, arg2, arg3,
                    (RestFn'ontoArrayPrepend args, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            4
                (.doInvoke this, arg1, arg2, arg3, arg4,
                    (RestFn'ontoArrayPrepend args, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            5
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5,
                    (RestFn'ontoArrayPrepend args, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            6
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6,
                    (RestFn'ontoArrayPrepend args, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            7
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                    (RestFn'ontoArrayPrepend args, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            8
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    (RestFn'ontoArrayPrepend args, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            9
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                    (RestFn'ontoArrayPrepend args, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            10
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                    (RestFn'ontoArrayPrepend args, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            11
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,
                    (RestFn'ontoArrayPrepend args, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            12
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,
                    (RestFn'ontoArrayPrepend args, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            13
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                    (RestFn'ontoArrayPrepend args, arg14, arg15, arg16, arg17, arg18, arg19, arg20))
            14
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    (RestFn'ontoArrayPrepend args, arg15, arg16, arg17, arg18, arg19, arg20))
            15
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                    (RestFn'ontoArrayPrepend args, arg16, arg17, arg18, arg19, arg20))
            16
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16,
                    (RestFn'ontoArrayPrepend args, arg17, arg18, arg19, arg20))
            17
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
                    (RestFn'ontoArrayPrepend args, arg18, arg19, arg20))
            18
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18,
                    (RestFn'ontoArrayPrepend args, arg19, arg20))
            19
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19,
                    (RestFn'ontoArrayPrepend args, arg20))
            20
                (.doInvoke this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20,
                    (ArraySeq'create-1 args))
            (do
                (.throwArity this, 21)
            )
        )
    )

    (defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" array & #_"Object..." args]
        (loop-when-recur [#_"ISeq" s (ArraySeq'create-1 array) #_"int" i (dec (alength args))] (<= 0 i) [(RT'cons (aget args i), s) (dec i)] => s)
    )

    (defn #_"ISeq" RestFn'findKey [#_"Object" key, #_"ISeq" args]
        (loop-when args (some? args)
            (if (= key (.first args)) (.next args) (recur (RT'next (RT'next args))))
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(class-ns ASeq
    (defn- #_"ASeq" ASeq'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"int" :_hash 0
            #_transient
            #_"int" :_hasheq 0
        )
    )

    (defn #_"ASeq" ASeq'new-1 [#_"IPersistentMap" meta]
        (let [this (ASeq'init)]
            (assoc this :_meta meta)
        )
    )

    (defn #_"ASeq" ASeq'new-0 []
        (ASeq'init)
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--ASeq [#_"ASeq" this]
        (:_meta this)
    )

    #_foreign
    (defn #_"String" toString---ASeq [#_"ASeq" this]
        (RT'printString this)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--ASeq [#_"ASeq" this]
        PersistentList'EMPTY
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--ASeq [#_"ASeq" this, #_"Object" obj]
        (and (or (instance? Sequential obj) (instance? List obj))
            (let [#_"ISeq" ms (RT'seq obj)]
                (loop-when [#_"ISeq" s (.seq this) ms ms] (some? s) => (nil? ms)
                    (and (some? ms) (Util'equiv-2oo (.first s), (.first ms)) (recur (.next s) (.next ms)))
                )
            )
        )
    )

    #_foreign
    (defn #_"boolean" equals---ASeq [#_"ASeq" this, #_"Object" obj]
        (or (= this obj)
            (and (or (instance? Sequential obj) (instance? List obj))
                (let [#_"ISeq" ms (RT'seq obj)]
                    (loop-when [#_"ISeq" s (.seq this) ms ms] (some? s) => (nil? ms)
                        (and (some? ms) (Util'equals (.first s), (.first ms)) (recur (.next s) (.next ms)))
                    )
                )
            )
        )
    )

    #_foreign
    (defn #_"int" hashCode---ASeq [#_"ASeq" this]
        (let-when [#_"int" hash (:_hash this)] (zero? hash) => hash
            (let [hash
                    (loop-when [hash 1 #_"ISeq" s (.seq this)] (some? s) => hash
                        (recur (+ (* 31 hash) (if (some? (.first s)) (.hashCode (.first s)) 0)) (.next s))
                    )]
                (ร ass this (assoc this :_hash hash))
                hash
            )
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--ASeq [#_"ASeq" this]
        (let-when [#_"int" cached (:_hasheq this)] (zero? cached) => cached
            (let [cached (Murmur3'hashOrdered this)]
                (ร ass this (assoc this :_hasheq cached))
                cached
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--ASeq [#_"ASeq" this]
        (loop-when [#_"ISeq" s (.next this) #_"int" i 1] (some? s) => i
            (if (instance? Counted s) (+ i (.count s)) (recur (.next s) (inc i)))
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--ASeq [#_"ASeq" this]
        this
    )

    #_override
    (defn #_"ISeq" ISeq'''cons--ASeq [#_"ASeq" this, #_"Object" o]
        (Cons'new-2 o, this)
    )

    #_override
    (defn #_"ISeq" ISeq'''more--ASeq [#_"ASeq" this]
        (or (.next this) PersistentList'EMPTY)
    )

    #_foreign
    (defn #_"Object[]" toArray---ASeq [#_"ASeq" this]
        (RT'seqToArray (.seq this))
    )

    #_foreign
    (defn #_"Object[]" toArray---ASeq [#_"ASeq" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_foreign
    (defn #_"int" size---ASeq [#_"ASeq" this]
        (.count this)
    )

    #_foreign
    (defn #_"boolean" contains---ASeq [#_"ASeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---ASeq [#_"ASeq" this]
        (SeqIterator'new this)
    )

    #_foreign
    (defn #_"Object" get---ASeq [#_"ASeq" this, #_"int" index]
        (RT'nth-2 this, index)
    )
)
)

(java-ns cloiure.lang.LazySeq

(class-ns LazySeq
    (defn- #_"LazySeq" LazySeq'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
            #_"IFn" :fn nil
            #_"Object" :sv nil
            #_"ISeq" :s nil
        )
    )

    (defn #_"LazySeq" LazySeq'new-1 [#_"IFn" fn]
        (let [this (LazySeq'init)]
            (assoc this :fn fn)
        )
    )

    (defn- #_"LazySeq" LazySeq'new-2 [#_"IPersistentMap" meta, #_"ISeq" s]
        (let [this (LazySeq'init)]
            (assoc this :_meta meta :s s)
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--LazySeq [#_"LazySeq" this]
        (:_meta this)
    )

    #_override
    (defn #_"LazySeq" IObj'''withMeta--LazySeq [#_"LazySeq" this, #_"IPersistentMap" meta]
        (LazySeq'new-2 meta, (.seq this))
    )

    #_method
    (defn #_"Object" LazySeq''sval [#_"LazySeq" this]
        (ยง sync this
            (when (some? (:fn this))
                (ร ass this (assoc this :sv (.invoke (:fn this))))
                (ร ass this (assoc this :fn nil))
            )
            (or (:sv this) (:s this))
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--LazySeq [#_"LazySeq" this]
        (ยง sync this
            (LazySeq''sval this)
            (when (some? (:sv this))
                (let [#_"Object" ls (:sv this) _ (ร ass this (assoc this :sv nil))
                      ls (loop-when-recur ls (instance? LazySeq ls) (LazySeq''sval (cast LazySeq ls)) => ls)]
                    (ร ass this (assoc this :s (RT'seq ls)))
                )
            )
            (:s this)
        )
    )

    #_override
    (defn #_"int" Counted'''count--LazySeq [#_"LazySeq" this]
        (loop-when-recur [#_"int" c 0 #_"ISeq" s (.seq this)] (some? s) [(inc c) (.next s)] => c)
    )

    #_override
    (defn #_"Object" ISeq'''first--LazySeq [#_"LazySeq" this]
        (.seq this)
        (when (some? (:s this))
            (.first (:s this))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''next--LazySeq [#_"LazySeq" this]
        (.seq this)
        (when (some? (:s this))
            (.next (:s this))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''more--LazySeq [#_"LazySeq" this]
        (.seq this)
        (if (some? (:s this)) (.more (:s this)) PersistentList'EMPTY)
    )

    #_override
    (defn #_"ISeq" ISeq'''cons--LazySeq [#_"LazySeq" this, #_"Object" o]
        (RT'cons o, (.seq this))
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--LazySeq [#_"LazySeq" this]
        PersistentList'EMPTY
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--LazySeq [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (.seq this)]
            (if (some? s)
                (.equiv s, o)
                (and (or (instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
            )
        )
    )

    #_foreign
    (defn #_"int" hashCode---LazySeq [#_"LazySeq" this]
        (let [#_"ISeq" s (.seq this)]
            (if (some? s) (Util'hash s) 1)
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--LazySeq [#_"LazySeq" this]
        (Murmur3'hashOrdered this)
    )

    #_foreign
    (defn #_"boolean" equals---LazySeq [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (.seq this)]
            (if (some? s)
                (.equals s, o)
                (and (or (instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
            )
        )
    )

    #_foreign
    (defn #_"Object[]" toArray---LazySeq [#_"LazySeq" this]
        (RT'seqToArray (.seq this))
    )

    #_foreign
    (defn #_"Object[]" toArray---LazySeq [#_"LazySeq" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_foreign
    (defn #_"int" size---LazySeq [#_"LazySeq" this]
        (.count this)
    )

    #_foreign
    (defn #_"boolean" contains---LazySeq [#_"LazySeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---LazySeq [#_"LazySeq" this]
        (SeqIterator'new this)
    )

    #_foreign
    (defn #_"Object" get---LazySeq [#_"LazySeq" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--LazySeq [#_"LazySeq" this]
        (ยง sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.APersistentMap

(class-ns KeySeq
    (defn #_"KeySeq" KeySeq'create [#_"ISeq" seq]
        (when (some? seq)
            (KeySeq'new-2 seq, nil)
        )
    )

    (defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" map]
        (when (some? map)
            (let [#_"ISeq" seq (.seq map)]
                (when (some? seq)
                    (KeySeq'new-2 seq, map)
                )
            )
        )
    )

    (defn- #_"KeySeq" KeySeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"KeySeq" KeySeq'new-2 [#_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-0) (KeySeq'init))]
            (assoc this :seq seq :iterable iterable)
        )
    )

    (defn- #_"KeySeq" KeySeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-1 meta) (KeySeq'init))]
            (assoc this :seq seq :iterable iterable)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--KeySeq [#_"KeySeq" this]
        (.getKey (cast Map$Entry (.first (:seq this))))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--KeySeq [#_"KeySeq" this]
        (KeySeq'create this, (.next (:seq this)))
    )

    #_override
    (defn #_"KeySeq" IObj'''withMeta--KeySeq [#_"KeySeq" this, #_"IPersistentMap" meta]
        (KeySeq'new-3 meta, (:seq this), (:iterable this))
    )

    #_foreign
    (defn #_"Iterator" iterator---KeySeq [#_"KeySeq" this]
        (cond
            (nil? (:iterable this))
                (.iterator (ยง super ))
            (instance? IMapIterable (:iterable this))
                (.keyIterator (cast IMapIterable (:iterable this)))
            :else
                (let [#_"Iterator" it (.iterator (:iterable this))]
                    (reify Iterator
                        #_foreign
                        (#_"boolean" hasNext [#_"Iterator" _self]
                            (.hasNext it)
                        )

                        #_foreign
                        (#_"Object" next [#_"Iterator" _self]
                            (.getKey (cast Map$Entry (.next it)))
                        )
                    )
                )
        )
    )
)

(class-ns ValSeq
    (defn #_"ValSeq" ValSeq'create [#_"ISeq" seq]
        (when (some? seq)
            (ValSeq'new-2 seq, nil)
        )
    )

    (defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" map]
        (when (some? map)
            (let [#_"ISeq" seq (.seq map)]
                (when (some? seq)
                    (ValSeq'new-2 seq, map)
                )
            )
        )
    )

    (defn- #_"ValSeq" ValSeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"ValSeq" ValSeq'new-2 [#_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-0) (ValSeq'init))]
            (assoc this :seq seq :iterable iterable)
        )
    )

    (defn- #_"ValSeq" ValSeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-1 meta) (ValSeq'init))]
            (assoc this :seq seq :iterable iterable)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ValSeq [#_"ValSeq" this]
        (.getValue (cast Map$Entry (.first (:seq this))))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ValSeq [#_"ValSeq" this]
        (ValSeq'create this, (.next (:seq this)))
    )

    #_override
    (defn #_"ValSeq" IObj'''withMeta--ValSeq [#_"ValSeq" this, #_"IPersistentMap" meta]
        (ValSeq'new-3 meta, (:seq this), (:iterable this))
    )

    #_foreign
    (defn #_"Iterator" iterator---ValSeq [#_"ValSeq" this]
        (cond
            (nil? (:iterable this))
                (.iterator (ยง super ))
            (instance? IMapIterable (:iterable this))
                (.valIterator (cast IMapIterable (:iterable this)))
            :else
                (let [#_"Iterator" it (.iterator (:iterable this))]
                    (reify Iterator
                        #_foreign
                        (#_"boolean" hasNext [#_"Iterator" _self]
                            (.hasNext it)
                        )

                        #_foreign
                        (#_"Object" next [#_"Iterator" _self]
                            (.getValue (cast Map$Entry (.next it)))
                        )
                    )
                )
        )
    )
)

(class-ns APersistentMap
    (defn- #_"APersistentMap" APersistentMap'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"APersistentMap" APersistentMap'new []
        (merge (AFn'new) (APersistentMap'init))
    )

    #_foreign
    (defn #_"String" toString---APersistentMap [#_"APersistentMap" this]
        (RT'printString this)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''cons--APersistentMap [#_"APersistentMap" this, #_"Object" o]
        (cond
            (instance? Map$Entry o)
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (.assoc this, (.getKey e), (.getValue e))
                )
            (instance? IPersistentVector o)
                (let [#_"IPersistentVector" v (cast IPersistentVector o)]
                    (when (= (.count v) 2) => (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                        (.assoc this, (.nth v, 0), (.nth v, 1))
                    )
                )
            :else
                (loop-when [#_"IPersistentMap" m this #_"ISeq" s (RT'seq o)] (some? s) => m
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (recur (.assoc m, (.getKey e), (.getValue e)) (.next s))
                    )
                )
        )
    )

    #_foreign
    (defn #_"boolean" equals---APersistentMap [#_"APersistentMap" this, #_"Object" obj]
        (APersistentMap'mapEquals this, obj)
    )

    (defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" m1, #_"Object" obj]
        (cond
            (= m1 obj)
                true
            (not (instance? Map obj))
                false
            :else
                (let-when [#_"Map" m (cast Map obj)] (= (.size m) (.count m1)) => false
                    (loop-when [#_"ISeq" s (.seq m1)] (some? s) => true
                        (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e)]
                            (and (.containsKey m, k) (Util'equals (.getValue e), (.get m, k))
                                (recur (.next s))
                            )
                        )
                    )
                )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--APersistentMap [#_"APersistentMap" this, #_"Object" obj]
        (cond
            (not (instance? Map obj))
                false
            (and (instance? IPersistentMap obj) (not (instance? MapEquivalence obj)))
                false
            :else
                (let-when [#_"Map" m (cast Map obj)] (= (.size m) (.size this)) => false
                    (loop-when [#_"ISeq" s (.seq this)] (some? s) => true
                        (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e)]
                            (and (.containsKey m, k) (Util'equiv-2oo (.getValue e), (.get m, k))
                                (recur (.next s))
                            )
                        )
                    )
                )
        )
    )

    #_foreign
    (defn #_"int" hashCode---APersistentMap [#_"APersistentMap" this]
        (let-when [#_"int" cached (:_hash this)] (zero? cached) => cached
            (let [cached (APersistentMap'mapHash this)]
                (ร ass this (assoc this :_hash cached))
                cached
            )
        )
    )

    (defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" m]
        (loop-when [#_"int" hash 0 #_"ISeq" s (.seq m)] (some? s) => hash
            (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e) #_"Object" v (.getValue e)]
                (recur (+ hash (bit-xor (if (some? k) (.hashCode k) 0) (if (some? v) (.hashCode v) 0))) (.next s))
            )
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--APersistentMap [#_"APersistentMap" this]
        (let-when [#_"int" cached (:_hasheq this)] (zero? cached) => cached
            (let [cached (Murmur3'hashUnordered this)]
                (ร ass this (assoc this :_hasheq cached))
                cached
            )
        )
    )

    (defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" m]
        (Murmur3'hashUnordered m)
    )

    (defn #_"Object" APersistentMap'MAKE_ENTRY [#_"Object" key, #_"Object" val]
        (MapEntry'create key, val)
    )

    (defn #_"Object" APersistentMap'MAKE_KEY [#_"Object" key, #_"Object" val]
        key
    )

    (defn #_"Object" APersistentMap'MAKE_VAL [#_"Object" key, #_"Object" val]
        val
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--APersistentMap [#_"APersistentMap" this, #_"Object" arg1]
        (.valAt this, arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--APersistentMap [#_"APersistentMap" this, #_"Object" arg1, #_"Object" notFound]
        (.valAt this, arg1, notFound)
    )

    #_method
    (defn #_"boolean" APersistentMap''containsValue [#_"APersistentMap" this, #_"Object" value]
        (.contains (APersistentMap''values this), value)
    )

    #_foreign
    (defn #_"Set" entrySet---APersistentMap [#_"APersistentMap" this!]
        (proxy [AbstractSet] []
            #_foreign
            (#_"Iterator" iterator [#_"AbstractSet" #_this]
                (.iterator this!)
            )

            #_foreign
            (#_"int" size [#_"AbstractSet" #_this]
                (.count this!)
            )

            #_foreign
            (#_"int" hashCode [#_"AbstractSet" #_this]
                (.hashCode this!)
            )

            #_foreign
            (#_"boolean" contains [#_"AbstractSet" #_this, #_"Object" o]
                (and (instance? Map$Entry o)
                    (let [#_"Map$Entry" e (cast Map$Entry o) #_"Map$Entry" found (.entryAt this!, (.getKey e))]
                        (and (some? found) (Util'equals (.getValue found), (.getValue e)))
                    )
                )
            )
        )
    )

    #_foreign
    (defn #_"Object" get---APersistentMap [#_"APersistentMap" this, #_"Object" key]
        (.valAt this, key)
    )

    #_method
    (defn #_"Set" APersistentMap''keySet [#_"APersistentMap" this!]
        (proxy [AbstractSet] []
            #_foreign
            (#_"Iterator" iterator [#_"AbstractSet" #_this]
                (let [#_"Iterator" it (.iterator this!)]
                    (reify Iterator
                        #_foreign
                        (#_"boolean" hasNext [#_"Iterator" _self]
                            (.hasNext it)
                        )

                        #_foreign
                        (#_"Object" next [#_"Iterator" _self]
                            (.getKey (cast Map$Entry (.next it)))
                        )
                    )
                )
            )

            #_foreign
            (#_"int" size [#_"AbstractSet" #_this]
                (.count this!)
            )

            #_foreign
            (#_"boolean" contains [#_"AbstractSet" #_this, #_"Object" o]
                (.containsKey this!, o)
            )
        )
    )

    #_foreign
    (defn #_"int" size---APersistentMap [#_"APersistentMap" this]
        (.count this)
    )

    #_method
    (defn #_"Collection" APersistentMap''values [#_"APersistentMap" this!]
        (proxy [AbstractCollection] []
            #_foreign
            (#_"Iterator" iterator [#_"AbstractCollection" #_this]
                (let [#_"Iterator" it (.iterator this!)]
                    (reify Iterator
                        #_foreign
                        (#_"boolean" hasNext [#_"Iterator" _self]
                            (.hasNext it)
                        )

                        #_foreign
                        (#_"Object" next [#_"Iterator" _self]
                            (.getValue (cast Map$Entry (.next it)))
                        )
                    )
                )
            )

            #_foreign
            (#_"int" size [#_"AbstractCollection" #_this]
                (.count this!)
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(class-ns APersistentSet
    (defn- #_"APersistentSet" APersistentSet'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
            #_"IPersistentMap" :impl nil
        )
    )

    (defn #_"APersistentSet" APersistentSet'new [#_"IPersistentMap" impl]
        (let [this (merge (AFn'new) (APersistentSet'init))]
            (assoc this :impl impl)
        )
    )

    #_foreign
    (defn #_"String" toString---APersistentSet [#_"APersistentSet" this]
        (RT'printString this)
    )

    #_override
    (defn #_"boolean" IPersistentSet'''contains--APersistentSet [#_"APersistentSet" this, #_"Object" key]
        (.containsKey (:impl this), key)
    )

    #_override
    (defn #_"Object" IPersistentSet'''get--APersistentSet [#_"APersistentSet" this, #_"Object" key]
        (.valAt (:impl this), key)
    )

    #_override
    (defn #_"int" Counted'''count--APersistentSet [#_"APersistentSet" this]
        (.count (:impl this))
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--APersistentSet [#_"APersistentSet" this]
        (RT'keys (:impl this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--APersistentSet [#_"APersistentSet" this, #_"Object" arg1]
        (.get this, arg1)
    )

    #_foreign
    (defn #_"boolean" equals---APersistentSet [#_"APersistentSet" this, #_"Object" obj]
        (APersistentSet'setEquals this, obj)
    )

    (defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" s1, #_"Object" obj]
        (or (= s1 obj)
            (and (instance? Set obj)
                (let-when [#_"Set" m (cast Set obj)] (= (.size m) (.count s1)) => false
                    (loop-when [#_"Iterator" it (.iterator m)] (.hasNext it) => true
                        (and (.contains s1, (.next it)) (recur it))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--APersistentSet [#_"APersistentSet" this, #_"Object" obj]
        (and (instance? Set obj)
            (let-when [#_"Set" m (cast Set obj)] (= (.size m) (.size this)) => false
                (loop-when [#_"Iterator" it (.iterator m)] (.hasNext it) => true
                    (and (.contains this, (.next it)) (recur it))
                )
            )
        )
    )

    #_foreign
    (defn #_"int" hashCode---APersistentSet [#_"APersistentSet" this]
        (let-when [#_"int" hash (:_hash this)] (zero? hash) => hash
            (let [hash
                    (loop-when [hash 0 #_"ISeq" s (.seq this)] (some? s) => hash
                        (recur (+ hash (Util'hash (.first s))) (.next s))
                    )]
                (ร ass this (assoc this :_hash hash))
                hash
            )
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--APersistentSet [#_"APersistentSet" this]
        (let-when [#_"int" cached (:_hasheq this)] (zero? cached) => cached
            (let [cached (Murmur3'hashUnordered this)]
                (ร ass this (assoc this :_hasheq cached))
                cached
            )
        )
    )

    #_foreign
    (defn #_"Object[]" toArray---APersistentSet [#_"APersistentSet" this]
        (RT'seqToArray (.seq this))
    )

    #_foreign
    (defn #_"Object[]" toArray---APersistentSet [#_"APersistentSet" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_foreign
    (defn #_"int" size---APersistentSet [#_"APersistentSet" this]
        (.count this)
    )

    #_foreign
    (defn #_"Iterator" iterator---APersistentSet [#_"APersistentSet" this]
        (if (instance? IMapIterable (:impl this))
            (.keyIterator (cast IMapIterable (:impl this)))
            (let [#_"Iterator" it (.iterator (:impl this))]
                (reify Iterator
                    #_foreign
                    (#_"boolean" hasNext [#_"Iterator" _self]
                        (.hasNext it)
                    )

                    #_foreign
                    (#_"Object" next [#_"Iterator" _self]
                        (.key (cast IMapEntry (.next it)))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(class-ns VSeq
    (defn- #_"VSeq" VSeq'init []
        (hash-map
            ;; todo - something more efficient
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"VSeq" VSeq'new-2 [#_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-0) (VSeq'init))]
            (assoc this :v v :i i)
        )
    )

    (defn #_"VSeq" VSeq'new-3 [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (VSeq'init))]
            (assoc this :v v :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--VSeq [#_"VSeq" this]
        (.nth (:v this), (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--VSeq [#_"VSeq" this]
        (when (< (inc (:i this)) (.count (:v this)))
            (VSeq'new-2 (:v this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" IndexedSeq'''index--VSeq [#_"VSeq" this]
        (:i this)
    )

    #_override
    (defn #_"int" Counted'''count--VSeq [#_"VSeq" this]
        (- (.count (:v this)) (:i this))
    )

    #_override
    (defn #_"VSeq" IObj'''withMeta--VSeq [#_"VSeq" this, #_"IPersistentMap" meta]
        (VSeq'new-3 meta, (:v this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--VSeq [#_"VSeq" this, #_"IFn" f]
        (let [#_"IPersistentVector" v (:v this) #_"int" i (:i this) #_"int" n (.count v)]
            (loop-when [#_"Object" r (.nth v, i) i (inc i)] (< i n) => r
                (let-when [r (.invoke f, r, (.nth v, i))] (RT'isReduced r) => (recur r (inc i))
                    (.deref (cast IDeref r))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--VSeq [#_"VSeq" this, #_"IFn" f, #_"Object" r]
        (let [#_"IPersistentVector" v (:v this) #_"int" i (:i this) #_"int" n (.count v)]
            (loop-when [r (.invoke f, r, (.nth v, i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (when (RT'isReduced r) => (recur (.invoke f, r, (.nth v, i)) (inc i))
                    (.deref (cast IDeref r))
                )
            )
        )
    )
)

(class-ns RSeq
    (defn- #_"RSeq" RSeq'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"RSeq" RSeq'new-2 [#_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-0) (RSeq'init))]
            (assoc this :v v :i i)
        )
    )

    (defn #_"RSeq" RSeq'new-3 [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (RSeq'init))]
            (assoc this :v v :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--RSeq [#_"RSeq" this]
        (.nth (:v this), (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--RSeq [#_"RSeq" this]
        (when (pos? (:i this))
            (RSeq'new-2 (:v this), (dec (:i this)))
        )
    )

    #_override
    (defn #_"int" IndexedSeq'''index--RSeq [#_"RSeq" this]
        (:i this)
    )

    #_override
    (defn #_"int" Counted'''count--RSeq [#_"RSeq" this]
        (inc (:i this))
    )

    #_override
    (defn #_"RSeq" IObj'''withMeta--RSeq [#_"RSeq" this, #_"IPersistentMap" meta]
        (RSeq'new-3 meta, (:v this), (:i this))
    )
)

(class-ns APersistentVector
    (defn- #_"APersistentVector" APersistentVector'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"APersistentVector" APersistentVector'new []
        (merge (AFn'new) (APersistentVector'init))
    )

    #_foreign
    (defn #_"String" toString---APersistentVector [#_"APersistentVector" this]
        (RT'printString this)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--APersistentVector [#_"APersistentVector" this]
        (when (pos? (.count this))
            (VSeq'new-2 this, 0)
        )
    )

    #_override
    (defn #_"ISeq" Reversible'''rseq--APersistentVector [#_"APersistentVector" this]
        (when (pos? (.count this))
            (RSeq'new-2 this, (dec (.count this)))
        )
    )

    (defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" v, #_"Object" obj]
        (cond
            (instance? IPersistentVector obj)
                (let-when [#_"IPersistentVector" ov (cast IPersistentVector obj)] (= (.count ov) (.count v)) => false
                    (loop-when [#_"int" i 0] (< i (.count v)) => true
                        (recur-if (Util'equals (.nth v, i), (.nth ov, i)) [(inc i)] => false)
                    )
                )
            (instance? List obj)
                (let-when [#_"Collection" ma (cast Collection obj)] (and (= (.size ma) (.count v)) (= (.hashCode ma) (.hashCode v))) => false
                    (loop-when [#_"Iterator" i1 (.iterator (cast List v)) #_"Iterator" i2 (.iterator ma)] (.hasNext i1) => true
                        (recur-if (Util'equals (.next i1), (.next i2)) [i1 i2] => false)
                    )
                )
            :else
                (when (instance? Sequential obj) => false
                    (loop-when [#_"int" i 0 #_"ISeq" ms (RT'seq obj)] (< i (.count v)) => (nil? ms)
                        (recur-if (and (some? ms) (Util'equals (.nth v, i), (.first ms))) [(inc i) (.next ms)] => false)
                    )
                )
        )
    )

    (defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" v, #_"Object" obj]
        (cond
            (instance? IPersistentVector obj)
                (let-when [#_"IPersistentVector" ov (cast IPersistentVector obj)] (= (.count ov) (.count v)) => false
                    (loop-when [#_"int" i 0] (< i (.count v)) => true
                        (recur-if (Util'equiv-2oo (.nth v, i), (.nth ov, i)) [(inc i)] => false)
                    )
                )
            (instance? List obj)
                (let-when [#_"Collection" ma (cast Collection obj)] (= (.size ma) (.count v)) => false
                    (loop-when [#_"Iterator" i1 (.iterator (cast List v)) #_"Iterator" i2 (.iterator ma)] (.hasNext i1) => true
                        (recur-if (Util'equiv-2oo (.next i1), (.next i2)) [i1 i2] => false)
                    )
                )
            :else
                (when (instance? Sequential obj) => false
                    (loop-when [#_"int" i 0 #_"ISeq" ms (RT'seq obj)] (< i (.count v)) => (nil? ms)
                        (recur-if (and (some? ms) (Util'equiv-2oo (.nth v, i), (.first ms))) [(inc i) (.next ms)] => false)
                    )
                )
        )
    )

    #_foreign
    (defn #_"boolean" equals---APersistentVector [#_"APersistentVector" this, #_"Object" obj]
        (or (= obj this) (APersistentVector'doEquals this, obj))
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--APersistentVector [#_"APersistentVector" this, #_"Object" obj]
        (or (= obj this) (APersistentVector'doEquiv this, obj))
    )

    #_foreign
    (defn #_"int" hashCode---APersistentVector [#_"APersistentVector" this]
        (let-when [#_"int" hash (:_hash this)] (zero? hash) => hash
            (let [hash
                    (loop-when [hash 1 #_"int" i 0] (< i (.count this)) => hash
                        (let [#_"Object" obj (.nth this, i)]
                            (recur (+ (* 31 hash) (if (some? obj) (.hashCode obj) 0)) (inc i))
                        )
                    )]
                (ร ass this (assoc this :_hash hash))
                hash
            )
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--APersistentVector [#_"APersistentVector" this]
        (let-when [#_"int" hash (:_hasheq this)] (zero? hash) => hash
            (let [hash
                    (loop-when [hash 1 #_"int" i 0] (< i (.count this)) => (Murmur3'mixCollHash hash, i)
                        (recur (+ (* 31 hash) (Util'hasheq (.nth this, i))) (inc i))
                    )]
                (ร ass this (assoc this :_hasheq hash))
                hash
            )
        )
    )

    #_foreign
    (defn #_"Object" get---APersistentVector [#_"APersistentVector" this, #_"int" index]
        (.nth this, index)
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--APersistentVector [#_"APersistentVector" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (.count this)) (.nth this, i) notFound)
    )

    #_override
    (defn #_"Iterator" APersistentVector'''rangedIterator--APersistentVector [#_"APersistentVector" this, #_"int" start, #_"int" end]
        (let [#_"int'" vi (volatile! start)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (< @vi end)
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (when (< @vi end) => (throw (NoSuchElementException.))
                        (let [_ (.nth this, @vi)]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--APersistentVector [#_"APersistentVector" this, #_"Object" arg1]
        (if (Util'isInteger arg1)
            (.nth this, (.intValue (cast Number arg1)))
            (throw (IllegalArgumentException. "Key must be integer"))
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---APersistentVector [#_"APersistentVector" this]
        (let [#_"int'" vi (volatile! 0)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (< @vi (.count this))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (when (< @vi (.count this)) => (throw (NoSuchElementException.))
                        (let [_ (.nth this, @vi)]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--APersistentVector [#_"APersistentVector" this]
        (when (pos? (.count this))
            (.nth this, (dec (.count this)))
        )
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--APersistentVector [#_"APersistentVector" this, #_"Object" key]
        (and (Util'isInteger key) (< -1 (.intValue (cast Number key)) (.count this)))
    )

    #_override
    (defn #_"IMapEntry" Associative'''entryAt--APersistentVector [#_"APersistentVector" this, #_"Object" key]
        (when (Util'isInteger key)
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (.count this))
                (cast IMapEntry (MapEntry'create key, (.nth this, i)))
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" Associative'''assoc--APersistentVector [#_"APersistentVector" this, #_"Object" key, #_"Object" val]
        (when (Util'isInteger key) => (throw (IllegalArgumentException. "Key must be integer"))
            (.assocN this, (.intValue (cast Number key)), val)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--APersistentVector [#_"APersistentVector" this, #_"Object" key, #_"Object" notFound]
        (when (Util'isInteger key) => notFound
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (.count this)) => notFound
                (.nth this, i)
            )
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--APersistentVector [#_"APersistentVector" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_foreign
    (defn #_"Object[]" toArray---APersistentVector [#_"APersistentVector" this]
        (let [#_"Object[]" a (make-array Object (.count this))]
            (dotimes [#_"int" i (.count this)]
                (aset a i (.nth this, i))
            )
            a
        )
    )

    #_foreign
    (defn #_"Object[]" toArray---APersistentVector [#_"APersistentVector" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_foreign
    (defn #_"int" size---APersistentVector [#_"APersistentVector" this]
        (.count this)
    )

    #_foreign
    (defn #_"boolean" contains---APersistentVector [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_override
    (defn #_"int" IPersistentVector'''length--APersistentVector [#_"APersistentVector" this]
        (.count this)
    )

    #_foreign
    (defn #_"int" compareTo---APersistentVector [#_"APersistentVector" this, #_"Object" o]
        (let [#_"IPersistentVector" v (cast IPersistentVector o) #_"int" n (.count this) #_"int" m (.count v)]
            (cond (< n m) -1 (< m n) 1
                :else
                    (loop-when [#_"int" i 0] (< i n) => 0
                        (let [#_"int" cmp (Util'compare (.nth this, i), (.nth v, i))]
                            (recur-if (zero? cmp) [(inc i)] => cmp)
                        )
                    )
            )
        )
    )
)

(class-ns SubVector
    (defn- #_"SubVector" SubVector'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :start 0
            #_"int" :end 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"SubVector" SubVector'new [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" start, #_"int" end]
        (let [this (merge (APersistentVector'new) (SubVector'init))
              this (assoc this :_meta meta)]
            (when (instance? SubVector v) => (assoc this :v v :start start :end end)
                (let [#_"SubVector" sv (cast SubVector v)]
                    (assoc this :v (:v sv) :start (+ start (:start sv)) :end (+ end (:start sv)))
                )
            )
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---SubVector [#_"SubVector" this]
        (if (instance? APersistentVector (:v this))
            (.rangedIterator (cast APersistentVector (:v this)), (:start this), (:end this))
            (.iterator (ยง super ))
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--SubVector [#_"SubVector" this, #_"int" i]
        (if (and (<= 0 i) (< (+ (:start this) i) (:end this)))
            (.nth (:v this), (+ (:start this) i))
            (throw (IndexOutOfBoundsException.))
        )
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''assocN--SubVector [#_"SubVector" this, #_"int" i, #_"Object" val]
        (cond
            (< (:end this) (+ (:start this) i)) (throw (IndexOutOfBoundsException.))
            (= (+ (:start this) i) (:end this)) (.cons this, val)
            :else (SubVector'new (:_meta this), (.assocN (:v this), (+ (:start this) i), val), (:start this), (:end this))
        )
    )

    #_override
    (defn #_"int" Counted'''count--SubVector [#_"SubVector" this]
        (- (:end this) (:start this))
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''cons--SubVector [#_"SubVector" this, #_"Object" o]
        (SubVector'new (:_meta this), (.assocN (:v this), (:end this), o), (:start this), (inc (:end this)))
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--SubVector [#_"SubVector" this]
        (.withMeta PersistentVector'EMPTY, (.meta this))
    )

    #_override
    (defn #_"IPersistentStack" IPersistentStack'''pop--SubVector [#_"SubVector" this]
        (if (= (dec (:end this)) (:start this))
            PersistentVector'EMPTY
            (SubVector'new (:_meta this), (:v this), (:start this), (dec (:end this)))
        )
    )

    #_override
    (defn #_"SubVector" IObj'''withMeta--SubVector [#_"SubVector" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (SubVector'new meta, (:v this), (:start this), (:end this))
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--SubVector [#_"SubVector" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.AMapEntry

(class-ns AMapEntry
    (defn #_"AMapEntry" AMapEntry'new []
        (APersistentVector'new)
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--AMapEntry [#_"AMapEntry" this, #_"int" i]
        (case i 0 (.key this) 1 (.val this) (throw (IndexOutOfBoundsException.)))
    )

    #_method
    (defn- #_"IPersistentVector" AMapEntry''asVector [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (.key this), (.val this))
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''assocN--AMapEntry [#_"AMapEntry" this, #_"int" i, #_"Object" val]
        (.assocN (AMapEntry''asVector this), i, val)
    )

    #_override
    (defn #_"int" Counted'''count--AMapEntry [#_"AMapEntry" this]
        2
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--AMapEntry [#_"AMapEntry" this]
        (.seq (AMapEntry''asVector this))
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''cons--AMapEntry [#_"AMapEntry" this, #_"Object" o]
        (.cons (AMapEntry''asVector this), o)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--AMapEntry [#_"AMapEntry" this]
        nil
    )

    #_override
    (defn #_"IPersistentStack" IPersistentStack'''pop--AMapEntry [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (.key this))
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference
    (defn- #_"AReference" AReference'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"AReference" AReference'new-0 []
        (AReference'new-1 nil)
    )

    (defn #_"AReference" AReference'new-1 [#_"IPersistentMap" meta]
        (let [this (AReference'init)]
            (assoc this :_meta meta)
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--AReference [#_"AReference" this]
        (ยง sync this
            (:_meta this)
        )
    )

    #_override
    (defn #_"IPersistentMap" IReference'''alterMeta--AReference [#_"AReference" this, #_"IFn" alter, #_"ISeq" args]
        (ยง sync this
            (let [#_"IPersistentMap" m (cast IPersistentMap (.applyTo alter, (Cons'new-2 (:_meta this), args)))]
                (ร ass this (assoc this :_meta m))
                (:_meta this)
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IReference'''resetMeta--AReference [#_"AReference" this, #_"IPersistentMap" m]
        (ยง sync this
            (ร ass this (assoc this :_meta m))
            m
        )
    )
)
)

(java-ns cloiure.lang.ARef

(class-ns ARef
    (defn- #_"ARef" ARef'init []
        (hash-map
            #_volatile
            #_"IFn" :validator nil
            #_volatile
            #_"IPersistentMap" :watches PersistentHashMap'EMPTY
        )
    )

    (defn #_"ARef" ARef'new-0 []
        (merge (AReference'new-0) (ARef'init))
    )

    (defn #_"ARef" ARef'new-1 [#_"IPersistentMap" meta]
        (merge (AReference'new-1 meta) (ARef'init))
    )

    #_method
    (defn #_"void" ARef''validate-3 [#_"ARef" this, #_"IFn" vf, #_"Object" val]
        (try
            (when (and (some? vf) (not (RT'booleanCast-1o (.invoke vf, val))))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException re
                (throw re)
            )
            (catch Exception e
                (throw (IllegalStateException. "Invalid reference state", e))
            )
        )
        nil
    )

    #_method
    (defn #_"void" ARef''validate-2 [#_"ARef" this, #_"Object" val]
        (ARef''validate-3 this, (:validator this), val)
        nil
    )

    #_override
    (defn #_"void" IRef'''setValidator--ARef [#_"ARef" this, #_"IFn" vf]
        (ARef''validate-3 this, vf, (.deref this))
        (ร ass this (assoc this :validator vf))
        nil
    )

    #_override
    (defn #_"IFn" IRef'''getValidator--ARef [#_"ARef" this]
        (:validator this)
    )

    #_override
    (defn #_"IPersistentMap" IRef'''getWatches--ARef [#_"ARef" this]
        (:watches this)
    )

    #_override
    (defn #_"IRef" IRef'''addWatch--ARef [#_"ARef" this, #_"Object" key, #_"IFn" callback]
        (ยง sync this
            (assoc this :watches (.assoc (:watches this), key, callback))
        )
    )

    #_override
    (defn #_"IRef" IRef'''removeWatch--ARef [#_"ARef" this, #_"Object" key]
        (ยง sync this
            (assoc this :watches (.without (:watches this), key))
        )
    )

    #_method
    (defn #_"void" ARef''notifyWatches [#_"ARef" this, #_"Object" oldval, #_"Object" newval]
        (let-when [#_"IPersistentMap" ws (:watches this)] (pos? (.count ws))
            (loop-when-recur [#_"ISeq" s (.seq ws)] (some? s) [(.next s)]
                (let [#_"Map$Entry" e (cast Map$Entry (.first s))
                      #_"IFn" fn (cast IFn (.getValue e))]
                    (when (some? fn)
                        (.invoke fn, (.getKey e), this, oldval, newval)
                    )
                )
            )
        )
        nil
    )
)
)

(java-ns cloiure.lang.Agent

(class-ns ActionQueue
    (ยง def #_"ActionQueue" ActionQueue'EMPTY (ActionQueue'new PersistentQueue'EMPTY, nil))

    (defn- #_"ActionQueue" ActionQueue'init []
        (hash-map
            #_"IPersistentStack" :q nil
            #_"Throwable" :error nil ;; non-null indicates fail state
        )
    )

    (defn #_"ActionQueue" ActionQueue'new [#_"IPersistentStack" q, #_"Throwable" error]
        (let [this (ActionQueue'init)]
            (assoc this :q q :error error)
        )
    )
)

(class-ns AgentAction
    (defn- #_"AgentAction" AgentAction'init []
        (hash-map
            #_"Agent" :agent nil
            #_"IFn" :fn nil
            #_"ISeq" :args nil
            #_"Executor" :exec nil
        )
    )

    (defn #_"AgentAction" AgentAction'new [#_"Agent" agent, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let [this (AgentAction'init)]
            (assoc this :agent agent :args args :fn fn :exec exec)
        )
    )

    #_method
    (defn #_"void" AgentAction''execute [#_"AgentAction" this]
        (try
            (.execute (:exec this), this)
            (catch Throwable error
                (when (some? (:errorHandler (:agent this)))
                    (try
                        (.invoke (:errorHandler (:agent this)), (:agent this), error)
                        (catch Throwable e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AgentAction'doRun [#_"AgentAction" action]
        (try
            (.set Agent'nested, PersistentVector'EMPTY)
            (let [#_"Throwable" error
                    (try
                        (let [#_"Object" oldval (:state (:agent action))
                              #_"Object" newval (.applyTo (:fn action), (RT'cons (:state (:agent action)), (:args action)))]
                            (Agent''setState (:agent action), newval)
                            (ARef''notifyWatches (:agent action), oldval, newval)
                            nil
                        )
                        (catch Throwable error
                            error
                        )
                    )
                  error
                    (when (some? error) => (do (Agent'releasePendingSends) nil)
                        (.set Agent'nested, nil) ;; allow errorHandler to send
                        (when (some? (:errorHandler (:agent action)))
                            (try
                                (.invoke (:errorHandler (:agent action)), (:agent action), error)
                                (catch Throwable _
                                    ;; ignore errorHandler errors
                                )
                            )
                        )
                        (when (= (:errorMode (:agent action)) Agent'CONTINUE) => error
                            nil
                        )
                    )
                  #_"ActionQueue" next
                    (loop-when [next nil #_"boolean" popped false] (not popped) => next
                        (let [#_"ActionQueue" prior (.get (:aq (:agent action))) next (ActionQueue'new (.pop (:q prior)), error)]
                            (recur next (.compareAndSet (:aq (:agent action)), prior, next))
                        )
                    )]
                (when (and (nil? error) (pos? (.count (:q next))))
                    (AgentAction''execute (cast AgentAction (.peek (:q next))))
                )
            )
            (finally
                (.set Agent'nested, nil)
            )
        )
        nil
    )

    #_foreign
    (defn #_"void" run---AgentAction [#_"AgentAction" this]
        (AgentAction'doRun this)
        nil
    )
)

(class-ns Agent
    (ยง def #_"Keyword" Agent'CONTINUE (Keyword'intern (Symbol'intern nil, "continue")))
    (ยง def #_"Keyword" Agent'FAIL (Keyword'intern (Symbol'intern nil, "fail")))

    (def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" format, #_"AtomicLong" threadPoolCounter]
        (reify ThreadFactory
            #_foreign
            (#_"Thread" newThread [#_"ThreadFactory" _self, #_"Runnable" runnable]
                (let [#_"Thread" thread (Thread. runnable)]
                    (.setName thread, (String/format format, (object-array [ (.getAndIncrement threadPoolCounter) ])))
                    thread
                )
            )
        )
    )

    #_volatile
    (ยง def #_"ExecutorService" Agent'pooledExecutor (Executors/newFixedThreadPool (+ 2 (.availableProcessors (Runtime/getRuntime))), (Agent'createThreadFactory "cloiure-agent-send-pool-%d", Agent'sendThreadPoolCounter)))

    #_volatile
    (ยง def #_"ExecutorService" Agent'soloExecutor (Executors/newCachedThreadPool (Agent'createThreadFactory "cloiure-agent-send-off-pool-%d", Agent'sendOffThreadPoolCounter)))

    (def #_"ThreadLocal<IPersistentVector>" Agent'nested (ThreadLocal.))

    (defn #_"void" Agent'shutdown []
        (.shutdown Agent'soloExecutor)
        (.shutdown Agent'pooledExecutor)
        nil
    )

    (defn- #_"Agent" Agent'init []
        (hash-map
            #_volatile
            #_"Object" :state nil
            #_"AtomicReference<ActionQueue>" :aq (AtomicReference. ActionQueue'EMPTY)

            #_volatile
            #_"Keyword" :errorMode Agent'CONTINUE
            #_volatile
            #_"IFn" :errorHandler nil
        )
    )

    (defn #_"Agent" Agent'new-1 [#_"Object" state]
        (Agent'new-2 state, nil)
    )

    (defn #_"Agent" Agent'new-2 [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Agent'init))]
            (Agent''setState this, state)
            this
        )
    )

    #_method
    (defn #_"boolean" Agent''setState [#_"Agent" this, #_"Object" newState]
        (ARef''validate-2 this, newState)
        (let [#_"boolean" ret (not= (:state this) newState)]
            (ร ass this (assoc this :state newState))
            ret
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Agent [#_"Agent" this]
        (:state this)
    )

    #_method
    (defn #_"Throwable" Agent''getError [#_"Agent" this]
        (:error (.get (:aq this)))
    )

    #_method
    (defn #_"void" Agent''setErrorMode [#_"Agent" this, #_"Keyword" k]
        (ร ass this (assoc this :errorMode k))
        nil
    )

    #_method
    (defn #_"Keyword" Agent''getErrorMode [#_"Agent" this]
        (:errorMode this)
    )

    #_method
    (defn #_"void" Agent''setErrorHandler [#_"Agent" this, #_"IFn" f]
        (ร ass this (assoc this :errorHandler f))
        nil
    )

    #_method
    (defn #_"IFn" Agent''getErrorHandler [#_"Agent" this]
        (:errorHandler this)
    )

    #_method
    (defn #_"Object" Agent''restart [#_"Agent" this, #_"Object" newState, #_"boolean" clearActions]
        (ยง sync this
            (when (some? (Agent''getError this)) => (throw (RuntimeException. "Agent does not need a restart"))
                (ARef''validate-2 this, newState)
                (ร ass this (assoc this :state newState))
                (when-not clearActions => (.set (:aq this), ActionQueue'EMPTY)
                    (let [#_"ActionQueue" prior
                            (loop-when [prior nil #_"boolean" restarted false] (not restarted) => prior
                                (let [prior (.get (:aq this))]
                                    (recur prior (.compareAndSet (:aq this), prior, (ActionQueue'new (:q prior), nil)))
                                )
                            )]
                        (when (pos? (.count (:q prior)))
                            (AgentAction''execute (cast AgentAction (.peek (:q prior))))
                        )
                    )
                )
                newState
            )
        )
    )

    #_method
    (defn #_"Object" Agent''dispatch [#_"Agent" this, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let-when [#_"Throwable" e (Agent''getError this)] (nil? e) => (throw (RuntimeException. "Agent is failed, needs restart", e))
            (Agent'dispatchAction (AgentAction'new this, fn, args, exec))
            this
        )
    )

    (defn #_"void" Agent'dispatchAction [#_"AgentAction" action]
        (let [#_"LockingTransaction" trans (LockingTransaction'getRunning)]
            (cond
                (some? trans)               (LockingTransaction''enqueue trans, action)
                (some? (.get Agent'nested)) (.set Agent'nested, (.cons (.get Agent'nested), action))
                :else                       (Agent''enqueue (:agent action), action)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Agent''enqueue [#_"Agent" this, #_"AgentAction" action]
        (let [#_"ActionQueue" prior
                (loop-when [prior nil #_"boolean" queued false] (not queued) => prior
                    (let [prior (.get (:aq this))]
                        (recur prior (.compareAndSet (:aq this), prior, (ActionQueue'new (cast IPersistentStack (.cons (:q prior), action)), (:error prior))))
                    )
                )]
            (when (and (zero? (.count (:q prior))) (nil? (:error prior)))
                (AgentAction''execute action)
            )
        )
        nil
    )

    #_method
    (defn #_"int" Agent''getQueueCount [#_"Agent" this]
        (.count (:q (.get (:aq this))))
    )

    (defn #_"int" Agent'releasePendingSends []
        (let-when [#_"IPersistentVector" sends (.get Agent'nested)] (some? sends) => 0
            (dotimes [#_"int" i (.count sends)]
                (let [#_"AgentAction" a (cast AgentAction (.valAt sends, i))]
                    (Agent''enqueue (:agent a), a)
                )
            )
            (.set Agent'nested, PersistentVector'EMPTY)
            (.count sends)
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException
    (defn- #_"ArityException" ArityException'init []
        (hash-map
            #_"int" :actual 0
            #_"String" :name nil
        )
    )

    (defn #_"ArityException" ArityException'new-2 [#_"int" actual, #_"String" name]
        (ArityException'new-3 actual, name, nil)
    )

    (defn #_"ArityException" ArityException'new-3 [#_"int" actual, #_"String" name, #_"Throwable" cause]
        (let [this (merge (ยง foreign IllegalArgumentException'new (str "Wrong number of args (" actual ") passed to: " name), cause) (ArityException'init))]
            (assoc this :actual actual :name name)
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk
    (defn- #_"ArrayChunk" ArrayChunk'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :off 0
            #_"int" :end 0
        )
    )

    (defn #_"ArrayChunk" ArrayChunk'new-1 [#_"Object[]" array]
        (ArrayChunk'new-3 array, 0, (alength array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-2 [#_"Object[]" array, #_"int" off]
        (ArrayChunk'new-3 array, off, (alength array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-3 [#_"Object[]" array, #_"int" off, #_"int" end]
        (let [this (ArrayChunk'init)]
            (assoc this :array array :off off :end end)
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--ArrayChunk [#_"ArrayChunk" this, #_"int" i]
        (aget (:array this) (+ (:off this) i))
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--ArrayChunk [#_"ArrayChunk" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (.count this)) (.nth this, i) notFound)
    )

    #_override
    (defn #_"int" Counted'''count--ArrayChunk [#_"ArrayChunk" this]
        (- (:end this) (:off this))
    )

    #_override
    (defn #_"IChunk" IChunk'''dropFirst--ArrayChunk [#_"ArrayChunk" this]
        (when-not (= (:off this) (:end this)) => (throw (IllegalStateException. "dropFirst of empty chunk"))
            (ArrayChunk'new-3 (:array this), (inc (:off this)), (:end this))
        )
    )

    #_override
    (defn #_"Object" IChunk'''reduce--ArrayChunk [#_"ArrayChunk" this, #_"IFn" f, #_"Object" r]
        (let [r (.invoke f, r, (aget (:array this) (:off this)))]
            (when-not (RT'isReduced r) => r
                (loop-when [#_"int" i (inc (:off this))] (< i (:end this)) => r
                    (let [r (.invoke f, r, (aget (:array this) i))]
                        (when-not (RT'isReduced r) => r
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(class-ns ArrayIter_int
    (defn #_"Iterator" ArrayIter_int'new [#_"int[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Long" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (Long/valueOf (aget a @vi))]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_float
    (defn #_"Iterator" ArrayIter_float'new [#_"float[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Double" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (Double/valueOf (aget a @vi))]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_double
    (defn #_"Iterator" ArrayIter_double'new [#_"double[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Double" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (aget a @vi)]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_long
    (defn #_"Iterator" ArrayIter_long'new [#_"long[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Long" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (Long/valueOf (aget a @vi))]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_byte
    (defn #_"Iterator" ArrayIter_byte'new [#_"byte[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Byte" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (aget a @vi)]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_char
    (defn #_"Iterator" ArrayIter_char'new [#_"char[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Character" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (aget a @vi)]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_short
    (defn #_"Iterator" ArrayIter_short'new [#_"short[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Long" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (Long/valueOf (aget a @vi))]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter_boolean
    (defn #_"Iterator" ArrayIter_boolean'new [#_"boolean[]" a, #_"int" i]
        (let [#_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Boolean" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (Boolean/valueOf (aget a @vi))]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)

(class-ns ArrayIter
    (def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (reify Iterator
            #_foreign
            (#_"boolean" hasNext [#_"Iterator" _self]
                false
            )

            #_foreign
            (#_"Object" next [#_"Iterator" _self]
                (throw (NoSuchElementException.))
            )
        )
    )

    (defn #_"Iterator" ArrayIter'create-0 []
        ArrayIter'EMPTY_ITERATOR
    )

    (defn #_"Iterator" ArrayIter'create-1 [& #_"Object..." a]
        (when (and (some? a) (pos? (alength a))) => ArrayIter'EMPTY_ITERATOR
            (ArrayIter'new a, 0)
        )
    )

    (defn #_"Iterator" ArrayIter'createFromObject [#_"Object" a]
        (when (and (some? a) (pos? (Array/getLength a))) => ArrayIter'EMPTY_ITERATOR
            (let [#_"Class" c (.getClass a)]
                (condp = c
                    RT'INTS_CLASS     (ArrayIter_int'new     (cast c a), 0)
                    RT'FLOATS_CLASS   (ArrayIter_float'new   (cast c a), 0)
                    RT'DOUBLES_CLASS  (ArrayIter_double'new  (cast c a), 0)
                    RT'LONGS_CLASS    (ArrayIter_long'new    (cast c a), 0)
                    RT'BYTES_CLASS    (ArrayIter_byte'new    (cast c a), 0)
                    RT'CHARS_CLASS    (ArrayIter_char'new    (cast c a), 0)
                    RT'SHORTS_CLASS   (ArrayIter_short'new   (cast c a), 0)
                    RT'BOOLEANS_CLASS (ArrayIter_boolean'new (cast c a), 0)
                                      (ArrayIter'new                 a,  0)
                )
            )
        )
    )

    (defn #_"Iterator" ArrayIter'new [#_"Object" array, #_"int" i]
        (let [#_"Object[]" a (cast RT'OBJECTS_CLASS array) #_"int'" vi (volatile! i)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (and (some? a) (< @vi (alength a)))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (when (and (some? a) (< @vi (alength a))) => (throw (NoSuchElementException.))
                        (let [_ (aget a @vi)]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(class-ns ArraySeq_int
    (defn- #_"ArraySeq_int" ArraySeq_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_int" ArraySeq_int'new [#_"IPersistentMap" meta, #_"int[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_int'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_int [#_"ArraySeq_int" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_int [#_"ArraySeq_int" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_int'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_int [#_"ArraySeq_int" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_int [#_"ArraySeq_int" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_int" IObj'''withMeta--ArraySeq_int [#_"ArraySeq_int" this, #_"IPersistentMap" meta]
        (ArraySeq_int'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_int [#_"ArraySeq_int" this, #_"IFn" f]
        (let [#_"int[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_int [#_"ArraySeq_int" this, #_"IFn" f, #_"Object" r]
        (let [#_"int[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_float
    (defn- #_"ArraySeq_float" ArraySeq_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_float" ArraySeq_float'new [#_"IPersistentMap" meta, #_"float[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_float'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_float [#_"ArraySeq_float" this]
        (Numbers'num-1f (aget (:array this) (:i this)))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_float [#_"ArraySeq_float" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_float'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_float [#_"ArraySeq_float" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_float [#_"ArraySeq_float" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_float" IObj'''withMeta--ArraySeq_float [#_"ArraySeq_float" this, #_"IPersistentMap" meta]
        (ArraySeq_float'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_float [#_"ArraySeq_float" this, #_"IFn" f]
        (let [#_"float[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (Numbers'num-1f (aget a i)) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (Numbers'num-1f (aget a i)))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_float [#_"ArraySeq_float" this, #_"IFn" f, #_"Object" r]
        (let [#_"float[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (Numbers'num-1f (aget a i))) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (Numbers'num-1f (aget a i))) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_double
    (defn- #_"ArraySeq_double" ArraySeq_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_double" ArraySeq_double'new [#_"IPersistentMap" meta, #_"double[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_double'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_double [#_"ArraySeq_double" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_double [#_"ArraySeq_double" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_double'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_double [#_"ArraySeq_double" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_double [#_"ArraySeq_double" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_double" IObj'''withMeta--ArraySeq_double [#_"ArraySeq_double" this, #_"IPersistentMap" meta]
        (ArraySeq_double'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_double [#_"ArraySeq_double" this, #_"IFn" f]
        (let [#_"double[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_double [#_"ArraySeq_double" this, #_"IFn" f, #_"Object" r]
        (let [#_"double[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_long
    (defn- #_"ArraySeq_long" ArraySeq_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_long" ArraySeq_long'new [#_"IPersistentMap" meta, #_"long[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_long'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_long [#_"ArraySeq_long" this]
        (Numbers'num-1l (aget (:array this) (:i this)))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_long [#_"ArraySeq_long" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_long'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_long [#_"ArraySeq_long" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_long [#_"ArraySeq_long" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_long" IObj'''withMeta--ArraySeq_long [#_"ArraySeq_long" this, #_"IPersistentMap" meta]
        (ArraySeq_long'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_long [#_"ArraySeq_long" this, #_"IFn" f]
        (let [#_"long[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (Numbers'num-1l (aget a i)) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (Numbers'num-1l (aget a i)))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_long [#_"ArraySeq_long" this, #_"IFn" f, #_"Object" r]
        (let [#_"long[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (Numbers'num-1l (aget a i))) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (Numbers'num-1l (aget a i))) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_byte
    (defn- #_"ArraySeq_byte" ArraySeq_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_byte" ArraySeq_byte'new [#_"IPersistentMap" meta, #_"byte[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_byte'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_byte [#_"ArraySeq_byte" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_byte [#_"ArraySeq_byte" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_byte'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_byte [#_"ArraySeq_byte" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_byte [#_"ArraySeq_byte" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_byte" IObj'''withMeta--ArraySeq_byte [#_"ArraySeq_byte" this, #_"IPersistentMap" meta]
        (ArraySeq_byte'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_byte [#_"ArraySeq_byte" this, #_"IFn" f]
        (let [#_"byte[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_byte [#_"ArraySeq_byte" this, #_"IFn" f, #_"Object" r]
        (let [#_"byte[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_char
    (defn- #_"ArraySeq_char" ArraySeq_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_char" ArraySeq_char'new [#_"IPersistentMap" meta, #_"char[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_char'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_char [#_"ArraySeq_char" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_char [#_"ArraySeq_char" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_char'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_char [#_"ArraySeq_char" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_char [#_"ArraySeq_char" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_char" IObj'''withMeta--ArraySeq_char [#_"ArraySeq_char" this, #_"IPersistentMap" meta]
        (ArraySeq_char'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_char [#_"ArraySeq_char" this, #_"IFn" f]
        (let [#_"char[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_char [#_"ArraySeq_char" this, #_"IFn" f, #_"Object" r]
        (let [#_"char[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_short
    (defn- #_"ArraySeq_short" ArraySeq_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_short" ArraySeq_short'new [#_"IPersistentMap" meta, #_"short[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_short'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_short [#_"ArraySeq_short" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_short [#_"ArraySeq_short" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_short'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_short [#_"ArraySeq_short" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_short [#_"ArraySeq_short" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_short" IObj'''withMeta--ArraySeq_short [#_"ArraySeq_short" this, #_"IPersistentMap" meta]
        (ArraySeq_short'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_short [#_"ArraySeq_short" this, #_"IFn" f]
        (let [#_"short[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_short [#_"ArraySeq_short" this, #_"IFn" f, #_"Object" r]
        (let [#_"short[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq_boolean
    (defn- #_"ArraySeq_boolean" ArraySeq_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_boolean" ArraySeq_boolean'new [#_"IPersistentMap" meta, #_"boolean[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_boolean'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_boolean'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_boolean" IObj'''withMeta--ArraySeq_boolean [#_"ArraySeq_boolean" this, #_"IPersistentMap" meta]
        (ArraySeq_boolean'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_boolean [#_"ArraySeq_boolean" this, #_"IFn" f]
        (let [#_"boolean[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_boolean [#_"ArraySeq_boolean" this, #_"IFn" f, #_"Object" r]
        (let [#_"boolean[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )
)

(class-ns ArraySeq
    (defn #_"ArraySeq" ArraySeq'create-0 []
        nil
    )

    (defn #_"ArraySeq" ArraySeq'create-1 [& #_"Object..." array]
        (when (and (some? array) (pos? (alength array)))
            (ArraySeq'new-2 array, 0)
        )
    )

    (defn #_"ISeq" ArraySeq'createFromObject [#_"Object" array]
        (when (and (some? array) (pos? (Array/getLength array)))
            (let [#_"Class" c (.getClass array)]
                (condp = c
                    RT'INTS_CLASS     (ArraySeq_int'new     nil, (cast c array), 0)
                    RT'FLOATS_CLASS   (ArraySeq_float'new   nil, (cast c array), 0)
                    RT'DOUBLES_CLASS  (ArraySeq_double'new  nil, (cast c array), 0)
                    RT'LONGS_CLASS    (ArraySeq_long'new    nil, (cast c array), 0)
                    RT'BYTES_CLASS    (ArraySeq_byte'new    nil, (cast c array), 0)
                    RT'CHARS_CLASS    (ArraySeq_char'new    nil, (cast c array), 0)
                    RT'SHORTS_CLASS   (ArraySeq_short'new   nil, (cast c array), 0)
                    RT'BOOLEANS_CLASS (ArraySeq_boolean'new nil, (cast c array), 0)
                                      (ArraySeq'new-2                    array,  0)
                )
            )
        )
    )

    (defn- #_"ArraySeq" ArraySeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-2 [#_"Object" array, #_"int" i]
        (let [this (merge (ASeq'new-0) (ArraySeq'init))]
            (assoc this :i i :array (cast RT'OBJECTS_CLASS array))
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-3 [#_"IPersistentMap" meta, #_"Object" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq'init))]
            (assoc this :i i :array (cast RT'OBJECTS_CLASS array))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq [#_"ArraySeq" this]
        (when (some? (:array this))
            (aget (:array this) (:i this))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq [#_"ArraySeq" this]
        (when (and (some? (:array this)) (< (inc (:i this)) (alength (:array this))))
            (ArraySeq'new-2 (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq [#_"ArraySeq" this]
        (if (some? (:array this)) (- (alength (:array this)) (:i this)) 0)
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq [#_"ArraySeq" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq" IObj'''withMeta--ArraySeq [#_"ArraySeq" this, #_"IPersistentMap" meta]
        (ArraySeq'new-3 meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq [#_"ArraySeq" this, #_"IFn" f]
        (when-let [#_"Object[]" a (:array this)]
            (let [#_"int" i (:i this) #_"int" n (alength a)]
                (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                    (let [r (.invoke f, r, (aget a i))]
                        (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq [#_"ArraySeq" this, #_"IFn" f, #_"Object" r]
        (when-let [#_"Object[]" a (:array this)]
            (let [#_"int" i (:i this) #_"int" n (alength a)]
                (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Atom

(class-ns Atom
    (defn- #_"Atom" Atom'init []
        (hash-map
            #_"AtomicReference" :state nil
        )
    )

    (defn #_"Atom" Atom'new-1 [#_"Object" state]
        (let [this (merge (ARef'new-0) (Atom'init))]
            (assoc this :state (AtomicReference. state))
        )
    )

    (defn #_"Atom" Atom'new-2 [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Atom'init))]
            (assoc this :state (AtomicReference. state))
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Atom [#_"Atom" this]
        (.get (:state this))
    )

    #_override
    (defn #_"Object" IAtom'''swap-2--Atom [#_"Atom" this, #_"IFn" f]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.invoke f, v)]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"Object" IAtom'''swap-3--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.invoke f, v, arg)]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"Object" IAtom'''swap-4--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.invoke f, v, arg1, arg2)]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"Object" IAtom'''swap-5--Atom [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.applyTo f, (RT'listStar-4 v, x, y, args))]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-2--Atom [#_"Atom" this, #_"IFn" f]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.invoke f, oldv)]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-3--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.invoke f, oldv, arg)]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-4--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.invoke f, oldv, arg1, arg2)]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-5--Atom [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.applyTo f, (RT'listStar-4 oldv, x, y, args))]
                (ARef''validate-2 this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"boolean" IAtom'''compareAndSet--Atom [#_"Atom" this, #_"Object" oldv, #_"Object" newv]
        (ARef''validate-2 this, newv)
        (let [#_"boolean" ret (.compareAndSet (:state this), oldv, newv)]
            (when ret
                (ARef''notifyWatches this, oldv, newv)
            )
            ret
        )
    )

    #_override
    (defn #_"Object" IAtom'''reset--Atom [#_"Atom" this, #_"Object" newval]
        (let [#_"Object" oldval (.get (:state this))]
            (ARef''validate-2 this, newval)
            (.set (:state this), newval)
            (ARef''notifyWatches this, oldval, newval)
            newval
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''resetVals--Atom [#_"Atom" this, #_"Object" newv]
        (ARef''validate-2 this, newv)
        (loop []
            (let [#_"Object" oldv (.deref this)]
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(class-ns ATransientMap
    (defn #_"ATransientMap" ATransientMap'new []
        (AFn'new)
    )

    #_method
    (defn #_"ITransientMap" ATransientMap''conj [#_"ATransientMap" this, #_"Object" o]
        (.ensureEditable this)
        (cond
            (instance? Map$Entry o)
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (.assoc this, (.getKey e), (.getValue e))
                )
            (instance? IPersistentVector o)
                (let [#_"IPersistentVector" v (cast IPersistentVector o)]
                    (when (= (.count v) 2) => (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                        (.assoc this, (.nth v, 0), (.nth v, 1))
                    )
                )
            :else
                (loop-when [#_"ITransientMap" m this #_"ISeq" s (RT'seq o)] (some? s) => m
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (recur (.assoc m, (.getKey e), (.getValue e)) (.next s))
                    )
                )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--ATransientMap [#_"ATransientMap" this, #_"Object" arg1]
        (.valAt this, arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--ATransientMap [#_"ATransientMap" this, #_"Object" arg1, #_"Object" notFound]
        (.valAt this, arg1, notFound)
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_override
    (defn #_"ITransientMap" ITransientMap'''assoc--ATransientMap [#_"ATransientMap" this, #_"Object" key, #_"Object" val]
        (.ensureEditable this)
        (.doAssoc this, key, val)
    )

    #_override
    (defn #_"ITransientMap" ITransientMap'''without--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (.ensureEditable this)
        (.doWithout this, key)
    )

    #_override
    (defn #_"IPersistentMap" ITransientMap'''persistent--ATransientMap [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doPersistent this)
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--ATransientMap [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound]
        (.ensureEditable this)
        (.doValAt this, key, notFound)
    )

    (def- #_"Object" ATransientMap'NOT_FOUND (Object.))

    #_override
    (defn #_"boolean" ITransientAssociative2'''containsKey--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (not= (.valAt this, key, ATransientMap'NOT_FOUND) ATransientMap'NOT_FOUND)
    )

    #_override
    (defn #_"IMapEntry" ITransientAssociative2'''entryAt--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (let [#_"Object" v (.valAt this, key, ATransientMap'NOT_FOUND)]
            (when-not (= v ATransientMap'NOT_FOUND)
                (MapEntry'create key, v)
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--ATransientMap [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doCount this)
    )
)
)

(java-ns cloiure.lang.ATransientSet

(class-ns ATransientSet
    (defn- #_"ATransientSet" ATransientSet'init []
        (hash-map
            #_volatile
            #_"ITransientMap" :impl nil
        )
    )

    (defn #_"ATransientSet" ATransientSet'new [#_"ITransientMap" impl]
        (let [this (merge (AFn'new) (ATransientSet'init))]
            (assoc this :impl impl)
        )
    )

    #_override
    (defn #_"int" Counted'''count--ATransientSet [#_"ATransientSet" this]
        (.count (:impl this))
    )

    #_override
    (defn #_"ITransientSet" ITransientCollection'''conj--ATransientSet [#_"ATransientSet" this, #_"Object" val]
        (let [#_"ITransientMap" m (.assoc (:impl this), val, val)]
            (when-not (= m (:impl this)) => this
                (assoc this :impl m)
            )
        )
    )

    #_override
    (defn #_"boolean" ITransientSet'''contains--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (not= this (.valAt (:impl this), key, this))
    )

    #_override
    (defn #_"ITransientSet" ITransientSet'''disjoin--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (let [#_"ITransientMap" m (.without (:impl this), key)]
            (when-not (= m (:impl this)) => this
                (assoc this :impl m)
            )
        )
    )

    #_override
    (defn #_"Object" ITransientSet'''get--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (.valAt (:impl this), key)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--ATransientSet [#_"ATransientSet" this, #_"Object" key, #_"Object" notFound]
        (.valAt (:impl this), key, notFound)
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (.valAt (:impl this), key)
    )
)
)

(java-ns cloiure.lang.BigInt

(class-ns BigInt
    (ยง def #_"BigInt" BigInt'ZERO (BigInt'new 0, nil))
    (ยง def #_"BigInt" BigInt'ONE (BigInt'new 1, nil))

    (defn- #_"BigInt" BigInt'init []
        (hash-map
            #_"long" :lpart 0
            #_"BigInteger" :bipart nil
        )
    )

    (defn- #_"BigInt" BigInt'new [#_"long" lpart, #_"BigInteger" bipart]
        (let [this (merge (ยง foreign Number'new) (BigInt'init))]
            (assoc this :lpart lpart :bipart bipart)
        )
    )

    ;; must follow Long
    #_foreign
    (defn #_"int" hashCode---BigInt [#_"BigInt" this]
        (if (nil? (:bipart this))
            (int (bit-xor (:lpart this) (>>> (:lpart this) 32)))
            (.hashCode (:bipart this))
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--BigInt [#_"BigInt" this]
        (if (nil? (:bipart this))
            (Murmur3'hashLong (:lpart this))
            (.hashCode (:bipart this))
        )
    )

    #_foreign
    (defn #_"boolean" equals---BigInt [#_"BigInt" this, #_"Object" obj]
        (cond
            (= this obj)
                true
            (instance? BigInt obj)
                (let [#_"BigInt" o (cast BigInt obj)]
                    (if (nil? (:bipart this))
                        (and (nil? (:bipart o)) (= (:lpart this) (:lpart o)))
                        (and (some? (:bipart o)) (.equals (:bipart this), (:bipart o)))
                    )
                )
            :else
                false
        )
    )

    (defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" val]
        (if (< (.bitLength val) 64)
            (BigInt'new (.longValue val), nil)
            (BigInt'new 0, val)
        )
    )

    (defn #_"BigInt" BigInt'fromLong [#_"long" val]
        (BigInt'new val, nil)
    )

    #_method
    (defn #_"BigInteger" BigInt''toBigInteger [#_"BigInt" this]
        (if (nil? (:bipart this))
            (BigInteger/valueOf (:lpart this))
            (:bipart this)
        )
    )

    #_method
    (defn #_"BigDecimal" BigInt''toBigDecimal [#_"BigInt" this]
        (if (nil? (:bipart this))
            (BigDecimal/valueOf (:lpart this))
            (BigDecimal. (:bipart this))
        )
    )

    #_method
    (defn #_"int" BigInt''intValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (int (:lpart this))
            (.intValue (:bipart this))
        )
    )

    #_method
    (defn #_"long" BigInt''longValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.longValue (:bipart this))
        )
    )

    #_method
    (defn #_"float" BigInt''floatValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.floatValue (:bipart this))
        )
    )

    #_method
    (defn #_"double" BigInt''doubleValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.doubleValue (:bipart this))
        )
    )

    #_method
    (defn #_"byte" BigInt''byteValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (byte (:lpart this))
            (.byteValue (:bipart this))
        )
    )

    #_method
    (defn #_"short" BigInt''shortValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (short (:lpart this))
            (.shortValue (:bipart this))
        )
    )

    (defn #_"BigInt" BigInt'valueOf [#_"long" val]
        (BigInt'new val, nil)
    )

    #_foreign
    (defn #_"String" toString---BigInt [#_"BigInt" this]
        (if (nil? (:bipart this))
            (String/valueOf (:lpart this))
            (.toString (:bipart this))
        )
    )

    #_method
    (defn #_"int" BigInt''bitLength [#_"BigInt" this]
        (.bitLength (BigInt''toBigInteger this))
    )

    #_method
    (defn #_"BigInt" BigInt''add [#_"BigInt" this, #_"BigInt" y]
        (or
            (when (and (nil? (:bipart this)) (nil? (:bipart y)))
                (let [#_"long" ret (+ (:lpart this) (:lpart y))]
                    (when (or (<= 0 (bit-xor ret (:lpart this))) (<= 0 (bit-xor ret (:lpart y))))
                        (BigInt'valueOf ret)
                    )
                )
            )
            (BigInt'fromBigInteger (.add (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"BigInt" BigInt''multiply [#_"BigInt" this, #_"BigInt" y]
        (or
            (when (and (nil? (:bipart this)) (nil? (:bipart y)))
                (let [#_"long" ret (* (:lpart this) (:lpart y))]
                    (when (or (zero? (:lpart y)) (and (= (/ ret (:lpart y)) (:lpart this)) (not= (:lpart this) Long/MIN_VALUE)))
                        (BigInt'valueOf ret)
                    )
                )
            )
            (BigInt'fromBigInteger (.multiply (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"BigInt" BigInt''quotient [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (if (and (= (:lpart this) Long/MIN_VALUE) (= (:lpart y) -1))
                (BigInt'fromBigInteger (.negate (BigInt''toBigInteger this)))
                (BigInt'valueOf (/ (:lpart this) (:lpart y)))
            )
            (BigInt'fromBigInteger (.divide (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"BigInt" BigInt''remainder [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (BigInt'valueOf (% (:lpart this) (:lpart y)))
            (BigInt'fromBigInteger (.remainder (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"boolean" BigInt''lt [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (< (:lpart this) (:lpart y))
            (neg? (.compareTo (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding
    (defn- #_"Binding" Binding'init []
        (hash-map
            #_"T" :val nil
            #_"Binding" :rest nil
        )
    )

    (defn #_"Binding" Binding'new-1 [#_"T" val]
        (let [this (Binding'init)]
            (assoc this :val val :rest nil)
        )
    )

    (defn #_"Binding" Binding'new-2 [#_"T" val, #_"Binding" rest]
        (let [this (Binding'init)]
            (assoc this :val val :rest rest)
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (defn- #_"Box" Box'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Box" Box'new [#_"Object" val]
        (let [this (Box'init)]
            (assoc this :val val)
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer
    (defn- #_"ChunkBuffer" ChunkBuffer'init []
        (hash-map
            #_"Object[]" :buffer nil
            #_"int" :end 0
        )
    )

    (defn #_"ChunkBuffer" ChunkBuffer'new [#_"int" capacity]
        (let [this (ChunkBuffer'init)]
            (assoc this :buffer (make-array Object capacity) :end 0)
        )
    )

    #_method
    (defn #_"void" ChunkBuffer''add [#_"ChunkBuffer" this, #_"Object" o]
        (aset (:buffer this) (:end this) o)
        (ร ass this (update this :end inc))
        nil
    )

    #_method
    (defn #_"IChunk" ChunkBuffer''chunk [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ret (ArrayChunk'new-3 (:buffer this), 0, (:end this))]
            (ร ass this (assoc this :buffer nil))
            ret
        )
    )

    #_override
    (defn #_"int" Counted'''count--ChunkBuffer [#_"ChunkBuffer" this]
        (:end this)
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons
    (defn- #_"ChunkedCons" ChunkedCons'init []
        (hash-map
            #_"IChunk" :chunk nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-3 [#_"IPersistentMap" meta, #_"IChunk" chunk, #_"ISeq" more]
        (let [this (merge (ASeq'new-1 meta) (ChunkedCons'init))]
            (assoc this :chunk chunk :_more more)
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-2 [#_"IChunk" chunk, #_"ISeq" more]
        (ChunkedCons'new-3 nil, chunk, more)
    )

    #_override
    (defn #_"ChunkedCons" IObj'''withMeta--ChunkedCons [#_"ChunkedCons" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (ChunkedCons'new-3 meta, (:chunk this), (:_more this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ChunkedCons [#_"ChunkedCons" this]
        (.nth (:chunk this), 0)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ChunkedCons [#_"ChunkedCons" this]
        (if (< 1 (.count (:chunk this)))
            (ChunkedCons'new-2 (.dropFirst (:chunk this)), (:_more this))
            (.chunkedNext this)
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''more--ChunkedCons [#_"ChunkedCons" this]
        (if (< 1 (.count (:chunk this)))
            (ChunkedCons'new-2 (.dropFirst (:chunk this)), (:_more this))
            (or (:_more this) PersistentList'EMPTY)
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--ChunkedCons [#_"ChunkedCons" this]
        (:chunk this)
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--ChunkedCons [#_"ChunkedCons" this]
        (.seq (.chunkedMore this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--ChunkedCons [#_"ChunkedCons" this]
        (or (:_more this) PersistentList'EMPTY)
    )
)
)

(java-ns cloiure.lang.Compiler

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

(class-ns UntypedExpr
    (defn #_"UntypedExpr" UntypedExpr'new []
        (hash-map)
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--UntypedExpr [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--UntypedExpr [#_"UntypedExpr" this]
        false
    )
)

(class-ns DefParser
    (defn #_"IParser" DefParser'new []
        (reify IParser
            ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (let [[#_"String" docstring form]
                        (when (and (= (RT'count form) 4) (instance? String (RT'third form))) => [nil form]
                            [(cast String (RT'third form)) (RT'list-3 (RT'first form), (RT'second form), (RT'fourth form))]
                        )]
                    (cond
                        (< 3 (RT'count form))                     (throw (RuntimeException. "Too many arguments to def"))
                        (< (RT'count form) 2)                     (throw (RuntimeException. "Too few arguments to def"))
                        (not (instance? Symbol (RT'second form))) (throw (RuntimeException. "First argument to def must be a Symbol"))
                    )
                    (let [#_"Symbol" sym (cast Symbol (RT'second form)) #_"Var" v (Compiler'lookupVar-2 sym, true)]
                        (when (some? v) => (throw (RuntimeException. "Can't refer to qualified var that doesn't exist"))
                            (let [[v #_"boolean" shadowsCoreMapping]
                                    (when (not (.equals (:ns v), (Compiler'currentNS))) => [v false]
                                        (when (nil? (:ns sym)) => (throw (RuntimeException. "Can't create defs outside of current ns"))
                                            (let [v (Namespace''intern (Compiler'currentNS), sym)]
                                                (Compiler'registerVar v)
                                                [v true]
                                            )
                                        )
                                    )
                                  #_"IPersistentMap" mm (.meta sym)
                                  #_"boolean" isDynamic (RT'booleanCast-1o (RT'get-2 mm, Compiler'dynamicKey))]
                                (when isDynamic
                                    (Var''setDynamic-1 v)
                                )
                                (when (and (not isDynamic) (.startsWith (:name sym), "*") (.endsWith (:name sym), "*") (< 2 (.length (:name sym))))
                                    (.format (RT'errPrintWriter), "Warning: %s not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic or change the name.\n", (object-array [ sym ]))
                                )
                                (let [mm (cast IPersistentMap (-> mm (RT'assoc RT'LINE_KEY, (Var''get Compiler'LINE)) (.assoc RT'COLUMN_KEY, (Var''get Compiler'COLUMN))))
                                      mm (if (some? docstring) (cast IPersistentMap (RT'assoc mm, RT'DOC_KEY, docstring)) mm)
                                      #_"Expr" meta (when (pos? (.count mm)) (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), mm))]
                                    (DefExpr'new (Compiler'lineDeref), (Compiler'columnDeref), v, (Compiler'analyze-3 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'third form), (:name (:sym v))), meta, (= (RT'count form) 3), isDynamic, shadowsCoreMapping)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr
    (def #_"Method" DefExpr'bindRootMethod (Method/getMethod "void bindRoot(Object)"))
    (def #_"Method" DefExpr'setTagMethod (Method/getMethod "void setTag(cloiure.lang.Symbol)"))
    (def #_"Method" DefExpr'setMetaMethod (Method/getMethod "void setMeta(cloiure.lang.IPersistentMap)"))
    (def #_"Method" DefExpr'setDynamicMethod (Method/getMethod "cloiure.lang.Var setDynamic(boolean)"))
    (def #_"Method" DefExpr'internVar (Method/getMethod "cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

    (defn- #_"DefExpr" DefExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Expr" :init nil
            #_"Expr" :meta nil
            #_"boolean" :initProvided false
            #_"boolean" :isDynamic false
            #_"boolean" :shadowsCoreMapping false
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"DefExpr" DefExpr'new [#_"int" line, #_"int" column, #_"Var" var, #_"Expr" init, #_"Expr" meta, #_"boolean" initProvided, #_"boolean" isDynamic, #_"boolean" shadowsCoreMapping]
        (let [this (DefExpr'init)]
            (assoc this :line line :column column :var var :init init :meta meta :isDynamic isDynamic :shadowsCoreMapping shadowsCoreMapping :initProvided initProvided)
        )
    )

    #_method
    (defn- #_"boolean" DefExpr''includesExplicitMetadata [#_"DefExpr" this, #_"MapExpr" expr]
        (loop-when [#_"int" i 0] (< i (.count (:keyvals expr))) => false
            (let [#_"Keyword" k (:k (cast KeywordExpr (.nth (:keyvals expr), i)))]
                (recur-if (any = k RT'DECLARED_KEY RT'LINE_KEY RT'COLUMN_KEY) [(+ i 2)] => true)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--DefExpr [#_"DefExpr" this]
        (try
            (when (:initProvided this)
                (Var''bindRoot (:var this), (.eval (:init this)))
            )
            (when (some? (:meta this))
                (let [#_"IPersistentMap" metaMap (cast IPersistentMap (.eval (:meta this)))]
                    (when (or (:initProvided this) true)
                        (Var''setMeta (:var this), metaMap)
                    )
                )
            )
            (Var''setDynamic-2 (:var this), (:isDynamic this))
            (catch Throwable e
                (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--DefExpr [#_"DefExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitVar objx, gen, (:var this))
        (when (:shadowsCoreMapping this)
            (.dup gen)
            (.getField gen, Compiler'VAR_TYPE, "ns", Compiler'NS_TYPE)
            (.swap gen)
            (.dup gen)
            (.getField gen, Compiler'VAR_TYPE, "sym", Compiler'SYMBOL_TYPE)
            (.swap gen)
            (.invokeVirtual gen, Compiler'NS_TYPE, DefExpr'internVar)
        )
        (when (:isDynamic this)
            (.push gen, (:isDynamic this))
            (.invokeVirtual gen, Compiler'VAR_TYPE, DefExpr'setDynamicMethod)
        )
        (when (some? (:meta this))
            (.dup gen)
            (.emit (:meta this), :Context'EXPRESSION, objx, gen)
            (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
            (.invokeVirtual gen, Compiler'VAR_TYPE, DefExpr'setMetaMethod)
        )
        (when (:initProvided this)
            (.dup gen)
            (if (instance? FnExpr (:init this))
                (FnExpr''emitForDefn (cast FnExpr (:init this)), objx, gen)
                (.emit (:init this), :Context'EXPRESSION, objx, gen)
            )
            (.invokeVirtual gen, Compiler'VAR_TYPE, DefExpr'bindRootMethod)
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--DefExpr [#_"DefExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--DefExpr [#_"DefExpr" this]
        Var
    )
)

(class-ns AssignParser
    (defn #_"IParser" AssignParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (let [#_"ISeq" s (cast ISeq form)]
                    (when (= (RT'length s) 3) => (throw (IllegalArgumentException. "Malformed assignment, expecting (set! target val)"))
                        (let [#_"Expr" target (Compiler'analyze-2 :Context'EXPRESSION, (RT'second s))]
                            (when (instance? AssignableExpr target) => (throw (IllegalArgumentException. "Invalid assignment target"))
                                (AssignExpr'new (cast AssignableExpr target), (Compiler'analyze-2 :Context'EXPRESSION, (RT'third s)))
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns AssignExpr
    (defn- #_"AssignExpr" AssignExpr'init []
        (hash-map
            #_"AssignableExpr" :target nil
            #_"Expr" :val nil
        )
    )

    (defn #_"AssignExpr" AssignExpr'new [#_"AssignableExpr" target, #_"Expr" val]
        (let [this (AssignExpr'init)]
            (assoc this :target target :val val)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--AssignExpr [#_"AssignExpr" this]
        (.evalAssign (:target this), (:val this))
    )

    #_override
    (defn #_"void" Expr'''emit--AssignExpr [#_"AssignExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitAssign (:target this), context, objx, gen, (:val this))
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--AssignExpr [#_"AssignExpr" this]
        (.hasJavaClass (:val this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--AssignExpr [#_"AssignExpr" this]
        (.getJavaClass (:val this))
    )
)

(class-ns VarExpr
    (def #_"Method" VarExpr'getMethod (Method/getMethod "Object get()"))
    (def #_"Method" VarExpr'setMethod (Method/getMethod "Object set(Object)"))

    (defn- #_"VarExpr" VarExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Object" :tag nil
        )
    )

    (defn #_"VarExpr" VarExpr'new [#_"Var" var, #_"Symbol" tag]
        (let [this (VarExpr'init)]
            (assoc this :var var :tag (or tag (Var''getTag var)))
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--VarExpr [#_"VarExpr" this]
        (.deref (:var this))
    )

    #_override
    (defn #_"void" Expr'''emit--VarExpr [#_"VarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitVarValue objx, gen, (:var this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--VarExpr [#_"VarExpr" this]
        (some? (:tag this))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--VarExpr [#_"VarExpr" this]
        (HostExpr'tagToClass (:tag this))
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--VarExpr [#_"VarExpr" this, #_"Expr" val]
        (Var''set (:var this), (.eval val))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--VarExpr [#_"VarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (ObjExpr''emitVar objx, gen, (:var this))
        (.emit val, :Context'EXPRESSION, objx, gen)
        (.invokeVirtual gen, Compiler'VAR_TYPE, VarExpr'setMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

(class-ns TheVarParser
    (defn #_"IParser" TheVarParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (let [#_"Symbol" sym (cast Symbol (RT'second form)) #_"Var" v (Compiler'lookupVar-2 sym, false)]
                    (when (some? v) => (throw (RuntimeException. (str "Unable to resolve var: " sym " in this context")))
                        (TheVarExpr'new v)
                    )
                )
            )
        )
    )
)

(class-ns TheVarExpr
    (defn- #_"TheVarExpr" TheVarExpr'init []
        (hash-map
            #_"Var" :var nil
        )
    )

    (defn #_"TheVarExpr" TheVarExpr'new [#_"Var" var]
        (let [this (TheVarExpr'init)]
            (assoc this :var var)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--TheVarExpr [#_"TheVarExpr" this]
        (:var this)
    )

    #_override
    (defn #_"void" Expr'''emit--TheVarExpr [#_"TheVarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitVar objx, gen, (:var this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--TheVarExpr [#_"TheVarExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--TheVarExpr [#_"TheVarExpr" this]
        Var
    )
)

(class-ns ImportParser
    (defn #_"IParser" ImportParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (ImportExpr'new (cast String (RT'second form)))
            )
        )
    )
)

(class-ns ImportExpr
    (def #_"Method" ImportExpr'forNameMethod (Method/getMethod "Class classForNameNonLoading(String)"))
    (def #_"Method" ImportExpr'importClassMethod (Method/getMethod "Class importClass(Class)"))
    (def #_"Method" ImportExpr'derefMethod (Method/getMethod "Object deref()"))

    (defn- #_"ImportExpr" ImportExpr'init []
        (hash-map
            #_"String" :c nil
        )
    )

    (defn #_"ImportExpr" ImportExpr'new [#_"String" c]
        (let [this (ImportExpr'init)]
            (assoc this :c c)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ImportExpr [#_"ImportExpr" this]
        (let [#_"Namespace" ns (cast Namespace (.deref RT'CURRENT_NS))]
            (Namespace''importClass-2 ns, (RT'classForNameNonLoading (:c this)))
            nil
        )
    )

    #_override
    (defn #_"void" Expr'''emit--ImportExpr [#_"ImportExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.getStatic gen, Compiler'RT_TYPE, "CURRENT_NS", Compiler'VAR_TYPE)
        (.invokeVirtual gen, Compiler'VAR_TYPE, ImportExpr'derefMethod)
        (.checkCast gen, Compiler'NS_TYPE)
        (.push gen, (:c this))
        (.invokeStatic gen, Compiler'RT_TYPE, ImportExpr'forNameMethod)
        (.invokeVirtual gen, Compiler'NS_TYPE, ImportExpr'importClassMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ImportExpr [#_"ImportExpr" this]
        false
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ImportExpr [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

(class-ns LiteralExpr
    (defn #_"LiteralExpr" LiteralExpr'new []
        (hash-map)
    )

    #_override
    (defn #_"Object" Expr'''eval--LiteralExpr [#_"LiteralExpr" this]
        (.val this)
    )
)

(class-ns KeywordExpr
    (defn- #_"KeywordExpr" KeywordExpr'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordExpr" KeywordExpr'new [#_"Keyword" k]
        (let [this (merge (LiteralExpr'new) (KeywordExpr'init))]
            (assoc this :k k)
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--KeywordExpr [#_"KeywordExpr" this]
        (:k this)
    )

    #_override
    (defn #_"Object" Expr'''eval--KeywordExpr [#_"KeywordExpr" this]
        (:k this)
    )

    #_override
    (defn #_"void" Expr'''emit--KeywordExpr [#_"KeywordExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitKeyword objx, gen, (:k this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--KeywordExpr [#_"KeywordExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--KeywordExpr [#_"KeywordExpr" this]
        Keyword
    )
)

(class-ns HostParser
    (defn #_"IParser" HostParser'new []
        (reify IParser
            ;; (. x fieldname-sym) or
            ;; (. x 0-ary-method)
            ;; (. x methodname-sym args+)
            ;; (. x (methodname-sym args?))
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"ISeq" form (cast ISeq frm)]
                    (when-not (< (RT'length form) 3) => (throw (IllegalArgumentException. "Malformed member expression, expecting (. target member ...)"))
                        ;; determine static or instance
                        ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                        (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref) #_"Class" c (HostExpr'maybeClass (RT'second form), false)
                              ;; at this point c will be non-null if static
                              #_"Expr" instance (when (nil? c) (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'second form)))
                              #_"boolean" maybeField (and (= (RT'length form) 3) (instance? Symbol (RT'third form)))
                              maybeField
                                (when (and maybeField (not= (.charAt (:name (cast Symbol (RT'third form))), 0) \-)) => maybeField
                                    (let [#_"Symbol" sym (cast Symbol (RT'third form))]
                                        (cond
                                            (some? c)
                                                (zero? (.size (Reflector'getMethods c, 0, (Compiler'munge (:name sym)), true)))
                                            (and (some? instance) (.hasJavaClass instance) (some? (.getJavaClass instance)))
                                                (zero? (.size (Reflector'getMethods (.getJavaClass instance), 0, (Compiler'munge (:name sym)), false)))
                                            :else
                                                maybeField
                                        )
                                    )
                                )]
                            (if maybeField
                                (let [? (= (.charAt (:name (cast Symbol (RT'third form))), 0) \-)
                                      #_"Symbol" sym (if ? (Symbol'intern (.substring (:name (cast Symbol (RT'third form))), 1)) (cast Symbol (RT'third form)))
                                      #_"Symbol" tag (Compiler'tagOf form)]
                                    (if (some? c)
                                        (StaticFieldExpr'new line, column, c, (Compiler'munge (:name sym)), tag)
                                        (InstanceFieldExpr'new line, column, instance, (Compiler'munge (:name sym)), tag, ?)
                                    )
                                )
                                (let [#_"ISeq" call (cast ISeq (if (instance? ISeq (RT'third form)) (RT'third form) (RT'next (RT'next form))))]
                                    (when (instance? Symbol (RT'first call)) => (throw (IllegalArgumentException. "Malformed member expression"))
                                        (let [#_"Symbol" sym (cast Symbol (RT'first call))
                                              #_"Symbol" tag (Compiler'tagOf form)
                                              #_"boolean" tailPosition (Compiler'inTailCall context)
                                              #_"PersistentVector" args
                                                (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'next call)]
                                                                 (some? s)
                                                                 [(.cons args, (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))) (.next s)]
                                                              => args
                                                )]
                                            (if (some? c)
                                                (StaticMethodExpr'new line, column, tag, c, (Compiler'munge (:name sym)), args, tailPosition)
                                                (InstanceMethodExpr'new line, column, tag, instance, (Compiler'munge (:name sym)), args, tailPosition)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns HostExpr
    (defn #_"HostExpr" HostExpr'new []
        (hash-map)
    )

    (def #_"Type" HostExpr'BOOLEAN_TYPE (Type/getType Boolean))
    (def #_"Type" HostExpr'CHAR_TYPE (Type/getType Character))
    (def #_"Type" HostExpr'INTEGER_TYPE (Type/getType Integer))
    (def #_"Type" HostExpr'LONG_TYPE (Type/getType Long))
    (def #_"Type" HostExpr'FLOAT_TYPE (Type/getType Float))
    (def #_"Type" HostExpr'DOUBLE_TYPE (Type/getType Double))
    (def #_"Type" HostExpr'SHORT_TYPE (Type/getType Short))
    (def #_"Type" HostExpr'BYTE_TYPE (Type/getType Byte))
    (def #_"Type" HostExpr'NUMBER_TYPE (Type/getType Number))

    (def #_"Method" HostExpr'charValueMethod (Method/getMethod "char charValue()"))
    (def #_"Method" HostExpr'booleanValueMethod (Method/getMethod "boolean booleanValue()"))

    (def #_"Method" HostExpr'charValueOfMethod (Method/getMethod "Character valueOf(char)"))
    (def #_"Method" HostExpr'intValueOfMethod (Method/getMethod "Integer valueOf(int)"))
    (def #_"Method" HostExpr'longValueOfMethod (Method/getMethod "Long valueOf(long)"))
    (def #_"Method" HostExpr'floatValueOfMethod (Method/getMethod "Float valueOf(float)"))
    (def #_"Method" HostExpr'doubleValueOfMethod (Method/getMethod "Double valueOf(double)"))
    (def #_"Method" HostExpr'shortValueOfMethod (Method/getMethod "Short valueOf(short)"))
    (def #_"Method" HostExpr'byteValueOfMethod (Method/getMethod "Byte valueOf(byte)"))

    (def #_"Method" HostExpr'intValueMethod (Method/getMethod "int intValue()"))
    (def #_"Method" HostExpr'longValueMethod (Method/getMethod "long longValue()"))
    (def #_"Method" HostExpr'floatValueMethod (Method/getMethod "float floatValue()"))
    (def #_"Method" HostExpr'doubleValueMethod (Method/getMethod "double doubleValue()"))
    (def #_"Method" HostExpr'byteValueMethod (Method/getMethod "byte byteValue()"))
    (def #_"Method" HostExpr'shortValueMethod (Method/getMethod "short shortValue()"))

    (def #_"Method" HostExpr'fromIntMethod (Method/getMethod "cloiure.lang.Num from(int)"))
    (def #_"Method" HostExpr'fromLongMethod (Method/getMethod "cloiure.lang.Num from(long)"))
    (def #_"Method" HostExpr'fromDoubleMethod (Method/getMethod "cloiure.lang.Num from(double)"))

    (defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" returnType]
        (when (.isPrimitive returnType)
            (condp = returnType
                Boolean/TYPE
                    (let [#_"Label" falseLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
                        (.ifZCmp gen, GeneratorAdapter/EQ, falseLabel)
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE)
                        (.goTo gen, endLabel)
                        (.mark gen, falseLabel)
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                        (.mark gen, endLabel)
                    )
                Void/TYPE      (.emit Compiler'NIL_EXPR, :Context'EXPRESSION, objx, gen)
                Character/TYPE (.invokeStatic gen, HostExpr'CHAR_TYPE, HostExpr'charValueOfMethod)
                Integer/TYPE   (.invokeStatic gen, HostExpr'INTEGER_TYPE, HostExpr'intValueOfMethod)
                Float/TYPE     (.invokeStatic gen, HostExpr'FLOAT_TYPE, HostExpr'floatValueOfMethod)
                Double/TYPE    (.invokeStatic gen, HostExpr'DOUBLE_TYPE, HostExpr'doubleValueOfMethod)
                Long/TYPE      (.invokeStatic gen, Compiler'NUMBERS_TYPE, (Method/getMethod "Number num(long)"))
                Byte/TYPE      (.invokeStatic gen, HostExpr'BYTE_TYPE, HostExpr'byteValueOfMethod)
                Short/TYPE     (.invokeStatic gen, HostExpr'SHORT_TYPE, HostExpr'shortValueOfMethod)
            )
        )
        nil
    )

    (defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" paramType]
        (when (.isPrimitive paramType) => (.checkCast gen, (Type/getType paramType))
            (condp = paramType
                Boolean/TYPE
                (do
                    (.checkCast gen, HostExpr'BOOLEAN_TYPE)
                    (.invokeVirtual gen, HostExpr'BOOLEAN_TYPE, HostExpr'booleanValueMethod)
                )
                Character/TYPE
                (do
                    (.checkCast gen, HostExpr'CHAR_TYPE)
                    (.invokeVirtual gen, HostExpr'CHAR_TYPE, HostExpr'charValueMethod)
                )
                (do
                    (.checkCast gen, HostExpr'NUMBER_TYPE)
                    (let [#_"Method" m
                            (condp = paramType
                                Integer/TYPE (Method/getMethod "int intCast(Object)")
                                Float/TYPE   (Method/getMethod "float floatCast(Object)")
                                Double/TYPE  (Method/getMethod "double doubleCast(Object)")
                                Long/TYPE    (Method/getMethod "long longCast(Object)")
                                Byte/TYPE    (Method/getMethod "byte byteCast(Object)")
                                Short/TYPE   (Method/getMethod "short shortCast(Object)")
                                             nil
                            )]
                        (.invokeStatic gen, Compiler'RT_TYPE, m)
                    )
                )
            )
        )
        nil
    )

    (defn #_"Class" HostExpr'maybeClass [#_"Object" form, #_"boolean" stringOk]
        (cond
            (instance? Class form)
                (cast Class form)
            (instance? Symbol form)
                (let-when [#_"Symbol" sym (cast Symbol form)] (nil? (:ns sym)) ;; if ns-qualified can't be classname
                    (cond
                        (Util'equals sym, (Var''get Compiler'COMPILE_STUB_SYM))
                            (cast Class (Var''get Compiler'COMPILE_STUB_CLASS))
                        (or (pos? (.indexOf (:name sym), \.)) (= (.charAt (:name sym), 0) \[))
                            (RT'classForNameNonLoading (:name sym))
                        :else
                            (let [#_"Object" o (Namespace''getMapping (Compiler'currentNS), sym)]
                                (cond
                                    (instance? Class o)
                                        (cast Class o)
                                    (and (some? (.deref Compiler'LOCAL_ENV)) (.containsKey (cast java.util.Map (.deref Compiler'LOCAL_ENV)), form))
                                        nil
                                    :else
                                        (try
                                            (RT'classForNameNonLoading (:name sym))
                                            (catch Exception _
                                                nil
                                            )
                                        )
                                )
                            )
                    )
                )
            (and stringOk (instance? String form))
                (RT'classForNameNonLoading (cast String form))
        )
    )

    (defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" sym]
        (or (Compiler'primClass-1s sym)
            (case (:name sym)
                "booleans" RT'BOOLEANS_CLASS
                "bytes"    RT'BYTES_CLASS
                "shorts"   RT'SHORTS_CLASS
                "chars"    RT'CHARS_CLASS
                "ints"     RT'INTS_CLASS
                "longs"    RT'LONGS_CLASS
                "floats"   RT'FLOATS_CLASS
                "doubles"  RT'DOUBLES_CLASS
                "objects"  RT'OBJECTS_CLASS
                           nil
            )
        )
    )

    (defn #_"Class" HostExpr'tagToClass [#_"Object" tag]
        (or
            (when (instance? Symbol tag)
                (let-when [#_"Symbol" sym (cast Symbol tag)] (nil? (:ns sym)) ;; if ns-qualified can't be classname
                    (HostExpr'maybeSpecialTag sym)
                )
            )
            (HostExpr'maybeClass tag, true)
            (throw (IllegalArgumentException. (str "Unable to resolve classname: " tag)))
        )
    )
)

(class-ns FieldExpr
    (defn #_"FieldExpr" FieldExpr'new []
        (HostExpr'new)
    )

)

(class-ns InstanceFieldExpr
    (def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (Method/getMethod "Object invokeNoArgInstanceMember(Object, String, boolean)"))
    (def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (Method/getMethod "Object setInstanceField(Object, String, Object)"))

    (defn- #_"InstanceFieldExpr" InstanceFieldExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"Class" :targetClass nil
            #_"java.lang.reflect.Field" :field nil
            #_"String" :fieldName nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :requireField false
        )
    )

    (defn #_"InstanceFieldExpr" InstanceFieldExpr'new [#_"int" line, #_"int" column, #_"Expr" target, #_"String" fieldName, #_"Symbol" tag, #_"boolean" requireField]
        (let [#_"Class" c (when (.hasJavaClass target) (.getJavaClass target))
              #_"java.lang.reflect.Field" f (when (some? c) (Reflector'getField c, fieldName, false))]
            (when (and (nil? f) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                (if (nil? c)
                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - reference to field %s can't be resolved.\n", (object-array [ line, column, fieldName ]))
                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - reference to field %s on %s can't be resolved.\n", (object-array [ line, column, fieldName, (.getName c) ]))
                )
            )
            (-> (merge (FieldExpr'new) (InstanceFieldExpr'init))
                (assoc :target target :targetClass c :field f :fieldName fieldName :line line :column column :tag tag :requireField requireField)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (Reflector'invokeNoArgInstanceMember (.eval (:target this)), (:fieldName this), (:requireField this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (and (some? (:targetClass this)) (some? (:field this)) (Util'isPrimitive (.getType (:field this))))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (and (some? (:targetClass this)) (some? (:field this))) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (.emit (:target this), :Context'EXPRESSION, objx, gen)
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.checkCast gen, (Compiler'getType (:targetClass this)))
            (.getField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (.getField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
                (HostExpr'emitBoxReturn objx, gen, (.getType (:field this)))
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.push gen, (:fieldName this))
                (.push gen, (:requireField this))
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'invokeNoArgInstanceMember)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (or (some? (:field this)) (some? (:tag this)))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this)))
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Expr" val]
        (Reflector'setInstanceField (.eval (:target this)), (:fieldName this), (.eval val))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (.emit val, :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.dupX1 gen)
                (HostExpr'emitUnboxArg objx, gen, (.getType (:field this)))
                (.putField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
            )
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.push gen, (:fieldName this))
                (.emit val, :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

(class-ns StaticFieldExpr
    (defn- #_"StaticFieldExpr" StaticFieldExpr'init []
        (hash-map
            #_"String" :fieldName nil
            #_"Class" :c nil
            #_"java.lang.reflect.Field" :field nil
            #_"Symbol" :tag nil

            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"StaticFieldExpr" StaticFieldExpr'new [#_"int" line, #_"int" column, #_"Class" c, #_"String" fieldName, #_"Symbol" tag]
        (let [#_"java.lang.reflect.Field" f (.getField c, fieldName)]
            (-> (merge (FieldExpr'new) (StaticFieldExpr'init))
                (assoc :fieldName fieldName :line line :column column :c c :field f :tag tag)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--StaticFieldExpr [#_"StaticFieldExpr" this]
        (Reflector'getStaticField-2c (:c this), (:fieldName this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--StaticFieldExpr [#_"StaticFieldExpr" this]
        (Util'isPrimitive (.getType (:field this)))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitLineNumber gen, (:line this), (.mark gen))
        (.getStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitLineNumber gen, (:line this), (.mark gen))

        (.getStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        (HostExpr'emitBoxReturn objx, gen, (.getType (:field this)))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StaticFieldExpr [#_"StaticFieldExpr" this]
        true
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--StaticFieldExpr [#_"StaticFieldExpr" this]
        (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this)))
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Expr" val]
        (Reflector'setStaticField-3c (:c this), (:fieldName this), (.eval val))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (.emit val, :Context'EXPRESSION, objx, gen)
        (.visitLineNumber gen, (:line this), (.mark gen))
        (.dup gen)
        (HostExpr'emitUnboxArg objx, gen, (.getType (:field this)))
        (.putStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

(class-ns MethodExpr
    (defn #_"MethodExpr" MethodExpr'new []
        (HostExpr'new)
    )

    (defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" args, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.push gen, (.count args))
        (.newArray gen, Compiler'OBJECT_TYPE)
        (dotimes [#_"int" i (.count args)]
            (.dup gen)
            (.push gen, i)
            (.emit (cast Expr (.nth args, i)), :Context'EXPRESSION, objx, gen)
            (.arrayStore gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    (defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class[]" parameterTypes, #_"IPersistentVector" args]
        (dotimes [#_"int" i (alength parameterTypes)]
            (let [#_"Expr" e (cast Expr (.nth args, i)) #_"Class" primc (Compiler'maybePrimitiveType e)]
                (cond
                    (= primc (aget parameterTypes i))
                        (let [#_"MaybePrimitiveExpr" pe (cast MaybePrimitiveExpr e)]
                            (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                        )
                    (and (= primc Integer/TYPE) (= (aget parameterTypes i) Long/TYPE))
                        (let [#_"MaybePrimitiveExpr" pe (cast MaybePrimitiveExpr e)]
                            (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                            (.visitInsn gen, Opcodes/I2L)
                        )
                    (and (= primc Long/TYPE) (= (aget parameterTypes i) Integer/TYPE))
                        (let [#_"MaybePrimitiveExpr" pe (cast MaybePrimitiveExpr e)]
                            (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                            (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                        )
                    (and (= primc Float/TYPE) (= (aget parameterTypes i) Double/TYPE))
                        (let [#_"MaybePrimitiveExpr" pe (cast MaybePrimitiveExpr e)]
                            (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                            (.visitInsn gen, Opcodes/F2D)
                        )
                    (and (= primc Double/TYPE) (= (aget parameterTypes i) Float/TYPE))
                        (let [#_"MaybePrimitiveExpr" pe (cast MaybePrimitiveExpr e)]
                            (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                            (.visitInsn gen, Opcodes/D2F)
                        )
                    :else
                        (do
                            (.emit e, :Context'EXPRESSION, objx, gen)
                            (HostExpr'emitUnboxArg objx, gen, (aget parameterTypes i))
                        )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr
    (def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (Method/getMethod "Object invokeInstanceMethod(Object, String, Object[])"))

    (defn- #_"InstanceMethodExpr" InstanceMethodExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
            #_"java.lang.reflect.Method" :method nil
        )
    )

    (defn #_"InstanceMethodExpr" InstanceMethodExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" target, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [#_"java.lang.reflect.Method" method
                (if (and (.hasJavaClass target) (some? (.getJavaClass target)))
                    (let [#_"List" methods (Reflector'getMethods (.getJavaClass target), (.count args), methodName, false)]
                        (if (.isEmpty methods)
                            (do
                                (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s on %s can't be resolved (no such method).\n", (object-array [ line, column, methodName, (.getName (.getJavaClass target)) ]))
                                )
                                nil
                            )
                            (let [#_"int" methodidx
                                    (when (< 1 (.size methods)) => 0
                                        (let [[#_"PersistentVector" pars #_"PersistentVector" rets]
                                                (loop-when [pars PersistentVector'EMPTY rets PersistentVector'EMPTY #_"int" i 0] [< i (.size methods)] => [pars rets]
                                                    (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.get methods, i))]
                                                        (recur (.cons pars, (.getParameterTypes m)) (.cons rets, (.getReturnType m)) (inc i))
                                                    )
                                                )]
                                            (Compiler'getMatchingParams methodName, pars, args, rets)
                                        )
                                    )
                                #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (when (<= 0 methodidx) (.get methods, methodidx)))
                                m (when (and (some? m) (not (Modifier/isPublic (.getModifiers (.getDeclaringClass m))))) => m
                                        ;; public method of non-public class, try to find it in hierarchy
                                        (Reflector'getAsMethodOfPublicBase (.getDeclaringClass m), m)
                                    )]
                                (when (and (nil? m) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", (object-array [ line, column, methodName, (.getName (.getJavaClass target)), (Compiler'getTypeStringForArgs args) ]))
                                )
                                m
                            )
                        )
                    )
                    (do
                        (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                            (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s can't be resolved (target class is unknown).\n", (object-array [ line, column, methodName ]))
                        )
                        nil
                    )
                )]
            (-> (merge (MethodExpr'new) (InstanceMethodExpr'init))
                (assoc :line line :column column :args args :methodName methodName :target target :tag tag :tailPosition tailPosition :method method)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" target (.eval (:target this)) #_"Object[]" args (make-array Object (.count (:args this)))]
                (dotimes [#_"int" i (.count (:args this))]
                    (aset args i (.eval (cast Expr (.nth (:args this), i))))
                )
                (if (some? (:method this))
                    (let [#_"List" ms (LinkedList.) _ (.add ms, (:method this))]
                        (Reflector'invokeMatchingMethod (:methodName this), ms, target, args)
                    )
                    (Reflector'invokeInstanceMethod target, (:methodName this), args)
                )
            )
            (catch Throwable e
                (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--InstanceMethodExpr [#_"InstanceMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (let [#_"Type" type (Type/getType (.getDeclaringClass (:method this)))]
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, type)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (and (:tailPosition this) (not (:canBeDirect objx)))
                    (ObjMethod''emitClearThis (cast ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (if (.isInterface (.getDeclaringClass (:method this)))
                        (.invokeInterface gen, type, m)
                        (.invokeVirtual gen, type, m)
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--InstanceMethodExpr [#_"InstanceMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:method this))
            (let [#_"Type" type (Type/getType (.getDeclaringClass (:method this)))]
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, type)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (if (.isInterface (.getDeclaringClass (:method this)))
                        (.invokeInterface gen, type, m)
                        (.invokeVirtual gen, type, m)
                    )
                    (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:method this)))
                )
            )
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.push gen, (:methodName this))
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this))))
    )
)

(class-ns StaticMethodExpr
    (def #_"Method" StaticMethodExpr'forNameMethod (Method/getMethod "Class classForName(String)"))
    (def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (Method/getMethod "Object invokeStaticMethod(Class, String, Object[])"))

    (defn- #_"StaticMethodExpr" StaticMethodExpr'init []
        (hash-map
            #_"Class" :c nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"java.lang.reflect.Method" :method nil
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
        )
    )

    (defn #_"StaticMethodExpr" StaticMethodExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Class" c, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [#_"java.lang.reflect.Method" method
                (let [#_"List" methods (Reflector'getMethods c, (.count args), methodName, true)]
                    (when-not (.isEmpty methods) => (throw (IllegalArgumentException. (str "No matching method: " methodName)))
                        (let [#_"int" methodidx
                                (when (< 1 (.size methods)) => 0
                                    (let [[#_"PersistentVector" pars #_"PersistentVector" rets]
                                            (loop-when [pars PersistentVector'EMPTY rets PersistentVector'EMPTY #_"int" i 0] [< i (.size methods)] => [pars rets]
                                                (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.get methods, i))]
                                                    (recur (.cons pars, (.getParameterTypes m)) (.cons rets, (.getReturnType m)) (inc i))
                                                )
                                            )]
                                        (Compiler'getMatchingParams methodName, pars, args, rets)
                                    )
                                )
                              #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (when (<= 0 methodidx) (.get methods, methodidx)))]
                            (when (and (nil? m) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", (object-array [ line, column, methodName, (.getName c), (Compiler'getTypeStringForArgs args) ]))
                            )
                            m
                        )
                    )
                )]
            (-> (merge (MethodExpr'new) (StaticMethodExpr'init))
                (assoc :c c :methodName methodName :args args :line line :column column :method method :tag tag :tailPosition tailPosition)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--StaticMethodExpr [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" args (make-array Object (.count (:args this)))]
                (dotimes [#_"int" i (.count (:args this))]
                    (aset args i (.eval (cast Expr (.nth (:args this), i))))
                )
                (if (some? (:method this))
                    (let [#_"List" ms (LinkedList.) _ (.add ms, (:method this))]
                        (Reflector'invokeMatchingMethod (:methodName this), ms, nil, args)
                    )
                    (Reflector'invokeStaticMethod-3c (:c this), (:methodName this), args)
                )
            )
            (catch Throwable e
                (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--StaticMethodExpr [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_method
    (defn #_"boolean" StaticMethodExpr''canEmitIntrinsicPredicate [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (some? (RT'get-2 Intrinsics'preds, (.toString (:method this)))))
    )

    #_method
    (defn #_"void" StaticMethodExpr''emitIntrinsicPredicate [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Label" falseLabel]
        (.visitLineNumber gen, (:line this), (.mark gen))
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
            (when (= context :Context'RETURN)
                (ObjMethod''emitClearLocals (cast ObjMethod (.deref Compiler'METHOD)), gen)
            )
            (let [#_"Object[]" predOps (cast RT'OBJECTS_CLASS (RT'get-2 Intrinsics'preds, (.toString (:method this))))]
                (dotimes [#_"int" i (dec (alength predOps))]
                    (.visitInsn gen, (cast Integer (aget predOps i)))
                )
                (.visitJumpInsn gen, (cast Integer (aget predOps (dec (alength predOps)))), falseLabel)
            )
        )
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--StaticMethodExpr [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
            (.visitLineNumber gen, (:line this), (.mark gen))
            (when (= context :Context'RETURN)
                (ObjMethod''emitClearLocals (cast ObjMethod (.deref Compiler'METHOD)), gen)
            )
            (let [#_"Object" ops (RT'get-2 Intrinsics'ops, (.toString (:method this)))]
                (if (some? ops)
                    (if (instance? RT'OBJECTS_CLASS ops)
                        (doseq [#_"Object" op (cast RT'OBJECTS_CLASS ops)]
                            (.visitInsn gen, (cast Integer op))
                        )
                        (.visitInsn gen, (cast Integer ops))
                    )
                    (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (.invokeStatic gen, (Type/getType (:c this)), m)
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--StaticMethodExpr [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:method this))
            (do
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (and (:tailPosition this) (not (:canBeDirect objx)))
                    (ObjMethod''emitClearThis (cast ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (let [#_"Type" type (Type/getType (:c this))
                      #_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (.invokeStatic gen, type, m)
                    (when (= context :Context'STATEMENT) => (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:method this)))
                        (let [#_"Class" rc (.getReturnType (:method this))]
                            (cond
                                (any = rc Long/TYPE Double/TYPE) (.pop2 gen)
                                (not (= rc Void/TYPE))           (.pop gen)
                            )
                        )
                    )
                )
            )
            (do
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.push gen, (.getName (:c this)))
                (.invokeStatic gen, Compiler'RT_TYPE, StaticMethodExpr'forNameMethod)
                (.push gen, (:methodName this))
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, StaticMethodExpr'invokeStaticMethodMethod)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StaticMethodExpr [#_"StaticMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--StaticMethodExpr [#_"StaticMethodExpr" this]
        (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this))))
    )
)

(class-ns UnresolvedVarExpr
    (defn- #_"UnresolvedVarExpr" UnresolvedVarExpr'init []
        (hash-map
            #_"Symbol" :symbol nil
        )
    )

    (defn #_"UnresolvedVarExpr" UnresolvedVarExpr'new [#_"Symbol" symbol]
        (let [this (UnresolvedVarExpr'init)]
            (assoc this :symbol symbol)
        )
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--UnresolvedVarExpr [#_"UnresolvedVarExpr" this]
        false
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--UnresolvedVarExpr [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_override
    (defn #_"void" Expr'''emit--UnresolvedVarExpr [#_"UnresolvedVarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        nil
    )

    #_override
    (defn #_"Object" Expr'''eval--UnresolvedVarExpr [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr
    (defn- #_"NumberExpr" NumberExpr'init []
        (hash-map
            #_"Number" :n nil
            #_"int" :id 0
        )
    )

    (defn #_"NumberExpr" NumberExpr'new [#_"Number" n]
        (let [this (merge (LiteralExpr'new) (NumberExpr'init))]
            (assoc this :n n :id (Compiler'registerConstant n))
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--NumberExpr [#_"NumberExpr" this]
        (:n this)
    )

    #_override
    (defn #_"void" Expr'''emit--NumberExpr [#_"NumberExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (ObjExpr''emitConstant objx, gen, (:id this))
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--NumberExpr [#_"NumberExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--NumberExpr [#_"NumberExpr" this]
        (cond
            (instance? Integer (:n this)) Long/TYPE
            (instance? Double (:n this))  Double/TYPE
            (instance? Long (:n this))    Long/TYPE
            :else                         (throw (IllegalStateException. (str "Unsupported Number type: " (.getName (.getClass (:n this))))))
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--NumberExpr [#_"NumberExpr" this]
        true
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--NumberExpr [#_"NumberExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (cond
            (instance? Integer (:n this)) (.push gen, (.longValue (:n this)))
            (instance? Double (:n this))  (.push gen, (.doubleValue (:n this)))
            (instance? Long (:n this))    (.push gen, (.longValue (:n this)))
        )
        nil
    )

    (defn #_"Expr" NumberExpr'parse [#_"Number" form]
        (if (or (instance? Integer form) (instance? Double form) (instance? Long form))
            (NumberExpr'new form)
            (ConstantExpr'new form)
        )
    )
)

(class-ns ConstantParser
    (ยง def #_"Keyword" ConstantParser'formKey (Keyword'intern (Symbol'intern "form")))

    (defn #_"IParser" ConstantParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (let [#_"int" argCount (dec (RT'count form))]
                    (if-not (= argCount 1)
                        (let [#_"IPersistentMap" exData (PersistentArrayMap'new-1 (object-array [ ConstantParser'formKey, form ]))]
                            (throw (ExceptionInfo'new-2 (str "Wrong number of args (" argCount ") passed to quote"), exData))
                        )
                        (let [#_"Object" v (RT'second form)]
                            (cond
                                (nil? v)             Compiler'NIL_EXPR
                                (= v Boolean/TRUE)   Compiler'TRUE_EXPR
                                (= v Boolean/FALSE)  Compiler'FALSE_EXPR
                                (instance? Number v) (NumberExpr'parse (cast Number v))
                                (instance? String v) (StringExpr'new (cast String v))
                                (and (instance? IPersistentCollection v) (zero? (.count (cast IPersistentCollection v)))) (EmptyExpr'new v)
                                :else                (ConstantExpr'new v)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr
    (defn- #_"ConstantExpr" ConstantExpr'init []
        (hash-map
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            #_"Object" :v nil
            #_"int" :id 0
        )
    )

    (defn #_"ConstantExpr" ConstantExpr'new [#_"Object" v]
        (let [this (merge (LiteralExpr'new) (ConstantExpr'init))]
            (assoc this :v v :id (Compiler'registerConstant v))
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--ConstantExpr [#_"ConstantExpr" this]
        (:v this)
    )

    #_override
    (defn #_"void" Expr'''emit--ConstantExpr [#_"ConstantExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitConstant objx, gen, (:id this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ConstantExpr [#_"ConstantExpr" this]
        (Modifier/isPublic (.getModifiers (.getClass (:v this))))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ConstantExpr [#_"ConstantExpr" this]
        (cond
            (instance? APersistentMap (:v this))    APersistentMap
            (instance? APersistentSet (:v this))    APersistentSet
            (instance? APersistentVector (:v this)) APersistentVector
            :else                                   (.getClass (:v this))
        )
    )
)

(class-ns NilExpr
    (defn #_"NilExpr" NilExpr'new []
        (LiteralExpr'new)
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--NilExpr [#_"NilExpr" this]
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--NilExpr [#_"NilExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitInsn gen, Opcodes/ACONST_NULL)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--NilExpr [#_"NilExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--NilExpr [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr
    (defn- #_"BooleanExpr" BooleanExpr'init []
        (hash-map
            #_"boolean" :val false
        )
    )

    (defn #_"BooleanExpr" BooleanExpr'new [#_"boolean" val]
        (let [this (merge (LiteralExpr'new) (BooleanExpr'init))]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--BooleanExpr [#_"BooleanExpr" this]
        (if (:val this) RT'T RT'F)
    )

    #_override
    (defn #_"void" Expr'''emit--BooleanExpr [#_"BooleanExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, (if (:val this) "TRUE" "FALSE"), Compiler'BOOLEAN_OBJECT_TYPE)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--BooleanExpr [#_"BooleanExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--BooleanExpr [#_"BooleanExpr" this]
        Boolean
    )
)

(class-ns StringExpr
    (defn- #_"StringExpr" StringExpr'init []
        (hash-map
            #_"String" :str nil
        )
    )

    (defn #_"StringExpr" StringExpr'new [#_"String" str]
        (let [this (merge (LiteralExpr'new) (StringExpr'init))]
            (assoc this :str str)
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--StringExpr [#_"StringExpr" this]
        (:str this)
    )

    #_override
    (defn #_"void" Expr'''emit--StringExpr [#_"StringExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (.push gen, (:str this))
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StringExpr [#_"StringExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--StringExpr [#_"StringExpr" this]
        String
    )
)

(class-ns MonitorEnterParser
    (defn #_"IParser" MonitorEnterParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (MonitorEnterExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
            )
        )
    )
)

(class-ns MonitorEnterExpr
    (defn- #_"MonitorEnterExpr" MonitorEnterExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorEnterExpr" MonitorEnterExpr'new [#_"Expr" target]
        (let [this (merge (UntypedExpr'new) (MonitorEnterExpr'init))]
            (assoc this :target target)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MonitorEnterExpr [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_override
    (defn #_"void" Expr'''emit--MonitorEnterExpr [#_"MonitorEnterExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:target this), :Context'EXPRESSION, objx, gen)
        (.monitorEnter gen)
        (.emit Compiler'NIL_EXPR, context, objx, gen)
        nil
    )
)

(class-ns MonitorExitParser
    (defn #_"IParser" MonitorExitParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (MonitorExitExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
            )
        )
    )
)

(class-ns MonitorExitExpr
    (defn- #_"MonitorExitExpr" MonitorExitExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorExitExpr" MonitorExitExpr'new [#_"Expr" target]
        (let [this (merge (UntypedExpr'new) (MonitorExitExpr'init))]
            (assoc this :target target)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MonitorExitExpr [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_override
    (defn #_"void" Expr'''emit--MonitorExitExpr [#_"MonitorExitExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:target this), :Context'EXPRESSION, objx, gen)
        (.monitorExit gen)
        (.emit Compiler'NIL_EXPR, context, objx, gen)
        nil
    )
)

(class-ns CatchClause
    (defn- #_"CatchClause" CatchClause'init []
        (hash-map
            #_"Class" :c nil
            #_"LocalBinding" :lb nil
            #_"Expr" :handler nil
            #_"Label" :label nil
            #_"Label" :endLabel nil
        )
    )

    (defn #_"CatchClause" CatchClause'new [#_"Class" c, #_"LocalBinding" lb, #_"Expr" handler]
        (let [this (CatchClause'init)]
            (assoc this :c c :lb lb :handler handler)
        )
    )
)

(class-ns TryParser
    (defn #_"IParser" TryParser'new []
        (reify IParser
            ;; (try try-expr* catch-expr* finally-expr?)
            ;; catch-expr: (catch class sym expr*)
            ;; finally-expr: (finally expr*)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"ISeq" form (cast ISeq frm)]
                    (when (= context :Context'RETURN) => (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                        (let [#_"PersistentVector" body PersistentVector'EMPTY #_"PersistentVector" catches PersistentVector'EMPTY
                              #_"Expr" bodyExpr nil #_"Expr" finallyExpr nil #_"boolean" caught false
                              #_"int" retLocal (Compiler'getAndIncLocalNum) #_"int" finallyLocal (Compiler'getAndIncLocalNum)]

                            (loop-when-recur [#_"ISeq" fs (.next form)] (some? fs) [(.next fs)]
                                (let [#_"Object" f (.first fs) #_"Object" op (when (instance? ISeq f) (.first (cast ISeq f)))]
                                    (if (and (not (Util'equals op, Compiler'CATCH)) (not (Util'equals op, Compiler'FINALLY)))
                                        (do
                                            (when-not caught => (throw (RuntimeException. "Only catch or finally clause can follow catch in try expression"))
                                                (ร ass body (.cons body, f))
                                            )
                                        )
                                        (do
                                            (when (nil? bodyExpr)
                                                (try
                                                    (Var'pushThreadBindings (RT'map
                                                        (object-array [
                                                            Compiler'NO_RECUR              true
                                                            Compiler'METHOD_RETURN_CONTEXT nil
                                                        ])
                                                    ))
                                                    (ร ass bodyExpr (.parse (BodyParser'new), context, (RT'seq body)))
                                                    (finally
                                                        (Var'popThreadBindings)
                                                    )
                                                )
                                            )

                                            (cond (Util'equals op, Compiler'CATCH)
                                                (let [#_"Class" c (HostExpr'maybeClass (RT'second f), false)]
                                                    (when (nil? c)
                                                        (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second f))))
                                                    )
                                                    (when (not (instance? Symbol (RT'third f)))
                                                        (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (RT'third f))))
                                                    )
                                                    (let [#_"Symbol" sym (cast Symbol (RT'third f))]
                                                        (when (some? (.getNamespace sym))
                                                            (throw (RuntimeException. (str "Can't bind qualified name:" sym)))
                                                        )
                                                        (let [#_"IPersistentMap" dynamicBindings
                                                                (RT'map
                                                                    (object-array [
                                                                        Compiler'LOCAL_ENV        (.deref Compiler'LOCAL_ENV)
                                                                        Compiler'NEXT_LOCAL_NUM   (.deref Compiler'NEXT_LOCAL_NUM)
                                                                        Compiler'IN_CATCH_FINALLY RT'T
                                                                    ])
                                                                )]
                                                            (try
                                                                (Var'pushThreadBindings dynamicBindings)
                                                                (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (cast Symbol (when (instance? Symbol (RT'second f)) (RT'second f))), nil, false)
                                                                      #_"Expr" handler (.parse (BodyParser'new), :Context'EXPRESSION, (RT'next (RT'next (RT'next f))))]
                                                                    (ร ass catches (.cons catches, (CatchClause'new c, lb, handler)))
                                                                )
                                                                (finally
                                                                    (Var'popThreadBindings)
                                                                )
                                                            )
                                                            (ร ass caught true)
                                                        )
                                                    )
                                                )
                                                :else ;; finally
                                                (do
                                                    (when (some? (.next fs))
                                                        (throw (RuntimeException. "finally clause must be last in try expression"))
                                                    )
                                                    (try
                                                        (Var'pushThreadBindings (RT'map
                                                            (object-array [
                                                                Compiler'IN_CATCH_FINALLY RT'T
                                                            ])
                                                        ))
                                                        (ร ass finallyExpr (.parse (BodyParser'new), :Context'STATEMENT, (RT'next f)))
                                                        (finally
                                                            (Var'popThreadBindings)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )

                            (when (nil? bodyExpr) => (TryExpr'new bodyExpr, catches, finallyExpr, retLocal, finallyLocal)
                                ;; when there is neither catch nor finally, e.g. (try (expr)) return a body expr directly
                                (try
                                    (Var'pushThreadBindings (RT'map
                                        (object-array [
                                            Compiler'NO_RECUR true
                                        ])
                                    ))
                                    (.parse (BodyParser'new), context, (RT'seq body))
                                    (finally
                                        (Var'popThreadBindings)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr
    (defn- #_"TryExpr" TryExpr'init []
        (hash-map
            #_"Expr" :tryExpr nil
            #_"Expr" :finallyExpr nil
            #_"PersistentVector" :catchExprs nil
            #_"int" :retLocal 0
            #_"int" :finallyLocal 0
        )
    )

    (defn #_"TryExpr" TryExpr'new [#_"Expr" tryExpr, #_"PersistentVector" catchExprs, #_"Expr" finallyExpr, #_"int" retLocal, #_"int" finallyLocal]
        (let [this (TryExpr'init)]
            (assoc this :tryExpr tryExpr :catchExprs catchExprs :finallyExpr finallyExpr :retLocal retLocal :finallyLocal finallyLocal)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--TryExpr [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_override
    (defn #_"void" Expr'''emit--TryExpr [#_"TryExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" startTry (.newLabel gen) #_"Label" endTry (.newLabel gen) #_"Label" end (.newLabel gen) #_"Label" ret (.newLabel gen) #_"Label" finallyLabel (.newLabel gen)]
            (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                (let [#_"CatchClause" clause (cast CatchClause (.nth (:catchExprs this), i))]
                    (ร ass (:label clause) (.newLabel gen))
                    (ร ass (:endLabel clause) (.newLabel gen))
                )
            )

            (.mark gen, startTry)
            (.emit (:tryExpr this), context, objx, gen)
            (when (not= context :Context'STATEMENT)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:retLocal this))
            )
            (.mark gen, endTry)
            (when (some? (:finallyExpr this))
                (.emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
            )
            (.goTo gen, ret)

            (dotimes [#_"int" i (.count (:catchExprs this))]
                (let [#_"CatchClause" clause (cast CatchClause (.nth (:catchExprs this), i))]
                    (.mark gen, (:label clause))
                    ;; exception should be on stack
                    ;; put in clause local
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:lb clause)))
                    (.emit (:handler clause), context, objx, gen)
                    (when (not= context :Context'STATEMENT)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:retLocal this))
                    )
                    (.mark gen, (:endLabel clause))

                    (when (some? (:finallyExpr this))
                        (.emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
                    )
                    (.goTo gen, ret)
                )
            )
            (when (some? (:finallyExpr this))
                (.mark gen, finallyLabel)
                ;; exception should be on stack
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:finallyLocal this))
                (.emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:finallyLocal this))
                (.throwException gen)
            )
            (.mark gen, ret)
            (when (not= context :Context'STATEMENT)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:retLocal this))
            )
            (.mark gen, end)
            (dotimes [#_"int" i (.count (:catchExprs this))]
                (let [#_"CatchClause" clause (cast CatchClause (.nth (:catchExprs this), i))]
                    (.visitTryCatchBlock gen, startTry, endTry, (:label clause), (.replace (.getName (:c clause)), \., \/))
                )
            )
            (when (some? (:finallyExpr this))
                (.visitTryCatchBlock gen, startTry, endTry, finallyLabel, nil)
                (dotimes [#_"int" i (.count (:catchExprs this))]
                    (let [#_"CatchClause" clause (cast CatchClause (.nth (:catchExprs this), i))]
                        (.visitTryCatchBlock gen, (:label clause), (:endLabel clause), finallyLabel, nil)
                    )
                )
            )
            (dotimes [#_"int" i (.count (:catchExprs this))]
                (let [#_"CatchClause" clause (cast CatchClause (.nth (:catchExprs this), i))]
                    (.visitLocalVariable gen, (:name (:lb clause)), "Ljava/lang/Object;", nil, (:label clause), (:endLabel clause), (:idx (:lb clause)))
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--TryExpr [#_"TryExpr" this]
        (.hasJavaClass (:tryExpr this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--TryExpr [#_"TryExpr" this]
        (.getJavaClass (:tryExpr this))
    )
)

(class-ns ThrowParser
    (defn #_"IParser" ThrowParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (cond
                    (= context :Context'EVAL) (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                    (= (RT'count form) 1)     (throw (RuntimeException. "Too few arguments to throw, throw expects a single Throwable instance"))
                    (< 2 (RT'count form))     (throw (RuntimeException. "Too many arguments to throw, throw expects a single Throwable instance"))
                    :else                     (ThrowExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
                )
            )
        )
    )
)

(class-ns ThrowExpr
    (defn- #_"ThrowExpr" ThrowExpr'init []
        (hash-map
            #_"Expr" :excExpr nil
        )
    )

    (defn #_"ThrowExpr" ThrowExpr'new [#_"Expr" excExpr]
        (let [this (merge (UntypedExpr'new) (ThrowExpr'init))]
            (assoc this :excExpr excExpr)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ThrowExpr [#_"ThrowExpr" this]
        (throw (RuntimeException. "Can't eval throw"))
    )

    #_override
    (defn #_"void" Expr'''emit--ThrowExpr [#_"ThrowExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:excExpr this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, Compiler'THROWABLE_TYPE)
        (.throwException gen)
        nil
    )
)

(class-ns NewParser
    (defn #_"IParser" NewParser'new []
        (reify IParser
            ;; (new Classname args...)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref) #_"ISeq" form (cast ISeq frm)]
                    (when (< 1 (.count form)) => (throw (RuntimeException. "wrong number of arguments, expecting: (new Classname args...)"))
                        (let [#_"Class" c (HostExpr'maybeClass (RT'second form), false)]
                            (when (some? c) => (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second form))))
                                (let [#_"PersistentVector" args
                                        (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'next (RT'next form))]
                                                         (some? s)
                                                         [(.cons args, (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))) (.next s)]
                                                      => args
                                        )]
                                    (NewExpr'new c, args, line, column)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr
    (def #_"Method" NewExpr'invokeConstructorMethod (Method/getMethod "Object invokeConstructor(Class, Object[])"))
    (def #_"Method" NewExpr'forNameMethod (Method/getMethod "Class classForName(String)"))

    (defn- #_"NewExpr" NewExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"Constructor" :ctor nil
            #_"Class" :c nil
        )
    )

    (defn #_"NewExpr" NewExpr'new [#_"Class" c, #_"IPersistentVector" args, #_"int" line, #_"int" column]
        (let [#_"Constructor" ctor
                (let [#_"Constructor[]" allctors (.getConstructors c)
                      [#_"PersistentVector" ctors #_"PersistentVector" pars #_"PersistentVector" rets]
                        (loop-when [ctors PersistentVector'EMPTY pars PersistentVector'EMPTY rets PersistentVector'EMPTY #_"int" i 0] [< i (alength allctors)] => [ctors pars rets]
                            (let [#_"Constructor" ctor (aget allctors i) #_"Class[]" types (.getParameterTypes ctor)
                                  [ctors pars rets]
                                    (when (= (alength types) (.count args)) => [ctors pars rets]
                                        [(.cons ctors, ctor) (.cons pars, types) (.cons rets, c)]
                                    )]
                                (recur ctors pars rets (inc i))
                            )
                        )]
                    (let-when [#_"int" n (.count ctors)] (< 0 n) => (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                        (let [#_"int" i (if (< 1 n) (Compiler'getMatchingParams (.getName c), pars, args, rets) 0)
                              #_"Constructor" ctor (when (<= 0 i) (cast Constructor (.nth ctors, i)))]
                            (when (and (nil? ctor) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to %s ctor can't be resolved.\n", (object-array [ line, column, (.getName c) ]))
                            )
                            ctor
                        )
                    )
                )]
            (-> (NewExpr'init)
                (assoc :args args :ctor ctor :c c)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--NewExpr [#_"NewExpr" this]
        (let [#_"Object[]" args (make-array Object (.count (:args this)))]
            (dotimes [#_"int" i (.count (:args this))]
                (aset args i (.eval (cast Expr (.nth (:args this), i))))
            )
            (when (some? (:ctor this)) => (Reflector'invokeConstructor (:c this), args)
                (.newInstance (:ctor this), (Reflector'boxArgs (.getParameterTypes (:ctor this)), args))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--NewExpr [#_"NewExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:ctor this))
            (let [#_"Type" type (Compiler'getType (:c this))]
                (.newInstance gen, type)
                (.dup gen)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:ctor this)), (:args this))
                (.invokeConstructor gen, type, (Method. "<init>", (Type/getConstructorDescriptor (:ctor this))))
            )
            (do
                (.push gen, (Compiler'destubClassName (.getName (:c this))))
                (.invokeStatic gen, Compiler'RT_TYPE, NewExpr'forNameMethod)
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, NewExpr'invokeConstructorMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--NewExpr [#_"NewExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--NewExpr [#_"NewExpr" this]
        (:c this)
    )
)

(class-ns MetaExpr
    (def #_"Type" MetaExpr'IOBJ_TYPE (Type/getType IObj))
    (def #_"Method" MetaExpr'withMetaMethod (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

    (defn- #_"MetaExpr" MetaExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Expr" :meta nil
        )
    )

    (defn #_"MetaExpr" MetaExpr'new [#_"Expr" expr, #_"Expr" meta]
        (let [this (MetaExpr'init)]
            (assoc this :expr expr :meta meta)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MetaExpr [#_"MetaExpr" this]
        (.withMeta (cast IObj (.eval (:expr this))), (cast IPersistentMap (.eval (:meta this))))
    )

    #_override
    (defn #_"void" Expr'''emit--MetaExpr [#_"MetaExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, MetaExpr'IOBJ_TYPE)
        (.emit (:meta this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
        (.invokeInterface gen, MetaExpr'IOBJ_TYPE, MetaExpr'withMetaMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--MetaExpr [#_"MetaExpr" this]
        (.hasJavaClass (:expr this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--MetaExpr [#_"MetaExpr" this]
        (.getJavaClass (:expr this))
    )
)

(class-ns IfParser
    (defn #_"IParser" IfParser'new []
        (reify IParser
            ;; (if test then) or (if test then else)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"ISeq" form (cast ISeq frm)]
                    (cond
                        (< 4 (.count form)) (throw (RuntimeException. "Too many arguments to if"))
                        (< (.count form) 3) (throw (RuntimeException. "Too few arguments to if"))
                    )
                    (let [#_"PathNode" branch (PathNode'new :PathType'BRANCH, (cast PathNode (Var''get Compiler'CLEAR_PATH)))
                          #_"Expr" testexpr (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'second form))
                          #_"Expr" thenexpr
                            (try
                                (Var'pushThreadBindings (RT'map
                                    (object-array [
                                        Compiler'CLEAR_PATH (PathNode'new :PathType'PATH, branch)
                                    ])
                                ))
                                (Compiler'analyze-2 context, (RT'third form))
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                          #_"Expr" elseexpr
                            (try
                                (Var'pushThreadBindings (RT'map
                                    (object-array [
                                        Compiler'CLEAR_PATH (PathNode'new :PathType'PATH, branch)
                                    ])
                                ))
                                (Compiler'analyze-2 context, (RT'fourth form))
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )]
                        (IfExpr'new (Compiler'lineDeref), (Compiler'columnDeref), testexpr, thenexpr, elseexpr)
                    )
                )
            )
        )
    )
)

(class-ns IfExpr
    (defn- #_"IfExpr" IfExpr'init []
        (hash-map
            #_"Expr" :testExpr nil
            #_"Expr" :thenExpr nil
            #_"Expr" :elseExpr nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"IfExpr" IfExpr'new [#_"int" line, #_"int" column, #_"Expr" testExpr, #_"Expr" thenExpr, #_"Expr" elseExpr]
        (let [this (IfExpr'init)]
            (assoc this :testExpr testExpr :thenExpr thenExpr :elseExpr elseExpr :line line :column column)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--IfExpr [#_"IfExpr" this]
        (let [#_"Object" t (.eval (:testExpr this))]
            (if (and (some? t) (not= t Boolean/FALSE))
                (.eval (:thenExpr this))
                (.eval (:elseExpr this))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--IfExpr [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (IfExpr''doEmit this, context, objx, gen, false)
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--IfExpr [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (IfExpr''doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (defn- #_"void" IfExpr''doEmit [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"Label" nullLabel (.newLabel gen) #_"Label" falseLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
            (.visitLineNumber gen, (:line this), (.mark gen))

            (cond (and (instance? StaticMethodExpr (:testExpr this)) (StaticMethodExpr''canEmitIntrinsicPredicate (cast StaticMethodExpr (:testExpr this))))
                (do
                    (StaticMethodExpr''emitIntrinsicPredicate (cast StaticMethodExpr (:testExpr this)), :Context'EXPRESSION, objx, gen, falseLabel)
                )
                (= (Compiler'maybePrimitiveType (:testExpr this)) Boolean/TYPE)
                (do
                    (.emitUnboxed (cast MaybePrimitiveExpr (:testExpr this)), :Context'EXPRESSION, objx, gen)
                    (.ifZCmp gen, GeneratorAdapter/EQ, falseLabel)
                )
                :else
                (do
                    (.emit (:testExpr this), :Context'EXPRESSION, objx, gen)
                    (.dup gen)
                    (.ifNull gen, nullLabel)
                    (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                    (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, falseLabel)
                )
            )
            (if emitUnboxed
                (.emitUnboxed (cast MaybePrimitiveExpr (:thenExpr this)), context, objx, gen)
                (.emit (:thenExpr this), context, objx, gen)
            )
            (.goTo gen, endLabel)
            (.mark gen, nullLabel)
            (.pop gen)
            (.mark gen, falseLabel)
            (if emitUnboxed
                (.emitUnboxed (cast MaybePrimitiveExpr (:elseExpr this)), context, objx, gen)
                (.emit (:elseExpr this), context, objx, gen)
            )
            (.mark gen, endLabel)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--IfExpr [#_"IfExpr" this]
        (and (.hasJavaClass (:thenExpr this))
             (.hasJavaClass (:elseExpr this))
            (or (= (.getJavaClass (:thenExpr this)) (.getJavaClass (:elseExpr this)))
                (= (.getJavaClass (:thenExpr this)) Recur)
                (= (.getJavaClass (:elseExpr this)) Recur)
                (and (nil? (.getJavaClass (:thenExpr this))) (not (.isPrimitive (.getJavaClass (:elseExpr this)))))
                (and (nil? (.getJavaClass (:elseExpr this))) (not (.isPrimitive (.getJavaClass (:thenExpr this)))))))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--IfExpr [#_"IfExpr" this]
        (try
            (and (instance? MaybePrimitiveExpr (:thenExpr this))
                 (instance? MaybePrimitiveExpr (:elseExpr this))
                (or (= (.getJavaClass (:thenExpr this)) (.getJavaClass (:elseExpr this)))
                    (= (.getJavaClass (:thenExpr this)) Recur)
                    (= (.getJavaClass (:elseExpr this)) Recur))
                 (.canEmitPrimitive (cast MaybePrimitiveExpr (:thenExpr this)))
                 (.canEmitPrimitive (cast MaybePrimitiveExpr (:elseExpr this))))
            (catch Exception e
                false
            )
        )
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--IfExpr [#_"IfExpr" this]
        (let [#_"Class" thenClass (.getJavaClass (:thenExpr this))]
            (if (and (some? thenClass) (not= thenClass Recur))
                thenClass
                (.getJavaClass (:elseExpr this))
            )
        )
    )
)

(class-ns EmptyExpr
    (def #_"Type" EmptyExpr'HASHMAP_TYPE (Type/getType PersistentArrayMap))
    (def #_"Type" EmptyExpr'HASHSET_TYPE (Type/getType PersistentHashSet))
    (def #_"Type" EmptyExpr'VECTOR_TYPE (Type/getType PersistentVector))
    (def #_"Type" EmptyExpr'IVECTOR_TYPE (Type/getType IPersistentVector))
    (def #_"Type" EmptyExpr'TUPLE_TYPE (Type/getType Tuple))
    (def #_"Type" EmptyExpr'LIST_TYPE (Type/getType PersistentList))
    (def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (Type/getType EmptyList))

    (defn- #_"EmptyExpr" EmptyExpr'init []
        (hash-map
            #_"Object" :coll nil
        )
    )

    (defn #_"EmptyExpr" EmptyExpr'new [#_"Object" coll]
        (let [this (EmptyExpr'init)]
            (assoc this :coll coll)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--EmptyExpr [#_"EmptyExpr" this]
        (:coll this)
    )

    #_override
    (defn #_"void" Expr'''emit--EmptyExpr [#_"EmptyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (cond
            (instance? IPersistentList (:coll this))   (.getStatic gen, EmptyExpr'LIST_TYPE,    "EMPTY", EmptyExpr'EMPTY_LIST_TYPE)
            (instance? IPersistentVector (:coll this)) (.getStatic gen, EmptyExpr'VECTOR_TYPE,  "EMPTY", EmptyExpr'VECTOR_TYPE)
            (instance? IPersistentMap (:coll this))    (.getStatic gen, EmptyExpr'HASHMAP_TYPE, "EMPTY", EmptyExpr'HASHMAP_TYPE)
            (instance? IPersistentSet (:coll this))    (.getStatic gen, EmptyExpr'HASHSET_TYPE, "EMPTY", EmptyExpr'HASHSET_TYPE)
            :else                                      (throw (UnsupportedOperationException. "Unknown collection type"))
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--EmptyExpr [#_"EmptyExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--EmptyExpr [#_"EmptyExpr" this]
        (cond
            (instance? IPersistentList (:coll this))   IPersistentList
            (instance? IPersistentVector (:coll this)) IPersistentVector
            (instance? IPersistentMap (:coll this))    IPersistentMap
            (instance? IPersistentSet (:coll this))    IPersistentSet
            :else                                      (throw (UnsupportedOperationException. "Unknown collection type"))
        )
    )
)

(class-ns ListExpr
    (def #_"Method" ListExpr'arrayToListMethod (Method/getMethod "cloiure.lang.ISeq arrayToList(Object[])"))

    (defn- #_"ListExpr" ListExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"ListExpr" ListExpr'new [#_"IPersistentVector" args]
        (let [this (ListExpr'init)]
            (assoc this :args args)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ListExpr [#_"ListExpr" this]
        (loop-when-recur [#_"IPersistentVector" v PersistentVector'EMPTY #_"int" i 0]
                         (< i (.count (:args this)))
                         [(cast IPersistentVector (.cons v, (.eval (cast Expr (.nth (:args this), i))))) (inc i)]
                      => (.seq v)
        )
    )

    #_override
    (defn #_"void" Expr'''emit--ListExpr [#_"ListExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MethodExpr'emitArgsAsArray (:args this), objx, gen)
        (.invokeStatic gen, Compiler'RT_TYPE, ListExpr'arrayToListMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ListExpr [#_"ListExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ListExpr [#_"ListExpr" this]
        IPersistentList
    )
)

(class-ns MapExpr
    (def #_"Method" MapExpr'mapMethod (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
    (def #_"Method" MapExpr'mapUniqueKeysMethod (Method/getMethod "cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

    (defn- #_"MapExpr" MapExpr'init []
        (hash-map
            #_"IPersistentVector" :keyvals nil
        )
    )

    (defn #_"MapExpr" MapExpr'new [#_"IPersistentVector" keyvals]
        (let [this (MapExpr'init)]
            (assoc this :keyvals keyvals)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MapExpr [#_"MapExpr" this]
        (let [#_"Object[]" a (make-array Object (.count (:keyvals this)))]
            (dotimes [#_"int" i (.count (:keyvals this))]
                (aset a i (.eval (cast Expr (.nth (:keyvals this), i))))
            )
            (RT'map a)
        )
    )

    #_override
    (defn #_"void" Expr'''emit--MapExpr [#_"MapExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [[#_"boolean" allKeysConstant #_"boolean" allConstantKeysUnique]
                (loop-when [constant? true unique? true #_"IPersistentSet" keys PersistentHashSet'EMPTY #_"int" i 0] (< i (.count (:keyvals this))) => [constant? unique?]
                    (let [#_"Expr" k (cast Expr (.nth (:keyvals this), i))
                          [constant? unique? keys]
                            (when (instance? LiteralExpr k) => [false unique? keys]
                                (let-when-not [#_"Object" v (.eval k)] (.contains keys, v) => [constant? false keys]
                                    [constant? unique? (cast IPersistentSet (.cons keys, v))]
                                )
                            )]
                        (recur constant? unique? keys (+ i 2))
                    )
                )]
            (MethodExpr'emitArgsAsArray (:keyvals this), objx, gen)
            (if (or (and allKeysConstant allConstantKeysUnique) (<= (.count (:keyvals this)) 2))
                (.invokeStatic gen, Compiler'RT_TYPE, MapExpr'mapUniqueKeysMethod)
                (.invokeStatic gen, Compiler'RT_TYPE, MapExpr'mapMethod)
            )
            (when (= context :Context'STATEMENT)
                (.pop gen)
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--MapExpr [#_"MapExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--MapExpr [#_"MapExpr" this]
        IPersistentMap
    )

    (defn #_"Expr" MapExpr'parse [#_"Context" context, #_"IPersistentMap" form]
        (let [#_"IPersistentVector" keyvals PersistentVector'EMPTY
              #_"boolean" keysConstant true #_"boolean" valsConstant true #_"boolean" allConstantKeysUnique true
              #_"IPersistentSet" constantKeys PersistentHashSet'EMPTY]
            (loop-when-recur [#_"ISeq" s (RT'seq form)] (some? s) [(.next s)]
                (let [#_"IMapEntry" e (cast IMapEntry (.first s))
                      #_"Expr" k (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.key e))
                      #_"Expr" v (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.val e))]
                    (ร ass keyvals (cast IPersistentVector (.cons keyvals, k)))
                    (ร ass keyvals (cast IPersistentVector (.cons keyvals, v)))
                    (if (instance? LiteralExpr k)
                        (let [#_"Object" kval (.eval k)]
                            (if (.contains constantKeys, kval)
                                (ร ass allConstantKeysUnique false)
                                (ร ass constantKeys (cast IPersistentSet (.cons constantKeys, kval)))
                            )
                        )
                        (ร ass keysConstant false)
                    )
                    (when (not (instance? LiteralExpr v))
                        (ร ass valsConstant false)
                    )
                )
            )

            (let [#_"Expr" e (MapExpr'new keyvals)]
                (cond
                    (and (instance? IObj form) (some? (.meta (cast IObj form))))
                        (MetaExpr'new e, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast IObj form))))
                    keysConstant
                        ;; TBD: Add more detail to exception thrown below.
                        (when allConstantKeysUnique => (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                            (when valsConstant => e
                                (loop-when-recur [#_"IPersistentMap" m PersistentArrayMap'EMPTY #_"int" i 0]
                                                 (< i (.length keyvals))
                                                 [(.assoc m, (.val (cast LiteralExpr (.nth keyvals, i))), (.val (cast LiteralExpr (.nth keyvals, (inc i))))) (+ i 2)]
                                              => (ConstantExpr'new m)
                                )
                            )
                        )
                    :else
                        e
                )
            )
        )
    )
)

(class-ns SetExpr
    (def #_"Method" SetExpr'setMethod (Method/getMethod "cloiure.lang.IPersistentSet set(Object[])"))

    (defn- #_"SetExpr" SetExpr'init []
        (hash-map
            #_"IPersistentVector" :keys nil
        )
    )

    (defn #_"SetExpr" SetExpr'new [#_"IPersistentVector" keys]
        (let [this (SetExpr'init)]
            (assoc this :keys keys)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--SetExpr [#_"SetExpr" this]
        (let [#_"Object[]" ret (make-array Object (.count (:keys this)))]
            (dotimes [#_"int" i (.count (:keys this))]
                (aset ret i (.eval (cast Expr (.nth (:keys this), i))))
            )
            (RT'set ret)
        )
    )

    #_override
    (defn #_"void" Expr'''emit--SetExpr [#_"SetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MethodExpr'emitArgsAsArray (:keys this), objx, gen)
        (.invokeStatic gen, Compiler'RT_TYPE, SetExpr'setMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--SetExpr [#_"SetExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--SetExpr [#_"SetExpr" this]
        IPersistentSet
    )

    (defn #_"Expr" SetExpr'parse [#_"Context" context, #_"IPersistentSet" form]
        (let [[#_"IPersistentVector" keys #_"boolean" constant?]
                (loop-when [keys PersistentVector'EMPTY constant? true #_"ISeq" s (RT'seq form)] (some? s) => [keys constant?]
                    (let [#_"Expr" e (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))]
                        (recur (cast IPersistentVector (.cons keys, e)) (and constant? (instance? LiteralExpr e)) (.next s))
                    )
                )]
            (cond
                (and (instance? IObj form) (some? (.meta (cast IObj form))))
                    (MetaExpr'new (SetExpr'new keys), (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast IObj form))))
                constant?
                    (loop-when-recur [#_"IPersistentSet" s PersistentHashSet'EMPTY #_"int" i 0]
                                     (< i (.count keys))
                                     [(cast IPersistentSet (.cons s, (.val (cast LiteralExpr (.nth keys, i))))) (inc i)]
                                  => (ConstantExpr'new s)
                    )
                :else
                    (SetExpr'new keys)
            )
        )
    )
)

(class-ns VectorExpr
    (def #_"Method" VectorExpr'vectorMethod (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))

    (defn- #_"VectorExpr" VectorExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"VectorExpr" VectorExpr'new [#_"IPersistentVector" args]
        (let [this (VectorExpr'init)]
            (assoc this :args args)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--VectorExpr [#_"VectorExpr" this]
        (loop-when-recur [#_"IPersistentVector" v PersistentVector'EMPTY #_"int" i 0]
                         (< i (.count (:args this)))
                         [(cast IPersistentVector (.cons v, (.eval (cast Expr (.nth (:args this), i))))) (inc i)]
                      => v
        )
    )

    #_override
    (defn #_"void" Expr'''emit--VectorExpr [#_"VectorExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (<= (.count (:args this)) Tuple'MAX_SIZE)
            (do
                (dotimes [#_"int" i (.count (:args this))]
                    (.emit (cast Expr (.nth (:args this), i)), :Context'EXPRESSION, objx, gen)
                )
                (.invokeStatic gen, Compiler'TUPLE_TYPE, (aget Compiler'createTupleMethods (.count (:args this))))
            )
            (do
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.invokeStatic gen, Compiler'RT_TYPE, VectorExpr'vectorMethod)
            )
        )

        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--VectorExpr [#_"VectorExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--VectorExpr [#_"VectorExpr" this]
        IPersistentVector
    )

    (defn #_"Expr" VectorExpr'parse [#_"Context" context, #_"IPersistentVector" form]
        (let [[#_"IPersistentVector" args #_"boolean" constant?]
                (loop-when [args PersistentVector'EMPTY constant? true #_"int" i 0] (< i (.count form)) => [args constant?]
                    (let [#_"Expr" e (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.nth form, i))]
                        (recur (cast IPersistentVector (.cons args, e)) (and constant? (instance? LiteralExpr e)) (inc i))
                    )
                )]
            (cond
                (and (instance? IObj form) (some? (.meta (cast IObj form))))
                    (MetaExpr'new (VectorExpr'new args), (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast IObj form))))
                constant?
                    (loop-when-recur [#_"IPersistentVector" v PersistentVector'EMPTY #_"int" i 0]
                                     (< i (.count args))
                                     [(.cons v, (.val (cast LiteralExpr (.nth args, i)))) (inc i)]
                                  => (ConstantExpr'new v)
                    )
                :else
                    (VectorExpr'new args)
            )
        )
    )
)

(class-ns KeywordInvokeExpr
    (def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (Type/getType ILookup))

    (defn- #_"KeywordInvokeExpr" KeywordInvokeExpr'init []
        (hash-map
            #_"KeywordExpr" :kw nil
            #_"Object" :tag nil
            #_"Expr" :target nil
            #_"int" :line 0
            #_"int" :column 0
            #_"int" :siteIndex 0
        )
    )

    (defn #_"KeywordInvokeExpr" KeywordInvokeExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"KeywordExpr" kw, #_"Expr" target]
        (let [this (KeywordInvokeExpr'init)]
            (assoc this :kw kw :target target :line line :column column :tag tag :siteIndex (Compiler'registerKeywordCallsite (:k kw)))
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--KeywordInvokeExpr [#_"KeywordInvokeExpr" this]
        (try
            (.invoke (:k (:kw this)), (.eval (:target this)))
            (catch Throwable e
                (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--KeywordInvokeExpr [#_"KeywordInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" endLabel (.newLabel gen) #_"Label" faultLabel (.newLabel gen)]
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.getStatic gen, (:objtype objx), (ObjExpr''thunkNameStatic objx, (:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE)
            (.dup gen) ;; thunk, thunk
            (.emit (:target this), :Context'EXPRESSION, objx, gen) ;; thunk, thunk, target
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.dupX2 gen) ;; target, thunk, thunk, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_THUNK_TYPE, (Method/getMethod "Object get(Object)")) ;; target, thunk, result
            (.dupX2 gen) ;; result, target, thunk, result
            (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, faultLabel) ;; result, target
            (.pop gen) ;; result
            (.goTo gen, endLabel)

            (.mark gen, faultLabel) ;; result, target
            (.swap gen) ;; target, result
            (.pop gen) ;; target
            (.dup gen) ;; target, target
            (.getStatic gen, (:objtype objx), (ObjExpr''siteNameStatic objx, (:siteIndex this)), ObjExpr'KEYWORD_LOOKUPSITE_TYPE) ;; target, target, site
            (.swap gen) ;; target, site, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_SITE_TYPE, (Method/getMethod "cloiure.lang.ILookupThunk fault(Object)")) ;; target, new-thunk
            (.dup gen) ;; target, new-thunk, new-thunk
            (.putStatic gen, (:objtype objx), (ObjExpr''thunkNameStatic objx, (:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE) ;; target, new-thunk
            (.swap gen) ;; new-thunk, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_THUNK_TYPE, (Method/getMethod "Object get(Object)")) ;; result

            (.mark gen, endLabel)
            (when (= context :Context'STATEMENT)
                (.pop gen)
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--KeywordInvokeExpr [#_"KeywordInvokeExpr" this]
        (some? (:tag this))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--KeywordInvokeExpr [#_"KeywordInvokeExpr" this]
        (HostExpr'tagToClass (:tag this))
    )
)

(class-ns InstanceOfExpr
    (defn- #_"InstanceOfExpr" InstanceOfExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Class" :c nil
        )
    )

    (defn #_"InstanceOfExpr" InstanceOfExpr'new [#_"Class" c, #_"Expr" expr]
        (let [this (InstanceOfExpr'init)]
            (assoc this :expr expr :c c)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InstanceOfExpr [#_"InstanceOfExpr" this]
        (if (.isInstance (:c this), (.eval (:expr this))) RT'T RT'F)
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--InstanceOfExpr [#_"InstanceOfExpr" this]
        true
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--InstanceOfExpr [#_"InstanceOfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.instanceOf gen, (Compiler'getType (:c this)))
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--InstanceOfExpr [#_"InstanceOfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitUnboxed this, context, objx, gen)
        (HostExpr'emitBoxReturn objx, gen, Boolean/TYPE)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InstanceOfExpr [#_"InstanceOfExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--InstanceOfExpr [#_"InstanceOfExpr" this]
        Boolean/TYPE
    )
)

(class-ns StaticInvokeExpr
    (defn- #_"StaticInvokeExpr" StaticInvokeExpr'init []
        (hash-map
            #_"Type" :target nil
            #_"Class" :retClass nil
            #_"Class[]" :paramclasses nil
            #_"Type[]" :paramtypes nil
            #_"IPersistentVector" :args nil
            #_"boolean" :variadic false
            #_"boolean" :tailPosition false
            #_"Object" :tag nil
        )
    )

    (defn #_"StaticInvokeExpr" StaticInvokeExpr'new [#_"Type" target, #_"Class" retClass, #_"Class[]" paramclasses, #_"Type[]" paramtypes, #_"boolean" variadic, #_"IPersistentVector" args, #_"Object" tag, #_"boolean" tailPosition]
        (let [this (StaticInvokeExpr'init)]
            (assoc this :target target :retClass retClass :paramclasses paramclasses :paramtypes paramtypes :args args :variadic variadic :tailPosition tailPosition :tag tag)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_override
    (defn #_"void" Expr'''emit--StaticInvokeExpr [#_"StaticInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitUnboxed this, context, objx, gen)
        (when (not= context :Context'STATEMENT)
            (HostExpr'emitBoxReturn objx, gen, (:retClass this))
        )
        (when (= context :Context'STATEMENT)
            (if (or (= (:retClass this) Long/TYPE) (= (:retClass this) Double/TYPE))
                (.pop2 gen)
                (.pop gen)
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        true
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (:retClass this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        (.isPrimitive (:retClass this))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--StaticInvokeExpr [#_"StaticInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Method" ms (Method. "invokeStatic", (Type/getType (:retClass this)), (:paramtypes this))]
            (when (:variadic this) => (MethodExpr'emitTypedArgs objx, gen, (:paramclasses this), (:args this))
                (dotimes [#_"int" i (dec (alength (:paramclasses this)))]
                    (let [#_"Expr" e (cast Expr (.nth (:args this), i))]
                        (if (= (Compiler'maybePrimitiveType e) (aget (:paramclasses this) i))
                            (do
                                (.emitUnboxed (cast MaybePrimitiveExpr e), :Context'EXPRESSION, objx, gen)
                            )
                            (do
                                (.emit e, :Context'EXPRESSION, objx, gen)
                                (HostExpr'emitUnboxArg objx, gen, (aget (:paramclasses this) i))
                            )
                        )
                    )
                )
                (let [#_"IPersistentVector" restArgs (RT'subvec (:args this), (dec (alength (:paramclasses this))), (.count (:args this)))]
                    (MethodExpr'emitArgsAsArray restArgs, objx, gen)
                    (.invokeStatic gen, (Type/getType ArraySeq), (Method/getMethod "cloiure.lang.ArraySeq create(Object[])"))
                )
            )

            (when (and (:tailPosition this) (not (:canBeDirect objx)))
                (ObjMethod''emitClearThis (cast ObjMethod (.deref Compiler'METHOD)), gen)
            )

            (.invokeStatic gen, (:target this), ms)
        )
        nil
    )

    (defn #_"Expr" StaticInvokeExpr'parse [#_"Var" v, #_"ISeq" args, #_"Object" tag, #_"boolean" tailPosition]
        (when (and (Var''isBound v) (some? (Var''get v)))
            (let [#_"Class" c (.getClass (Var''get v)) #_"java.lang.reflect.Method[]" methods (.getMethods c) #_"int" argc (RT'count args)
                  [#_"java.lang.reflect.Method" method #_"boolean" variadic]
                    (loop-when [#_"int" i 0] (< i (alength methods)) => [nil false]
                        (let [#_"java.lang.reflect.Method" m (aget methods i)]
                            (or
                                (when (and (Modifier/isStatic (.getModifiers m)) (= (.getName m) "invokeStatic"))
                                    (let [#_"Class[]" types (.getParameterTypes m) #_"int" n (alength types)]
                                        (cond
                                            (= n argc)
                                                [m (and (pos? n) (= (aget types (dec n)) ISeq))]
                                            (and (< 0 n argc) (= (aget types (dec n)) ISeq))
                                                [m true]
                                        )
                                    )
                                )
                                (recur (inc i))
                            )
                        )
                    )]
                (when (some? method)
                    (let [#_"Class" retClass (.getReturnType method) #_"Class[]" paramClasses (.getParameterTypes method)
                          #_"Type[]" paramTypes (make-array Type (alength paramClasses))
                          _ (dotimes [#_"int" i (alength paramClasses)]
                                (aset paramTypes i (Type/getType (aget paramClasses i)))
                            )
                          #_"Type" target (Type/getType c)
                          #_"PersistentVector" argv
                            (loop-when-recur [argv PersistentVector'EMPTY #_"ISeq" s (RT'seq args)]
                                             (some? s)
                                             [(.cons argv, (Compiler'analyze-2 :Context'EXPRESSION, (.first s))) (.next s)]
                                          => argv
                            )]
                        (StaticInvokeExpr'new target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition)
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr
    (ยง def #_"Keyword" InvokeExpr'onKey (Keyword'intern (Symbol'intern "on")))
    (ยง def #_"Keyword" InvokeExpr'methodMapKey (Keyword'intern (Symbol'intern "method-map")))

    (defn- #_"InvokeExpr" InvokeExpr'init []
        (hash-map
            #_"Expr" :fexpr nil
            #_"Object" :tag nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :tailPosition false

            #_"boolean" :isProtocol false
            #_"boolean" :isDirect false
            #_"int" :siteIndex -1
            #_"Class" :protocolOn nil
            #_"java.lang.reflect.Method" :onMethod nil
        )
    )

    (defn #_"InvokeExpr" InvokeExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" fexpr, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (InvokeExpr'init)
              this (assoc this :fexpr fexpr :args args :line line :column column :tailPosition tailPosition)
              this
                (when (instance? VarExpr fexpr) => this
                    (let [#_"Var" fvar (:var (cast VarExpr fexpr)) #_"Var" pvar (cast Var (RT'get-2 (.meta fvar), Compiler'protocolKey))]
                        (when (and (some? pvar) (Var''isBound Compiler'PROTOCOL_CALLSITES)) => this
                            (let [this (assoc this :isProtocol true)
                                  this (assoc this :siteIndex (Compiler'registerProtocolCallsite (:var (cast VarExpr fexpr))))
                                  this (assoc this :protocolOn (HostExpr'maybeClass (RT'get-2 (Var''get pvar), Compiler'onKey), false))]
                                (when (some? (:protocolOn this)) => this
                                    (let [#_"IPersistentMap" mmap (cast IPersistentMap (RT'get-2 (Var''get pvar), InvokeExpr'methodMapKey))
                                          #_"Keyword" mmapVal (cast Keyword (.valAt mmap, (Keyword'intern (:sym fvar))))]
                                        (when (some? mmapVal) => (throw (IllegalArgumentException. (str "No method of interface: " (.getName (:protocolOn this)) " found for function: " (:sym fvar) " of protocol: " (:sym pvar) " (The protocol method may have been defined before and removed.)")))
                                            (let [#_"String" mname (Compiler'munge (.toString (:sym mmapVal)))
                                                  #_"List" methods (Reflector'getMethods (:protocolOn this), (dec (.count args)), mname, false)]
                                                (when (= (.size methods) 1) => (throw (IllegalArgumentException. (str "No single method: " mname " of interface: " (.getName (:protocolOn this)) " found for function: " (:sym fvar) " of protocol: " (:sym pvar))))
                                                    (assoc this :onMethod (cast java.lang.reflect.Method (.get methods, 0)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )]
            (assoc this :tag (or tag (when (instance? VarExpr fexpr) (:tag (cast VarExpr fexpr)))))
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InvokeExpr [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" fn (cast IFn (.eval (:fexpr this)))
                  #_"PersistentVector" argvs
                    (loop-when-recur [argvs PersistentVector'EMPTY #_"int" i 0]
                                     (< i (.count (:args this)))
                                     [(.cons argvs, (.eval (cast Expr (.nth (:args this), i)))) (inc i)]
                                  => argvs
                    )]
                (.applyTo fn, (RT'seq argvs))
            )
            (catch Throwable e
                (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--InvokeExpr [#_"InvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (:isProtocol this)
            (do
                (.visitLineNumber gen, (:line this), (.mark gen))
                (InvokeExpr''emitProto this, context, objx, gen)
            )
            (do
                (.emit (:fexpr this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, Compiler'IFN_TYPE)
                (InvokeExpr''emitArgsAndCall this, 0, context, objx, gen)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (defn #_"void" InvokeExpr''emitProto [#_"InvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" onLabel (.newLabel gen) #_"Label" callLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)
              #_"Var" v (:var (cast VarExpr (:fexpr this)))
              #_"Expr" e (cast Expr (.nth (:args this), 0))]
            (.emit e, :Context'EXPRESSION, objx, gen)
            (.dup gen) ;; target, target
            (.invokeStatic gen, Compiler'UTIL_TYPE, (Method/getMethod "Class classOf(Object)")) ;; target, class
            (.getStatic gen, (:objtype objx), (ObjExpr''cachedClassName objx, (:siteIndex this)), Compiler'CLASS_TYPE) ;; target, class, cached-class
            (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, callLabel) ;; target
            (when (some? (:protocolOn this))
                (.dup gen) ;; target, target
                (.instanceOf gen, (Type/getType (:protocolOn this)))
                (.ifZCmp gen, GeneratorAdapter/NE, onLabel)
            )

            (.dup gen) ;; target, target
            (.invokeStatic gen, Compiler'UTIL_TYPE, (Method/getMethod "Class classOf(Object)")) ;; target, class
            (.putStatic gen, (:objtype objx), (ObjExpr''cachedClassName objx, (:siteIndex this)), Compiler'CLASS_TYPE) ;; target

            (.mark gen, callLabel) ;; target
            (ObjExpr''emitVar objx, gen, v)
            (.invokeVirtual gen, Compiler'VAR_TYPE, (Method/getMethod "Object getRawRoot()")) ;; target, proto-fn
            (.swap gen)
            (InvokeExpr''emitArgsAndCall this, 1, context, objx, gen)
            (.goTo gen, endLabel)

            (.mark gen, onLabel) ;; target
            (when (some? (:protocolOn this))
                (.checkCast gen, (Type/getType (:protocolOn this)))
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:onMethod this)), (RT'subvec (:args this), 1, (.count (:args this))))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (.getName (:onMethod this)), (Type/getReturnType (:onMethod this)), (Type/getArgumentTypes (:onMethod this)))]
                    (.invokeInterface gen, (Type/getType (:protocolOn this)), m)
                    (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:onMethod this)))
                )
            )
            (.mark gen, endLabel)
        )
        nil
    )

    #_method
    (defn #_"void" InvokeExpr''emitArgsAndCall [#_"InvokeExpr" this, #_"int" firstArgToEmit, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i firstArgToEmit] (< i (Math/min Compiler'MAX_POSITIONAL_ARITY, (.count (:args this)))) [(inc i)]
            (let [#_"Expr" e (cast Expr (.nth (:args this), i))]
                (.emit e, :Context'EXPRESSION, objx, gen)
            )
        )
        (when (< Compiler'MAX_POSITIONAL_ARITY (.count (:args this)))
            (let [#_"PersistentVector" restArgs
                    (loop-when-recur [restArgs PersistentVector'EMPTY #_"int" i Compiler'MAX_POSITIONAL_ARITY]
                                     (< i (.count (:args this)))
                                     [(.cons restArgs, (.nth (:args this), i)) (inc i)]
                                  => restArgs
                    )]
                (MethodExpr'emitArgsAsArray restArgs, objx, gen)
            )
        )
        (.visitLineNumber gen, (:line this), (.mark gen))

        (when (and (:tailPosition this) (not (:canBeDirect objx)))
            (ObjMethod''emitClearThis (cast ObjMethod (.deref Compiler'METHOD)), gen)
        )

        (.invokeInterface gen, Compiler'IFN_TYPE, (Method. "invoke", Compiler'OBJECT_TYPE, (aget Compiler'ARG_TYPES (Math/min (inc Compiler'MAX_POSITIONAL_ARITY), (.count (:args this))))))
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InvokeExpr [#_"InvokeExpr" this]
        (some? (:tag this))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--InvokeExpr [#_"InvokeExpr" this]
        (HostExpr'tagToClass (:tag this))
    )

    (defn #_"Expr" InvokeExpr'parse [#_"Context" context, #_"ISeq" form]
        (let [#_"boolean" tailPosition (Compiler'inTailCall context) context (if (= context :Context'EVAL) context :Context'EXPRESSION)
              #_"Expr" fexpr (Compiler'analyze-2 context, (.first form))]
            (or
                (when (and (instance? VarExpr fexpr) (.equals (:var (cast VarExpr fexpr)), Compiler'INSTANCE) (= (RT'count form) 3))
                    (let-when [#_"Expr" sexpr (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form))] (instance? ConstantExpr sexpr)
                        (let-when [#_"Object" val (.val (cast ConstantExpr sexpr))] (instance? Class val)
                            (InstanceOfExpr'new (cast Class val), (Compiler'analyze-2 context, (RT'third form)))
                        )
                    )
                )

                (when (and #_"direct-linking" false (instance? VarExpr fexpr) (not= context :Context'EVAL))
                    (let [#_"Var" v (:var (cast VarExpr fexpr))]
                        (when (and (not (Var''isDynamic v)) (not (RT'booleanCast-1o (RT'get-3 (.meta v), Compiler'redefKey, false))))
                            (let [#_"Symbol" formtag (Compiler'tagOf form) #_"Object" vtag (RT'get-2 (RT'meta v), RT'TAG_KEY)]
                                (StaticInvokeExpr'parse v, (RT'next form), (or formtag vtag), tailPosition)
                            )
                        )
                    )
                )

                (when (and (instance? KeywordExpr fexpr) (= (RT'count form) 2) (Var''isBound Compiler'KEYWORD_CALLSITES))
                    (let [#_"Expr" target (Compiler'analyze-2 context, (RT'second form))]
                        (KeywordInvokeExpr'new (Compiler'lineDeref), (Compiler'columnDeref), (Compiler'tagOf form), (cast KeywordExpr fexpr), target)
                    )
                )

                (let [#_"PersistentVector" args
                        (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'seq (.next form))]
                                         (some? s)
                                         [(.cons args, (Compiler'analyze-2 context, (.first s))) (.next s)]
                                      => args
                        )]
                    (InvokeExpr'new (Compiler'lineDeref), (Compiler'columnDeref), (Compiler'tagOf form), fexpr, args, tailPosition)
                )
            )
        )
    )
)

(class-ns ObjExpr
    (def #_"String" ObjExpr'CONST_PREFIX "const__")

    (def #_"Method" ObjExpr'voidctor (Method/getMethod "void <init>()"))

    (def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (Type/getType DynamicClassLoader))
    (def #_"Method" ObjExpr'getClassMethod (Method/getMethod "Class getClass()"))
    (def #_"Method" ObjExpr'getClassLoaderMethod (Method/getMethod "ClassLoader getClassLoader()"))
    (def #_"Method" ObjExpr'getConstantsMethod (Method/getMethod "Object[] getConstants(int)"))
    (def #_"Method" ObjExpr'readStringMethod (Method/getMethod "Object readString(String)"))

    (def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (Type/getType ILookupSite))
    (def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (Type/getType ILookupThunk))
    (def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (Type/getType KeywordLookupSite))

    (defn- #_"ObjExpr" ObjExpr'init []
        (hash-map
            #_"String" :name nil
            #_"String" :internalName nil
            #_"String" :thisName nil
            #_"Type" :objtype nil
            #_"Object" :tag nil
            ;; localbinding->itself
            #_"IPersistentMap" :closes PersistentHashMap'EMPTY
            ;; localbndingexprs
            #_"IPersistentVector" :closesExprs PersistentVector'EMPTY
            ;; symbols
            #_"IPersistentSet" :volatiles PersistentHashSet'EMPTY

            ;; symbol->lb
            #_"IPersistentMap" :fields nil

            ;; hinted fields
            #_"IPersistentVector" :hintedFields PersistentVector'EMPTY

            ;; Keyword->KeywordExpr
            #_"IPersistentMap" :keywords PersistentHashMap'EMPTY
            #_"IPersistentMap" :vars PersistentHashMap'EMPTY
            #_"Class" :compiledClass nil
            #_"int" :line 0
            #_"int" :column 0
            #_"PersistentVector" :constants nil
            #_"IPersistentSet" :usedConstants PersistentHashSet'EMPTY

            #_"int" :constantsID 0
            #_"int" :altCtorDrops 0

            #_"IPersistentVector" :keywordCallsites nil
            #_"IPersistentVector" :protocolCallsites nil
            #_"IPersistentSet" :varCallsites nil
            #_"boolean" :onceOnly false

            #_"Object" :src nil

            #_"IPersistentMap" :opts PersistentHashMap'EMPTY

            #_"IPersistentMap" :classMeta nil
            #_"boolean" :canBeDirect false

            #_"DynamicClassLoader" :loader nil
            #_"byte[]" :bytecode nil
        )
    )

    (defn #_"ObjExpr" ObjExpr'new [#_"Object" tag]
        (let [this (ObjExpr'init)]
            (assoc this :tag tag)
        )
    )

    (defn #_"String" ObjExpr'trimGenID [#_"String" name]
        (let [#_"int" i (.lastIndexOf name, "__")]
            (if (= i -1) name (.substring name, 0, i))
        )
    )

    #_method
    (defn #_"Type[]" ObjExpr''ctorTypes [#_"ObjExpr" this]
        (let [#_"IPersistentVector" v (if (.supportsMeta this) (RT'vector Compiler'IPERSISTENTMAP_TYPE) PersistentVector'EMPTY)
              v (loop-when [v v #_"ISeq" s (RT'keys (:closes this))] (some? s) => v
                    (let [#_"Class" c (LocalBinding''getPrimitiveType (cast LocalBinding (.first s)))]
                        (recur (.cons v, (if (some? c) (Type/getType c) Compiler'OBJECT_TYPE)) (.next s))
                    )
                )]
            (let [#_"Type[]" a (make-array Type (.count v))]
                (dotimes [#_"int" i (.count v)]
                    (aset a i (cast Type (.nth v, i)))
                )
                a
            )
        )
    )

    #_method
    (defn #_"void" ObjExpr''compile [#_"ObjExpr" this, #_"String" superName, #_"String[]" interfaceNames, #_"boolean" oneTimeUse]
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" cw (ClassWriter. ClassWriter/COMPUTE_MAXS) #_"ClassVisitor" cv cw]
            (.visit cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER Opcodes/ACC_FINAL), (:internalName this), nil, superName, interfaceNames)
            (when (.supportsMeta this)
                (.visitField cv, Opcodes/ACC_FINAL, "__meta", (.getDescriptor Compiler'IPERSISTENTMAP_TYPE), nil, nil)
            )
            ;; instance fields for closed-overs
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast LocalBinding (.first s))
                      #_"String" fd
                        (if (some? (LocalBinding''getPrimitiveType lb))
                            (.getDescriptor (Type/getType (LocalBinding''getPrimitiveType lb)))
                            ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                            (.getDescriptor Compiler'OBJECT_TYPE)
                        )]
                    (if (ObjExpr''isDeftype this)
                        (let [#_"int" access
                                (cond
                                    (ObjExpr''isVolatile this, lb) Opcodes/ACC_VOLATILE
                                    (ObjExpr''isMutable this, lb) 0
                                    :else (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL)
                                )]
                            (.visitField cv, access, (:name lb), fd, nil, nil)
                        )
                        ;; todo - only enable this non-private+writability for letfns where we need it
                        (let [#_"int" access
                                (if (some? (LocalBinding''getPrimitiveType lb))
                                    (if (ObjExpr''isVolatile this, lb) Opcodes/ACC_VOLATILE 0)
                                    0
                                )]
                            (.visitField cv, access, (:name lb), fd, nil, nil)
                        )
                    )
                )
            )

            ;; static fields for callsites and thunks
            (dotimes [#_"int" i (.count (:protocolCallsites this))]
                (.visitField cv, (+ Opcodes/ACC_PRIVATE Opcodes/ACC_STATIC), (ObjExpr''cachedClassName this, i), (.getDescriptor Compiler'CLASS_TYPE), nil, nil)
            )

            ;; ctor that takes closed-overs and inits base + fields
            (let [#_"Method" m (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes this))
                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, nil, cv)
                  #_"Label" start (.newLabel ctorgen) #_"Label" end (.newLabel ctorgen)]
                (.visitCode ctorgen)
                (.visitLineNumber ctorgen, (:line this), (.mark ctorgen))
                (.visitLabel ctorgen, start)
                (.loadThis ctorgen)
                (.invokeConstructor ctorgen, (Type/getObjectType superName), ObjExpr'voidctor)

                (when (.supportsMeta this)
                    (.loadThis ctorgen)
                    (.visitVarInsn ctorgen, (.getOpcode Compiler'IPERSISTENTMAP_TYPE, Opcodes/ILOAD), 1)
                    (.putField ctorgen, (:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE)
                )

                (let [#_"int" a
                        (loop-when [a (if (.supportsMeta this) 2 1) #_"ISeq" s (RT'keys (:closes this))] (some? s) => a
                            (let [#_"LocalBinding" lb (cast LocalBinding (.first s))]
                                (.loadThis ctorgen)
                                (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)
                                      a (if (some? primc)
                                            (do
                                                (.visitVarInsn ctorgen, (.getOpcode (Type/getType primc), Opcodes/ILOAD), a)
                                                (.putField ctorgen, (:objtype this), (:name lb), (Type/getType primc))
                                                (if (any = primc Long/TYPE Double/TYPE) (inc a) a)
                                            )
                                            (do
                                                (.visitVarInsn ctorgen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), a)
                                                (.putField ctorgen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                                                a
                                            )
                                        )]
                                    (ร ass this (assoc this :closesExprs (.cons (:closesExprs this), (LocalBindingExpr'new lb, nil))))
                                )
                                (recur (inc a) (.next s))
                            )
                        )]

                    (.visitLabel ctorgen, end)
                    (.returnValue ctorgen)
                    (.endMethod ctorgen)

                    (when (pos? (:altCtorDrops this))
                        (let [#_"Type[]" ctorTypes (ObjExpr''ctorTypes this)]

                            ;; ctor that takes closed-overs and inits base + fields
                            (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) (:altCtorDrops this)))
                                  _ (dotimes [#_"int" i (alength altCtorTypes)]
                                        (aset altCtorTypes i (aget ctorTypes i))
                                    )
                                  #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                                (.visitCode ctorgen)
                                (.loadThis ctorgen)
                                (.loadArgs ctorgen)

                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __meta
                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                (.returnValue ctorgen)
                                (.endMethod ctorgen)
                            )

                            ;; alt ctor no __hash, __hasheq
                            (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) 2))
                                  _ (dotimes [#_"int" i (alength altCtorTypes)]
                                        (aset altCtorTypes i (aget ctorTypes i))
                                    )
                                  #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                                (.visitCode ctorgen)
                                (.loadThis ctorgen)
                                (.loadArgs ctorgen)

                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                (.returnValue ctorgen)
                                (.endMethod ctorgen)
                            )
                        )
                    )

                    (when (.supportsMeta this)
                        (let [#_"Type[]" ctorTypes (ObjExpr''ctorTypes this)]

                            ;; ctor that takes closed-overs but not meta
                            (let [#_"Type[]" noMetaCtorTypes (make-array Type (dec (alength ctorTypes)))
                                  _ (loop-when-recur [#_"int" i 1] (< i (alength ctorTypes)) [(inc i)]
                                        (aset noMetaCtorTypes (dec i) (aget ctorTypes i))
                                    )
                                  #_"Method" alt (Method. "<init>", Type/VOID_TYPE, noMetaCtorTypes)
                                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                                (.visitCode ctorgen)
                                (.loadThis ctorgen)
                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; nil meta
                                (.loadArgs ctorgen)
                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))
                                (.returnValue ctorgen)
                                (.endMethod ctorgen)
                            )

                            ;; meta()
                            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IPersistentMap meta()")
                                  #_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, meth, nil, nil, cv)]
                                (.visitCode gen)
                                (.loadThis gen)
                                (.getField gen, (:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE)
                                (.returnValue gen)
                                (.endMethod gen)
                            )

                            ;; withMeta()
                            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")
                                  #_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, meth, nil, nil, cv)]
                                (.visitCode gen)
                                (.newInstance gen, (:objtype this))
                                (.dup gen)
                                (.loadArg gen, 0)
                                (loop-when-recur [a a #_"ISeq" s (RT'keys (:closes this))] (some? s) [(inc a) (.next s)]
                                    (let [#_"LocalBinding" lb (cast LocalBinding (.first s))]
                                        (.loadThis gen)
                                        (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                                            (.getField gen, (:objtype this), (:name lb), (if (some? primc) (Type/getType primc) Compiler'OBJECT_TYPE))
                                        )
                                    )
                                )
                                (.invokeConstructor gen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))
                                (.returnValue gen)
                                (.endMethod gen)
                            )
                        )
                    )

                    (.emitStatics this, cv)
                    (.emitMethods this, cv)

                    ;; static fields for constants
                    (dotimes [#_"int" i (.count (:constants this))]
                        (when (.contains (:usedConstants this), i)
                            (.visitField cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL Opcodes/ACC_STATIC), (ObjExpr''constantName this, i), (.getDescriptor (ObjExpr''constantType this, i)), nil, nil)
                        )
                    )

                    ;; static fields for lookup sites
                    (dotimes [#_"int" i (.count (:keywordCallsites this))]
                        (.visitField cv, (+ Opcodes/ACC_FINAL Opcodes/ACC_STATIC), (ObjExpr''siteNameStatic this, i), (.getDescriptor ObjExpr'KEYWORD_LOOKUPSITE_TYPE), nil, nil)
                        (.visitField cv, Opcodes/ACC_STATIC, (ObjExpr''thunkNameStatic this, i), (.getDescriptor ObjExpr'ILOOKUP_THUNK_TYPE), nil, nil)
                    )

                    ;; static init for constants, keywords and vars
                    (let [#_"GeneratorAdapter" clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, cv)]
                        (.visitCode clinitgen)
                        (.visitLineNumber clinitgen, (:line this), (.mark clinitgen))

                        (when (pos? (.count (:constants this)))
                            (ObjExpr''emitConstants this, clinitgen)
                        )

                        (when (pos? (.count (:keywordCallsites this)))
                            (ObjExpr''emitKeywordCallsites this, clinitgen)
                        )

                        (when (and (ObjExpr''isDeftype this) (RT'booleanCast-1o (RT'get-2 (:opts this), Compiler'loadNs)))
                            (let [#_"String" nsname (.getNamespace (cast Symbol (RT'second (:src this))))]
                                (when (not (= nsname "cloiure.core"))
                                    (.push clinitgen, "cloiure.core")
                                    (.push clinitgen, "require")
                                    (.invokeStatic clinitgen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Var var(String, String)"))
                                    (.invokeVirtual clinitgen, Compiler'VAR_TYPE, (Method/getMethod "Object getRawRoot()"))
                                    (.checkCast clinitgen, Compiler'IFN_TYPE)
                                    (.push clinitgen, nsname)
                                    (.invokeStatic clinitgen, Compiler'SYMBOL_TYPE, (Method/getMethod "cloiure.lang.Symbol create(String)"))
                                    (.invokeInterface clinitgen, Compiler'IFN_TYPE, (Method/getMethod "Object invoke(Object)"))
                                    (.pop clinitgen)
                                )
                            )
                        )

                        (.returnValue clinitgen)
                        (.endMethod clinitgen)
                        ;; end of class
                        (.visitEnd cv)

                        (ร ass this (assoc this :bytecode (.toByteArray cw)))
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" ObjExpr''emitKeywordCallsites [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
        (dotimes [#_"int" i (.count (:keywordCallsites this))]
            (let [#_"Keyword" k (cast Keyword (.nth (:keywordCallsites this), i))]
                (.newInstance clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.dup clinitgen)
                (ObjExpr''emitValue this, k, clinitgen)
                (.invokeConstructor clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE, (Method/getMethod "void <init>(cloiure.lang.Keyword)"))
                (.dup clinitgen)
                (.putStatic clinitgen, (:objtype this), (ObjExpr''siteNameStatic this, i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.putStatic clinitgen, (:objtype this), (ObjExpr''thunkNameStatic this, i), ObjExpr'ILOOKUP_THUNK_TYPE)
            )
        )
        nil
    )

    #_override
    (defn #_"void" ObjExpr'''emitStatics--ObjExpr [#_"ObjExpr" this, #_"ClassVisitor" gen]
        nil
    )

    #_override
    (defn #_"void" ObjExpr'''emitMethods--ObjExpr [#_"ObjExpr" this, #_"ClassVisitor" gen]
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitListAsObjectArray [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
        (.push gen, (.size (cast List value)))
        (.newArray gen, Compiler'OBJECT_TYPE)
        (loop-when-recur [#_"Iterator" it (.iterator (cast List value)) #_"int" i 0] (.hasNext it) [it (inc i)]
            (.dup gen)
            (.push gen, i)
            (ObjExpr''emitValue this, (.next it), gen)
            (.arrayStore gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitValue [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
        (let [#_"boolean" partial?
                (cond (nil? value)
                    (do
                        (.visitInsn gen, Opcodes/ACONST_NULL)
                        true
                    )
                    (instance? String value)
                    (do
                        (.push gen, (cast String value))
                        true
                    )
                    (instance? Boolean value)
                    (do
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, (if (.booleanValue (cast Boolean value)) "TRUE" "FALSE"), Compiler'BOOLEAN_OBJECT_TYPE)
                        true
                    )
                    (instance? Integer value)
                    (do
                        (.push gen, (.intValue (cast Integer value)))
                        (.invokeStatic gen, (Type/getType Integer), (Method/getMethod "Integer valueOf(int)"))
                        true
                    )
                    (instance? Long value)
                    (do
                        (.push gen, (.longValue (cast Long value)))
                        (.invokeStatic gen, (Type/getType Long), (Method/getMethod "Long valueOf(long)"))
                        true
                    )
                    (instance? Double value)
                    (do
                        (.push gen, (.doubleValue (cast Double value)))
                        (.invokeStatic gen, (Type/getType Double), (Method/getMethod "Double valueOf(double)"))
                        true
                    )
                    (instance? Character value)
                    (do
                        (.push gen, (.charValue (cast Character value)))
                        (.invokeStatic gen, (Type/getType Character), (Method/getMethod "Character valueOf(char)"))
                        true
                    )
                    (instance? Class value)
                    (let [#_"Class" cc (cast Class value)]
                        (if (.isPrimitive cc)
                            (let [#_"Type" bt
                                    (condp = cc
                                        Boolean/TYPE   (Type/getType Boolean)
                                        Byte/TYPE      (Type/getType Byte)
                                        Character/TYPE (Type/getType Character)
                                        Double/TYPE    (Type/getType Double)
                                        Float/TYPE     (Type/getType Float)
                                        Integer/TYPE   (Type/getType Integer)
                                        Long/TYPE      (Type/getType Long)
                                        Short/TYPE     (Type/getType Short)
                                        (throw (RuntimeException. (str "Can't embed unknown primitive in code: " value)))
                                    )]
                                (.getStatic gen, bt, "TYPE", (Type/getType Class))
                            )
                            (do
                                (.push gen, (Compiler'destubClassName (.getName cc)))
                                (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "Class classForName(String)"))
                            )
                        )
                        true
                    )
                    (instance? Symbol value)
                    (do
                        (.push gen, (:ns (cast Symbol value)))
                        (.push gen, (:name (cast Symbol value)))
                        (.invokeStatic gen, (Type/getType Symbol), (Method/getMethod "cloiure.lang.Symbol intern(String, String)"))
                        true
                    )
                    (instance? Keyword value)
                    (do
                        (.push gen, (:ns (:sym (cast Keyword value))))
                        (.push gen, (:name (:sym (cast Keyword value))))
                        (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Keyword keyword(String, String)"))
                        true
                    )
                    (instance? Var value)
                    (let [#_"Var" var (cast Var value)]
                        (.push gen, (.toString (:name (:ns var))))
                        (.push gen, (.toString (:sym var)))
                        (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Var var(String, String)"))
                        true
                    )
                    (instance? IType value)
                    (let [#_"Method" ctor (Method. "<init>", (Type/getConstructorDescriptor (aget (.getConstructors (.getClass value)) 0)))]
                        (.newInstance gen, (Type/getType (.getClass value)))
                        (.dup gen)
                        (let [#_"IPersistentVector" fields (cast IPersistentVector (Reflector'invokeStaticMethod-3c (.getClass value), "getBasis", (object-array 0)))]
                            (loop-when-recur [#_"ISeq" s (RT'seq fields)] (some? s) [(.next s)]
                                (let [#_"Symbol" field (cast Symbol (.first s))]
                                    (ObjExpr''emitValue this, (Reflector'getInstanceField value, (Compiler'munge (:name field))), gen)
                                    (let-when [#_"Class" k (Compiler'tagClass (Compiler'tagOf field))] (.isPrimitive k)
                                        (let [#_"Type" b (Type/getType (Compiler'boxClass k))]
                                            (.invokeVirtual gen, b, (Method. (str (.getName k) "Value"), (str "()" (.getDescriptor (Type/getType k)))))
                                        )
                                    )
                                )
                            )
                            (.invokeConstructor gen, (Type/getType (.getClass value)), ctor)
                        )
                        true
                    )
                    (instance? IPersistentMap value)
                    (let [#_"List" entries (ArrayList.)]
                        (doseq [#_"Map$Entry" entry (cast Set #_"<Map$Entry>" (.entrySet (cast Map value)))]
                            (.add entries, (.getKey entry))
                            (.add entries, (.getValue entry))
                        )
                        (ObjExpr''emitListAsObjectArray this, entries, gen)
                        (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
                        true
                    )
                    (instance? IPersistentVector value)
                    (let [#_"IPersistentVector" args (cast IPersistentVector value)]
                        (if (<= (.count args) Tuple'MAX_SIZE)
                            (do
                                (dotimes [#_"int" i (.count args)]
                                    (ObjExpr''emitValue this, (.nth args, i), gen)
                                )
                                (.invokeStatic gen, Compiler'TUPLE_TYPE, (aget Compiler'createTupleMethods (.count args)))
                            )
                            (do
                                (ObjExpr''emitListAsObjectArray this, value, gen)
                                (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))
                            )
                        )
                        true
                    )
                    (instance? PersistentHashSet value)
                    (let [#_"ISeq" vs (RT'seq value)]
                        (if (nil? vs)
                            (do
                                (.getStatic gen, (Type/getType PersistentHashSet), "EMPTY", (Type/getType PersistentHashSet))
                            )
                            (do
                                (ObjExpr''emitListAsObjectArray this, vs, gen)
                                (.invokeStatic gen, (Type/getType PersistentHashSet), (Method/getMethod "cloiure.lang.PersistentHashSet create(Object[])"))
                            )
                        )
                        true
                    )
                    (or (instance? ISeq value) (instance? IPersistentList value))
                    (do
                        (ObjExpr''emitListAsObjectArray this, value, gen)
                        (.invokeStatic gen, (Type/getType java.util.Arrays), (Method/getMethod "java.util.List asList(Object[])"))
                        (.invokeStatic gen, (Type/getType PersistentList), (Method/getMethod "cloiure.lang.IPersistentList create(java.util.List)"))
                        true
                    )
                    (instance? Pattern value)
                    (do
                        (ObjExpr''emitValue this, (.toString value), gen)
                        (.invokeStatic gen, (Type/getType Pattern), (Method/getMethod "java.util.regex.Pattern compile(String)"))
                        true
                    )
                    :else
                    (let [#_"String" cs
                            (try
                                (RT'printString value)
                                (catch Exception e
                                    (throw (RuntimeException. (str "Can't embed object in code: " value)))
                                )
                            )]
                        (when (zero? (.length cs))
                            (throw (RuntimeException. (str "Can't embed unreadable object in code: " value)))
                        )
                        (when (.startsWith cs, "#<")
                            (throw (RuntimeException. (str "Can't embed unreadable object in code: " cs)))
                        )
                        (.push gen, cs)
                        (.invokeStatic gen, Compiler'RT_TYPE, ObjExpr'readStringMethod)
                        false
                    )
                )]
            (when partial?
                (when (and (instance? IObj value) (pos? (RT'count (.meta (cast IObj value)))))
                    (.checkCast gen, Compiler'IOBJ_TYPE)
                    (ObjExpr''emitValue this, (.meta (cast IObj value)), gen)
                    (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
                    (.invokeInterface gen, Compiler'IOBJ_TYPE, (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitConstants [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
        (dotimes [#_"int" i (.count (:constants this))]
            (when (.contains (:usedConstants this), i)
                (ObjExpr''emitValue this, (.nth (:constants this), i), clinitgen)
                (.checkCast clinitgen, (ObjExpr''constantType this, i))
                (.putStatic clinitgen, (:objtype this), (ObjExpr''constantName this, i), (ObjExpr''constantType this, i))
            )
        )
        nil
    )

    #_method
    (defn #_"boolean" ObjExpr''isMutable [#_"ObjExpr" this, #_"LocalBinding" lb]
        (or (ObjExpr''isVolatile this, lb) (and (RT'booleanCast-1o (RT'contains (:fields this), (:sym lb))) (RT'booleanCast-1o (RT'get-2 (.meta (:sym lb)), (Keyword'intern (Symbol'intern "unsynchronized-mutable"))))))
    )

    #_method
    (defn #_"boolean" ObjExpr''isVolatile [#_"ObjExpr" this, #_"LocalBinding" lb]
        (and (RT'booleanCast-1o (RT'contains (:fields this), (:sym lb))) (RT'booleanCast-1o (RT'get-2 (.meta (:sym lb)), (Keyword'intern (Symbol'intern "volatile-mutable")))))
    )

    #_method
    (defn #_"boolean" ObjExpr''isDeftype [#_"ObjExpr" this]
        (some? (:fields this))
    )

    #_override
    (defn #_"boolean" ObjExpr'''supportsMeta--ObjExpr [#_"ObjExpr" this]
        (not (ObjExpr''isDeftype this))
    )

    #_method
    (defn #_"void" ObjExpr''emitClearCloses [#_"ObjExpr" this, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (defn #_"Class" ObjExpr''getCompiledClass [#_"ObjExpr" this]
        (ยง sync this
            (when (nil? (:compiledClass this))
                (ร ass this (assoc this :loader (cast DynamicClassLoader (.deref Compiler'LOADER))))
                (ร ass this (assoc this :compiledClass (.defineClass (:loader this), (:name this), (:bytecode this), (:src this))))
            )
            (:compiledClass this)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ObjExpr [#_"ObjExpr" this]
        (when-not (ObjExpr''isDeftype this)
            (.newInstance (ObjExpr''getCompiledClass this))
        )
    )

    #_method
    (defn #_"void" ObjExpr''emitLetFnInits [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"IPersistentSet" letFnLocals]
        ;; objx arg is enclosing objx, not this
        (.checkCast gen, (:objtype this))

        (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
            (let [#_"LocalBinding" lb (cast LocalBinding (.first s))]
                (when (.contains letFnLocals, lb)
                    (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                        (.dup gen)
                        (if (some? primc)
                            (do
                                (ObjExpr''emitUnboxedLocal objx, gen, lb)
                                (.putField gen, (:objtype this), (:name lb), (Type/getType primc))
                            )
                            (do
                                (ObjExpr''emitLocal objx, gen, lb, false)
                                (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                            )
                        )
                    )
                )
            )
        )
        (.pop gen)
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--ObjExpr [#_"ObjExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (when-not (ObjExpr''isDeftype this) => (.visitInsn gen, Opcodes/ACONST_NULL)
            (.newInstance gen, (:objtype this))
            (.dup gen)
            (when (.supportsMeta this)
                (.visitInsn gen, Opcodes/ACONST_NULL)
            )
            (loop-when-recur [#_"ISeq" s (RT'seq (:closesExprs this))] (some? s) [(.next s)]
                (let [#_"LocalBindingExpr" lbe (cast LocalBindingExpr (.first s)) #_"LocalBinding" lb (:lb lbe)]
                    (if (some? (LocalBinding''getPrimitiveType lb))
                        (ObjExpr''emitUnboxedLocal objx, gen, lb)
                        (ObjExpr''emitLocal objx, gen, lb, (:shouldClear lbe))
                    )
                )
            )
            (.invokeConstructor gen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes this)))
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ObjExpr [#_"ObjExpr" this]
        true
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--ObjExpr [#_"ObjExpr" this]
        (or (:compiledClass this)
            (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) IFn)
        )
    )

    #_method
    (defn #_"void" ObjExpr''emitAssignLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"Expr" val]
        (when (ObjExpr''isMutable this, lb) => (throw (IllegalArgumentException. (str "Cannot assign to non-mutable: " (:name lb))))
            (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                (.loadThis gen)
                (if (some? primc)
                    (do
                        (when (not (and (instance? MaybePrimitiveExpr val) (.canEmitPrimitive (cast MaybePrimitiveExpr val))))
                            (throw (IllegalArgumentException. (str "Must assign primitive to primitive mutable: " (:name lb))))
                        )
                        (let [#_"MaybePrimitiveExpr" me (cast MaybePrimitiveExpr val)]
                            (.emitUnboxed me, :Context'EXPRESSION, this, gen)
                            (.putField gen, (:objtype this), (:name lb), (Type/getType primc))
                        )
                    )
                    (do
                        (.emit val, :Context'EXPRESSION, this, gen)
                        (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" ObjExpr''emitLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"boolean" clear?]
        (if (.containsKey (:closes this), lb)
            (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                (.loadThis gen)
                (if (some? primc)
                    (do
                        (.getField gen, (:objtype this), (:name lb), (Type/getType primc))
                        (HostExpr'emitBoxReturn this, gen, primc)
                    )
                    (do
                        (.getField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                        (when (and (:onceOnly this) clear? (:canBeCleared lb))
                            (.loadThis gen)
                            (.visitInsn gen, Opcodes/ACONST_NULL)
                            (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                        )
                    )
                )
            )
            (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                (if (:isArg lb)
                    (let [#_"int" argoff (if (:canBeDirect this) 0 1)]
                        (.loadArg gen, (- (:idx lb) argoff))
                        (cond (some? primc)
                            (do
                                (HostExpr'emitBoxReturn this, gen, primc)
                            )
                            (and clear? (:canBeCleared lb))
                            (do
                                (.visitInsn gen, Opcodes/ACONST_NULL)
                                (.storeArg gen, (- (:idx lb) argoff))
                            )
                        )
                    )
                    (if (some? primc)
                        (do
                            (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ILOAD), (:idx lb))
                            (HostExpr'emitBoxReturn this, gen, primc)
                        )
                        (do
                            (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:idx lb))
                            (when (and clear? (:canBeCleared lb))
                                (.visitInsn gen, Opcodes/ACONST_NULL)
                                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx lb))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" ObjExpr''emitUnboxedLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb]
        (cond (.containsKey (:closes this), lb)
            (do
                (.loadThis gen)
                (.getField gen, (:objtype this), (:name lb), (Type/getType (LocalBinding''getPrimitiveType lb)))
            )
            (:isArg lb)
            (do
                (.loadArg gen, (- (:idx lb) (if (:canBeDirect this) 0 1)))
            )
            :else
            (do
                (.visitVarInsn gen, (.getOpcode (Type/getType (LocalBinding''getPrimitiveType lb)), Opcodes/ILOAD), (:idx lb))
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitVar [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" var]
        (let [#_"Integer" i (cast Integer (.valAt (:vars this), var))]
            (ObjExpr''emitConstant this, gen, i)
        )
        nil
    )

    (def #_"Method" ObjExpr'varGetMethod (Method/getMethod "Object get()"))
    (def #_"Method" ObjExpr'varGetRawMethod (Method/getMethod "Object getRawRoot()"))

    #_method
    (defn #_"void" ObjExpr''emitVarValue [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" v]
        (let [#_"Integer" i (cast Integer (.valAt (:vars this), v))]
            (if (not (Var''isDynamic v))
                (do
                    (ObjExpr''emitConstant this, gen, i)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, ObjExpr'varGetRawMethod)
                )
                (do
                    (ObjExpr''emitConstant this, gen, i)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, ObjExpr'varGetMethod)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitKeyword [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Keyword" k]
        (let [#_"Integer" i (cast Integer (.valAt (:keywords this), k))]
            (ObjExpr''emitConstant this, gen, i)
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitConstant [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"int" id]
        (ร ass this (assoc this :usedConstants (cast IPersistentSet (.cons (:usedConstants this), id))))
        (.getStatic gen, (:objtype this), (ObjExpr''constantName this, id), (ObjExpr''constantType this, id))
        nil
    )

    #_method
    (defn #_"String" ObjExpr''constantName [#_"ObjExpr" this, #_"int" id]
        (str ObjExpr'CONST_PREFIX id)
    )

    #_method
    (defn #_"String" ObjExpr''siteName [#_"ObjExpr" this, #_"int" n]
        (str "__site__" n)
    )

    #_method
    (defn #_"String" ObjExpr''siteNameStatic [#_"ObjExpr" this, #_"int" n]
        (str (ObjExpr''siteName this, n) "__")
    )

    #_method
    (defn #_"String" ObjExpr''thunkName [#_"ObjExpr" this, #_"int" n]
        (str "__thunk__" n)
    )

    #_method
    (defn #_"String" ObjExpr''cachedClassName [#_"ObjExpr" this, #_"int" n]
        (str "__cached_class__" n)
    )

    #_method
    (defn #_"String" ObjExpr''cachedVarName [#_"ObjExpr" this, #_"int" n]
        (str "__cached_var__" n)
    )

    #_method
    (defn #_"String" ObjExpr''varCallsiteName [#_"ObjExpr" this, #_"int" n]
        (str "__var__callsite__" n)
    )

    #_method
    (defn #_"String" ObjExpr''thunkNameStatic [#_"ObjExpr" this, #_"int" n]
        (str (ObjExpr''thunkName this, n) "__")
    )

    #_method
    (defn #_"Type" ObjExpr''constantType [#_"ObjExpr" this, #_"int" id]
        (let [#_"Object" o (.nth (:constants this), id) #_"Class" c (Util'classOf o)]
            (or
                (when (and (some? c) (Modifier/isPublic (.getModifiers c)))
                    ;; can't emit derived fn types due to visibility
                    (cond
                        (.isAssignableFrom LazySeq, c) (Type/getType ISeq)
                        (= c Keyword)                  (Type/getType Keyword)
                        (.isAssignableFrom RestFn, c)  (Type/getType RestFn)
                        (.isAssignableFrom AFn, c)     (Type/getType AFn)
                        (= c Var)                      (Type/getType Var)
                        (= c String)                   (Type/getType String)
                    )
                )
                Compiler'OBJECT_TYPE
            )
        )
    )
)

(class-ns FnExpr
    (def #_"Type" FnExpr'aFnType (Type/getType AFunction))
    (def #_"Type" FnExpr'restFnType (Type/getType RestFn))

    (defn- #_"FnExpr" FnExpr'init []
        (hash-map
            ;; if there is a variadic overload (there can only be one) it is stored here
            #_"FnMethod" :variadicMethod nil
            #_"IPersistentCollection" :methods nil
            #_"boolean" :hasPrimSigs false
            #_"boolean" :hasMeta false
            #_"boolean" :hasEnclosingMethod false
        )
    )

    (defn #_"FnExpr" FnExpr'new [#_"Object" tag]
        (merge (ObjExpr'new tag) (FnExpr'init))
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--FnExpr [#_"FnExpr" this]
        true
    )

    #_override
    (defn #_"boolean" ObjExpr'''supportsMeta--FnExpr [#_"FnExpr" this]
        (:hasMeta this)
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--FnExpr [#_"FnExpr" this]
        (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) AFunction)
    )

    #_override
    (defn #_"void" ObjExpr'''emitMethods--FnExpr [#_"FnExpr" this, #_"ClassVisitor" cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [#_"ISeq" s (RT'seq (:methods this))] (some? s) [(.next s)]
            (.emit (cast ObjMethod (.first s)), this, cv)
        )

        (when (FnExpr''isVariadic this)
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, (Method/getMethod "int getRequiredArity()"), nil, nil, cv)]
                (.visitCode gen)
                (.push gen, (.count (:reqParms (:variadicMethod this))))
                (.returnValue gen)
                (.endMethod gen)
            )
        )
        nil
    )

    (defn #_"Expr" FnExpr'parse [#_"Context" context, #_"ISeq" form, #_"String" name]
        (let [#_"IPersistentMap" fmeta (RT'meta form)
              #_"ObjMethod" owner (cast ObjMethod (.deref Compiler'METHOD))
              #_"FnExpr" fn
                (-> (FnExpr'new (Compiler'tagOf form))
                    (assoc :src form :hasEnclosingMethod (some? owner) :line (Compiler'lineDeref) :column (Compiler'columnDeref))
                )
              fn (when (some? (.meta (cast IMeta (.first form)))) => fn
                    (assoc fn :onceOnly (RT'booleanCast-1o (RT'get-2 (RT'meta (.first form)), (Keyword'intern (Symbol'intern nil, "once")))))
                )
              #_"String" basename (if (some? owner) (:name (:objx owner)) (Compiler'munge (:name (:name (Compiler'currentNS)))))
              [#_"Symbol" nm name]
                (if (instance? Symbol (RT'second form))
                    (let [nm (cast Symbol (RT'second form))]
                        [nm (str (:name nm) "__" (RT'nextID))]
                    )
                    (cond
                        (nil? name)   [nil (str "fn__" (RT'nextID))]
                        (some? owner) [nil (str name "__"(RT'nextID))]
                        :else         [nil name]
                    )
                )
              fn (assoc fn :name (str basename "$" (.replace (Compiler'munge name), ".", "_DOT_")))
              fn (assoc fn :internalName (.replace (:name fn), \., \/))
              fn (assoc fn :objtype (Type/getObjectType (:internalName fn)))
              #_"Keyword" retkey (Keyword'intern (Symbol'intern nil, "rettag")) #_"Object" rettag (RT'get-2 fmeta, retkey)
              #_"List<String>" prims (ArrayList.)
              fn (try
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            Compiler'CONSTANTS          PersistentVector'EMPTY
                            Compiler'CONSTANT_IDS       (IdentityHashMap.)
                            Compiler'KEYWORDS           PersistentHashMap'EMPTY
                            Compiler'VARS               PersistentHashMap'EMPTY
                            Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                            Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                            Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                            Compiler'NO_RECUR           nil
                        ])
                    ))
                    ;; arglist might be preceded by symbol naming this fn
                    (let [[fn form]
                            (when (some? nm) => [fn form]
                                [(assoc fn :thisName (:name nm)) (RT'cons Compiler'FN, (RT'next (RT'next form)))]
                            )
                          ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                          ;; turn former into latter
                          form
                            (when (instance? IPersistentVector (RT'second form)) => form
                                (RT'list-2 Compiler'FN, (RT'next form))
                            )
                          #_"FnMethod[]" a (make-array #_"FnMethod" Object (inc Compiler'MAX_POSITIONAL_ARITY))
                          [#_"FnMethod" variadic? #_"boolean" usesThis]
                            (loop-when [variadic? nil usesThis false #_"ISeq" s (RT'next form)] (some? s) => [variadic? usesThis]
                                (let [#_"FnMethod" f (FnMethod'parse fn, (cast ISeq (RT'first s)), rettag)
                                    usesThis (or usesThis (:usesThis f))
                                    variadic?
                                        (if (FnMethod''isVariadic f)
                                            (when (nil? variadic?) => (throw (RuntimeException. "Can't have more than 1 variadic overload"))
                                                f
                                            )
                                            (let [#_"int" n (.count (:reqParms f))]
                                                (when (nil? (aget a n)) => (throw (RuntimeException. "Can't have 2 overloads with same arity"))
                                                    (aset a n f)
                                                    variadic?
                                                )
                                            )
                                        )]
                                    (when (some? (:prim f))
                                        (.add prims, (:prim f))
                                    )
                                    (recur variadic? usesThis (RT'next s))
                                )
                            )]
                        (when (some? variadic?)
                            (loop-when-recur [#_"int" i (inc (.count (:reqParms variadic?)))] (<= i Compiler'MAX_POSITIONAL_ARITY) [(inc i)]
                                (when (some? (aget a i))
                                    (throw (RuntimeException. "Can't have fixed arity function with more params than variadic function"))
                                )
                            )
                        )
                        (let [fn (assoc fn :canBeDirect (and (not (:hasEnclosingMethod fn)) (zero? (.count (:closes fn))) (not usesThis)))
                              #_"IPersistentCollection" methods
                                (loop-when-recur [methods nil #_"int" i 0]
                                                 (< i (alength a))
                                                 [(if (some? (aget a i)) (RT'conj methods, (aget a i)) methods) (inc i)]
                                              => (if (some? variadic?) (RT'conj methods, variadic?) methods)
                                )]
                            (when (:canBeDirect fn)
                                (loop-when-recur [#_"Iterator" fmi (.iterator (cast Collection #_"<FnMethod>" methods))] (.hasNext fmi) [fmi]
                                    (let-when [#_"FnMethod" fm (.next fmi)] (some? (:locals fm))
                                        (loop-when-recur [#_"Iterator" lbi (.iterator (cast Collection #_"<LocalBinding>" (RT'keys (:locals fm))))] (.hasNext lbi) [lbi]
                                            (let-when [#_"LocalBinding" lb (.next lbi)] (:isArg lb)
                                                (ร ass (:idx lb) (dec (:idx lb)))
                                            )
                                        )
                                    )
                                )
                            )
                            (assoc fn
                                :methods methods
                                :variadicMethod variadic?
                                :keywords (cast IPersistentMap (.deref Compiler'KEYWORDS))
                                :vars (cast IPersistentMap (.deref Compiler'VARS))
                                :constants (cast PersistentVector (.deref Compiler'CONSTANTS))
                                :keywordCallsites (cast IPersistentVector (.deref Compiler'KEYWORD_CALLSITES))
                                :protocolCallsites (cast IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES))
                                :varCallsites (cast IPersistentSet (.deref Compiler'VAR_CALLSITES))
                                :constantsID (RT'nextID)
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
              fn (assoc fn :hasPrimSigs (pos? (.size prims)))
              fmeta
                (when (some? fmeta)
                    (-> fmeta (.without RT'LINE_KEY) (.without RT'COLUMN_KEY) (.without retkey))
                )
              fn (assoc fn :hasMeta (pos? (RT'count fmeta)))]
            (ObjExpr''compile fn, (if (FnExpr''isVariadic fn) "cloiure/lang/RestFn" "cloiure/lang/AFunction"), (when (pos? (.size prims)) (.toArray prims, (make-array String (.size prims)))), (:onceOnly fn))
            (ObjExpr''getCompiledClass fn)
            (when (.supportsMeta fn) => fn
                (MetaExpr'new fn, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), fmeta))
            )
        )
    )

    #_method
    (defn #_"boolean" FnExpr''isVariadic [#_"FnExpr" this]
        (some? (:variadicMethod this))
    )

    #_method
    (defn #_"void" FnExpr''emitForDefn [#_"FnExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit this, :Context'EXPRESSION, objx, gen)
        nil
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (defn- #_"PathNode" PathNode'init []
        (hash-map
            #_"PathType" :type nil
            #_"PathNode" :parent nil
        )
    )

    (defn #_"PathNode" PathNode'new [#_"PathType" type, #_"PathNode" parent]
        (let [this (PathNode'init)]
            (assoc this :type type :parent parent)
        )
    )
)

(class-ns ObjMethod
    (defn- #_"ObjMethod" ObjMethod'init []
        (hash-map
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            #_"ObjMethod" :parent nil
            ;; localbinding->localbinding
            #_"IPersistentMap" :locals nil
            ;; num->localbinding
            #_"IPersistentMap" :indexlocals nil
            #_"Expr" :body nil
            #_"ObjExpr" :objx nil
            #_"PersistentVector" :argLocals nil
            #_"int" :maxLocal 0
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :usesThis false
            #_"PersistentHashSet" :localsUsedInCatchFinally PersistentHashSet'EMPTY
            #_"IPersistentMap" :methodMeta nil
        )
    )

    (defn #_"ObjMethod" ObjMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (let [this (ObjMethod'init)]
            (assoc this :parent parent :objx objx)
        )
    )

    (defn #_"void" ObjMethod'emitBody [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" retClass, #_"Expr" body]
        (let [#_"MaybePrimitiveExpr" be (cast MaybePrimitiveExpr body)]
            (if (and (Util'isPrimitive retClass) (.canEmitPrimitive be))
                (let [#_"Class" bc (Compiler'maybePrimitiveType be)]
                    (cond (= bc retClass)
                        (do
                            (.emitUnboxed be, :Context'RETURN, objx, gen)
                        )
                        (and (= retClass Long/TYPE) (= bc Integer/TYPE))
                        (do
                            (.emitUnboxed be, :Context'RETURN, objx, gen)
                            (.visitInsn gen, Opcodes/I2L)
                        )
                        (and (= retClass Double/TYPE) (= bc Float/TYPE))
                        (do
                            (.emitUnboxed be, :Context'RETURN, objx, gen)
                            (.visitInsn gen, Opcodes/F2D)
                        )
                        (and (= retClass Integer/TYPE) (= bc Long/TYPE))
                        (do
                            (.emitUnboxed be, :Context'RETURN, objx, gen)
                            (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                        )
                        (and (= retClass Float/TYPE) (= bc Double/TYPE))
                        (do
                            (.emitUnboxed be, :Context'RETURN, objx, gen)
                            (.visitInsn gen, Opcodes/D2F)
                        )
                        :else
                        (do
                            (throw (IllegalArgumentException. (str "Mismatched primitive return, expected: " retClass ", had: " (.getJavaClass be))))
                        )
                    )
                )
                (do
                    (.emit body, :Context'RETURN, objx, gen)
                    (if (= retClass Void/TYPE)
                        (.pop gen)
                        (.unbox gen, (Type/getType retClass))
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--ObjMethod [#_"ObjMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                (.visitCode gen)

                (let [#_"Label" loopLabel (.mark gen)]
                    (.visitLineNumber gen, (:line this), loopLabel)
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'LOOP_LABEL loopLabel
                                Compiler'METHOD     this
                            ])
                        ))

                        (.emit (:body this), :Context'RETURN, fn, gen)
                        (let [#_"Label" end (.mark gen)]
                            (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                            (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                (let [#_"LocalBinding" lb (cast LocalBinding (.first lbs))]
                                    (.visitLocalVariable gen, (:name lb), "Ljava/lang/Object;", nil, loopLabel, end, (:idx lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjMethod''emitClearLocals [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (defn #_"void" ObjMethod''emitClearLocalsOld [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (.count (:argLocals this))]
            (let [#_"LocalBinding" lb (cast LocalBinding (.nth (:argLocals this), i))]
                (when (and (not (.contains (:localsUsedInCatchFinally this), (:idx lb))) (nil? (LocalBinding''getPrimitiveType lb)))
                    (.visitInsn gen, Opcodes/ACONST_NULL)
                    (.storeArg gen, (dec (:idx lb)))
                )
            )
        )
        (loop-when-recur [#_"int" i (inc (.numParams this))] (< i (inc (:maxLocal this))) [(inc i)]
            (when (not (.contains (:localsUsedInCatchFinally this), i))
                (let [#_"LocalBinding" b (cast LocalBinding (RT'get-2 (:indexlocals this), i))]
                    (when (or (nil? b) (nil? (Compiler'maybePrimitiveType (:init b))))
                        (.visitInsn gen, Opcodes/ACONST_NULL)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), i)
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjMethod''emitClearThis [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        (.visitInsn gen, Opcodes/ACONST_NULL)
        (.visitVarInsn gen, Opcodes/ASTORE, 0)
        nil
    )
)

(class-ns FnMethod
    (defn- #_"FnMethod" FnMethod'init []
        (hash-map
            ;; localbinding->localbinding
            #_"PersistentVector" :reqParms nil
            #_"LocalBinding" :restParm nil
            #_"Type[]" :argtypes nil
            #_"Class[]" :argclasses nil
            #_"Class" :retClass nil
            #_"String" :prim nil
        )
    )

    (defn #_"FnMethod" FnMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (merge (ObjMethod'new objx, parent) (FnMethod'init))
    )

    (defn #_"char" FnMethod'classChar [#_"Object" x]
        (let [#_"Class" c
                (cond
                    (instance? Class x)  (cast Class x)
                    (instance? Symbol x) (Compiler'primClass-1s (cast Symbol x))
                )]
            (cond
                (or (nil? c) (not (.isPrimitive c))) \O
                (= c Long/TYPE)                      \L
                (= c Double/TYPE)                    \D
                :else
                    (throw (IllegalArgumentException. "Only long and double primitives are supported"))
            )
        )
    )

    (defn #_"String" FnMethod'primInterface [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (dotimes [#_"int" i (.count args)]
                (.append sb, (FnMethod'classChar (Compiler'tagOf (.nth args, i))))
            )
            (.append sb, (FnMethod'classChar (Compiler'tagOf args)))
            (let [#_"String" s (.toString sb) #_"boolean" prim? (or (.contains s, "L") (.contains s, "D"))]
                (cond
                    (and prim? (< 4 (.count args))) (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    prim?                           (str "cloiure.lang.IFn$" s)
                )
            )
        )
    )

    (defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Object" rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" parms (cast IPersistentVector (RT'first form)) #_"ISeq" body (RT'next form)]
            (try
                (let [#_"FnMethod" method
                        (-> (FnMethod'new objx, (cast ObjMethod (.deref Compiler'METHOD)))
                            (assoc :line (Compiler'lineDeref) :column (Compiler'columnDeref))
                        )
                      ;; register as the current method and set up a new env frame
                      #_"PathNode" pnode (or (cast PathNode (Var''get Compiler'CLEAR_PATH)) (PathNode'new :PathType'PATH, nil))]
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            Compiler'METHOD                method
                            Compiler'LOCAL_ENV             (.deref Compiler'LOCAL_ENV)
                            Compiler'LOOP_LOCALS           nil
                            Compiler'NEXT_LOCAL_NUM        0
                            Compiler'CLEAR_PATH            pnode
                            Compiler'CLEAR_ROOT            pnode
                            Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                            Compiler'METHOD_RETURN_CONTEXT RT'T
                        ])
                    ))
                    (let [#_"String" prim (FnMethod'primInterface parms) prim (when (some? prim) (.replace prim, \., \/))
                          method (assoc method :prim prim)
                          rettag (if (instance? String rettag) (Symbol'intern nil, (cast String rettag)) rettag)
                          rettag (when (and (instance? Symbol rettag) (any = (.getName (cast Symbol rettag)) "long" "double")) rettag)
                          #_"Class" retClass (Compiler'tagClass (or (Compiler'tagOf parms) rettag))
                          retClass
                            (when (.isPrimitive retClass) => Object
                                (when-not (any = retClass Double/TYPE Long/TYPE) => retClass
                                    (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                )
                            )
                          method (assoc method :retClass retClass)]
                        ;; register 'this' as local 0
                        (if (some? (:thisName objx))
                            (Compiler'registerLocal (Symbol'intern (:thisName objx)), nil, nil, false)
                            (Compiler'getAndIncLocalNum)
                        )
                        (let [#_"List<Type>" argtypes (ArrayList.) #_"List<Class>" argclasses (ArrayList.)
                              [#_"PersistentVector" reqParms #_"LocalBinding" restParm #_"PersistentVector" argLocals]
                                (loop-when [#_"boolean" rest? false reqParms PersistentVector'EMPTY restParm nil argLocals PersistentVector'EMPTY #_"int" i 0] (< i (.count parms)) => [reqParms restParm argLocals]
                                    (when (instance? Symbol (.nth parms, i)) => (throw (IllegalArgumentException. "fn params must be Symbols"))
                                        (let [#_"Symbol" p (cast Symbol (.nth parms, i))]
                                            (cond
                                                (some? (.getNamespace p))
                                                    (throw (RuntimeException. (str "Can't use qualified name as parameter: " p)))
                                                (.equals p, Compiler'_AMP_)
                                                    (when-not rest? => (throw (RuntimeException. "Invalid parameter list"))
                                                        (recur true reqParms restParm argLocals (inc i))
                                                    )
                                                :else
                                                    (let [#_"Class" pc (Compiler'primClass-1c (Compiler'tagClass (Compiler'tagOf p)))]
                                                        (when (and (.isPrimitive pc) (not (any = pc Double/TYPE Long/TYPE)))
                                                            (throw (IllegalArgumentException. (str "Only long and double primitives are supported: " p)))
                                                        )
                                                        (when (and rest? (some? (Compiler'tagOf p)))
                                                            (throw (RuntimeException. "& arg cannot have type hint"))
                                                        )
                                                        (when (and rest? (some? prim))
                                                            (throw (RuntimeException. "fns taking primitives cannot be variadic"))
                                                        )
                                                        (let [pc (if rest? ISeq pc)]
                                                            (.add argtypes, (Type/getType pc))
                                                            (.add argclasses, pc)
                                                            (let [#_"LocalBinding" lb
                                                                    (if (.isPrimitive pc)
                                                                        (Compiler'registerLocal p, nil, (MethodParamExpr'new pc), true)
                                                                        (Compiler'registerLocal p, (if rest? Compiler'ISEQ (Compiler'tagOf p)), nil, true)
                                                                    )
                                                                  argLocals (.cons argLocals, lb)]
                                                                (if-not rest?
                                                                    [(.cons reqParms, lb) restParm argLocals]
                                                                    [reqParms lb argLocals]
                                                                )
                                                            )
                                                        )
                                                    )
                                            )
                                        )
                                    )
                                )]
                            (when (< Compiler'MAX_POSITIONAL_ARITY (.count reqParms))
                                (throw (RuntimeException. (str "Can't specify more than " Compiler'MAX_POSITIONAL_ARITY " params")))
                            )
                            (Var''set Compiler'LOOP_LOCALS, argLocals)
                            (let [method
                                    (assoc method
                                        :reqParms reqParms :restParm restParm :argLocals argLocals
                                        :argtypes (.toArray argtypes, (make-array Type (.size argtypes)))
                                        :argclasses (.toArray argclasses, (make-array Class (.size argtypes)))
                                    )]
                                (when (some? prim)
                                    (dotimes [#_"int" i (alength (:argclasses method))]
                                        (when (any = (aget (:argclasses method) i) Long/TYPE Double/TYPE)
                                            (Compiler'getAndIncLocalNum)
                                        )
                                    )
                                )
                                (assoc method :body (.parse (BodyParser'new), :Context'RETURN, body))
                            )
                        )
                    )
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--FnMethod [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (cond
            (:canBeDirect fn)    (FnMethod''doEmitStatic this, fn, cv)
            (some? (:prim this)) (FnMethod''doEmitPrim this, fn, cv)
            :else                (FnMethod''doEmit this, fn, cv)
        )
        nil
    )

    #_method
    (defn #_"void" FnMethod''doEmitStatic [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Type" returnType (Type/getType (:retClass this))
              #_"Method" ms (Method. "invokeStatic", returnType, (:argtypes this))
              ;; todo don't hardwire EXCEPTION_TYPES
              #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ms, nil, Compiler'EXCEPTION_TYPES, cv)]
            (.visitCode gen)
            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map
                        (object-array [
                            Compiler'LOOP_LABEL loopLabel
                            Compiler'METHOD     this
                        ])
                    ))
                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))
                    (let [#_"Label" end (.mark gen)]
                        (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argtypes this) (:idx lb))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
                (.returnValue gen)
                (.endMethod gen)
                ;; generate the regular invoke, calling the static method
                (let [#_"Method" m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))
                      ;; todo don't hardwire EXCEPTION_TYPES
                      gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                    (.visitCode gen)
                    (dotimes [#_"int" i (alength (:argtypes this))]
                        (.loadArg gen, i)
                        (HostExpr'emitUnboxArg fn, gen, (aget (:argclasses this) i))
                        (when-not (.isPrimitive (aget (:argclasses this) i))
                            (.visitInsn gen, Opcodes/ACONST_NULL)
                            (.storeArg gen, i)
                        )
                    )
                    (let [#_"Label" callLabel (.mark gen)]
                        (.visitLineNumber gen, (:line this), callLabel)
                        (.invokeStatic gen, (:objtype (:objx this)), ms)
                        (.box gen, returnType)
                        (.returnValue gen)
                        (.endMethod gen)
                        ;; generate invokePrim if prim
                        (when (some? (:prim this))
                            (let [returnType (if (any = (:retClass this) Double/TYPE Long/TYPE) (.getReturnType this) Compiler'OBJECT_TYPE)
                                  #_"Method" pm (Method. "invokePrim", returnType, (:argtypes this))
                                  ;; todo don't hardwire EXCEPTION_TYPES
                                  gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), pm, nil, Compiler'EXCEPTION_TYPES, cv)]
                                (.visitCode gen)
                                (dotimes [#_"int" i (alength (:argtypes this))]
                                    (.loadArg gen, i)
                                    (when-not (.isPrimitive (aget (:argclasses this) i))
                                        (.visitInsn gen, Opcodes/ACONST_NULL)
                                        (.storeArg gen, i)
                                    )
                                )
                                (.invokeStatic gen, (:objtype (:objx this)), ms)
                                (.returnValue gen)
                                (.endMethod gen)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" FnMethod''doEmitPrim [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Type" returnType (if (any = (:retClass this) Double/TYPE Long/TYPE) (.getReturnType this) Compiler'OBJECT_TYPE)
              #_"Method" ms (Method. "invokePrim", returnType, (:argtypes this))
              ;; todo don't hardwire EXCEPTION_TYPES
              #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ms, nil, Compiler'EXCEPTION_TYPES, cv)]
            (.visitCode gen)

            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map
                        (object-array [
                            Compiler'LOOP_LABEL loopLabel
                            Compiler'METHOD     this
                        ])
                    ))
                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))

                    (let [#_"Label" end (.mark gen)]
                        (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                        (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argtypes this) (dec (:idx lb)))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )

                (.returnValue gen)
                (.endMethod gen)

                ;; generate the regular invoke, calling the prim method
                (let [#_"Method" m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))
                      ;; todo don't hardwire EXCEPTION_TYPES
                      gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                    (.visitCode gen)
                    (.loadThis gen)
                    (dotimes [#_"int" i (alength (:argtypes this))]
                        (.loadArg gen, i)
                        (HostExpr'emitUnboxArg fn, gen, (aget (:argclasses this) i))
                    )
                    (.invokeInterface gen, (Type/getType (str "L" (:prim this) ";")), ms)
                    (.box gen, (.getReturnType this))

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" FnMethod''doEmit [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                (.visitCode gen)

                (let [#_"Label" loopLabel (.mark gen)]
                    (.visitLineNumber gen, (:line this), loopLabel)
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'LOOP_LABEL loopLabel
                                Compiler'METHOD     this
                            ])
                        ))

                        (.emit (:body this), :Context'RETURN, fn, gen)
                        (let [#_"Label" end (.mark gen)]
                            (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                            (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                (let [#_"LocalBinding" lb (cast LocalBinding (.first lbs))]
                                    (.visitLocalVariable gen, (:name lb), "Ljava/lang/Object;", nil, loopLabel, end, (:idx lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"boolean" FnMethod''isVariadic [#_"FnMethod" this]
        (some? (:restParm this))
    )

    #_override
    (defn #_"int" ObjMethod'''numParams--FnMethod [#_"FnMethod" this]
        (+ (.count (:reqParms this)) (if (FnMethod''isVariadic this) 1 0))
    )

    #_override
    (defn #_"String" ObjMethod'''getMethodName--FnMethod [#_"FnMethod" this]
        (if (FnMethod''isVariadic this) "doInvoke" "invoke")
    )

    #_override
    (defn #_"Type" ObjMethod'''getReturnType--FnMethod [#_"FnMethod" this]
        (if (some? (:prim this))
            (Type/getType (:retClass this))
            Compiler'OBJECT_TYPE
        )
    )

    #_override
    (defn #_"Type[]" ObjMethod'''getArgTypes--FnMethod [#_"FnMethod" this]
        (if (and (FnMethod''isVariadic this) (= (.count (:reqParms this)) Compiler'MAX_POSITIONAL_ARITY))
            (let [#_"int" n (inc Compiler'MAX_POSITIONAL_ARITY) #_"Type[]" a (make-array Type n)]
                (dotimes [#_"int" i n]
                    (aset a i Compiler'OBJECT_TYPE)
                )
                a
            )
            (aget Compiler'ARG_TYPES (.numParams this))
        )
    )
)

(class-ns LocalBinding
    (defn- #_"LocalBinding" LocalBinding'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"Symbol" :tag nil
            #_"Expr" :init nil
            #_"int" :idx 0
            #_"String" :name nil
            #_"boolean" :isArg false
            #_"PathNode" :clearPathRoot nil
            #_"boolean" :canBeCleared true
            #_"boolean" :recurMistmatch false
            #_"boolean" :used false
        )
    )

    (defn #_"LocalBinding" LocalBinding'new [#_"int" num, #_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg, #_"PathNode" clearPathRoot]
        (when (and (some? (Compiler'maybePrimitiveType init)) (some? tag))
            (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
        )
        (-> (LocalBinding'init)
            (assoc :idx num :sym sym :tag tag :init init :isArg isArg :clearPathRoot clearPathRoot :name (Compiler'munge (:name sym)))
        )
    )

    #_memoize!
    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LocalBinding [#_"LocalBinding" this]
        (let [? (and (some? (:init this)) (.hasJavaClass (:init this)))]
            (if (and ? (Util'isPrimitive (.getJavaClass (:init this))) (not (instance? MaybePrimitiveExpr (:init this))))
                false
                (or (some? (:tag this)) ?)
            )
        )
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--LocalBinding [#_"LocalBinding" this]
        (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getJavaClass (:init this)))
    )

    #_method
    (defn #_"Class" LocalBinding''getPrimitiveType [#_"LocalBinding" this]
        (Compiler'maybePrimitiveType (:init this))
    )
)

(class-ns LocalBindingExpr
    (defn- #_"LocalBindingExpr" LocalBindingExpr'init []
        (hash-map
            #_"LocalBinding" :lb nil
            #_"Symbol" :tag nil

            #_"PathNode" :clearPath nil
            #_"PathNode" :clearRoot nil
            #_"boolean" :shouldClear false
        )
    )

    (defn #_"LocalBindingExpr" LocalBindingExpr'new [#_"LocalBinding" lb, #_"Symbol" tag]
        (when (or (nil? (LocalBinding''getPrimitiveType lb)) (nil? tag)) => (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            (let [this
                    (assoc (LocalBindingExpr'init)
                        :lb lb
                        :tag tag
                        :clearPath (cast PathNode (Var''get Compiler'CLEAR_PATH))
                        :clearRoot (cast PathNode (Var''get Compiler'CLEAR_ROOT))
                    )]
                (ร ass (:used lb) true)
                (when (pos? (:idx lb)) => this
                    (let [#_"IPersistentCollection" sites (cast IPersistentCollection (RT'get-2 (Var''get Compiler'CLEAR_SITES), lb))]
                        (when (some? sites)
                            (loop-when-recur [#_"ISeq" s (.seq sites)] (some? s) [(.next s)]
                                (let [#_"LocalBindingExpr" lbe (cast LocalBindingExpr (.first s))
                                      #_"PathNode" common (Compiler'commonPath (:clearPath this), (:clearPath lbe))]
                                    (when (and (some? common) (= (:type common) :PathType'PATH))
                                        (ร ass (:shouldClear lbe) false)
                                    )
                                )
                            )
                        )
                        (when (= (:clearRoot this) (:clearPathRoot lb)) => this
                            (let [this (assoc this :shouldClear true)]
                                (Var''set Compiler'CLEAR_SITES, (RT'assoc (Var''get Compiler'CLEAR_SITES), lb, (RT'conj sites, this)))
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--LocalBindingExpr [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--LocalBindingExpr [#_"LocalBindingExpr" this]
        (some? (LocalBinding''getPrimitiveType (:lb this)))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitUnboxedLocal objx, gen, (:lb this))
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (ObjExpr''emitLocal objx, gen, (:lb this), (:shouldClear this))
        )
        nil
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Expr" val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (ObjExpr''emitAssignLocal objx, gen, (:lb this), val)
        (when (not= context :Context'STATEMENT)
            (ObjExpr''emitLocal objx, gen, (:lb this), false)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LocalBindingExpr [#_"LocalBindingExpr" this]
        (or (some? (:tag this)) (.hasJavaClass (:lb this)))
    )

    #_memoize!
    #_override
    (defn #_"Class" Expr'''getJavaClass--LocalBindingExpr [#_"LocalBindingExpr" this]
        (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getJavaClass (:lb this)))
    )
)

(class-ns BodyParser
    (defn #_"IParser" BodyParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" forms]
                (let [#_"ISeq" s (cast ISeq forms) s (if (Util'equals (RT'first s), Compiler'DO) (RT'next s) s)
                      #_"PersistentVector" v
                        (loop-when [v PersistentVector'EMPTY s s] (some? s) => v
                            (let [#_"Context" c (if (and (not= context :Context'EVAL) (or (= context :Context'STATEMENT) (some? (.next s)))) :Context'STATEMENT context)]
                                (recur (.cons v, (Compiler'analyze-2 c, (.first s))) (.next s))
                            )
                        )]
                    (BodyExpr'new (if (pos? (.count v)) v (.cons v, Compiler'NIL_EXPR)))
                )
            )
        )
    )
)

(class-ns BodyExpr
    (defn- #_"BodyExpr" BodyExpr'init []
        (hash-map
            #_"PersistentVector" :exprs nil
        )
    )

    (defn #_"BodyExpr" BodyExpr'new [#_"PersistentVector" exprs]
        (let [this (BodyExpr'init)]
            (assoc this :exprs exprs)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--BodyExpr [#_"BodyExpr" this]
        (let [#_"Iterator" it (.iterator (:exprs this))]
            (loop-when-recur [#_"Object" ret nil] (.hasNext it) [(.eval (cast Expr (.next it)))] => ret)
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--BodyExpr [#_"BodyExpr" this]
        (and (instance? MaybePrimitiveExpr (BodyExpr''lastExpr this)) (.canEmitPrimitive (cast MaybePrimitiveExpr (BodyExpr''lastExpr this))))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--BodyExpr [#_"BodyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (dec (.count (:exprs this)))]
            (let [#_"Expr" e (cast Expr (.nth (:exprs this), i))]
                (.emit e, :Context'STATEMENT, objx, gen)
            )
        )
        (let [#_"MaybePrimitiveExpr" last (cast MaybePrimitiveExpr (.nth (:exprs this), (dec (.count (:exprs this)))))]
            (.emitUnboxed last, context, objx, gen)
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--BodyExpr [#_"BodyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (dec (.count (:exprs this)))]
            (let [#_"Expr" e (cast Expr (.nth (:exprs this), i))]
                (.emit e, :Context'STATEMENT, objx, gen)
            )
        )
        (let [#_"Expr" last (cast Expr (.nth (:exprs this), (dec (.count (:exprs this)))))]
            (.emit last, context, objx, gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--BodyExpr [#_"BodyExpr" this]
        (.hasJavaClass (BodyExpr''lastExpr this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--BodyExpr [#_"BodyExpr" this]
        (.getJavaClass (BodyExpr''lastExpr this))
    )

    #_method
    (defn- #_"Expr" BodyExpr''lastExpr [#_"BodyExpr" this]
        (cast Expr (.nth (:exprs this), (dec (.count (:exprs this)))))
    )
)

(class-ns BindingInit
    (defn- #_"BindingInit" BindingInit'init []
        (hash-map
            #_"LocalBinding" :binding nil
            #_"Expr" :init nil
        )
    )

    (defn #_"BindingInit" BindingInit'new [#_"LocalBinding" binding, #_"Expr" init]
        (let [this (BindingInit'init)]
            (assoc this :binding binding :init init)
        )
    )
)

(class-ns LetFnParser
    (defn #_"IParser" LetFnParser'new []
        (reify IParser
            ;; (letfns* [var (fn [args] body) ...] body...)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"ISeq" form (cast ISeq frm)]
                    (when (instance? IPersistentVector (RT'second form)) => (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                        (let [#_"IPersistentVector" bindings (cast IPersistentVector (RT'second form))]
                            (when (zero? (% (.count bindings) 2)) => (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                                (if (= context :Context'EVAL)
                                    (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                                    (try
                                        (Var'pushThreadBindings (RT'map
                                            (object-array [
                                                Compiler'LOCAL_ENV      (.deref Compiler'LOCAL_ENV)
                                                Compiler'NEXT_LOCAL_NUM (.deref Compiler'NEXT_LOCAL_NUM)
                                            ])
                                        ))
                                        ;; pre-seed env (like Lisp labels)
                                        (let [#_"PersistentVector" lbs
                                                (loop-when [lbs PersistentVector'EMPTY #_"int" i 0] (< i (.count bindings)) => lbs
                                                    (let-when [#_"Object" o (.nth bindings, i)] (instance? Symbol o) => (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " o)))
                                                        (let-when [#_"Symbol" sym (cast Symbol o)] (nil? (.getNamespace sym)) => (throw (RuntimeException. (str "Can't let qualified name: " sym)))
                                                            (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (Compiler'tagOf sym), nil, false)]
                                                                (ร ass (:canBeCleared lb) false)
                                                                (recur (.cons lbs, lb) (+ i 2))
                                                            )
                                                        )
                                                    )
                                                )
                                              #_"PersistentVector" bis
                                                (loop-when [bis PersistentVector'EMPTY #_"int" i 0] (< i (.count bindings)) => bis
                                                    (let [#_"Symbol" sym (cast Symbol (.nth bindings, i))
                                                          #_"Expr" init (Compiler'analyze-3 :Context'EXPRESSION, (.nth bindings, (inc i)), (:name sym))
                                                          #_"LocalBinding" lb (cast LocalBinding (.nth lbs, (/ i 2)))]
                                                        (ร ass (:init lb) init)
                                                        (recur (.cons bis, (BindingInit'new lb, init)) (+ i 2))
                                                    )
                                                )]
                                            (LetFnExpr'new bis, (.parse (BodyParser'new), context, (RT'next (RT'next form))))
                                        )
                                        (finally
                                            (Var'popThreadBindings)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr
    (defn- #_"LetFnExpr" LetFnExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
        )
    )

    (defn #_"LetFnExpr" LetFnExpr'new [#_"PersistentVector" bindingInits, #_"Expr" body]
        (let [this (LetFnExpr'init)]
            (assoc this :bindingInits bindingInits :body body)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--LetFnExpr [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_override
    (defn #_"void" Expr'''emit--LetFnExpr [#_"LetFnExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (.count (:bindingInits this))]
            (let [#_"BindingInit" bi (cast BindingInit (.nth (:bindingInits this), i))]
                (.visitInsn gen, Opcodes/ACONST_NULL)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
            )
        )
        (let [#_"IPersistentSet" lbset
                (loop-when [lbset PersistentHashSet'EMPTY #_"int" i 0] (< i (.count (:bindingInits this))) => lbset
                    (let [#_"BindingInit" bi (cast BindingInit (.nth (:bindingInits this), i))
                          lbset (cast IPersistentSet (.cons lbset, (:binding bi)))]
                        (.emit (:init bi), :Context'EXPRESSION, objx, gen)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
                        (recur lbset (inc i))
                    )
                )]
            (dotimes [#_"int" i (.count (:bindingInits this))]
                (let [#_"BindingInit" bi (cast BindingInit (.nth (:bindingInits this), i))]
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:idx (:binding bi)))
                    (ObjExpr''emitLetFnInits (cast ObjExpr (:init bi)), gen, objx, lbset)
                )
            )
            (let [#_"Label" loopLabel (.mark gen)]
                (.emit (:body this), context, objx, gen)
                (let [#_"Label" end (.mark gen)]
                    (loop-when-recur [#_"ISeq" bis (.seq (:bindingInits this))] (some? bis) [(.next bis)]
                        (let [#_"BindingInit" bi (cast BindingInit (.first bis))
                              #_"String" lname (:name (:binding bi)) lname (if (.endsWith lname, "__auto__") (str lname (RT'nextID)) lname)
                              #_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                            (.visitLocalVariable gen, lname, (if (some? primc) (Type/getDescriptor primc) "Ljava/lang/Object;"), nil, loopLabel, end, (:idx (:binding bi)))
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LetFnExpr [#_"LetFnExpr" this]
        (.hasJavaClass (:body this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--LetFnExpr [#_"LetFnExpr" this]
        (.getJavaClass (:body this))
    )
)

(class-ns LetParser
    (defn #_"IParser" LetParser'new []
        (reify IParser
            ;; (let [var val var2 val2 ...] body...)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"ISeq" form (cast ISeq frm) #_"boolean" isLoop (.equals (RT'first form), Compiler'LOOP)]
                    (when (instance? IPersistentVector (RT'second form)) => (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                        (let [#_"IPersistentVector" bindings (cast IPersistentVector (RT'second form))]
                            (when (zero? (% (.count bindings) 2)) => (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                                (if (or (= context :Context'EVAL) (and (= context :Context'EXPRESSION) isLoop))
                                    (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                                    (let [#_"ISeq" body (RT'next (RT'next form))
                                          #_"ObjMethod" method (cast ObjMethod (.deref Compiler'METHOD))
                                          #_"IPersistentMap" backupMethodLocals (:locals method)
                                          #_"IPersistentMap" backupMethodIndexLocals (:indexlocals method)
                                          #_"IPersistentVector" recurMismatches
                                            (loop-when-recur [recurMismatches PersistentVector'EMPTY #_"int" i 0]
                                                             (< i (/ (.count bindings) 2))
                                                             [(.cons recurMismatches, RT'F) (inc i)]
                                                          => recurMismatches
                                            )]
                                        ;; may repeat once for each binding with a mismatch, return breaks
                                        (while true
                                            (let [#_"IPersistentMap" dynamicBindings
                                                    (RT'map
                                                        (object-array [
                                                            Compiler'LOCAL_ENV      (.deref Compiler'LOCAL_ENV)
                                                            Compiler'NEXT_LOCAL_NUM (.deref Compiler'NEXT_LOCAL_NUM)
                                                        ])
                                                    )
                                                  dynamicBindings
                                                    (when isLoop => dynamicBindings
                                                        (.assoc dynamicBindings, Compiler'LOOP_LOCALS, nil)
                                                    )
                                                  _ (ร ass method (assoc method :locals backupMethodLocals))
                                                  _ (ร ass method (assoc method :indexlocals backupMethodIndexLocals))
                                                  #_"PathNode" looproot (PathNode'new :PathType'PATH, (cast PathNode (Var''get Compiler'CLEAR_PATH)))
                                                  #_"PathNode" clearroot (PathNode'new :PathType'PATH, looproot)
                                                  #_"PathNode" clearpath (PathNode'new :PathType'PATH, looproot)]
                                                (try
                                                    (Var'pushThreadBindings dynamicBindings)
                                                    (let [#_"PersistentVector" bindingInits PersistentVector'EMPTY
                                                          #_"PersistentVector" loopLocals PersistentVector'EMPTY
                                                          _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                                                (when (instance? Symbol (.nth bindings, i)) => (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth bindings, i))))
                                                                    (let [#_"Symbol" sym (cast Symbol (.nth bindings, i))]
                                                                        (when (nil? (.getNamespace sym)) => (throw (RuntimeException. (str "Can't let qualified name: " sym)))
                                                                            (let [#_"Expr" init (Compiler'analyze-3 :Context'EXPRESSION, (.nth bindings, (inc i)), (:name sym))
                                                                                  init
                                                                                    (when isLoop => init
                                                                                        (if (and (some? recurMismatches) (RT'booleanCast-1o (.nth recurMismatches, (/ i 2))))
                                                                                            (do
                                                                                                (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                                                                                                    (.println (RT'errPrintWriter), (str "Auto-boxing loop arg: " sym))
                                                                                                )
                                                                                                (StaticMethodExpr'new 0, 0, nil, RT, "box", (RT'vector init), false)
                                                                                            )
                                                                                            (condp = (Compiler'maybePrimitiveType init)
                                                                                                Integer/TYPE (StaticMethodExpr'new 0, 0, nil, RT, "longCast", (RT'vector init), false)
                                                                                                Float/TYPE   (StaticMethodExpr'new 0, 0, nil, RT, "doubleCast", (RT'vector init), false)
                                                                                                             init
                                                                                            )
                                                                                        )
                                                                                    )]
                                                                                ;; sequential enhancement of env (like Lisp let*)
                                                                                (try
                                                                                    (when isLoop
                                                                                        (Var'pushThreadBindings (RT'map
                                                                                            (object-array [
                                                                                                Compiler'CLEAR_PATH clearpath
                                                                                                Compiler'CLEAR_ROOT clearroot
                                                                                                Compiler'NO_RECUR   nil
                                                                                            ])
                                                                                        ))
                                                                                    )
                                                                                    (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (Compiler'tagOf sym), init, false)]
                                                                                        (ร ass bindingInits (.cons bindingInits, (BindingInit'new lb, init)))
                                                                                        (when isLoop
                                                                                            (ร ass loopLocals (.cons loopLocals, lb))
                                                                                        )
                                                                                    )
                                                                                    (finally
                                                                                        (when isLoop
                                                                                            (Var'popThreadBindings)
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )]
                                                        (when isLoop
                                                            (Var''set Compiler'LOOP_LOCALS, loopLocals)
                                                        )
                                                        (let [#_"boolean" moreMismatches false
                                                              #_"Expr" bodyExpr
                                                                (try
                                                                    (when isLoop
                                                                        (Var'pushThreadBindings (RT'map
                                                                            (object-array [
                                                                                Compiler'CLEAR_PATH            clearpath
                                                                                Compiler'CLEAR_ROOT            clearroot
                                                                                Compiler'NO_RECUR              nil
                                                                                Compiler'METHOD_RETURN_CONTEXT (when (= context :Context'RETURN) (.deref Compiler'METHOD_RETURN_CONTEXT))
                                                                            ])
                                                                        ))
                                                                    )
                                                                    (.parse (BodyParser'new), (if isLoop :Context'RETURN context), body)
                                                                    (finally
                                                                        (when isLoop
                                                                            (Var'popThreadBindings)
                                                                            (loop-when-recur [#_"int" i 0] (< i (.count loopLocals)) [(inc i)]
                                                                                (when (:recurMistmatch (cast LocalBinding (.nth loopLocals, i)))
                                                                                    (ร ass recurMismatches (cast IPersistentVector (.assoc recurMismatches, i, RT'T)))
                                                                                    (ร ass moreMismatches true)
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )]
                                                            (when-not moreMismatches
                                                                (ร return (LetExpr'new bindingInits, bodyExpr, isLoop))
                                                            )
                                                        )
                                                    )
                                                    (finally
                                                        (Var'popThreadBindings)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr
    (defn- #_"LetExpr" LetExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
            #_"boolean" :isLoop false
        )
    )

    (defn #_"LetExpr" LetExpr'new [#_"PersistentVector" bindingInits, #_"Expr" body, #_"boolean" isLoop]
        (let [this (LetExpr'init)]
            (assoc this :bindingInits bindingInits :body body :isLoop isLoop)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--LetExpr [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_override
    (defn #_"void" Expr'''emit--LetExpr [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (LetExpr''doEmit this, context, objx, gen, false)
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--LetExpr [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (LetExpr''doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (defn- #_"void" LetExpr''doEmit [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" bindingLabels (HashMap.)]
            (dotimes [#_"int" i (.count (:bindingInits this))]
                (let [#_"BindingInit" bi (cast BindingInit (.nth (:bindingInits this), i))
                      #_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                    (if (some? primc)
                        (do
                            (.emitUnboxed (cast MaybePrimitiveExpr (:init bi)), :Context'EXPRESSION, objx, gen)
                            (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ISTORE), (:idx (:binding bi)))
                        )
                        (do
                            (.emit (:init bi), :Context'EXPRESSION, objx, gen)
                            (if (and (not (:used (:binding bi))) (:canBeCleared (:binding bi)))
                                (.pop gen)
                                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
                            )
                        )
                    )
                    (.put bindingLabels, bi, (.mark gen))
                )
            )
            (let [#_"Label" loopLabel (.mark gen)]
                (if (:isLoop this)
                    (try
                        (Var'pushThreadBindings (RT'map Compiler'LOOP_LABEL, loopLabel))
                        (if emitUnboxed
                            (.emitUnboxed (cast MaybePrimitiveExpr (:body this)), context, objx, gen)
                            (.emit (:body this), context, objx, gen)
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                    (if emitUnboxed
                        (.emitUnboxed (cast MaybePrimitiveExpr (:body this)), context, objx, gen)
                        (.emit (:body this), context, objx, gen)
                    )
                )
                (let [#_"Label" end (.mark gen)]
                    (loop-when-recur [#_"ISeq" bis (.seq (:bindingInits this))] (some? bis) [(.next bis)]
                        (let [#_"BindingInit" bi (cast BindingInit (.first bis))
                              #_"String" lname (:name (:binding bi)) lname (if (.endsWith lname, "__auto__") (str lname (RT'nextID)) lname)
                              #_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                            (.visitLocalVariable gen, lname, (if (some? primc) (Type/getDescriptor primc) "Ljava/lang/Object;"), nil, (.get bindingLabels, bi), end, (:idx (:binding bi)))
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LetExpr [#_"LetExpr" this]
        (.hasJavaClass (:body this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--LetExpr [#_"LetExpr" this]
        (.getJavaClass (:body this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--LetExpr [#_"LetExpr" this]
        (and (instance? MaybePrimitiveExpr (:body this)) (.canEmitPrimitive (cast MaybePrimitiveExpr (:body this))))
    )
)

(class-ns RecurParser
    (defn #_"IParser" RecurParser'new []
        (reify IParser
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref)
                      #_"ISeq" form (cast ISeq frm)
                      #_"IPersistentVector" loopLocals (cast IPersistentVector (.deref Compiler'LOOP_LOCALS))]
                    (when-not (and (= context :Context'RETURN) (some? loopLocals))
                        (throw (UnsupportedOperationException. "Can only recur from tail position"))
                    )
                    (when (some? (.deref Compiler'NO_RECUR))
                        (throw (UnsupportedOperationException. "Cannot recur across try"))
                    )
                    (let [#_"PersistentVector" args
                            (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'seq (.next form))]
                                             (some? s)
                                             [(.cons args, (Compiler'analyze-2 :Context'EXPRESSION, (.first s))) (.next s)]
                                          => args
                            )]
                        (when-not (= (.count args) (.count loopLocals))
                            (throw (IllegalArgumentException. (str "Mismatched argument count to recur, expected: " (.count loopLocals) " args, got: " (.count args))))
                        )
                        (dotimes [#_"int" i (.count loopLocals)]
                            (let [#_"LocalBinding" lb (cast LocalBinding (.nth loopLocals, i))]
                                (when-let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                                    (let [#_"Class" pc (Compiler'maybePrimitiveType (cast Expr (.nth args, i)))
                                          #_"boolean" mismatch?
                                            (condp = primc
                                                Long/TYPE   (not (any = pc Long/TYPE Integer/TYPE Short/TYPE Character/TYPE Byte/TYPE))
                                                Double/TYPE (not (any = pc Double/TYPE Float/TYPE))
                                                            false
                                            )]
                                        (when mismatch?
                                            (ร ass (:recurMistmatch lb) true)
                                            (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                                                (.println (RT'errPrintWriter), (str "line " line ": recur arg for primitive local: " (:name lb) " is not matching primitive, had: " (if (some? pc) (.getName pc) "Object") ", needed: " (.getName primc)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (RecurExpr'new loopLocals, args, line, column)
                    )
                )
            )
        )
    )
)

(class-ns RecurExpr
    (defn- #_"RecurExpr" RecurExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"IPersistentVector" :loopLocals nil

            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"RecurExpr" RecurExpr'new [#_"IPersistentVector" loopLocals, #_"IPersistentVector" args, #_"int" line, #_"int" column]
        (let [this (RecurExpr'init)]
            (assoc this :loopLocals loopLocals :args args :line line :column column)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--RecurExpr [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_override
    (defn #_"void" Expr'''emit--RecurExpr [#_"RecurExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let-when [#_"Label" loopLabel (cast Label (.deref Compiler'LOOP_LABEL))] (some? loopLabel) => (throw (IllegalStateException.))
            (dotimes [#_"int" i (.count (:loopLocals this))]
                (let [#_"LocalBinding" lb (cast LocalBinding (.nth (:loopLocals this), i)) #_"Expr" arg (cast Expr (.nth (:args this), i))]
                    (when (some? (LocalBinding''getPrimitiveType lb)) => (.emit arg, :Context'EXPRESSION, objx, gen)
                        (let [#_"Class" primc (LocalBinding''getPrimitiveType lb) #_"Class" pc (Compiler'maybePrimitiveType arg)]
                            (cond (= primc pc)
                                (do
                                    (.emitUnboxed (cast MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                )
                                (and (= primc Long/TYPE) (= pc Integer/TYPE))
                                (do
                                    (.emitUnboxed (cast MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/I2L)
                                )
                                (and (= primc Double/TYPE) (= pc Float/TYPE))
                                (do
                                    (.emitUnboxed (cast MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/F2D)
                                )
                                (and (= primc Integer/TYPE) (= pc Long/TYPE))
                                (do
                                    (.emitUnboxed (cast MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                                )
                                (and (= primc Float/TYPE) (= pc Double/TYPE))
                                (do
                                    (.emitUnboxed (cast MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/D2F)
                                )
                                :else
                                (do
                                    (throw (IllegalArgumentException. (str "recur arg for primitive local: " (:name lb) " is not matching primitive, had: " (if (.hasJavaClass arg) (.getName (.getJavaClass arg)) "Object") ", needed: " (.getName primc))))
                                )
                            )
                        )
                    )
                )
            )
            (loop-when-recur [#_"int" i (dec (.count (:loopLocals this)))] (<= 0 i) [(dec i)]
                (let [#_"LocalBinding" lb (cast LocalBinding (.nth (:loopLocals this), i)) #_"Class" primc (LocalBinding''getPrimitiveType lb)]
                    (if (:isArg lb)
                        (.storeArg gen, (- (:idx lb) (if (:canBeDirect objx) 0 1)))
                        (.visitVarInsn gen, (.getOpcode (if (some? primc) (Type/getType primc) Compiler'OBJECT_TYPE), Opcodes/ISTORE), (:idx lb))
                    )
                )
            )
            (.goTo gen, loopLabel)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--RecurExpr [#_"RecurExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--RecurExpr [#_"RecurExpr" this]
        Recur
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--RecurExpr [#_"RecurExpr" this]
        true
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--RecurExpr [#_"RecurExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit this, context, objx, gen)
        nil
    )
)

(class-ns CompilerException
    (defn- #_"CompilerException" CompilerException'init []
        (hash-map
            #_"int" :line 0
        )
    )

    (defn #_"CompilerException" CompilerException'new [#_"int" line, #_"int" column, #_"Throwable" cause]
        (let [this (merge (ยง foreign RuntimeException'new (str cause ", compiling at (" line ":" column ")"), cause) (CompilerException'init))]
            (assoc this :line line)
        )
    )

    #_foreign
    (defn #_"String" toString---CompilerException [#_"CompilerException" this]
        (.getMessage this)
    )
)

(class-ns DeftypeParser
    (defn #_"IParser" DeftypeParser'new []
        (reify IParser
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (let [#_"ISeq" s (cast ISeq form)                                      s (RT'next s)
                      #_"String" tagname (.getName (cast Symbol (.first s)))           s (.next s)
                      #_"Symbol" classname (cast Symbol (.first s))                    s (.next s)
                      #_"IPersistentVector" fields (cast IPersistentVector (.first s)) s (.next s)
                      [#_"IPersistentMap" opts s]
                        (loop-when-recur [opts PersistentHashMap'EMPTY s s]
                                         (and (some? s) (instance? Keyword (.first s)))
                                         [(.assoc opts, (.first s), (RT'second s)) (.next (.next s))]
                                      => [opts s]
                        )]
                    (NewInstanceExpr'build (cast IPersistentVector (RT'get-3 opts, Compiler'implementsKey, PersistentVector'EMPTY)), fields, nil, tagname, classname, (cast Symbol (RT'get-2 opts, RT'TAG_KEY)), s, form, opts)
                )
            )
        )
    )
)

(class-ns ReifyParser
    (defn #_"IParser" ReifyParser'new []
        (reify IParser
            ;; (reify this-name? [interfaces] (method-name [args] body)*)
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" form]
                (let [#_"ISeq" s (cast ISeq form)
                      #_"ObjMethod" owner (cast ObjMethod (.deref Compiler'METHOD))
                      #_"String" basename (if (some? owner) (ObjExpr'trimGenID (:name (:objx owner))) (Compiler'munge (:name (:name (Compiler'currentNS)))))
                      #_"String" classname (str basename "$" "reify__" (RT'nextID))
                      s (RT'next s)
                      #_"IPersistentVector" ifaces (.cons (cast IPersistentVector (RT'first s)), (Symbol'intern "cloiure.lang.IObj"))
                      s (RT'next s)
                      #_"ObjExpr" ret (NewInstanceExpr'build ifaces, nil, nil, classname, (Symbol'intern classname), nil, s, form, nil)]
                    (when (and (instance? IObj form) (some? (.meta (cast IObj form)))) => ret
                        (MetaExpr'new ret, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast IObj form))))
                    )
                )
            )
        )
    )
)

(class-ns NewInstanceExpr
    (defn- #_"NewInstanceExpr" NewInstanceExpr'init []
        (hash-map
            #_"IPersistentCollection" :methods nil

            #_"Map<IPersistentVector, java.lang.reflect.Method>" :mmap nil
            #_"Map<IPersistentVector, Set<Class>>" :covariants nil
        )
    )

    (defn #_"NewInstanceExpr" NewInstanceExpr'new [#_"Object" tag]
        (merge (ObjExpr'new tag) (NewInstanceExpr'init))
    )

    (defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" interfaceSyms, #_"IPersistentVector" fieldSyms, #_"Symbol" thisSym, #_"String" tagName, #_"Symbol" className, #_"Symbol" typeTag, #_"ISeq" methodForms, #_"Object" frm, #_"IPersistentMap" opts]
        (let [#_"NewInstanceExpr" ret (NewInstanceExpr'new nil)
              ret (assoc ret :src frm)
              ret (assoc ret :name (.toString className))
              ret (assoc ret :classMeta (RT'meta className))
              ret (assoc ret :internalName (.replace (:name ret), \., \/))
              ret (assoc ret :objtype (Type/getObjectType (:internalName ret)))
              ret (assoc ret :opts opts)
              ret (if (some? thisSym) (assoc ret :thisName (:name thisSym)) ret)
              ret
                (when (some? fieldSyms) => ret
                    (let [#_"Object[]" a (make-array Object (* 2 (.count fieldSyms)))
                          #_"IPersistentMap" fmap
                            (loop-when [fmap PersistentHashMap'EMPTY #_"int" i 0] (< i (.count fieldSyms)) => fmap
                                (let [#_"Symbol" sym (cast Symbol (.nth fieldSyms, i))
                                      #_"LocalBinding" lb (LocalBinding'new -1, sym, nil, (MethodParamExpr'new (Compiler'tagClass (Compiler'tagOf sym))), false, nil)]
                                    (aset a (* i 2) lb)
                                    (aset a (inc (* i 2)) lb)
                                    (recur (.assoc fmap, sym, lb) (inc i))
                                )
                            )
                          ;; todo - inject __meta et al into closes - when?
                          ;; use array map to preserve ctor order
                          ret (assoc ret :closes (PersistentArrayMap'new-1 a))
                          ret (assoc ret :fields fmap)]
                        (loop-when-recur [ret ret #_"int" i (dec (.count fieldSyms))]
                                         (and (<= 0 i) (any = (:name (cast Symbol (.nth fieldSyms, i))) "__meta" "__extmap" "__hash" "__hasheq"))
                                         [(update ret :altCtorDrops inc) (dec i)]
                                      => ret
                        )
                    )
                )
              #_"PersistentVector" ifaces
                (loop-when [ifaces PersistentVector'EMPTY #_"ISeq" s (RT'seq interfaceSyms)] (some? s) => ifaces
                    (let [#_"Class" c (cast Class (Compiler'resolve-1 (cast Symbol (.first s))))]
                        (when (.isInterface c) => (throw (IllegalArgumentException. (str "only interfaces are supported, had: " (.getName c))))
                            (recur (.cons ifaces, c) (.next s))
                        )
                    )
                )
              #_"Class" superClass Object
              #_"Map[]" mc (NewInstanceExpr'gatherMethods-2s superClass, (RT'seq ifaces))
              #_"Map" overrideables (aget mc 0) #_"Map" covariants (aget mc 1)
              ret (assoc ret :mmap overrideables)
              ret (assoc ret :covariants covariants)
              #_"String[]" inames (NewInstanceExpr'interfaceNames ifaces)
              #_"Class" stub (NewInstanceExpr'compileStub (NewInstanceExpr'slashname superClass), ret, inames, frm)
              #_"Symbol" thistag (Symbol'intern nil, (.getName stub))
              ret
                (try
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            Compiler'CONSTANTS          PersistentVector'EMPTY
                            Compiler'CONSTANT_IDS       (IdentityHashMap.)
                            Compiler'KEYWORDS           PersistentHashMap'EMPTY
                            Compiler'VARS               PersistentHashMap'EMPTY
                            Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                            Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                            Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                            Compiler'NO_RECUR           nil
                        ])
                    ))
                    (let [ret
                            (when (ObjExpr''isDeftype ret) => ret
                                (Var'pushThreadBindings (RT'mapUniqueKeys
                                    (object-array [
                                        Compiler'METHOD             nil
                                        Compiler'LOCAL_ENV          (:fields ret)
                                        Compiler'COMPILE_STUB_SYM   (Symbol'intern nil, tagName)
                                        Compiler'COMPILE_STUB_CLASS stub
                                    ])
                                ))
                                (assoc ret :hintedFields (RT'subvec fieldSyms, 0, (- (.count fieldSyms) (:altCtorDrops ret))))
                            )
                          ;; now (methodname [args] body)*
                          ret (assoc ret :line (Compiler'lineDeref) :column (Compiler'columnDeref))
                          #_"IPersistentCollection" methods
                            (loop-when [methods nil #_"ISeq" s methodForms] (some? s) => methods
                                (let [#_"NewInstanceMethod" m (NewInstanceMethod'parse ret, (cast ISeq (RT'first s)), thistag, overrideables)]
                                    (recur (RT'conj methods, m) (RT'next s))
                                )
                            )]
                        (assoc ret
                            :methods methods
                            :keywords (cast IPersistentMap (.deref Compiler'KEYWORDS))
                            :vars (cast IPersistentMap (.deref Compiler'VARS))
                            :constants (cast PersistentVector (.deref Compiler'CONSTANTS))
                            :constantsID (RT'nextID)
                            :keywordCallsites (cast IPersistentVector (.deref Compiler'KEYWORD_CALLSITES))
                            :protocolCallsites (cast IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES))
                            :varCallsites (cast IPersistentSet (.deref Compiler'VAR_CALLSITES))
                        )
                    )
                    (finally
                        (when (ObjExpr''isDeftype ret)
                            (Var'popThreadBindings)
                        )
                        (Var'popThreadBindings)
                    )
                )]
            (ObjExpr''compile ret, (NewInstanceExpr'slashname superClass), inames, false)
            (ObjExpr''getCompiledClass ret)
            ret
        )
    )

    ;;;
     ; Current host interop uses reflection, which requires pre-existing classes.
     ; Work around this by:
     ; Generate a stub class that has the same interfaces and fields as the class we are generating.
     ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc.)
     ; Unmunge the name (using a magic prefix) on any code gen for classes.
     ;;
    (defn #_"Class" NewInstanceExpr'compileStub [#_"String" superName, #_"NewInstanceExpr" ret, #_"String[]" interfaceNames, #_"Object" frm]
        (let [#_"ClassWriter" cw (ClassWriter. ClassWriter/COMPUTE_MAXS) #_"ClassVisitor" cv cw]
            (.visit cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER), (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret)), nil, superName, interfaceNames)

            ;; instance fields for closed-overs
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes ret))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast LocalBinding (.first s))
                      #_"int" access (+ Opcodes/ACC_PUBLIC (if (ObjExpr''isVolatile ret, lb) Opcodes/ACC_VOLATILE (if (ObjExpr''isMutable ret, lb) 0 Opcodes/ACC_FINAL)))]
                    (if (some? (LocalBinding''getPrimitiveType lb))
                        (.visitField cv, access, (:name lb), (.getDescriptor (Type/getType (LocalBinding''getPrimitiveType lb))), nil, nil)
                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                        (.visitField cv, access, (:name lb), (.getDescriptor Compiler'OBJECT_TYPE), nil, nil)
                    )
                )
            )

            ;; ctor that takes closed-overs and does nothing
            (let [#_"Method" m (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes ret))
                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, nil, cv)]
                (.visitCode ctorgen)
                (.loadThis ctorgen)
                (.invokeConstructor ctorgen, (Type/getObjectType superName), ObjExpr'voidctor)
                (.returnValue ctorgen)
                (.endMethod ctorgen)
            )

            (when (pos? (:altCtorDrops ret))
                (let [#_"Type[]" ctorTypes (ObjExpr''ctorTypes ret)]

                    (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) (:altCtorDrops ret)))
                          _ (dotimes [#_"int" i (alength altCtorTypes)]
                                (aset altCtorTypes i (aget ctorTypes i))
                            )
                          #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                          #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                        (.visitCode ctorgen)
                        (.loadThis ctorgen)
                        (.loadArgs ctorgen)

                        (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __meta
                        (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                        (.invokeConstructor ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret))), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                        (.returnValue ctorgen)
                        (.endMethod ctorgen)
                    )

                    ;; alt ctor no __hash, __hasheq
                    (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) 2))
                          _ (dotimes [#_"int" i (alength altCtorTypes)]
                                (aset altCtorTypes i (aget ctorTypes i))
                            )
                          #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                          #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                        (.visitCode ctorgen)
                        (.loadThis ctorgen)
                        (.loadArgs ctorgen)

                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                        (.invokeConstructor ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret))), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                        (.returnValue ctorgen)
                        (.endMethod ctorgen)
                    )
                )
            )

            ;; end of class
            (.visitEnd cv)

            (let [#_"byte[]" bytecode (.toByteArray cw)
                  #_"DynamicClassLoader" loader (cast DynamicClassLoader (.deref Compiler'LOADER))]
                (.defineClass loader, (str Compiler'COMPILE_STUB_PREFIX "." (:name ret)), bytecode, frm)
            )
        )
    )

    (defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" interfaces]
        (let [#_"int" n (.count interfaces)
              #_"String[]" inames (when (pos? n) (make-array String n))]
            (dotimes [#_"int" i n]
                (aset inames i (NewInstanceExpr'slashname (cast Class (.nth interfaces, i))))
            )
            inames
        )
    )

    (defn #_"String" NewInstanceExpr'slashname [#_"Class" c]
        (.replace (.getName c), \., \/)
    )

    #_override
    (defn #_"void" ObjExpr'''emitStatics--NewInstanceExpr [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
        (when (ObjExpr''isDeftype this)
            ;; getBasis()
            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IPersistentVector getBasis()")
                  #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), meth, nil, nil, cv)]
                (ObjExpr''emitValue this, (:hintedFields this), gen)
                (.returnValue gen)
                (.endMethod gen)

                (let-when [#_"int" n (.count (:hintedFields this))] (< n (.count (:fields this)))
                    ;; create(IPersistentMap)
                    (let [#_"String" className (.replace (:name this), \., \/)
                          #_"MethodVisitor" mv (.visitMethod cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), "create", (str "(Lcloiure/lang/IPersistentMap;)L" className ";"), nil, nil)]
                        (.visitCode mv)

                        (loop-when-recur [#_"ISeq" s (RT'seq (:hintedFields this)) #_"int" i 1] (some? s) [(.next s) (inc i)]
                            (let [#_"String" bName (:name (cast Symbol (.first s)))
                                  #_"Class" k (Compiler'tagClass (Compiler'tagOf (.first s)))]
                                (.visitVarInsn mv, Opcodes/ALOAD, 0)
                                (.visitLdcInsn mv, bName)
                                (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                (.visitInsn mv, Opcodes/ACONST_NULL)
                                (.visitMethodInsn mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                                (when (.isPrimitive k)
                                    (.visitTypeInsn mv, Opcodes/CHECKCAST, (.getInternalName (Type/getType (Compiler'boxClass k))))
                                )
                                (.visitVarInsn mv, Opcodes/ASTORE, i)
                                (.visitVarInsn mv, Opcodes/ALOAD, 0)
                                (.visitLdcInsn mv, bName)
                                (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                (.visitMethodInsn mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                                (.visitVarInsn mv, Opcodes/ASTORE, 0)
                            )
                        )

                        (.visitTypeInsn mv, Opcodes/NEW, className)
                        (.visitInsn mv, Opcodes/DUP)

                        (let [#_"Method" ctor (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes this))]
                            (dotimes [#_"int" i n]
                                (.visitVarInsn mv, Opcodes/ALOAD, (inc i))
                                (let-when [#_"Class" k (Compiler'tagClass (Compiler'tagOf (.nth (:hintedFields this), i)))] (.isPrimitive k)
                                    (.visitMethodInsn mv, Opcodes/INVOKEVIRTUAL, (.getInternalName (Type/getType (Compiler'boxClass k))), (str (.getName k) "Value"), (str "()" (.getDescriptor (Type/getType k))))
                                )
                            )

                            (.visitInsn mv, Opcodes/ACONST_NULL) ;; __meta
                            (.visitVarInsn mv, Opcodes/ALOAD, 0) ;; __extmap
                            (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                            (.visitInsn mv, Opcodes/ICONST_0) ;; __hash
                            (.visitInsn mv, Opcodes/ICONST_0) ;; __hasheq
                            (.visitMethodInsn mv, Opcodes/INVOKESPECIAL, className, "<init>", (.getDescriptor ctor))
                            (.visitInsn mv, Opcodes/ARETURN)
                            (.visitMaxs mv, (+ 4 n), (+ 1 n))
                            (.visitEnd mv)
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"void" ObjExpr'''emitMethods--NewInstanceExpr [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
        (loop-when-recur [#_"ISeq" s (RT'seq (:methods this))] (some? s) [(.next s)]
            (.emit (cast ObjMethod (.first s)), this, cv)
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" e (.entrySet (:covariants this))]
            (let [#_"java.lang.reflect.Method" m (.get (:mmap this), (.getKey e))
                  #_"Class[]" params (.getParameterTypes m)
                  #_"Type[]" argTypes (make-array Type (alength params))
                  _ (dotimes [#_"int" i (alength params)]
                        (aset argTypes i (Type/getType (aget params i)))
                    )
                  #_"Method" target (Method. (.getName m), (Type/getType (.getReturnType m)), argTypes)]
                (doseq [#_"Class" retType (.getValue e)]
                    (let [#_"Method" meth (Method. (.getName m), (Type/getType retType), argTypes)
                          ;; todo don't hardwire EXCEPTION_TYPES
                          #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_BRIDGE), meth, nil, Compiler'EXCEPTION_TYPES, cv)]
                        (.visitCode gen)
                        (.loadThis gen)
                        (.loadArgs gen)
                        (.invokeInterface gen, (Type/getType (.getDeclaringClass m)), target)
                        (.returnValue gen)
                        (.endMethod gen)
                    )
                )
            )
        )
        nil
    )

    (defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" m]
        (RT'vector (.getName m), (RT'seq (.getParameterTypes m)), (.getReturnType m))
    )

    (defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" m, #_"Map" mm]
        (let [#_"IPersistentVector" mk (NewInstanceExpr'msig m) #_"int" mods (.getModifiers m)]
            (when (not (or (.containsKey mm, mk) (not (or (Modifier/isPublic mods) (Modifier/isProtected mods))) (Modifier/isStatic mods) (Modifier/isFinal mods)))
                (.put mm, mk, m)
            )
        )
        nil
    )

    (defn #_"void" NewInstanceExpr'gatherMethods-2m [#_"Class" c, #_"Map" mm]
        (loop-when-recur [c c] (some? c) [(.getSuperclass c)]
            (doseq [#_"java.lang.reflect.Method" m (.getDeclaredMethods c)]
                (NewInstanceExpr'considerMethod m, mm)
            )
            (doseq [#_"java.lang.reflect.Method" m (.getMethods c)]
                (NewInstanceExpr'considerMethod m, mm)
            )
        )
        nil
    )

    (defn #_"Map[]" NewInstanceExpr'gatherMethods-2s [#_"Class" sc, #_"ISeq" ifaces]
        (let [#_"Map" allm (HashMap.)
              _ (NewInstanceExpr'gatherMethods-2m sc, allm)
              _ (loop-when-recur ifaces (some? ifaces) [(.next ifaces)]
                    (NewInstanceExpr'gatherMethods-2m (cast Class (.first ifaces)), allm)
                )
              #_"Map<IPersistentVector, java.lang.reflect.Method>" methods (HashMap.)
              #_"Map<IPersistentVector, Set<Class>>" covariants (HashMap.)]
            (loop-when-recur [#_"Iterator" it (.iterator (.entrySet allm))] (.hasNext it) [it]
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))
                      #_"IPersistentVector" mk (cast IPersistentVector (.pop (cast IPersistentVector (.getKey e))))
                      #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                    (if (.containsKey methods, mk) ;; covariant return
                        (let [#_"Set<Class>" cvs
                                (or (.get covariants, mk)
                                    (let [cvs (HashSet.)]
                                        (.put covariants, mk, cvs)
                                        cvs
                                    )
                                )
                              #_"Class" tk (.getReturnType (.get methods, mk)) #_"Class" t (.getReturnType m)]
                            (when (.isAssignableFrom tk, t) => (.add cvs, t)
                                (.add cvs, tk)
                                (.put methods, mk, m)
                            )
                        )
                        (.put methods, mk, m)
                    )
                )
            )
            (ร new Map[] (object-array [ methods, covariants ]))
        )
    )
)

(class-ns NewInstanceMethod
    (ยง def #_"Symbol" NewInstanceMethod'dummyThis (Symbol'intern nil, "dummy_this_dlskjsdfower"))

    (defn- #_"NewInstanceMethod" NewInstanceMethod'init []
        (hash-map
            #_"String" :name nil
            #_"Type[]" :argTypes nil
            #_"Type" :retType nil
            #_"Class" :retClass nil
            #_"Class[]" :exclasses nil

            #_"IPersistentVector" :parms nil
        )
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (merge (ObjMethod'new objx, parent) (NewInstanceMethod'init))
    )

    #_override
    (defn #_"int" ObjMethod'''numParams--NewInstanceMethod [#_"NewInstanceMethod" this]
        (.count (:argLocals this))
    )

    #_override
    (defn #_"String" ObjMethod'''getMethodName--NewInstanceMethod [#_"NewInstanceMethod" this]
        (:name this)
    )

    #_override
    (defn #_"Type" ObjMethod'''getReturnType--NewInstanceMethod [#_"NewInstanceMethod" this]
        (:retType this)
    )

    #_override
    (defn #_"Type[]" ObjMethod'''getArgTypes--NewInstanceMethod [#_"NewInstanceMethod" this]
        (:argTypes this)
    )

    (defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" name, #_"Class[]" paramTypes]
        (RT'vector name, (RT'seq paramTypes))
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Symbol" thistag, #_"Map" overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" method (NewInstanceMethod'new objx, (cast ObjMethod (.deref Compiler'METHOD)))
              #_"Symbol" dotname (cast Symbol (RT'first form))
              #_"Symbol" name (cast Symbol (.withMeta (Symbol'intern nil, (Compiler'munge (:name dotname))), (RT'meta dotname)))
              #_"IPersistentVector" parms (cast IPersistentVector (RT'second form))]
            (when (pos? (.count parms)) => (throw (IllegalArgumentException. (str "Must supply at least one argument for 'this' in: " dotname)))
                (let [#_"Symbol" thisName (cast Symbol (.nth parms, 0))
                      parms (RT'subvec parms, 1, (.count parms))
                      #_"ISeq" body (RT'next (RT'next form))]
                    (try
                        (let [method (assoc method :line (Compiler'lineDeref) :column (Compiler'columnDeref))
                              ;; register as the current method and set up a new env frame
                              #_"PathNode" pnode (PathNode'new :PathType'PATH, (cast PathNode (Var''get Compiler'CLEAR_PATH)))]
                            (Var'pushThreadBindings (RT'mapUniqueKeys
                                (object-array [
                                    Compiler'METHOD                method
                                    Compiler'LOCAL_ENV             (.deref Compiler'LOCAL_ENV)
                                    Compiler'LOOP_LOCALS           nil
                                    Compiler'NEXT_LOCAL_NUM        0
                                    Compiler'CLEAR_PATH            pnode
                                    Compiler'CLEAR_ROOT            pnode
                                    Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                    Compiler'METHOD_RETURN_CONTEXT RT'T
                                ])
                            ))
                            ;; register 'this' as local 0
                            (if (some? thisName)
                                (Compiler'registerLocal (or thisName NewInstanceMethod'dummyThis), thistag, nil, false)
                                (Compiler'getAndIncLocalNum)
                            )
                            (let [method (assoc method :retClass (Compiler'tagClass (Compiler'tagOf name)))
                                  method (assoc method :argTypes (make-array Type (.count parms)))
                                  #_"Class[]" pclasses (make-array Class (.count parms))
                                  #_"Symbol[]" psyms (make-array #_"Symbol" Object (.count parms))
                                  #_"boolean" hinted
                                    (loop-when [hinted (some? (Compiler'tagOf name)) #_"int" i 0] (< i (.count parms)) => hinted
                                        (when (instance? Symbol (.nth parms, i)) => (throw (IllegalArgumentException. "params must be Symbols"))
                                            (let [#_"Symbol" p (cast Symbol (.nth parms, i))
                                                  #_"Object" tag (Compiler'tagOf p)
                                                  hinted (or hinted (some? tag))
                                                  p (if (some? (.getNamespace p)) (Symbol'intern (:name p)) p)]
                                                (aset pclasses i (Compiler'tagClass tag))
                                                (aset psyms i p)
                                                (recur hinted (inc i))
                                            )
                                        )
                                    )
                                  #_"Map" matches (NewInstanceMethod'findMethodsWithNameAndArity (:name name), (.count parms), overrideables)
                                  #_"Object" mk (NewInstanceMethod'msig (:name name), pclasses)
                                  [method pclasses #_"java.lang.reflect.Method" m]
                                    (case (.size matches)
                                        0   (throw (IllegalArgumentException. (str "Can't define method not in interfaces: " (:name name))))
                                        1   (if hinted ;; validate match
                                                (let [m (cast java.lang.reflect.Method (.get matches, mk))]
                                                    (when (nil? m)
                                                        (throw (IllegalArgumentException. (str "Can't find matching method: " (:name name) ", leave off hints for auto match.")))
                                                    )
                                                    (when-not (= (.getReturnType m) (:retClass method))
                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name name) ", expected: " (.getName (.getReturnType m)) ", had: " (.getName (:retClass method)))))
                                                    )
                                                    [method pclasses m]
                                                )
                                                ;; adopt found method sig
                                                (let [m (cast java.lang.reflect.Method (.next (.iterator (.values matches))))]
                                                    [(assoc method :retClass (.getReturnType m)) (.getParameterTypes m) m]
                                                )
                                            )
                                            ;; must be hinted and match one method
                                            (when hinted => (throw (IllegalArgumentException. (str "Must hint overloaded method: " (:name name))))
                                                (let [m (cast java.lang.reflect.Method (.get matches, mk))]
                                                    (when (nil? m)
                                                        (throw (IllegalArgumentException. (str "Can't find matching overloaded method: " (:name name))))
                                                    )
                                                    (when-not (= (.getReturnType m) (:retClass method))
                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name name) ", expected: " (.getName (.getReturnType m)) ", had: " (.getName (:retClass method)))))
                                                    )
                                                    [method pclasses m]
                                                )
                                            )
                                    )
                                  ;; validate unque name+arity among additional methods
                                  method (assoc method :retType (Type/getType (:retClass method)))
                                  method (assoc method :exclasses (.getExceptionTypes m))
                                  #_"PersistentVector" argLocals
                                    (loop-when [argLocals PersistentVector'EMPTY #_"int" i 0] (< i (.count parms)) => argLocals
                                        (let [#_"LocalBinding" lb (Compiler'registerLocal (aget psyms i), nil, (MethodParamExpr'new (aget pclasses i)), true)]
                                            (aset (:argTypes method) i (Type/getType (aget pclasses i)))
                                            (recur (.assocN argLocals, i, lb) (inc i))
                                        )
                                    )]
                                (dotimes [#_"int" i (.count parms)]
                                    (when (any = (aget pclasses i) Long/TYPE Double/TYPE)
                                        (Compiler'getAndIncLocalNum)
                                    )
                                )
                                (Var''set Compiler'LOOP_LOCALS, argLocals)
                                (assoc method
                                    :name (:name name)
                                    :methodMeta (RT'meta name)
                                    :parms parms
                                    :argLocals argLocals
                                    :body (.parse (BodyParser'new), :Context'RETURN, body)
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" name, #_"int" arity, #_"Map" mm]
        (let [#_"Map" found (HashMap.)]
            (doseq [#_"Object" o (.entrySet mm)]
                (let [#_"Map$Entry" e (cast Map$Entry o)
                      #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                    (when (and (= name (.getName m)) (= (alength (.getParameterTypes m)) arity))
                        (.put found, (.getKey e), (.getValue e))
                    )
                )
            )
            found
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" name, #_"Map" mm]
        (let [#_"Map" found (HashMap.)]
            (doseq [#_"Object" o (.entrySet mm)]
                (let [#_"Map$Entry" e (cast Map$Entry o)
                      #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                    (when (= name (.getName m))
                        (.put found, (.getKey e), (.getValue e))
                    )
                )
            )
            found
        )
    )

    #_override
    (defn #_"void" Expr'''emit--NewInstanceMethod [#_"NewInstanceMethod" this, #_"ObjExpr" obj, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))
              #_"Type[]" extypes
                (let-when [#_"int" n (alength (:exclasses this))] (pos? n)
                    (let [extypes (make-array Type n)]
                        (dotimes [#_"int" i n]
                            (aset extypes i (Type/getType (aget (:exclasses this) i)))
                        )
                        extypes
                    )
                )
              #_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, extypes, cv)]
            (.visitCode gen)

            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map Compiler'LOOP_LABEL, loopLabel, Compiler'METHOD, this))

                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))
                    (let [#_"Label" end (.mark gen)]
                        (.visitLocalVariable gen, "this", (.getDescriptor (:objtype obj)), nil, loopLabel, end, 0)
                        (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argTypes this) (dec (:idx lb)))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )

                (.returnValue gen)
                (.endMethod gen)
            )
        )
        nil
    )
)

(class-ns MethodParamExpr
    (defn- #_"MethodParamExpr" MethodParamExpr'init []
        (hash-map
            #_"Class" :c nil
        )
    )

    (defn #_"MethodParamExpr" MethodParamExpr'new [#_"Class" c]
        (let [this (MethodParamExpr'init)]
            (assoc this :c c)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MethodParamExpr [#_"MethodParamExpr" this]
        (throw (RuntimeException. "Can't eval"))
    )

    #_override
    (defn #_"void" Expr'''emit--MethodParamExpr [#_"MethodParamExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (throw (RuntimeException. "Can't emit"))
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--MethodParamExpr [#_"MethodParamExpr" this]
        (some? (:c this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--MethodParamExpr [#_"MethodParamExpr" this]
        (:c this)
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--MethodParamExpr [#_"MethodParamExpr" this]
        (Util'isPrimitive (:c this))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--MethodParamExpr [#_"MethodParamExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (throw (RuntimeException. "Can't emit"))
    )
)

(class-ns CaseParser
    (defn #_"IParser" CaseParser'new []
        (reify IParser
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            #_override
            (#_"Expr" parse [#_"IParser" _self, #_"Context" context, #_"Object" frm]
                (let [#_"ISeq" form (cast ISeq frm)]
                    (if (= context :Context'EVAL)
                        (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                        (let [#_"IPersistentVector" args (LazilyPersistentVector'create (.next form))
                              #_"Object" exprForm (.nth args, 0)
                              #_"int" shift (.intValue (cast Number (.nth args, 1)))
                              #_"int" mask (.intValue (cast Number (.nth args, 2)))
                              #_"Object" defaultForm (.nth args, 3)
                              #_"Map" caseMap (cast Map (.nth args, 4))
                              #_"Keyword" switchType (cast Keyword (.nth args, 5))
                              #_"Keyword" testType (cast Keyword (.nth args, 6))
                              #_"Set" skipCheck (when (< 7 (RT'count args)) (cast Set (.nth args, 7)))
                              #_"ISeq" keys (RT'keys caseMap)
                              #_"int" low (.intValue (cast Number (RT'first keys)))
                              #_"int" high (.intValue (cast Number (RT'nth-2 keys, (dec (RT'count keys)))))
                              #_"LocalBindingExpr" testexpr (cast LocalBindingExpr (Compiler'analyze-2 :Context'EXPRESSION, exprForm))
                              testexpr (assoc testexpr :shouldClear false)
                              #_"SortedMap<Integer, Expr>" tests (TreeMap.)
                              #_"HashMap<Integer, Expr>" thens (HashMap.)
                              #_"PathNode" branch (PathNode'new :PathType'BRANCH, (cast PathNode (Var''get Compiler'CLEAR_PATH)))
                              _ (doseq [#_"Object" o (.entrySet caseMap)]
                                    (let [#_"Map$Entry" e (cast Map$Entry o)
                                          #_"Integer" minhash (.intValue (cast Number (.getKey e)))
                                          #_"Object" pair (.getValue e) ;; [test-val then-expr]
                                          #_"Expr" testExpr
                                            (if (= testType CaseExpr'intKey)
                                                (NumberExpr'parse (.intValue (cast Number (RT'first pair))))
                                                (ConstantExpr'new (RT'first pair))
                                            )]
                                        (.put tests, minhash, testExpr)
                                        (let [#_"Expr" thenExpr
                                                (try
                                                    (Var'pushThreadBindings (RT'map Compiler'CLEAR_PATH, (PathNode'new :PathType'PATH, branch)))
                                                    (Compiler'analyze-2 context, (RT'second pair))
                                                    (finally
                                                        (Var'popThreadBindings)
                                                    )
                                                )]
                                            (.put thens, minhash, thenExpr)
                                        )
                                    )
                                )
                              #_"Expr" defaultExpr
                                (try
                                    (Var'pushThreadBindings (RT'map Compiler'CLEAR_PATH, (PathNode'new :PathType'PATH, branch)))
                                    (Compiler'analyze-2 context, (.nth args, 3))
                                    (finally
                                        (Var'popThreadBindings)
                                    )
                                )
                              #_"int" line (.intValue (cast Number (.deref Compiler'LINE)))
                              #_"int" column (.intValue (cast Number (.deref Compiler'COLUMN)))]
                            (CaseExpr'new line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck)
                        )
                    )
                )
            )
        )
    )
)

(class-ns CaseExpr
    (def #_"Type" CaseExpr'NUMBER_TYPE (Type/getType Number))
    (def #_"Method" CaseExpr'intValueMethod (Method/getMethod "int intValue()"))

    (def #_"Method" CaseExpr'hashMethod (Method/getMethod "int hash(Object)"))
    (def #_"Method" CaseExpr'hashCodeMethod (Method/getMethod "int hashCode()"))
    (def #_"Method" CaseExpr'equivMethod (Method/getMethod "boolean equiv(Object, Object)"))
    (ยง def #_"Keyword" CaseExpr'compactKey (Keyword'intern (Symbol'intern nil, "compact")))
    (ยง def #_"Keyword" CaseExpr'sparseKey (Keyword'intern (Symbol'intern nil, "sparse")))
    (ยง def #_"Keyword" CaseExpr'hashIdentityKey (Keyword'intern (Symbol'intern nil, "hash-identity")))
    (ยง def #_"Keyword" CaseExpr'hashEquivKey (Keyword'intern (Symbol'intern nil, "hash-equiv")))
    (ยง def #_"Keyword" CaseExpr'intKey (Keyword'intern (Symbol'intern nil, "int")))

    (defn- #_"CaseExpr" CaseExpr'init []
        (hash-map
            #_"LocalBindingExpr" :expr nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"int" :low 0
            #_"int" :high 0
            #_"Expr" :defaultExpr nil
            #_"SortedMap<Integer, Expr>" :tests nil
            #_"HashMap<Integer, Expr>" :thens nil
            #_"Keyword" :switchType nil
            #_"Keyword" :testType nil
            #_"Set<Integer>" :skipCheck nil
            #_"Class" :returnType nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (defn #_"CaseExpr" CaseExpr'new [#_"int" line, #_"int" column, #_"LocalBindingExpr" expr, #_"int" shift, #_"int" mask, #_"int" low, #_"int" high, #_"Expr" defaultExpr, #_"SortedMap<Integer, Expr>" tests, #_"HashMap<Integer, Expr>" thens, #_"Keyword" switchType, #_"Keyword" testType, #_"Set<Integer>" skipCheck]
        (let [this
                (-> (CaseExpr'init)
                    (assoc :expr expr :shift shift :mask mask :low low :high high :defaultExpr defaultExpr :tests tests :thens thens :line line :column column)
                )
              _ (when-not (any = switchType CaseExpr'compactKey CaseExpr'sparseKey)
                    (throw (IllegalArgumentException. (str "Unexpected switch type: " switchType)))
                )
              this (assoc this :switchType switchType)
              _ (when-not (any = testType CaseExpr'intKey CaseExpr'hashEquivKey CaseExpr'hashIdentityKey)
                    (throw (IllegalArgumentException. (str "Unexpected test type: " switchType)))
                )
              this (assoc this :testType testType)
              this (assoc this :skipCheck skipCheck)
              #_"List<Expr>" returns (ArrayList. (.values thens)) _ (.add returns, defaultExpr)
              this (assoc this :returnType (Compiler'maybeJavaClass returns))]
            (when (and (pos? (RT'count skipCheck)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                (.format (RT'errPrintWriter), "Performance warning, %d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", (object-array [ line, column ]))
            )
            this
        )
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--CaseExpr [#_"CaseExpr" this]
        (some? (:returnType this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--CaseExpr [#_"CaseExpr" this]
        (Util'isPrimitive (:returnType this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--CaseExpr [#_"CaseExpr" this]
        (:returnType this)
    )

    #_override
    (defn #_"Object" Expr'''eval--CaseExpr [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_override
    (defn #_"void" Expr'''emit--CaseExpr [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (CaseExpr''doEmit this, context, objx, gen, false)
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--CaseExpr [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (CaseExpr''doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''doEmit [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"Label" defaultLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)
              #_"SortedMap<Integer, Label>" labels (TreeMap.) _ (doseq [#_"Integer" i (.keySet (:tests this))] (.put labels, i, (.newLabel gen)))]
            (.visitLineNumber gen, (:line this), (.mark gen))
            (let [#_"Class" primExprClass (Compiler'maybePrimitiveType (:expr this))
                  #_"Type" primExprType (when (some? primExprClass) (Type/getType primExprClass))]
                (if (= (:testType this) CaseExpr'intKey)
                    (CaseExpr''emitExprForInts this, objx, gen, primExprType, defaultLabel)
                    (CaseExpr''emitExprForHashes this, objx, gen)
                )
                (if (= (:switchType this) CaseExpr'sparseKey)
                    (let [#_"Label[]" la (make-array Label (.size labels)) la (.toArray (.values labels), la)]
                        (.visitLookupSwitchInsn gen, defaultLabel, (Numbers'int_array-1 (.keySet (:tests this))), la)
                    )
                    (let [#_"Label[]" la (make-array Label (inc (- (:high this) (:low this))))]
                        (loop-when-recur [#_"int" i (:low this)] (<= i (:high this)) [(inc i)]
                            (aset la (- i (:low this)) (if (.containsKey labels, i) (.get labels, i) defaultLabel))
                        )
                        (.visitTableSwitchInsn gen, (:low this), (:high this), defaultLabel, la)
                    )
                )
                (doseq [#_"Integer" i (.keySet labels)]
                    (.mark gen, (.get labels, i))
                    (cond
                        (= (:testType this) CaseExpr'intKey)
                            (CaseExpr''emitThenForInts this, objx, gen, primExprType, (.get (:tests this), i), (.get (:thens this), i), defaultLabel, emitUnboxed)
                        (= (RT'contains (:skipCheck this), i) RT'T)
                            (CaseExpr'emitExpr objx, gen, (.get (:thens this), i), emitUnboxed)
                        :else
                            (CaseExpr''emitThenForHashes this, objx, gen, (.get (:tests this), i), (.get (:thens this), i), defaultLabel, emitUnboxed)
                    )
                    (.goTo gen, endLabel)
                )
                (.mark gen, defaultLabel)
                (CaseExpr'emitExpr objx, gen, (:defaultExpr this), emitUnboxed)
                (.mark gen, endLabel)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"boolean" CaseExpr''isShiftMasked [#_"CaseExpr" this]
        (not= (:mask this) 0)
    )

    #_method
    (defn- #_"void" CaseExpr''emitShiftMask [#_"CaseExpr" this, #_"GeneratorAdapter" gen]
        (when (CaseExpr''isShiftMasked this)
            (.push gen, (:shift this))
            (.visitInsn gen, Opcodes/ISHR)
            (.push gen, (:mask this))
            (.visitInsn gen, Opcodes/IAND)
        )
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitExprForInts [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Label" defaultLabel]
        (cond (nil? exprType)
            (do
                (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                    (.format (RT'errPrintWriter), "Performance warning, %d:%d - case has int tests, but tested expression is not primitive.\n", (object-array [ (:line this), (:column this) ]))
                )
                (.emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.instanceOf gen, CaseExpr'NUMBER_TYPE)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
                (.emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, CaseExpr'NUMBER_TYPE)
                (.invokeVirtual gen, CaseExpr'NUMBER_TYPE, HostExpr'intValueMethod)
                (CaseExpr''emitShiftMask this, gen)
            )
            (or (= exprType Type/LONG_TYPE) (= exprType Type/INT_TYPE) (= exprType Type/SHORT_TYPE) (= exprType Type/BYTE_TYPE))
            (do
                (.emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                (.cast gen, exprType, Type/INT_TYPE)
                (CaseExpr''emitShiftMask this, gen)
            )
            :else
            (do
                (.goTo gen, defaultLabel)
            )
        )
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitThenForInts [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
        (cond (nil? exprType)
            (do
                (.emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.emit test, :Context'EXPRESSION, objx, gen)
                (.invokeStatic gen, Compiler'UTIL_TYPE, CaseExpr'equivMethod)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            (= exprType Type/LONG_TYPE)
            (do
                (.emitUnboxed (cast NumberExpr test), :Context'EXPRESSION, objx, gen)
                (.emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                (.ifCmp gen, Type/LONG_TYPE, GeneratorAdapter/NE, defaultLabel)
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            (or (= exprType Type/INT_TYPE) (= exprType Type/SHORT_TYPE) (= exprType Type/BYTE_TYPE))
            (do
                (when (CaseExpr''isShiftMasked this)
                    (.emitUnboxed (cast NumberExpr test), :Context'EXPRESSION, objx, gen)
                    (.emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                    (.cast gen, exprType, Type/LONG_TYPE)
                    (.ifCmp gen, Type/LONG_TYPE, GeneratorAdapter/NE, defaultLabel)
                )
                ;; else direct match
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            :else
            (do
                (.goTo gen, defaultLabel)
            )
        )
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitExprForHashes [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.invokeStatic gen, Compiler'UTIL_TYPE, CaseExpr'hashMethod)
        (CaseExpr''emitShiftMask this, gen)
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitThenForHashes [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.emit test, :Context'EXPRESSION, objx, gen)
        (if (= (:testType this) CaseExpr'hashIdentityKey)
            (do
                (.visitJumpInsn gen, Opcodes/IF_ACMPNE, defaultLabel)
            )
            (do
                (.invokeStatic gen, Compiler'UTIL_TYPE, CaseExpr'equivMethod)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
            )
        )
        (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
        nil
    )

    (defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" expr, #_"boolean" emitUnboxed]
        (if (and emitUnboxed (instance? MaybePrimitiveExpr expr))
            (.emitUnboxed (cast MaybePrimitiveExpr expr), :Context'EXPRESSION, objx, gen)
            (.emit expr, :Context'EXPRESSION, objx, gen)
        )
        nil
    )
)

(class-ns Compiler
    (ยง def #_"Symbol" Compiler'DEF (Symbol'intern "def"))
    (ยง def #_"Symbol" Compiler'LOOP (Symbol'intern "loop*"))
    (ยง def #_"Symbol" Compiler'RECUR (Symbol'intern "recur"))
    (ยง def #_"Symbol" Compiler'IF (Symbol'intern "if"))
    (ยง def #_"Symbol" Compiler'LET (Symbol'intern "let*"))
    (ยง def #_"Symbol" Compiler'LETFN (Symbol'intern "letfn*"))
    (ยง def #_"Symbol" Compiler'DO (Symbol'intern "do"))
    (ยง def #_"Symbol" Compiler'FN (Symbol'intern "fn*"))
    (ยง def #_"Symbol" Compiler'FNONCE (cast Symbol (.withMeta (Symbol'intern "fn*"), (RT'map (Keyword'intern (Symbol'intern nil, "once")), RT'T))))
    (ยง def #_"Symbol" Compiler'QUOTE (Symbol'intern "quote"))
    (ยง def #_"Symbol" Compiler'THE_VAR (Symbol'intern "var"))
    (ยง def #_"Symbol" Compiler'DOT (Symbol'intern "."))
    (ยง def #_"Symbol" Compiler'ASSIGN (Symbol'intern "set!"))
    (ยง def #_"Symbol" Compiler'TRY (Symbol'intern "try"))
    (ยง def #_"Symbol" Compiler'CATCH (Symbol'intern "catch"))
    (ยง def #_"Symbol" Compiler'FINALLY (Symbol'intern "finally"))
    (ยง def #_"Symbol" Compiler'THROW (Symbol'intern "throw"))
    (ยง def #_"Symbol" Compiler'MONITOR_ENTER (Symbol'intern "monitor-enter"))
    (ยง def #_"Symbol" Compiler'MONITOR_EXIT (Symbol'intern "monitor-exit"))
    (ยง def #_"Symbol" Compiler'IMPORT (Symbol'intern "cloiure.core", "import*"))
    (ยง def #_"Symbol" Compiler'DEFTYPE (Symbol'intern "deftype*"))
    (ยง def #_"Symbol" Compiler'CASE (Symbol'intern "case*"))

    (ยง def #_"Symbol" Compiler'CLASS (Symbol'intern "Class"))
    (ยง def #_"Symbol" Compiler'NEW (Symbol'intern "new"))
    (ยง def #_"Symbol" Compiler'THIS (Symbol'intern "this"))
    (ยง def #_"Symbol" Compiler'REIFY (Symbol'intern "reify*"))
    (ยง def #_"Symbol" Compiler'LIST (Symbol'intern "cloiure.core", "list"))
    (ยง def #_"Symbol" Compiler'HASHMAP (Symbol'intern "cloiure.core", "hash-map"))
    (ยง def #_"Symbol" Compiler'VECTOR (Symbol'intern "cloiure.core", "vector"))
    (ยง def #_"Symbol" Compiler'IDENTITY (Symbol'intern "cloiure.core", "identity"))

    (ยง def #_"Symbol" Compiler'_AMP_ (Symbol'intern "&"))
    (ยง def #_"Symbol" Compiler'ISEQ (Symbol'intern "cloiure.lang.ISeq"))

    (ยง def #_"Keyword" Compiler'loadNs (Keyword'intern (Symbol'intern nil, "load-ns")))
    (ยง def #_"Keyword" Compiler'inlineKey (Keyword'intern (Symbol'intern nil, "inline")))
    (ยง def #_"Keyword" Compiler'inlineAritiesKey (Keyword'intern (Symbol'intern nil, "inline-arities")))

    (ยง def #_"Keyword" Compiler'volatileKey (Keyword'intern (Symbol'intern nil, "volatile")))
    (ยง def #_"Keyword" Compiler'implementsKey (Keyword'intern (Symbol'intern nil, "implements")))
    (def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (ยง def #_"Keyword" Compiler'protocolKey (Keyword'intern (Symbol'intern nil, "protocol")))
    (ยง def #_"Keyword" Compiler'onKey (Keyword'intern (Symbol'intern nil, "on")))
    (ยง def #_"Keyword" Compiler'dynamicKey (Keyword'intern (Symbol'intern "dynamic")))
    (ยง def #_"Keyword" Compiler'redefKey (Keyword'intern (Symbol'intern nil, "redef")))

    (ยง def #_"Symbol" Compiler'NS (Symbol'intern "ns"))
    (ยง def #_"Symbol" Compiler'IN_NS (Symbol'intern "in-ns"))

    (ยง def #_"IPersistentMap" Compiler'specials (PersistentHashMap'create-1a
        (object-array [
            Compiler'DEF           (DefParser'new)
            Compiler'LOOP          (LetParser'new)
            Compiler'RECUR         (RecurParser'new)
            Compiler'IF            (IfParser'new)
            Compiler'CASE          (CaseParser'new)
            Compiler'LET           (LetParser'new)
            Compiler'LETFN         (LetFnParser'new)
            Compiler'DO            (BodyParser'new)
            Compiler'FN            nil
            Compiler'QUOTE         (ConstantParser'new)
            Compiler'THE_VAR       (TheVarParser'new)
            Compiler'IMPORT        (ImportParser'new)
            Compiler'DOT           (HostParser'new)
            Compiler'ASSIGN        (AssignParser'new)
            Compiler'DEFTYPE       (DeftypeParser'new)
            Compiler'REIFY         (ReifyParser'new)
            Compiler'TRY           (TryParser'new)
            Compiler'THROW         (ThrowParser'new)
            Compiler'MONITOR_ENTER (MonitorEnterParser'new)
            Compiler'MONITOR_EXIT  (MonitorExitParser'new)
            Compiler'CATCH         nil
            Compiler'FINALLY       nil
            Compiler'NEW           (NewParser'new)
            Compiler'_AMP_         nil
        ])
    ))

    (def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)

    (def #_"Type" Compiler'CLASS_TYPE (Type/getType Class))
    (def #_"Type" Compiler'OBJECT_TYPE (Type/getType Object))
    (def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (Type/getType Boolean))
    (def #_"Type" Compiler'THROWABLE_TYPE (Type/getType Throwable))

    (def- #_"Type" Compiler'KEYWORD_TYPE (Type/getType Keyword))
    (def- #_"Type" Compiler'VAR_TYPE (Type/getType Var))
    (def- #_"Type" Compiler'SYMBOL_TYPE (Type/getType Symbol))
    (def- #_"Type" Compiler'IFN_TYPE (Type/getType IFn))
    (def- #_"Type" Compiler'AFUNCTION_TYPE (Type/getType AFunction))
    (def- #_"Type" Compiler'RT_TYPE (Type/getType RT))
    (def- #_"Type" Compiler'NUMBERS_TYPE (Type/getType Numbers))

    (def #_"Type" Compiler'NS_TYPE (Type/getType Namespace))
    (def #_"Type" Compiler'UTIL_TYPE (Type/getType Util))
    (def #_"Type" Compiler'REFLECTOR_TYPE (Type/getType Reflector))
    (def #_"Type" Compiler'IPERSISTENTMAP_TYPE (Type/getType IPersistentMap))
    (def #_"Type" Compiler'IOBJ_TYPE (Type/getType IObj))
    (def #_"Type" Compiler'TUPLE_TYPE (Type/getType Tuple))

    (def #_"Method[]" Compiler'createTupleMethods
        (object-array [
            (Method/getMethod "cloiure.lang.IPersistentVector create()")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object, Object)")
        ])
    )

    (def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (def- #_"Type[]" Compiler'EXCEPTION_TYPES (object-array 0))

    (ยง static
        (ร ass Compiler'ARG_TYPES (ร new Type[(+ Compiler'MAX_POSITIONAL_ARITY 2)][]))
        (loop-when-recur [#_"int" i 0] (<= i Compiler'MAX_POSITIONAL_ARITY) [(inc i)]
            (let [#_"Type[]" a (make-array Type i)]
                (loop-when-recur [#_"int" j 0] (< j i) [(inc j)]
                    (aset a j Compiler'OBJECT_TYPE)
                )
                (aset Compiler'ARG_TYPES i a)
            )
        )
        (let [#_"Type[]" a (make-array Type (inc Compiler'MAX_POSITIONAL_ARITY))]
            (loop-when-recur [#_"int" j 0] (< j Compiler'MAX_POSITIONAL_ARITY) [(inc j)]
                (aset a j Compiler'OBJECT_TYPE)
            )
            (aset a Compiler'MAX_POSITIONAL_ARITY (Type/getType "[Ljava/lang/Object;"))
            (aset Compiler'ARG_TYPES (inc Compiler'MAX_POSITIONAL_ARITY) a)
        )
    )

    ;; symbol->localbinding
    (ยง def #_"Var" Compiler'LOCAL_ENV (Var''setDynamic-1 (Var'create nil)))

    ;; vector<localbinding>
    (ยง def #_"Var" Compiler'LOOP_LOCALS (Var''setDynamic-1 (Var'create)))

    ;; Label
    (ยง def #_"Var" Compiler'LOOP_LABEL (Var''setDynamic-1 (Var'create)))

    ;; vector<object>
    (ยง def #_"Var" Compiler'CONSTANTS (Var''setDynamic-1 (Var'create)))

    ;; IdentityHashMap
    (ยง def #_"Var" Compiler'CONSTANT_IDS (Var''setDynamic-1 (Var'create)))

    ;; vector<keyword>
    (ยง def #_"Var" Compiler'KEYWORD_CALLSITES (Var''setDynamic-1 (Var'create)))

    ;; vector<var>
    (ยง def #_"Var" Compiler'PROTOCOL_CALLSITES (Var''setDynamic-1 (Var'create)))

    ;; set<var>
    (ยง def #_"Var" Compiler'VAR_CALLSITES (Var''setDynamic-1 (Var'create)))

    ;; keyword->constid
    (ยง def #_"Var" Compiler'KEYWORDS (Var''setDynamic-1 (Var'create)))

    ;; var->constid
    (ยง def #_"Var" Compiler'VARS (Var''setDynamic-1 (Var'create)))

    ;; FnFrame
    (ยง def #_"Var" Compiler'METHOD (Var''setDynamic-1 (Var'create nil)))

    ;; nil or not
    (ยง def #_"Var" Compiler'IN_CATCH_FINALLY (Var''setDynamic-1 (Var'create nil)))

    (ยง def #_"Var" Compiler'METHOD_RETURN_CONTEXT (Var''setDynamic-1 (Var'create nil)))

    (ยง def #_"Var" Compiler'NO_RECUR (Var''setDynamic-1 (Var'create nil)))

    ;; DynamicClassLoader
    (ยง def #_"Var" Compiler'LOADER (Var''setDynamic-1 (Var'create)))

    (ยง def #_"Var" Compiler'INSTANCE (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "instance?")))

    ;; Integer
    (ยง def #_"Var" Compiler'LINE (Var''setDynamic-1 (Var'create 0)))
    (ยง def #_"Var" Compiler'COLUMN (Var''setDynamic-1 (Var'create 0)))

    (defn #_"int" Compiler'lineDeref []
        (.intValue (cast Number (.deref Compiler'LINE)))
    )

    (defn #_"int" Compiler'columnDeref []
        (.intValue (cast Number (.deref Compiler'COLUMN)))
    )

    ;; Integer
    (ยง def #_"Var" Compiler'NEXT_LOCAL_NUM (Var''setDynamic-1 (Var'create 0)))

    ;; Integer
    (ยง def #_"Var" Compiler'RET_LOCAL_NUM (Var''setDynamic-1 (Var'create)))

    (ยง def #_"Var" Compiler'COMPILE_STUB_SYM (Var''setDynamic-1 (Var'create nil)))
    (ยง def #_"Var" Compiler'COMPILE_STUB_CLASS (Var''setDynamic-1 (Var'create nil)))

    ;; PathNode chain
    (ยง def #_"Var" Compiler'CLEAR_PATH (Var''setDynamic-1 (Var'create nil)))

    ;; tail of PathNode chain
    (ยง def #_"Var" Compiler'CLEAR_ROOT (Var''setDynamic-1 (Var'create nil)))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (ยง def #_"Var" Compiler'CLEAR_SITES (Var''setDynamic-1 (Var'create nil)))

    (defn #_"boolean" Compiler'isSpecial [#_"Object" sym]
        (.containsKey Compiler'specials, sym)
    )

    (defn #_"boolean" Compiler'inTailCall [#_"Context" context]
        (and (= context :Context'RETURN) (some? (.deref Compiler'METHOD_RETURN_CONTEXT)) (nil? (.deref Compiler'IN_CATCH_FINALLY)))
    )

    (defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" sym]
        ;; already qualified or classname?
        (cond
            (pos? (.indexOf (:name sym), \.))
                sym
            (some? (:ns sym))
                (let [#_"Namespace" ns (Compiler'namespaceFor-1 sym)]
                    (if (and (some? ns) (not (and (some? (:name (:name ns))) (.equals (:name (:name ns)), (:ns sym)))))
                        (Symbol'intern (:name (:name ns)), (:name sym))
                        sym
                    )
                )
            :else
                (let [#_"Object" o (Namespace''getMapping (Compiler'currentNS), sym)]
                    (cond
                        (nil? o)            (Symbol'intern (:name (:name (Compiler'currentNS))), (:name sym))
                        (instance? Class o) (Symbol'intern nil, (.getName (cast Class o)))
                        (instance? Var o)   (let [#_"Var" v (cast Var o)] (Symbol'intern (:name (:name (:ns v))), (:name (:sym v))))
                    )
                )
        )
    )

    (defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" e]
        (when (and (instance? MaybePrimitiveExpr e) (.hasJavaClass e) (.canEmitPrimitive (cast MaybePrimitiveExpr e)))
            (let [#_"Class" c (.getJavaClass e)]
                (when (Util'isPrimitive c)
                    c
                )
            )
        )
    )

    (defn #_"Class" Compiler'maybeJavaClass [#_"Iterable" exprs]
        (try
            (let [#_"Iterator" it (.iterator exprs)]
                (loop-when [#_"Class" match nil] (.hasNext it) => match
                    (let [#_"Expr" e (.next it)]
                        (cond
                            (instance? ThrowExpr e)
                                (recur match)
                            (.hasJavaClass e)
                                (let [#_"Class" c (.getJavaClass e)]
                                    (cond
                                        (nil? match) (recur c)
                                        (= match c) (recur match)
                                    )
                                )
                        )
                    )
                )
            )
            (catch Exception _
                nil
            )
        )
    )

    (ยง def #_"NilExpr" Compiler'NIL_EXPR (NilExpr'new))

    (ยง def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr'new true))
    (ยง def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr'new false))

    (defn #_"boolean" Compiler'subsumes [#_"Class[]" c1, #_"Class[]" c2]
        ;; presumes matching lengths
        (loop-when [#_"boolean" better false #_"int" i 0] (< i (alength c1)) => better
            (when-not (= (aget c1 i) (aget c2 i)) => (recur better (inc i))
                (and (or (and (not (.isPrimitive (aget c1 i))) (.isPrimitive (aget c2 i))) (.isAssignableFrom (aget c2 i), (aget c1 i)))
                    (recur true (inc i))
                )
            )
        )
    )

    (defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (dotimes [#_"int" i (.count args)]
                (let [#_"Expr" arg (cast Expr (.nth args, i))]
                    (when (pos? i)
                        (.append sb, ", ")
                    )
                    (.append sb, (if (and (.hasJavaClass arg) (some? (.getJavaClass arg))) (.getName (.getJavaClass arg)) "unknown"))
                )
            )
            (.toString sb)
        )
    )

    (defn #_"int" Compiler'getMatchingParams [#_"String" methodName, #_"IPersistentVector" pars, #_"IPersistentVector" args, #_"IPersistentVector" rets]
        ;; presumes matching lengths
        (let [[#_"int" matchIdx #_"boolean" tied]
                (loop-when [matchIdx -1 tied false #_"boolean" foundExact false #_"int" i 0] (< i (.count pars)) => [matchIdx tied]
                    (let [[#_"int" exact #_"boolean" match]
                            (loop-when [exact 0 match true #_"int" p 0 #_"ISeq" s (.seq args)] (and match (< p (.count args)) (some? s)) => [exact match]
                                (let [#_"Expr" arg (cast Expr (.first s))
                                      #_"Class" aclass (if (.hasJavaClass arg) (.getJavaClass arg) Object) #_"Class" pclass (aget (.nth pars, i) p)
                                      [exact match]
                                        (if (and (.hasJavaClass arg) (= aclass pclass))
                                            [(inc exact) match]
                                            [exact (Reflector'paramArgTypeMatch pclass, aclass)]
                                        )]
                                    (recur exact match (inc p) (.next s))
                                )
                            )
                          [matchIdx tied foundExact]
                            (cond (= exact (.count args))
                                (let [matchIdx
                                        (when (or (not foundExact) (= matchIdx -1) (.isAssignableFrom (.nth rets, matchIdx), (.nth rets, i))) => matchIdx
                                            i
                                        )]
                                    [matchIdx false true]
                                )
                                (and match (not foundExact))
                                (let [[matchIdx tied]
                                        (cond (= matchIdx -1)
                                            (do
                                                [i tied]
                                            )
                                            (Compiler'subsumes (.nth pars, i), (.nth pars, matchIdx))
                                            (do
                                                [i false]
                                            )
                                            (Arrays/equals (.nth pars, matchIdx), (.nth pars, i))
                                            (let [matchIdx
                                                    (when (.isAssignableFrom (.nth rets, matchIdx), (.nth rets, i)) => matchIdx
                                                        i
                                                    )]
                                                [matchIdx tied]
                                            )
                                            (not (Compiler'subsumes (.nth pars, matchIdx), (.nth pars, i)))
                                            (do
                                                [matchIdx true]
                                            )
                                            :else
                                            (do
                                                [matchIdx tied]
                                            )
                                        )]
                                    [matchIdx tied foundExact]
                                )
                                :else
                                (do
                                    [matchIdx tied foundExact]
                                )
                            )]
                        (recur matchIdx tied foundExact (inc i))
                    )
                )]
            (when tied
                (throw (IllegalArgumentException. (str "More than one matching method found: " methodName)))
            )
            matchIdx
        )
    )

    (ยง def #_"IPersistentMap" Compiler'CHAR_MAP (PersistentHashMap'create-1a
        (object-array [
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        ])
    ))

    (def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (ยง static
        ;; DEMUNGE_MAP maps strings to characters in the opposite direction that CHAR_MAP does, plus it maps "$" to '/'.
        (let [#_"IPersistentMap" m
                (loop-when [m (RT'map "$", \/) #_"ISeq" s (RT'seq Compiler'CHAR_MAP)] (some? s) => m
                    (let [#_"IMapEntry" e (cast IMapEntry (.first s))]
                        (recur (.assoc m, (cast String (.val e)), (cast Character (.key e))) (.next s))
                    )
                )]
            (ร ass Compiler'DEMUNGE_MAP m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_" returns "_", but #"_COLON_|_" "_COLON_"
            ;; returns "_COLON_" as desired. Sorting string keys of DEMUNGE_MAP from longest to shortest ensures
            ;; correct matching behavior, even if some strings are prefixes of others.
            (let [#_"Object[]" a (RT'toArray (RT'keys m))]
                (Arrays/sort a,
                    (reify Comparator
                        #_foreign
                        (#_"int" compare [#_"Comparator" _self, #_"Object" s1, #_"Object" s2]
                            (- (.length (cast String s2)) (.length (cast String s1)))
                        )
                    )
                )
                (let [#_"StringBuilder" sb (StringBuilder.)]
                    (dotimes [#_"int" i (alength a)]
                        (when (pos? i)
                            (.append sb, "|")
                        )
                        (.append sb, "\\Q")
                        (.append sb, (cast String (aget a i)))
                        (.append sb, "\\E")
                    )
                    (ร ass Compiler'DEMUNGE_PATTERN (Pattern/compile (.toString sb)))
                )
            )
        )
    )

    (defn #_"String" Compiler'munge [#_"String" name]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (doseq [#_"char" c (.toCharArray name)]
                (.append sb, (or (cast String (.valAt Compiler'CHAR_MAP, c)) c))
            )
            (.toString sb)
        )
    )

    (defn #_"String" Compiler'demunge [#_"String" mungedName]
        (let [#_"StringBuilder" sb (StringBuilder.)
              #_"Matcher" m (.matcher Compiler'DEMUNGE_PATTERN, mungedName)
              #_"int" lastMatchEnd
                (loop-when [lastMatchEnd 0] (.find m) => lastMatchEnd
                    (let [#_"int" start (.start m) #_"int" end (.end m)]
                        ;; keep everything before the match
                        (.append sb, (.substring mungedName, lastMatchEnd, start))
                        ;; replace the match with DEMUNGE_MAP result
                        (.append sb, (cast Character (.valAt Compiler'DEMUNGE_MAP, (.group m))))
                        (recur end)
                    )
                )]
            ;; keep everything after the last match
            (.append sb, (.substring mungedName, lastMatchEnd))
            (.toString sb)
        )
    )

    (defn #_"PathNode" Compiler'clearPathRoot []
        (cast PathNode (Var''get Compiler'CLEAR_ROOT))
    )

    (defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg]
        (let [#_"int" n (Compiler'getAndIncLocalNum)
              #_"LocalBinding" lb (LocalBinding'new n, sym, tag, init, isArg, (Compiler'clearPathRoot))]
            (Var''set Compiler'LOCAL_ENV, (RT'assoc (cast IPersistentMap (.deref Compiler'LOCAL_ENV)), (:sym lb), lb))
            (let [#_"ObjMethod" method (cast ObjMethod (.deref Compiler'METHOD))]
                (ร ass method (assoc method :locals (cast IPersistentMap (RT'assoc (:locals method), lb, lb))))
                (ร ass method (assoc method :indexlocals (cast IPersistentMap (RT'assoc (:indexlocals method), n, lb))))
                lb
            )
        )
    )

    (defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" n (.intValue (cast Number (.deref Compiler'NEXT_LOCAL_NUM)))
              #_"ObjMethod" m (cast ObjMethod (.deref Compiler'METHOD))]
            (when (< (:maxLocal m) n)
                (ร ass m (assoc m :maxLocal n))
            )
            (Var''set Compiler'NEXT_LOCAL_NUM, (inc n))
            n
        )
    )

    (defn #_"Expr" Compiler'analyze-2 [#_"Context" context, #_"Object" form]
        (Compiler'analyze-3 context, form, nil)
    )

    (defn- #_"Expr" Compiler'analyze-3 [#_"Context" context, #_"Object" form, #_"String" name]
        ;; todo symbol macro expansion?
        (try
            (let [form
                    (when (instance? LazySeq form) => form
                        (.withMeta (cast IObj (or (RT'seq form) PersistentList'EMPTY)), (RT'meta form))
                    )]
                (cond
                    (nil? form)            Compiler'NIL_EXPR
                    (= form Boolean/TRUE)  Compiler'TRUE_EXPR
                    (= form Boolean/FALSE) Compiler'FALSE_EXPR
                    :else
                        (let [#_"Class" c (.getClass form)]
                            (cond
                                (= c Symbol)                       (Compiler'analyzeSymbol (cast Symbol form))
                                (= c Keyword)                      (Compiler'registerKeyword (cast Keyword form))
                                (instance? Number form)            (NumberExpr'parse (cast Number form))
                                (= c String)                       (StringExpr'new (.intern (cast String form)))
                                (and (instance? IPersistentCollection form) (not (instance? IType form)) (zero? (.count (cast IPersistentCollection form))))
                                    (let-when [#_"Expr" e (EmptyExpr'new form)] (some? (RT'meta form)) => e
                                        (MetaExpr'new e, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast IObj form))))
                                    )
                                (instance? ISeq form)              (Compiler'analyzeSeq context, (cast ISeq form), name)
                                (instance? IPersistentVector form) (VectorExpr'parse context, (cast IPersistentVector form))
                                (instance? IType form)             (ConstantExpr'new form)
                                (instance? IPersistentMap form)    (MapExpr'parse context, (cast IPersistentMap form))
                                (instance? IPersistentSet form)    (SetExpr'parse context, (cast IPersistentSet form))
                                :else                              (ConstantExpr'new form)
                            )
                        )
                )
            )
            (catch Throwable e
                (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e)))
            )
        )
    )

    (defn #_"Var" Compiler'isMacro [#_"Object" op]
        ;; no local macros for now
        (when-not (and (instance? Symbol op) (some? (Compiler'referenceLocal (cast Symbol op))))
            (when (or (instance? Symbol op) (instance? Var op))
                (let [#_"Var" v (if (instance? Var op) (cast Var op) (Compiler'lookupVar-3 (cast Symbol op), false, false))]
                    (when (and (some? v) (Var''isMacro v))
                        (when (or (= (:ns v) (Compiler'currentNS)) (Var''isPublic v)) => (throw (IllegalStateException. (str "var: " v " is not public")))
                            v
                        )
                    )
                )
            )
        )
    )

    (defn #_"IFn" Compiler'isInline [#_"Object" op, #_"int" arity]
        ;; no local inlines for now
        (when-not (and (instance? Symbol op) (some? (Compiler'referenceLocal (cast Symbol op))))
            (when (or (instance? Symbol op) (instance? Var op))
                (when-let [#_"Var" v (if (instance? Var op) (cast Var op) (Compiler'lookupVar-2 (cast Symbol op), false))]
                    (when (or (= (:ns v) (Compiler'currentNS)) (Var''isPublic v)) => (throw (IllegalStateException. (str "var: " v " is not public")))
                        (when-let [#_"IFn" f (cast IFn (RT'get-2 (.meta v), Compiler'inlineKey))]
                            (let [#_"IFn" arityPred (cast IFn (RT'get-2 (.meta v), Compiler'inlineAritiesKey))]
                                (when (or (nil? arityPred) (RT'booleanCast-1o (.invoke arityPred, arity)))
                                    f
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" sym]
        (and (some? (:ns sym)) (nil? (Compiler'namespaceFor-1 sym)))
    )

    (defn #_"Object" Compiler'preserveTag [#_"ISeq" src, #_"Object" dst]
        (let-when [#_"Symbol" tag (Compiler'tagOf src)] (and (some? tag) (instance? IObj dst)) => dst
            (.withMeta (cast IObj dst), (cast IPersistentMap (RT'assoc (RT'meta dst), RT'TAG_KEY, tag)))
        )
    )

    #_volatile
    (def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (defn- #_"Var" Compiler'ensureMacroCheck []
        (or Compiler'MACRO_CHECK
            (ยง sync Compiler'MACRO_CHECK_LOCK
                (or Compiler'MACRO_CHECK
                    (do
                        (ร ass Compiler'MACRO_CHECK_LOADING true)
                        (RT'load-1 "cloiure/spec/alpha")
                        (RT'load-1 "cloiure/core/specs/alpha")
                        (ร ass Compiler'MACRO_CHECK (Var'find (Symbol'intern "cloiure.spec.alpha", "macroexpand-check")))
                        (ร ass Compiler'MACRO_CHECK_LOADING false)
                        Compiler'MACRO_CHECK
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'checkSpecs [#_"Var" v, #_"ISeq" form]
        (when (and RT'CHECK_SPECS (not Compiler'MACRO_CHECK_LOADING))
            (try
                (.applyTo (Compiler'ensureMacroCheck), (RT'cons v, (RT'list-1 (.next form))))
                (catch Exception e
                    (throw (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e))
                )
            )
        )
        nil
    )

    (defn #_"Object" Compiler'macroexpand1 [#_"Object" x]
        (when (instance? ISeq x) => x
            (let [#_"ISeq" form (cast ISeq x) #_"Object" op (RT'first form)]
                (when-not (Compiler'isSpecial op) => x
                    ;; macro expansion
                    (let [#_"Var" v (Compiler'isMacro op)]
                        (if (some? v)
                            (do
                                (Compiler'checkSpecs v, form)
                                (try
                                    (.applyTo v, (RT'cons form, (RT'cons (Var''get Compiler'LOCAL_ENV), (.next form))))
                                    (ยง catch ArityException e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ArityException'new-2 (- (:actual e) 2), (:name e)))
                                    )
                                )
                            )
                            (when (instance? Symbol op) => x
                                (let [#_"Symbol" sym (cast Symbol op) #_"String" sname (:name sym)]
                                    ;; (.substring s 2 5) => (. s substring 2 5)
                                    (cond
                                        (= (.charAt (:name sym), 0) \.)
                                            (when (< 1 (RT'length form)) => (throw (IllegalArgumentException. "Malformed member expression, expecting (.member target ...)"))
                                                (let [#_"Symbol" meth (Symbol'intern (.substring sname, 1))
                                                      #_"Object" target (RT'second form)
                                                      target
                                                        (when (some? (HostExpr'maybeClass target, false)) => target
                                                            (.withMeta (cast IObj (RT'list-2 Compiler'IDENTITY, target)), (RT'map RT'TAG_KEY, Compiler'CLASS))
                                                        )]
                                                    (Compiler'preserveTag form, (RT'listStar-4 Compiler'DOT, target, meth, (.next (.next form))))
                                                )
                                            )
                                        (Compiler'namesStaticMember sym)
                                            (let-when [#_"Symbol" target (Symbol'intern (:ns sym))] (some? (HostExpr'maybeClass target, false)) => x
                                                (let [#_"Symbol" meth (Symbol'intern (:name sym))]
                                                    (Compiler'preserveTag form, (RT'listStar-4 Compiler'DOT, target, meth, (.next form)))
                                                )
                                            )
                                        :else
                                            ;; (s.substring ...) => (. s substring ...)
                                            ;; (package.class.name ...) => (. package.class name ...)
                                            ;; (StringBuilder. ...) => (new StringBuilder ...)
                                            (let-when [#_"int" i (.lastIndexOf sname, \.)] (= i (dec (.length sname))) => x
                                                (RT'listStar-3 Compiler'NEW, (Symbol'intern (.substring sname, 0, i)), (.next form))
                                            )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Compiler'macroexpand [#_"Object" form]
        (let [#_"Object" f (Compiler'macroexpand1 form)]
            (if (= f form) form (recur f))
        )
    )

    (defn- #_"Expr" Compiler'analyzeSeq [#_"Context" context, #_"ISeq" form, #_"String" name]
        (let [#_"IPersistentMap" meta (RT'meta form)
              #_"Object" line   (if (and (some? meta) (.containsKey meta, RT'LINE_KEY))   (.valAt meta, RT'LINE_KEY)   (Compiler'lineDeref))
              #_"Object" column (if (and (some? meta) (.containsKey meta, RT'COLUMN_KEY)) (.valAt meta, RT'COLUMN_KEY) (Compiler'columnDeref))]
            (Var'pushThreadBindings (RT'map Compiler'LINE, line, Compiler'COLUMN, column))
            (try
                (let-when [#_"Object" me (Compiler'macroexpand1 form)] (= me form) => (Compiler'analyze-3 context, me, name)
                    (let-when [#_"Object" op (RT'first form)] (some? op) => (throw (IllegalArgumentException. (str "Can't call nil, form: " form)))
                        (let [#_"IFn" inline (Compiler'isInline op, (RT'count (RT'next form)))]
                            (cond
                                (some? inline)
                                    (Compiler'analyze-2 context, (Compiler'preserveTag form, (.applyTo inline, (RT'next form))))
                                (.equals op, Compiler'FN)
                                    (FnExpr'parse context, form, name)
                                :else
                                    (let [#_"IParser" p (cast IParser (.valAt Compiler'specials, op))]
                                        (if (some? p)
                                            (.parse p, context, form)
                                            (InvokeExpr'parse context, form)
                                        )
                                    )
                            )
                        )
                    )
                )
                (catch Throwable e
                    (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e)))
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" Compiler'eval-1 [#_"Object" form]
        (Compiler'eval-2 form, true)
    )

    (defn #_"Object" Compiler'eval-2 [#_"Object" form, #_"boolean" freshLoader]
        (Var'pushThreadBindings (RT'map Compiler'LOADER, (RT'makeClassLoader)))
        (try
            (let [#_"IPersistentMap" meta (RT'meta form)
                  #_"Object" line   (if (and (some? meta) (.containsKey meta, RT'LINE_KEY))   (.valAt meta, RT'LINE_KEY)   (Compiler'lineDeref))
                  #_"Object" column (if (and (some? meta) (.containsKey meta, RT'COLUMN_KEY)) (.valAt meta, RT'COLUMN_KEY) (Compiler'columnDeref))]
                (Var'pushThreadBindings (RT'map Compiler'LINE, line, Compiler'COLUMN, column))
                (try
                    (let [form (Compiler'macroexpand form)]
                        (cond
                            (and (instance? ISeq form) (Util'equals (RT'first form), Compiler'DO))
                                (loop-when-recur [#_"ISeq" s (RT'next form)] (some? (RT'next s)) [(RT'next s)] => (Compiler'eval-2 (RT'first s), false)
                                    (Compiler'eval-2 (RT'first s), false)
                                )
                            (or (instance? IType form) (and (instance? IPersistentCollection form) (not (and (instance? Symbol (RT'first form)) (.startsWith (:name (cast Symbol (RT'first form))), "def")))))
                                (let [#_"ObjExpr" fexpr (cast ObjExpr (Compiler'analyze-3 :Context'EXPRESSION, (RT'list-3 Compiler'FN, PersistentVector'EMPTY, form), (str "eval" (RT'nextID))))
                                      #_"IFn" fn (cast IFn (.eval fexpr))]
                                    (.invoke fn)
                                )
                            :else
                                (let [#_"Expr" expr (Compiler'analyze-2 :Context'EVAL, form)]
                                    (.eval expr)
                                )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
    )

    (defn- #_"int" Compiler'registerConstant [#_"Object" o]
        (when (Var''isBound Compiler'CONSTANTS) => -1
            (let [#_"PersistentVector" v (cast PersistentVector (.deref Compiler'CONSTANTS))
                  #_"IdentityHashMap<Object, Integer>" ids (cast IdentityHashMap #_"<Object, Integer>" (.deref Compiler'CONSTANT_IDS))]
                (or (.get ids, o)
                    (do
                        (Var''set Compiler'CONSTANTS, (RT'conj v, o))
                        (.put ids, o, (.count v))
                        (.count v)
                    )
                )
            )
        )
    )

    (defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" keyword]
        (when (Var''isBound Compiler'KEYWORDS) => (KeywordExpr'new keyword)
            (let [#_"IPersistentMap" keywordsMap (cast IPersistentMap (.deref Compiler'KEYWORDS))
                  #_"Object" id (RT'get-2 keywordsMap, keyword)]
                (when (nil? id)
                    (Var''set Compiler'KEYWORDS, (RT'assoc keywordsMap, keyword, (Compiler'registerConstant keyword)))
                )
                (KeywordExpr'new keyword)
            )
        )
    )

    (defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" keyword]
        (when (Var''isBound Compiler'KEYWORD_CALLSITES) => (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
            (let [#_"IPersistentVector" callsites (-> (cast IPersistentVector (.deref Compiler'KEYWORD_CALLSITES)) (.cons keyword))]
                (Var''set Compiler'KEYWORD_CALLSITES, callsites)
                (dec (.count callsites))
            )
        )
    )

    (defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" v]
        (when (Var''isBound Compiler'PROTOCOL_CALLSITES) => (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
            (let [#_"IPersistentVector" callsites (-> (cast IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES)) (.cons v))]
                (Var''set Compiler'PROTOCOL_CALLSITES, callsites)
                (dec (.count callsites))
            )
        )
    )

    (defn- #_"void" Compiler'registerVarCallsite [#_"Var" v]
        (when (Var''isBound Compiler'VAR_CALLSITES) => (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
            (let [#_"IPersistentCollection" callsites (-> (cast IPersistentCollection (.deref Compiler'VAR_CALLSITES)) (.cons v))]
                (Var''set Compiler'VAR_CALLSITES, callsites)
            )
        )
        nil
    )

    (defn #_"ISeq" Compiler'fwdPath [#_"PathNode" p]
        (loop-when-recur [#_"ISeq" s nil p p] (some? p) [(RT'cons p, s) (:parent p)] => s)
    )

    (defn #_"PathNode" Compiler'commonPath [#_"PathNode" p1, #_"PathNode" p2]
        (let [#_"ISeq" s1 (Compiler'fwdPath p1) #_"ISeq" s2 (Compiler'fwdPath p2)]
            (when (= (RT'first s1) (RT'first s2))
                (loop-when-recur [s1 s1 s2 s2]
                                 (and (some? (RT'second s1)) (= (RT'second s1) (RT'second s2)))
                                 [(.next s1) (.next s2)]
                              => (cast PathNode (RT'first s1))
                )
            )
        )
    )

    (defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" sym]
        (let [#_"Symbol" tag (Compiler'tagOf sym)]
            (or
                (cond
                    (nil? (:ns sym)) ;; ns-qualified syms are always Vars
                        (when-let [#_"LocalBinding" b (Compiler'referenceLocal sym)]
                            (LocalBindingExpr'new b, tag)
                        )
                    (nil? (Compiler'namespaceFor-1 sym))
                        (when-let [#_"Class" c (HostExpr'maybeClass (Symbol'intern (:ns sym)), false)]
                            (if (some? (Reflector'getField c, (:name sym), true))
                                (StaticFieldExpr'new (Compiler'lineDeref), (Compiler'columnDeref), c, (:name sym), tag)
                                (throw (RuntimeException. (str "Unable to find static field: " (:name sym) " in " c)))
                            )
                        )
                )
                (let [#_"Object" o (Compiler'resolve-1 sym)]
                    (cond
                        (instance? Var o)
                            (let-when [#_"Var" v (cast Var o)] (nil? (Compiler'isMacro v)) => (throw (RuntimeException. (str "Can't take value of a macro: " v)))
                                (Compiler'registerVar v)
                                (VarExpr'new v, tag)
                            )
                        (instance? Class o)
                            (ConstantExpr'new o)
                        (instance? Symbol o)
                            (UnresolvedVarExpr'new (cast Symbol o))
                        :else
                            (throw (RuntimeException. (str "Unable to resolve symbol: " sym " in this context")))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'destubClassName [#_"String" name]
        ;; skip over prefix + '.' or '/'
        (if (.startsWith name, Compiler'COMPILE_STUB_PREFIX)
            (.substring name, (inc (.length Compiler'COMPILE_STUB_PREFIX)))
            name
        )
    )

    (defn #_"Type" Compiler'getType [#_"Class" c]
        (let [#_"String" desc (.getDescriptor (Type/getType c))
              desc
                (when (.startsWith desc, "L") => desc
                    (str "L" (Compiler'destubClassName (.substring desc, 1)))
                )]
            (Type/getType desc)
        )
    )

    (defn #_"Object" Compiler'resolve-2 [#_"Symbol" sym, #_"boolean" allowPrivate]
        (Compiler'resolveIn (Compiler'currentNS), sym, allowPrivate)
    )

    (defn #_"Object" Compiler'resolve-1 [#_"Symbol" sym]
        (Compiler'resolveIn (Compiler'currentNS), sym, false)
    )

    (defn #_"Namespace" Compiler'namespaceFor-1 [#_"Symbol" sym]
        (Compiler'namespaceFor-2 (Compiler'currentNS), sym)
    )

    (defn #_"Namespace" Compiler'namespaceFor-2 [#_"Namespace" inns, #_"Symbol" sym]
        ;; note, presumes non-nil sym.ns
        (let [#_"Symbol" nsSym (Symbol'intern (:ns sym))]
            ;; first check against currentNS' aliases, otherwise check the Namespaces map
            (or (Namespace''lookupAlias inns, nsSym) (Namespace'find nsSym))
        )
    )

    (defn #_"Object" Compiler'resolveIn [#_"Namespace" n, #_"Symbol" sym, #_"boolean" allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond
            (some? (:ns sym))
                (let-when [#_"Namespace" ns (Compiler'namespaceFor-2 n, sym)] (some? ns)                         => (throw (RuntimeException. (str "No such namespace: " (:ns sym))))
                    (let-when [#_"Var" v (Namespace''findInternedVar ns, (Symbol'intern (:name sym)))] (some? v) => (throw (RuntimeException. (str "No such var: " sym)))
                        (when (or (= (:ns v) (Compiler'currentNS)) (Var''isPublic v) allowPrivate)               => (throw (IllegalStateException. (str "var: " sym " is not public")))
                            v
                        )
                    )
                )
            (or (pos? (.indexOf (:name sym), \.)) (= (.charAt (:name sym), 0) \[)) (RT'classForName-1 (:name sym))
            (.equals sym, Compiler'NS)                              RT'NS_VAR
            (.equals sym, Compiler'IN_NS)                           RT'IN_NS_VAR
            (Util'equals sym, (Var''get Compiler'COMPILE_STUB_SYM)) (Var''get Compiler'COMPILE_STUB_CLASS)
            :else
                (or (Namespace''getMapping n, sym)
                    (when (RT'booleanCast-1o (.deref RT'ALLOW_UNRESOLVED_VARS)) => (throw (RuntimeException. (str "Unable to resolve symbol: " sym " in this context")))
                        sym
                    )
                )
        )
    )

    (defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" n, #_"Symbol" sym]
        ;; note - ns-qualified vars must already exist
        (cond
            (some? (:ns sym))
                (when-let [#_"Namespace" ns (Compiler'namespaceFor-2 n, sym)]
                    (when-let [#_"Var" v (Namespace''findInternedVar ns, (Symbol'intern (:name sym)))]
                        v
                    )
                )
            (or (and (pos? (.indexOf (:name sym), \.)) (not (.endsWith (:name sym), "."))) (= (.charAt (:name sym), 0) \[))
                (RT'classForName-1 (:name sym))
            (.equals sym, Compiler'NS)
                RT'NS_VAR
            (.equals sym, Compiler'IN_NS)
                RT'IN_NS_VAR
            :else
                (Namespace''getMapping n, sym)
        )
    )

    (defn #_"Var" Compiler'lookupVar-3 [#_"Symbol" sym, #_"boolean" internNew, #_"boolean" registerMacro]
        ;; note - ns-qualified vars in other namespaces must already exist
        (let [#_"Var" var
                (cond
                    (some? (:ns sym))
                        (when-let [#_"Namespace" ns (Compiler'namespaceFor-1 sym)]
                            (let [#_"Symbol" name (Symbol'intern (:name sym))]
                                (if (and internNew (= ns (Compiler'currentNS)))
                                    (Namespace''intern ns, name)
                                    (Namespace''findInternedVar ns, name)
                                )
                            )
                        )
                    (.equals sym, Compiler'NS)    RT'NS_VAR
                    (.equals sym, Compiler'IN_NS) RT'IN_NS_VAR
                    :else ;; is it mapped?
                        (let [#_"Object" o (Namespace''getMapping (Compiler'currentNS), sym)]
                            (cond
                                (nil? o) ;; introduce a new var in the current ns
                                    (when internNew
                                        (Namespace''intern (Compiler'currentNS), (Symbol'intern (:name sym)))
                                    )
                                (instance? Var o)
                                    (cast Var o)
                                :else
                                    (throw (RuntimeException. (str "Expecting var, but " sym " is mapped to " o)))
                            )
                        )
                )]
            (when (and (some? var) (or (not (Var''isMacro var)) registerMacro))
                (Compiler'registerVar var)
            )
            var
        )
    )

    (defn #_"Var" Compiler'lookupVar-2 [#_"Symbol" sym, #_"boolean" internNew]
        (Compiler'lookupVar-3 sym, internNew, true)
    )

    (defn- #_"void" Compiler'registerVar [#_"Var" var]
        (when (Var''isBound Compiler'VARS)
            (let [#_"IPersistentMap" m (cast IPersistentMap (.deref Compiler'VARS))]
                (let-when [#_"Object" id (RT'get-2 m, var)] (nil? id)
                    (Var''set Compiler'VARS, (RT'assoc m, var, (Compiler'registerConstant var)))
                )
            )
        )
        nil
    )

    (defn #_"Namespace" Compiler'currentNS []
        (cast Namespace (.deref RT'CURRENT_NS))
    )

    (defn #_"void" Compiler'closeOver [#_"LocalBinding" b, #_"ObjMethod" method]
        (when (and (some? b) (some? method))
            (let [#_"LocalBinding" lb (cast LocalBinding (RT'get-2 (:locals method), b))]
                (if (nil? lb)
                    (do
                        (ร ass method (update-in method [:objx :closes] #(cast IPersistentMap (RT'assoc %, b, b))))
                        (Compiler'closeOver b, (:parent method))
                    )
                    (do
                        (when (zero? (:idx lb))
                            (ร ass method (assoc method :usesThis true))
                        )
                        (when (some? (.deref Compiler'IN_CATCH_FINALLY))
                            (ร ass method (update method :localsUsedInCatchFinally #(cast PersistentHashSet (.cons %, (:idx b)))))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" sym]
        (when (Var''isBound Compiler'LOCAL_ENV)
            (when-let [#_"LocalBinding" b (cast LocalBinding (RT'get-2 (.deref Compiler'LOCAL_ENV), sym))]
                (let [#_"ObjMethod" method (cast ObjMethod (.deref Compiler'METHOD))]
                    (when (zero? (:idx b))
                        (ร ass method (assoc method :usesThis true))
                    )
                    (Compiler'closeOver b, method)
                    b
                )
            )
        )
    )

    (defn- #_"Symbol" Compiler'tagOf [#_"Object" o]
        (let [#_"Object" tag (RT'get-2 (RT'meta o), RT'TAG_KEY)]
            (cond
                (instance? Symbol tag) (cast Symbol tag)
                (instance? String tag) (Symbol'intern nil, (cast String tag))
            )
        )
    )

    (defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" pushbackReader]
        (loop-when-recur [#_"int" ch (LispReader'read1 pushbackReader)]
                         (LispReader'isWhitespace ch)
                         [(LispReader'read1 pushbackReader)]
                      => (LispReader'unread pushbackReader, ch)
        )
        nil
    )

    (defn #_"Object" Compiler'load [#_"Reader" reader]
        (let [#_"LineNumberingPushbackReader" r
                (if (instance? LineNumberingPushbackReader reader) (cast LineNumberingPushbackReader reader) (LineNumberingPushbackReader'new-1 reader))]
            (Var'pushThreadBindings (RT'mapUniqueKeys
                (object-array [
                    Compiler'LOADER         (RT'makeClassLoader)
                    Compiler'METHOD         nil
                    Compiler'LOCAL_ENV      nil
                    Compiler'LOOP_LOCALS    nil
                    Compiler'NEXT_LOCAL_NUM 0
                    RT'CURRENT_NS           (.deref RT'CURRENT_NS)
                    RT'WARN_ON_REFLECTION   (.deref RT'WARN_ON_REFLECTION)
                ])
            ))
            (try
                (let [#_"Object" EOF (Object.)]
                    (loop [#_"Object" v nil]
                        (Compiler'consumeWhitespaces r)
                        (let-when [#_"Object" x (LispReader'read-4 r, false, EOF, false)] (not= x EOF) => v
                            (recur (Compiler'eval-2 x, false))
                        )
                    )
                )
                (ยง catch LispReaderException e
                    (throw (CompilerException'new (:line e), (:column e), (.getCause e)))
                )
                (catch Throwable e
                    (throw (if (instance? CompilerException e) (cast CompilerException e) (CompilerException'new 0, 0, e)))
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"void" Compiler'pushNS []
        (Var'pushThreadBindings (PersistentHashMap'create-1a
            (object-array [
                (Var''setDynamic-1 (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "*ns*"))) nil
            ])
        ))
        nil
    )

    (defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" loader]
        (Var'pushThreadBindings (RT'map
            (object-array [
                (Var''setDynamic-1 (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "*ns*"))) nil
                RT'FN_LOADER_VAR loader
            ])
        ))
        nil
    )

    (defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" target, #_"Keyword" k]
        nil
    )

    (defn #_"boolean" Compiler'inty [#_"Class" c] (any = c Integer/TYPE Short/TYPE Byte/TYPE Character/TYPE))

    (defn #_"Class" Compiler'retType [#_"Class" tc, #_"Class" ret]
        (cond
            (nil? tc)
                ret
            (nil? ret)
                tc
            (and (.isPrimitive ret) (.isPrimitive tc))
                (if (or (and (Compiler'inty ret) (Compiler'inty tc)) (= ret tc))
                    tc
                    (throw (UnsupportedOperationException. (str "Cannot coerce " ret " to " tc ", use a cast instead")))
                )
            :else
                tc
        )
    )

    (defn #_"Class" Compiler'primClass-1s [#_"Symbol" sym]
        (when (some? sym)
            (condp = (:name sym)
                "int"     Integer/TYPE
                "long"    Long/TYPE
                "float"   Float/TYPE
                "double"  Double/TYPE
                "char"    Character/TYPE
                "short"   Short/TYPE
                "byte"    Byte/TYPE
                "boolean" Boolean/TYPE
                "void"    Void/TYPE
                          nil
            )
        )
    )

    (defn #_"Class" Compiler'tagClass [#_"Object" tag]
        (when (some? tag) => Object
            (or
                (when (instance? Symbol tag)
                    (Compiler'primClass-1s (cast Symbol tag))
                )
                (HostExpr'tagToClass tag)
            )
        )
    )

    (defn #_"Class" Compiler'primClass-1c [#_"Class" c]
        (if (.isPrimitive c) c Object)
    )

    (defn #_"Class" Compiler'boxClass [#_"Class" p]
        (when (.isPrimitive p) => p
            (condp = p
                Integer/TYPE   Integer
                Long/TYPE      Long
                Float/TYPE     Float
                Double/TYPE    Double
                Character/TYPE Character
                Short/TYPE     Short
                Byte/TYPE      Byte
                Boolean/TYPE   Boolean
                               nil
            )
        )
    )

    (defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        PersistentHashSet'EMPTY
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons
    (defn- #_"Cons" Cons'init []
        (hash-map
            #_"Object" :_first nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"Cons" Cons'new-2 [#_"Object" _first, #_"ISeq" _more]
        (let [this (merge (ASeq'new-0) (Cons'init))]
            (assoc this :_first _first :_more _more)
        )
    )

    (defn #_"Cons" Cons'new-3 [#_"IPersistentMap" meta, #_"Object" _first, #_"ISeq" _more]
        (let [this (merge (ASeq'new-1 meta) (Cons'init))]
            (assoc this :_first _first :_more _more)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--Cons [#_"Cons" this]
        (:_first this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Cons [#_"Cons" this]
        (.seq (.more this))
    )

    #_override
    (defn #_"ISeq" ISeq'''more--Cons [#_"Cons" this]
        (or (:_more this) PersistentList'EMPTY)
    )

    #_override
    (defn #_"int" Counted'''count--Cons [#_"Cons" this]
        (inc (RT'count (:_more this)))
    )

    #_override
    (defn #_"Cons" IObj'''withMeta--Cons [#_"Cons" this, #_"IPersistentMap" meta]
        (Cons'new-3 meta, (:_first this), (:_more this))
    )
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle
    (defn- #_"Cycle" Cycle'init []
        (hash-map
            #_"ISeq" :all nil ;; never nil
            #_"ISeq" :prev nil
            #_volatile
            #_"ISeq" :_current nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Cycle" Cycle'new-3 [#_"ISeq" all, #_"ISeq" prev, #_"ISeq" current]
        (let [this (merge (ASeq'new-0) (Cycle'init))]
            (assoc this :all all :prev prev :_current current)
        )
    )

    (defn- #_"Cycle" Cycle'new-5 [#_"IPersistentMap" meta, #_"ISeq" all, #_"ISeq" prev, #_"ISeq" current, #_"ISeq" next]
        (let [this (merge (ASeq'new-1 meta) (Cycle'init))]
            (assoc this :all all :prev prev :_current current :_next next)
        )
    )

    (defn #_"ISeq" Cycle'create [#_"ISeq" vals]
        (if (some? vals) (Cycle'new-3 vals, nil, vals) PersistentList'EMPTY)
    )

    ;; realization for use of current
    #_method
    (defn- #_"ISeq" Cycle''current [#_"Cycle" this]
        (when (nil? (:_current this))
            (let [#_"ISeq" current (.next (:prev this))]
                (ร ass this (assoc this :_current (or current (:all this))))
            )
        )
        (:_current this)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--Cycle [#_"Cycle" this]
        (some? (:_current this))
    )

    #_override
    (defn #_"Object" ISeq'''first--Cycle [#_"Cycle" this]
        (.first (Cycle''current this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Cycle [#_"Cycle" this]
        (when (nil? (:_next this))
            (ร ass this (assoc this :_next (Cycle'new-3 (:all this), (Cycle''current this), nil)))
        )
        (:_next this)
    )

    #_override
    (defn #_"Cycle" IObj'''withMeta--Cycle [#_"Cycle" this, #_"IPersistentMap" meta]
        (Cycle'new-5 meta, (:all this), (:prev this), (:_current this), (:_next this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Cycle [#_"Cycle" this, #_"IFn" f]
        (loop [#_"ISeq" s (Cycle''current this) #_"Object" r (.first s)]
            (let [s (or (.next s) (:all this)) r (.invoke f, r, (.first s))]
                (when-not (RT'isReduced r) => (.deref (cast IDeref r))
                    (recur s r)
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Cycle [#_"Cycle" this, #_"IFn" f, #_"Object" r]
        (loop [#_"ISeq" s (Cycle''current this) r (.invoke f, r, (.first s))]
            (when-not (RT'isReduced r) => (.deref (cast IDeref r))
                (let [s (or (.next s) (:all this))]
                    (recur s (.invoke f, r, (.first s)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay
    (defn- #_"Delay" Delay'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Throwable" :exception nil
            #_volatile
            #_"IFn" :fn nil
        )
    )

    (defn #_"Delay" Delay'new [#_"IFn" fn]
        (let [this (Delay'init)]
            (assoc this :fn fn :val nil :exception nil)
        )
    )

    (defn #_"Object" Delay'force [#_"Object" x]
        (if (instance? Delay x) (.deref (cast Delay x)) x)
    )

    #_override
    (defn #_"Object" IDeref'''deref--Delay [#_"Delay" this]
        (when (some? (:fn this))
            (ยง sync this
                ;; double check
                (when (some? (:fn this))
                    (try
                        (ร ass this (assoc this :val (.invoke (:fn this))))
                        (catch Throwable t
                            (ร ass this (assoc this :exception t))
                        )
                    )
                    (ร ass this (assoc this :fn nil))
                )
            )
        )
        (when (some? (:exception this))
            (throw (:exception this))
        )
        (:val this)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--Delay [#_"Delay" this]
        (ยง sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(class-ns DynamicClassLoader
    (def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ConcurrentHashMap.))

    (def #_"ReferenceQueue" DynamicClassLoader'RQ (ReferenceQueue.))

    (defn- #_"DynamicClassLoader" DynamicClassLoader'init []
        (hash-map
            #_"HashMap<Integer, Object[]>" :constantVals (HashMap.)
        )
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new [#_"ClassLoader" parent]
        (merge (ยง foreign URLClassLoader'new (make-array URL 0), parent) (DynamicClassLoader'init))
    )

    #_foreign
    (defn #_"Class" defineClass---DynamicClassLoader [#_"DynamicClassLoader" this, #_"String" name, #_"byte[]" bytes, #_"Object" srcForm]
        (Util'clearCache DynamicClassLoader'RQ, DynamicClassLoader'classCache)
        (let [#_"Class" c (.defineClass this, name, bytes, 0, (alength bytes))]
            (.put DynamicClassLoader'classCache, name, (SoftReference. c, DynamicClassLoader'RQ))
            c
        )
    )

    (defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" name]
        (when-let [#_"Reference<Class>" r (.get DynamicClassLoader'classCache, name)]
            (or (.get r) (do (.remove DynamicClassLoader'classCache, name, r) nil))
        )
    )

    #_foreign
    (defn #_"Class<?>" findClass---DynamicClassLoader [#_"DynamicClassLoader" this, #_"String" name]
        (or (DynamicClassLoader'findInMemoryClass name) (.findClass (ยง super ), name))
    )

    #_foreign
    (defn #_"Class<?>" loadClass---DynamicClassLoader [#_"DynamicClassLoader" this, #_"String" name, #_"boolean" resolve]
        (ยง sync this
            (let [#_"Class" c
                    (or (.findLoadedClass this, name)
                        (DynamicClassLoader'findInMemoryClass name)
                        (.loadClass (ยง super ), name, false)
                    )]
                (when resolve
                    (.resolveClass this, c)
                )
                c
            )
        )
    )

    #_method
    (defn #_"void" DynamicClassLoader''registerConstants [#_"DynamicClassLoader" this, #_"int" id, #_"Object[]" val]
        (.put (:constantVals this), id, val)
        nil
    )

    #_method
    (defn #_"Object[]" DynamicClassLoader''getConstants [#_"DynamicClassLoader" this, #_"int" id]
        (.get (:constantVals this), id)
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo
    (defn- #_"ExceptionInfo" ExceptionInfo'init []
        (hash-map
            #_"IPersistentMap" :data nil
        )
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-2 [#_"String" s, #_"IPersistentMap" data]
        (ExceptionInfo'new-3 s, data, nil)
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-3 [#_"String" s, #_"IPersistentMap" data, #_"Throwable" throwable]
        (let [this (merge (ยง foreign RuntimeException'new s, throwable) (ExceptionInfo'init))]
            ;; nil cause is equivalent to not passing a cause
            (when (some? data) => (throw (IllegalArgumentException. "Additional data must be non-nil."))
                (assoc this :data data)
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IExceptionInfo'''getData--ExceptionInfo [#_"ExceptionInfo" this]
        (:data this)
    )

    #_foreign
    (defn #_"String" toString---ExceptionInfo [#_"ExceptionInfo" this]
        (str "cloiure.lang.ExceptionInfo: " (.getMessage this) " " (:data this))
    )
)
)

(java-ns cloiure.lang.Intrinsics

(class-ns Intrinsics
    (defn- #_"Object[]" Intrinsics'oa [& #_"Object..." arr]
        arr
    )

    (ยง def #_"IPersistentMap" Intrinsics'ops (RT'map
        (object-array [
            "public static double cloiure.lang.Numbers.add(double,double)"                Opcodes/DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      Opcodes/LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       Opcodes/LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      Opcodes/LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           Opcodes/DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             Opcodes/DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                Opcodes/LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (Intrinsics'oa Opcodes/L2I, Opcodes/LSHL)
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (Intrinsics'oa Opcodes/L2I, Opcodes/LSHR)
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (Intrinsics'oa Opcodes/L2I, Opcodes/LUSHR)
            "public static double cloiure.lang.Numbers.minus(double)"                     Opcodes/DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              Opcodes/DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static double cloiure.lang.Numbers.dec(double)"                       (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 Opcodes/LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                Opcodes/ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               Opcodes/ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       Opcodes/IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           Opcodes/IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      Opcodes/ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            Opcodes/INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (Intrinsics'oa Opcodes/ICONST_1, Opcodes/IADD)
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (Intrinsics'oa Opcodes/ICONST_1, Opcodes/ISUB)
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      Opcodes/IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        Opcodes/IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     Opcodes/IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            Opcodes/LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      Opcodes/DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               Opcodes/LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           Opcodes/DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    Opcodes/DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          Opcodes/LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       Opcodes/LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" Opcodes/DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (Intrinsics'oa Opcodes/LCONST_1, Opcodes/LADD)
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (Intrinsics'oa Opcodes/LCONST_1, Opcodes/LSUB)

            "public static boolean cloiure.lang.RT.aget_boolean(boolean[],int)"                  Opcodes/BALOAD
            "public static byte cloiure.lang.RT.aget_byte(byte[],int)"                           Opcodes/BALOAD
            "public static short cloiure.lang.RT.aget_short(short[],int)"                        Opcodes/SALOAD
            "public static char cloiure.lang.RT.aget_char(char[],int)"                           Opcodes/CALOAD
            "public static int cloiure.lang.RT.aget_int(int[],int)"                              Opcodes/IALOAD
            "public static long cloiure.lang.RT.aget_long(long[],int)"                           Opcodes/LALOAD
            "public static float cloiure.lang.RT.aget_float(float[],int)"                        Opcodes/FALOAD
            "public static double cloiure.lang.RT.aget_double(double[],int)"                     Opcodes/DALOAD
            "public static java.lang.Object cloiure.lang.RT.aget_object(java.lang.Object[],int)" Opcodes/AALOAD

            "public static int cloiure.lang.RT.alength_boolean(boolean[])"         Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_byte(byte[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_short(short[])"             Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_char(char[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_int(int[])"                 Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_long(long[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_float(float[])"             Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_double(double[])"           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_object(java.lang.Object[])" Opcodes/ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            Opcodes/L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          Opcodes/NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           Opcodes/F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" Opcodes/NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  Opcodes/F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   Opcodes/L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   Opcodes/I2D
            "public static long cloiure.lang.RT.longCast(long)"                Opcodes/NOP
            "public static long cloiure.lang.RT.longCast(short)"               Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(byte)"                Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(int)"                 Opcodes/I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         Opcodes/L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       Opcodes/D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        Opcodes/F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      Opcodes/F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     Opcodes/D2L
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       Opcodes/NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        Opcodes/I2L
        ])
    ))

    ;; map to instructions terminated with comparator for branch to false
    (ยง def #_"IPersistentMap" Intrinsics'preds (RT'map
        (object-array [
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (Intrinsics'oa Opcodes/DCMPG, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (Intrinsics'oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (Intrinsics'oa Opcodes/DCMPG, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (Intrinsics'oa Opcodes/LCMP, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (Intrinsics'oa Opcodes/LCMP, Opcodes/IFLT)
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFLT)
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (Intrinsics'oa Opcodes/IF_ICMPNE)
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFNE)

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPG, Opcodes/IFGE)
        ])
    ))
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate
    (def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (defn- #_"Iterate" Iterate'init []
        (hash-map
            #_"IFn" :f nil ;; never nil
            #_"Object" :prevSeed nil
            #_volatile
            #_"Object" :_seed nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Iterate" Iterate'new-3 [#_"IFn" f, #_"Object" prevSeed, #_"Object" seed]
        (let [this (merge (ASeq'new-0) (Iterate'init))]
            (assoc this :f f :prevSeed prevSeed :_seed seed)
        )
    )

    (defn- #_"Iterate" Iterate'new-5 [#_"IPersistentMap" meta, #_"IFn" f, #_"Object" prevSeed, #_"Object" seed, #_"ISeq" next]
        (let [this (merge (ASeq'new-1 meta) (Iterate'init))]
            (assoc this :f f :prevSeed prevSeed :_seed seed :_next next)
        )
    )

    (defn #_"ISeq" Iterate'create [#_"IFn" f, #_"Object" seed]
        (Iterate'new-3 f, nil, seed)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--Iterate [#_"Iterate" this]
        (not= (:_seed this) Iterate'UNREALIZED_SEED)
    )

    #_override
    (defn #_"Object" ISeq'''first--Iterate [#_"Iterate" this]
        (when (= (:_seed this) Iterate'UNREALIZED_SEED)
            (ร ass this (assoc this :_seed (.invoke (:f this), (:prevSeed this))))
        )
        (:_seed this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Iterate [#_"Iterate" this]
        (when (nil? (:_next this))
            (ร ass this (assoc this :_next (Iterate'new-3 (:f this), (.first this), Iterate'UNREALIZED_SEED)))
        )
        (:_next this)
    )

    #_override
    (defn #_"Iterate" IObj'''withMeta--Iterate [#_"Iterate" this, #_"IPersistentMap" meta]
        (Iterate'new-5 meta, (:f this), (:prevSeed this), (:_seed this), (:_next this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Iterate [#_"Iterate" this, #_"IFn" f]
        (loop [#_"Object" r (.first this) #_"Object" v (.invoke (:f this), r)]
            (let [r (.invoke f, r, v)]
                (when-not (RT'isReduced r) => (.deref (cast IDeref r))
                    (recur r (.invoke (:f this), v))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Iterate [#_"Iterate" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"Object" v (.first this)]
            (let [r (.invoke f, r, v)]
                (when-not (RT'isReduced r) => (.deref (cast IDeref r))
                    (recur r (.invoke (:f this), v))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(class-ns IteratorSeqState
    (defn- #_"IteratorSeqState" IteratorSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"IteratorSeqState" IteratorSeqState'new []
        (IteratorSeqState'init)
    )
)

(class-ns IteratorSeq
    (defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" iter]
        (when (.hasNext iter)
            (IteratorSeq'new-1 iter)
        )
    )

    (defn- #_"IteratorSeq" IteratorSeq'init []
        (hash-map
            #_"Iterator" :iter nil
            #_"IteratorSeqState" :state nil
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-1 [#_"Iterator" iter]
        (let [this (merge (ASeq'new-0) (IteratorSeq'init))
              this (assoc this :iter iter)
              this (assoc this :state (IteratorSeqState'new))
              _ (ร ass (:val (:state this)) (:state this))
              _ (ร ass (:_rest (:state this)) (:state this))]
            this
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-3 [#_"IPersistentMap" meta, #_"Iterator" iter, #_"IteratorSeqState" state]
        (let [this (merge (ASeq'new-1 meta) (IteratorSeq'init))]
            (assoc this :iter iter :state state)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--IteratorSeq [#_"IteratorSeq" this]
        (when (= (:val (:state this)) (:state this))
            (ยง sync (:state this)
                (when (= (:val (:state this)) (:state this))
                    (ร ass (:val (:state this)) (.next (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--IteratorSeq [#_"IteratorSeq" this]
        (when (= (:_rest (:state this)) (:state this))
            (ยง sync (:state this)
                (when (= (:_rest (:state this)) (:state this))
                    (.first this)
                    (ร ass (:_rest (:state this)) (IteratorSeq'create (:iter this)))
                )
            )
        )
        (cast ISeq (:_rest (:state this)))
    )

    #_override
    (defn #_"IteratorSeq" IObj'''withMeta--IteratorSeq [#_"IteratorSeq" this, #_"IPersistentMap" meta]
        (IteratorSeq'new-3 meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.Keyword

(class-ns Keyword
    (def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'TABLE (ConcurrentHashMap.))

    (def #_"ReferenceQueue" Keyword'RQ (ReferenceQueue.))

    (defn #_"Keyword" Keyword'intern [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" r (.get Keyword'TABLE, sym)
              [sym r #_"Keyword" k]
                (when (nil? r) => [sym r nil]
                    (Util'clearCache Keyword'RQ, Keyword'TABLE)
                    (let [sym
                            (when (some? (.meta sym)) => sym
                                (cast Symbol (.withMeta sym, nil))
                            )
                          k (Keyword'new sym)
                          r (.putIfAbsent Keyword'TABLE, sym, (WeakReference. #_"<Keyword>" k, Keyword'RQ))]
                        [sym r k]
                    )
                )]
            (when (some? r) => k
                (or (.get r)
                    (do ;; entry died in the interim, do over
                        (.remove Keyword'TABLE, sym, r)
                        (recur #_"Keyword'intern" sym)
                    )
                )
            )
        )
    )

    (defn- #_"Keyword" Keyword'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"int" :hasheq 0
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Keyword" Keyword'new [#_"Symbol" sym]
        (let [this (Keyword'init)]
            (assoc this :sym sym :hasheq (+ (.hasheq sym) 0x9e3779b9))
        )
    )

    (defn #_"Keyword" Keyword'find [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" ref (.get Keyword'TABLE, sym)]
            (when (some? ref)
                (.get ref)
            )
        )
    )

    (defn #_"Keyword" Keyword'find-2 [#_"String" ns, #_"String" name]
        (Keyword'find (Symbol'intern ns, name))
    )

    (defn #_"Keyword" Keyword'find-1 [#_"String" nsname]
        (Keyword'find (Symbol'intern nsname))
    )

    #_foreign
    (defn #_"int" hashCode---Keyword [#_"Keyword" this]
        (+ (.hashCode (:sym this)) 0x9e3779b9)
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--Keyword [#_"Keyword" this]
        (:hasheq this)
    )

    #_foreign
    (defn #_"String" toString---Keyword [#_"Keyword" this]
        (when (nil? (:_str this))
            (ร ass this (assoc this :_str (str ":" (:sym this))))
        )
        (:_str this)
    )

    #_method
    (defn #_"Object" Keyword''throwArity [#_"Keyword" this]
        (throw (IllegalArgumentException. (str "Wrong number of args passed to keyword: " this)))
    )

    #_foreign
    (defn #_"Object" call---Keyword [#_"Keyword" this]
        (Keyword''throwArity this)
    )

    #_foreign
    (defn #_"void" run---Keyword [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--Keyword [#_"Keyword" this]
        (Keyword''throwArity this)
    )

    #_foreign
    (defn #_"int" compareTo---Keyword [#_"Keyword" this, #_"Object" o]
        (.compareTo (:sym this), (:sym (cast Keyword o)))
    )

    #_override
    (defn #_"String" Named'''getNamespace--Keyword [#_"Keyword" this]
        (.getNamespace (:sym this))
    )

    #_override
    (defn #_"String" Named'''getName--Keyword [#_"Keyword" this]
        (.getName (:sym this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Keyword [#_"Keyword" this, #_"Object" obj]
        (if (instance? ILookup obj)
            (.valAt (cast ILookup obj), this)
            (RT'get-2 obj, this)
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Keyword [#_"Keyword" this, #_"Object" obj, #_"Object" notFound]
        (if (instance? ILookup obj)
            (.valAt (cast ILookup obj), this, notFound)
            (RT'get-3 obj, this, notFound)
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (Keyword''throwArity this)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (Keyword''throwArity this)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (Keyword''throwArity this)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''applyTo--Keyword [#_"Keyword" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite
    (defn- #_"KeywordLookupSite" KeywordLookupSite'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordLookupSite" KeywordLookupSite'new [#_"Keyword" k]
        (let [this (KeywordLookupSite'init)]
            (assoc this :k k)
        )
    )

    #_override
    (defn #_"ILookupThunk" ILookupSite'''fault--KeywordLookupSite [#_"KeywordLookupSite" this, #_"Object" target]
        (cond
            (instance? IKeywordLookup target) (KeywordLookupSite''install this, target)
            (instance? ILookup target)        (KeywordLookupSite''ilookupThunk this, (.getClass target))
            :else                             this
        )
    )

    #_override
    (defn #_"Object" ILookupThunk'''get--KeywordLookupSite [#_"KeywordLookupSite" this, #_"Object" target]
        (if (or (instance? IKeywordLookup target) (instance? ILookup target))
            this
            (RT'get-2 target, (:k this))
        )
    )

    #_method
    (defn- #_"ILookupThunk" KeywordLookupSite''ilookupThunk [#_"KeywordLookupSite" this, #_"Class" c]
        (reify ILookupThunk
            #_override
            (#_"Object" get [#_"ILookupThunk" self, #_"Object" target]
                (if (and (some? target) (= (.getClass target) c))
                    (.valAt (cast ILookup target), (:k this))
                    self
                )
            )
        )
    )

    #_method
    (defn- #_"ILookupThunk" KeywordLookupSite''install [#_"KeywordLookupSite" this, #_"Object" target]
        (or (.getLookupThunk (cast IKeywordLookup target), (:k this)) (KeywordLookupSite''ilookupThunk this, (.getClass target)))
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(class-ns LazilyPersistentVector
    (defn #_"IPersistentVector" LazilyPersistentVector'createOwning [& #_"Object..." items]
        (if (<= (alength items) 32)
            (PersistentVector'new-4 (alength items), 5, PersistentVector'EMPTY_NODE, items)
            (PersistentVector'create-1a items)
        )
    )

    (defn #_"int" LazilyPersistentVector'fcount [#_"Object" c]
        (if (instance? Counted c)
            (.count (cast Counted c))
            (.size (cast Collection c))
        )
    )

    (defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" obj]
        (cond
            (instance? IReduceInit obj) (PersistentVector'create-1r (cast IReduceInit obj))
            (instance? ISeq obj)        (PersistentVector'create-1s (RT'seq obj))
            (instance? Iterable obj)    (PersistentVector'create-1i (cast Iterable obj))
            :else                       (LazilyPersistentVector'createOwning (RT'toArray obj))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(class-ns LineNumberingPushbackReader
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (def- #_"int" LineNumberingPushbackReader'newline (int \newline))

    (defn- #_"LineNumberingPushbackReader" LineNumberingPushbackReader'init []
        (hash-map
            #_"boolean" :_atLineStart true
            #_"boolean" :_prev false
            #_"int" :_columnNumber 1
        )
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-1 [#_"Reader" r]
        (merge (ยง foreign PushbackReader'new (LineNumberReader. r)) (LineNumberingPushbackReader'init))
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-2 [#_"Reader" r, #_"int" size]
        (merge (ยง foreign PushbackReader'new (LineNumberReader. r, size)) (LineNumberingPushbackReader'init))
    )

    #_method
    (defn #_"int" LineNumberingPushbackReader''getLineNumber [#_"LineNumberingPushbackReader" this]
        (inc (.getLineNumber (cast LineNumberReader (ยง foreign in))))
    )

    #_method
    (defn #_"void" LineNumberingPushbackReader''setLineNumber [#_"LineNumberingPushbackReader" this, #_"int" line]
        (.setLineNumber (cast LineNumberReader (ยง foreign in)), (dec line))
        nil
    )

    #_method
    (defn #_"int" LineNumberingPushbackReader''getColumnNumber [#_"LineNumberingPushbackReader" this]
        (:_columnNumber this)
    )

    #_foreign
    (defn #_"int" read---LineNumberingPushbackReader [#_"LineNumberingPushbackReader" this]
        (let [#_"int" c (.read (ยง super ))]
            (ร ass this (assoc this :_prev (:_atLineStart this)))
            (if (or (= c LineNumberingPushbackReader'newline) (= c -1))
                (do
                    (ร ass this (assoc this :_atLineStart true))
                    (ร ass this (assoc this :_columnNumber 1))
                )
                (do
                    (ร ass this (assoc this :_atLineStart false))
                    (ร ass this (update this :_columnNumber inc))
                )
            )
            c
        )
    )

    #_foreign
    (defn #_"void" unread---LineNumberingPushbackReader [#_"LineNumberingPushbackReader" this, #_"int" c]
        (.unread (ยง super ), c)
        (ร ass this (assoc this :_atLineStart (:_prev this)))
        (ร ass this (update this :_columnNumber dec))
        nil
    )

    #_method
    (defn #_"String" LineNumberingPushbackReader''readLine [#_"LineNumberingPushbackReader" this]
        (let [#_"int" c (.read this)]
            (condp = c -1 nil LineNumberingPushbackReader'newline ""
                (let [#_"String" s (String/valueOf (char c)) #_"String" z (.readLine (cast LineNumberReader (ยง foreign in)))]
                    (ร ass this (assoc this :_prev false :_atLineStart true :_columnNumber 1))
                    (if (nil? z) s (str s z))
                )
            )
        )
    )

    #_method
    (defn #_"boolean" LineNumberingPushbackReader''atLineStart [#_"LineNumberingPushbackReader" this]
        (:_atLineStart this)
    )
)
)

(java-ns cloiure.lang.LispReader

(class-ns LispReaderException
    (defn- #_"LispReaderException" LispReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"LispReaderException" LispReaderException'new [#_"int" line, #_"int" column, #_"Throwable" cause]
        (let [this (merge (ยง foreign RuntimeException'new cause) (LispReaderException'init))]
            (assoc this :line line :column column)
        )
    )
)

(class-ns RegexReader
    (defn #_"Fn" RegexReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" doublequote, #_"Object" pendingForms]
            (let [#_"Reader" r (cast Reader reader) #_"StringBuilder" sb (StringBuilder.)]
                (loop []
                    (let-when [#_"int" ch (LispReader'read1 r)] (not= ch -1) => (throw (RuntimeException. "EOF while reading regex"))
                        (when-not (= ch \") ;; oops! "
                            (.append sb, (char ch))
                            (when (= ch \\) ;; escape
                                (let-when [ch (LispReader'read1 r)] (not= ch -1) => (throw (RuntimeException. "EOF while reading regex"))
                                    (.append sb, (char ch))
                                )
                            )
                            (recur)
                        )
                    )
                )
                (Pattern/compile (.toString sb))
            )
        )
    )
)

(class-ns StringReader
    (defn #_"Fn" StringReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" doublequote, #_"Object" pendingForms]
            (let [#_"StringBuilder" sb (StringBuilder.) #_"Reader" r (cast Reader reader)]
                (loop-when-recur [#_"int" ch (LispReader'read1 r)] (not= ch \") [(LispReader'read1 r)] ;; oops! "
                    (when (not= ch -1) => (throw (RuntimeException. "EOF while reading string"))
                        (let [ch
                                (when (= ch \\) => ch
                                    ;; escape
                                    (let [ch (LispReader'read1 r)]
                                        (when (not= ch -1) => (throw (RuntimeException. "EOF while reading string"))
                                            (case ch
                                                \t  \tab
                                                \r  \return
                                                \n  \newline
                                                \\  ch
                                                \"  ch ;; oops! "
                                                \b  \backspace
                                                \f  \formfeed
                                                \u  (let [ch (LispReader'read1 r)]
                                                        (when (= (Character/digit ch, 16) -1)
                                                            (throw (RuntimeException. (str "Invalid unicode escape: \\u" (char ch))))
                                                        )
                                                        (LispReader'readUnicodeChar-5 (cast PushbackReader r), ch, 16, 4, true)
                                                    )
                                                (when (Character/isDigit ch) => (throw (RuntimeException. (str "Unsupported escape character: \\" (char ch))))
                                                    (let [ch (LispReader'readUnicodeChar-5 (cast PushbackReader r), ch, 8, 3, false)]
                                                        (when (< 0377 ch)
                                                            (throw (RuntimeException. "Octal escape sequence must be in range [0, 377]."))
                                                        )
                                                        ch
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )]
                            (.append sb, (char ch))
                        )
                    )
                )
                (.toString sb)
            )
        )
    )
)

(class-ns CommentReader
    (defn #_"Fn" CommentReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" semicolon, #_"Object" pendingForms]
            (let [#_"Reader" r (cast Reader reader)]
                (while (not (any = (LispReader'read1 r) -1 \newline \return)))
                r
            )
        )
    )
)

(class-ns DiscardReader
    (defn #_"Fn" DiscardReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" underscore, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))
                r
            )
        )
    )
)

(class-ns NamespaceMapReader
    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    (defn #_"Fn" NamespaceMapReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" colon, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  #_"boolean" auto
                    (let [#_"int" autoChar (LispReader'read1 r)]
                        (or (= autoChar \:)
                            (do (LispReader'unread r, autoChar) false)
                        )
                    )
                  #_"int" nextChar (LispReader'read1 r)
                  [#_"Object" sym nextChar]
                    (cond
                        (LispReader'isWhitespace nextChar) ;; the #:: { } case or an error
                        (if auto
                            (let [nextChar (loop-when-recur nextChar (LispReader'isWhitespace nextChar) (LispReader'read1 r) => nextChar)]
                                (when (not= nextChar \{)
                                    (LispReader'unread r, nextChar)
                                    (throw (RuntimeException. "Namespaced map must specify a namespace"))
                                )
                                [nil nextChar]
                            )
                            (do
                                (LispReader'unread r, nextChar)
                                (throw (RuntimeException. "Namespaced map must specify a namespace"))
                            )
                        )
                        (not= nextChar \{) ;; #:foo { } or #::foo { }
                        (do
                            (LispReader'unread r, nextChar)
                            (let [sym (LispReader'read-5 r, true, nil, false, pendingForms)
                                  nextChar (LispReader'read1 r)
                                  nextChar (loop-when-recur nextChar (LispReader'isWhitespace nextChar) (LispReader'read1 r) => nextChar)]
                                [sym nextChar]
                            )
                        )
                        :else
                        (do
                            [nil nextChar]
                        )
                    )]
                (when (not= nextChar \{)
                    (throw (RuntimeException. "Namespaced map must specify a map"))
                )

                ;; resolve autoresolved ns
                (let [#_"String" ns
                        (cond auto
                            (cond (nil? sym)
                                (do
                                    (.getName (Namespace''getName (Compiler'currentNS)))
                                )
                                (or (not (instance? Symbol sym)) (some? (.getNamespace (cast Symbol sym))))
                                (do
                                    (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " sym)))
                                )
                                :else
                                (let [#_"Symbol" resolvedNS
                                        (when-let [#_"Namespace" rns (Namespace''lookupAlias (Compiler'currentNS), (cast Symbol sym))]
                                            (Namespace''getName rns)
                                        )]
                                    (when (some? resolvedNS) => (throw (RuntimeException. (str "Unknown auto-resolved namespace alias: " sym)))
                                        (.getName resolvedNS)
                                    )
                                )
                            )
                            (or (not (instance? Symbol sym)) (some? (.getNamespace (cast Symbol sym))))
                            (do
                                (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " sym)))
                            )
                            :else
                            (do
                                (.getName (cast Symbol sym))
                            )
                        )]

                    ;; read map
                    (let [#_"List" kvs (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms))]
                        (when (= (& (.size kvs) 1) 1)
                            (throw (RuntimeException. "Namespaced map literal must contain an even number of forms"))
                        )

                        ;; construct output map
                        (let [#_"Object[]" a (make-array Object (.size kvs)) #_"Iterator" it (.iterator kvs)]
                            (loop-when-recur [#_"int" i 0] (.hasNext it) [(+ i 2)]
                                (let [#_"Object" key (.next it) #_"Object" val (.next it)
                                      _ (cond
                                            (instance? Keyword key)
                                            (let [#_"Keyword" kw (cast Keyword key)]
                                                (cond
                                                    (nil? (.getNamespace kw))  (Keyword'intern (Symbol'intern ns, (.getName kw)))
                                                    (= (.getNamespace kw) "_") (Keyword'intern (Symbol'intern nil, (.getName kw)))
                                                )
                                            )
                                            (instance? Symbol key)
                                            (let [#_"Symbol" s (cast Symbol key)]
                                                (cond
                                                    (nil? (.getNamespace s))  (Symbol'intern ns, (.getName s))
                                                    (= (.getNamespace s) "_") (Symbol'intern nil, (.getName s))
                                                )
                                            )
                                        )]
                                    (aset a i (or _ key))
                                    (aset a (inc i) val)
                                )
                            )
                            (RT'map a)
                        )
                    )
                )
            )
        )
    )
)

(class-ns SymbolicValueReader
    (ยง def #_"IPersistentMap" SymbolicValueReader'specials (PersistentHashMap'create-1a
        (object-array [
            (Symbol'intern "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern "NaN")  Double/NaN
        ])
    ))

    (defn #_"Fn" SymbolicValueReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (when-not (instance? Symbol o)
                    (throw (RuntimeException. (str "Invalid token: ##" o)))
                )
                (when-not (.containsKey SymbolicValueReader'specials, o)
                    (throw (RuntimeException. (str "Unknown symbolic value: ##" o)))
                )
                (.valAt SymbolicValueReader'specials, o)
            )
        )
    )
)

(class-ns WrappingReader
    (defn #_"Fn" WrappingReader'new [#_"Symbol" sym]
        (fn #_"Object" [#_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (RT'list-2 sym, o)
            )
        )
    )
)

(class-ns VarReader
    (defn #_"Fn" VarReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (RT'list-2 LispReader'THE_VAR, o)
            )
        )
    )
)

(class-ns DispatchReader
    (defn #_"Fn" DispatchReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" hash, #_"Object" pendingForms]
            (let-when-not [#_"int" ch (LispReader'read1 (cast Reader reader))] (= ch -1) => (throw (RuntimeException. "EOF while reading character"))
                (let-when-not [#_"IFn" fn (aget LispReader'dispatchMacros ch)] (some? fn) => (.invoke fn, reader, ch, pendingForms)
                    (LispReader'unread (cast PushbackReader reader), ch)
                    (throw (RuntimeException. (str "No dispatch macro for: " (char ch))))
                )
            )
        )
    )
)

(class-ns FnReader
    (defn #_"Fn" FnReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" lparen, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (when (some? (.deref LispReader'ARG_ENV))
                    (throw (IllegalStateException. "Nested #()s are not allowed"))
                )
                (try
                    (Var'pushThreadBindings (RT'map LispReader'ARG_ENV, PersistentTreeMap'EMPTY))
                    (LispReader'unread r, \()
                    (let [#_"Object" form (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))
                          #_"PersistentVector" args PersistentVector'EMPTY
                          #_"PersistentTreeMap" argsyms (cast PersistentTreeMap (.deref LispReader'ARG_ENV))
                          args
                            (let-when [#_"ISeq" rargs (.rseq argsyms)] (some? rargs) => args
                                (let [args
                                        (let-when [#_"int" higharg (cast Integer (.getKey (cast Map$Entry (.first rargs))))] (pos? higharg) => args
                                            (loop-when [args args #_"int" i 1] (<= i higharg) => args
                                                (let [#_"Object" sym (or (.valAt argsyms, i) (LispReader'garg i))]
                                                    (recur (.cons args, sym) (inc i))
                                                )
                                            )
                                        )]
                                    (let-when [#_"Object" restsym (.valAt argsyms, -1)] (some? restsym) => args
                                        (-> args (.cons Compiler'_AMP_) (.cons restsym))
                                    )
                                )
                            )]
                        (RT'list-3 Compiler'FN, args, form)
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )
)

(class-ns ArgReader
    (defn #_"Fn" ArgReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" pct, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (when (some? (.deref LispReader'ARG_ENV)) => (LispReader'interpretToken (LispReader'readToken r, \%))
                    (let [#_"int" ch (LispReader'read1 r) _ (LispReader'unread r, ch)]
                        ;; % alone is first arg
                        (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isTerminatingMacro ch))
                            (LispReader'registerArg 1)
                            (let [#_"Object" n (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                                (cond
                                    (.equals n, Compiler'_AMP_) (LispReader'registerArg -1)
                                    (instance? Number n)        (LispReader'registerArg (.intValue (cast Number n)))
                                    :else                       (throw (IllegalStateException. "arg literal must be %, %& or %integer"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns MetaReader
    (defn #_"Fn" MetaReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" caret, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  [#_"int" line #_"int" column]
                    (when (instance? LineNumberingPushbackReader r) => [-1 -1]
                        [(LineNumberingPushbackReader''getLineNumber (cast LineNumberingPushbackReader r)) (dec (LineNumberingPushbackReader''getColumnNumber (cast LineNumberingPushbackReader r)))]
                    )
                  pendingForms (LispReader'ensurePending pendingForms)
                  #_"Object" meta (LispReader'read-5 r, true, nil, true, pendingForms)
                  meta
                    (cond
                        (or (instance? Symbol meta) (instance? String meta)) (RT'map RT'TAG_KEY, meta)
                        (instance? Keyword meta)                             (RT'map meta, RT'T)
                        (instance? IPersistentMap meta)                      meta
                        :else (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                    )
                  #_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                (when (instance? IMeta o) => (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                    (let [meta
                            (when (and (not= line -1) (instance? ISeq o)) => meta
                                (-> (cast IPersistentMap meta) (.assoc RT'LINE_KEY, line) (.assoc RT'COLUMN_KEY, column))
                            )]
                        (if (instance? IReference o)
                            (do
                                (.resetMeta (cast IReference o), (cast IPersistentMap meta))
                                o
                            )
                            (let [#_"Object" ometa
                                    (loop-when [ometa (RT'meta o) #_"ISeq" s (RT'seq meta)] (some? s) => ometa
                                        (let [#_"IMapEntry" kv (cast IMapEntry (.first s))]
                                            (recur (RT'assoc ometa, (.getKey kv), (.getValue kv)) (.next s))
                                        )
                                    )]
                                (.withMeta (cast IObj o), (cast IPersistentMap ometa))
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns SyntaxQuoteReader
    (defn #_"Fn" SyntaxQuoteReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" backquote, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (try
                    (Var'pushThreadBindings (RT'map LispReader'GENSYM_ENV, PersistentHashMap'EMPTY))
                    (let [#_"Object" form (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                        (SyntaxQuoteReader'syntaxQuote form)
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    (defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" form]
        (let [#_"Object" ret
                (cond
                    (Compiler'isSpecial form)
                        (RT'list-2 Compiler'QUOTE, form)
                    (instance? Symbol form)
                        (let [#_"Symbol" sym (cast Symbol form)
                              sym
                                (cond
                                    (and (nil? (:ns sym)) (.endsWith (:name sym), "#"))
                                        (let-when [#_"IPersistentMap" gmap (cast IPersistentMap (.deref LispReader'GENSYM_ENV))] (some? gmap) => (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                            (or (cast Symbol (.valAt gmap, sym))
                                                (let [#_"Symbol" gs (Symbol'intern nil, (str (.substring (:name sym), 0, (dec (.length (:name sym)))) "__" (RT'nextID) "__auto__"))]
                                                    (Var''set LispReader'GENSYM_ENV, (.assoc gmap, sym, gs))
                                                    gs
                                                )
                                            )
                                        )
                                    (and (nil? (:ns sym)) (.endsWith (:name sym), "."))
                                        (let [#_"Symbol" csym (Symbol'intern nil, (.substring (:name sym), 0, (dec (.length (:name sym)))))]
                                            (Symbol'intern nil, (.concat (:name (Compiler'resolveSymbol csym)), "."))
                                        )
                                    (and (nil? (:ns sym)) (.startsWith (:name sym), "."))
                                        sym ;; Simply quote method names.
                                    :else
                                        (let [#_"Object" maybeClass (when (some? (:ns sym)) (Namespace''getMapping (Compiler'currentNS), (Symbol'intern nil, (:ns sym))))]
                                            (when (instance? Class maybeClass) => (Compiler'resolveSymbol sym)
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (Symbol'intern (.getName (cast Class maybeClass)), (:name sym))
                                            )
                                        )
                                )]
                            (RT'list-2 Compiler'QUOTE, sym)
                        )
                    (LispReader'isUnquote form)
                        (ร return (RT'second form))
                    (LispReader'isUnquoteSplicing form)
                        (throw (IllegalStateException. "splice not in list"))
                    (instance? IPersistentCollection form)
                        (cond
                            (instance? IPersistentMap form)
                                (let [#_"IPersistentVector" keyvals (SyntaxQuoteReader'flattenMap form)]
                                    (RT'list-3 LispReader'APPLY, LispReader'HASHMAP, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (.seq keyvals)))))
                                )
                            (instance? IPersistentVector form)
                                (RT'list-3 LispReader'APPLY, LispReader'VECTOR, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (.seq (cast IPersistentVector form))))))
                            (instance? IPersistentSet form)
                                (RT'list-3 LispReader'APPLY, LispReader'HASHSET, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (.seq (cast IPersistentSet form))))))
                            (or (instance? ISeq form) (instance? IPersistentList form))
                                (let [#_"ISeq" seq (RT'seq form)]
                                    (if (some? seq)
                                        (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList seq)))
                                        (RT'cons LispReader'LIST, nil)
                                    )
                                )
                            :else
                                (throw (UnsupportedOperationException. "Unknown collection type"))
                        )
                    (or (instance? Keyword form) (instance? Number form) (instance? Character form) (instance? String form))
                        form
                    :else
                        (RT'list-2 Compiler'QUOTE, form)
                )]
            (when (and (instance? IObj form) (some? (RT'meta form))) => ret
                ;; filter line and column numbers
                (when (pos? (.count (.without (.without (.meta (cast IObj form)), RT'LINE_KEY), RT'COLUMN_KEY))) => ret
                    (RT'list-3 LispReader'WITH_META, ret, (SyntaxQuoteReader'syntaxQuote (.meta (cast IObj form))))
                )
            )
        )
    )

    (defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" seq]
        (loop-when [#_"PersistentVector" v PersistentVector'EMPTY seq seq] (some? seq) => (.seq v)
            (let [#_"Object" item (.first seq)
                  v (cond
                        (LispReader'isUnquote item)         (.cons v, (RT'list-2 LispReader'LIST, (RT'second item)))
                        (LispReader'isUnquoteSplicing item) (.cons v, (RT'second item))
                        :else                               (.cons v, (RT'list-2 LispReader'LIST, (SyntaxQuoteReader'syntaxQuote item)))
                    )]
                (recur v (.next seq))
            )
        )
    )

    (defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" form]
        (loop-when [#_"IPersistentVector" keyvals PersistentVector'EMPTY #_"ISeq" s (RT'seq form)] (some? s) => keyvals
            (let [#_"IMapEntry" e (cast IMapEntry (.first s))
                  keyvals (cast IPersistentVector (.cons keyvals, (.key e)))
                  keyvals (cast IPersistentVector (.cons keyvals, (.val e)))]
                (recur keyvals (.next s))
            )
        )
    )
)

(class-ns UnquoteReader
    (defn #_"Fn" UnquoteReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" comma, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (let-when [#_"int" ch (LispReader'read1 r)] (not= ch -1) => (throw (RuntimeException. "EOF while reading character"))
                    (let [pendingForms (LispReader'ensurePending pendingForms)]
                        (if (= ch \@)
                            (let [#_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                                (RT'list-2 LispReader'UNQUOTE_SPLICING, o)
                            )
                            (do
                                (LispReader'unread r, ch)
                                (let [#_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                                    (RT'list-2 LispReader'UNQUOTE, o)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns CharacterReader
    (defn #_"Fn" CharacterReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" backslash, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader) #_"int" ch (LispReader'read1 r)]
                (when-not (= ch -1) => (throw (RuntimeException. "EOF while reading character"))
                    (let [#_"String" token (LispReader'readToken r, (char ch))]
                        (when-not (= (.length token) 1) => (Character/valueOf (.charAt token, 0))
                            (case token
                                "newline"   \newline
                                "space"     \space
                                "tab"       \tab
                                "backspace" \backspace
                                "formfeed"  \formfeed
                                "return"    \return
                                (cond
                                    (.startsWith token, "u")
                                        (let [#_"char" c (char (LispReader'readUnicodeChar-4 token, 1, 4, 16))]
                                            (when (<= (ยง char "\ud800") c (ยง char "\udfff")) ;; surrogate code unit?
                                                (throw (RuntimeException. (str "Invalid character constant: \\u" (Integer/toString c, 16))))
                                            )
                                            c
                                        )
                                    (.startsWith token, "o")
                                        (let [#_"int" len (dec (.length token))]
                                            (when (< 3 len)
                                                (throw (RuntimeException. (str "Invalid octal escape sequence length: " len)))
                                            )
                                            (let [#_"int" uc (LispReader'readUnicodeChar-4 token, 1, len, 8)]
                                                (when (< 0377 uc)
                                                    (throw (RuntimeException. "Octal escape sequence must be in range [0, 377]."))
                                                )
                                                (char uc)
                                            )
                                        )
                                    :else
                                        (throw (RuntimeException. (str "Unsupported character: \\" token)))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns ListReader
    (defn #_"Fn" ListReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  [#_"int" line #_"int" column]
                    (when (instance? LineNumberingPushbackReader r) => [-1 -1]
                        [(LineNumberingPushbackReader''getLineNumber (cast LineNumberingPushbackReader r)) (dec (LineNumberingPushbackReader''getColumnNumber (cast LineNumberingPushbackReader r)))]
                    )
                  #_"List" l (LispReader'readDelimitedList \), r, true, (LispReader'ensurePending pendingForms))]
                (when-not (.isEmpty l) => PersistentList'EMPTY
                    (let [#_"IObj" s (cast IObj (PersistentList'create l))]
                        (when-not (= line -1) => s
                            (.withMeta s, (RT'map
                                (object-array [
                                    RT'LINE_KEY   line
                                    RT'COLUMN_KEY column
                                ])
                            ))
                        )
                    )
                )
            )
        )
    )
)

(class-ns VectorReader
    (defn #_"Fn" VectorReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (LazilyPersistentVector'create (LispReader'readDelimitedList \], r, true, (LispReader'ensurePending pendingForms)))
            )
        )
    )
)

(class-ns MapReader
    (defn #_"Fn" MapReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  #_"Object[]" a (.toArray (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms)))]
                (when (= (& (alength a) 1) 1)
                    (throw (RuntimeException. "Map literal must contain an even number of forms"))
                )
                (RT'map a)
            )
        )
    )
)

(class-ns SetReader
    (defn #_"Fn" SetReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" leftbracket, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (cast PushbackReader reader)]
                (PersistentHashSet'createWithCheck-1l (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms)))
            )
        )
    )
)

(class-ns UnmatchedDelimiterReader
    (defn #_"Fn" UnmatchedDelimiterReader'new []
        (fn #_"Object" [#_"Object" reader, #_"Object" rightdelim, #_"Object" pendingForms]
            (throw (RuntimeException. (str "Unmatched delimiter: " rightdelim)))
        )
    )
)

(class-ns LispReader
    (ยง def #_"Symbol" LispReader'QUOTE (Symbol'intern "quote"))
    (ยง def #_"Symbol" LispReader'THE_VAR (Symbol'intern "var"))

    (ยง def #_"Symbol" LispReader'UNQUOTE (Symbol'intern "cloiure.core", "unquote"))
    (ยง def #_"Symbol" LispReader'UNQUOTE_SPLICING (Symbol'intern "cloiure.core", "unquote-splicing"))
    (ยง def #_"Symbol" LispReader'CONCAT (Symbol'intern "cloiure.core", "concat"))
    (ยง def #_"Symbol" LispReader'SEQ (Symbol'intern "cloiure.core", "seq"))
    (ยง def #_"Symbol" LispReader'LIST (Symbol'intern "cloiure.core", "list"))
    (ยง def #_"Symbol" LispReader'APPLY (Symbol'intern "cloiure.core", "apply"))
    (ยง def #_"Symbol" LispReader'HASHMAP (Symbol'intern "cloiure.core", "hash-map"))
    (ยง def #_"Symbol" LispReader'HASHSET (Symbol'intern "cloiure.core", "hash-set"))
    (ยง def #_"Symbol" LispReader'VECTOR (Symbol'intern "cloiure.core", "vector"))
    (ยง def #_"Symbol" LispReader'WITH_META (Symbol'intern "cloiure.core", "with-meta"))
    (ยง def #_"Symbol" LispReader'META (Symbol'intern "cloiure.core", "meta"))
    (ยง def #_"Symbol" LispReader'DEREF (Symbol'intern "cloiure.core", "deref"))

    (def #_"IFn[]" LispReader'macros (make-array #_"IFn" Object 256))
    (def #_"IFn[]" LispReader'dispatchMacros (make-array #_"IFn" Object 256))

    (def #_"Pattern" LispReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" LispReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" LispReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" LispReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (ยง def #_"Var" LispReader'GENSYM_ENV (Var''setDynamic-1 (Var'create nil)))
    ;; sorted-map num->gensymbol
    (ยง def #_"Var" LispReader'ARG_ENV (Var''setDynamic-1 (Var'create nil)))

    (ยง static
        (aset LispReader'macros \" (StringReader'new)) ;; oops! "
        (aset LispReader'macros \; (CommentReader'new))
        (aset LispReader'macros \' (WrappingReader'new LispReader'QUOTE))
        (aset LispReader'macros \@ (WrappingReader'new LispReader'DEREF))
        (aset LispReader'macros \^ (MetaReader'new))
        (aset LispReader'macros \` (SyntaxQuoteReader'new))
        (aset LispReader'macros \~ (UnquoteReader'new))
        (aset LispReader'macros \( (ListReader'new))
        (aset LispReader'macros \) (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \[ (VectorReader'new))
        (aset LispReader'macros \] (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \{ (MapReader'new))
        (aset LispReader'macros \} (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \\ (CharacterReader'new))
        (aset LispReader'macros \% (ArgReader'new))
        (aset LispReader'macros \# (DispatchReader'new))

        (aset LispReader'dispatchMacros \^ (MetaReader'new))
        (aset LispReader'dispatchMacros \# (SymbolicValueReader'new))
        (aset LispReader'dispatchMacros \' (VarReader'new))
        (aset LispReader'dispatchMacros \" (RegexReader'new)) ;; oops! "
        (aset LispReader'dispatchMacros \( (FnReader'new))
        (aset LispReader'dispatchMacros \{ (SetReader'new))
        (aset LispReader'dispatchMacros \! (CommentReader'new))
        (aset LispReader'dispatchMacros \_ (DiscardReader'new))
        (aset LispReader'dispatchMacros \: (NamespaceMapReader'new))
    )

    (defn #_"boolean" LispReader'isWhitespace [#_"int" ch]
        (or (Character/isWhitespace ch) (= ch \,))
    )

    (defn #_"void" LispReader'unread [#_"PushbackReader" r, #_"int" ch]
        (when-not (= ch -1)
            (.unread r, ch)
        )
        nil
    )

    (defn #_"int" LispReader'read1 [#_"Reader" r]
        (.read r)
    )

    ;; Reader opts
    (ยง def #_"Keyword" LispReader'OPT_EOF (Keyword'intern (Symbol'intern nil, "eof")))

    ;; EOF special value to throw on eof
    (ยง def #_"Keyword" LispReader'EOFTHROW (Keyword'intern (Symbol'intern nil, "eofthrow")))

    (defn #_"Object" LispReader'read-1 [#_"PushbackReader" r]
        (LispReader'read-4 r, true, nil, false)
    )

    (defn #_"Object" LispReader'read-4 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (LispReader'read-7 r, eofIsError, eofValue, nil, nil, isRecursive, nil)
    )

    (defn- #_"Object" LispReader'read-5 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" pendingForms]
        (LispReader'read-7 r, eofIsError, eofValue, nil, nil, isRecursive, (LispReader'ensurePending pendingForms))
    )

    (defn- #_"Object" LispReader'ensurePending [#_"Object" pendingForms]
        (or pendingForms (LinkedList.))
    )

    (defn- #_"Object" LispReader'read-7 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"Character" returnOn, #_"Object" returnOnValue, #_"boolean" isRecursive, #_"Object" pendingForms]
        (try
            (loop-when [] (or (not (instance? List pendingForms)) (.isEmpty (cast List pendingForms))) => (.remove (cast List pendingForms), 0)
                (let [#_"int" ch (loop-when-recur [ch (LispReader'read1 r)] (LispReader'isWhitespace ch) [(LispReader'read1 r)] => ch)]
                    (cond
                        (= ch -1)
                            (if eofIsError (throw (RuntimeException. "EOF while reading")) eofValue)
                        (and (some? returnOn) (= (.charValue returnOn) ch))
                            returnOnValue
                        (Character/isDigit ch)
                            (LispReader'readNumber r, (char ch))
                        :else
                            (let [#_"IFn" macroFn (LispReader'getMacro ch)]
                                (if (some? macroFn)
                                    (let [#_"Object" ret (.invoke macroFn, r, (char ch), pendingForms)]
                                        ;; no op macros return the reader
                                        (recur-if (= ret r) [] => ret)
                                    )
                                    (do
                                        (when (any = ch \+ \-)
                                            (let [#_"int" ch2 (LispReader'read1 r)]
                                                (when (Character/isDigit ch2)
                                                    (LispReader'unread r, ch2)
                                                    (ร return (LispReader'readNumber r, (char ch)))
                                                )
                                                (LispReader'unread r, ch2)
                                            )
                                        )
                                        (LispReader'interpretToken (LispReader'readToken r, (char ch)))
                                    )
                                )
                            )
                    )
                )
            )
            (catch Exception e
                (when (and (not isRecursive) (instance? LineNumberingPushbackReader r)) => (throw e)
                    (let [#_"LineNumberingPushbackReader" rdr (cast LineNumberingPushbackReader r)]
                        (throw (LispReaderException'new (LineNumberingPushbackReader''getLineNumber rdr), (LineNumberingPushbackReader''getColumnNumber rdr), e))
                    )
                )
            )
        )
    )

    (defn- #_"String" LispReader'readToken [#_"PushbackReader" r, #_"char" ch]
        (let [#_"StringBuilder" sb (StringBuilder.) _ (.append sb, ch)]
            (loop []
                (let [ch (LispReader'read1 r)]
                    (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isTerminatingMacro ch))
                        (do
                            (LispReader'unread r, ch)
                            (.toString sb)
                        )
                        (do
                            (.append sb, (char ch))
                            (recur)
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'readNumber [#_"PushbackReader" r, #_"char" ch]
        (let [#_"String" s
                (let [#_"StringBuilder" sb (StringBuilder.) _ (.append sb, ch)]
                    (loop []
                        (let [ch (LispReader'read1 r)]
                            (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isMacro ch))
                                (do
                                    (LispReader'unread r, ch)
                                    (.toString sb)
                                )
                                (do
                                    (.append sb, (char ch))
                                    (recur)
                                )
                            )
                        )
                    )
                )]
            (or (LispReader'matchNumber s) (throw (NumberFormatException. (str "Invalid number: " s))))
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-4 [#_"String" token, #_"int" offset, #_"int" n, #_"int" base]
        (when (= (.length token) (+ offset n)) => (throw (IllegalArgumentException. (str "Invalid unicode character: \\" token)))
            (loop-when [#_"int" uc 0 #_"int" i offset] (< i (+ offset n)) => (char uc)
                (let [#_"int" d (Character/digit (.charAt token, i), base)]
                    (when-not (= d -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt token, i))))
                        (recur (+ (* uc base) d) (inc i))
                    )
                )
            )
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-5 [#_"PushbackReader" r, #_"int" ch, #_"int" base, #_"int" n, #_"boolean" exact?]
        (let-when-not [#_"int" uc (Character/digit ch, base)] (= uc -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (char ch))))
            (let [[uc #_"int" i]
                    (loop-when [uc uc i 1] (< i n) => [uc i]
                        (let [ch (LispReader'read1 r)]
                            (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isMacro ch))
                                (do
                                    (LispReader'unread r, ch)
                                    [uc i]
                                )
                                (let [#_"int" d (Character/digit ch, base)]
                                    (when-not (= d -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (char ch))))
                                        (recur (+ (* uc base) d) (inc i))
                                    )
                                )
                            )
                        )
                    )]
                (when (or (= i n) (not exact?)) => (throw (IllegalArgumentException. (str "Invalid character length: " i ", should be: " n)))
                    uc
                )
            )
        )
    )

    (defn- #_"Object" LispReader'interpretToken [#_"String" s]
        (case s "nil" nil "true" RT'T "false" RT'F
            (or (LispReader'matchSymbol s) (throw (RuntimeException. (str "Invalid token: " s))))
        )
    )

    (defn- #_"Object" LispReader'matchSymbol [#_"String" s]
        (let-when [#_"Matcher" m (.matcher LispReader'symbolPat, s)] (.matches m)
            (let [#_"int" gc (.groupCount m) #_"String" ns (.group m, 1) #_"String" name (.group m, 2)]
                (cond
                    (or (and (some? ns) (.endsWith ns, ":/")) (.endsWith name, ":") (not= (.indexOf s, "::", 1) -1))
                        nil
                    (.startsWith s, "::")
                        (let [#_"Symbol" ks (Symbol'intern (.substring s, 2))
                              #_"Namespace" kns (if (some? (:ns ks)) (Namespace''lookupAlias (Compiler'currentNS), (Symbol'intern (:ns ks))) (Compiler'currentNS))]
                            ;; auto-resolving keyword
                            (when (some? kns)
                                (Keyword'intern (Symbol'intern (:name (:name kns)), (:name ks)))
                            )
                        )
                    :else
                        (let [#_"boolean" isKeyword (= (.charAt s, 0) \:) #_"Symbol" sym (Symbol'intern (.substring s, (if isKeyword 1 0)))]
                            (if isKeyword (Keyword'intern sym) sym)
                        )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'matchNumber [#_"String" s]
        (let [_ (or
                    (let-when [#_"Matcher" m (.matcher LispReader'intPat, s)] (.matches m)
                        (if (some? (.group m, 2))
                            (if (some? (.group m, 8))
                                BigInt'ZERO
                                (Numbers'num-1l 0)
                            )
                            (let [[#_"String" n #_"int" radix]
                                    (cond-let
                                        [n (.group m, 3)] [n 10]
                                        [n (.group m, 4)] [n 16]
                                        [n (.group m, 5)] [n 8]
                                        [n (.group m, 7)] [n (Integer/parseInt (.group m, 6))]
                                    )]
                                (when (some? n) => :nil
                                    (let [#_"BigInteger" bn (BigInteger. n, radix) bn (if (= (.group m, 1) "-") (.negate bn) bn)]
                                        (cond
                                            (some? (.group m, 8))  (BigInt'fromBigInteger bn)
                                            (< (.bitLength bn) 64) (Numbers'num-1l (.longValue bn))
                                            :else                  (BigInt'fromBigInteger bn)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (let-when [#_"Matcher" m (.matcher LispReader'floatPat, s)] (.matches m)
                        (if (some? (.group m, 4))
                            (BigDecimal. (.group m, 1))
                            (Double/parseDouble s)
                        )
                    )
                    (let-when [#_"Matcher" m (.matcher LispReader'ratioPat, s)] (.matches m)
                        (let [#_"String" numerator (.group m, 1) numerator (if (.startsWith numerator, "+") (.substring numerator, 1) numerator)]
                            (Numbers'divide-2oo
                                (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. numerator))),
                                (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. (.group m, 2))))
                            )
                        )
                    )
                )]
            (when-not (= _ :nil) _)
        )
    )

    (defn- #_"IFn" LispReader'getMacro [#_"int" ch]
        (when (< ch (alength LispReader'macros))
            (aget LispReader'macros ch)
        )
    )

    (defn- #_"boolean" LispReader'isMacro [#_"int" ch]
        (and (< ch (alength LispReader'macros)) (some? (aget LispReader'macros ch)))
    )

    (defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ch]
        (and (not= ch \#) (not= ch \') (not= ch \%) (LispReader'isMacro ch))
    )

    (defn #_"Symbol" LispReader'garg [#_"int" n]
        (Symbol'intern nil, (str (if (= n -1) "rest" (str "p" n)) "__" (RT'nextID) "#"))
    )

    (defn #_"Symbol" LispReader'registerArg [#_"int" n]
        (let [#_"PersistentTreeMap" args (cast PersistentTreeMap (.deref LispReader'ARG_ENV))]
            (when (some? args) => (throw (IllegalStateException. "arg literal not in #()"))
                (or (cast Symbol (.valAt args, n))
                    (let [#_"Symbol" sym (LispReader'garg n)]
                        (Var''set LispReader'ARG_ENV, (.assoc args, n, sym))
                        sym
                    )
                )
            )
        )
    )

    (defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" form]
        (and (instance? ISeq form) (Util'equals (RT'first form), LispReader'UNQUOTE_SPLICING))
    )

    (defn #_"boolean" LispReader'isUnquote [#_"Object" form]
        (and (instance? ISeq form) (Util'equals (RT'first form), LispReader'UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (def- #_"Object" LispReader'READ_EOF (Object.))
    (def- #_"Object" LispReader'READ_FINISHED (Object.))

    (defn #_"List" LispReader'readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" pendingForms]
        (let [#_"int" firstline (if (instance? LineNumberingPushbackReader r) (LineNumberingPushbackReader''getLineNumber (cast LineNumberingPushbackReader r)) -1)
              #_"List" a (ArrayList.)]
            (loop []
                (let [#_"Object" form (LispReader'read-7 r, false, LispReader'READ_EOF, delim, LispReader'READ_FINISHED, isRecursive, pendingForms)]
                    (condp = form
                        LispReader'READ_EOF
                            (if (neg? firstline)
                                (throw (RuntimeException. "EOF while reading"))
                                (throw (RuntimeException. (str "EOF while reading, starting at line " firstline)))
                            )
                        LispReader'READ_FINISHED
                            a
                        (do
                            (.add a, form)
                            (recur)
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(class-ns RetryEx
    (defn #_"RetryEx" RetryEx'new []
        (ยง foreign Error'new)
    )
)

(class-ns AbortException
    (defn #_"AbortException" AbortException'new []
        (ยง foreign Exception'new)
    )
)

(class-ns LockingTransactionInfo
    (defn- #_"LockingTransactionInfo" LockingTransactionInfo'init []
        (hash-map
            #_"AtomicInteger" :status nil
            #_"long" :startPoint 0
            #_"CountDownLatch" :latch nil
        )
    )

    (defn #_"LockingTransactionInfo" LockingTransactionInfo'new [#_"int" status, #_"long" startPoint]
        (let [this (LockingTransactionInfo'init)]
            (assoc this :status (AtomicInteger. status) :startPoint startPoint :latch (CountDownLatch. 1))
        )
    )

    #_method
    (defn #_"boolean" LockingTransactionInfo''running [#_"LockingTransactionInfo" this]
        (let [#_"int" s (.get (:status this))]
            (or (= s LockingTransaction'RUNNING) (= s LockingTransaction'COMMITTING))
        )
    )
)

(class-ns CFn
    (defn- #_"CFn" CFn'init []
        (hash-map
            #_"IFn" :fn nil
            #_"ISeq" :args nil
        )
    )

    (defn #_"CFn" CFn'new [#_"IFn" fn, #_"ISeq" args]
        (let [this (CFn'init)]
            (assoc this :fn fn :args args)
        )
    )
)

(class-ns Notify
    (defn- #_"Notify" Notify'init []
        (hash-map
            #_"Ref" :ref nil
            #_"Object" :oldval nil
            #_"Object" :newval nil
        )
    )

    (defn #_"Notify" Notify'new [#_"Ref" ref, #_"Object" oldval, #_"Object" newval]
        (let [this (Notify'init)]
            (assoc this :ref ref :oldval oldval :newval newval)
        )
    )
)

(class-ns LockingTransaction
    (def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (def #_"long" LockingTransaction'BARGE_WAIT_NANOS (* 10 1000000))

    (def #_"int" LockingTransaction'RUNNING 0)
    (def #_"int" LockingTransaction'COMMITTING 1)
    (def #_"int" LockingTransaction'RETRY 2)
    (def #_"int" LockingTransaction'KILLED 3)
    (def #_"int" LockingTransaction'COMMITTED 4)

    (def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ThreadLocal.))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (defn- #_"LockingTransaction" LockingTransaction'init []
        (hash-map
            #_"LockingTransactionInfo" :info nil
            #_"long" :readPoint 0
            #_"long" :startPoint 0
            #_"long" :startTime 0

            #_"RetryEx" :retryex (RetryEx'new)
            #_"List<AgentAction>" :actions (ArrayList.)
            #_"HashMap<Ref, Object>" :vals (HashMap.)
            #_"HashSet<Ref>" :sets (HashSet.)
            #_"TreeMap<Ref, List<CFn>>" :commutes (TreeMap.)

            #_"HashSet<Ref>" :ensures (HashSet.) ;; all hold readLock
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'new []
        (LockingTransaction'init)
    )

    #_method
    (defn #_"void" LockingTransaction''getReadPoint [#_"LockingTransaction" this]
        (ร ass this (assoc this :readPoint (.incrementAndGet LockingTransaction'lastPoint)))
        nil
    )

    #_method
    (defn #_"long" LockingTransaction''getCommitPoint [#_"LockingTransaction" this]
        (.incrementAndGet LockingTransaction'lastPoint)
    )

    #_method
    (defn #_"void" LockingTransaction''stop [#_"LockingTransaction" this, #_"int" status]
        (when (some? (:info this))
            (ยง sync (:info this)
                (.set (:status (:info this)), status)
                (.countDown (:latch (:info this)))
            )
            (ร ass this (assoc this :info nil))
            (.clear (:vals this))
            (.clear (:sets this))
            (.clear (:commutes this))
        )
        nil
    )

    #_method
    (defn #_"void" LockingTransaction''tryWriteLock [#_"LockingTransaction" this, #_"Ref" ref]
        (try
            (when (not (.tryLock (.writeLock (:lock ref)), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
                (throw (:retryex this))
            )
            (catch InterruptedException e
                (throw (:retryex this))
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (defn #_"Object" LockingTransaction''lock [#_"LockingTransaction" this, #_"Ref" ref]
        ;; can't upgrade readLock, so release it
        (LockingTransaction''releaseIfEnsured this, ref)

        (let [#_"boolean" unlocked true]
            (try
                (LockingTransaction''tryWriteLock this, ref)
                (ร ass unlocked false)

                (when-not (and (some? (:tvals ref)) (< (:readPoint this) (:point (:tvals ref)))) => (throw (:retryex this))
                    (let [#_"LockingTransactionInfo" refinfo (:tinfo ref)]
                        ;; write lock conflict
                        (if (and (some? refinfo) (not= refinfo (:info this)) (LockingTransactionInfo''running refinfo) (not (LockingTransaction''barge this, refinfo)))
                            (do
                                (.unlock (.writeLock (:lock ref)))
                                (ร ass unlocked true)
                                (LockingTransaction''blockAndBail this, refinfo)
                            )
                            (do
                                (ร ass (:tinfo ref) (:info this))
                                (when (some? (:tvals ref)) (:val (:tvals ref)))
                            )
                        )
                    )
                )
                (finally
                    (when-not unlocked
                        (.unlock (.writeLock (:lock ref)))
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"Object" LockingTransaction''blockAndBail [#_"LockingTransaction" this, #_"LockingTransactionInfo" refinfo]
        ;; stop prior to blocking
        (LockingTransaction''stop this, LockingTransaction'RETRY)
        (try
            (.await (:latch refinfo), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS)
            (catch InterruptedException _
                ;; ignore
            )
        )
        (throw (:retryex this))
    )

    #_method
    (defn- #_"void" LockingTransaction''releaseIfEnsured [#_"LockingTransaction" this, #_"Ref" ref]
        (when (.contains (:ensures this), ref)
            (.remove (:ensures this), ref)
            (.unlock (.readLock (:lock ref)))
        )
        nil
    )

    #_method
    (defn #_"void" LockingTransaction''abort [#_"LockingTransaction" this]
        (LockingTransaction''stop this, LockingTransaction'KILLED)
        (throw (AbortException'new))
    )

    #_method
    (defn- #_"boolean" LockingTransaction''bargeTimeElapsed [#_"LockingTransaction" this]
        (< LockingTransaction'BARGE_WAIT_NANOS (- (System/nanoTime) (:startTime this)))
    )

    #_method
    (defn- #_"boolean" LockingTransaction''barge [#_"LockingTransaction" this, #_"LockingTransactionInfo" refinfo]
        ;; if this transaction is older, try to abort the other
        (and (LockingTransaction''bargeTimeElapsed this) (< (:startPoint this) (:startPoint refinfo))
            (let [#_"boolean" barged (.compareAndSet (:status refinfo), LockingTransaction'RUNNING, LockingTransaction'KILLED)]
                (when barged
                    (.countDown (:latch refinfo))
                )
                barged
            )
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (and (some? t) (some? (:info t))) => (throw (IllegalStateException. "No transaction running"))
                t
            )
        )
    )

    (defn #_"boolean" LockingTransaction'isRunning []
        (some? (LockingTransaction'getRunning))
    )

    (defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (and (some? t) (some? (:info t)))
                t
            )
        )
    )

    (defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" fn]
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (nil? t) => (if (some? (:info t)) (.call fn) (LockingTransaction''run t, fn))
                (let [t (LockingTransaction'new)]
                    (.set LockingTransaction'transaction, t)
                    (try
                        (LockingTransaction''run t, fn)
                        (finally
                            (.remove LockingTransaction'transaction)
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Object" LockingTransaction''run [#_"LockingTransaction" this, #_"Callable" fn]
        (let [#_"List<Ref>" locked (ArrayList.) #_"List<Notify>" notify (ArrayList.)]
            (loop [#_"boolean" done false #_"Object" ret nil #_"int" i 0]
                (if (and (not done) (< i LockingTransaction'RETRY_LIMIT))
                    (let [[done ret]
                            (try
                                (LockingTransaction''getReadPoint this)
                                (when (zero? i)
                                    (ร ass this (assoc this :startPoint (:readPoint this)))
                                    (ร ass this (assoc this :startTime (System/nanoTime)))
                                )
                                (ร ass this (assoc this :info (LockingTransactionInfo'new LockingTransaction'RUNNING, (:startPoint this))))
                                (let [ret (.call fn)]
                                    ;; make sure no one has killed us before this point, and can't from now on
                                    (when (.compareAndSet (:status (:info this)), LockingTransaction'RUNNING, LockingTransaction'COMMITTING) => [false ret]
                                        (let [#_"Iterator" it (.iterator (.entrySet (:commutes this)))]
                                            (while (.hasNext it)
                                                (let [#_"Map$Entry<Ref, List<CFn>>" e (.next it) #_"Ref" ref (.getKey e)]
                                                    (when-not (.contains (:sets this), ref)
                                                        (let [#_"boolean" wasEnsured (.contains (:ensures this), ref)]
                                                            ;; can't upgrade readLock, so release it
                                                            (LockingTransaction''releaseIfEnsured this, ref)
                                                            (LockingTransaction''tryWriteLock this, ref)
                                                            (.add locked, ref)
                                                            (when (and wasEnsured (some? (:tvals ref)) (< (:readPoint this) (:point (:tvals ref))))
                                                                (throw (:retryex this))
                                                            )
                                                            (let [#_"LockingTransactionInfo" refinfo (:tinfo ref)]
                                                                (when (and (some? refinfo) (not= refinfo (:info this)) (LockingTransactionInfo''running refinfo) (not (LockingTransaction''barge this, refinfo)))
                                                                    (throw (:retryex this))
                                                                )
                                                                (let [#_"Object" val (when (some? (:tvals ref)) (:val (:tvals ref)))]
                                                                    (.put (:vals this), ref, val)
                                                                    (doseq [#_"CFn" f (.getValue e)]
                                                                        (.put (:vals this), ref, (.applyTo (:fn f), (RT'cons (.get (:vals this), ref), (:args f))))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (doseq [#_"Ref" ref (:sets this)]
                                            (LockingTransaction''tryWriteLock this, ref)
                                            (.add locked, ref)
                                        )
                                        ;; validate and enqueue notifications
                                        (doseq [#_"Map$Entry<Ref, Object>" e (.entrySet (:vals this))]
                                            (let [#_"Ref" ref (.getKey e)]
                                                (ARef''validate-3 ref, (.getValidator ref), (.getValue e))
                                            )
                                        )
                                        ;; at this point, all values calced, all refs to be written locked
                                        ;; no more client code to be called
                                        (let [#_"long" commitPoint (LockingTransaction''getCommitPoint this) #_"Iterator" it (.iterator (.entrySet (:vals this)))]
                                            (while (.hasNext it)
                                                (let [#_"Map$Entry<Ref, Object>" e (.next it) #_"Ref" ref (.getKey e)
                                                      #_"Object" oldval (when (some? (:tvals ref)) (:val (:tvals ref))) #_"Object" newval (.getValue e)
                                                      #_"int" hcount (Ref''histCount ref)]
                                                    (cond
                                                        (nil? (:tvals ref))
                                                        (do
                                                            (ร ass (:tvals ref) (RefTVal'new-2 newval, commitPoint))
                                                        )
                                                        (or (and (pos? (.get (:faults ref))) (< hcount (:maxHistory ref))) (< hcount (:minHistory ref)))
                                                        (do
                                                            (ร ass (:tvals ref) (RefTVal'new-3 newval, commitPoint, (:tvals ref)))
                                                            (.set (:faults ref), 0)
                                                        )
                                                        :else
                                                        (do
                                                            (ร ass (:tvals ref) (:next (:tvals ref)))
                                                            (ร ass (:val (:tvals ref)) newval)
                                                            (ร ass (:point (:tvals ref)) commitPoint)
                                                        )
                                                    )
                                                    (when (pos? (.count (.getWatches ref)))
                                                        (.add notify, (Notify'new ref, oldval, newval))
                                                    )
                                                )
                                            )
                                            (.set (:status (:info this)), LockingTransaction'COMMITTED)
                                            [true ret]
                                        )
                                    )
                                )
                                (ยง catch RetryEx _
                                    ;; eat this so we retry rather than fall out
                                    [false ret]
                                )
                                (finally
                                    (loop-when-recur [#_"int" k (dec (.size locked))] (<= 0 k) [(dec k)]
                                        (.unlock (.writeLock (:lock (.get locked, k))))
                                    )
                                    (.clear locked)
                                    (doseq [#_"Ref" r (:ensures this)]
                                        (.unlock (.readLock (:lock r)))
                                    )
                                    (.clear (:ensures this))
                                    (LockingTransaction''stop this, (if (ยง naughty done) LockingTransaction'COMMITTED LockingTransaction'RETRY))
                                    (try
                                        (when (ยง naughty done) ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" n notify]
                                                (ARef''notifyWatches (:ref n), (:oldval n), (:newval n))
                                            )
                                            (doseq [#_"AgentAction" action (:actions this)]
                                                (Agent'dispatchAction action)
                                            )
                                        )
                                        (finally
                                            (.clear notify)
                                            (.clear (:actions this))
                                        )
                                    )
                                )
                            )]
                        (recur done ret (inc i))
                    )
                    (when done => (throw (RuntimeException. "Transaction failed after reaching retry limit"))
                        ret
                    )
                )
            )
        )
    )

    #_method
    (defn #_"void" LockingTransaction''enqueue [#_"LockingTransaction" this, #_"AgentAction" action]
        (.add (:actions this), action)
        nil
    )

    #_method
    (defn #_"Object" LockingTransaction''doGet [#_"LockingTransaction" this, #_"Ref" ref]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:vals this), ref) => (.get (:vals this), ref)
                (let [_ (try
                            (.lock (.readLock (:lock ref)))
                            (let-when [#_"RefTVal" ver (:tvals ref)] (some? ver) => (throw (IllegalStateException. (str ref " is unbound.")))
                                (loop-when [ver ver] (< (:readPoint this) (:point ver)) => (:val ver)
                                    (let-when [ver (:prior ver)] (not= ver (:tvals ref)) => :nil
                                        (recur ver)
                                    )
                                )
                            )
                            (finally
                                (.unlock (.readLock (:lock ref)))
                            )
                        )]
                    (when (= _ :nil) => _
                        ;; no version of val precedes the read point
                        (.incrementAndGet (:faults ref))
                        (throw (:retryex this))
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Object" LockingTransaction''doSet [#_"LockingTransaction" this, #_"Ref" ref, #_"Object" val]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:commutes this), ref) => (throw (IllegalStateException. "Can't set after commute"))
                (when-not (.contains (:sets this), ref)
                    (.add (:sets this), ref)
                    (LockingTransaction''lock this, ref)
                )
                (.put (:vals this), ref, val)
                val
            )
        )
    )

    #_method
    (defn #_"void" LockingTransaction''doEnsure [#_"LockingTransaction" this, #_"Ref" ref]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.contains (:ensures this), ref)
                (.lock (.readLock (:lock ref)))
                ;; someone completed a write after our snapshot
                (let-when [#_"RefTVal" ver (:tvals ref)] (and (some? ver) (< (:readPoint this) (:point ver)))
                    (.unlock (.readLock (:lock ref)))
                    (throw (:retryex this))
                )
                (let-when [#_"LockingTransactionInfo" refinfo (:tinfo ref)] (and (some? refinfo) (LockingTransactionInfo''running refinfo)) => (.add (:ensures this), ref)
                    ;; writer exists
                    (.unlock (.readLock (:lock ref)))
                    (when-not (= refinfo (:info this)) ;; not us, ensure is doomed
                        (LockingTransaction''blockAndBail this, refinfo)
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn #_"Object" LockingTransaction''doCommute [#_"LockingTransaction" this, #_"Ref" ref, #_"IFn" fn, #_"ISeq" args]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:vals this), ref)
                (let [#_"Object" val
                        (try
                            (.lock (.readLock (:lock ref)))
                            (when (some? (:tvals ref)) (:val (:tvals ref)))
                            (finally
                                (.unlock (.readLock (:lock ref)))
                            )
                        )]
                    (.put (:vals this), ref, val)
                )
            )
            (let [#_"List<CFn>" fns
                    (or (.get (:commutes this), ref)
                        (let [fns (ArrayList.)]
                            (.put (:commutes this), ref, fns)
                            fns
                        )
                    )]
                (.add fns, (CFn'new fn, args))
                (let [#_"Object" ret (.applyTo fn, (RT'cons (.get (:vals this), ref), args))]
                    (.put (:vals this), ref, ret)
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(class-ns LongChunk
    (defn- #_"LongChunk" LongChunk'init []
        (hash-map
            #_"long" :start 0
            #_"long" :step 0
            #_"int" :count 0
        )
    )

    (defn #_"LongChunk" LongChunk'new [#_"long" start, #_"long" step, #_"int" count]
        (let [this (LongChunk'init)]
            (assoc this :start start :step step :count count)
        )
    )

    #_method
    (defn #_"long" LongChunk''first [#_"LongChunk" this]
        (:start this)
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--LongChunk [#_"LongChunk" this, #_"int" i]
        (+ (:start this) (* i (:step this)))
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--LongChunk [#_"LongChunk" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (:count this)) (+ (:start this) (* i (:step this))) notFound)
    )

    #_override
    (defn #_"int" Counted'''count--LongChunk [#_"LongChunk" this]
        (:count this)
    )

    #_override
    (defn #_"LongChunk" IChunk'''dropFirst--LongChunk [#_"LongChunk" this]
        (when (< 1 (:count this)) => (throw (IllegalStateException. "dropFirst of empty chunk"))
            (LongChunk'new (+ (:start this) (:step this)), (:step this), (dec (:count this)))
        )
    )

    #_override
    (defn #_"Object" IChunk'''reduce--LongChunk [#_"LongChunk" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"long" x (:start this) #_"int" i 0] (< i (:count this)) => r
            (let-when-not [r (.invoke f, r, x)] (RT'isReduced r) => r
                (recur r (+ x (:step this)) (inc i))
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange
    (def- #_"int" LongRange'CHUNK_SIZE 32)

    (defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" end]
        (reify LongRangeBoundsCheck
            #_override
            (#_"boolean" exceededBounds [#_"LongRangeBoundsCheck" _self, #_"long" val]
                (<= end val)
            )
        )
    )

    (defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" end]
        (reify LongRangeBoundsCheck
            #_override
            (#_"boolean" exceededBounds [#_"LongRangeBoundsCheck" _self, #_"long" val]
                (<= val end)
            )
        )
    )

    (defn- #_"LongRange" LongRange'init []
        (hash-map
            ;; Invariants guarantee this is never an empty or infinite seq
            #_"long" :start 0
            #_"long" :end 0
            #_"long" :step 0
            #_"LongRangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"LongChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"LongRange" LongRange'new-4 [#_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck]
        (let [this (merge (ASeq'new-0) (LongRange'init))]
            (assoc this :start start :end end :step step :boundsCheck boundsCheck)
        )
    )

    (defn- #_"LongRange" LongRange'new-6 [#_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-0) (LongRange'init))]
            (assoc this :start start :end end :step step :boundsCheck boundsCheck :_chunk chunk :_chunkNext chunkNext)
        )
    )

    (defn- #_"LongRange" LongRange'new-7 [#_"IPersistentMap" meta, #_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-1 meta) (LongRange'init))]
            (assoc this :start start :end end :step step :boundsCheck boundsCheck :_chunk chunk :_chunkNext chunkNext)
        )
    )

    (defn #_"ISeq" LongRange'create-1 [#_"long" end]
        (if (< 0 end)
            (LongRange'new-4 0, end, 1, (LongRange'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" LongRange'create-2 [#_"long" start, #_"long" end]
        (if (< start end)
            (LongRange'new-4 start, end, 1, (LongRange'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" LongRange'create-3 [#_"long" start, #_"long" end, #_"long" step]
        (cond
            (pos? step) (if (< start end) (LongRange'new-4 start, end, step, (LongRange'positiveStep end)) PersistentList'EMPTY)
            (neg? step) (if (< end start) (LongRange'new-4 start, end, step, (LongRange'negativeStep end)) PersistentList'EMPTY)
            :else       (if (= start end) PersistentList'EMPTY (Repeat'create-1 start))
        )
    )

    #_override
    (defn #_"LongRange" IObj'''withMeta--LongRange [#_"LongRange" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (LongRange'new-7 meta, (:start this), (:end this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--LongRange [#_"LongRange" this]
        (:start this)
    )

    #_method
    (defn #_"void" LongRange''forceChunk [#_"LongRange" this]
        (when (nil? (:_chunk this))
            (let [#_"long" n
                    (try
                        (LongRange''rangeCount this, (:start this), (:end this), (:step this))
                        (catch ArithmeticException e
                            ;; size of total range is > Long.MAX_VALUE, so must step to count
                            ;; this only happens in pathological range cases like:
                            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                            (LongRange''steppingCount this, (:start this), (:end this), (:step this))
                        )
                    )]
                (if (< LongRange'CHUNK_SIZE n)
                    ;; not last chunk
                    (let [#_"long" nextStart (+ (:start this) (* (:step this) LongRange'CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (ร ass this (assoc this :_chunkNext (LongRange'new-4 nextStart, (:end this), (:step this), (:boundsCheck this))))
                        (ร ass this (assoc this :_chunk (LongChunk'new (:start this), (:step this), LongRange'CHUNK_SIZE)))
                    )
                    ;; last chunk
                    (ร ass this (assoc this :_chunk (LongChunk'new (:start this), (:step this), (int n)))) ;; n must be <= CHUNK_SIZE
                )
            )
        )
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''next--LongRange [#_"LongRange" this]
        (let-when [#_"ISeq" _next (:_next this)] (nil? _next) => _next
            (LongRange''forceChunk this)
            (when (< 1 (.count (:_chunk this))) => (.chunkedNext this)
                (let [#_"LongChunk" _rest (.dropFirst (:_chunk this))
                      _next (LongRange'new-6 (LongChunk''first _rest), (:end this), (:step this), (:boundsCheck this), _rest, (:_chunkNext this))]
                    (ร ass this (assoc this :_next _next))
                    _next
                )
            )
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--LongRange [#_"LongRange" this]
        (LongRange''forceChunk this)
        (:_chunk this)
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--LongRange [#_"LongRange" this]
        (.seq (.chunkedMore this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--LongRange [#_"LongRange" this]
        (LongRange''forceChunk this)
        (or (:_chunkNext this) PersistentList'EMPTY)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (defn #_"long" LongRange''steppingCount [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        (loop-when [#_"long" s start #_"long" n 1] (<= n LongRange'CHUNK_SIZE) => n
            (let [[s n]
                    (try
                        (let [s (Numbers'add-2ll s, step)]
                            (if (.exceededBounds (:boundsCheck this), s)
                                [nil n]
                                [s (inc n)]
                            )
                        )
                        (catch ArithmeticException _
                            [nil n]
                        )
                    )]
                (recur-if (some? s) [s n] => n)
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (defn #_"long" LongRange''rangeCount [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (/ (Numbers'add-2ll (Numbers'add-2ll (Numbers'minus-2ll end, start), step), (if (pos? (:step this)) -1 1)) step)
    )

    #_override
    (defn #_"int" Counted'''count--LongRange [#_"LongRange" this]
        (try
            (let [#_"long" n (LongRange''rangeCount this, (:start this), (:end this), (:step this))]
                (when (<= n Integer/MAX_VALUE) => (Numbers'throwIntOverflow)
                    (int n)
                )
            )
            (catch ArithmeticException _
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"long" n
                        (loop-when-recur [#_"Iterator" it (.iterator this) n 0] (.hasNext it) [it (inc n)] => n
                            (.next it)
                        )]
                    (when (<= n Integer/MAX_VALUE) => (Numbers'throwIntOverflow)
                        (int n)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduce'''reduce--LongRange [#_"LongRange" this, #_"IFn" f]
        (loop [#_"Object" r (:start this) #_"long" n r]
            (let-when-not [n (+ n (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast Reduced r))
                    (recur r n)
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--LongRange [#_"LongRange" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"long" n (:start this)]
            (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast Reduced r))
                (let-when-not [n (+ n (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                    (recur r n)
                )
            )
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---LongRange [#_"LongRange" this]
        (let [#_"long'" vn (volatile! (:start this)) #_"boolean'" vm (volatile! true)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    @vm
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (when @vm => (throw (NoSuchElementException.))
                        (let [_ @vn]
                            (try
                                (vswap! vn Numbers'add-2ll (:step this))
                                (vreset! vm (not (.exceededBounds (:boundsCheck this), @vn)))
                                (catch ArithmeticException e
                                    (vreset! vm false)
                                )
                            )
                            _
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(class-ns MapEntry
    (defn #_"MapEntry" MapEntry'create [#_"Object" key, #_"Object" val]
        (MapEntry'new key, val)
    )

    (defn- #_"MapEntry" MapEntry'init []
        (hash-map
            #_"Object" :_key nil
            #_"Object" :_val nil
        )
    )

    (defn #_"MapEntry" MapEntry'new [#_"Object" key, #_"Object" val]
        (let [this (merge (AMapEntry'new) (MapEntry'init))]
            (assoc this :_key key :_val val)
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''key--MapEntry [#_"MapEntry" this]
        (:_key this)
    )

    #_override
    (defn #_"Object" IMapEntry'''val--MapEntry [#_"MapEntry" this]
        (:_val this)
    )

    #_foreign
    (defn #_"Object" getKey---MapEntry [#_"MapEntry" this]
        (.key this)
    )

    #_foreign
    (defn #_"Object" getValue---MapEntry [#_"MapEntry" this]
        (.val this)
    )
)
)

(java-ns cloiure.lang.MethodImplCache

(class-ns Entry
    (defn- #_"Entry" Entry'init []
        (hash-map
            #_"Class" :c nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"Entry" Entry'new [#_"Class" c, #_"IFn" fn]
        (let [this (Entry'init)]
            (assoc this :c c :fn fn)
        )
    )
)

(class-ns MethodImplCache
    (defn- #_"MethodImplCache" MethodImplCache'init []
        (hash-map
            #_"IPersistentMap" :protocol nil
            #_"Keyword" :methodk nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"Object[]" :table nil ;; [class, entry. class, entry ...]
            #_"Map" :map nil

            #_"Entry" :mre nil
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-2 [#_"IPersistentMap" protocol, #_"Keyword" methodk]
        (MethodImplCache'new-5 protocol, methodk, 0, 0, RT'EMPTY_ARRAY)
    )

    (defn #_"MethodImplCache" MethodImplCache'new-5 [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"int" shift, #_"int" mask, #_"Object[]" table]
        (let [this (MethodImplCache'init)]
            (assoc this :protocol protocol :methodk methodk :shift shift :mask mask :table table :map nil)
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-3 [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"Map" map]
        (let [this (MethodImplCache'init)]
            (assoc this :protocol protocol :methodk methodk :shift 0 :mask 0 :table nil :map map)
        )
    )

    #_method
    (defn #_"IFn" MethodImplCache''fnFor [#_"MethodImplCache" this, #_"Class" c]
        (let [#_"Entry" last (:mre this)]
            (if (and (some? last) (= (:c last) c)) (:fn last) (MethodImplCache''findFnFor this, c))
        )
    )

    #_method
    (defn #_"IFn" MethodImplCache''findFnFor [#_"MethodImplCache" this, #_"Class" c]
        (if (some? (:map this))
            (let [#_"Entry" e (cast Entry (.get (:map this), c))]
                (ร ass this (assoc this :mre e))
                (when (some? e) (:fn e))
            )
            (let [#_"int" idx (<< (& (>> (Util'hash c) (:shift this)) (:mask this)) 1)]
                (when (and (< idx (alength (:table this))) (= (aget (:table this) idx) c))
                    (let [#_"Entry" e (cast Entry (aget (:table this) (inc idx)))]
                        (ร ass this (assoc this :mre e))
                        (when (some? e) (:fn e))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(class-ns MultiFn
    (ยง def #_"Var" MultiFn'assoc (RT'var "cloiure.core", "assoc"))
    (ยง def #_"Var" MultiFn'dissoc (RT'var "cloiure.core", "dissoc"))
    (ยง def #_"Var" MultiFn'isa (RT'var "cloiure.core", "isa?"))
    (ยง def #_"Var" MultiFn'parents (RT'var "cloiure.core", "parents"))

    (defn- #_"MultiFn" MultiFn'init []
        (hash-map
            #_"IFn" :dispatchFn nil
            #_"Object" :defaultDispatchVal nil
            #_"IRef" :hierarchy nil
            #_"String" :name nil
            #_"ReentrantReadWriteLock" :rw nil

            #_volatile
            #_"IPersistentMap" :methodTable nil
            #_volatile
            #_"IPersistentMap" :preferTable nil
            #_volatile
            #_"IPersistentMap" :methodCache nil
            #_volatile
            #_"Object" :cachedHierarchy nil
        )
    )

    (defn #_"MultiFn" MultiFn'new [#_"String" name, #_"IFn" dispatchFn, #_"Object" defaultDispatchVal, #_"IRef" hierarchy]
        (let [this (merge (AFn'new) (MultiFn'init))]
            (assoc this :rw (ReentrantReadWriteLock.) :name name :dispatchFn dispatchFn :defaultDispatchVal defaultDispatchVal :methodTable PersistentHashMap'EMPTY :methodCache PersistentHashMap'EMPTY :preferTable PersistentHashMap'EMPTY :hierarchy hierarchy :cachedHierarchy nil)
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''reset [#_"MultiFn" this]
        (.lock (.writeLock (:rw this)))
        (try
            (assoc this :methodTable PersistentHashMap'EMPTY :methodCache PersistentHashMap'EMPTY :preferTable PersistentHashMap'EMPTY :cachedHierarchy nil)
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''addMethod [#_"MultiFn" this, #_"Object" dispatchVal, #_"IFn" method]
        (.lock (.writeLock (:rw this)))
        (try
            (let [this (update this :methodTable #(.assoc %, dispatchVal, method))]
                (MultiFn''resetCache this)
                this
            )
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''removeMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (.lock (.writeLock (:rw this)))
        (try
            (let [this (update this :methodTable #(.without %, dispatchVal))]
                (MultiFn''resetCache this)
                this
            )
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''preferMethod [#_"MultiFn" this, #_"Object" dispatchValX, #_"Object" dispatchValY]
        (.lock (.writeLock (:rw this)))
        (try
            (when (MultiFn''prefers this, dispatchValY, dispatchValX)
                (throw (IllegalStateException. (str "Preference conflict in multimethod '" (:name this) "': " dispatchValY " is already preferred to " dispatchValX)))
            )
            (let [this (update this :preferTable #(.assoc %, dispatchValX, (RT'conj (cast IPersistentCollection (RT'get-3 %, dispatchValX, PersistentHashSet'EMPTY)), dispatchValY)))]
                (MultiFn''resetCache this)
                this
            )
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn- #_"boolean" MultiFn''prefers [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (or
            (let [#_"IPersistentSet" xprefs (cast IPersistentSet (.valAt (:preferTable this), x))]
                (and (some? xprefs) (.contains xprefs, y))
            )
            (loop-when [#_"ISeq" ps (RT'seq (.invoke MultiFn'parents, y))] (some? ps) => false
                (or (MultiFn''prefers this, x, (.first ps)) (recur (.next ps)))
            )
            (loop-when [#_"ISeq" ps (RT'seq (.invoke MultiFn'parents, x))] (some? ps) => false
                (or (MultiFn''prefers this, (.first ps), y) (recur (.next ps)))
            )
        )
    )

    #_method
    (defn- #_"boolean" MultiFn''isA [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (RT'booleanCast-1o (.invoke MultiFn'isa, (.deref (:hierarchy this)), x, y))
    )

    #_method
    (defn- #_"boolean" MultiFn''dominates [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (or (MultiFn''prefers this, x, y) (MultiFn''isA this, x, y))
    )

    #_method
    (defn- #_"IPersistentMap" MultiFn''resetCache [#_"MultiFn" this]
        (.lock (.writeLock (:rw this)))
        (try
            (ร ass this (assoc this :methodCache (:methodTable this)))
            (ร ass this (assoc this :cachedHierarchy (.deref (:hierarchy this))))
            (:methodCache this)
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"IFn" MultiFn''getMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (when-not (= (:cachedHierarchy this) (.deref (:hierarchy this)))
            (MultiFn''resetCache this)
        )
        (let [#_"IFn" targetFn (cast IFn (.valAt (:methodCache this), dispatchVal))]
            (or targetFn (MultiFn''findAndCacheBestMethod this, dispatchVal))
        )
    )

    #_method
    (defn- #_"IFn" MultiFn''getFn [#_"MultiFn" this, #_"Object" dispatchVal]
        (let [#_"IFn" targetFn (MultiFn''getMethod this, dispatchVal)]
            (or targetFn (throw (IllegalArgumentException. (str "No method in multimethod '" (:name this) "' for dispatch value: " dispatchVal))))
        )
    )

    #_method
    (defn- #_"IFn" MultiFn''findAndCacheBestMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (.lock (.readLock (:rw this)))
        (let [#_"IPersistentMap" mt (:methodTable this) #_"IPersistentMap" pt (:preferTable this) #_"Object" ch (:cachedHierarchy this)
              #_"Object" bestValue
                (try
                    (let [#_"Iterator" it (.iterator (:methodTable this))
                            #_"Map$Entry" bestEntry
                            (loop-when [bestEntry nil] (.hasNext it) => bestEntry
                                (let-when [#_"Map$Entry" e (cast Map$Entry (.next it))] (MultiFn''isA this, dispatchVal, (.getKey e)) => (recur bestEntry)
                                    (let [bestEntry
                                            (when (or (nil? bestEntry) (MultiFn''dominates this, (.getKey e), (.getKey bestEntry))) => bestEntry
                                                e
                                            )]
                                        (when-not (MultiFn''dominates this, (.getKey bestEntry), (.getKey e))
                                            (throw (IllegalArgumentException. (str "Multiple methods in multimethod '" (:name this) "' match dispatch value: " dispatchVal " -> " (.getKey e) " and " (.getKey bestEntry) ", and neither is preferred")))
                                        )
                                        (recur bestEntry)
                                    )
                                )
                            )]
                        (if (some? bestEntry) (.getValue bestEntry) (.valAt (:methodTable this), (:defaultDispatchVal this)))
                    )
                    (finally
                        (.unlock (.readLock (:rw this)))
                    )
                )]
            (when (some? bestValue)
                ;; ensure basis has stayed stable throughout, else redo
                (.lock (.writeLock (:rw this)))
                (try
                    (if (and (= mt (:methodTable this)) (= pt (:preferTable this)) (= ch (:cachedHierarchy this)) (= (:cachedHierarchy this) (.deref (:hierarchy this))))
                        (do
                            ;; place in cache
                            (ร ass this (assoc this :methodCache (.assoc (:methodCache this), dispatchVal, bestValue)))
                            (cast IFn bestValue)
                        )
                        (do
                            (MultiFn''resetCache this)
                            (MultiFn''findAndCacheBestMethod this, dispatchVal)
                        )
                    )
                    (finally
                        (.unlock (.writeLock (:rw this)))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--MultiFn [#_"MultiFn" this]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this))))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--MultiFn [#_"MultiFn" this, #_"Object" arg1]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1)), arg1
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2)), arg1, arg2
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3)), arg1, arg2, arg3
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4)), arg1, arg2, arg3, arg4
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5)), arg1, arg2, arg3, arg4, arg5
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6)), arg1, arg2, arg3, arg4, arg5, arg6
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7)), arg1, arg2, arg3, arg4, arg5, arg6, arg7
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.invoke (MultiFn''getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, args)), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20,
            args
        )
    )
)
)

(java-ns cloiure.lang.Murmur3

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
(class-ns Murmur3
    (def- #_"int" Murmur3'seed 0)
    (def- #_"int" Murmur3'C1 0xcc9e2d51)
    (def- #_"int" Murmur3'C2 0x1b873593)

    (defn #_"int" Murmur3'hashInt [#_"int" input]
        (when-not (zero? input) => 0
            (let [#_"int" k1 (Murmur3'mixK1 input)
                  #_"int" h1 (Murmur3'mixH1 Murmur3'seed, k1)]
                (Murmur3'fmix h1, 4)
            )
        )
    )

    (defn #_"int" Murmur3'hashLong [#_"long" input]
        (when-not (zero? input) => 0
            (let [#_"int" low (int input)
                  #_"int" high (int (>>> input 32))
                  #_"int" k1 (Murmur3'mixK1 low)
                  #_"int" h1 (Murmur3'mixH1 Murmur3'seed, k1)
                  k1 (Murmur3'mixK1 high)
                  h1 (Murmur3'mixH1 h1, k1)]
                (Murmur3'fmix h1, 8)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" input]
        (let [#_"int" h1 ;; step through the input 2 chars at a time
                (loop-when [h1 Murmur3'seed #_"int" i 1] (< i (.length input)) => h1
                    (let [#_"int" k1 (| (.charAt input, (dec i)) (<< (.charAt input, i) 16))]
                        (recur (Murmur3'mixH1 h1, (Murmur3'mixK1 k1)) (+ i 2))
                    )
                )
              h1 ;; deal with any remaining characters
                (when (= (& (.length input) 1) 1) => h1
                    (let [#_"int" k1 (.charAt input, (dec (.length input)))]
                        (bit-xor h1 (Murmur3'mixK1 k1))
                    )
                )]
            (Murmur3'fmix h1, (* 2 (.length input)))
        )
    )

    (defn #_"int" Murmur3'mixCollHash [#_"int" hash, #_"int" n]
        (Murmur3'fmix (Murmur3'mixH1 Murmur3'seed, (Murmur3'mixK1 hash)), n)
    )

    (defn #_"int" Murmur3'hashOrdered [#_"Iterable" xs]
        (let [#_"Iterator" it (.iterator xs)]
            (loop-when-recur [#_"int" hash 1 #_"int" n 0]
                             (.hasNext it)
                             [(+ (* 31 hash) (Util'hasheq (.next it))) (inc n)]
                          => (Murmur3'mixCollHash hash, n)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnordered [#_"Iterable" xs]
        (let [#_"Iterator" it (.iterator xs)]
            (loop-when-recur [#_"int" hash 0 #_"int" n 0]
                             (.hasNext it)
                             [(+ hash (Util'hasheq (.next it))) (inc n)]
                          => (Murmur3'mixCollHash hash, n)
            )
        )
    )

    (defn- #_"int" Murmur3'mixK1 [#_"int" k1]
        (-> k1 (* Murmur3'C1) (Integer/rotateLeft 15) (* Murmur3'C2))
    )

    (defn- #_"int" Murmur3'mixH1 [#_"int" h1, #_"int" k1]
        (-> h1 (bit-xor k1) (Integer/rotateLeft 13) (* 5) (+ 0xe6546b64))
    )

    ;; finalization mix - force all bits of a hash block to avalanche
    (defn- #_"int" Murmur3'fmix [#_"int" h1, #_"int" n]
        (let [h1 (bit-xor h1 n)    h1 (bit-xor h1 (>>> h1 16))
              h1 (* h1 0x85ebca6b) h1 (bit-xor h1 (>>> h1 13))
              h1 (* h1 0xc2b2ae35) h1 (bit-xor h1 (>>> h1 16))]
            h1
        )
    )
)
)

(java-ns cloiure.lang.Namespace

(class-ns Namespace
    (def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ConcurrentHashMap.))

    (defn- #_"Namespace" Namespace'init []
        (hash-map
            #_"Symbol" :name nil

            #_transient
            #_"AtomicReference<IPersistentMap>" :mappings (AtomicReference.)
            #_transient
            #_"AtomicReference<IPersistentMap>" :aliases (AtomicReference.)
        )
    )

    (defn #_"Namespace" Namespace'new [#_"Symbol" name]
        (let [this
                (-> (merge (AReference'new-1 (.meta name)) (Namespace'init))
                    (assoc :name name)
                )]
            (.set (:mappings this), RT'DEFAULT_IMPORTS)
            (.set (:aliases this), (RT'map))
            this
        )
    )

    #_foreign
    (defn #_"String" toString---Namespace [#_"Namespace" this]
        (.toString (:name this))
    )

    (defn #_"ISeq" Namespace'all []
        (RT'seq (.values Namespace'namespaces))
    )

    #_method
    (defn #_"Symbol" Namespace''getName [#_"Namespace" this]
        (:name this)
    )

    #_method
    (defn #_"IPersistentMap" Namespace''getMappings [#_"Namespace" this]
        (.get (:mappings this))
    )

    #_method
    (defn- #_"void" Namespace''warnOrFailOnReplace [#_"Namespace" this, #_"Symbol" sym, #_"Object" o, #_"Var" var]
        (or
            (when (instance? Var o)
                (let [#_"Namespace" ns (:ns (cast Var o))]
                    (when-not (or (= ns this) (= (:ns var) RT'CLOIURE_NS)) => :ok
                        (when-not (= ns RT'CLOIURE_NS)
                            (throw (IllegalStateException. (str sym " already refers to: " o " in namespace: " (:name this))))
                        )
                    )
                )
            )
            (.println (RT'errPrintWriter), (str "WARNING: " sym " already refers to: " o " in namespace: " (:name this) ", being replaced by: " var))
        )
        nil
    )

    #_method
    (defn #_"Var" Namespace''intern [#_"Namespace" this, #_"Symbol" sym]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [[#_"IPersistentMap" m #_"Object" o #_"Var" v]
                    (loop [v nil]
                        (let-when [m (Namespace''getMappings this) o (.valAt m, sym)] (nil? o) => [m o v]
                            (let [v (or v (Var'new this, sym))]
                                (.compareAndSet (:mappings this), m, (.assoc m, sym, v))
                                (recur v)
                            )
                        )
                    )]
                (when-not (and (instance? Var o) (= (:ns (cast Var o)) this)) => (cast Var o)
                    (let [v (or v (Var'new this, sym))]
                        (Namespace''warnOrFailOnReplace this, sym, o, v)
                        (loop-when-recur m (not (.compareAndSet (:mappings this), m, (.assoc m, sym, v))) (Namespace''getMappings this))
                        v
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Var" Namespace''referenceVar [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [[#_"IPersistentMap" m #_"Object" o]
                    (loop []
                        (let-when [m (Namespace''getMappings this) o (.valAt m, sym)] (nil? o) => [m o]
                            (.compareAndSet (:mappings this), m, (.assoc m, sym, var))
                            (recur)
                        )
                    )]
                (when-not (= o var)
                    (Namespace''warnOrFailOnReplace this, sym, o, var)
                    (loop-when-recur m (not (.compareAndSet (:mappings this), m, (.assoc m, sym, var))) (Namespace''getMappings this))
                )
                var
            )
        )
    )

    (defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" cls1, #_"Class" cls2]
        (and (not= cls1 cls2) (.equals (.getName cls1), (.getName cls2)))
    )

    #_method
    (defn #_"Class" Namespace''referenceClass [#_"Namespace" this, #_"Symbol" sym, #_"Class" cls]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [#_"Class" c
                    (loop []
                        (let [#_"IPersistentMap" m (Namespace''getMappings this) c (cast Class (.valAt m, sym))]
                            (when (or (nil? c) (Namespace'areDifferentInstancesOfSameClassName c, cls)) => c
                                (.compareAndSet (:mappings this), m, (.assoc m, sym, cls))
                                (recur)
                            )
                        )
                    )]
                (when (= c cls) => (throw (IllegalStateException. (str sym " already refers to: " c " in namespace: " (:name this))))
                    c
                )
            )
        )
    )

    #_method
    (defn #_"void" Namespace''unmap [#_"Namespace" this, #_"Symbol" sym]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
            (loop-when-recur [#_"IPersistentMap" m (Namespace''getMappings this)] (.containsKey m, sym) [(Namespace''getMappings this)]
                (.compareAndSet (:mappings this), m, (.without m, sym))
            )
        )
        nil
    )

    #_method
    (defn #_"Class" Namespace''importClass-3 [#_"Namespace" this, #_"Symbol" sym, #_"Class" cls]
        (Namespace''referenceClass this, sym, cls)
    )

    #_method
    (defn #_"Class" Namespace''importClass-2 [#_"Namespace" this, #_"Class" cls]
        (let [#_"String" s (.getName cls)]
            (Namespace''importClass-3 this, (Symbol'intern (.substring s, (inc (.lastIndexOf s, \.)))), cls)
        )
    )

    #_method
    (defn #_"Var" Namespace''refer [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (Namespace''referenceVar this, sym, var)
    )

    (defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" name]
        (or (.get Namespace'namespaces, name)
            (let [#_"Namespace" ns (Namespace'new name)]
                (or (.putIfAbsent Namespace'namespaces, name, ns) ns)
            )
        )
    )

    (defn #_"Namespace" Namespace'remove [#_"Symbol" name]
        (when (.equals name, (:name RT'CLOIURE_NS))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (.remove Namespace'namespaces, name)
    )

    (defn #_"Namespace" Namespace'find [#_"Symbol" name]
        (.get Namespace'namespaces, name)
    )

    #_method
    (defn #_"Object" Namespace''getMapping [#_"Namespace" this, #_"Symbol" name]
        (.valAt (.get (:mappings this)), name)
    )

    #_method
    (defn #_"Var" Namespace''findInternedVar [#_"Namespace" this, #_"Symbol" symbol]
        (let [#_"Object" o (.valAt (.get (:mappings this)), symbol)]
            (when (and (some? o) (instance? Var o) (= (:ns (cast Var o)) this))
                (cast Var o)
            )
        )
    )

    #_method
    (defn #_"IPersistentMap" Namespace''getAliases [#_"Namespace" this]
        (.get (:aliases this))
    )

    #_method
    (defn #_"Namespace" Namespace''lookupAlias [#_"Namespace" this, #_"Symbol" alias]
        (cast Namespace (.valAt (Namespace''getAliases this), alias))
    )

    #_method
    (defn #_"void" Namespace''addAlias [#_"Namespace" this, #_"Symbol" alias, #_"Namespace" ns]
        (when (and (some? alias) (some? ns)) => (throw (NullPointerException. "Expecting Symbol + Namespace"))
            (let [#_"IPersistentMap" m
                    (loop-when-recur [m (Namespace''getAliases this)] (not (.containsKey m, alias)) [(Namespace''getAliases this)] => m
                        (.compareAndSet (:aliases this), m, (.assoc m, alias, ns))
                    )]
                ;; you can rebind an alias, but only to the initially-aliased namespace
                (when-not (.equals (.valAt m, alias), ns)
                    (throw (IllegalStateException. (str "Alias " alias " already exists in namespace " (:name this) ", aliasing " (.valAt m, alias))))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" Namespace''removeAlias [#_"Namespace" this, #_"Symbol" alias]
        (loop-when-recur [#_"IPersistentMap" m (Namespace''getAliases this)] (.containsKey m, alias) [(Namespace''getAliases this)]
            (.compareAndSet (:aliases this), m, (.without m, alias))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Numbers

(class-ns OpsP
    (defn #_"OpsP" OpsP'new []
        (hash-map)
    )

    #_override
    (defn #_"Number" Ops'''addP--OpsP [#_"OpsP" this, #_"Number" x, #_"Number" y]
        (.add this, x, y)
    )

    #_override
    (defn #_"Number" Ops'''multiplyP--OpsP [#_"OpsP" this, #_"Number" x, #_"Number" y]
        (.multiply this, x, y)
    )

    #_override
    (defn #_"Number" Ops'''negateP--OpsP [#_"OpsP" this, #_"Number" x]
        (.negate this, x)
    )

    #_override
    (defn #_"Number" Ops'''incP--OpsP [#_"OpsP" this, #_"Number" x]
        (.inc this, x)
    )

    #_override
    (defn #_"Number" Ops'''decP--OpsP [#_"OpsP" this, #_"Number" x]
        (.dec this, x)
    )
)

(class-ns LongOps
    (defn #_"LongOps" LongOps'new []
        (hash-map)
    )

    #_override
    (defn #_"Ops" Ops'''combine--LongOps [#_"LongOps" this, #_"Ops" y]
        (.opsWithLong y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--LongOps [#_"LongOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--LongOps [#_"LongOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--LongOps [#_"LongOps" this, #_"RatioOps" x]
        Numbers'RATIO_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--LongOps [#_"LongOps" this, #_"BigIntOps" x]
        Numbers'BIGINT_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--LongOps [#_"LongOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_override
    (defn #_"boolean" Ops'''isZero--LongOps [#_"LongOps" this, #_"Number" x]
        (zero? (.longValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isPos--LongOps [#_"LongOps" this, #_"Number" x]
        (pos? (.longValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--LongOps [#_"LongOps" this, #_"Number" x]
        (neg? (.longValue x))
    )

    #_override
    (defn #_"Number" Ops'''add--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (Numbers'add-2ll (.longValue x), (.longValue y)))
    )

    #_override
    (defn #_"Number" Ops'''addP--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y) #_"long" lz (+ lx ly)]
            (if (and (neg? (bit-xor lz lx)) (neg? (bit-xor lz ly)))
                (.add Numbers'BIGINT_OPS, x, y)
                (Numbers'num-1l lz)
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''multiply--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (Numbers'multiply-2ll (.longValue x), (.longValue y)))
    )

    #_override
    (defn #_"Number" Ops'''multiplyP--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y)]
            (if (and (= lx Long/MIN_VALUE) (neg? ly))
                (.multiply Numbers'BIGINT_OPS, x, y)
                (let [#_"long" lz (* lx ly)]
                    (if (and (not= ly 0) (not= (/ lz ly) lx))
                        (.multiply Numbers'BIGINT_OPS, x, y)
                        (Numbers'num-1l lz)
                    )
                )
            )
        )
    )

    (defn #_"long" LongOps'gcd [#_"long" u, #_"long" v] (if (zero? v) u (recur v (% u v))))

    #_override
    (defn #_"Number" Ops'''divide--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y)]
            (let-when-not [#_"long" gcd (LongOps'gcd lx, ly)] (zero? gcd) => (Numbers'num-1l 0)
                (let-when-not [lx (/ lx gcd) ly (/ ly gcd)] (= ly 1) => (Numbers'num-1l lx)
                    (let [[lx ly]
                            (when (neg? ly) => [lx ly]
                                [(- lx) (- ly)]
                            )]
                        (Ratio'new (BigInteger/valueOf lx), (BigInteger/valueOf ly))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''quotient--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (/ (.longValue x) (.longValue y)))
    )

    #_override
    (defn #_"Number" Ops'''remainder--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (% (.longValue x) (.longValue y)))
    )

    #_override
    (defn #_"boolean" Ops'''equiv--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (= (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lt--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (< (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lte--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (<= (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"boolean" Ops'''gte--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (>= (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"Number" Ops'''negate--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'minus-1l val))
        )
    )

    #_override
    (defn #_"Number" Ops'''negateP--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< Long/MIN_VALUE val)
                (Numbers'num-1l (- val))
                (BigInt'fromBigInteger (.negate (BigInteger/valueOf val)))
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''inc--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'inc-1l val))
        )
    )

    #_override
    (defn #_"Number" Ops'''incP--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< val Long/MAX_VALUE)
                (Numbers'num-1l (inc val))
                (.inc Numbers'BIGINT_OPS, x)
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''dec--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'dec-1l val))
        )
    )

    #_override
    (defn #_"Number" Ops'''decP--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< Long/MIN_VALUE val)
                (Numbers'num-1l (dec val))
                (.dec Numbers'BIGINT_OPS, x)
            )
        )
    )
)

(class-ns DoubleOps
    (defn #_"DoubleOps" DoubleOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--DoubleOps [#_"DoubleOps" this, #_"Ops" y]
        (.opsWithDouble y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--DoubleOps [#_"DoubleOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--DoubleOps [#_"DoubleOps" this, #_"DoubleOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--DoubleOps [#_"DoubleOps" this, #_"RatioOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--DoubleOps [#_"DoubleOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--DoubleOps [#_"DoubleOps" this, #_"BigDecimalOps" x]
        this
    )

    #_override
    (defn #_"boolean" Ops'''isZero--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (zero? (.doubleValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isPos--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (pos? (.doubleValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (neg? (.doubleValue x))
    )

    #_override
    (defn #_"Number" Ops'''add--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (+ (.doubleValue x) (.doubleValue y)))
    )

    #_override
    (defn #_"Number" Ops'''multiply--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (* (.doubleValue x) (.doubleValue y)))
    )

    #_override
    (defn #_"Number" Ops'''divide--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (/ (.doubleValue x) (.doubleValue y)))
    )

    #_override
    (defn #_"Number" Ops'''quotient--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Numbers'quotient-2dd (.doubleValue x), (.doubleValue y))
    )

    #_override
    (defn #_"Number" Ops'''remainder--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Numbers'remainder-2dd (.doubleValue x), (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''equiv--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (= (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lt--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (< (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lte--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (<= (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''gte--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (>= (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"Number" Ops'''negate--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (- (.doubleValue x)))
    )

    #_override
    (defn #_"Number" Ops'''inc--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (inc (.doubleValue x)))
    )

    #_override
    (defn #_"Number" Ops'''dec--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (dec (.doubleValue x)))
    )
)

(class-ns RatioOps
    (defn #_"RatioOps" RatioOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--RatioOps [#_"RatioOps" this, #_"Ops" y]
        (.opsWithRatio y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--RatioOps [#_"RatioOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--RatioOps [#_"RatioOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--RatioOps [#_"RatioOps" this, #_"RatioOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--RatioOps [#_"RatioOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--RatioOps [#_"RatioOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_override
    (defn #_"boolean" Ops'''isZero--RatioOps [#_"RatioOps" this, #_"Number" x]
        (zero? (.signum (:numerator (cast Ratio x))))
    )

    #_override
    (defn #_"boolean" Ops'''isPos--RatioOps [#_"RatioOps" this, #_"Number" x]
        (pos? (.signum (:numerator (cast Ratio x))))
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--RatioOps [#_"RatioOps" this, #_"Number" x]
        (neg? (.signum (:numerator (cast Ratio x))))
    )

    (defn #_"Number" RatioOps'normalizeRet [#_"Number" ret, #_"Number" x, #_"Number" y]
        ret
    )

    #_override
    (defn #_"Number" Ops'''add--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"Number" ret (.divide this, (.add (.multiply (:numerator ry), (:denominator rx)), (.multiply (:numerator rx), (:denominator ry))), (.multiply (:denominator ry), (:denominator rx)))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''multiply--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"Number" ret (.divide this, (.multiply (:numerator ry), (:numerator rx)), (.multiply (:denominator ry), (:denominator rx)))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''divide--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"Number" ret (.divide this, (.multiply (:denominator ry), (:numerator rx)), (.multiply (:numerator ry), (:denominator rx)))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''quotient--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"BigInteger" q (.divide (.multiply (:numerator rx), (:denominator ry)), (.multiply (:denominator rx), (:numerator ry)))]
            (RatioOps'normalizeRet (BigInt'fromBigInteger q), x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''remainder--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"BigInteger" q (.divide (.multiply (:numerator rx), (:denominator ry)), (.multiply (:denominator rx), (:numerator ry)))
              #_"Number" ret (Numbers'minus-2oo x, (Numbers'multiply-2oo q, y))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"boolean" Ops'''equiv--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (and (.equals (:numerator rx), (:numerator ry)) (.equals (:denominator rx), (:denominator ry)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''lt--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (Numbers'lt-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''lte--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (Numbers'lte-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''gte--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (Numbers'gte-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
        )
    )

    #_override
    (defn #_"Number" Ops'''negate--RatioOps [#_"RatioOps" this, #_"Number" x]
        (let [#_"Ratio" r (cast Ratio x)]
            (Ratio'new (.negate (:numerator r)), (:denominator r))
        )
    )

    #_override
    (defn #_"Number" Ops'''inc--RatioOps [#_"RatioOps" this, #_"Number" x]
        (Numbers'add-2ol x, 1)
    )

    #_override
    (defn #_"Number" Ops'''dec--RatioOps [#_"RatioOps" this, #_"Number" x]
        (Numbers'add-2ol x, -1)
    )
)

(class-ns BigIntOps
    (defn #_"BigIntOps" BigIntOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--BigIntOps [#_"BigIntOps" this, #_"Ops" y]
        (.opsWithBigInt y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--BigIntOps [#_"BigIntOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--BigIntOps [#_"BigIntOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--BigIntOps [#_"BigIntOps" this, #_"RatioOps" x]
        Numbers'RATIO_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--BigIntOps [#_"BigIntOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--BigIntOps [#_"BigIntOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_override
    (defn #_"boolean" Ops'''isZero--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (zero? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isPos--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (pos? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (neg? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_override
    (defn #_"Number" Ops'''add--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''add (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"Number" Ops'''multiply--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''multiply (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"Number" Ops'''divide--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (Numbers'divide-2ii (.toBigInteger this, x), (.toBigInteger this, y))
    )

    #_override
    (defn #_"Number" Ops'''quotient--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''quotient (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"Number" Ops'''remainder--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''remainder (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"boolean" Ops'''equiv--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.equals (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"boolean" Ops'''lt--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''lt (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"boolean" Ops'''lte--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (<= (.compareTo (.toBigInteger this, x), (.toBigInteger this, y)) 0)
    )

    #_override
    (defn #_"boolean" Ops'''gte--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (>= (.compareTo (.toBigInteger this, x), (.toBigInteger this, y)) 0)
    )

    #_override
    (defn #_"Number" Ops'''negate--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.negate (.toBigInteger this, x)))
    )

    #_override
    (defn #_"Number" Ops'''inc--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.add (.toBigInteger this, x), BigInteger/ONE))
    )

    #_override
    (defn #_"Number" Ops'''dec--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.subtract (.toBigInteger this, x), BigInteger/ONE))
    )
)

(class-ns BigDecimalOps
    (ยง def #_"Var" BigDecimalOps'MATH_CONTEXT RT'MATH_CONTEXT)

    (defn #_"BigDecimalOps" BigDecimalOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--BigDecimalOps [#_"BigDecimalOps" this, #_"Ops" y]
        (.opsWithBigDecimal y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--BigDecimalOps [#_"BigDecimalOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--BigDecimalOps [#_"BigDecimalOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--BigDecimalOps [#_"BigDecimalOps" this, #_"RatioOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--BigDecimalOps [#_"BigDecimalOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--BigDecimalOps [#_"BigDecimalOps" this, #_"BigDecimalOps" x]
        this
    )

    #_override
    (defn #_"boolean" Ops'''isZero--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (zero? (.signum bx))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isPos--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (pos? (.signum bx))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (neg? (.signum bx))
        )
    )

    #_override
    (defn #_"Number" Ops'''add--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.add (.toBigDecimal this, x), (.toBigDecimal this, y)) (.add (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''multiply--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.multiply (.toBigDecimal this, x), (.toBigDecimal this, y)) (.multiply (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''divide--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.divide (.toBigDecimal this, x), (.toBigDecimal this, y)) (.divide (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''quotient--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.divideToIntegralValue (.toBigDecimal this, x), (.toBigDecimal this, y)) (.divideToIntegralValue (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''remainder--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.remainder (.toBigDecimal this, x), (.toBigDecimal this, y)) (.remainder (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"boolean" Ops'''equiv--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (zero? (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)))
    )

    #_override
    (defn #_"boolean" Ops'''lt--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (neg? (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)))
    )

    #_override
    (defn #_"boolean" Ops'''lte--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (<= (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)) 0)
    )

    #_override
    (defn #_"boolean" Ops'''gte--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (>= (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)) 0)
    )

    #_override
    (defn #_"Number" Ops'''negate--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.negate (cast BigDecimal x)) (.negate (cast BigDecimal x), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''inc--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))
              #_"BigDecimal" bx (cast BigDecimal x)]
            (if (nil? mc) (.add bx, BigDecimal/ONE) (.add bx, BigDecimal/ONE, mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''dec--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))
              #_"BigDecimal" bx (cast BigDecimal x)]
            (if (nil? mc) (.subtract bx, BigDecimal/ONE) (.subtract bx, BigDecimal/ONE, mc))
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

(class-ns Numbers
    (defn #_"boolean" Numbers'isZero-1o [#_"Object" x]
        (.isZero (Numbers'ops x), (cast Number x))
    )

    (defn #_"boolean" Numbers'isPos-1o [#_"Object" x]
        (.isPos (Numbers'ops x), (cast Number x))
    )

    (defn #_"boolean" Numbers'isNeg-1o [#_"Object" x]
        (.isNeg (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'minus-1o [#_"Object" x]
        (.negate (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'minusP-1o [#_"Object" x]
        (.negateP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'inc-1o [#_"Object" x]
        (.inc (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'incP-1o [#_"Object" x]
        (.incP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'dec-1o [#_"Object" x]
        (.dec (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'decP-1o [#_"Object" x]
        (.decP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'add-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.add (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'addP-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.addP (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'minus-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (-> (.combine (Numbers'ops x), yops) (.add (cast Number x), (.negate yops, (cast Number y))))
        )
    )

    (defn #_"Number" Numbers'minusP-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)
              #_"Number" negativeY (.negateP yops, (cast Number y))
              #_"Ops" negativeYOps (Numbers'ops negativeY)]
            (-> (.combine (Numbers'ops x), negativeYOps) (.addP (cast Number x), negativeY))
        )
    )

    (defn #_"Number" Numbers'multiply-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.multiply (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'multiplyP-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.multiplyP (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'divide-2oo [#_"Object" x, #_"Object" y]
        (cond
            (Numbers'isNaN x) (cast Number x)
            (Numbers'isNaN y) (cast Number y)
            :else
                (let [#_"Ops" yops (Numbers'ops y)]
                    (when (.isZero yops, (cast Number y))
                        (throw (ArithmeticException. "Divide by zero"))
                    )
                    (-> (.combine (Numbers'ops x), yops) (.divide (cast Number x), (cast Number y)))
                )
        )
    )

    (defn #_"Number" Numbers'quotient-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (when (.isZero yops, (cast Number y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (-> (.combine (Numbers'ops x), yops) (.quotient (cast Number x), (cast Number y)))
        )
    )

    (defn #_"Number" Numbers'remainder-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (when (.isZero yops, (cast Number y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (-> (.combine (Numbers'ops x), yops) (.remainder (cast Number x), (cast Number y)))
        )
    )

    (defn #_"double" Numbers'quotient-2dd [#_"double" n, #_"double" d]
        (when (zero? d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (/ n d)]
            (cond (<= Long/MIN_VALUE q Long/MAX_VALUE)
                (do
                    (double (long q))
                )
                :else ;; bigint quotient
                (do
                    (.doubleValue (.toBigInteger (BigDecimal. q)))
                )
            )
        )
    )

    (defn #_"double" Numbers'remainder-2dd [#_"double" n, #_"double" d]
        (when (zero? d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (/ n d)]
            (cond (<= Long/MIN_VALUE q Long/MAX_VALUE)
                (do
                    (- n (* (long q) d))
                )
                :else ;; bigint quotient
                (let [#_"Number" bq (.toBigInteger (BigDecimal. q))]
                    (- n (* (.doubleValue bq) d))
                )
            )
        )
    )

    (defn #_"boolean" Numbers'equiv-2oo [#_"Object" x, #_"Object" y]
        (Numbers'equiv-2nn (cast Number x), (cast Number y))
    )

    (defn #_"boolean" Numbers'equiv-2nn [#_"Number" x, #_"Number" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.equiv x, y))
    )

    (defn #_"boolean" Numbers'equal [#_"Number" x, #_"Number" y]
        (and (= (Numbers'category x) (Numbers'category y)) (.equiv (.combine (Numbers'ops x), (Numbers'ops y)), x, y))
    )

    (defn #_"boolean" Numbers'lt-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.lt (cast Number x), (cast Number y)))
    )

    (defn #_"boolean" Numbers'lte-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.lte (cast Number x), (cast Number y)))
    )

    (defn #_"boolean" Numbers'gt-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.lt (cast Number y), (cast Number x)))
    )

    (defn #_"boolean" Numbers'gte-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.gte (cast Number x), (cast Number y)))
    )

    (defn #_"int" Numbers'compare [#_"Number" x, #_"Number" y]
        (let [#_"Ops" ops (.combine (Numbers'ops x), (Numbers'ops y))]
            (cond (.lt ops, x, y) -1 (.lt ops, y, x) 1 :else 0)
        )
    )

    (defn #_"BigInt" Numbers'toBigInt [#_"Object" x]
        (cond
            (instance? BigInt x)     (cast BigInt x)
            (instance? BigInteger x) (BigInt'fromBigInteger (cast BigInteger x))
            :else                    (BigInt'fromLong (.longValue (cast Number x)))
        )
    )

    (defn #_"BigInteger" Numbers'toBigInteger [#_"Object" x]
        (cond
            (instance? BigInteger x) (cast BigInteger x)
            (instance? BigInt x)     (BigInt''toBigInteger (cast BigInt x))
            :else                    (BigInteger/valueOf (.longValue (cast Number x)))
        )
    )

    (defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" x]
        (cond
            (instance? BigDecimal x)
                (cast BigDecimal x)
            (instance? BigInt x)
                (let [#_"BigInt" bi (cast BigInt x)]
                    (if (nil? (:bipart bi))
                        (BigDecimal/valueOf (:lpart bi))
                        (BigDecimal. (:bipart bi))
                    )
                )
            (instance? BigInteger x)
                (BigDecimal. (cast BigInteger x))
            (instance? Double x)
                (BigDecimal. (.doubleValue (cast Number x)))
            (instance? Float x)
                (BigDecimal. (.doubleValue (cast Number x)))
            (instance? Ratio x)
                (let [#_"Ratio" r (cast Ratio x)]
                    (cast BigDecimal (Numbers'divide-2oo (BigDecimal. (:numerator r)), (:denominator r)))
                )
            :else
                (BigDecimal/valueOf (.longValue (cast Number x)))
        )
    )

    (defn #_"Ratio" Numbers'toRatio [#_"Object" x]
        (cond
            (instance? Ratio x)
                (cast Ratio x)
            (instance? BigDecimal x)
                (let [#_"BigDecimal" bx (cast BigDecimal x) #_"BigInteger" bv (.unscaledValue bx) #_"int" scale (.scale bx)]
                    (if (neg? scale)
                        (Ratio'new (.multiply bv, (.pow BigInteger/TEN, (- scale))), BigInteger/ONE)
                        (Ratio'new bv, (.pow BigInteger/TEN, scale))
                    )
                )
            :else
                (Ratio'new (Numbers'toBigInteger x), BigInteger/ONE)
        )
    )

    (defn #_"Number" Numbers'rationalize [#_"Number" x]
        (cond
            (or (instance? Float x) (instance? Double x))
                (Numbers'rationalize (BigDecimal/valueOf (.doubleValue x)))
            (instance? BigDecimal x)
                (let [#_"BigDecimal" bx (cast BigDecimal x) #_"BigInteger" bv (.unscaledValue bx) #_"int" scale (.scale bx)]
                    (if (neg? scale)
                        (BigInt'fromBigInteger (.multiply bv, (.pow BigInteger/TEN, (- scale))))
                        (Numbers'divide-2ii bv, (.pow BigInteger/TEN, scale))
                    )
                )
            :else
                x
        )
    )

    (defn #_"Number" Numbers'reduceBigInt [#_"BigInt" val]
        (or (:bipart val) (Numbers'num-1l (:lpart val)))
    )

    (defn #_"Number" Numbers'divide-2ii [#_"BigInteger" n, #_"BigInteger" d]
        (when-not (.equals d, BigInteger/ZERO) => (throw (ArithmeticException. "Divide by zero"))
            (let [#_"BigInteger" gcd (.gcd n, d)]
                (when-not (.equals gcd, BigInteger/ZERO) => BigInt'ZERO
                    (let [n (.divide n, gcd) d (.divide d, gcd)]
                        (cond
                            (.equals d, BigInteger/ONE)
                                (BigInt'fromBigInteger n)
                            (.equals d, (.negate BigInteger/ONE))
                                (BigInt'fromBigInteger (.negate n))
                            :else
                                (Ratio'new (if (neg? (.signum d)) (.negate n) n), (if (neg? (.signum d)) (.negate d) d))
                        )
                    )
                )
            )
        )
    )

    (defn #_"int" Numbers'shiftLeftInt [#_"int" x, #_"int" n]
        (<< x n)
    )

    (defn #_"long" Numbers'shiftLeft-2oo [#_"Object" x, #_"Object" y]
        (Numbers'shiftLeft-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftLeft-2ol [#_"Object" x, #_"long" y]
        (Numbers'shiftLeft-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'shiftLeft-2lo [#_"long" x, #_"Object" y]
        (Numbers'shiftLeft-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftLeft-2ll [#_"long" x, #_"long" n]
        (<< x n)
    )

    (defn #_"int" Numbers'shiftRightInt [#_"int" x, #_"int" n]
        (>> x n)
    )

    (defn #_"long" Numbers'shiftRight-2oo [#_"Object" x, #_"Object" y]
        (Numbers'shiftRight-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftRight-2ol [#_"Object" x, #_"long" y]
        (Numbers'shiftRight-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'shiftRight-2lo [#_"long" x, #_"Object" y]
        (Numbers'shiftRight-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftRight-2ll [#_"long" x, #_"long" n]
        (>> x n)
    )

    (defn #_"int" Numbers'unsignedShiftRightInt [#_"int" x, #_"int" n]
        (>>> x n)
    )

    (defn #_"long" Numbers'unsignedShiftRight-2oo [#_"Object" x, #_"Object" y]
        (Numbers'unsignedShiftRight-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ol [#_"Object" x, #_"long" y]
        (Numbers'unsignedShiftRight-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'unsignedShiftRight-2lo [#_"long" x, #_"Object" y]
        (Numbers'unsignedShiftRight-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ll [#_"long" x, #_"long" n]
        (>>> x n)
    )

    (ยง def #_"LongOps"       Numbers'LONG_OPS       (LongOps'new)      )
    (ยง def #_"DoubleOps"     Numbers'DOUBLE_OPS     (DoubleOps'new)    )
    (ยง def #_"RatioOps"      Numbers'RATIO_OPS      (RatioOps'new)     )
    (ยง def #_"BigIntOps"     Numbers'BIGINT_OPS     (BigIntOps'new)    )
    (ยง def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps'new))

    (defn #_"Ops" Numbers'ops [#_"Object" x]
        (condp = (.getClass x)
            Integer    Numbers'LONG_OPS
            Long       Numbers'LONG_OPS
            BigInt     Numbers'BIGINT_OPS
            BigInteger Numbers'BIGINT_OPS
            Ratio      Numbers'RATIO_OPS
            Float      Numbers'DOUBLE_OPS
            Double     Numbers'DOUBLE_OPS
            BigDecimal Numbers'BIGDECIMAL_OPS
                       Numbers'LONG_OPS
        )
    )

    (defn #_"int" Numbers'hasheqFrom [#_"Number" x, #_"Class" xc]
        (cond
            (or (any = xc Integer Short Byte) (and (= xc BigInteger) (Numbers'lte-2ol x, Long/MAX_VALUE) (Numbers'gte-2ol x, Long/MIN_VALUE)))
                (Murmur3'hashLong (.longValue x))
            (= xc BigDecimal)
                ;; stripTrailingZeros() to make all numerically equal BigDecimal values come out the same before calling hashCode.
                ;; Special check for 0 because stripTrailingZeros() does not do anything to values equal to 0 with different scales.
                (.hashCode (if (Numbers'isZero-1o x) BigDecimal/ZERO (.stripTrailingZeros (cast BigDecimal x))))
            (and (= xc Float) (.equals x, (float -0.0)))
                0 ;; match 0.0f
            :else
                (.hashCode x)
        )
    )

    (defn #_"int" Numbers'hasheq [#_"Number" x]
        (let [#_"Class" xc (.getClass x)]
            (condp = xc
                Long
                    (Murmur3'hashLong (.longValue x))
                Double
                    (if (.equals x, -0.0)
                        0 ;; match 0.0
                        (.hashCode x)
                    )
                (Numbers'hasheqFrom x, xc)
            )
        )
    )

    (defn #_"Category" Numbers'category [#_"Object" x]
        (condp = (.getClass x)
            Integer    :Category'INTEGER
            Long       :Category'INTEGER
            BigInt     :Category'INTEGER
            Ratio      :Category'RATIO
            Float      :Category'FLOATING
            Double     :Category'FLOATING
            BigDecimal :Category'DECIMAL
                       :Category'INTEGER
        )
    )

    (defn #_"long" Numbers'bitOpsCast [#_"Object" x]
        (let [#_"Class" xc (.getClass x)]               ;; no bignums, no decimals
            (when (any = xc Long Integer Short Byte) => (throw (IllegalArgumentException. (str "bit operation not supported for: " xc)))
                (RT'longCast-1o x)
            )
        )
    )

    (defn #_"float[]" Numbers'float_array-2 [#_"int" size, #_"Object" init]
        (let [#_"float[]" ret (.float-array size)]
            (if (instance? Number init)
                (let [#_"float" f (.floatValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.floatValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"float[]" Numbers'float_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.float-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"float[]" ret (.float-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.floatValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"double[]" Numbers'double_array-2 [#_"int" size, #_"Object" init]
        (let [#_"double[]" ret (.double-array size)]
            (if (instance? Number init)
                (let [#_"double" f (.doubleValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.doubleValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"double[]" Numbers'double_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.double-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"double[]" ret (.double-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.doubleValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"int[]" Numbers'int_array-2 [#_"int" size, #_"Object" init]
        (let [#_"int[]" ret (.int-array size)]
            (if (instance? Number init)
                (let [#_"int" f (.intValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.intValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"int[]" Numbers'int_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.int-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"int[]" ret (.int-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.intValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"long[]" Numbers'long_array-2 [#_"int" size, #_"Object" init]
        (let [#_"long[]" ret (.long-array size)]
            (if (instance? Number init)
                (let [#_"long" f (.longValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.longValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"long[]" Numbers'long_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.long-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"long[]" ret (.long-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.longValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"short[]" Numbers'short_array-2 [#_"int" size, #_"Object" init]
        (let [#_"short[]" ret (.short-array size)]
            (if (instance? Short init)
                (let [#_"short" s (cast Short init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i s)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.shortValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"short[]" Numbers'short_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.short-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"short[]" ret (.short-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.shortValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"char[]" Numbers'char_array-2 [#_"int" size, #_"Object" init]
        (let [#_"char[]" ret (.char-array size)]
            (if (instance? Character init)
                (let [#_"char" c (cast Character init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i c)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (cast Character (.first s)))
                    )
                )
            )
            ret
        )
    )

    (defn #_"char[]" Numbers'char_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.char-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"char[]" ret (.char-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (cast Character (.first s)))
                )
                ret
            )
        )
    )

    (defn #_"byte[]" Numbers'byte_array-2 [#_"int" size, #_"Object" init]
        (let [#_"byte[]" ret (.byte-array size)]
            (if (instance? Byte init)
                (let [#_"byte" b (cast Byte init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i b)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.byteValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"byte[]" Numbers'byte_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.byte-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"byte[]" ret (.byte-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.byteValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-2 [#_"int" size, #_"Object" init]
        (let [#_"boolean[]" ret (.boolean-array size)]
            (if (instance? Boolean init)
                (let [#_"boolean" b (cast Boolean init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i b)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (cast Boolean (.first s)))
                    )
                )
            )
            ret
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.boolean-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"boolean[]" ret (.boolean-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (cast Boolean (.first s)))
                )
                ret
            )
        )
    )

    (defn #_"boolean[]" Numbers'booleans [#_"Object" array] (cast RT'BOOLEANS_CLASS array))
    (defn #_"byte[]"    Numbers'bytes    [#_"Object" array] (cast RT'BYTES_CLASS    array))
    (defn #_"short[]"   Numbers'shorts   [#_"Object" array] (cast RT'SHORTS_CLASS   array))
    (defn #_"char[]"    Numbers'chars    [#_"Object" array] (cast RT'CHARS_CLASS    array))
    (defn #_"int[]"     Numbers'ints     [#_"Object" array] (cast RT'INTS_CLASS     array))
    (defn #_"long[]"    Numbers'longs    [#_"Object" array] (cast RT'LONGS_CLASS    array))
    (defn #_"float[]"   Numbers'floats   [#_"Object" array] (cast RT'FLOATS_CLASS   array))
    (defn #_"double[]"  Numbers'doubles  [#_"Object" array] (cast RT'DOUBLES_CLASS  array))

    (defn #_"Number" Numbers'num-1o [#_"Object" x]
        (cast Number x)
    )

    (defn #_"Number" Numbers'num-1f [#_"float" x]
        (Float/valueOf x)
    )

    (defn #_"Number" Numbers'num-1d [#_"double" x]
        (Double/valueOf x)
    )

    (defn #_"double" Numbers'add-2dd [#_"double" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2dd [#_"double" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'minus-2dd [#_"double" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2dd [#_"double" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minus-1d [#_"double" x]
        (- x)
    )

    (defn #_"double" Numbers'minusP-1d [#_"double" x]
        (- x)
    )

    (defn #_"double" Numbers'inc-1d [#_"double" x]
        (inc x)
    )

    (defn #_"double" Numbers'incP-1d [#_"double" x]
        (inc x)
    )

    (defn #_"double" Numbers'dec-1d [#_"double" x]
        (dec x)
    )

    (defn #_"double" Numbers'decP-1d [#_"double" x]
        (dec x)
    )

    (defn #_"double" Numbers'multiply-2dd [#_"double" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2dd [#_"double" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'divide-2dd [#_"double" x, #_"double" y]
        (/ x y)
    )

    (defn #_"boolean" Numbers'equiv-2dd [#_"double" x, #_"double" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'lt-2dd [#_"double" x, #_"double" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2dd [#_"double" x, #_"double" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2dd [#_"double" x, #_"double" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2dd [#_"double" x, #_"double" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'isPos-1d [#_"double" x]
        (> x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1d [#_"double" x]
        (< x 0)
    )

    (defn #_"boolean" Numbers'isZero-1d [#_"double" x]
        (zero? x)
    )

    (defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (defn #_"int" Numbers'unchecked_int_add [#_"int" x, #_"int" y]
        (+ x y)
    )

    (defn #_"int" Numbers'unchecked_int_subtract [#_"int" x, #_"int" y]
        (- x y)
    )

    (defn #_"int" Numbers'unchecked_int_negate [#_"int" x]
        (- x)
    )

    (defn #_"int" Numbers'unchecked_int_inc [#_"int" x]
        (inc x)
    )

    (defn #_"int" Numbers'unchecked_int_dec [#_"int" x]
        (dec x)
    )

    (defn #_"int" Numbers'unchecked_int_multiply [#_"int" x, #_"int" y]
        (* x y)
    )

    (defn #_"long" Numbers'not-1o [#_"Object" x]
        (Numbers'not-1l (Numbers'bitOpsCast x))
    )

    (defn #_"long" Numbers'not-1l [#_"long" x]
        (bit-not x)
    )

    (defn #_"long" Numbers'and-2oo [#_"Object" x, #_"Object" y]
        (Numbers'and-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'and-2ol [#_"Object" x, #_"long" y]
        (Numbers'and-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'and-2lo [#_"long" x, #_"Object" y]
        (Numbers'and-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'and-2ll [#_"long" x, #_"long" y]
        (& x y)
    )

    (defn #_"long" Numbers'or-2oo [#_"Object" x, #_"Object" y]
        (Numbers'or-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'or-2ol [#_"Object" x, #_"long" y]
        (Numbers'or-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'or-2lo [#_"long" x, #_"Object" y]
        (Numbers'or-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'or-2ll [#_"long" x, #_"long" y]
        (| x y)
    )

    (defn #_"long" Numbers'xor-2oo [#_"Object" x, #_"Object" y]
        (Numbers'xor-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'xor-2ol [#_"Object" x, #_"long" y]
        (Numbers'xor-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'xor-2lo [#_"long" x, #_"Object" y]
        (Numbers'xor-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'xor-2ll [#_"long" x, #_"long" y]
        (bit-xor x y)
    )

    (defn #_"long" Numbers'andNot-2oo [#_"Object" x, #_"Object" y]
        (Numbers'andNot-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'andNot-2ol [#_"Object" x, #_"long" y]
        (Numbers'andNot-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'andNot-2lo [#_"long" x, #_"Object" y]
        (Numbers'andNot-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'andNot-2ll [#_"long" x, #_"long" y]
        (& x (bit-not y))
    )

    (defn #_"long" Numbers'clearBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'clearBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'clearBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'clearBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'clearBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'clearBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'clearBit-2ll [#_"long" x, #_"long" n]
        (& x (bit-not (<< 1 n)))
    )

    (defn #_"long" Numbers'setBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'setBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'setBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'setBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'setBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'setBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'setBit-2ll [#_"long" x, #_"long" n]
        (| x (<< 1 n))
    )

    (defn #_"long" Numbers'flipBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'flipBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'flipBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'flipBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'flipBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'flipBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'flipBit-2ll [#_"long" x, #_"long" n]
        (bit-xor x (<< 1 n))
    )

    (defn #_"boolean" Numbers'testBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'testBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"boolean" Numbers'testBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'testBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"boolean" Numbers'testBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'testBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"boolean" Numbers'testBit-2ll [#_"long" x, #_"long" n]
        (not= (& x (<< 1 n)) 0)
    )

    (defn #_"int" Numbers'unchecked_int_divide [#_"int" x, #_"int" y]
        (/ x y)
    )

    (defn #_"int" Numbers'unchecked_int_remainder [#_"int" x, #_"int" y]
        (% x y)
    )

    (defn #_"Number" Numbers'num-1l [#_"long" x]
        (Long/valueOf x)
    )

    (defn #_"long" Numbers'unchecked_add-2ll [#_"long" x, #_"long" y]
        (+ x y)
    )

    (defn #_"long" Numbers'unchecked_minus-2ll [#_"long" x, #_"long" y]
        (- x y)
    )

    (defn #_"long" Numbers'unchecked_multiply-2ll [#_"long" x, #_"long" y]
        (* x y)
    )

    (defn #_"long" Numbers'unchecked_minus-1l [#_"long" x]
        (- x)
    )

    (defn #_"long" Numbers'unchecked_inc-1l [#_"long" x]
        (inc x)
    )

    (defn #_"long" Numbers'unchecked_dec-1l [#_"long" x]
        (dec x)
    )

    (defn #_"Number" Numbers'unchecked_add-2oo [#_"Object" x, #_"Object" y]
        (Numbers'add-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2oo [#_"Object" x, #_"Object" y]
        (Numbers'minus-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2oo [#_"Object" x, #_"Object" y]
        (Numbers'multiply-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-1o [#_"Object" x]
        (Numbers'minus-1o x)
    )

    (defn #_"Number" Numbers'unchecked_inc-1o [#_"Object" x]
        (Numbers'inc-1o x)
    )

    (defn #_"Number" Numbers'unchecked_dec-1o [#_"Object" x]
        (Numbers'dec-1o x)
    )

    (defn #_"double" Numbers'unchecked_add-2dd [#_"double" x, #_"double" y]
        (Numbers'add-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dd [#_"double" x, #_"double" y]
        (Numbers'minus-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dd [#_"double" x, #_"double" y]
        (Numbers'multiply-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-1d [#_"double" x]
        (Numbers'minus-1d x)
    )

    (defn #_"double" Numbers'unchecked_inc-1d [#_"double" x]
        (Numbers'inc-1d x)
    )

    (defn #_"double" Numbers'unchecked_dec-1d [#_"double" x]
        (Numbers'dec-1d x)
    )

    (defn #_"double" Numbers'unchecked_add-2do [#_"double" x, #_"Object" y]
        (Numbers'add-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2do [#_"double" x, #_"Object" y]
        (Numbers'multiply-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2od [#_"Object" x, #_"double" y]
        (Numbers'add-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2od [#_"Object" x, #_"double" y]
        (Numbers'multiply-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2dl [#_"double" x, #_"long" y]
        (Numbers'add-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dl [#_"double" x, #_"long" y]
        (Numbers'minus-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dl [#_"double" x, #_"long" y]
        (Numbers'multiply-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2ld [#_"long" x, #_"double" y]
        (Numbers'add-2ld x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2ld [#_"long" x, #_"double" y]
        (Numbers'minus-2ld x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2ld [#_"long" x, #_"double" y]
        (Numbers'multiply-2ld x, y)
    )

    (defn #_"Number" Numbers'unchecked_add-2lo [#_"long" x, #_"Object" y]
        (Numbers'add-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2lo [#_"long" x, #_"Object" y]
        (Numbers'minus-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiply-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_add-2ol [#_"Object" x, #_"long" y]
        (Numbers'add-2ol x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2ol [#_"Object" x, #_"long" y]
        (Numbers'minus-2ol x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiply-2ol x, y)
    )

    (defn #_"Number" Numbers'quotient-2do [#_"double" x, #_"Object" y]
        (Numbers'quotient-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'quotient-2od [#_"Object" x, #_"double" y]
        (Numbers'quotient-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'quotient-2lo [#_"long" x, #_"Object" y]
        (Numbers'quotient-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'quotient-2ol [#_"Object" x, #_"long" y]
        (Numbers'quotient-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'quotient-2dl [#_"double" x, #_"long" y]
        (Numbers'quotient-2dd x, (double y))
    )

    (defn #_"double" Numbers'quotient-2ld [#_"long" x, #_"double" y]
        (Numbers'quotient-2dd (double x), y)
    )

    (defn #_"Number" Numbers'remainder-2do [#_"double" x, #_"Object" y]
        (Numbers'remainder-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'remainder-2od [#_"Object" x, #_"double" y]
        (Numbers'remainder-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'remainder-2lo [#_"long" x, #_"Object" y]
        (Numbers'remainder-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'remainder-2ol [#_"Object" x, #_"long" y]
        (Numbers'remainder-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'remainder-2dl [#_"double" x, #_"long" y]
        (Numbers'remainder-2dd x, (double y))
    )

    (defn #_"double" Numbers'remainder-2ld [#_"long" x, #_"double" y]
        (Numbers'remainder-2dd (double x), y)
    )

    (defn #_"long" Numbers'add-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (+ x y)]
            (when-not (and (neg? (bit-xor ret x)) (neg? (bit-xor ret y))) => (Numbers'throwIntOverflow)
                ret
            )
        )
    )

    (defn #_"Number" Numbers'addP-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (+ x y)]
            (if (and (neg? (bit-xor ret x)) (neg? (bit-xor ret y)))
                (Numbers'addP-2oo (cast Number x), (cast Number y))
                (Numbers'num-1l ret)
            )
        )
    )

    (defn #_"long" Numbers'minus-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (- x y)]
            (when-not (and (neg? (bit-xor ret x)) (neg? (bit-xor ret (bit-not y)))) => (Numbers'throwIntOverflow)
                ret
            )
        )
    )

    (defn #_"Number" Numbers'minusP-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (- x y)]
            (if (and (neg? (bit-xor ret x)) (neg? (bit-xor ret (bit-not y))))
                (Numbers'minusP-2oo (cast Number x), (cast Number y))
                (Numbers'num-1l ret)
            )
        )
    )

    (defn #_"long" Numbers'minus-1l [#_"long" x]
        (when-not (= x Long/MIN_VALUE) => (Numbers'throwIntOverflow)
            (- x)
        )
    )

    (defn #_"Number" Numbers'minusP-1l [#_"long" x]
        (if (= x Long/MIN_VALUE)
            (BigInt'fromBigInteger (.negate (BigInteger/valueOf x)))
            (Numbers'num-1l (- x))
        )
    )

    (defn #_"long" Numbers'inc-1l [#_"long" x] (if (= x Long/MAX_VALUE) (Numbers'throwIntOverflow) (inc x)))
    (defn #_"long" Numbers'dec-1l [#_"long" x] (if (= x Long/MIN_VALUE) (Numbers'throwIntOverflow) (dec x)))

    (defn #_"Number" Numbers'incP-1l [#_"long" x] (if (= x Long/MAX_VALUE) (.inc Numbers'BIGINT_OPS, x) (Numbers'num-1l (inc x))))
    (defn #_"Number" Numbers'decP-1l [#_"long" x] (if (= x Long/MIN_VALUE) (.dec Numbers'BIGINT_OPS, x) (Numbers'num-1l (dec x))))

    (defn #_"long" Numbers'multiply-2ll [#_"long" x, #_"long" y]
        (when-not (and (= x Long/MIN_VALUE) (neg? y)) => (Numbers'throwIntOverflow)
            (let [#_"long" ret (* x y)]
                (when (or (zero? y) (= (/ ret y) x)) => (Numbers'throwIntOverflow)
                    ret
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiplyP-2ll [#_"long" x, #_"long" y]
        (when-not (and (= x Long/MIN_VALUE) (neg? y)) => (Numbers'multiplyP-2oo (cast Number x), (cast Number y))
            (let [#_"long" ret (* x y)]
                (when (or (zero? y) (= (/ ret y) x)) => (Numbers'multiplyP-2oo (cast Number x), (cast Number y))
                    (Numbers'num-1l ret)
                )
            )
        )
    )

    (defn #_"long" Numbers'quotient-2ll [#_"long" x, #_"long" y]
        (/ x y)
    )

    (defn #_"long" Numbers'remainder-2ll [#_"long" x, #_"long" y]
        (% x y)
    )

    (defn #_"boolean" Numbers'equiv-2ll [#_"long" x, #_"long" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'lt-2ll [#_"long" x, #_"long" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2ll [#_"long" x, #_"long" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2ll [#_"long" x, #_"long" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2ll [#_"long" x, #_"long" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'isPos-1l [#_"long" x]
        (> x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1l [#_"long" x]
        (< x 0)
    )

    (defn #_"boolean" Numbers'isZero-1l [#_"long" x]
        (zero? x)
    )

    ;; overload resolution

    (defn #_"Number" Numbers'add-2lo [#_"long" x, #_"Object" y]
        (Numbers'add-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'add-2ol [#_"Object" x, #_"long" y]
        (Numbers'add-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'addP-2lo [#_"long" x, #_"Object" y]
        (Numbers'addP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'addP-2ol [#_"Object" x, #_"long" y]
        (Numbers'addP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'add-2do [#_"double" x, #_"Object" y]
        (Numbers'add-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'add-2od [#_"Object" x, #_"double" y]
        (Numbers'add-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'add-2dl [#_"double" x, #_"long" y]
        (+ x y)
    )

    (defn #_"double" Numbers'add-2ld [#_"long" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2do [#_"double" x, #_"Object" y]
        (Numbers'addP-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'addP-2od [#_"Object" x, #_"double" y]
        (Numbers'addP-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'addP-2dl [#_"double" x, #_"long" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2ld [#_"long" x, #_"double" y]
        (+ x y)
    )

    (defn #_"Number" Numbers'minus-2lo [#_"long" x, #_"Object" y]
        (Numbers'minus-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'minus-2ol [#_"Object" x, #_"long" y]
        (Numbers'minus-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'minusP-2lo [#_"long" x, #_"Object" y]
        (Numbers'minusP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'minusP-2ol [#_"Object" x, #_"long" y]
        (Numbers'minusP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'minus-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'minus-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'minus-2dl [#_"double" x, #_"long" y]
        (- x y)
    )

    (defn #_"double" Numbers'minus-2ld [#_"long" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'minusP-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'minusP-2dl [#_"double" x, #_"long" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2ld [#_"long" x, #_"double" y]
        (- x y)
    )

    (defn #_"Number" Numbers'multiply-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiply-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'multiply-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiply-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'multiplyP-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiplyP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'multiplyP-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiplyP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'multiply-2do [#_"double" x, #_"Object" y]
        (Numbers'multiply-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'multiply-2od [#_"Object" x, #_"double" y]
        (Numbers'multiply-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'multiply-2dl [#_"double" x, #_"long" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiply-2ld [#_"long" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2do [#_"double" x, #_"Object" y]
        (Numbers'multiplyP-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'multiplyP-2od [#_"Object" x, #_"double" y]
        (Numbers'multiplyP-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'multiplyP-2dl [#_"double" x, #_"long" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2ld [#_"long" x, #_"double" y]
        (* x y)
    )

    (defn #_"Number" Numbers'divide-2lo [#_"long" x, #_"Object" y]
        (Numbers'divide-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'divide-2ol [#_"Object" x, #_"long" y]
        (Numbers'divide-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'divide-2do [#_"double" x, #_"Object" y]
        (/ x (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'divide-2od [#_"Object" x, #_"double" y]
        (/ (.doubleValue (cast Number x)) y)
    )

    (defn #_"double" Numbers'divide-2dl [#_"double" x, #_"long" y]
        (/ x y)
    )

    (defn #_"double" Numbers'divide-2ld [#_"long" x, #_"double" y]
        (/ x y)
    )

    (defn #_"Number" Numbers'divide-2ll [#_"long" x, #_"long" y]
        (Numbers'divide-2oo (cast Number x), (cast Number y))
    )

    (defn #_"boolean" Numbers'lt-2lo [#_"long" x, #_"Object" y]
        (Numbers'lt-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'lt-2ol [#_"Object" x, #_"long" y]
        (Numbers'lt-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'lt-2do [#_"double" x, #_"Object" y]
        (< x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'lt-2od [#_"Object" x, #_"double" y]
        (< (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'lt-2dl [#_"double" x, #_"long" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lt-2ld [#_"long" x, #_"double" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2lo [#_"long" x, #_"Object" y]
        (Numbers'lte-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'lte-2ol [#_"Object" x, #_"long" y]
        (Numbers'lte-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'lte-2do [#_"double" x, #_"Object" y]
        (<= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'lte-2od [#_"Object" x, #_"double" y]
        (<= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'lte-2dl [#_"double" x, #_"long" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'lte-2ld [#_"long" x, #_"double" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2lo [#_"long" x, #_"Object" y]
        (Numbers'gt-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'gt-2ol [#_"Object" x, #_"long" y]
        (Numbers'gt-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'gt-2do [#_"double" x, #_"Object" y]
        (> x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'gt-2od [#_"Object" x, #_"double" y]
        (> (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'gt-2dl [#_"double" x, #_"long" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gt-2ld [#_"long" x, #_"double" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2lo [#_"long" x, #_"Object" y]
        (Numbers'gte-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'gte-2ol [#_"Object" x, #_"long" y]
        (Numbers'gte-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'gte-2do [#_"double" x, #_"Object" y]
        (>= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'gte-2od [#_"Object" x, #_"double" y]
        (>= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'gte-2dl [#_"double" x, #_"long" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'gte-2ld [#_"long" x, #_"double" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'equiv-2lo [#_"long" x, #_"Object" y]
        (Numbers'equiv-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'equiv-2ol [#_"Object" x, #_"long" y]
        (Numbers'equiv-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'equiv-2do [#_"double" x, #_"Object" y]
        (= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'equiv-2od [#_"Object" x, #_"double" y]
        (= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'equiv-2dl [#_"double" x, #_"long" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'equiv-2ld [#_"long" x, #_"double" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'isNaN [#_"Object" x]
        (or (and (instance? Double x) (.isNaN (cast Double x))) (and (instance? Float x) (.isNaN (cast Float x))))
    )

    (defn #_"long" Numbers'max-2ll [#_"long" x, #_"long" y]
        (if (> x y) x y)
    )

    (defn #_"double" Numbers'max-2dd [#_"double" x, #_"double" y]
        (Math/max x, y)
    )

    (defn #_"Object" Numbers'max-2ld [#_"long" x, #_"double" y] (cond (Double/isNaN y) y (> x y) x :else y))
    (defn #_"Object" Numbers'max-2dl [#_"double" x, #_"long" y] (cond (Double/isNaN x) x (> x y) x :else y))

    (defn #_"Object" Numbers'max-2lo [#_"long" x, #_"Object" y] (cond (Numbers'isNaN y) y (Numbers'gt-2lo x, y) x :else y))
    (defn #_"Object" Numbers'max-2ol [#_"Object" x, #_"long" y] (cond (Numbers'isNaN x) x (Numbers'gt-2ol x, y) x :else y))

    (defn #_"Object" Numbers'max-2do [#_"double" x, #_"Object" y]
        (cond (Double/isNaN x) x (Numbers'isNaN y) y (> x (.doubleValue (cast Number y))) x :else y)
    )

    (defn #_"Object" Numbers'max-2od [#_"Object" x, #_"double" y]
        (cond (Numbers'isNaN x) x (Double/isNaN y) y (< y (.doubleValue (cast Number x))) x :else y)
    )

    (defn #_"Object" Numbers'max-2oo [#_"Object" x, #_"Object" y]
        (cond (Numbers'isNaN x) x (Numbers'isNaN y) y (Numbers'gt-2oo x, y) x :else y)
    )

    (defn #_"long" Numbers'min-2ll [#_"long" x, #_"long" y]
        (if (< x y) x y)
    )

    (defn #_"double" Numbers'min-2dd [#_"double" x, #_"double" y]
        (Math/min x, y)
    )

    (defn #_"Object" Numbers'min-2ld [#_"long" x, #_"double" y] (cond (Double/isNaN y) y (< x y) x :else y))
    (defn #_"Object" Numbers'min-2dl [#_"double" x, #_"long" y] (cond (Double/isNaN x) x (< x y) x :else y))

    (defn #_"Object" Numbers'min-2lo [#_"long" x, #_"Object" y] (cond (Numbers'isNaN y) y (Numbers'lt-2lo x, y) x :else y))
    (defn #_"Object" Numbers'min-2ol [#_"Object" x, #_"long" y] (cond (Numbers'isNaN x) x (Numbers'lt-2ol x, y) x :else y))

    (defn #_"Object" Numbers'min-2do [#_"double" x, #_"Object" y]
        (cond (Double/isNaN x) x (Numbers'isNaN y) y (< x (.doubleValue (cast Number y))) x :else y)
    )

    (defn #_"Object" Numbers'min-2od [#_"Object" x, #_"double" y]
        (cond (Numbers'isNaN x) x (Double/isNaN y) y (< (.doubleValue (cast Number x)) y) x :else y)
    )

    (defn #_"Object" Numbers'min-2oo [#_"Object" x, #_"Object" y]
        (cond (Numbers'isNaN x) x (Numbers'isNaN y) y (Numbers'lt-2oo x, y) x :else y)
    )
)
)

(java-ns cloiure.lang.PersistentArrayMap

(class-ns MSeq
    (defn- #_"MSeq" MSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"MSeq" MSeq'new-2 [#_"Object[]" array, #_"int" i]
        (let [this (merge (ASeq'new-0) (MSeq'init))]
            (assoc this :array array :i i)
        )
    )

    (defn #_"MSeq" MSeq'new-3 [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (MSeq'init))]
            (assoc this :array array :i i)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--MSeq [#_"MSeq" this]
        (MapEntry'create (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--MSeq [#_"MSeq" this]
        (when (< (+ (:i this) 2) (alength (:array this)))
            (MSeq'new-2 (:array this), (+ (:i this) 2))
        )
    )

    #_override
    (defn #_"int" Counted'''count--MSeq [#_"MSeq" this]
        (/ (- (alength (:array this)) (:i this)) 2)
    )

    #_override
    (defn #_"MSeq" IObj'''withMeta--MSeq [#_"MSeq" this, #_"IPersistentMap" meta]
        (MSeq'new-3 meta, (:array this), (:i this))
    )
)

(class-ns MIter
    (defn #_"Iterator" MIter'new [#_"Object[]" a, #_"IFn" f]
        (let [#_"int'" vi (volatile! -2)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (< (+ @vi 2) (alength a))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (vswap! vi + 2)
                    (try
                        (.invoke f, (aget a @vi), (aget a (inc @vi)))
                        (catch IndexOutOfBoundsException _
                            (throw (NoSuchElementException.))
                        )
                    )
                )
            )
        )
    )
)

(class-ns TransientArrayMap
    (defn- #_"TransientArrayMap" TransientArrayMap'init []
        (hash-map
            #_volatile
            #_"int" :len 0
            #_"Object[]" :array nil
            #_volatile
            #_"Thread" :owner nil
        )
    )

    (defn #_"TransientArrayMap" TransientArrayMap'new [#_"Object[]" array]
        (let [#_"Object[]" a (make-array Object (Math/max PersistentArrayMap'HASHTABLE_THRESHOLD, (alength array)))
              _ (System/arraycopy array, 0, a, 0, (alength array))]
            (-> (merge (ATransientMap'new) (TransientArrayMap'init))
                (assoc :owner (Thread/currentThread) :array a :len (alength array))
            )
        )
    )

    #_method
    (defn- #_"int" TransientArrayMap''indexOf [#_"TransientArrayMap" this, #_"Object" key]
        (loop-when [#_"int" i 0] (< i (:len this)) => -1
            (if (PersistentArrayMap'equalKey (aget (:array this) i), key) i (recur (+ i 2)))
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doAssoc--TransientArrayMap [#_"TransientArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (TransientArrayMap''indexOf this, key)]
            (cond (<= 0 i) ;; already have key,
                (do
                    (when-not (= (aget (:array this) (inc i)) val) ;; no change, no op
                        (aset (:array this) (inc i) val)
                    )
                    this
                )
                :else ;; didn't have key, grow
                (if (< (:len this) (alength (:array this)))
                    (let [_ (aset (:array this) (:len this) key) this (update this :len inc)
                          _ (aset (:array this) (:len this) val) this (update this :len inc)]
                        this
                    )
                    (-> (PersistentHashMap'create-1a (:array this)) (.asTransient) (.assoc key, val))
                )
            )
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doWithout--TransientArrayMap [#_"TransientArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (TransientArrayMap''indexOf this, key)] (<= 0 i) => this
            ;; have key, will remove
            (when (<= 2 (:len this))
                (aset (:array this) i (aget (:array this) (- (:len this) 2)))
                (aset (:array this) (inc i) (aget (:array this) (- (:len this) 1)))
            )
            (assoc this :len (- (:len this) 2))
        )
    )

    #_override
    (defn #_"Object" ATransientMap'''doValAt--TransientArrayMap [#_"TransientArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (TransientArrayMap''indexOf this, key)]
            (if (<= 0 i) (aget (:array this) (inc i)) notFound)
        )
    )

    #_override
    (defn #_"int" ATransientMap'''doCount--TransientArrayMap [#_"TransientArrayMap" this]
        (/ (:len this) 2)
    )

    #_override
    (defn #_"IPersistentMap" ATransientMap'''doPersistent--TransientArrayMap [#_"TransientArrayMap" this]
        (.ensureEditable this)
        (ร ass this (assoc this :owner nil))
        (let [#_"Object[]" a (make-array Object (:len this))]
            (System/arraycopy (:array this), 0, a, 0, (:len this))
            (PersistentArrayMap'new-1 a)
        )
    )

    #_override
    (defn #_"void" ATransientMap'''ensureEditable--TransientArrayMap [#_"TransientArrayMap" this]
        (when (nil? (:owner this))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array.
 ;
 ; Note that instances of this class are constant values, i.e. add/remove etc return new values.
 ; Copies array on every change, so only appropriate for _very_small_ maps. nil keys and values are
 ; ok, but you won't be able to distinguish a nil value via valAt, use contains/entryAt for that.
 ;;
(class-ns PersistentArrayMap
    (ยง def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap'new-0))
    (def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" other]
        (let [#_"Iterator" it (.iterator (.entrySet other))]
            (loop-when [#_"ITransientMap" ret (.asTransient PersistentArrayMap'EMPTY)] (.hasNext it) => (.persistent ret)
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))]
                    (recur (.assoc ret, (.getKey e), (.getValue e)))
                )
            )
        )
    )

    (defn- #_"PersistentArrayMap" PersistentArrayMap'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-0 []
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (assoc this :array (make-array Object 0) :_meta nil)
        )
    )

    #_override
    (defn #_"PersistentArrayMap" IObj'''withMeta--PersistentArrayMap [#_"PersistentArrayMap" this, #_"IPersistentMap" meta]
        (PersistentArrayMap'new-2 meta, (:array this))
    )

    #_method
    (defn #_"PersistentArrayMap" PersistentArrayMap''create [#_"PersistentArrayMap" this & #_"Object..." init]
        (PersistentArrayMap'new-2 (.meta this), init)
    )

    #_method
    (defn #_"IPersistentMap" PersistentArrayMap''createHT [#_"PersistentArrayMap" this, #_"Object[]" init]
        (PersistentHashMap'create-2 (.meta this), init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" init]
        (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
            (loop-when-recur [#_"int" j (+ i 2)] (< j (alength init)) [(+ j 2)]
                (when (PersistentArrayMap'equalKey (aget init i), (aget init j))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget init i))))
                )
            )
        )
        (PersistentArrayMap'new-1 init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" init]
        (when (= (& (alength init) 1) 1)
            (throw (IllegalArgumentException. (str "No value supplied for key: " (aget init (dec (alength init))))))
        )
        ;; If this looks like it is doing busy-work, it is because it is achieving these goals: O(n^2) run time
        ;; like createWithCheck(), never modify init arg, and only allocate memory if there are duplicate keys.
        (let [#_"int" n
                (loop-when [n 0 #_"int" i 0] (< i (alength init)) => n
                    (let [#_"boolean" dup?
                            (loop-when [dup? false #_"int" j 0] (< j i) => dup?
                                (or (PersistentArrayMap'equalKey (aget init i), (aget init j))
                                    (recur dup? (+ j 2))
                                )
                            )]
                        (recur (if dup? n (+ n 2)) (+ i 2))
                    )
                )
              init
                (when (< n (alength init)) => init
                    ;; Create a new shorter array with unique keys, and the last value associated with each key.
                    ;; To behave like assoc, the first occurrence of each key must be used, since its metadata
                    ;; may be different than later equal keys.
                    (let [#_"Object[]" nodups (make-array Object n)
                          #_"int" m
                            (loop-when [m 0 #_"int" i 0] (< i (alength init)) => m
                                (let [#_"boolean" dup?
                                        (loop-when [dup? false #_"int" j 0] (< j m) => dup?
                                            (or (PersistentArrayMap'equalKey (aget init i), (aget nodups j))
                                                (recur dup? (+ j 2))
                                            )
                                        )
                                      m (when-not dup? => m
                                            (let [#_"int" j
                                                    (loop-when [j (- (alength init) 2)] (<= i j) => j
                                                        (if (PersistentArrayMap'equalKey (aget init i), (aget init j))
                                                            j
                                                            (recur (- j 2))
                                                        )
                                                    )]
                                                (aset nodups m (aget init i))
                                                (aset nodups (inc m) (aget init (inc j)))
                                                (+ m 2)
                                            )
                                        )]
                                    (recur m (+ i 2))
                                )
                            )]
                        (when (= m n) => (throw (IllegalArgumentException. (str "Internal error: m=" m)))
                            nodups
                        )
                    )
                )]
            (PersistentArrayMap'new-1 init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify it later.
     ;;
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-1 [#_"Object[]" init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (assoc this :array init :_meta nil)
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-2 [#_"IPersistentMap" meta, #_"Object[]" init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (assoc this :_meta meta :array init)
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentArrayMap [#_"PersistentArrayMap" this]
        (/ (alength (:array this)) 2)
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (<= 0 (PersistentArrayMap''indexOf this, key))
    )

    #_override
    (defn #_"IMapEntry" Associative'''entryAt--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (PersistentArrayMap''indexOf this, key)] (<= 0 i)
            (cast IMapEntry (MapEntry'create (aget (:array this) i), (aget (:array this) (inc i))))
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assocEx--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (PersistentArrayMap''indexOf this, key)]
            (when-not (<= 0 i) => (throw (RuntimeException. "Key already present"))
                ;; didn't have key, grow
                (if (< PersistentArrayMap'HASHTABLE_THRESHOLD (alength (:array this)))
                    (.assocEx (PersistentArrayMap''createHT this, (:array this)), key, val)
                    (let [#_"int" n (alength (:array this)) #_"Object[]" newArray (make-array Object (+ n 2))]
                        (when (pos? n)
                            (System/arraycopy (:array this), 0, newArray, 2, n)
                        )
                        (aset newArray 0 key)
                        (aset newArray 1 val)
                        (PersistentArrayMap''create this, newArray)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assoc--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (PersistentArrayMap''indexOf this, key)]
            (if (<= 0 i) ;; already have key, same-sized replacement
                (if (= (aget (:array this) (inc i)) val) ;; no change, no op
                    this
                    (let [#_"Object[]" newArray (.clone (:array this))]
                        (aset newArray (inc i) val)
                        (PersistentArrayMap''create this, newArray)
                    )
                )
                ;; didn't have key, grow
                (if (< PersistentArrayMap'HASHTABLE_THRESHOLD (alength (:array this)))
                    (.assoc (PersistentArrayMap''createHT this, (:array this)), key, val)
                    (let [#_"int" n (alength (:array this)) #_"Object[]" newArray (make-array Object (+ n 2))]
                        (when (pos? n)
                            (System/arraycopy (:array this), 0, newArray, 0, n)
                        )
                        (aset newArray n key)
                        (aset newArray (inc n) val)
                        (PersistentArrayMap''create this, newArray)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''without--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (PersistentArrayMap''indexOf this, key)] (<= 0 i) => this ;; don't have key, no op
            ;; have key, will remove
            (let-when [#_"int" n (- (alength (:array this)) 2)] (pos? n) => (.empty this)
                (let [#_"Object[]" a (make-array Object n)]
                    (System/arraycopy (:array this), 0, a, 0, i)
                    (System/arraycopy (:array this), (+ i 2), a, i, (- n i))
                    (PersistentArrayMap''create this, a)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentCollection'''empty--PersistentArrayMap [#_"PersistentArrayMap" this]
        (cast IPersistentMap (.withMeta PersistentArrayMap'EMPTY, (.meta this)))
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (PersistentArrayMap''indexOf this, key)]
            (if (<= 0 i) (aget (:array this) (inc i)) notFound)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (defn #_"int" PersistentArrayMap''capacity [#_"PersistentArrayMap" this]
        (.count this)
    )

    #_method
    (defn- #_"int" PersistentArrayMap''indexOfObject [#_"PersistentArrayMap" this, #_"Object" key]
        (let [#_"EquivPred" ep (Util'equivPred key)]
            (loop-when [#_"int" i 0] (< i (alength (:array this))) => -1
                (if (.equiv ep, key, (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    #_method
    (defn- #_"int" PersistentArrayMap''indexOf [#_"PersistentArrayMap" this, #_"Object" key]
        (when (instance? Keyword key) => (PersistentArrayMap''indexOfObject this, key)
            (loop-when [#_"int" i 0] (< i (alength (:array this))) => -1
                (if (= key (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    (defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" k1, #_"Object" k2]
        (if (instance? Keyword k1) (= k1 k2) (Util'equiv-2oo k1, k2))
    )

    #_foreign
    (defn #_"Iterator" iterator---PersistentArrayMap [#_"PersistentArrayMap" this]
        (MIter'new (:array this), APersistentMap'MAKE_ENTRY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''keyIterator--PersistentArrayMap [#_"PersistentArrayMap" this]
        (MIter'new (:array this), APersistentMap'MAKE_KEY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''valIterator--PersistentArrayMap [#_"PersistentArrayMap" this]
        (MIter'new (:array this), APersistentMap'MAKE_VAL)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentArrayMap [#_"PersistentArrayMap" this]
        (when (pos? (alength (:array this)))
            (MSeq'new-2 (:array this), 0)
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentArrayMap [#_"PersistentArrayMap" this]
        (:_meta this)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentArrayMap [#_"PersistentArrayMap" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (alength (:array this))) => r
            (let [r (.invoke f, r, (aget (:array this) i), (aget (:array this) (inc i)))]
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (+ i 2)))
            )
        )
    )

    #_override
    (defn #_"ITransientMap" IEditableCollection'''asTransient--PersistentArrayMap [#_"PersistentArrayMap" this]
        (TransientArrayMap'new (:array this))
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(class-ns TransientHashMap
    (defn- #_"TransientHashMap" TransientHashMap'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_volatile
            #_"INode" :root nil
            #_volatile
            #_"int" :count 0
            #_volatile
            #_"boolean" :hasNull false
            #_volatile
            #_"Object" :nullValue nil
            #_"Box" :leafFlag (Box'new nil)
        )
    )

    (defn #_"TransientHashMap" TransientHashMap'new-1 [#_"PersistentHashMap" m]
        (TransientHashMap'new-5 (AtomicReference. (Thread/currentThread)), (:root m), (:count m), (:hasNull m), (:nullValue m))
    )

    (defn #_"TransientHashMap" TransientHashMap'new-5 [#_"AtomicReference<Thread>" edit, #_"INode" root, #_"int" count, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (ATransientMap'new) (TransientHashMap'init))]
            (assoc this :edit edit :root root :count count :hasNull hasNull :nullValue nullValue)
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doAssoc--TransientHashMap [#_"TransientHashMap" this, #_"Object" key, #_"Object" val]
        (if (nil? key)
            (let [this (if (= (:nullValue this) val) this (assoc this :nullValue val))]
                (when-not (:hasNull this) => this
                    (-> this (update :count inc) (assoc :hasNull true))
                )
            )
            (let [this (assoc-in this [:leafFlag :val] nil)
                  #_"INode" n (.assoc (or (:root this) BitmapIndexedNode'EMPTY), (:edit this), 0, (PersistentHashMap'hash key), key, val, (:leafFlag this))
                  this (if (= (:root this) n) this (assoc this :root n))]
                (when (some? (:val (:leafFlag this))) => this
                    (update this :count inc)
                )
            )
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doWithout--TransientHashMap [#_"TransientHashMap" this, #_"Object" key]
        (if (nil? key)
            (when (:hasNull this) => this
                (-> this (assoc :hasNull false :nullValue nil) (update :count dec))
            )
            (when (some? (:root this)) => this
                (let [this (assoc-in this [:leafFlag :val] nil)
                      #_"INode" n (.without (:root this), (:edit this), 0, (PersistentHashMap'hash key), key, (:leafFlag this))
                      this (if (= (:root this) n) this (assoc this :root n))]
                    (when (some? (:val (:leafFlag this))) => this
                        (update this :count dec)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" ATransientMap'''doPersistent--TransientHashMap [#_"TransientHashMap" this]
        (.set (:edit this), nil)
        (PersistentHashMap'new-4 (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_override
    (defn #_"Object" ATransientMap'''doValAt--TransientHashMap [#_"TransientHashMap" this, #_"Object" key, #_"Object" notFound]
        (if (nil? key)
            (when (:hasNull this) => notFound
                (:nullValue this)
            )
            (when (some? (:root this)) => notFound
                (.find (:root this), 0, (PersistentHashMap'hash key), key, notFound)
            )
        )
    )

    #_override
    (defn #_"int" ATransientMap'''doCount--TransientHashMap [#_"TransientHashMap" this]
        (:count this)
    )

    #_override
    (defn #_"void" ATransientMap'''ensureEditable--TransientHashMap [#_"TransientHashMap" this]
        (when (nil? (.get (:edit this)))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(class-ns HSeq
    (defn #_"ISeq" HSeq'create-1 [#_"INode[]" nodes]
        (HSeq'create-4 nil, nodes, 0, nil)
    )

    (defn- #_"ISeq" HSeq'create-4 [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
        (when (nil? s) => (HSeq'new meta, nodes, i, s)
            (loop-when i (< i (alength nodes))
                (let-when [#_"INode" ai (aget nodes i)] (some? ai) => (recur (inc i))
                    (let-when [s (.nodeSeq ai)] (some? s) => (recur (inc i))
                        (HSeq'new meta, nodes, (inc i), s)
                    )
                )
            )
        )
    )

    (defn- #_"HSeq" HSeq'init []
        (hash-map
            #_"INode[]" :nodes nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn- #_"HSeq" HSeq'new [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
        (let [this (merge (ASeq'new-1 meta) (HSeq'init))]
            (assoc this :nodes nodes :i i :s s)
        )
    )

    #_override
    (defn #_"HSeq" IObj'''withMeta--HSeq [#_"HSeq" this, #_"IPersistentMap" meta]
        (HSeq'new meta, (:nodes this), (:i this), (:s this))
    )

    #_override
    (defn #_"Object" ISeq'''first--HSeq [#_"HSeq" this]
        (.first (:s this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--HSeq [#_"HSeq" this]
        (HSeq'create-4 nil, (:nodes this), (:i this), (.next (:s this)))
    )
)

(class-ns HIter
    (defn #_"Iterator" HIter'new [#_"INode[]" a, #_"IFn" f]
        (let [#_"int'" vi (volatile! 0) #_"Iterator'" vn (volatile! nil)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (loop []
                        (or
                            (when (some? @vn)
                                (or (.hasNext @vn)
                                    (vreset! vn nil)
                                )
                            )
                            (and (< @vi (alength a))
                                (let [#_"INode" ai (aget a @vi)]
                                    (vswap! vi inc)
                                    (when (some? ai)
                                        (vreset! vn (.iterator ai, f))
                                    )
                                    (recur)
                                )
                            )
                        )
                    )
                )

                #_foreign
                (#_"Object" next [#_"Iterator" self]
                    (when (.hasNext self) => (throw (NoSuchElementException.))
                        (.next @vn)
                    )
                )
            )
        )
    )
)

(class-ns ArrayNode
    (defn- #_"ArrayNode" ArrayNode'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_"int" :count 0
            #_"INode[]" :array nil
        )
    )

    (defn #_"ArrayNode" ArrayNode'new [#_"AtomicReference<Thread>" edit, #_"int" count, #_"INode[]" array]
        (let [this (ArrayNode'init)]
            (assoc this :edit edit :count count :array array)
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-6--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)]
            (if (some? ai)
                (let [#_"INode" node (.assoc ai, (+ shift 5), hash, key, val, addedLeaf)]
                    (when-not (= node ai) => this
                        (ArrayNode'new nil, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                    )
                )
                (let [#_"INode" node (.assoc BitmapIndexedNode'EMPTY, (+ shift 5), hash, key, val, addedLeaf)]
                    (ArrayNode'new nil, (inc (:count this)), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-4--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)] (some? ai) => this
            (let-when-not [#_"INode" node (.without ai, (+ shift 5), hash, key)] (= node ai) => this
                (cond
                    (some? node)         (ArrayNode'new nil, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                    (<= (:count this) 8) (ArrayNode''pack this, nil, i) ;; shrink
                    :else                (ArrayNode'new nil, (dec (:count this)), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                )
            )
        )
    )

    #_override
    (defn #_"IMapEntry" INode'''find-4--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" node (aget (:array this) i)]
            (when (some? node)
                (.find node, (+ shift 5), hash, key)
            )
        )
    )

    #_override
    (defn #_"Object" INode'''find-5--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" node (aget (:array this) i)]
            (when (some? node) => notFound
                (.find node, (+ shift 5), hash, key, notFound)
            )
        )
    )

    #_override
    (defn #_"ISeq" INode'''nodeSeq--ArrayNode [#_"ArrayNode" this]
        (HSeq'create-1 (:array this))
    )

    #_override
    (defn #_"Iterator" INode'''iterator--ArrayNode [#_"ArrayNode" this, #_"IFn" f]
        (HIter'new (:array this), f)
    )

    #_override
    (defn #_"Object" INode'''kvreduce--ArrayNode [#_"ArrayNode" this, #_"IFn" f, #_"Object" r]
        (let [#_"INode[]" a (:array this)]
            (loop-when [r r #_"int" i 0] (< i (alength a)) => r
                (let-when [#_"INode" node (aget a i)] (some? node) => (recur r (inc i))
                    (let [r (.kvreduce node, f, r)]
                        (when-not (RT'isReduced r) => r
                            (recur r (inc i))
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" INode'''fold--ArrayNode [#_"ArrayNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (let [#_"List<Callable>" tasks (ArrayList.)]
            (doseq [#_"INode" node (:array this)]
                (when (some? node)
                    (.add tasks,
                        (reify Callable
                            #_foreign
                            (#_"Object" call [#_"Callable" _self]
                                (.fold node, combinef, reducef, fjtask, fjfork, fjjoin)
                            )
                        )
                    )
                )
            )
            (ArrayNode'foldTasks tasks, combinef, fjtask, fjfork, fjjoin)
        )
    )

    (defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" tasks, #_"IFn" combinef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (cond
            (.isEmpty tasks)
                (.invoke combinef)
            (= (.size tasks) 1)
                (.call (.get tasks, 0))
            :else
                (let [#_"int" n (.size tasks)
                      #_"List<Callable>" t1 (.subList tasks, 0, (/ n 2)) #_"List<Callable>" t2 (.subList tasks, (/ n 2), n)
                      #_"Object" forked
                        (.invoke fjfork, (.invoke fjtask,
                            (reify Callable
                                #_foreign
                                (#_"Object" call [#_"Callable" _self]
                                    (ArrayNode'foldTasks t2, combinef, fjtask, fjfork, fjjoin)
                                )
                            )
                        ))]
                    (.invoke combinef, (ArrayNode'foldTasks t1, combinef, fjtask, fjfork, fjjoin), (.invoke fjjoin, forked))
                )
        )
    )

    #_method
    (defn- #_"ArrayNode" ArrayNode''ensureEditable [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit]
        (if (= (:edit this) edit)
            this
            (ArrayNode'new edit, (:count this), (.clone (:array this)))
        )
    )

    #_method
    (defn- #_"ArrayNode" ArrayNode''editAndSet [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"INode" node]
        (let [#_"ArrayNode" e (ArrayNode''ensureEditable this, edit)]
            (aset (:array e) i node)
            e
        )
    )

    #_method
    (defn- #_"INode" ArrayNode''pack [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" idx]
        (let [#_"Object[]" a (make-array Object (* 2 (dec (:count this))))
              [#_"int" bitmap #_"int" j]
                (loop-when [bitmap 0 j 1 #_"int" i 0] (< i idx) => [bitmap j]
                    (let [[bitmap j]
                            (when (some? (aget (:array this) i)) => [bitmap j]
                                (aset a j (aget (:array this) i))
                                [(| bitmap (<< 1 i)) (+ j 2)]
                            )]
                        (recur bitmap j (inc i))
                    )
                )
              bitmap
                (loop-when [bitmap bitmap j j #_"int" i (inc idx)] (< i (alength (:array this))) => bitmap
                    (let [[bitmap j]
                            (when (some? (aget (:array this) i)) => [bitmap j]
                                (aset a j (aget (:array this) i))
                                [(| bitmap (<< 1 i)) (+ j 2)]
                            )]
                        (recur bitmap j (inc i))
                    )
                )]
            (BitmapIndexedNode'new edit, bitmap, a)
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-7--ArrayNode [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)]
            (if (some? ai)
                (let [#_"INode" node (.assoc ai, edit, (+ shift 5), hash, key, val, addedLeaf)]
                    (when-not (= node ai) => this
                        (ArrayNode''editAndSet this, edit, i, node)
                    )
                )
                (-> (ArrayNode''editAndSet this, edit, i, (.assoc BitmapIndexedNode'EMPTY, edit, (+ shift 5), hash, key, val, addedLeaf))
                    (update :count inc)
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-6--ArrayNode [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)] (some? ai) => this
            (let-when-not [#_"INode" node (.without ai, edit, (+ shift 5), hash, key, removedLeaf)] (= node ai) => this
                (cond
                    (some? node)         (ArrayNode''editAndSet this, edit, i, node)
                    (<= (:count this) 8) (ArrayNode''pack this, edit, i) ;; shrink
                    :else            (-> (ArrayNode''editAndSet this, edit, i, node) (update :count dec))
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode
    (ยง def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (BitmapIndexedNode'new nil, 0, (object-array 0)))

    (defn- #_"BitmapIndexedNode" BitmapIndexedNode'init []
        (hash-map
            #_"int" :bitmap 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"BitmapIndexedNode" BitmapIndexedNode'new [#_"AtomicReference<Thread>" edit, #_"int" bitmap, #_"Object[]" array]
        (let [this (BitmapIndexedNode'init)]
            (assoc this :bitmap bitmap :array array :edit edit)
        )
    )

    #_method
    (defn #_"int" BitmapIndexedNode''index [#_"BitmapIndexedNode" this, #_"int" bit]
        (Integer/bitCount (& (:bitmap this) (dec bit)))
    )

    #_override
    (defn #_"INode" INode'''assoc-6--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" bit (PersistentHashMap'bitpos hash, shift) #_"int" idx (BitmapIndexedNode''index this, bit)]
            (if-not (zero? (& (:bitmap this) bit))
                (let [#_"Object" keyOrNull (aget (:array this) (* 2 idx))
                      #_"Object" valOrNode (aget (:array this) (inc (* 2 idx)))
                      _ (cond
                            (nil? keyOrNull)
                                (let [#_"INode" n (.assoc (cast INode valOrNode), (+ shift 5), hash, key, val, addedLeaf)]
                                    (when-not (= n valOrNode)
                                        (PersistentHashMap'cloneAndSet-3 (:array this), (inc (* 2 idx)), n)
                                    )
                                )
                            (Util'equiv-2oo key, keyOrNull)
                                (when-not (= val valOrNode)
                                    (PersistentHashMap'cloneAndSet-3 (:array this), (inc (* 2 idx)), val)
                                )
                            :else
                                (let [_ (ร ass (:val addedLeaf) addedLeaf)]
                                    (PersistentHashMap'cloneAndSet-5 (:array this), (* 2 idx), nil, (inc (* 2 idx)), (PersistentHashMap'createNode-6 (+ shift 5), keyOrNull, valOrNode, hash, key, val))
                                )
                        )]
                    (if (some? _) (BitmapIndexedNode'new nil, (:bitmap this), _) this)
                )
                (let [#_"int" n (Integer/bitCount (:bitmap this))]
                    (if (<= 16 n)
                        (let [#_"INode[]" nodes (make-array #_"INode" Object 32) #_"int" jdx (PersistentHashMap'mask hash, shift)]
                            (aset nodes jdx (.assoc BitmapIndexedNode'EMPTY, (+ shift 5), hash, key, val, addedLeaf))
                            (loop-when [#_"int" j 0 #_"int" i 0] (< i 32)
                                (when-not (= (& (>>> (:bitmap this) i) 1) 0) => (recur j (inc i))
                                    (if (some? (aget (:array this) j))
                                        (aset nodes i (.assoc BitmapIndexedNode'EMPTY, (+ shift 5), (PersistentHashMap'hash (aget (:array this) j)), (aget (:array this) j), (aget (:array this) (inc j)), addedLeaf))
                                        (aset nodes i (cast INode (aget (:array this) (inc j))))
                                    )
                                    (recur (+ j 2) (inc i))
                                )
                            )
                            (ArrayNode'new nil, (inc n), nodes)
                        )
                        (let [#_"Object[]" a (make-array Object (* 2 (inc n)))]
                            (System/arraycopy (:array this), 0, a, 0, (* 2 idx))
                            (aset a (* 2 idx) key)
                            (ร ass (:val addedLeaf) addedLeaf)
                            (aset a (inc (* 2 idx)) val)
                            (System/arraycopy (:array this), (* 2 idx), a, (* 2 (inc idx)), (* 2 (- n idx)))
                            (BitmapIndexedNode'new nil, (| (:bitmap this) bit), a)
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-4--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => this
            (let [#_"int" i (BitmapIndexedNode''index this, bit) #_"int" ii (* 2 i)
                  #_"Object" keyOrNull (aget (:array this) ii)
                  #_"Object" valOrNode (aget (:array this) (inc ii))]
                (if (some? keyOrNull)
                    (when (Util'equiv-2oo key, keyOrNull) => this
                        ;; TODO: collapse
                        (BitmapIndexedNode'new nil, (bit-xor (:bitmap this) bit), (PersistentHashMap'removePair (:array this), i))
                    )
                    (let [#_"INode" n (.without (cast INode valOrNode), (+ shift 5), hash, key)]
                        (cond
                            (= n valOrNode)
                                this
                            (some? n)
                                (BitmapIndexedNode'new nil, (:bitmap this), (PersistentHashMap'cloneAndSet-3 (:array this), (inc ii), n))
                            (= (:bitmap this) bit)
                                nil
                            :else
                                (BitmapIndexedNode'new nil, (bit-xor (:bitmap this) bit), (PersistentHashMap'removePair (:array this), i))
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IMapEntry" INode'''find-4--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit))
            (let [#_"int" i (BitmapIndexedNode''index this, bit)
                  #_"Object" keyOrNull (aget (:array this) (* 2 i))
                  #_"Object" valOrNode (aget (:array this) (inc (* 2 i)))]
                (cond
                    (nil? keyOrNull)                (.find (cast INode valOrNode), (+ shift 5), hash, key)
                    (Util'equiv-2oo key, keyOrNull) (cast IMapEntry (MapEntry'create keyOrNull, valOrNode))
                )
            )
        )
    )

    #_override
    (defn #_"Object" INode'''find-5--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => notFound
            (let [#_"int" i (BitmapIndexedNode''index this, bit)
                  #_"Object" keyOrNull (aget (:array this) (* 2 i))
                  #_"Object" valOrNode (aget (:array this) (inc (* 2 i)))]
                (cond
                    (nil? keyOrNull)                (.find (cast INode valOrNode), (+ shift 5), hash, key, notFound)
                    (Util'equiv-2oo key, keyOrNull) valOrNode
                    :else                           notFound
                )
            )
        )
    )

    #_override
    (defn #_"ISeq" INode'''nodeSeq--BitmapIndexedNode [#_"BitmapIndexedNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_override
    (defn #_"Iterator" INode'''iterator--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"IFn" f]
        (NodeIter'new (:array this), f)
    )

    #_override
    (defn #_"Object" INode'''kvreduce--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"IFn" f, #_"Object" r]
        (NodeSeq'kvreduce (:array this), f, r)
    )

    #_override
    (defn #_"Object" INode'''fold--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (NodeSeq'kvreduce (:array this), reducef, (.invoke combinef))
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''ensureEditable [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit]
        (when-not (= (:edit this) edit) => this
            (let [#_"int" n (Integer/bitCount (:bitmap this)) #_"Object[]" a (make-array Object (* 2 (inc n)))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                (BitmapIndexedNode'new edit, (:bitmap this), a)
            )
        )
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''editAndSet-4 [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" x]
        (let [#_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit)]
            (aset (:array e) i x)
            e
        )
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''editAndSet-6 [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" x, #_"int" j, #_"Object" y]
        (let [#_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit)]
            (aset (:array e) i x)
            (aset (:array e) j y)
            e
        )
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''editAndRemovePair [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" bit, #_"int" i]
        (when-not (= (:bitmap this) bit)
            (let [#_"BitmapIndexedNode" e (-> (BitmapIndexedNode''ensureEditable this, edit) (update :bitmap bit-xor bit))
                  #_"Object[]" a (:array e) #_"int" n (alength a)]
                (System/arraycopy a, (* 2 (inc i)), a, (* 2 i), (- n (* 2 (inc i))))
                (aset a (- n 2) nil)
                (aset a (- n 1) nil)
                e
            )
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-7--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" bit (PersistentHashMap'bitpos hash, shift) #_"int" idx (BitmapIndexedNode''index this, bit)]
            (if-not (zero? (& (:bitmap this) bit))
                (let [#_"Object" keyOrNull (aget (:array this) (* 2 idx))
                      #_"Object" valOrNode (aget (:array this) (inc (* 2 idx)))]
                    (cond
                        (nil? keyOrNull)
                            (let [#_"INode" n (.assoc (cast INode valOrNode), edit, (+ shift 5), hash, key, val, addedLeaf)]
                                (when-not (= n valOrNode) => this
                                    (BitmapIndexedNode''editAndSet-4 this, edit, (inc (* 2 idx)), n)
                                )
                            )
                        (Util'equiv-2oo key, keyOrNull)
                            (when-not (= val valOrNode) => this
                                (BitmapIndexedNode''editAndSet-4 this, edit, (inc (* 2 idx)), val)
                            )
                        :else
                            (let [_ (ร ass (:val addedLeaf) addedLeaf)]
                                (BitmapIndexedNode''editAndSet-6 this, edit, (* 2 idx), nil, (inc (* 2 idx)), (PersistentHashMap'createNode-7 edit, (+ shift 5), keyOrNull, valOrNode, hash, key, val))
                            )
                    )
                )
                (let [#_"int" n (Integer/bitCount (:bitmap this))]
                    (cond
                        (< (* n 2) (alength (:array this)))
                            (let [_ (ร ass (:val addedLeaf) addedLeaf)
                                  #_"BitmapIndexedNode" e (-> (BitmapIndexedNode''ensureEditable this, edit) (update :bitmap | bit))]
                                (System/arraycopy (:array e), (* 2 idx), (:array e), (* 2 (inc idx)), (* 2 (- n idx)))
                                (aset (:array e) (* 2 idx) key)
                                (aset (:array e) (inc (* 2 idx)) val)
                                e
                            )
                        (<= 16 n)
                            (let [#_"INode[]" nodes (make-array #_"INode" Object 32) #_"int" jdx (PersistentHashMap'mask hash, shift)]
                                (aset nodes jdx (.assoc BitmapIndexedNode'EMPTY, edit, (+ shift 5), hash, key, val, addedLeaf))
                                (loop-when [#_"int" j 0 #_"int" i 0] (< i 32)
                                    (when-not (= (& (>>> (:bitmap this) i) 1) 0) => (recur j (inc i))
                                        (if (some? (aget (:array this) j))
                                            (aset nodes i (.assoc BitmapIndexedNode'EMPTY, edit, (+ shift 5), (PersistentHashMap'hash (aget (:array this) j)), (aget (:array this) j), (aget (:array this) (inc j)), addedLeaf))
                                            (aset nodes i (cast INode (aget (:array this) (inc j))))
                                        )
                                        (recur (+ j 2) (inc i))
                                    )
                                )
                                (ArrayNode'new edit, (inc n), nodes)
                            )
                        :else
                            (let [#_"Object[]" a (make-array Object (* 2 (+ n 4)))]
                                (System/arraycopy (:array this), 0, a, 0, (* 2 idx))
                                (aset a (* 2 idx) key)
                                (ร ass (:val addedLeaf) addedLeaf)
                                (aset a (inc (* 2 idx)) val)
                                (System/arraycopy (:array this), (* 2 idx), a, (* 2 (inc idx)), (* 2 (- n idx)))
                                (-> (BitmapIndexedNode''ensureEditable this, edit)
                                    (assoc :array a)
                                    (update :bitmap | bit)
                                )
                            )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-6--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => this
            (let [#_"int" i (BitmapIndexedNode''index this, bit) #_"int" ii (* 2 i)
                  #_"Object" keyOrNull (aget (:array this) ii)
                  #_"Object" valOrNode (aget (:array this) (inc ii))]
                (if (some? keyOrNull)
                    (when (Util'equiv-2oo key, keyOrNull) => this
                        (ร ass (:val removedLeaf) removedLeaf)
                        ;; TODO: collapse
                        (BitmapIndexedNode''editAndRemovePair this, edit, bit, i)
                    )
                    (let [#_"INode" n (.without (cast INode valOrNode), edit, (+ shift 5), hash, key, removedLeaf)]
                        (cond
                            (= n valOrNode)
                                this
                            (some? n)
                                (BitmapIndexedNode''editAndSet-4 this, edit, (inc ii), n)
                            (= (:bitmap this) bit)
                                nil
                            :else
                                (BitmapIndexedNode''editAndRemovePair this, edit, bit, i)
                        )
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode
    (defn- #_"HashCollisionNode" HashCollisionNode'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_"int" :hash 0
            #_"int" :count 0
            #_"Object[]" :array nil
        )
    )

    (defn #_"HashCollisionNode" HashCollisionNode'new [#_"AtomicReference<Thread>" edit, #_"int" hash, #_"int" count & #_"Object..." array]
        (let [this (HashCollisionNode'init)]
            (assoc this :edit edit :hash hash :count count :array array)
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-6--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (if (= hash (:hash this))
            (let [#_"int" i (HashCollisionNode''findIndex this, key)]
                (if (<= 0 i)
                    (when-not (= (aget (:array this) (inc i)) val) => this
                        (HashCollisionNode'new nil, hash, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), (inc i), val))
                    )
                    (let [#_"int" n (:count this) #_"Object[]" a (make-array Object (* 2 (inc n)))]
                        (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                        (aset a (* 2 n) key)
                        (aset a (inc (* 2 n)) val)
                        (ร ass (:val addedLeaf) addedLeaf)
                        (HashCollisionNode'new (:edit this), hash, (inc n), a)
                    )
                )
            )
            ;; nest it in a bitmap node
            (let [#_"BitmapIndexedNode" node (BitmapIndexedNode'new nil, (PersistentHashMap'bitpos (:hash this), shift), (object-array [ nil, this ]))]
                (.assoc node, shift, hash, key, val, addedLeaf)
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-4--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i) => this
            (let-when [#_"int" n (:count this)] (< 1 n)
                (HashCollisionNode'new nil, hash, (dec n), (PersistentHashMap'removePair (:array this), (/ i 2)))
            )
        )
    )

    #_override
    (defn #_"IMapEntry" INode'''find-4--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i)
            (let-when [#_"Object" ai (aget (:array this) i)] (Util'equiv-2oo key, ai)
                (cast IMapEntry (MapEntry'create ai, (aget (:array this) (inc i))))
            )
        )
    )

    #_override
    (defn #_"Object" INode'''find-5--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i) => notFound
            (when (Util'equiv-2oo key, (aget (:array this) i)) => notFound
                (aget (:array this) (inc i))
            )
        )
    )

    #_override
    (defn #_"ISeq" INode'''nodeSeq--HashCollisionNode [#_"HashCollisionNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_override
    (defn #_"Iterator" INode'''iterator--HashCollisionNode [#_"HashCollisionNode" this, #_"IFn" f]
        (NodeIter'new (:array this), f)
    )

    #_override
    (defn #_"Object" INode'''kvreduce--HashCollisionNode [#_"HashCollisionNode" this, #_"IFn" f, #_"Object" r]
        (NodeSeq'kvreduce (:array this), f, r)
    )

    #_override
    (defn #_"Object" INode'''fold--HashCollisionNode [#_"HashCollisionNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (NodeSeq'kvreduce (:array this), reducef, (.invoke combinef))
    )

    #_method
    (defn #_"int" HashCollisionNode''findIndex [#_"HashCollisionNode" this, #_"Object" key]
        (let [#_"int" n (* 2 (:count this))]
            (loop-when [#_"int" i 0] (< i n) => -1
                (if (Util'equiv-2oo key, (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''ensureEditable-2 [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit]
        (when-not (= (:edit this) edit) => this
            (let [#_"int" n (:count this) #_"Object[]" a (make-array Object (* 2 (inc n)))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                (HashCollisionNode'new edit, (:hash this), n, a)
            )
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''ensureEditable-4 [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" count, #_"Object[]" array]
        (if (= (:edit this) edit)
            (assoc this :array array :count count)
            (HashCollisionNode'new edit, (:hash this), count, array)
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''editAndSet-4 [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
        (let [#_"HashCollisionNode" e (HashCollisionNode''ensureEditable-2 this, edit)]
            (aset (:array e) i a)
            e
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''editAndSet-6 [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
        (let [#_"HashCollisionNode" e (HashCollisionNode''ensureEditable-2 this, edit)]
            (aset (:array e) i a)
            (aset (:array e) j b)
            e
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-7--HashCollisionNode [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (if (= hash (:hash this))
            (let [#_"int" i (HashCollisionNode''findIndex this, key)]
                (if (<= 0 i)
                    (when-not (= (aget (:array this) (inc i)) val) => this
                        (HashCollisionNode''editAndSet-4 this, edit, (inc i), val)
                    )
                    (let [#_"int" n (:count this) #_"int" m (alength (:array this))]
                        (if (< (* 2 n) m)
                            (let [_ (ร ass (:val addedLeaf) addedLeaf)]
                                (-> (HashCollisionNode''editAndSet-6 this, edit, (* 2 n), key, (inc (* 2 n)), val)
                                    (update :count inc)
                                )
                            )
                            (let [#_"Object[]" a (make-array Object (+ m 2))]
                                (System/arraycopy (:array this), 0, a, 0, m)
                                (aset a m key)
                                (aset a (inc m) val)
                                (ร ass (:val addedLeaf) addedLeaf)
                                (HashCollisionNode''ensureEditable-4 this, edit, (inc n), a)
                            )
                        )
                    )
                )
            )
            ;; nest it in a bitmap node
            (let [#_"BitmapIndexedNode" node (BitmapIndexedNode'new edit, (PersistentHashMap'bitpos (:hash this), shift), (object-array [ nil, this, nil, nil ]))]
                (.assoc node, edit, shift, hash, key, val, addedLeaf)
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-6--HashCollisionNode [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i) => this
            (ร ass (:val removedLeaf) removedLeaf)
            (let-when [#_"int" n (:count this)] (< 1 n)
                (let [#_"HashCollisionNode" e (-> (HashCollisionNode''ensureEditable-2 this, edit) (update :count dec))
                      #_"int" m (* 2 n)]
                    (aset (:array e) i (aget (:array e) (- m 2)))
                    (aset (:array e) (inc i) (aget (:array e) (- m 1)))
                    (aset (:array e) (- m 2) nil)
                    (aset (:array e) (- m 1) nil)
                    e
                )
            )
        )
    )
)

(class-ns NodeIter
    (def- #_"Object" NodeIter'NULL (Object.))

    (defn #_"Iterator" NodeIter'new [#_"Object[]" a, #_"IFn" f]
        (let [#_"int'" vi (volatile! 0) #_"Object'" ve (volatile! NodeIter'NULL) #_"Iterator'" vn (volatile! nil)
              step!
                (fn #_"boolean" []
                    (loop-when [] (< @vi (alength a)) => false
                        (let [#_"Object" key (aget a @vi) #_"Object" nodeOrVal (aget a (inc @vi)) _ (vswap! vi + 2)]
                            (cond
                                (some? key)
                                    (do
                                        (vreset! ve (.invoke f, key, nodeOrVal))
                                        true
                                    )
                                (some? nodeOrVal)
                                    (let-when [#_"Iterator" it (.iterator (cast INode nodeOrVal), f)] (and (some? it) (.hasNext it)) => (recur)
                                        (vreset! vn it)
                                        true
                                    )
                                :else
                                    (recur)
                            )
                        )
                    )
                )]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (or (not (identical? @ve NodeIter'NULL)) (some? @vn) (step!))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" self]
                    (let [#_"Object" e @ve]
                        (cond
                            (not (identical? e NodeIter'NULL))
                                (do
                                    (vreset! ve NodeIter'NULL)
                                    e
                                )
                            (some? @vn)
                                (let [e (.next @vn)]
                                    (when-not (.hasNext @vn)
                                        (vreset! vn nil)
                                    )
                                    e
                                )
                            (step!)
                                (.next self)
                            :else
                                (throw (NoSuchElementException.))
                        )
                    )
                )
            )
        )
    )
)

(class-ns NodeSeq
    (defn- #_"NodeSeq" NodeSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-2 [#_"Object[]" array, #_"int" i]
        (NodeSeq'new-4 nil, array, i, nil)
    )

    (defn #_"ISeq" NodeSeq'create-1 [#_"Object[]" array]
        (NodeSeq'create-3 array, 0, nil)
    )

    (defn #_"Object" NodeSeq'kvreduce [#_"Object[]" array, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (alength array)) => r
            (let [r (if (some? (aget array i))
                        (.invoke f, r, (aget array i), (aget array (inc i)))
                        (let-when [#_"INode" node (cast INode (aget array (inc i)))] (some? node) => r
                            (.kvreduce node, f, r)
                        )
                    )]
                (when-not (RT'isReduced r) => r
                    (recur r (+ i 2))
                )
            )
        )
    )

    (defn- #_"ISeq" NodeSeq'create-3 [#_"Object[]" array, #_"int" i, #_"ISeq" s]
        (when (nil? s) => (NodeSeq'new-4 nil, array, i, s)
            (loop-when i (< i (alength array))
                (when (nil? (aget array i)) => (NodeSeq'new-4 nil, array, i, nil)
                    (or
                        (when-let [#_"INode" node (cast INode (aget array (inc i)))]
                            (when-let [s (.nodeSeq node)]
                                (NodeSeq'new-4 nil, array, (+ i 2), s)
                            )
                        )
                        (recur (+ i 2))
                    )
                )
            )
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-4 [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i, #_"ISeq" s]
        (let [this (merge (ASeq'new-1 meta) (NodeSeq'init))]
            (assoc this :array array :i i :s s)
        )
    )

    #_override
    (defn #_"NodeSeq" IObj'''withMeta--NodeSeq [#_"NodeSeq" this, #_"IPersistentMap" meta]
        (NodeSeq'new-4 meta, (:array this), (:i this), (:s this))
    )

    #_override
    (defn #_"Object" ISeq'''first--NodeSeq [#_"NodeSeq" this]
        (if (some? (:s this))
            (.first (:s this))
            (MapEntry'create (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''next--NodeSeq [#_"NodeSeq" this]
        (if (some? (:s this))
            (NodeSeq'create-3 (:array this), (:i this), (.next (:s this)))
            (NodeSeq'create-3 (:array this), (+ (:i this) 2), nil)
        )
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie.
 ;
 ; Uses path copying for persistence,
 ; hash collision leaves vs. extended hashing,
 ; node polymorphism vs. conditionals,
 ; no sub-tree pools or root-resizing.
 ;
 ; Any errors are my own.
 ;;
(class-ns PersistentHashMap
    (ยง def #_"PersistentHashMap" PersistentHashMap'EMPTY (PersistentHashMap'new-4 0, nil, false, nil))
    (def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (defn #_"IPersistentMap" PersistentHashMap'create-1m [#_"Map" other]
        (let [#_"Iterator" it (.iterator (.entrySet other))]
            (loop-when [#_"ITransientMap" m (.asTransient PersistentHashMap'EMPTY)] (.hasNext it) => (.persistent m)
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))]
                    (recur (.assoc m, (.getKey e), (.getValue e)))
                )
            )
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1a [& #_"Object..." a]
        (loop-when-recur [#_"ITransientMap" m (.asTransient PersistentHashMap'EMPTY) #_"int" i 0]
                         (< i (alength a))
                         [(.assoc m, (aget a i), (aget a (inc i))) (+ i 2)]
                      => (cast PersistentHashMap (.persistent m))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1a [& #_"Object..." a]
        (let [#_"ITransientMap" m (.asTransient PersistentHashMap'EMPTY)
              m (loop-when [m m #_"int" i 0] (< i (alength a)) => m
                    (let [m (.assoc m, (aget a i), (aget a (inc i)))]
                        (when (= (.count m) (inc (/ i 2))) => (throw (IllegalArgumentException. (str "Duplicate key: " (aget a i))))
                            (recur m (+ i 2))
                        )
                    )
                )]
            (cast PersistentHashMap (.persistent m))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1s [#_"ISeq" s]
        (let [#_"ITransientMap" m (.asTransient PersistentHashMap'EMPTY)
              m (loop-when [m m s s] (some? s) => m
                    (when (some? (.next s)) => (throw (IllegalArgumentException. (str "No value supplied for key: " (.first s))))
                        (recur (.assoc m, (.first s), (RT'second s)) (.next (.next s)))
                    )
                )]
            (cast PersistentHashMap (.persistent m))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1s [#_"ISeq" s]
        (let [#_"ITransientMap" m (.asTransient PersistentHashMap'EMPTY)
              m (loop-when [m m s s #_"int" i 0] (some? s) => m
                    (when (some? (.next s)) => (throw (IllegalArgumentException. (str "No value supplied for key: " (.first s))))
                        (let [m (.assoc m, (.first s), (RT'second s))]
                            (when (= (.count m) (inc i)) => (throw (IllegalArgumentException. (str "Duplicate key: " (.first s))))
                                (recur m (.next (.next s)) (inc i))
                            )
                        )
                    )
                )]
            (cast PersistentHashMap (.persistent m))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-2 [#_"IPersistentMap" meta & #_"Object..." init]
        (-> (PersistentHashMap'create-1a init) (.withMeta meta))
    )

    (defn- #_"PersistentHashMap" PersistentHashMap'init []
        (hash-map
            #_"int" :count 0
            #_"INode" :root nil
            #_"boolean" :hasNull false
            #_"Object" :nullValue nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-4 [#_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (assoc this :count count :root root :hasNull hasNull :nullValue nullValue :_meta nil)
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-5 [#_"IPersistentMap" meta, #_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (assoc this :_meta meta :count count :root root :hasNull hasNull :nullValue nullValue)
        )
    )

    (defn #_"int" PersistentHashMap'hash [#_"Object" k]
        (Util'hasheq k)
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (if (nil? key)
            (:hasNull this)
            (and (some? (:root this))
                 (not= (.find (:root this), 0, (PersistentHashMap'hash key), key, PersistentHashMap'NOT_FOUND) PersistentHashMap'NOT_FOUND)
            )
        )
    )

    #_override
    (defn #_"IMapEntry" Associative'''entryAt--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (if (nil? key)
            (when (:hasNull this) (cast IMapEntry (MapEntry'create nil, (:nullValue this))))
            (when (some? (:root this)) (.find (:root this), 0, (PersistentHashMap'hash key), key))
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assoc--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (if (nil? key)
            (when-not (and (:hasNull this) (= val (:nullValue this))) => this
                (PersistentHashMap'new-5 (.meta this), (+ (:count this) (if (:hasNull this) 0 1)), (:root this), true, val)
            )
            (let [#_"Box" addedLeaf (Box'new nil)
                  #_"INode" newroot (.assoc (or (:root this) BitmapIndexedNode'EMPTY), 0, (PersistentHashMap'hash key), key, val, addedLeaf)]
                (when-not (= newroot (:root this)) => this
                    (PersistentHashMap'new-5 (.meta this), (+ (:count this) (if (some? (:val addedLeaf)) 1 0)), newroot, (:hasNull this), (:nullValue this))
                )
            )
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key, #_"Object" notFound]
        (if (nil? key)
            (if (:hasNull this) (:nullValue this) notFound)
            (if (some? (:root this)) (.find (:root this), 0, (PersistentHashMap'hash key), key, notFound) notFound)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assocEx--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (when (.containsKey this, key)
            (throw (RuntimeException. "Key already present"))
        )
        (.assoc this, key, val)
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''without--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (cond
            (nil? key)
                (if (:hasNull this) (PersistentHashMap'new-5 (.meta this), (dec (:count this)), (:root this), false, nil) this)
            (nil? (:root this))
                this
            :else
                (let [#_"INode" newroot (.without (:root this), 0, (PersistentHashMap'hash key), key)]
                    (when-not (= newroot (:root this)) => this
                        (PersistentHashMap'new-5 (.meta this), (dec (:count this)), newroot, (:hasNull this), (:nullValue this))
                    )
                )
        )
    )

    (def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (reify Iterator
            #_foreign
            (#_"boolean" hasNext [#_"Iterator" _self]
                false
            )

            #_foreign
            (#_"Object" next [#_"Iterator" _self]
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (defn- #_"Iterator" PersistentHashMap''iterator [#_"PersistentHashMap" this, #_"IFn" f]
        (let [#_"Iterator" it (if (some? (:root this)) (.iterator (:root this), f) PersistentHashMap'EMPTY_ITER)]
            (when (:hasNull this) => it
                (let [#_"boolean'" seen (volatile! false)]
                    (reify Iterator
                        #_foreign
                        (#_"boolean" hasNext [#_"Iterator" _self]
                            (or (not @seen) (.hasNext it))
                        )

                        #_foreign
                        (#_"Object" next [#_"Iterator" _self]
                            (when (not @seen) => (.next it)
                                (vreset! seen true)
                                (.invoke f, nil, (:nullValue this))
                            )
                        )
                    )
                )
            )
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---PersistentHashMap [#_"PersistentHashMap" this]
        (PersistentHashMap''iterator this, APersistentMap'MAKE_ENTRY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''keyIterator--PersistentHashMap [#_"PersistentHashMap" this]
        (PersistentHashMap''iterator this, APersistentMap'MAKE_KEY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''valIterator--PersistentHashMap [#_"PersistentHashMap" this]
        (PersistentHashMap''iterator this, APersistentMap'MAKE_VAL)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentHashMap [#_"PersistentHashMap" this, #_"IFn" f, #_"Object" r]
        (let [r (if (:hasNull this) (.invoke f, r, nil, (:nullValue this)) r)]
            (when-not (RT'isReduced r) => (.deref (cast IDeref r))
                (when (some? (:root this)) => r
                    (let [r (.kvreduce (:root this), f, r)]
                        (when-not (RT'isReduced r) => (.deref (cast IDeref r))
                            r
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Object" PersistentHashMap''fold [#_"PersistentHashMap" this, #_"long" n, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjinvoke, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        ;; we are ignoring n for now
        (.invoke fjinvoke,
            (reify Callable
                #_foreign
                (#_"Object" call [#_"Callable" _self]
                    (let [#_"Object" ret (.invoke combinef)
                            ret (if (some? (:root this)) (.invoke combinef, ret, (.fold (:root this), combinef, reducef, fjtask, fjfork, fjjoin)) ret)
                            ret (if (:hasNull this) (.invoke combinef, ret, (.invoke reducef, (.invoke combinef), nil, (:nullValue this))) ret)]
                        ret
                    )
                )
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentHashMap [#_"PersistentHashMap" this]
        (:count this)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentHashMap [#_"PersistentHashMap" this]
        (let [#_"ISeq" s (when (some? (:root this)) (.nodeSeq (:root this)))]
            (if (:hasNull this) (Cons'new-2 (MapEntry'create nil, (:nullValue this)), s) s)
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentHashMap [#_"PersistentHashMap" this]
        (.withMeta PersistentHashMap'EMPTY, (.meta this))
    )

    (defn #_"int" PersistentHashMap'mask [#_"int" hash, #_"int" shift]
        (& (>>> hash shift) 0x01f)
    )

    #_override
    (defn #_"PersistentHashMap" IObj'''withMeta--PersistentHashMap [#_"PersistentHashMap" this, #_"IPersistentMap" meta]
        (PersistentHashMap'new-5 meta, (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_override
    (defn #_"TransientHashMap" IEditableCollection'''asTransient--PersistentHashMap [#_"PersistentHashMap" this]
        (TransientHashMap'new-1 this)
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentHashMap [#_"PersistentHashMap" this]
        (:_meta this)
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-3 [#_"Object[]" array, #_"int" i, #_"Object" x]
        (let [#_"Object[]" a (.clone array)]
            (aset a i x)
            a
        )
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-5 [#_"Object[]" array, #_"int" i, #_"Object" x, #_"int" j, #_"Object" y]
        (let [#_"Object[]" a (.clone array)]
            (aset a i x)
            (aset a j y)
            a
        )
    )

    (defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" array, #_"int" i]
        (let [#_"Object[]" a (make-array Object (- (alength array) 2))]
            (System/arraycopy array, 0, a, 0, (* 2 i))
            (System/arraycopy array, (* 2 (inc i)), a, (* 2 i), (- (alength a) (* 2 i)))
            a
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-6 [#_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (PersistentHashMap'hash key1)]
            (when-not (= key1hash key2hash) => (HashCollisionNode'new nil, key1hash, 2, (object-array [ key1, val1, key2, val2 ]))
                (let [#_"Box" addedLeaf (Box'new nil) #_"AtomicReference<Thread>" edit (AtomicReference.)]
                    (-> BitmapIndexedNode'EMPTY
                        (.assoc edit, shift, key1hash, key1, val1, addedLeaf)
                        (.assoc edit, shift, key2hash, key2, val2, addedLeaf)
                    )
                )
            )
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-7 [#_"AtomicReference<Thread>" edit, #_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (PersistentHashMap'hash key1)]
            (when-not (= key1hash key2hash) => (HashCollisionNode'new nil, key1hash, 2, (object-array [ key1, val1, key2, val2 ]))
                (let [#_"Box" addedLeaf (Box'new nil)]
                    (-> BitmapIndexedNode'EMPTY
                        (.assoc edit, shift, key1hash, key1, val1, addedLeaf)
                        (.assoc edit, shift, key2hash, key2, val2, addedLeaf)
                    )
                )
            )
        )
    )

    (defn- #_"int" PersistentHashMap'bitpos [#_"int" hash, #_"int" shift]
        (<< 1 (PersistentHashMap'mask hash, shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(class-ns TransientHashSet
    (defn #_"TransientHashSet" TransientHashSet'new [#_"ITransientMap" impl]
        (ATransientSet'new impl)
    )

    #_override
    (defn #_"IPersistentCollection" ITransientCollection'''persistent--TransientHashSet [#_"TransientHashSet" this]
        (PersistentHashSet'new nil, (.persistent (:impl this)))
    )
)

(class-ns PersistentHashSet
    (ยง def #_"PersistentHashSet" PersistentHashSet'EMPTY (PersistentHashSet'new nil, PersistentHashMap'EMPTY))

    (defn #_"PersistentHashSet" PersistentHashSet'create-1a [& #_"Object..." items]
        (loop-when-recur [#_"ITransientSet" s (cast ITransientSet (.asTransient PersistentHashSet'EMPTY)) #_"int" i 0]
                         (< i (alength items))
                         [(cast ITransientSet (.conj s, (aget items i))) (inc i)]
                      => (cast PersistentHashSet (.persistent s))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1l [#_"List" items]
        (let [#_"Iterator" it (.iterator items)]
            (loop-when-recur [#_"ITransientSet" s (cast ITransientSet (.asTransient PersistentHashSet'EMPTY))]
                             (.hasNext it)
                             [(cast ITransientSet (.conj s, (.next it)))]
                          => (cast PersistentHashSet (.persistent s))
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1s [#_"ISeq" items]
        (loop-when-recur [#_"ITransientSet" s (cast ITransientSet (.asTransient PersistentHashSet'EMPTY)) items items]
                         (some? items)
                         [(cast ITransientSet (.conj s, (.first items))) (.next items)]
                      => (cast PersistentHashSet (.persistent s))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1a [& #_"Object..." items]
        (let [#_"ITransientSet" s (cast ITransientSet (.asTransient PersistentHashSet'EMPTY))
              s (loop-when [s s #_"int" i 0] (< i (alength items)) => s
                    (let [s (cast ITransientSet (.conj s, (aget items i)))]
                        (when (= (.count s) (inc i)) => (throw (IllegalArgumentException. (str "Duplicate key: " (aget items i))))
                            (recur s (inc i))
                        )
                    )
                )]
            (cast PersistentHashSet (.persistent s))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1l [#_"List" items]
        (let [#_"Iterator" it (.iterator items)
              #_"ITransientSet" s (cast ITransientSet (.asTransient PersistentHashSet'EMPTY))
              s (loop-when [s s #_"int" i 0] (.hasNext it) => s
                    (let [#_"Object" key (.next it) s (cast ITransientSet (.conj s, key))]
                        (when (= (.count s) (inc i)) => (throw (IllegalArgumentException. (str "Duplicate key: " key)))
                            (recur s (inc i))
                        )
                    )
                )]
            (cast PersistentHashSet (.persistent s))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1s [#_"ISeq" items]
        (let [#_"ITransientSet" s (cast ITransientSet (.asTransient PersistentHashSet'EMPTY))
              s (loop-when [s s items items #_"int" i 0] (some? items) => s
                    (let [s (cast ITransientSet (.conj s, (.first items)))]
                        (when (= (.count s) (inc i)) => (throw (IllegalArgumentException. (str "Duplicate key: " (.first items))))
                            (recur s (.next items) (inc i))
                        )
                    )
                )]
            (cast PersistentHashSet (.persistent s))
        )
    )

    (defn- #_"PersistentHashSet" PersistentHashSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'new [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (merge (APersistentSet'new impl) (PersistentHashSet'init))]
            (assoc this :_meta meta)
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentSet'''disjoin--PersistentHashSet [#_"PersistentHashSet" this, #_"Object" key]
        (if (.contains this, key)
            (PersistentHashSet'new (.meta this), (.without (:impl this), key))
            this
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentCollection'''cons--PersistentHashSet [#_"PersistentHashSet" this, #_"Object" o]
        (if (.contains this, o)
            this
            (PersistentHashSet'new (.meta this), (.assoc (:impl this), o, o))
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentHashSet [#_"PersistentHashSet" this]
        (.withMeta PersistentHashSet'EMPTY, (.meta this))
    )

    #_override
    (defn #_"PersistentHashSet" IObj'''withMeta--PersistentHashSet [#_"PersistentHashSet" this, #_"IPersistentMap" meta]
        (PersistentHashSet'new meta, (:impl this))
    )

    #_override
    (defn #_"ITransientCollection" IEditableCollection'''asTransient--PersistentHashSet [#_"PersistentHashSet" this]
        (TransientHashSet'new (.asTransient (cast PersistentHashMap (:impl this))))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentHashSet [#_"PersistentHashSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentList

(class-ns Primordial
    (defn #_"Primordial" Primordial'new []
        (RestFn'new)
    )

    #_override
    (defn #_"int" RestFn'''getRequiredArity--Primordial [#_"Primordial" this]
        0
    )

    #_override
    (defn #_"Object" RestFn'''doInvoke-2--Primordial [#_"Primordial" this, #_"Object" args]
        (if (instance? ArraySeq args)
            (let [#_"Object[]" a (:array (cast ArraySeq args))]
                (loop-when-recur [#_"IPersistentList" l PersistentList'EMPTY #_"int" i (dec (alength a))]
                                 (<= (:i (cast ArraySeq args)) i)
                                 [(cast IPersistentList (.cons l, (aget a i))) (dec i)]
                              => l
                )
            )
            (let [#_"List" l (LinkedList.)]
                (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                    (.add l, (.first s))
                )
                (PersistentList'create l)
            )
        )
    )

    (defn #_"Object" Primordial'invokeStatic [#_"ISeq" args]
        (if (instance? ArraySeq args)
            (let [#_"Object[]" a (:array (cast ArraySeq args))]
                (loop-when-recur [#_"IPersistentList" l PersistentList'EMPTY #_"int" i (dec (alength a))]
                                 (<= 0 i)
                                 [(cast IPersistentList (.cons l, (aget a i))) (dec i)]
                              => l
                )
            )
            (let [#_"List" l (LinkedList.)]
                (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                    (.add l, (.first s))
                )
                (PersistentList'create l)
            )
        )
    )

    #_override
    (defn #_"Primordial" IObj'''withMeta--Primordial [#_"Primordial" this, #_"IPersistentMap" meta]
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--Primordial [#_"Primordial" this]
        nil
    )
)

(class-ns EmptyList
    (ยง def #_"int" EmptyList'HASHEQ (Murmur3'hashOrdered Collections/EMPTY_LIST))

    (defn- #_"EmptyList" EmptyList'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"EmptyList" EmptyList'new [#_"IPersistentMap" meta]
        (let [this (EmptyList'init)]
            (assoc this :_meta meta)
        )
    )

    #_foreign
    (defn #_"int" hashCode---EmptyList [#_"EmptyList" this]
        1
    )

    #_method
    (defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'HASHEQ
    )

    #_foreign
    (defn #_"String" toString---EmptyList [#_"EmptyList" this]
        "()"
    )

    #_foreign
    (defn #_"boolean" equals---EmptyList [#_"EmptyList" this, #_"Object" o]
        (and (or (instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--EmptyList [#_"EmptyList" this, #_"Object" o]
        (.equals this, o)
    )

    #_override
    (defn #_"Object" ISeq'''first--EmptyList [#_"EmptyList" this]
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''next--EmptyList [#_"EmptyList" this]
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''more--EmptyList [#_"EmptyList" this]
        this
    )

    #_override
    (defn #_"PersistentList" IPersistentCollection'''cons--EmptyList [#_"EmptyList" this, #_"Object" o]
        (PersistentList'new-4 (.meta this), o, nil, 1)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--EmptyList [#_"EmptyList" this]
        this
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--EmptyList [#_"EmptyList" this]
        (:_meta this)
    )

    #_override
    (defn #_"EmptyList" IObj'''withMeta--EmptyList [#_"EmptyList" this, #_"IPersistentMap" meta]
        (when-not (= meta (.meta this)) => this
            (EmptyList'new meta)
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--EmptyList [#_"EmptyList" this]
        nil
    )

    #_override
    (defn #_"IPersistentList" IPersistentStack'''pop--EmptyList [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_override
    (defn #_"int" Counted'''count--EmptyList [#_"EmptyList" this]
        0
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--EmptyList [#_"EmptyList" this]
        nil
    )

    #_foreign
    (defn #_"int" size---EmptyList [#_"EmptyList" this]
        0
    )

    #_foreign
    (defn #_"boolean" contains---EmptyList [#_"EmptyList" this, #_"Object" o]
        false
    )

    #_foreign
    (defn #_"Iterator" iterator---EmptyList [#_"EmptyList" this]
        (reify Iterator
            #_foreign
            (#_"boolean" hasNext [#_"Iterator" _self]
                false
            )

            #_foreign
            (#_"Object" next [#_"Iterator" _self]
                (throw (NoSuchElementException.))
            )
        )
    )

    #_foreign
    (defn #_"Object[]" toArray---EmptyList [#_"EmptyList" this]
        RT'EMPTY_ARRAY
    )

    #_foreign
    (defn #_"Object[]" toArray---EmptyList [#_"EmptyList" this, #_"Object[]" objects]
        (when (pos? (alength objects))
            (aset objects 0 nil)
        )
        objects
    )

    #_foreign
    (defn #_"Object" get---EmptyList [#_"EmptyList" this, #_"int" index]
        (RT'nth-2 this, index)
    )
)

(class-ns PersistentList
    (ยง def #_"IFn" PersistentList'creator (Primordial'new))

    (ยง def #_"EmptyList" PersistentList'EMPTY (EmptyList'new nil))

    (defn- #_"PersistentList" PersistentList'init []
        (hash-map
            #_"Object" :_first nil
            #_"IPersistentList" :_rest nil
            #_"int" :_count 0
        )
    )

    (defn #_"PersistentList" PersistentList'new-1 [#_"Object" _first]
        (let [this (merge (ASeq'new-0) (PersistentList'init))]
            (assoc this :_first _first :_rest nil :_count 1)
        )
    )

    (defn #_"PersistentList" PersistentList'new-4 [#_"IPersistentMap" meta, #_"Object" _first, #_"IPersistentList" _rest, #_"int" _count]
        (let [this (merge (ASeq'new-1 meta) (PersistentList'init))]
            (assoc this :_first _first :_rest _rest :_count _count)
        )
    )

    (defn #_"IPersistentList" PersistentList'create [#_"List" items]
        (let [#_"ListIterator" it (.listIterator items, (.size items))]
            (loop-when-recur [#_"IPersistentList" ret PersistentList'EMPTY] (.hasPrevious it) [(cast IPersistentList (.cons ret, (.previous it)))] => ret)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--PersistentList [#_"PersistentList" this]
        (:_first this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--PersistentList [#_"PersistentList" this]
        (when-not (= (:_count this) 1)
            (cast ISeq (:_rest this))
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--PersistentList [#_"PersistentList" this]
        (.first this)
    )

    #_override
    (defn #_"IPersistentList" IPersistentStack'''pop--PersistentList [#_"PersistentList" this]
        (or (:_rest this) (.withMeta PersistentList'EMPTY, (:_meta this)))
    )

    #_override
    (defn #_"int" Counted'''count--PersistentList [#_"PersistentList" this]
        (:_count this)
    )

    #_override
    (defn #_"PersistentList" IPersistentCollection'''cons--PersistentList [#_"PersistentList" this, #_"Object" o]
        (PersistentList'new-4 (.meta this), o, this, (inc (:_count this)))
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentList [#_"PersistentList" this]
        (.withMeta PersistentList'EMPTY, (.meta this))
    )

    #_override
    (defn #_"PersistentList" IObj'''withMeta--PersistentList [#_"PersistentList" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (PersistentList'new-4 meta, (:_first this), (:_rest this), (:_count this))
        )
    )

    #_override
    (defn #_"Object" IReduce'''reduce--PersistentList [#_"PersistentList" this, #_"IFn" f]
        (loop-when [#_"Object" r (.first this) #_"ISeq" s (.next this)] (some? s) => r
            (let [r (.invoke f, r, (.first s))]
                (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (.next s)))
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--PersistentList [#_"PersistentList" this, #_"IFn" f, #_"Object" r]
        (loop-when [r (.invoke f, r, (.first this)) #_"ISeq" s (.next this)] (some? s) => (if (RT'isReduced r) (.deref (cast IDeref r)) r)
            (if (RT'isReduced r) (.deref (cast IDeref r)) (recur (.invoke f, r, (.first s)) (.next s)))
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(class-ns QSeq
    (defn- #_"QSeq" QSeq'init []
        (hash-map
            #_"ISeq" :f nil
            #_"ISeq" :rseq nil
        )
    )

    (defn #_"QSeq" QSeq'new-2 [#_"ISeq" f, #_"ISeq" rseq]
        (let [this (merge (ASeq'new-0) (QSeq'init))]
            (assoc this :f f :rseq rseq)
        )
    )

    (defn #_"QSeq" QSeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" f, #_"ISeq" rseq]
        (let [this (merge (ASeq'new-1 meta) (QSeq'init))]
            (assoc this :f f :rseq rseq)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--QSeq [#_"QSeq" this]
        (.first (:f this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--QSeq [#_"QSeq" this]
        (let [#_"ISeq" f (.next (:f this)) #_"ISeq" r (:rseq this)]
            (cond
                (some? f) (QSeq'new-2 f, r)
                (some? r) (QSeq'new-2 r, nil)
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--QSeq [#_"QSeq" this]
        (+ (RT'count (:f this)) (RT'count (:rseq this)))
    )

    #_override
    (defn #_"QSeq" IObj'''withMeta--QSeq [#_"QSeq" this, #_"IPersistentMap" meta]
        (QSeq'new-3 meta, (:f this), (:rseq this))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ;
 ; See Okasaki's Batched Queues.
 ; Differs in that, it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use.
 ;;
(class-ns PersistentQueue
    (ยง def #_"PersistentQueue" PersistentQueue'EMPTY (PersistentQueue'new nil, 0, nil, nil))

    (defn- #_"PersistentQueue" PersistentQueue'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
            #_"int" :cnt 0
            #_"ISeq" :f nil
            #_"PersistentVector" :r nil
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"PersistentQueue" PersistentQueue'new [#_"IPersistentMap" meta, #_"int" cnt, #_"ISeq" f, #_"PersistentVector" r]
        (let [this (PersistentQueue'init)]
            (assoc this :_meta meta :cnt cnt :f f :r r)
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--PersistentQueue [#_"PersistentQueue" this, #_"Object" obj]
        (and (instance? Sequential obj)
            (loop-when [#_"ISeq" s (.seq this) #_"ISeq" ms (RT'seq obj)] (some? s) => (nil? ms)
                (and (some? ms) (Util'equiv-2oo (.first s), (.first ms))
                    (recur (.next s) (.next ms))
                )
            )
        )
    )

    #_foreign
    (defn #_"boolean" equals---PersistentQueue [#_"PersistentQueue" this, #_"Object" obj]
        (and (instance? Sequential obj)
            (loop-when [#_"ISeq" s (.seq this) #_"ISeq" ms (RT'seq obj)] (some? s) => (nil? ms)
                (and (some? ms) (Util'equals (.first s), (.first ms))
                    (recur (.next s) (.next ms))
                )
            )
        )
    )

    #_foreign
    (defn #_"int" hashCode---PersistentQueue [#_"PersistentQueue" this]
        (let-when [#_"int" hash (:_hash this)] (zero? hash) => hash
            (let [hash
                    (loop-when [hash 1 #_"ISeq" s (.seq this)] (some? s) => hash
                        (recur (+ (* 31 hash) (if (some? (.first s)) (.hashCode (.first s)) 0)) (.next s))
                    )]
                (ร ass this (assoc this :_hash hash))
                hash
            )
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--PersistentQueue [#_"PersistentQueue" this]
        (let-when [#_"int" cached (:_hasheq this)] (zero? cached) => cached
            (let [cached (Murmur3'hashOrdered this)]
                (ร ass this (assoc this :_hasheq cached))
                cached
            )
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--PersistentQueue [#_"PersistentQueue" this]
        (RT'first (:f this))
    )

    #_override
    (defn #_"PersistentQueue" IPersistentStack'''pop--PersistentQueue [#_"PersistentQueue" this]
        (when (some? (:f this)) => this ;; hmmm... pop of empty queue -> empty queue?
            (let [#_"ISeq" f (.next (:f this)) #_"PersistentVector" r (:r this)
                  [f r]
                    (when (nil? f) => [f r]
                        [(RT'seq r) nil]
                    )]
                (PersistentQueue'new (.meta this), (dec (:cnt this)), f, r)
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentQueue [#_"PersistentQueue" this]
        (:cnt this)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentQueue [#_"PersistentQueue" this]
        (when (some? (:f this))
            (QSeq'new-2 (:f this), (RT'seq (:r this)))
        )
    )

    #_override
    (defn #_"PersistentQueue" IPersistentCollection'''cons--PersistentQueue [#_"PersistentQueue" this, #_"Object" o]
        (let [[#_"ISeq" f #_"PersistentVector" r]
                (if (nil? (:f this)) ;; empty
                    [(RT'list-1 o) nil]
                    [(:f this) (.cons (or (:r this) PersistentVector'EMPTY), o)]
                )]
            (PersistentQueue'new (.meta this), (inc (:cnt this)), f, r)
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentQueue [#_"PersistentQueue" this]
        (.withMeta PersistentQueue'EMPTY, (.meta this))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentQueue [#_"PersistentQueue" this]
        (:_meta this)
    )

    #_override
    (defn #_"PersistentQueue" IObj'''withMeta--PersistentQueue [#_"PersistentQueue" this, #_"IPersistentMap" meta]
        (PersistentQueue'new meta, (:cnt this), (:f this), (:r this))
    )

    #_foreign
    (defn #_"Object[]" toArray---PersistentQueue [#_"PersistentQueue" this]
        (RT'seqToArray (.seq this))
    )

    #_foreign
    (defn #_"Object[]" toArray---PersistentQueue [#_"PersistentQueue" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_foreign
    (defn #_"int" size---PersistentQueue [#_"PersistentQueue" this]
        (.count this)
    )

    #_foreign
    (defn #_"boolean" contains---PersistentQueue [#_"PersistentQueue" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---PersistentQueue [#_"PersistentQueue" this]
        (let [#_"ISeq'" vs (volatile! (:f this)) #_"Iterator" it (when (some? (:r this)) (.iterator (:r this)))]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (or (and (some? @vs) (some? (.seq @vs))) (and (some? it) (.hasNext it)))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (if (some? @vs)
                        (let [_ (.first @vs)]
                            (vswap! vs #(.next %))
                            _
                        )
                        (when (and (some? it) (.hasNext it)) => (throw (NoSuchElementException.))
                            (.next it)
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(class-ns TNode
    (defn- #_"TNode" TNode'init []
        (hash-map
            #_"Object" :key nil
        )
    )

    (defn #_"TNode" TNode'new [#_"Object" key]
        (let [this (merge (AMapEntry'new) (TNode'init))]
            (assoc this :key key)
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''key--TNode [#_"TNode" this]
        (:key this)
    )

    #_override
    (defn #_"Object" IMapEntry'''val--TNode [#_"TNode" this]
        nil
    )

    #_foreign
    (defn #_"Object" getKey---TNode [#_"TNode" this]
        (.key this)
    )

    #_foreign
    (defn #_"Object" getValue---TNode [#_"TNode" this]
        (.val this)
    )

    #_override
    (defn #_"TNode" TNode'''left--TNode [#_"TNode" this]
        nil
    )

    #_override
    (defn #_"TNode" TNode'''right--TNode [#_"TNode" this]
        nil
    )

    #_override
    (defn #_"TNode" TNode'''balanceLeft--TNode [#_"TNode" this, #_"TNode" parent]
        (PersistentTreeMap'black (:key parent), (.val parent), this, (.right parent))
    )

    #_override
    (defn #_"TNode" TNode'''balanceRight--TNode [#_"TNode" this, #_"TNode" parent]
        (PersistentTreeMap'black (:key parent), (.val parent), (.left parent), this)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--TNode [#_"TNode" this, #_"IFn" f, #_"Object" r]
        (or
            (when (some? (.left this))
                (let [r (.kvreduce (.left this), f, r)]
                    (when (RT'isReduced r)
                        r
                    )
                )
            )
            (let [r (.invoke f, r, (.key this), (.val this))]
                (cond
                    (RT'isReduced r)      r
                    (some? (.right this)) (.kvreduce (.right this), f, r)
                    :else                 r
                )
            )
        )
    )
)

(class-ns Black
    (defn #_"Black" Black'new [#_"Object" key]
        (TNode'new key)
    )

    #_override
    (defn #_"TNode" TNode'''addLeft--Black [#_"Black" this, #_"TNode" ins]
        (.balanceLeft ins, this)
    )

    #_override
    (defn #_"TNode" TNode'''addRight--Black [#_"Black" this, #_"TNode" ins]
        (.balanceRight ins, this)
    )

    #_override
    (defn #_"TNode" TNode'''removeLeft--Black [#_"Black" this, #_"TNode" del]
        (PersistentTreeMap'balanceLeftDel (:key this), (.val this), del, (.right this))
    )

    #_override
    (defn #_"TNode" TNode'''removeRight--Black [#_"Black" this, #_"TNode" del]
        (PersistentTreeMap'balanceRightDel (:key this), (.val this), (.left this), del)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--Black [#_"Black" this]
        this
    )

    #_override
    (defn #_"TNode" TNode'''redden--Black [#_"Black" this]
        (Red'new (:key this))
    )

    #_override
    (defn #_"TNode" TNode'''replace--Black [#_"Black" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (PersistentTreeMap'black key, val, left, right)
    )
)

(class-ns BlackVal
    (defn- #_"BlackVal" BlackVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackVal" BlackVal'new [#_"Object" key, #_"Object" val]
        (let [this (merge (Black'new key) (BlackVal'init))]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--BlackVal [#_"BlackVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''redden--BlackVal [#_"BlackVal" this]
        (RedVal'new (:key this), (:val this))
    )
)

(class-ns BlackBranch
    (defn- #_"BlackBranch" BlackBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"BlackBranch" BlackBranch'new [#_"Object" key, #_"TNode" left, #_"TNode" right]
        (let [this (merge (Black'new key) (BlackBranch'init))]
            (assoc this :left left :right right)
        )
    )

    #_override
    (defn #_"TNode" TNode'''left--BlackBranch [#_"BlackBranch" this]
        (:left this)
    )

    #_override
    (defn #_"TNode" TNode'''right--BlackBranch [#_"BlackBranch" this]
        (:right this)
    )

    #_override
    (defn #_"TNode" TNode'''redden--BlackBranch [#_"BlackBranch" this]
        (RedBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns BlackBranchVal
    (defn- #_"BlackBranchVal" BlackBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackBranchVal" BlackBranchVal'new [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (let [this (merge (BlackBranch'new key, left, right) (BlackBranchVal'init))]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--BlackBranchVal [#_"BlackBranchVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''redden--BlackBranchVal [#_"BlackBranchVal" this]
        (RedBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns Red
    (defn #_"Red" Red'new [#_"Object" key]
        (TNode'new key)
    )

    #_override
    (defn #_"TNode" TNode'''addLeft--Red [#_"Red" this, #_"TNode" ins]
        (PersistentTreeMap'red (:key this), (.val this), ins, (.right this))
    )

    #_override
    (defn #_"TNode" TNode'''addRight--Red [#_"Red" this, #_"TNode" ins]
        (PersistentTreeMap'red (:key this), (.val this), (.left this), ins)
    )

    #_override
    (defn #_"TNode" TNode'''removeLeft--Red [#_"Red" this, #_"TNode" del]
        (PersistentTreeMap'red (:key this), (.val this), del, (.right this))
    )

    #_override
    (defn #_"TNode" TNode'''removeRight--Red [#_"Red" this, #_"TNode" del]
        (PersistentTreeMap'red (:key this), (.val this), (.left this), del)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--Red [#_"Red" this]
        (Black'new (:key this))
    )

    #_override
    (defn #_"TNode" TNode'''redden--Red [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_override
    (defn #_"TNode" TNode'''replace--Red [#_"Red" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (PersistentTreeMap'red key, val, left, right)
    )
)

(class-ns RedVal
    (defn- #_"RedVal" RedVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedVal" RedVal'new [#_"Object" key, #_"Object" val]
        (let [this (merge (Red'new key) (RedVal'init))]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--RedVal [#_"RedVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--RedVal [#_"RedVal" this]
        (BlackVal'new (:key this), (:val this))
    )
)

(class-ns RedBranch
    (defn- #_"RedBranch" RedBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"RedBranch" RedBranch'new [#_"Object" key, #_"TNode" left, #_"TNode" right]
        (let [this (merge (Red'new key) (RedBranch'init))]
            (assoc this :left left :right right)
        )
    )

    #_override
    (defn #_"TNode" TNode'''left--RedBranch [#_"RedBranch" this]
        (:left this)
    )

    #_override
    (defn #_"TNode" TNode'''right--RedBranch [#_"RedBranch" this]
        (:right this)
    )

    #_override
    (defn #_"TNode" TNode'''balanceLeft--RedBranch [#_"RedBranch" this, #_"TNode" parent]
        (cond (instance? Red (:left this))
            (do
                (PersistentTreeMap'red (:key this), (.val this), (.blacken (:left this)), (PersistentTreeMap'black (:key parent), (.val parent), (:right this), (.right parent)))
            )
            (instance? Red (:right this))
            (do
                (PersistentTreeMap'red (:key (:right this)), (.val (:right this)), (PersistentTreeMap'black (:key this), (.val this), (:left this), (.left (:right this))), (PersistentTreeMap'black (:key parent), (.val parent), (.right (:right this)), (.right parent)))
            )
            :else
            (do
                (.balanceLeft (ยง super ), parent)
            )
        )
    )

    #_override
    (defn #_"TNode" TNode'''balanceRight--RedBranch [#_"RedBranch" this, #_"TNode" parent]
        (cond (instance? Red (:right this))
            (do
                (PersistentTreeMap'red (:key this), (.val this), (PersistentTreeMap'black (:key parent), (.val parent), (.left parent), (:left this)), (.blacken (:right this)))
            )
            (instance? Red (:left this))
            (do
                (PersistentTreeMap'red (:key (:left this)), (.val (:left this)), (PersistentTreeMap'black (:key parent), (.val parent), (.left parent), (.left (:left this))), (PersistentTreeMap'black (:key this), (.val this), (.right (:left this)), (:right this)))
            )
            :else
            (do
                (.balanceRight (ยง super ), parent)
            )
        )
    )

    #_override
    (defn #_"TNode" TNode'''blacken--RedBranch [#_"RedBranch" this]
        (BlackBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns RedBranchVal
    (defn- #_"RedBranchVal" RedBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedBranchVal" RedBranchVal'new [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (let [this (merge (RedBranch'new key, left, right) (RedBranchVal'init))]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--RedBranchVal [#_"RedBranchVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--RedBranchVal [#_"RedBranchVal" this]
        (BlackBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns TSeq
    (defn- #_"TSeq" TSeq'init []
        (hash-map
            #_"ISeq" :stack nil
            #_"boolean" :asc false
            #_"int" :cnt 0
        )
    )

    (defn #_"TSeq" TSeq'new-2 [#_"ISeq" stack, #_"boolean" asc]
        (let [this (merge (ASeq'new-0) (TSeq'init))]
            (assoc this :stack stack :asc asc :cnt -1)
        )
    )

    (defn #_"TSeq" TSeq'new-3 [#_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
        (let [this (merge (ASeq'new-0) (TSeq'init))]
            (assoc this :stack stack :asc asc :cnt cnt)
        )
    )

    (defn #_"TSeq" TSeq'new-4 [#_"IPersistentMap" meta, #_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
        (let [this (merge (ASeq'new-1 meta) (TSeq'init))]
            (assoc this :stack stack :asc asc :cnt cnt)
        )
    )

    (defn #_"TSeq" TSeq'create [#_"TNode" t, #_"boolean" asc, #_"int" cnt]
        (TSeq'new-3 (TSeq'push t, nil, asc), asc, cnt)
    )

    (defn #_"ISeq" TSeq'push [#_"TNode" t, #_"ISeq" stack, #_"boolean" asc]
        (loop-when [stack stack t t] (some? t) => stack
            (recur (RT'cons t, stack) (if asc (.left t) (.right t)))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--TSeq [#_"TSeq" this]
        (.first (:stack this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--TSeq [#_"TSeq" this]
        (let [#_"TNode" t (cast TNode (.first (:stack this))) #_"boolean" asc? (:asc this)]
            (when-let [#_"ISeq" stack (TSeq'push (if asc? (.right t) (.left t)), (.next (:stack this)), asc?)]
                (TSeq'new-3 stack, asc?, (dec (:cnt this)))
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--TSeq [#_"TSeq" this]
        (when (neg? (:cnt this)) => (:cnt this)
            (.count (ยง super ))
        )
    )

    #_override
    (defn #_"TSeq" IObj'''withMeta--TSeq [#_"TSeq" this, #_"IPersistentMap" meta]
        (TSeq'new-4 meta, (:stack this), (:asc this), (:cnt this))
    )
)

(class-ns NodeIterator
    (defn #_"Iterator" NodeIterator'new [#_"TNode" t, #_"boolean" asc?]
        (let [#_"Stack" s (Stack.)
              push!
                (fn #_"void" [#_"TNode" t]
                    (loop-when-recur t (some? t) (if asc? (.left t) (.right t)) => nil
                        (.push s, t)
                    )
                )
              _ (push! t)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (not (.isEmpty s))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (try
                        (let [#_"TNode" t (cast TNode (.pop s))]
                            (push! (if asc? (.right t) (.left t)))
                            t
                        )
                        (catch EmptyStackException _
                            (throw (NoSuchElementException.))
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; Persistent Red Black Tree.
 ;
 ; Note that instances of this class are constant values,
 ; i.e. add/remove etc return new values.
 ;
 ; See Okasaki, Kahrs, Larsen, et al.
 ;;
(class-ns PersistentTreeMap
    (ยง def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap'new-0))

    (defn #_"IPersistentMap" PersistentTreeMap'create-1m [#_"Map" other]
        (let [#_"Iterator" it (.iterator (.entrySet other))]
            (loop-when [#_"IPersistentMap" ret PersistentTreeMap'EMPTY] (.hasNext it) => ret
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))]
                    (recur (.assoc ret, (.getKey e), (.getValue e)))
                )
            )
        )
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'init []
        (hash-map
            #_"Comparator" :comp nil
            #_"TNode" :tree nil
            #_"int" :_count 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-0 []
        (PersistentTreeMap'new-1 RT'DEFAULT_COMPARATOR)
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'new-1 [#_"Comparator" comp]
        (PersistentTreeMap'new-2 nil, comp)
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-2 [#_"IPersistentMap" meta, #_"Comparator" comp]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (assoc this :comp comp :_meta meta :tree nil :_count 0)
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4m [#_"IPersistentMap" meta, #_"Comparator" comp, #_"TNode" tree, #_"int" _count]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (assoc this :_meta meta :comp comp :tree tree :_count _count)
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IObj'''withMeta--PersistentTreeMap [#_"PersistentTreeMap" this, #_"IPersistentMap" meta]
        (PersistentTreeMap'new-4m meta, (:comp this), (:tree this), (:_count this))
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-1s [#_"ISeq" s]
        (loop-when [#_"IPersistentMap" m PersistentTreeMap'EMPTY s s] (some? s) => (cast PersistentTreeMap m)
            (when (some? (.next s)) => (throw (IllegalArgumentException. (str "No value supplied for key: " (.first s))))
                (recur (.assoc m, (.first s), (RT'second s)) (.next (.next s)))
            )
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-2 [#_"Comparator" comp, #_"ISeq" s]
        (loop-when [#_"IPersistentMap" m (PersistentTreeMap'new-1 comp) s s] (some? s) => (cast PersistentTreeMap m)
            (when (some? (.next s)) => (throw (IllegalArgumentException. (str "No value supplied for key: " (.first s))))
                (recur (.assoc m, (.first s), (RT'second s)) (.next (.next s)))
            )
        )
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (some? (.entryAt this, key))
    )

    #_foreign
    (defn #_"boolean" equals---PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (.equals (ยง super ), obj)
            (catch ClassCastException e
                false
            )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (.equiv (ยง super ), obj)
            (catch ClassCastException e
                false
            )
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IPersistentMap'''assocEx--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (PersistentTreeMap''add this, (:tree this), key, val, found)]
            (when (nil? t) ;; nil == already contains key
                (throw (RuntimeException. "Key already present"))
            )
            (PersistentTreeMap'new-4c (:comp this), (.blacken t), (inc (:_count this)), (.meta this))
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IPersistentMap'''assoc--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (PersistentTreeMap''add this, (:tree this), key, val, found)]
            (if (nil? t) ;; nil == already contains key
                (if (= (.val (cast TNode (:val found))) val) ;; note only get same collection on identity of val, not equals()
                    this
                    (PersistentTreeMap'new-4c (:comp this), (PersistentTreeMap''replace this, (:tree this), key, val), (:_count this), (.meta this))
                )
                (PersistentTreeMap'new-4c (:comp this), (.blacken t), (inc (:_count this)), (.meta this))
            )
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IPersistentMap'''without--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (PersistentTreeMap''remove this, (:tree this), key, found)]
            (if (nil? t)
                (if (nil? (:val found)) ;; nil == doesn't contain key
                    this
                    (PersistentTreeMap'new-2 (.meta this), (:comp this)) ;; empty
                )
                (PersistentTreeMap'new-4c (:comp this), (.blacken t), (dec (:_count this)), (.meta this))
            )
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentTreeMap [#_"PersistentTreeMap" this]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), true, (:_count this))
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentTreeMap [#_"PersistentTreeMap" this]
        (PersistentTreeMap'new-2 (.meta this), (:comp this))
    )

    #_override
    (defn #_"ISeq" Reversible'''rseq--PersistentTreeMap [#_"PersistentTreeMap" this]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), false, (:_count this))
        )
    )

    #_override
    (defn #_"Comparator" Sorted'''comparator--PersistentTreeMap [#_"PersistentTreeMap" this]
        (:comp this)
    )

    #_override
    (defn #_"Object" Sorted'''entryKey--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" entry]
        (.key (cast IMapEntry entry))
    )

    #_override
    (defn #_"ISeq" Sorted'''seq--PersistentTreeMap [#_"PersistentTreeMap" this, #_"boolean" ascending]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), ascending, (:_count this))
        )
    )

    #_override
    (defn #_"ISeq" Sorted'''seqFrom--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"boolean" ascending]
        (when (pos? (:_count this))
            (loop-when [#_"ISeq" s nil #_"TNode" t (:tree this)] (some? t) => (when (some? s) (TSeq'new-2 s, ascending))
                (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                    (cond
                        (zero? cmp) (TSeq'new-2 (RT'cons t, s), ascending)
                        ascending   (if (neg? cmp) (recur (RT'cons t, s) (.left t)) (recur s (.right t)))
                        :else       (if (pos? cmp) (recur (RT'cons t, s) (.right t)) (recur s (.left t)))
                    )
                )
            )
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---PersistentTreeMap [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), true)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentTreeMap [#_"PersistentTreeMap" this, #_"IFn" f, #_"Object" r]
        (let [r (if (some? (:tree this)) (.kvreduce (:tree this), f, r) r)]
            (if (RT'isReduced r) (.deref (cast IDeref r)) r)
        )
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''reverseIterator [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), false)
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''keys [#_"PersistentTreeMap" this]
        (let [#_"Iterator" it (.iterator this)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (.hasNext it)
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (:key (cast TNode (.next it)))
                )
            )
        )
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''vals [#_"PersistentTreeMap" this]
        (let [#_"Iterator" it (.iterator this)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (.hasNext it)
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (.val (cast TNode (.next it)))
                )
            )
        )
    )

    #_method
    (defn #_"Object" PersistentTreeMap''minKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (PersistentTreeMap''min this)]
            (when (some? t) (:key t))
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''min [#_"PersistentTreeMap" this]
        (when-let [#_"TNode" t (:tree this)]
            (loop-when-recur t (some? (.left t)) (.left t) => t)
        )
    )

    #_method
    (defn #_"Object" PersistentTreeMap''maxKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (PersistentTreeMap''max this)]
            (when (some? t) (:key t))
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''max [#_"PersistentTreeMap" this]
        (when-let [#_"TNode" t (:tree this)]
            (loop-when-recur t (some? (.right t)) (.right t) => t)
        )
    )

    #_method
    (defn #_"int" PersistentTreeMap''depth-1 [#_"PersistentTreeMap" this]
        (PersistentTreeMap''depth-2 this, (:tree this))
    )

    #_method
    (defn #_"int" PersistentTreeMap''depth-2 [#_"PersistentTreeMap" this, #_"TNode" t]
        (when (some? t) => 0
            (inc (Math/max (PersistentTreeMap''depth-2 this, (.left t)), (PersistentTreeMap''depth-2 this, (.right t))))
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"TNode" n (.entryAt this, key)]
            (if (some? n) (.val n) notFound)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (defn #_"int" PersistentTreeMap''capacity [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_override
    (defn #_"int" Counted'''count--PersistentTreeMap [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_override
    (defn #_"TNode" Associative'''entryAt--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (loop-when [#_"TNode" t (:tree this)] (some? t) => t
            (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                (cond
                    (neg? cmp) (recur (.left t))
                    (pos? cmp) (recur (.right t))
                    :else      t
                )
            )
        )
    )

    #_method
    (defn #_"int" PersistentTreeMap''doCompare [#_"PersistentTreeMap" this, #_"Object" k1, #_"Object" k2]
        (.compare (:comp this), k1, k2)
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''add [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Object" val, #_"Box" found]
        (if (nil? t)
            (if (nil? val)
                (Red'new key)
                (RedVal'new key, val)
            )
            (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                (if (zero? cmp)
                    (do
                        (ร ass (:val found) t)
                        nil
                    )
                    (let [#_"TNode" ins (if (neg? cmp) (PersistentTreeMap''add this, (.left t), key, val, found) (PersistentTreeMap''add this, (.right t), key, val, found))]
                        (cond
                            (nil? ins) nil ;; found below
                            (neg? cmp) (.addLeft t, ins)
                            :else      (.addRight t, ins)
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''remove [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Box" found]
        (when (some? t) => nil ;; not found indicator
            (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                (if (zero? cmp)
                    (do
                        (ร ass (:val found) t)
                        (PersistentTreeMap'append (.left t), (.right t))
                    )
                    (let [#_"TNode" del (if (neg? cmp) (PersistentTreeMap''remove this, (.left t), key, found) (PersistentTreeMap''remove this, (.right t), key, found))]
                        (when (or (some? del) (some? (:val found))) => nil ;; not found below
                            (if (neg? cmp)
                                (if (instance? Black (.left t))
                                    (PersistentTreeMap'balanceLeftDel (:key t), (.val t), del, (.right t))
                                    (PersistentTreeMap'red (:key t), (.val t), del, (.right t))
                                )
                                (if (instance? Black (.right t))
                                    (PersistentTreeMap'balanceRightDel (:key t), (.val t), (.left t), del)
                                    (PersistentTreeMap'red (:key t), (.val t), (.left t), del)
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'append [#_"TNode" left, #_"TNode" right]
        (cond
            (nil? left)
                right
            (nil? right)
                left
            (instance? Red left)
                (if (instance? Red right)
                    (let [#_"TNode" app (PersistentTreeMap'append (.right left), (.left right))]
                        (if (instance? Red app)
                            (PersistentTreeMap'red (:key app), (.val app), (PersistentTreeMap'red (:key left), (.val left), (.left left), (.left app)), (PersistentTreeMap'red (:key right), (.val right), (.right app), (.right right)))
                            (PersistentTreeMap'red (:key left), (.val left), (.left left), (PersistentTreeMap'red (:key right), (.val right), app, (.right right)))
                        )
                    )
                    (PersistentTreeMap'red (:key left), (.val left), (.left left), (PersistentTreeMap'append (.right left), right))
                )
            (instance? Red right)
                (PersistentTreeMap'red (:key right), (.val right), (PersistentTreeMap'append left, (.left right)), (.right right))
            :else ;; black/black
                (let [#_"TNode" app (PersistentTreeMap'append (.right left), (.left right))]
                    (if (instance? Red app)
                        (PersistentTreeMap'red (:key app), (.val app), (PersistentTreeMap'black (:key left), (.val left), (.left left), (.left app)), (PersistentTreeMap'black (:key right), (.val right), (.right app), (.right right)))
                        (PersistentTreeMap'balanceLeftDel (:key left), (.val left), (.left left), (PersistentTreeMap'black (:key right), (.val right), app, (.right right)))
                    )
                )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" key, #_"Object" val, #_"TNode" del, #_"TNode" right]
        (cond
            (instance? Red del)
                (PersistentTreeMap'red key, val, (.blacken del), right)
            (instance? Black right)
                (PersistentTreeMap'rightBalance key, val, del, (.redden right))
            (and (instance? Red right) (instance? Black (.left right)))
                (PersistentTreeMap'red (:key (.left right)), (.val (.left right)), (PersistentTreeMap'black key, val, del, (.left (.left right))), (PersistentTreeMap'rightBalance (:key right), (.val right), (.right (.left right)), (.redden (.right right))))
            :else
                (throw (UnsupportedOperationException. "Invariant violation"))
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" del]
        (cond
            (instance? Red del)
                (PersistentTreeMap'red key, val, left, (.blacken del))
            (instance? Black left)
                (PersistentTreeMap'leftBalance key, val, (.redden left), del)
            (and (instance? Red left) (instance? Black (.right left)))
                (PersistentTreeMap'red (:key (.right left)), (.val (.right left)), (PersistentTreeMap'leftBalance (:key left), (.val left), (.redden (.left left)), (.left (.right left))), (PersistentTreeMap'black key, val, (.right (.right left)), del))
            :else
                (throw (UnsupportedOperationException. "Invariant violation"))
        )
    )

    (defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" key, #_"Object" val, #_"TNode" ins, #_"TNode" right]
        (cond
            (and (instance? Red ins) (instance? Red (.left ins)))
                (PersistentTreeMap'red (:key ins), (.val ins), (.blacken (.left ins)), (PersistentTreeMap'black key, val, (.right ins), right))
            (and (instance? Red ins) (instance? Red (.right ins)))
                (PersistentTreeMap'red (:key (.right ins)), (.val (.right ins)), (PersistentTreeMap'black (:key ins), (.val ins), (.left ins), (.left (.right ins))), (PersistentTreeMap'black key, val, (.right (.right ins)), right))
            :else
                (PersistentTreeMap'black key, val, ins, right)
        )
    )

    (defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" ins]
        (cond
            (and (instance? Red ins) (instance? Red (.right ins)))
                (PersistentTreeMap'red (:key ins), (.val ins), (PersistentTreeMap'black key, val, left, (.left ins)), (.blacken (.right ins)))
            (and (instance? Red ins) (instance? Red (.left ins)))
                (PersistentTreeMap'red (:key (.left ins)), (.val (.left ins)), (PersistentTreeMap'black key, val, left, (.left (.left ins))), (PersistentTreeMap'black (:key ins), (.val ins), (.right (.left ins)), (.right ins)))
            :else
                (PersistentTreeMap'black key, val, left, ins)
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''replace [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Object" val]
        (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
            (.replace t, (:key t), (if (zero? cmp) val (.val t)), (if (neg? cmp) (PersistentTreeMap''replace this, (.left t), key, val) (.left t)), (if (pos? cmp) (PersistentTreeMap''replace this, (.right t), key, val) (.right t)))
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4c [#_"Comparator" comp, #_"TNode" tree, #_"int" count, #_"IPersistentMap" meta]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (assoc this :_meta meta :comp comp :tree tree :_count count)
        )
    )

    (defn #_"Red" PersistentTreeMap'red [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (if (and (nil? left) (nil? right))
            (if (nil? val)
                (Red'new key)
                (RedVal'new key, val)
            )
            (if (nil? val)
                (RedBranch'new key, left, right)
                (RedBranchVal'new key, val, left, right)
            )
        )
    )

    (defn #_"Black" PersistentTreeMap'black [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (if (and (nil? left) (nil? right))
            (if (nil? val)
                (Black'new key)
                (BlackVal'new key, val)
            )
            (if (nil? val)
                (BlackBranch'new key, left, right)
                (BlackBranchVal'new key, val, left, right)
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentTreeMap [#_"PersistentTreeMap" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(class-ns PersistentTreeSet
    (ยง def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (PersistentTreeSet'new nil, PersistentTreeMap'EMPTY))

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-1 [#_"ISeq" s]
        (loop-when-recur [#_"PersistentTreeSet" t PersistentTreeSet'EMPTY s s]
                         (some? s)
                         [(cast PersistentTreeSet (.cons t, (.first s))) (.next s)]
                      => t
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-2 [#_"Comparator" comp, #_"ISeq" s]
        (loop-when-recur [#_"PersistentTreeSet" t (PersistentTreeSet'new nil, (PersistentTreeMap'new-2 nil, comp)) s s]
                         (some? s)
                         [(cast PersistentTreeSet (.cons t, (.first s))) (.next s)]
                      => t
        )
    )

    (defn- #_"PersistentTreeSet" PersistentTreeSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'new [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (merge (APersistentSet'new impl) (PersistentTreeSet'init))]
            (assoc this :_meta meta)
        )
    )

    #_foreign
    (defn #_"boolean" equals---PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (.equals (ยง super ), obj)
            (catch ClassCastException _
                false
            )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (.equiv (ยง super ), obj)
            (catch ClassCastException _
                false
            )
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentSet'''disjoin--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" key]
        (if (.contains this, key)
            (PersistentTreeSet'new (.meta this), (.without (:impl this), key))
            this
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentCollection'''cons--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" o]
        (if (.contains this, o)
            this
            (PersistentTreeSet'new (.meta this), (.assoc (:impl this), o, o))
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentTreeSet [#_"PersistentTreeSet" this]
        (PersistentTreeSet'new (.meta this), (cast PersistentTreeMap (.empty (:impl this))))
    )

    #_override
    (defn #_"ISeq" Reversible'''rseq--PersistentTreeSet [#_"PersistentTreeSet" this]
        (KeySeq'create (.rseq (cast Reversible (:impl this))))
    )

    #_override
    (defn #_"PersistentTreeSet" IObj'''withMeta--PersistentTreeSet [#_"PersistentTreeSet" this, #_"IPersistentMap" meta]
        (PersistentTreeSet'new meta, (:impl this))
    )

    #_override
    (defn #_"Comparator" Sorted'''comparator--PersistentTreeSet [#_"PersistentTreeSet" this]
        (.comparator (cast Sorted (:impl this)))
    )

    #_override
    (defn #_"Object" Sorted'''entryKey--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" entry]
        entry
    )

    #_override
    (defn #_"ISeq" Sorted'''seq--PersistentTreeSet [#_"PersistentTreeSet" this, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (cast PersistentTreeMap (:impl this))]
            (RT'keys (.seq m, ascending))
        )
    )

    #_override
    (defn #_"ISeq" Sorted'''seqFrom--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" key, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (cast PersistentTreeMap (:impl this))]
            (RT'keys (.seqFrom m, key, ascending))
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentTreeSet [#_"PersistentTreeSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(class-ns VNode
    (defn- #_"VNode" VNode'init []
        (hash-map
            #_transient
            #_"AtomicReference<Thread>" :edit nil
            #_"Object[]" :array nil
        )
    )

    (defn #_"VNode" VNode'new-2 [#_"AtomicReference<Thread>" edit, #_"Object[]" array]
        (let [this (VNode'init)]
            (assoc this :edit edit :array array)
        )
    )

    (defn #_"VNode" VNode'new-1 [#_"AtomicReference<Thread>" edit]
        (let [this (VNode'init)]
            (assoc this :edit edit :array (make-array Object 32))
        )
    )
)

(class-ns ChunkedSeq
    (defn- #_"ChunkedSeq" ChunkedSeq'init []
        (hash-map
            #_"PersistentVector" :vec nil
            #_"Object[]" :node nil
            #_"int" :i 0
            #_"int" :offset 0
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-3 [#_"PersistentVector" vec, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new-0) (ChunkedSeq'init))]
            (assoc this :vec vec :i i :offset offset :node (PersistentVector''arrayFor vec, i))
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-5 [#_"IPersistentMap" meta, #_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new-1 meta) (ChunkedSeq'init))]
            (assoc this :vec vec :node node :i i :offset offset)
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-4 [#_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new-0) (ChunkedSeq'init))]
            (assoc this :vec vec :node node :i i :offset offset)
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--ChunkedSeq [#_"ChunkedSeq" this]
        (ArrayChunk'new-2 (:node this), (:offset this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--ChunkedSeq [#_"ChunkedSeq" this]
        (when (< (+ (:i this) (alength (:node this))) (:cnt (:vec this)))
            (ChunkedSeq'new-3 (:vec this), (+ (:i this) (alength (:node this))), 0)
        )
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--ChunkedSeq [#_"ChunkedSeq" this]
        (or (.chunkedNext this) PersistentList'EMPTY)
    )

    #_override
    (defn #_"ChunkedSeq" IObj'''withMeta--ChunkedSeq [#_"ChunkedSeq" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (ChunkedSeq'new-5 meta, (:vec this), (:node this), (:i this), (:offset this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ChunkedSeq [#_"ChunkedSeq" this]
        (aget (:node this) (:offset this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ChunkedSeq [#_"ChunkedSeq" this]
        (if (< (inc (:offset this)) (alength (:node this)))
            (ChunkedSeq'new-4 (:vec this), (:node this), (:i this), (inc (:offset this)))
            (.chunkedNext this)
        )
    )

    #_override
    (defn #_"int" Counted'''count--ChunkedSeq [#_"ChunkedSeq" this]
        (- (:cnt (:vec this)) (+ (:i this) (:offset this)))
    )
)

(class-ns TransientVector
    (defn- #_"TransientVector" TransientVector'init []
        (hash-map
            #_volatile
            #_"int" :cnt 0
            #_volatile
            #_"int" :shift 0
            #_volatile
            #_"VNode" :root nil
            #_volatile
            #_"Object[]" :tail nil
        )
    )

    (defn #_"TransientVector" TransientVector'new-4 [#_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (AFn'new) (TransientVector'init))]
            (assoc this :cnt cnt :shift shift :root root :tail tail)
        )
    )

    (defn #_"TransientVector" TransientVector'new-1 [#_"PersistentVector" v]
        (TransientVector'new-4 (:cnt v), (:shift v), (.editableRoot (:root v)), (.editableTail (:tail v)))
    )

    #_override
    (defn #_"int" Counted'''count--TransientVector [#_"TransientVector" this]
        (TransientVector''ensureEditable-1 this)
        (:cnt this)
    )

    #_method
    (defn #_"VNode" TransientVector''ensureEditable-2 [#_"TransientVector" this, #_"VNode" node]
        (if (= (:edit node) (:edit (:root this)))
            node
            (VNode'new-2 (:edit (:root this)), (.clone (:array node)))
        )
    )

    #_method
    (defn #_"void" TransientVector''ensureEditable-1 [#_"TransientVector" this]
        (when (nil? (.get (:edit (:root this))))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (defn #_"VNode" TransientVector'editableRoot [#_"VNode" node]
        (VNode'new-2 (AtomicReference. (Thread/currentThread)), (.clone (:array node)))
    )

    #_override
    (defn #_"PersistentVector" ITransientCollection'''persistent--TransientVector [#_"TransientVector" this]
        (TransientVector''ensureEditable-1 this)
        (.set (:edit (:root this)), nil)
        (let [#_"Object[]" trimmedTail (make-array Object (- (:cnt this) (TransientVector''tailoff this)))]
            (System/arraycopy (:tail this), 0, trimmedTail, 0, (alength trimmedTail))
            (PersistentVector'new-4 (:cnt this), (:shift this), (:root this), trimmedTail)
        )
    )

    (defn #_"Object[]" TransientVector'editableTail [#_"Object[]" tail]
        (let [#_"Object[]" a (make-array Object 32)]
            (System/arraycopy tail, 0, a, 0, (alength tail))
            a
        )
    )

    #_override
    (defn #_"TransientVector" ITransientCollection'''conj--TransientVector [#_"TransientVector" this, #_"Object" val]
        (TransientVector''ensureEditable-1 this)
        (let [#_"int" n (:cnt this)]
            (if (< (- n (TransientVector''tailoff this)) 32) ;; room in tail?
                (do
                    (aset (:tail this) (& n 0x01f) val)
                    (update this :cnt inc)
                )
                ;; full tail, push into tree
                (let [#_"VNode" tailnode (VNode'new-2 (:edit (:root this)), (:tail this))
                      this (assoc this :tail (make-array Object 32))
                      _ (aset (:tail this) 0 val)
                      #_"int" shift (:shift this)
                      [#_"VNode" root shift]
                        (if (< (<< 1 shift) (>>> n 5)) ;; overflow root?
                            (let [root (VNode'new-1 (:edit (:root this)))]
                                (aset (:array root) 0 (:root this))
                                (aset (:array root) 1 (PersistentVector'newPath (:edit (:root this)), shift, tailnode))
                                [root (+ shift 5)]
                            )
                            [(TransientVector''pushTail this, shift, (:root this), tailnode) shift]
                        )]
                    (-> this (assoc :root root :shift shift) (update :cnt inc))
                )
            )
        )
    )

    #_method
    (defn- #_"VNode" TransientVector''pushTail [#_"TransientVector" this, #_"int" level, #_"VNode" parent, #_"VNode" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (let [parent (TransientVector''ensureEditable-2 this, parent)
              #_"int" i (& (>>> (dec (:cnt this)) level) 0x01f)
              #_"VNode" nodeToInsert
                (when-not (= level 5) => tailnode
                    (let [#_"VNode" child (cast VNode (aget (:array parent) i))]
                        (if (some? child)
                            (TransientVector''pushTail this, (- level 5), child, tailnode)
                            (PersistentVector'newPath (:edit (:root this)), (- level 5), tailnode)
                        )
                    )
                )]
            (aset (:array parent) i nodeToInsert)
            parent
        )
    )

    #_method
    (defn- #_"int" TransientVector''tailoff [#_"TransientVector" this]
        (if (< (:cnt this) 32) 0 (<< (>>> (dec (:cnt this)) 5) 5))
    )

    #_method
    (defn- #_"Object[]" TransientVector''arrayFor [#_"TransientVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (TransientVector''tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(cast VNode (aget (:array node) (& (>>> i level) 0x01f))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_method
    (defn- #_"Object[]" TransientVector''editableArrayFor [#_"TransientVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (TransientVector''tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(TransientVector''ensureEditable-2 this, (cast VNode (aget (:array node) (& (>>> i level) 0x01f)))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--TransientVector [#_"TransientVector" this, #_"Object" key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (.valAt this, key, nil)
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--TransientVector [#_"TransientVector" this, #_"Object" key, #_"Object" notFound]
        (TransientVector''ensureEditable-1 this)
        (when (Util'isInteger key) => notFound
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (:cnt this)) => notFound
                (.nth this, i)
            )
        )
    )

    (def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_override
    (defn #_"boolean" ITransientAssociative2'''containsKey--TransientVector [#_"TransientVector" this, #_"Object" key]
        (not= (.valAt this, key, TransientVector'NOT_FOUND) TransientVector'NOT_FOUND)
    )

    #_override
    (defn #_"IMapEntry" ITransientAssociative2'''entryAt--TransientVector [#_"TransientVector" this, #_"Object" key]
        (let [#_"Object" v (.valAt this, key, TransientVector'NOT_FOUND)]
            (when-not (= v TransientVector'NOT_FOUND)
                (MapEntry'create key, v)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--TransientVector [#_"TransientVector" this, #_"Object" arg1]
        ;; note - relies on ensureEditable in nth
        (when (Util'isInteger arg1) => (throw (IllegalArgumentException. "Key must be integer"))
            (.nth this, (.intValue (cast Number arg1)))
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--TransientVector [#_"TransientVector" this, #_"int" i]
        (TransientVector''ensureEditable-1 this)
        (let [#_"Object[]" node (TransientVector''arrayFor this, i)]
            (aget node (& i 0x01f))
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--TransientVector [#_"TransientVector" this, #_"int" i, #_"Object" notFound]
        (when (< -1 i (.count this)) => notFound
            (.nth this, i)
        )
    )

    #_override
    (defn #_"TransientVector" ITransientVector'''assocN--TransientVector [#_"TransientVector" this, #_"int" i, #_"Object" val]
        (TransientVector''ensureEditable-1 this)
        (if (< -1 i (:cnt this))
            (if (<= (TransientVector''tailoff this) i)
                (do
                    (aset (:tail this) (& i 0x01f) val)
                    this
                )
                (do
                    (assoc this :root (TransientVector''doAssoc this, (:shift this), (:root this), i, val))
                )
            )
            (when (= i (:cnt this)) => (throw (IndexOutOfBoundsException.))
                (.conj this, val)
            )
        )
    )

    #_override
    (defn #_"TransientVector" ITransientAssociative'''assoc--TransientVector [#_"TransientVector" this, #_"Object" key, #_"Object" val]
        ;; note - relies on ensureEditable in assocN
        (when (Util'isInteger key) => (throw (IllegalArgumentException. "Key must be integer"))
            (.assocN this, (.intValue (cast Number key)), val)
        )
    )

    #_method
    (defn- #_"VNode" TransientVector''doAssoc [#_"TransientVector" this, #_"int" level, #_"VNode" node, #_"int" i, #_"Object" val]
        (let [node (TransientVector''ensureEditable-2 this, node)]
            (if (zero? level)
                (aset (:array node) (& i 0x01f) val)
                (let [#_"int" si (& (>>> i level) 0x01f)]
                    (aset (:array node) si (TransientVector''doAssoc this, (- level 5), (cast VNode (aget (:array node) si)), i, val))
                )
            )
            node
        )
    )

    #_override
    (defn #_"TransientVector" ITransientVector'''pop--TransientVector [#_"TransientVector" this]
        (TransientVector''ensureEditable-1 this)
        (let [#_"int" n (:cnt this)]
            (when-not (zero? n) => (throw (IllegalStateException. "Can't pop empty vector"))
                (when (and (not= n 1) (zero? (& (dec n) 0x01f))) => (assoc this :cnt (dec n))
                    (let [#_"Object[]" tail (TransientVector''editableArrayFor this, (- n 2))
                          #_"int" shift (:shift this) #_"VNode" root (:root this)
                          root (or (TransientVector''popTail this, shift, root) (VNode'new-1 (:edit root)))
                          [shift root]
                            (when (and (< 5 shift) (nil? (aget (:array root) 1))) => [shift root]
                                [(- shift 5) (TransientVector''ensureEditable-2 this, (cast VNode (aget (:array root) 0)))]
                            )]
                        (assoc this :cnt (dec n) :shift shift :root root :tail tail)
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"VNode" TransientVector''popTail [#_"TransientVector" this, #_"int" level, #_"VNode" node]
        (let [node (TransientVector''ensureEditable-2 this, node)
              #_"int" i (& (>>> (- (:cnt this) 2) level) 0x01f)]
            (cond
                (< 5 level)
                    (let [#_"VNode" child (TransientVector''popTail this, (- level 5), (cast VNode (aget (:array node) i)))]
                        (when-not (and (nil? child) (zero? i))
                            (aset (:array node) i child)
                            node
                        )
                    )
                (pos? i)
                    (do
                        (aset (:array node) i nil)
                        node
                    )
            )
        )
    )
)

(class-ns PersistentVector
    (def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (AtomicReference. nil))
    (def #_"VNode" PersistentVector'EMPTY_NODE (VNode'new-2 PersistentVector'NOEDIT, (object-array 32)))

    (ยง def #_"PersistentVector" PersistentVector'EMPTY (PersistentVector'new-4 0, 5, PersistentVector'EMPTY_NODE, (object-array 0)))

    (defn- #_"Object" PersistentVector'TRANSIENT_VECTOR_CONJ
        ([#_"Object" coll] coll)
        ([#_"Object" coll, #_"Object" val] (.conj (cast ITransientVector coll), val))
    )

    (defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" items]
        (PersistentVector'new-4 (alength items), 5, PersistentVector'EMPTY_NODE, items)
    )

    (defn #_"PersistentVector" PersistentVector'create-1r [#_"IReduceInit" items]
        (let [#_"TransientVector" ret (.asTransient PersistentVector'EMPTY)]
            (.reduce items, PersistentVector'TRANSIENT_VECTOR_CONJ, ret)
            (.persistent ret)
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1s [#_"ISeq" items]
        (let [#_"Object[]" a (make-array Object 32)
              #_"int" i
                (loop-when-recur [items items i 0] (and (some? items) (< i 32)) [(.next items) (inc i)] => i
                    (aset a i (.first items))
                )]
            (cond
                (some? items) ;; >32, construct with array directly
                    (let [#_"PersistentVector" v0 (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, a)]
                        (loop-when-recur [#_"TransientVector" v (.asTransient v0) items items]
                                         (some? items)
                                         [(.conj v, (.first items)) (.next items)]
                                      => (.persistent v)
                        )
                    )
                (= i 32) ;; exactly 32, skip copy
                    (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, a)
                :else ;; <32, copy to minimum array and construct
                    (let [#_"Object[]" b (make-array Object i)]
                        (System/arraycopy a, 0, b, 0, i)
                        (PersistentVector'new-4 i, 5, PersistentVector'EMPTY_NODE, b)
                    )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1l [#_"List" items]
        (let-when [#_"int" n (.size items)] (< 32 n) => (PersistentVector'new-4 n, 5, PersistentVector'EMPTY_NODE, (.toArray items))
            (loop-when-recur [#_"TransientVector" v (.asTransient PersistentVector'EMPTY) #_"int" i 0]
                             (< i n)
                             [(.conj v, (.get items, i)) (inc i)]
                          => (.persistent v)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1i [#_"Iterable" items]
        (when-not (instance? ArrayList items) => (PersistentVector'create-1l (cast ArrayList items)) ;; optimize common case
            (let [#_"Iterator" it (.iterator items)]
                (loop-when-recur [#_"TransientVector" v (.asTransient PersistentVector'EMPTY)]
                                 (.hasNext it)
                                 [(.conj v, (.next it))]
                              => (.persistent v)
                )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1a [& #_"Object..." items]
        (loop-when-recur [#_"TransientVector" v (.asTransient PersistentVector'EMPTY) #_"int" i 0]
                         (< i (alength items))
                         [(.conj v, (aget items i)) (inc i)]
                      => (.persistent v)
        )
    )

    (defn- #_"PersistentVector" PersistentVector'init []
        (hash-map
            #_"int" :cnt 0
            #_"int" :shift 0
            #_"VNode" :root nil
            #_"Object[]" :tail nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-4 [#_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (assoc this :_meta nil :cnt cnt :shift shift :root root :tail tail)
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-5 [#_"IPersistentMap" meta, #_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (assoc this :_meta meta :cnt cnt :shift shift :root root :tail tail)
        )
    )

    #_override
    (defn #_"TransientVector" IEditableCollection'''asTransient--PersistentVector [#_"PersistentVector" this]
        (TransientVector'new-1 this)
    )

    #_method
    (defn #_"int" PersistentVector''tailoff [#_"PersistentVector" this]
        (if (< (:cnt this) 32) 0 (<< (>>> (dec (:cnt this)) 5) 5))
    )

    #_method
    (defn #_"Object[]" PersistentVector''arrayFor [#_"PersistentVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (PersistentVector''tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(cast VNode (aget (:array node) (& (>>> i level) 0x01f))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--PersistentVector [#_"PersistentVector" this, #_"int" i]
        (aget (PersistentVector''arrayFor this, i) (& i 0x01f))
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--PersistentVector [#_"PersistentVector" this, #_"int" i, #_"Object" notFound]
        (when (< -1 i (:cnt this)) => notFound
            (.nth this, i)
        )
    )

    #_override
    (defn #_"PersistentVector" IPersistentVector'''assocN--PersistentVector [#_"PersistentVector" this, #_"int" i, #_"Object" val]
        (if (< -1 i (:cnt this))
            (if (<= (PersistentVector''tailoff this) i)
                (let [#_"Object[]" tail (make-array Object (alength (:tail this)))]
                    (System/arraycopy (:tail this), 0, tail, 0, (alength (:tail this)))
                    (aset tail (& i 0x01f) val)
                    (PersistentVector'new-5 (.meta this), (:cnt this), (:shift this), (:root this), tail)
                )
                (PersistentVector'new-5 (.meta this), (:cnt this), (:shift this), (PersistentVector'doAssoc (:shift this), (:root this), i, val), (:tail this))
            )
            (when (= i (:cnt this)) => (throw (IndexOutOfBoundsException.))
                (.cons this, val)
            )
        )
    )

    (defn- #_"VNode" PersistentVector'doAssoc [#_"int" level, #_"VNode" node, #_"int" i, #_"Object" val]
        (let [#_"VNode" ret (VNode'new-2 (:edit node), (.clone (:array node)))]
            (if (zero? level)
                (aset (:array ret) (& i 0x01f) val)
                (let [#_"int" si (& (>>> i level) 0x01f)]
                    (aset (:array ret) si (PersistentVector'doAssoc (- level 5), (cast VNode (aget (:array node) si)), i, val))
                )
            )
            ret
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentVector [#_"PersistentVector" this]
        (:cnt this)
    )

    #_override
    (defn #_"PersistentVector" IObj'''withMeta--PersistentVector [#_"PersistentVector" this, #_"IPersistentMap" meta]
        (PersistentVector'new-5 meta, (:cnt this), (:shift this), (:root this), (:tail this))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentVector [#_"PersistentVector" this]
        (:_meta this)
    )

    #_override
    (defn #_"PersistentVector" IPersistentVector'''cons--PersistentVector [#_"PersistentVector" this, #_"Object" val]
        (let [#_"int" n (:cnt this)]
            (if (< (- n (PersistentVector''tailoff this)) 32) ;; room in tail?
                (let [#_"int" e (alength (:tail this)) #_"Object[]" tail (make-array Object (inc e))]
                    (System/arraycopy (:tail this), 0, tail, 0, e)
                    (aset tail e val)
                    (PersistentVector'new-5 (.meta this), (inc n), (:shift this), (:root this), tail)
                )
                ;; full tail, push into tree
                (let [#_"VNode" tailnode (VNode'new-2 (:edit (:root this)), (:tail this))
                      #_"int" shift (:shift this)
                      [#_"VNode" root shift]
                        (if (< (<< 1 shift) (>>> n 5)) ;; overflow root?
                            (let [root (VNode'new-1 (:edit (:root this)))]
                                (aset (:array root) 0 (:root this))
                                (aset (:array root) 1 (PersistentVector'newPath (:edit (:root this)), shift, tailnode))
                                [root (+ shift 5)]
                            )
                            [(PersistentVector''pushTail this, shift, (:root this), tailnode) shift]
                        )]
                    (PersistentVector'new-5 (.meta this), (inc n), shift, root, (object-array [ val ]))
                )
            )
        )
    )

    #_method
    (defn- #_"VNode" PersistentVector''pushTail [#_"PersistentVector" this, #_"int" level, #_"VNode" parent, #_"VNode" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" i (& (>>> (dec (:cnt this)) level) 0x01f)
              #_"VNode" ret (VNode'new-2 (:edit parent), (.clone (:array parent)))
              #_"VNode" nodeToInsert
                (when-not (= level 5) => tailnode
                    (let [#_"VNode" child (cast VNode (aget (:array parent) i))]
                        (if (some? child)
                            (PersistentVector''pushTail this, (- level 5), child, tailnode)
                            (PersistentVector'newPath (:edit (:root this)), (- level 5), tailnode)
                        )
                    )
                )]
            (aset (:array ret) i nodeToInsert)
            ret
        )
    )

    (defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" edit, #_"int" level, #_"VNode" node]
        (when-not (zero? level) => node
            (let [#_"VNode" ret (VNode'new-1 edit)]
                (aset (:array ret) 0 (PersistentVector'newPath edit, (- level 5), node))
                ret
            )
        )
    )

    #_method
    (defn #_"IChunkedSeq" PersistentVector''chunkedSeq [#_"PersistentVector" this]
        (when (pos? (.count this))
            (ChunkedSeq'new-3 this, 0, 0)
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentVector [#_"PersistentVector" this]
        (PersistentVector''chunkedSeq this)
    )

    #_override
    (defn #_"Iterator" APersistentVector'''rangedIterator--PersistentVector [#_"PersistentVector" this, #_"int" start, #_"int" end]
        (let [#_"int'" vi (volatile! start) #_"int'" vb (volatile! (- start (% start 32)))
              #_"Object[]'" va (volatile! (when (< start (.count this)) (PersistentVector''arrayFor this, start)))]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (< @vi end)
                )

                #_foreign
                (#_"Object" next [#_"Iterator" _self]
                    (when (< @vi end) => (throw (NoSuchElementException.))
                        (when (= @vi (+ @vb 32))
                            (vreset! va (PersistentVector''arrayFor this, @vi))
                            (vreset! vb @vi)
                        )
                        (let [_ (aget @va (& @vi 0x01f))]
                            (vswap! vi inc)
                            _
                        )
                    )
                )
            )
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---PersistentVector [#_"PersistentVector" this]
        (.rangedIterator this, 0, (.count this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--PersistentVector [#_"PersistentVector" this, #_"IFn" f]
        (when (pos? (:cnt this)) => (.invoke f)
            (loop-when [#_"Object" r (aget (PersistentVector''arrayFor this, 0) 0) #_"int" i 0] (< i (:cnt this)) => r
                (let [#_"Object[]" a (PersistentVector''arrayFor this, i)
                      r (loop-when [r r #_"int" j (if (zero? i) 1 0)] (< j (alength a)) => r
                            (let [r (.invoke f, r, (aget a j))]
                                (when-not (RT'isReduced r) => (ร return (.deref (cast IDeref r)))
                                    (recur r (inc j))
                                )
                            )
                        )]
                    (recur r (+ i (alength a)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--PersistentVector [#_"PersistentVector" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (:cnt this)) => r
            (let [#_"Object[]" a (PersistentVector''arrayFor this, i)
                  r (loop-when [r r #_"int" j 0] (< j (alength a)) => r
                        (let [r (.invoke f, r, (aget a j))]
                            (when-not (RT'isReduced r) => (ร return (.deref (cast IDeref r)))
                                (recur r (inc j))
                            )
                        )
                    )]
                (recur r (+ i (alength a)))
            )
        )
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentVector [#_"PersistentVector" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (:cnt this)) => r
            (let [#_"Object[]" a (PersistentVector''arrayFor this, i)
                  r (loop-when [r r #_"int" j 0] (< j (alength a)) => r
                        (let [r (.invoke f, r, (+ j i), (aget a j))]
                            (when-not (RT'isReduced r) => (ร return (.deref (cast IDeref r)))
                                (recur r (inc j))
                            )
                        )
                    )]
                (recur r (+ i (alength a)))
            )
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentVector [#_"PersistentVector" this]
        (.withMeta PersistentVector'EMPTY, (.meta this))
    )

    #_override
    (defn #_"PersistentVector" IPersistentStack'''pop--PersistentVector [#_"PersistentVector" this]
        (cond
            (zero? (:cnt this))
                (throw (IllegalStateException. "Can't pop empty vector"))
            (= (:cnt this) 1)
                (.withMeta PersistentVector'EMPTY, (.meta this))
            (< 1 (- (:cnt this) (PersistentVector''tailoff this)))
                (let [#_"Object[]" tail (make-array Object (dec (alength (:tail this))))]
                    (System/arraycopy (:tail this), 0, tail, 0, (alength tail))
                    (PersistentVector'new-5 (.meta this), (dec (:cnt this)), (:shift this), (:root this), tail)
                )
            :else
                (let [#_"Object[]" tail (PersistentVector''arrayFor this, (- (:cnt this) 2))
                      #_"int" shift (:shift this)
                      #_"VNode" root (or (PersistentVector''popTail this, shift, (:root this)) PersistentVector'EMPTY_NODE)
                      [shift root]
                        (when (and (< 5 shift) (nil? (aget (:array root) 1))) => [shift root]
                            [(- shift 5) (cast VNode (aget (:array root) 0))]
                        )]
                    (PersistentVector'new-5 (.meta this), (dec (:cnt this)), shift, root, tail)
                )
        )
    )

    #_method
    (defn- #_"VNode" PersistentVector''popTail [#_"PersistentVector" this, #_"int" level, #_"VNode" node]
        (let [#_"int" i (& (>>> (- (:cnt this) 2) level) 0x01f)]
            (cond
                (< 5 level)
                    (let [#_"VNode" child (PersistentVector''popTail this, (- level 5), (cast VNode (aget (:array node) i)))]
                        (when-not (and (nil? child) (zero? i))
                            (let [#_"VNode" ret (VNode'new-2 (:edit (:root this)), (.clone (:array node)))]
                                (aset (:array ret) i child)
                                ret
                            )
                        )
                    )
                (pos? i)
                    (let [#_"VNode" ret (VNode'new-2 (:edit (:root this)), (.clone (:array node)))]
                        (aset (:array ret) i nil)
                        ret
                    )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(class-ns ProxyHandler
    (defn- #_"ProxyHandler" ProxyHandler'init []
        (hash-map
            ;; method-name-string->fn
            #_"IPersistentMap" :fns nil
        )
    )

    (defn #_"ProxyHandler" ProxyHandler'new [#_"IPersistentMap" fns]
        (let [this (ProxyHandler'init)]
            (assoc this :fns fns)
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--ProxyHandler [#_"ProxyHandler" this, #_"Object" proxy, #_"java.lang.reflect.Method" method, #_"Object[]" args]
        (let [#_"IFn" fn (cast IFn (.valAt (:fns this), (.getName method))) #_"Class" rt (.getReturnType method)]
            (if (nil? fn)
                (cond
                    (= rt Void/TYPE)                 nil
                    (= (.getName method) "equals")   (= proxy (aget args 0))
                    (= (.getName method) "hashCode") (System/identityHashCode proxy)
                    (= (.getName method) "toString") (str "Proxy: " (System/identityHashCode proxy))
                    :else                            (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ret (.applyTo fn, (ArraySeq'create-1 args))]
                    (cond
                        (= rt Void/TYPE) nil
                        (.isPrimitive rt)
                            (cond
                                (= rt Character/TYPE) ret
                                (= rt Integer/TYPE)   (.intValue (cast Number ret))
                                (= rt Long/TYPE)      (.longValue (cast Number ret))
                                (= rt Float/TYPE)     (.floatValue (cast Number ret))
                                (= rt Double/TYPE)    (.doubleValue (cast Number ret))
                                (and (= rt Boolean/TYPE) (not (instance? Boolean ret))) (if (nil? ret) Boolean/FALSE Boolean/TRUE)
                                (= rt Byte/TYPE)      (byte (.intValue (cast Number ret)))
                                (= rt Short/TYPE)     (short (.intValue (cast Number ret)))
                                :else ret
                            )
                        :else ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range
    (def- #_"int" Range'CHUNK_SIZE 32)

    (defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" end]
        (reify RangeBoundsCheck
            #_override
            (#_"boolean" exceededBounds [#_"RangeBoundsCheck" _self, #_"Object" val]
                (Numbers'gte-2oo val, end)
            )
        )
    )

    (defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" end]
        (reify RangeBoundsCheck
            #_override
            (#_"boolean" exceededBounds [#_"RangeBoundsCheck" _self, #_"Object" val]
                (Numbers'lte-2oo val, end)
            )
        )
    )

    (defn- #_"Range" Range'init []
        (hash-map
            ;; Invariants guarantee this is never an "empty" seq
            #_"Object" :end nil
            #_"Object" :start nil
            #_"Object" :step nil
            #_"RangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"IChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Range" Range'new-4 [#_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck]
        (let [this (merge (ASeq'new-0) (Range'init))]
            (assoc this :end end :start start :step step :boundsCheck boundsCheck)
        )
    )

    (defn- #_"Range" Range'new-6 [#_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-0) (Range'init))]
            (assoc this :end end :start start :step step :boundsCheck boundsCheck :_chunk chunk :_chunkNext chunkNext)
        )
    )

    (defn- #_"Range" Range'new-7 [#_"IPersistentMap" meta, #_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-1 meta) (Range'init))]
            (assoc this :end end :start start :step step :boundsCheck boundsCheck :_chunk chunk :_chunkNext chunkNext)
        )
    )

    (defn #_"ISeq" Range'create-1 [#_"Object" end]
        (if (Numbers'isPos-1o end)
            (Range'new-4 0, end, 1, (Range'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" Range'create-2 [#_"Object" start, #_"Object" end]
        (Range'create-3 start, end, 1)
    )

    (defn #_"ISeq" Range'create-3 [#_"Object" start, #_"Object" end, #_"Object" step]
        (cond
            (or (and (Numbers'isPos-1o step) (Numbers'gt-2oo start, end))
                (and (Numbers'isNeg-1o step) (Numbers'gt-2oo end, start))
                (Numbers'equiv-2oo start, end)
            )
                PersistentList'EMPTY
            (Numbers'isZero-1o step)
                (Repeat'create-1 start)
            :else
                (Range'new-4 start, end, step, (if (Numbers'isPos-1o step) (Range'positiveStep end) (Range'negativeStep end)))
        )
    )

    #_override
    (defn #_"Range" IObj'''withMeta--Range [#_"Range" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (Range'new-7 meta, (:end this), (:start this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--Range [#_"Range" this]
        (:start this)
    )

    #_method
    (defn #_"void" Range''forceChunk [#_"Range" this]
        (when (nil? (:_chunk this))
            (let [#_"Object[]" a (make-array Object Range'CHUNK_SIZE)]
                (loop [#_"Object" n (:start this) #_"int" i 0]
                    (if (< i Range'CHUNK_SIZE)
                        (do
                            (aset a i n)
                            (let-when [n (Numbers'addP-2oo n, (:step this))] (.exceededBounds (:boundsCheck this), n) => (recur n (inc i))
                                ;; partial last chunk
                                (ร ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, (inc i))))
                            )
                        )
                        (if (.exceededBounds (:boundsCheck this), n)
                            (do
                                ;; full last chunk
                                (ร ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, Range'CHUNK_SIZE)))
                            )
                            (do
                                ;; full intermediate chunk
                                (ร ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, Range'CHUNK_SIZE)))
                                (ร ass this (assoc this :_chunkNext (Range'new-4 n, (:end this), (:step this), (:boundsCheck this))))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Range [#_"Range" this]
        (let-when [#_"Range" _next (:_next this)] (nil? _next) => _next
            (Range''forceChunk this)
            (when (< 1 (.count (:_chunk this))) => (.chunkedNext this)
                (let [#_"IChunk" _rest (.dropFirst (:_chunk this))
                      _next (Range'new-6 (.nth _rest, 0), (:end this), (:step this), (:boundsCheck this), _rest, (:_chunkNext this))]
                    (ร ass this (assoc this :_next _next))
                    _next
                )
            )
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--Range [#_"Range" this]
        (Range''forceChunk this)
        (:_chunk this)
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--Range [#_"Range" this]
        (.seq (.chunkedMore this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--Range [#_"Range" this]
        (Range''forceChunk this)
        (or (:_chunkNext this) PersistentList'EMPTY)
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Range [#_"Range" this, #_"IFn" f]
        (loop [#_"Object" r (:start this) #_"Number" n r]
            (let-when-not [n (Numbers'addP-2oo n, (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast Reduced r))
                    (recur r n)
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Range [#_"Range" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"Object" n (:start this)]
            (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast Reduced r))
                (let-when-not [n (Numbers'addP-2oo n, (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                    (recur r n)
                )
            )
        )
    )

    #_foreign
    (defn #_"Iterator" iterator---Range [#_"Range" this]
        (let [#_"Object'" vn (volatile! (:start this))]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (not (.exceededBounds (:boundsCheck this), @vn))
                )

                #_foreign
                (#_"Object" next [#_"Iterator" self]
                    (when (.hasNext self) => (throw (NoSuchElementException.))
                        (let [_ @vn]
                            (vswap! vn Numbers'addP-2oo (:step this))
                            _
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(class-ns Ratio
    (defn- #_"Ratio" Ratio'init []
        (hash-map
            #_"BigInteger" :numerator nil
            #_"BigInteger" :denominator nil
        )
    )

    (defn #_"Ratio" Ratio'new [#_"BigInteger" numerator, #_"BigInteger" denominator]
        (let [this (merge (ยง foreign Number'new) (Ratio'init))]
            (assoc this :numerator numerator :denominator denominator)
        )
    )

    #_foreign
    (defn #_"boolean" equals---Ratio [#_"Ratio" this, #_"Object" arg0]
        (and (some? arg0) (instance? Ratio arg0) (.equals (:numerator (cast Ratio arg0)), (:numerator this)) (.equals (:denominator (cast Ratio arg0)), (:denominator this)))
    )

    #_foreign
    (defn #_"int" hashCode---Ratio [#_"Ratio" this]
        (bit-xor (.hashCode (:numerator this)) (.hashCode (:denominator this)))
    )

    #_foreign
    (defn #_"String" toString---Ratio [#_"Ratio" this]
        (str (:numerator this) "/" (:denominator this))
    )

    #_method
    (defn #_"int" Ratio''intValue [#_"Ratio" this]
        (int (Ratio''doubleValue this))
    )

    #_method
    (defn #_"long" Ratio''longValue [#_"Ratio" this]
        (.longValue (Ratio''bigIntegerValue this))
    )

    #_method
    (defn #_"float" Ratio''floatValue [#_"Ratio" this]
        (float (Ratio''doubleValue this))
    )

    #_method
    (defn #_"double" Ratio''doubleValue [#_"Ratio" this]
        (.doubleValue (Ratio''decimalValue-2 this, MathContext/DECIMAL64))
    )

    #_method
    (defn #_"BigDecimal" Ratio''decimalValue-1 [#_"Ratio" this]
        (Ratio''decimalValue-2 this, MathContext/UNLIMITED)
    )

    #_method
    (defn #_"BigDecimal" Ratio''decimalValue-2 [#_"Ratio" this, #_"MathContext" mc]
        (let [#_"BigDecimal" numerator (BigDecimal. (:numerator this))
              #_"BigDecimal" denominator (BigDecimal. (:denominator this))]
            (.divide numerator, denominator, mc)
        )
    )

    #_method
    (defn #_"BigInteger" Ratio''bigIntegerValue [#_"Ratio" this]
        (.divide (:numerator this), (:denominator this))
    )

    #_foreign
    (defn #_"int" compareTo---Ratio [#_"Ratio" this, #_"Object" o]
        (Numbers'compare this, (cast Number o))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced
    (defn- #_"Reduced" Reduced'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Reduced" Reduced'new [#_"Object" val]
        (let [this (Reduced'init)]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Reduced [#_"Reduced" this]
        (:val this)
    )
)
)

(java-ns cloiure.lang.Ref

(class-ns RefTVal
    (defn- #_"RefTVal" RefTVal'init []
        (hash-map
            #_"Object" :val nil
            #_"long" :point 0
            #_"RefTVal" :prior nil
            #_"RefTVal" :next nil
        )
    )

    (defn #_"RefTVal" RefTVal'new-3 [#_"Object" val, #_"long" point, #_"RefTVal" prior]
        (let [this
                (-> (RefTVal'init)
                    (assoc :val val :point point :prior prior :next (:next prior))
                )]
            (ร ass (:next (:prior this)) this)
            (ร ass (:prior (:next this)) this)
            this
        )
    )

    (defn #_"RefTVal" RefTVal'new-2 [#_"Object" val, #_"long" point]
        (let [this (RefTVal'init)]
            (assoc this :val val :point point :next this :prior this)
        )
    )
)

(class-ns Ref
    (def #_"AtomicLong" Ref'ids (AtomicLong.))

    (defn- #_"Ref" Ref'init []
        (hash-map
            #_"RefTVal" :tvals nil
            #_"AtomicInteger" :faults nil
            #_"ReentrantReadWriteLock" :lock nil
            #_"LockingTransactionInfo" :tinfo nil
            #_"long" :id 0

            #_volatile
            #_"int" :minHistory 0
            #_volatile
            #_"int" :maxHistory 10
        )
    )

    (defn #_"Ref" Ref'new-1 [#_"Object" initVal]
        (Ref'new-2 initVal, nil)
    )

    (defn #_"Ref" Ref'new-2 [#_"Object" initVal, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Ref'init))]
            (assoc this :id (.getAndIncrement Ref'ids) :faults (AtomicInteger.) :lock (ReentrantReadWriteLock.) :tvals (RefTVal'new-2 initVal, 0))
        )
    )

    #_foreign
    (defn #_"int" compareTo---Ref [#_"Ref" this, #_"Ref" ref]
        (let [a (:id this) b (:id ref)]
            (cond (< a b) -1 (> a b) 1 :else 0)
        )
    )

    #_method
    (defn #_"int" Ref''getMinHistory [#_"Ref" this]
        (:minHistory this)
    )

    #_method
    (defn #_"Ref" Ref''setMinHistory [#_"Ref" this, #_"int" minHistory]
        (assoc this :minHistory minHistory)
    )

    #_method
    (defn #_"int" Ref''getMaxHistory [#_"Ref" this]
        (:maxHistory this)
    )

    #_method
    (defn #_"Ref" Ref''setMaxHistory [#_"Ref" this, #_"int" maxHistory]
        (assoc this :maxHistory maxHistory)
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (defn #_"Object" Ref''currentVal [#_"Ref" this]
        (try
            (.lock (.readLock (:lock this)))
            (when (some? (:tvals this)) => (throw (IllegalStateException. (str this " is unbound.")))
                (:val (:tvals this))
            )
            (finally
                (.unlock (.readLock (:lock this)))
            )
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Ref [#_"Ref" this]
        (let [#_"LockingTransaction" t (LockingTransaction'getRunning)]
            (if (some? t) (LockingTransaction''doGet t, this) (Ref''currentVal this))
        )
    )

    #_method
    (defn #_"Object" Ref''set [#_"Ref" this, #_"Object" val]
        (LockingTransaction''doSet (LockingTransaction'getEx), this, val)
    )

    #_method
    (defn #_"Object" Ref''commute [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (LockingTransaction''doCommute (LockingTransaction'getEx), this, fn, args)
    )

    #_method
    (defn #_"Object" Ref''alter [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (let [#_"LockingTransaction" t (LockingTransaction'getEx)]
            (LockingTransaction''doSet t, this, (.applyTo fn, (RT'cons (LockingTransaction''doGet t, this), args)))
        )
    )

    #_method
    (defn #_"void" Ref''touch [#_"Ref" this]
        (LockingTransaction''doEnsure (LockingTransaction'getEx), this)
        nil
    )

    #_method
    (defn #_"boolean" Ref''isBound [#_"Ref" this]
        (try
            (.lock (.readLock (:lock this)))
            (some? (:tvals this))
            (finally
                (.unlock (.readLock (:lock this)))
            )
        )
    )

    #_method
    (defn #_"void" Ref''trimHistory [#_"Ref" this]
        (try
            (.lock (.writeLock (:lock this)))
            (when (some? (:tvals this))
                (ร ass (:next (:tvals this)) (:tvals this))
                (ร ass (:prior (:tvals this)) (:tvals this))
            )
            (finally
                (.unlock (.writeLock (:lock this)))
            )
        )
        nil
    )

    #_method
    (defn #_"int" Ref''getHistoryCount [#_"Ref" this]
        (try
            (.lock (.writeLock (:lock this)))
            (Ref''histCount this)
            (finally
                (.unlock (.writeLock (:lock this)))
            )
        )
    )

    #_method
    (defn #_"int" Ref''histCount [#_"Ref" this]
        (when (some? (:tvals this)) => 0
            (loop-when-recur [#_"int" n 0 #_"RefTVal" tv (:next (:tvals this))] (not= tv (:tvals this)) [(inc n) (:next tv)] => n)
        )
    )

    #_method
    (defn #_"IFn" Ref''fn [#_"Ref" this]
        (cast IFn (.deref this))
    )

    #_foreign
    (defn #_"Object" call---Ref [#_"Ref" this]
        (.invoke this)
    )

    #_foreign
    (defn #_"void" run---Ref [#_"Ref" this]
        (.invoke this)
        nil
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--Ref [#_"Ref" this]
        (.invoke (Ref''fn this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Ref [#_"Ref" this, #_"Object" arg1]
        (.invoke (Ref''fn this), arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2]
        (.invoke (Ref''fn this), arg1, arg2)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.invoke (Ref''fn this), arg1, arg2, arg3)
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4)
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5)
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6)
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16)
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17)
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.invoke (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args)
    )

    #_override
    (defn #_"Object" IFn'''applyTo--Ref [#_"Ref" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )
)
)

(java-ns cloiure.lang.Reflector

(class-ns Reflector
    (defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" target, #_"String" methodName, #_"Object[]" args]
        (let [#_"List" methods (Reflector'getMethods (.getClass target), (alength args), methodName, false)]
            (Reflector'invokeMatchingMethod methodName, methods, target, args)
        )
    )

    (defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" e]
        (or (.getCause e) e)
    )

    (defn- #_"String" Reflector'noMethodReport [#_"String" methodName, #_"Object" target]
        (str "No matching method found: " methodName (when (some? target) (str " for " (.getClass target))))
    )

    (defn #_"Object" Reflector'invokeMatchingMethod [#_"String" methodName, #_"List" methods, #_"Object" target, #_"Object[]" args]
        (let-when [#_"int" n (.size methods)] (pos? n) => (throw (IllegalArgumentException. (Reflector'noMethodReport methodName, target)))
            (let [[#_"java.lang.reflect.Method" m #_"Object[]" boxedArgs]
                    (if (= n 1)
                        (let [m (cast java.lang.reflect.Method (.get methods, 0))]
                            [m (Reflector'boxArgs (.getParameterTypes m), args)]
                        )
                        ;; overloaded w/same arity
                        (let [#_"Iterator" it (.iterator methods)]
                            (loop-when [#_"java.lang.reflect.Method" found nil boxedArgs nil] (.hasNext it) => [found boxedArgs]
                                (let [m (cast java.lang.reflect.Method (.next it)) #_"Class[]" params (.getParameterTypes m)
                                    [found boxedArgs]
                                        (if (and (Reflector'isCongruent params, args) (or (nil? found) (Compiler'subsumes params, (.getParameterTypes found))))
                                            [m (Reflector'boxArgs params, args)]
                                            [found boxedArgs]
                                        )]
                                    (recur found boxedArgs)
                                )
                            )
                        )
                    )]
                (when (some? m) => (throw (IllegalArgumentException. (Reflector'noMethodReport methodName, target)))
                    (let [m (when-not (Modifier/isPublic (.getModifiers (.getDeclaringClass m))) => m
                                ;; public method of non-public class, try to find it in hierarchy
                                (or (Reflector'getAsMethodOfPublicBase (.getClass target), m)
                                    (throw (IllegalArgumentException. (str "Can't call public method of non-public class: " m)))
                                )
                            )]
                        (try
                            (Reflector'prepRet (.getReturnType m), (.invoke m, target, boxedArgs))
                            (catch Exception e
                                (throw (Reflector'getCauseOrElse e))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"java.lang.reflect.Method" Reflector'getAsMethodOfPublicBase [#_"Class" c, #_"java.lang.reflect.Method" m]
        (or
            (let [#_"Class[]" ifaces (.getInterfaces c)]
                (loop-when [#_"int" j 0] (< j (alength ifaces))
                    (let [#_"java.lang.reflect.Method[]" methods (.getMethods (aget ifaces j))]
                        (or
                            (loop-when [#_"int" i 0] (< i (alength methods))
                                (let-when [#_"java.lang.reflect.Method" im (aget methods i)] (Reflector'isMatch im, m) => (recur (inc i))
                                    im
                                )
                            )
                            (recur (inc j))
                        )
                    )
                )
            )
            (when-let [#_"Class" sc (.getSuperclass c)]
                (let [#_"java.lang.reflect.Method[]" methods (.getMethods sc)]
                    (loop-when [#_"int" i 0] (< i (alength methods)) => (Reflector'getAsMethodOfPublicBase sc, m)
                        (let-when [#_"java.lang.reflect.Method" scm (aget methods i)] (Reflector'isMatch scm, m) => (recur (inc i))
                            scm
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" Reflector'isMatch [#_"java.lang.reflect.Method" lhs, #_"java.lang.reflect.Method" rhs]
        (and (.equals (.getName lhs), (.getName rhs)) (Modifier/isPublic (.getModifiers (.getDeclaringClass lhs)))
            (let [#_"Class[]" types1 (.getParameterTypes lhs) #_"Class[]" types2 (.getParameterTypes rhs)]
                (and (= (alength types1) (alength types2))
                    (loop-when [#_"int" i 0] (< i (alength types1)) => true
                        (and (.isAssignableFrom (aget types1 i), (aget types2 i))
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeConstructor [#_"Class" c, #_"Object[]" args]
        (try
            (let [#_"Constructor[]" allctors (.getConstructors c) #_"List" ctors (ArrayList.)]
                (dotimes [#_"int" i (alength allctors)]
                    (let-when [#_"Constructor" ctor (aget allctors i)] (= (alength (.getParameterTypes ctor)) (alength args))
                        (.add ctors, ctor)
                    )
                )
                (condp = (.size ctors)
                    0   (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    1   (let [#_"Constructor" ctor (cast Constructor (.get ctors, 0))]
                            (.newInstance ctor, (Reflector'boxArgs (.getParameterTypes ctor), args))
                        )
                    (or ;; overloaded w/same arity
                        (loop-when-recur [#_"Iterator" it (.iterator ctors)] (.hasNext it) [it]
                            (let [#_"Constructor" ctor (cast Constructor (.next it))]
                                (let-when [#_"Class[]" params (.getParameterTypes ctor)] (Reflector'isCongruent params, args)
                                    (.newInstance ctor, (Reflector'boxArgs params, args))
                                )
                            )
                        )
                        (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    )
                )
            )
            (catch Exception e
                (throw (Reflector'getCauseOrElse e))
            )
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" className, #_"String" methodName & #_"Object..." args]
        (Reflector'invokeStaticMethod-3s className, methodName, args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3s [#_"String" className, #_"String" methodName, #_"Object[]" args]
        (Reflector'invokeStaticMethod-3c (RT'classForName-1 className), methodName, args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3c [#_"Class" c, #_"String" methodName, #_"Object[]" args]
        (if (= methodName "new")
            (Reflector'invokeConstructor c, args)
            (let [#_"List" methods (Reflector'getMethods c, (alength args), methodName, true)]
                (Reflector'invokeMatchingMethod methodName, methods, nil, args)
            )
        )
    )

    (defn #_"Object" Reflector'getStaticField-2s [#_"String" className, #_"String" fieldName]
        (let [#_"Class" c (RT'classForName-1 className)]
            (Reflector'getStaticField-2c c, fieldName)
        )
    )

    (defn #_"Object" Reflector'getStaticField-2c [#_"Class" c, #_"String" fieldName]
        (let [#_"Field" f (Reflector'getField c, fieldName, true)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (Reflector'prepRet (.getType f), (.get f, nil))
            )
        )
    )

    (defn #_"Object" Reflector'setStaticField-3s [#_"String" className, #_"String" fieldName, #_"Object" val]
        (Reflector'setStaticField-3c (RT'classForName-1 className), fieldName, val)
    )

    (defn #_"Object" Reflector'setStaticField-3c [#_"Class" c, #_"String" fieldName, #_"Object" val]
        (let [#_"Field" f (Reflector'getField c, fieldName, true)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (.set f, nil, (Reflector'boxArg (.getType f), val))
                val
            )
        )
    )

    (defn #_"Object" Reflector'getInstanceField [#_"Object" target, #_"String" fieldName]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, fieldName, false)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (Reflector'prepRet (.getType f), (.get f, target))
            )
        )
    )

    (defn #_"Object" Reflector'setInstanceField [#_"Object" target, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, fieldName, false)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " (.getClass target))))
                (.set f, target, (Reflector'boxArg (.getType f), val))
                val
            )
        )
    )

    (defn #_"Object" Reflector'invokeNoArgInstanceMember [#_"Object" target, #_"String" name, #_"boolean" requireField]
        (let [#_"Class" c (.getClass target)]
            (if requireField
                (let [#_"Field" f (Reflector'getField c, name, false)]
                    (if (some? f)
                        (Reflector'getInstanceField target, name)
                        (throw (IllegalArgumentException. (str "No matching field found: " name " for " (.getClass target))))
                    )
                )
                (let [#_"List" meths (Reflector'getMethods c, 0, name, false)]
                    (if (pos? (.size meths))
                        (Reflector'invokeMatchingMethod name, meths, target, RT'EMPTY_ARRAY)
                        (Reflector'getInstanceField target, name)
                    )
                )
            )
        )
    )

    ;; field get
    (defn #_"Object" Reflector'invokeInstanceMember-2 [#_"Object" target, #_"String" name]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, name, false)]
            (when (some? f) => (Reflector'invokeInstanceMethod target, name, RT'EMPTY_ARRAY)
                (Reflector'prepRet (.getType f), (.get f, target))
            )
        )
    )

    ;; field set
    (defn #_"Object" Reflector'invokeInstanceMember-3o [#_"String" name, #_"Object" target, #_"Object" arg1]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, name, false)]
            (when (some? f) => (Reflector'invokeInstanceMethod target, name, (object-array [ arg1 ]))
                (.set f, target, (Reflector'boxArg (.getType f), arg1))
                arg1
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3a [#_"String" name, #_"Object" target & #_"Object..." args]
        (Reflector'invokeInstanceMethod target, name, args)
    )

    (defn #_"Field" Reflector'getField [#_"Class" c, #_"String" name, #_"boolean" getStatics]
        (let [#_"Field[]" allfields (.getFields c)]
            (loop-when [#_"int" i 0] (< i (alength allfields))
                (let [#_"Field" f (aget allfields i)]
                    (if (and (.equals name, (.getName f)) (= (Modifier/isStatic (.getModifiers f)) getStatics))
                        f
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (defn #_"List" Reflector'getMethods [#_"Class" c, #_"int" arity, #_"String" name, #_"boolean" getStatics]
        (let [#_"java.lang.reflect.Method[]" allmethods (.getMethods c)
              #_"List" methods (ArrayList.) #_"List" bridgeMethods (ArrayList.)]
            (dotimes [#_"int" i (alength allmethods)]
                (let [#_"java.lang.reflect.Method" m (aget allmethods i)]
                    (when (and (.equals name, (.getName m)) (= (Modifier/isStatic (.getModifiers m)) getStatics) (= (alength (.getParameterTypes m)) arity))
                        (try
                            (if (and (.isBridge m) (.equals (.getMethod c, (.getName m), (.getParameterTypes m)), m))
                                (.add bridgeMethods, m)
                                (.add methods, m)
                            )
                            (catch NoSuchMethodException _
                            )
                        )
                    )
                )
            )
            (when (.isEmpty methods)
                (dotimes [#_"int" i (.size bridgeMethods)]
                    (.add methods, (.get bridgeMethods, i))
                )
            )
            (when (and (not getStatics) (.isInterface c))
                (let [allmethods (.getMethods Object)]
                    (dotimes [#_"int" i (alength allmethods)]
                        (let [#_"java.lang.reflect.Method" m (aget allmethods i)]
                            (when (and (.equals name, (.getName m)) (= (Modifier/isStatic (.getModifiers m)) getStatics) (= (alength (.getParameterTypes m)) arity))
                                (.add methods, m)
                            )
                        )
                    )
                )
            )
            methods
        )
    )

    (defn #_"Object" Reflector'boxArg [#_"Class" paramType, #_"Object" arg]
        (let [unexpected! #(throw (IllegalArgumentException. (str "Unexpected param type, expected: " paramType ", given: " (.getName (.getClass arg)))))]
            (cond
                (not (.isPrimitive paramType)) (.cast paramType, arg)
                (= paramType Boolean/TYPE)     (.cast Boolean, arg)
                (= paramType Character/TYPE)   (.cast Character, arg)
                (instance? Number arg)
                    (let [#_"Number" n (cast Number arg)]
                        (condp = paramType
                            Integer/TYPE (.intValue n)
                            Float/TYPE   (.floatValue n)
                            Double/TYPE  (.doubleValue n)
                            Long/TYPE    (.longValue n)
                            Short/TYPE   (.shortValue n)
                            Byte/TYPE    (.byteValue n)
                                         (unexpected!)
                        )
                    )
                :else
                    (unexpected!)
            )
        )
    )

    (defn #_"Object[]" Reflector'boxArgs [#_"Class[]" params, #_"Object[]" args]
        (when (pos? (alength params))
            (let [#_"Object[]" a (make-array Object (alength params))]
                (dotimes [#_"int" i (alength params)]
                    (aset a i (Reflector'boxArg (aget params i), (aget args i)))
                )
                a
            )
        )
    )

    (defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" paramType, #_"Class" argType]
        (cond
            (nil? argType)
                (not (.isPrimitive paramType))
            (or (= paramType argType) (.isAssignableFrom paramType, argType))
                true
            :else
                (condp = paramType
                    Integer/TYPE   (any = argType Integer Long/TYPE Long Short/TYPE Byte/TYPE)
                    Float/TYPE     (any = argType Float Double/TYPE)
                    Double/TYPE    (any = argType Double Float/TYPE)
                    Long/TYPE      (any = argType Long Integer/TYPE Short/TYPE Byte/TYPE)
                    Character/TYPE (= argType Character)
                    Short/TYPE     (= argType Short)
                    Byte/TYPE      (= argType Byte)
                    Boolean/TYPE   (= argType Boolean)
                                   false
                )
        )
    )

    (defn #_"boolean" Reflector'isCongruent [#_"Class[]" params, #_"Object[]" args]
        (when (some? args) => (zero? (alength params))
            (and (= (alength params) (alength args))
                (loop-when [#_"boolean" ? true #_"int" i 0] (and ? (< i (alength params)))
                    (let [#_"Object" arg (aget args i)]
                        (recur (Reflector'paramArgTypeMatch (aget params i), (when (some? arg) (.getClass arg))) (inc i))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'prepRet [#_"Class" c, #_"Object" x]
        (cond
            (not (or (.isPrimitive c) (= c Boolean))) x
            (instance? Boolean x)                     (if (cast Boolean x) Boolean/TRUE Boolean/FALSE)
            :else                                     x
        )
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat
    (def- #_"long" Repeat'INFINITE -1)

    (defn- #_"Repeat" Repeat'init []
        (hash-map
            #_"long" :count 0 ;; always INFINITE or >0
            #_"Object" :val nil
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Repeat" Repeat'new-2 [#_"long" count, #_"Object" val]
        (let [this (merge (ASeq'new-0) (Repeat'init))]
            (assoc this :count count :val val)
        )
    )

    (defn- #_"Repeat" Repeat'new-3 [#_"IPersistentMap" meta, #_"long" count, #_"Object" val]
        (let [this (merge (ASeq'new-1 meta) (Repeat'init))]
            (assoc this :count count :val val)
        )
    )

    (defn #_"Repeat" Repeat'create-1 [#_"Object" val]
        (Repeat'new-2 Repeat'INFINITE, val)
    )

    (defn #_"ISeq" Repeat'create-2 [#_"long" count, #_"Object" val]
        (if (pos? count) (Repeat'new-2 count, val) PersistentList'EMPTY)
    )

    #_override
    (defn #_"Object" ISeq'''first--Repeat [#_"Repeat" this]
        (:val this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Repeat [#_"Repeat" this]
        (when (nil? (:_next this))
            (cond (< 1 (:count this))
                (do
                    (ร ass this (assoc this :_next (Repeat'new-2 (dec (:count this)), (:val this))))
                )
                (= (:count this) Repeat'INFINITE)
                (do
                    (ร ass this (assoc this :_next this))
                )
            )
        )
        (:_next this)
    )

    #_override
    (defn #_"Repeat" IObj'''withMeta--Repeat [#_"Repeat" this, #_"IPersistentMap" meta]
        (Repeat'new-3 meta, (:count this), (:val this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Repeat [#_"Repeat" this, #_"IFn" f]
        (let [#_"Object" r (:val this)]
            (if (= (:count this) Repeat'INFINITE)
                (loop [r r]
                    (let [r (.invoke f, r, (:val this))]
                        (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r))
                    )
                )
                (loop-when [r r #_"long" i 1] (< i (:count this)) => r
                    (let [r (.invoke f, r, (:val this))]
                        (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Repeat [#_"Repeat" this, #_"IFn" f, #_"Object" r]
        (if (= (:count this) Repeat'INFINITE)
            (loop [r r]
                (let [r (.invoke f, r, (:val this))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r))
                )
            )
            (loop-when [r r #_"long" i 0] (< i (:count this)) => r
                (let [r (.invoke f, r, (:val this))]
                    (if (RT'isReduced r) (.deref (cast IDeref r)) (recur r (inc i)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RT

(class-ns RT
    (def #_"Class" RT'BOOLEANS_CLASS (Class/forName "[Z"))
    (def #_"Class" RT'BYTES_CLASS (Class/forName "[B"))
    (def #_"Class" RT'SHORTS_CLASS (Class/forName "[S"))
    (def #_"Class" RT'CHARS_CLASS (Class/forName "[C"))
    (def #_"Class" RT'INTS_CLASS (Class/forName "[I"))
    (def #_"Class" RT'LONGS_CLASS (Class/forName "[J"))
    (def #_"Class" RT'FLOATS_CLASS (Class/forName "[F"))
    (def #_"Class" RT'DOUBLES_CLASS (Class/forName "[D"))
    (def #_"Class" RT'OBJECTS_CLASS (Class/forName "[Ljava.lang.Object;"))

    (def #_"Boolean" RT'T Boolean/TRUE)
    (def #_"Boolean" RT'F Boolean/FALSE)
    (def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (ยง def #_"IPersistentMap" RT'DEFAULT_IMPORTS (RT'map
        (object-array [
            (Symbol'intern "Boolean")                         Boolean
            (Symbol'intern "Byte")                            Byte
            (Symbol'intern "Character")                       Character
            (Symbol'intern "Class")                           Class
            (Symbol'intern "ClassLoader")                     ClassLoader
            (Symbol'intern "Compiler")                        Compiler
            (Symbol'intern "Double")                          Double
            (Symbol'intern "Enum")                            Enum
            (Symbol'intern "Float")                           Float
            (Symbol'intern "InheritableThreadLocal")          InheritableThreadLocal
            (Symbol'intern "Integer")                         Integer
            (Symbol'intern "Long")                            Long
            (Symbol'intern "Math")                            Math
            (Symbol'intern "Number")                          Number
            (Symbol'intern "Object")                          Object
            (Symbol'intern "Package")                         Package
            (Symbol'intern "Process")                         Process
            (Symbol'intern "ProcessBuilder")                  ProcessBuilder
            (Symbol'intern "Runtime")                         Runtime
            (Symbol'intern "RuntimePermission")               RuntimePermission
            (Symbol'intern "SecurityManager")                 SecurityManager
            (Symbol'intern "Short")                           Short
            (Symbol'intern "StackTraceElement")               StackTraceElement
            (Symbol'intern "StrictMath")                      StrictMath
            (Symbol'intern "String")                          String
            (Symbol'intern "StringBuffer")                    StringBuffer
            (Symbol'intern "StringBuilder")                   StringBuilder
            (Symbol'intern "System")                          System
            (Symbol'intern "Thread")                          Thread
            (Symbol'intern "ThreadGroup")                     ThreadGroup
            (Symbol'intern "ThreadLocal")                     ThreadLocal
            (Symbol'intern "Throwable")                       Throwable
            (Symbol'intern "Void")                            Void
            (Symbol'intern "Appendable")                      Appendable
            (Symbol'intern "CharSequence")                    CharSequence
            (Symbol'intern "Cloneable")                       Cloneable
            (Symbol'intern "Comparable")                      Comparable
            (Symbol'intern "Iterable")                        Iterable
            (Symbol'intern "Readable")                        Readable
            (Symbol'intern "Runnable")                        Runnable
            (Symbol'intern "Callable")                        Callable
            (Symbol'intern "BigInteger")                      BigInteger
            (Symbol'intern "BigDecimal")                      BigDecimal
            (Symbol'intern "ArithmeticException")             ArithmeticException
            (Symbol'intern "ArrayIndexOutOfBoundsException")  ArrayIndexOutOfBoundsException
            (Symbol'intern "ArrayStoreException")             ArrayStoreException
            (Symbol'intern "ClassCastException")              ClassCastException
            (Symbol'intern "ClassNotFoundException")          ClassNotFoundException
            (Symbol'intern "CloneNotSupportedException")      CloneNotSupportedException
            (Symbol'intern "EnumConstantNotPresentException") EnumConstantNotPresentException
            (Symbol'intern "Exception")                       Exception
            (Symbol'intern "IllegalAccessException")          IllegalAccessException
            (Symbol'intern "IllegalArgumentException")        IllegalArgumentException
            (Symbol'intern "IllegalMonitorStateException")    IllegalMonitorStateException
            (Symbol'intern "IllegalStateException")           IllegalStateException
            (Symbol'intern "IllegalThreadStateException")     IllegalThreadStateException
            (Symbol'intern "IndexOutOfBoundsException")       IndexOutOfBoundsException
            (Symbol'intern "InstantiationException")          InstantiationException
            (Symbol'intern "InterruptedException")            InterruptedException
            (Symbol'intern "NegativeArraySizeException")      NegativeArraySizeException
            (Symbol'intern "NoSuchFieldException")            NoSuchFieldException
            (Symbol'intern "NoSuchMethodException")           NoSuchMethodException
            (Symbol'intern "NullPointerException")            NullPointerException
            (Symbol'intern "NumberFormatException")           NumberFormatException
            (Symbol'intern "RuntimeException")                RuntimeException
            (Symbol'intern "SecurityException")               SecurityException
            (Symbol'intern "StringIndexOutOfBoundsException") StringIndexOutOfBoundsException
            (Symbol'intern "TypeNotPresentException")         TypeNotPresentException
            (Symbol'intern "UnsupportedOperationException")   UnsupportedOperationException
            (Symbol'intern "AbstractMethodError")             AbstractMethodError
            (Symbol'intern "AssertionError")                  AssertionError
            (Symbol'intern "ClassCircularityError")           ClassCircularityError
            (Symbol'intern "ClassFormatError")                ClassFormatError
            (Symbol'intern "Error")                           Error
            (Symbol'intern "ExceptionInInitializerError")     ExceptionInInitializerError
            (Symbol'intern "IllegalAccessError")              IllegalAccessError
            (Symbol'intern "IncompatibleClassChangeError")    IncompatibleClassChangeError
            (Symbol'intern "InstantiationError")              InstantiationError
            (Symbol'intern "InternalError")                   InternalError
            (Symbol'intern "LinkageError")                    LinkageError
            (Symbol'intern "NoClassDefFoundError")            NoClassDefFoundError
            (Symbol'intern "NoSuchFieldError")                NoSuchFieldError
            (Symbol'intern "NoSuchMethodError")               NoSuchMethodError
            (Symbol'intern "OutOfMemoryError")                OutOfMemoryError
            (Symbol'intern "StackOverflowError")              StackOverflowError
            (Symbol'intern "ThreadDeath")                     ThreadDeath
            (Symbol'intern "UnknownError")                    UnknownError
            (Symbol'intern "UnsatisfiedLinkError")            UnsatisfiedLinkError
            (Symbol'intern "UnsupportedClassVersionError")    UnsupportedClassVersionError
            (Symbol'intern "VerifyError")                     VerifyError
            (Symbol'intern "VirtualMachineError")             VirtualMachineError
            (Symbol'intern "Thread$UncaughtExceptionHandler") Thread$UncaughtExceptionHandler
            (Symbol'intern "Thread$State")                    Thread$State
            (Symbol'intern "Deprecated")                      Deprecated
            (Symbol'intern "Override")                        Override
            (Symbol'intern "SuppressWarnings")                SuppressWarnings
        ])
    ))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (def #_"Charset" RT'UTF8 (Charset/forName "UTF-8"))

    (ยง def #_"Namespace" RT'CLOIURE_NS (Namespace'findOrCreate (Symbol'intern "cloiure.core")))

    (ยง def #_"Var" RT'IN (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*in*"), (LineNumberingPushbackReader'new-1 (InputStreamReader. System/in)))))
    (ยง def #_"Var" RT'OUT (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*out*"), (OutputStreamWriter. System/out))))
    (ยง def #_"Var" RT'ERR (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*err*"), (PrintWriter. (OutputStreamWriter. System/err), true))))

    (ยง def #_"Keyword" RT'TAG_KEY (Keyword'intern (Symbol'intern nil, "tag")))

    (ยง def #_"Var" RT'AGENT (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*agent*"), nil)))

    (ยง def #_"Var" RT'ASSERT (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*assert*"), RT'T)))
    (ยง def #_"Var" RT'MATH_CONTEXT (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*math-context*"), nil)))

    (ยง def #_"Keyword" RT'LINE_KEY (Keyword'intern (Symbol'intern nil, "line")))
    (ยง def #_"Keyword" RT'COLUMN_KEY (Keyword'intern (Symbol'intern nil, "column")))
    (ยง def #_"Keyword" RT'DECLARED_KEY (Keyword'intern (Symbol'intern nil, "declared")))
    (ยง def #_"Keyword" RT'DOC_KEY (Keyword'intern (Symbol'intern nil, "doc")))

    (ยง def #_"Symbol" RT'IN_NAMESPACE (Symbol'intern "in-ns"))
    (ยง def #_"Symbol" RT'NAMESPACE (Symbol'intern "ns"))
    (ยง def #_"Symbol" RT'IDENTICAL (Symbol'intern "identical?"))

    (ยง def #_"Var" RT'CURRENT_NS (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*ns*"), RT'CLOIURE_NS)))

    (ยง def #_"Var" RT'FLUSH_ON_NEWLINE (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*flush-on-newline*"), RT'T)))
    (ยง def #_"Var" RT'PRINT_READABLY (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*print-readably*"), RT'T)))
    (ยง def #_"Var" RT'WARN_ON_REFLECTION (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*warn-on-reflection*"), RT'F)))
    (ยง def #_"Var" RT'ALLOW_UNRESOLVED_VARS (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*allow-unresolved-vars*"), RT'F)))

    (ยง def #_"Var" RT'IN_NS_VAR (Var'intern RT'CLOIURE_NS, (Symbol'intern "in-ns"), RT'F))
    (ยง def #_"Var" RT'NS_VAR (Var'intern RT'CLOIURE_NS, (Symbol'intern "ns"), RT'F))
    (ยง def #_"Var" RT'FN_LOADER_VAR (Var''setDynamic-1 (Var'intern RT'CLOIURE_NS, (Symbol'intern "*fn-loader*"), nil)))
    (ยง def #_"Var" RT'PRINT_INITIALIZED (Var'intern RT'CLOIURE_NS, (Symbol'intern "print-initialized")))
    (ยง def #_"Var" RT'PR_ON (Var'intern RT'CLOIURE_NS, (Symbol'intern "pr-on")))

    (defn #_"Object" RT'inNamespace [#_"Object" arg1]
        (let [#_"Namespace" ns (Namespace'findOrCreate (cast Symbol arg1))]
            (Var''set RT'CURRENT_NS, ns)
            ns
        )
    )

    (defn #_"Object" RT'bootNamespace [#_"Object" __form, #_"Object" __env, #_"Object" arg1]
        (let [#_"Namespace" ns (Namespace'findOrCreate (cast Symbol arg1))]
            (Var''set RT'CURRENT_NS, ns)
            ns
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" w (cast Writer (.deref RT'ERR))]
            (if (instance? PrintWriter w) (cast PrintWriter w) (PrintWriter. w))
        )
    )

    (def #_"Object[]" RT'EMPTY_ARRAY (make-array Object 0))
    (def #_"Comparator" RT'DEFAULT_COMPARATOR
        (reify Comparator
            #_foreign
            (#_"int" compare [#_"Comparator" _self, #_"Object" o1, #_"Object" o2]
                (Util'compare o1, o2)
            )
        )
    )

    (def #_"AtomicInteger" RT'ID (AtomicInteger. 1))

    (def #_"boolean" RT'CHECK_SPEC_ASSERTS false #_"cloiure.spec.check-asserts")
    (def #_"boolean" RT'INSTRUMENT_MACROS true #_"cloiure.spec.skip-macros")
    #_volatile
    (def #_"boolean" RT'CHECK_SPECS false)

    (ยง static
        (Var''setTag RT'OUT, (Symbol'intern "java.io.Writer"))
        (Var''setTag RT'CURRENT_NS, (Symbol'intern "cloiure.lang.Namespace"))
        (Var''setMeta RT'AGENT, (RT'map RT'DOC_KEY, "The agent currently running an action on this thread, else nil."))
        (Var''setTag RT'AGENT, (Symbol'intern "cloiure.lang.Agent"))
        (Var''setTag RT'MATH_CONTEXT, (Symbol'intern "java.math.MathContext"))
        (let [#_"Var" v (Var'intern RT'CLOIURE_NS, RT'NAMESPACE, bootNamespace)
              _ (Var''setMacro v)
              v (Var'intern RT'CLOIURE_NS, RT'IN_NAMESPACE, inNamespace)
              _ (Var''setMeta v, (RT'map RT'DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed."))]
            (RT'load-1 "cloiure/core")
            (ร ass RT'CHECK_SPECS RT'INSTRUMENT_MACROS)
        )
    )

    (defn #_"Keyword" RT'keyword [#_"String" ns, #_"String" name]
        (Keyword'intern (Symbol'intern ns, name))
    )

    (defn #_"Var" RT'var
        ([#_"String" ns, #_"String" name]
            (Var'intern (Namespace'findOrCreate (Symbol'intern nil, ns)), (Symbol'intern nil, name))
        )
        ([#_"String" ns, #_"String" name, #_"Object" init]
            (Var'intern (Namespace'findOrCreate (Symbol'intern nil, ns)), (Symbol'intern nil, name), init)
        )
    )

    (defn #_"void" RT'loadResourceScript [#_"String" name, #_"boolean" failIfNotFound]
        (let [#_"InputStream" ins (RT'resourceAsStream (RT'baseLoader), name)]
            (cond (some? ins)
                (try
                    (Compiler'load (InputStreamReader. ins, RT'UTF8))
                    (finally
                        (.close ins)
                    )
                )
                failIfNotFound
                    (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " name)))
            )
        )
        nil
    )

    (defn #_"long" RT'lastModified [#_"URL" url, #_"String" libfile]
        (let [#_"URLConnection" connection (.openConnection url)]
            (try
                (if (= (.getProtocol url) "jar")
                    (.getTime (.getEntry (.getJarFile (cast JarURLConnection connection)), libfile))
                    (.getLastModified connection)
                )
                (finally
                    (let [#_"InputStream" ins (.getInputStream connection)]
                        (when (some? ins)
                            (.close ins)
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'load-1 [#_"String" scriptbase]
        (RT'load-2 scriptbase, true)
        nil
    )

    (defn #_"void" RT'load-2 [#_"String" scriptbase, #_"boolean" failIfNotFound]
        (let [#_"String" classfile (str scriptbase RT'LOADER_SUFFIX ".class") #_"String" cljfile (str scriptbase ".cli")
              #_"URL" classURL (RT'getResource (RT'baseLoader), classfile) #_"URL" cljURL (RT'getResource (RT'baseLoader), cljfile)
              #_"boolean" loaded false
              loaded
                (when (or (and (some? classURL) (or (nil? cljURL) (< (RT'lastModified cljURL, cljfile) (RT'lastModified classURL, classfile)))) (nil? classURL)) => loaded
                    (try
                        (Var'pushThreadBindings (RT'mapUniqueKeys
                            (object-array [
                                RT'CURRENT_NS         (.deref RT'CURRENT_NS)
                                RT'WARN_ON_REFLECTION (.deref RT'WARN_ON_REFLECTION)
                            ])
                        ))
                        (some? (RT'loadClassForName (str (.replace scriptbase, \/, \.) RT'LOADER_SUFFIX)))
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                )]
            (cond
                (and (not loaded) (some? cljURL))
                    (RT'loadResourceScript cljfile, true)
                (and (not loaded) failIfNotFound)
                    (throw (FileNotFoundException. (str "Could not locate " classfile " or " cljfile " on classpath." (when (.contains scriptbase, "_") " Please check that namespaces with dashes use underscores in the Cloiure file name."))))
            )
        )
        nil
    )

    (defn #_"int" RT'nextID []
        (.getAndIncrement RT'ID)
    )

    (def- #_"int" RT'CHUNK_SIZE 32)

    (defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" it]
        (when (.hasNext it)
            (LazySeq'new-1
                (fn #_"Object" []
                    (let [#_"Object[]" a (make-array Object RT'CHUNK_SIZE)
                          #_"int" n
                            (loop-when-recur [n 0] (and (.hasNext it) (< n RT'CHUNK_SIZE)) [(inc n)] => n
                                (aset a n (.next it))
                            )]
                        (ChunkedCons'new-2 (ArrayChunk'new-3 a, 0, n), (RT'chunkIteratorSeq it))
                    )
                )
            )
        )
    )

    (defn #_"ISeq" RT'seq [#_"Object" coll]
        (cond
            (instance? ASeq coll)    (cast ASeq coll)
            (instance? LazySeq coll) (.seq (cast LazySeq coll))
            :else                    (RT'seqFrom coll)
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (defn #_"ISeq" RT'seqFrom [#_"Object" coll]
        (cond
            (instance? Seqable coll)      (.seq (cast Seqable coll))
            (nil? coll)                   nil
            (instance? Iterable coll)     (RT'chunkIteratorSeq (.iterator (cast Iterable coll)))
            (.isArray (.getClass coll))   (ArraySeq'createFromObject coll)
            (instance? CharSequence coll) (StringSeq'create (cast CharSequence coll))
            (instance? Map coll)          (RT'seq (.entrySet (cast Map coll)))
            :else (throw (IllegalArgumentException. (str "Don't know how to create ISeq from: " (.getName (.getClass coll)))))
        )
    )

    (defn #_"boolean" RT'canSeq [#_"Object" coll]
        (or
            (instance? ISeq coll)
            (instance? Seqable coll)
            (nil? coll)
            (instance? Iterable coll)
            (.isArray (.getClass coll))
            (instance? CharSequence coll)
            (instance? Map coll)
        )
    )

    (defn #_"Iterator" RT'iter [#_"Object" coll]
        (cond
            (instance? Iterable coll)
                (.iterator (cast Iterable coll))
            (nil? coll)
                (reify Iterator
                    #_foreign
                    (#_"boolean" hasNext [#_"Iterator" _self]
                        false
                    )

                    #_foreign
                    (#_"Object" next [#_"Iterator" _self]
                        (throw (NoSuchElementException.))
                    )
                )
            (instance? Map coll)
                (.iterator (.entrySet (cast Map coll)))
            (instance? String coll)
                (let [#_"String" s (cast String coll) #_"int'" vi (volatile! 0)]
                    (reify Iterator
                        #_foreign
                        (#_"boolean" hasNext [#_"Iterator" _self]
                            (< @vi (.length s))
                        )

                        #_foreign
                        (#_"Object" next [#_"Iterator" _self]
                            (let [_ (.charAt s, @vi)]
                                (vswap! vi inc)
                                _
                            )
                        )
                    )
                )
            (.isArray (.getClass coll))
                (ArrayIter'createFromObject coll)
            :else
                (RT'iter (RT'seq coll))
        )
    )

    (defn #_"Object" RT'seqOrElse [#_"Object" o]
        (when (some? (RT'seq o))
            o
        )
    )

    (defn #_"ISeq" RT'keys [#_"Object" coll]
        (if (instance? IPersistentMap coll)
            (KeySeq'createFromMap (cast IPersistentMap coll))
            (KeySeq'create (RT'seq coll))
        )
    )

    (defn #_"ISeq" RT'vals [#_"Object" coll]
        (if (instance? IPersistentMap coll)
            (ValSeq'createFromMap (cast IPersistentMap coll))
            (ValSeq'create (RT'seq coll))
        )
    )

    (defn #_"IPersistentMap" RT'meta [#_"Object" x]
        (when (instance? IMeta x)
            (.meta (cast IMeta x))
        )
    )

    (defn #_"int" RT'count [#_"Object" o]
        (cond
            (instance? Counted o)
                (.count (cast Counted o))
            (nil? o)
                0
            (instance? IPersistentCollection o)
                (loop-when [#_"int" i 0 #_"ISeq" s (RT'seq o)] (some? s) => i
                    (when (instance? Counted s) => (recur (inc i) (.next s))
                        (+ i (.count s))
                    )
                )
            (instance? CharSequence o)
                (.length (cast CharSequence o))
            (instance? Collection o)
                (.size (cast Collection o))
            (instance? Map o)
                (.size (cast Map o))
            (instance? Map$Entry o)
                2
            (.isArray (.getClass o))
                (Array/getLength o)
            :else
                (throw (UnsupportedOperationException. (str "count not supported on this type: " (.getSimpleName (.getClass o)))))
        )
    )

    (defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" coll, #_"Object" x]
        (if (some? coll) (.cons coll, x) (PersistentList'new-1 x))
    )

    (defn #_"ISeq" RT'cons [#_"Object" x, #_"Object" coll]
        (cond
            (nil? coll)           (PersistentList'new-1 x)
            (instance? ISeq coll) (Cons'new-2 x, (cast ISeq coll))
            :else                 (Cons'new-2 x, (RT'seq coll))
        )
    )

    (defn #_"Object" RT'first [#_"Object" x]
        (if (instance? ISeq x)
            (.first (cast ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (when (some? s)
                    (.first s)
                )
            )
        )
    )

    (defn #_"Object" RT'second [#_"Object" x]
        (RT'first (RT'next x))
    )

    (defn #_"Object" RT'third [#_"Object" x]
        (RT'first (RT'next (RT'next x)))
    )

    (defn #_"Object" RT'fourth [#_"Object" x]
        (RT'first (RT'next (RT'next (RT'next x))))
    )

    (defn #_"ISeq" RT'next [#_"Object" x]
        (if (instance? ISeq x)
            (.next (cast ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (when (some? s)
                    (.next s)
                )
            )
        )
    )

    (defn #_"ISeq" RT'more [#_"Object" x]
        (if (instance? ISeq x)
            (.more (cast ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (if (some? s) (.more s) PersistentList'EMPTY)
            )
        )
    )

    (defn #_"Object" RT'peek [#_"Object" x]
        (when (some? x)
            (.peek (cast IPersistentStack x))
        )
    )

    (defn #_"Object" RT'pop [#_"Object" x]
        (when (some? x)
            (.pop (cast IPersistentStack x))
        )
    )

    (defn #_"Object" RT'get-2 [#_"Object" coll, #_"Object" key]
        (if (instance? ILookup coll)
            (.valAt (cast ILookup coll), key)
            (RT'getFrom-2 coll, key)
        )
    )

    (defn #_"Object" RT'getFrom-2 [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                nil
            (instance? Map coll)
                (.get (cast Map coll), key)
            (instance? IPersistentSet coll)
                (.get (cast IPersistentSet coll), key)
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let-when [#_"int" n (.intValue (cast Number key))] (< -1 n (RT'count coll))
                    (RT'nth-2 coll, n)
                )
            (instance? ITransientSet coll)
                (.get (cast ITransientSet coll), key)
        )
    )

    (defn #_"Object" RT'get-3 [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (if (instance? ILookup coll)
            (.valAt (cast ILookup coll), key, notFound)
            (RT'getFrom-3 coll, key, notFound)
        )
    )

    (defn #_"Object" RT'getFrom-3 [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (cond
            (nil? coll)
                notFound
            (instance? Map coll)
                (let [#_"Map" m (cast Map coll)]
                    (if (.containsKey m, key) (.get m, key) notFound)
                )
            (instance? IPersistentSet coll)
                (let [#_"IPersistentSet" s (cast IPersistentSet coll)]
                    (if (.contains s, key) (.get s, key) notFound)
                )
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (if (< -1 n (RT'count coll)) (RT'nth-2 coll, n) notFound)
                )
            (instance? ITransientSet coll)
                (let [#_"ITransientSet" s (cast ITransientSet coll)]
                    (if (.contains s, key) (.get s, key) notFound)
                )
            :else
                notFound
        )
    )

    (defn #_"Associative" RT'assoc [#_"Object" coll, #_"Object" key, #_"Object" val]
        (if (some? coll)
            (.assoc (cast Associative coll), key, val)
            (PersistentArrayMap'new-1 (object-array [ key, val ]))
        )
    )

    (defn #_"Object" RT'contains [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                RT'F
            (instance? Associative coll)
                (if (.containsKey (cast Associative coll), key) RT'T RT'F)
            (instance? IPersistentSet coll)
                (if (.contains (cast IPersistentSet coll), key) RT'T RT'F)
            (instance? Map coll)
                (if (.containsKey (cast Map coll), key) RT'T RT'F)
            (instance? Set coll)
                (if (.contains (cast Set coll), key) RT'T RT'F)
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (if (< -1 n (RT'count coll)) RT'T RT'F)
                )
            (instance? ITransientSet coll)
                (if (.contains (cast ITransientSet coll), key) RT'T RT'F)
            (instance? ITransientAssociative2 coll)
                (if (.containsKey (cast ITransientAssociative2 coll), key) RT'T RT'F)
            :else
                (throw (IllegalArgumentException. (str "contains? not supported on type: " (.getName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'find [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                nil
            (instance? Associative coll)
                (.entryAt (cast Associative coll), key)
            (instance? Map coll)
                (let-when [#_"Map" m (cast Map coll)] (.containsKey m, key)
                    (MapEntry'create key, (.get m, key))
                )
            (instance? ITransientAssociative2 coll)
                (.entryAt (cast ITransientAssociative2 coll), key)
            :else
                (throw (IllegalArgumentException. (str "find not supported on type: " (.getName (.getClass coll)))))
        )
    )

    ;; takes a seq of key, val, key, val
    ;; returns tail starting at val of matching key if found, else nil

    (defn #_"ISeq" RT'findKey [#_"Keyword" key, #_"ISeq" keyvals]
        (loop-when keyvals (some? keyvals)
            (let-when [#_"ISeq" r (.next keyvals)] (some? r) => (throw (RuntimeException. "Malformed keyword argslist"))
                (when-not (= (.first keyvals) key) => r
                    (recur (.next r))
                )
            )
        )
    )

    (defn #_"Object" RT'dissoc [#_"Object" coll, #_"Object" key]
        (when (some? coll)
            (.without (cast IPersistentMap coll), key)
        )
    )

    (defn #_"Object" RT'nth-2 [#_"Object" coll, #_"int" n]
        (cond
            (instance? Indexed coll)
                (.nth (cast Indexed coll), n)
            (nil? coll)
                nil
            (instance? CharSequence coll)
                (Character/valueOf (.charAt (cast CharSequence coll), n))
            (.isArray (.getClass coll))
                (Reflector'prepRet (.getComponentType (.getClass coll)), (Array/get coll, n))
            (instance? Matcher coll)
                (.group (cast Matcher coll), n)
            (instance? Map$Entry coll)
                (let [#_"Map$Entry" e (cast Map$Entry coll)]
                    (case n 0 (.getKey e) 1 (.getValue e) (throw (IndexOutOfBoundsException.)))
                )
            (instance? Sequential coll)
                (loop-when [#_"int" i 0 #_"ISeq" s (RT'seq coll)] (and (<= i n) (some? s)) => (throw (IndexOutOfBoundsException.))
                    (recur-if (< i n) [(inc i) (.next s)] => (.first s))
                )
            :else
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'nth-3 [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (cond
            (instance? Indexed coll)
                (.nth (cast Indexed coll), n, notFound)
            (nil? coll)
                notFound
            (neg? n)
                notFound
            (instance? CharSequence coll)
                (let [#_"CharSequence" s (cast CharSequence coll)]
                    (if (< n (.length s)) (Character/valueOf (.charAt s, n)) notFound)
                )
            (.isArray (.getClass coll))
                (when (< n (Array/getLength coll)) => notFound
                    (Reflector'prepRet (.getComponentType (.getClass coll)), (Array/get coll, n))
                )
            (instance? Matcher coll)
                (let-when [#_"Matcher" m (cast Matcher coll)] (< n (.groupCount m)) => notFound
                    (.group m, n)
                )
            (instance? Map$Entry coll)
                (let [#_"Map$Entry" e (cast Map$Entry coll)]
                    (case n 0 (.getKey e) 1 (.getValue e) notFound)
                )
            (instance? Sequential coll)
                (loop-when [#_"int" i 0 #_"ISeq" s (RT'seq coll)] (and (<= i n) (some? s)) => notFound
                    (recur-if (< i n) [(inc i) (.next s)] => (.first s))
                )
            :else
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'assocN [#_"int" n, #_"Object" val, #_"Object" coll]
        (cond
            (nil? coll)
                nil
            (instance? IPersistentVector coll)
                (.assocN (cast IPersistentVector coll), n, val)
            (instance? RT'OBJECTS_CLASS coll)
                ;; hmm... this is not persistent
                (let [#_"Object[]" array (cast RT'OBJECTS_CLASS coll)]
                    (aset array n val)
                    array
                )
        )
    )

    (defn #_"boolean" RT'hasTag [#_"Object" o, #_"Object" tag]
        (Util'equals tag, (RT'get-2 (RT'meta o), RT'TAG_KEY))
    )

    (defn #_"Object"    RT'box-1o [#_"Object"  x] x)
    (defn #_"Character" RT'box-1c [#_"char"    x] (Character/valueOf x))
    (defn #_"Object"    RT'box-1z [#_"boolean" x] (if x RT'T RT'F))
    (defn #_"Object"    RT'box-1Z [#_"Boolean" x] x)
    (defn #_"Number"    RT'box-1b [#_"byte"    x] x)
    (defn #_"Number"    RT'box-1s [#_"short"   x] x)
    (defn #_"Number"    RT'box-1i [#_"int"     x] x)
    (defn #_"Number"    RT'box-1l [#_"long"    x] x)
    (defn #_"Number"    RT'box-1f [#_"float"   x] x)
    (defn #_"Number"    RT'box-1d [#_"double"  x] x)

    (defn #_"char" RT'charCast-1o [#_"Object" x]
        (if (instance? Character x)
            (.charValue (cast Character x))
            (let [#_"long" n (.longValue (cast Number x))]
                (when (<= Character/MIN_VALUE n Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                    (char n)
                )
            )
        )
    )

    (defn #_"char" RT'charCast-1b [#_"byte" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1s [#_"short" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1c [#_"char" x]
        x
    )

    (defn #_"char" RT'charCast-1i [#_"int" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1l [#_"long" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1f [#_"float" x]
        (when (<= Character/MIN_VALUE x Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
            (char x)
        )
    )

    (defn #_"char" RT'charCast-1d [#_"double" x]
        (when (<= Character/MIN_VALUE x Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
            (char x)
        )
    )

    (defn #_"boolean" RT'booleanCast-1o [#_"Object" x]
        (if (instance? Boolean x) (.booleanValue (cast Boolean x)) (some? x))
    )

    (defn #_"boolean" RT'booleanCast-1b [#_"boolean" x]
        x
    )

    (defn #_"byte" RT'byteCast-1o [#_"Object" x]
        (if (instance? Byte x)
            (.byteValue (cast Byte x))
            (let [#_"long" n (RT'longCast-1o x)]
                (when (<= Byte/MIN_VALUE n Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                    (byte n)
                )
            )
        )
    )

    (defn #_"byte" RT'byteCast-1b [#_"byte" x]
        x
    )

    (defn #_"byte" RT'byteCast-1s [#_"short" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1i [#_"int" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1l [#_"long" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1f [#_"float" x]
        (when (<= Byte/MIN_VALUE x Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
            (byte x)
        )
    )

    (defn #_"byte" RT'byteCast-1d [#_"double" x]
        (when (<= Byte/MIN_VALUE x Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
            (byte x)
        )
    )

    (defn #_"short" RT'shortCast-1o [#_"Object" x]
        (if (instance? Short x)
            (.shortValue (cast Short x))
            (let [#_"long" n (RT'longCast-1o x)]
                (when (<= Short/MIN_VALUE n Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                    (short n)
                )
            )
        )
    )

    (defn #_"short" RT'shortCast-1b [#_"byte"  x] x)
    (defn #_"short" RT'shortCast-1s [#_"short" x] x)

    (defn #_"short" RT'shortCast-1i [#_"int" x]
        (let [#_"short" i (short x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                i
            )
        )
    )

    (defn #_"short" RT'shortCast-1l [#_"long" x]
        (let [#_"short" i (short x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                i
            )
        )
    )

    (defn #_"short" RT'shortCast-1f [#_"float" x]
        (when (<= Short/MIN_VALUE x Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
            (short x)
        )
    )

    (defn #_"short" RT'shortCast-1d [#_"double" x]
        (when (<= Short/MIN_VALUE x Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
            (short x)
        )
    )

    (defn #_"int" RT'intCast-1o [#_"Object" x]
        (cond
            (instance? Integer x) (.intValue (cast Integer x))
            (instance? Number x)  (RT'intCast-1l (RT'longCast-1o x))
            :else                 (.charValue (cast Character x))
        )
    )

    (defn #_"int" RT'intCast-1b [#_"byte"  x] x)
    (defn #_"int" RT'intCast-1s [#_"short" x] x)
    (defn #_"int" RT'intCast-1c [#_"char"  x] x)
    (defn #_"int" RT'intCast-1i [#_"int"   x] x)

    (defn #_"int" RT'intCast-1l [#_"long" x]
        (let [#_"int" i (int x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
                i
            )
        )
    )

    (defn #_"int" RT'intCast-1f [#_"float" x]
        (when (<= Integer/MIN_VALUE x Integer/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
            (int x)
        )
    )

    (defn #_"int" RT'intCast-1d [#_"double" x]
        (when (<= Integer/MIN_VALUE x Integer/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
            (int x)
        )
    )

    (defn #_"long" RT'longCast-1o [#_"Object" x]
        (cond
            (or (instance? Integer x) (instance? Long x))
                (.longValue (cast Number x))
            (instance? BigInt x)
                (let [#_"BigInt" bi (cast BigInt x)]
                    (when (nil? (:bipart bi)) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
                        (:lpart bi)
                    )
                )
            (instance? BigInteger x)
                (let [#_"BigInteger" bi (cast BigInteger x)]
                    (when (< (.bitLength bi) 64) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
                        (.longValue bi)
                    )
                )
            (or (instance? Byte x) (instance? Short x))
                (.longValue (cast Number x))
            (instance? Ratio x)
                (RT'longCast-1o (Ratio''bigIntegerValue (cast Ratio x)))
            (instance? Character x)
                (RT'longCast-1l (.charValue (cast Character x)))
            :else
                (RT'longCast-1d (.doubleValue (cast Number x)))
        )
    )

    (defn #_"long" RT'longCast-1b [#_"byte"  x] x)
    (defn #_"long" RT'longCast-1s [#_"short" x] x)
    (defn #_"long" RT'longCast-1i [#_"int"   x] x)
    (defn #_"long" RT'longCast-1l [#_"long"  x] x)

    (defn #_"long" RT'longCast-1f [#_"float" x]
        (when (<= Long/MIN_VALUE x Long/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
            (long x)
        )
    )

    (defn #_"long" RT'longCast-1d [#_"double" x]
        (when (<= Long/MIN_VALUE x Long/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
            (long x)
        )
    )

    (defn #_"float" RT'floatCast-1o [#_"Object" x]
        (if (instance? Float x)
            (.floatValue (cast Float x))
            (let [#_"double" n (.doubleValue (cast Number x))]
                (when (<= (- Float/MAX_VALUE) n Float/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for float: " x)))
                    (float n)
                )
            )
        )
    )

    (defn #_"float" RT'floatCast-1b [#_"byte"  x] x)
    (defn #_"float" RT'floatCast-1s [#_"short" x] x)
    (defn #_"float" RT'floatCast-1i [#_"int"   x] x)
    (defn #_"float" RT'floatCast-1l [#_"long"  x] x)
    (defn #_"float" RT'floatCast-1f [#_"float" x] x)

    (defn #_"float" RT'floatCast-1d [#_"double" x]
        (when (<= (- Float/MAX_VALUE) x Float/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for float: " x)))
            (float x)
        )
    )

    (defn #_"double" RT'doubleCast-1o [#_"Object" x]
        (.doubleValue (cast Number x))
    )

    (defn #_"double" RT'doubleCast-1b [#_"byte"   x] x)
    (defn #_"double" RT'doubleCast-1s [#_"short"  x] x)
    (defn #_"double" RT'doubleCast-1i [#_"int"    x] x)
    (defn #_"double" RT'doubleCast-1l [#_"long"   x] x)
    (defn #_"double" RT'doubleCast-1f [#_"float"  x] x)
    (defn #_"double" RT'doubleCast-1d [#_"double" x] x)

    (defn #_"byte" RT'uncheckedByteCast-1o [#_"Object" x]
        (.byteValue (cast Number x))
    )

    (defn #_"byte" RT'uncheckedByteCast-1b [#_"byte"   x]       x )
    (defn #_"byte" RT'uncheckedByteCast-1s [#_"short"  x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1i [#_"int"    x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1l [#_"long"   x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1f [#_"float"  x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1d [#_"double" x] (byte x))

    (defn #_"short" RT'uncheckedShortCast-1o [#_"Object" x]
        (.shortValue (cast Number x))
    )

    (defn #_"short" RT'uncheckedShortCast-1b [#_"byte"   x]        x )
    (defn #_"short" RT'uncheckedShortCast-1s [#_"short"  x]        x )
    (defn #_"short" RT'uncheckedShortCast-1i [#_"int"    x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1l [#_"long"   x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1f [#_"float"  x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1d [#_"double" x] (short x))

    (defn #_"char" RT'uncheckedCharCast-1o [#_"Object" x]
        (if (instance? Character x) (.charValue (cast Character x)) (char (.longValue (cast Number x))))
    )

    (defn #_"char" RT'uncheckedCharCast-1b [#_"byte"   x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1s [#_"short"  x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1c [#_"char"   x]       x )
    (defn #_"char" RT'uncheckedCharCast-1i [#_"int"    x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1l [#_"long"   x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1f [#_"float"  x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1d [#_"double" x] (char x))

    (defn #_"int" RT'uncheckedIntCast-1o [#_"Object" x]
        (if (instance? Number x) (.intValue (cast Number x)) (.charValue (cast Character x)))
    )

    (defn #_"int" RT'uncheckedIntCast-1b [#_"byte"   x]      x )
    (defn #_"int" RT'uncheckedIntCast-1s [#_"short"  x]      x )
    (defn #_"int" RT'uncheckedIntCast-1c [#_"char"   x]      x )
    (defn #_"int" RT'uncheckedIntCast-1i [#_"int"    x]      x )
    (defn #_"int" RT'uncheckedIntCast-1l [#_"long"   x] (int x))
    (defn #_"int" RT'uncheckedIntCast-1f [#_"float"  x] (int x))
    (defn #_"int" RT'uncheckedIntCast-1d [#_"double" x] (int x))

    (defn #_"long" RT'uncheckedLongCast-1o [#_"Object" x]
        (.longValue (cast Number x))
    )

    (defn #_"long" RT'uncheckedLongCast-1b [#_"byte"   x]       x )
    (defn #_"long" RT'uncheckedLongCast-1s [#_"short"  x]       x )
    (defn #_"long" RT'uncheckedLongCast-1i [#_"int"    x]       x )
    (defn #_"long" RT'uncheckedLongCast-1l [#_"long"   x]       x )
    (defn #_"long" RT'uncheckedLongCast-1f [#_"float"  x] (long x))
    (defn #_"long" RT'uncheckedLongCast-1d [#_"double" x] (long x))

    (defn #_"float" RT'uncheckedFloatCast-1o [#_"Object" x]
        (.floatValue (cast Number x))
    )

    (defn #_"float" RT'uncheckedFloatCast-1b [#_"byte"   x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1s [#_"short"  x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1i [#_"int"    x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1l [#_"long"   x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1f [#_"float"  x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1d [#_"double" x] (float x))

    (defn #_"double" RT'uncheckedDoubleCast-1o [#_"Object" x]
        (.doubleValue (cast Number x))
    )

    (defn #_"double" RT'uncheckedDoubleCast-1b [#_"byte"   x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1s [#_"short"  x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1i [#_"int"    x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1l [#_"long"   x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1f [#_"float"  x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1d [#_"double" x] x)

    (defn #_"IPersistentMap" RT'map [& #_"Object..." init]
        (cond
            (nil? init)
                PersistentArrayMap'EMPTY
            (<= (alength init) PersistentArrayMap'HASHTABLE_THRESHOLD)
                (PersistentArrayMap'createWithCheck init)
            :else
                (PersistentHashMap'createWithCheck-1a init)
        )
    )

    (defn #_"IPersistentMap" RT'mapUniqueKeys [& #_"Object..." init]
        (cond
            (nil? init)
                PersistentArrayMap'EMPTY
            (<= (alength init) PersistentArrayMap'HASHTABLE_THRESHOLD)
                (PersistentArrayMap'new-1 init)
            :else
                (PersistentHashMap'create-1a init)
        )
    )

    (defn #_"IPersistentSet" RT'set [& #_"Object..." init]
        (PersistentHashSet'createWithCheck-1a init)
    )

    (defn #_"IPersistentVector" RT'vector [& #_"Object..." init]
        (LazilyPersistentVector'createOwning init)
    )

    (defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" v, #_"int" start, #_"int" end]
        (when (<= 0 start end (.count v)) => (throw (IndexOutOfBoundsException.))
            (if (= start end)
                PersistentVector'EMPTY
                (SubVector'new nil, v, start, end)
            )
        )
    )

    (defn #_"ISeq" RT'list-0 []
        nil
    )

    (defn #_"ISeq" RT'list-1 [#_"Object" arg1]
        (PersistentList'new-1 arg1)
    )

    (defn #_"ISeq" RT'list-2 [#_"Object" arg1, #_"Object" arg2]
        (RT'listStar-3 arg1, arg2, nil)
    )

    (defn #_"ISeq" RT'list-3 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (RT'listStar-4 arg1, arg2, arg3, nil)
    )

    (defn #_"ISeq" RT'list-4 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (RT'listStar-5 arg1, arg2, arg3, arg4, nil)
    )

    (defn #_"ISeq" RT'list-5 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (RT'listStar-6 arg1, arg2, arg3, arg4, arg5, nil)
    )

    (defn #_"ISeq" RT'listStar-2 [#_"Object" arg1, #_"ISeq" rest]
        (cast ISeq (RT'cons arg1, rest))
    )

    (defn #_"ISeq" RT'listStar-3 [#_"Object" arg1, #_"Object" arg2, #_"ISeq" rest]
        (cast ISeq (RT'cons arg1, (RT'cons arg2, rest)))
    )

    (defn #_"ISeq" RT'listStar-4 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"ISeq" rest]
        (cast ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, rest))))
    )

    (defn #_"ISeq" RT'listStar-5 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"ISeq" rest]
        (cast ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, (RT'cons arg4, rest)))))
    )

    (defn #_"ISeq" RT'listStar-6 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"ISeq" rest]
        (cast ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, (RT'cons arg4, (RT'cons arg5, rest))))))
    )

    (defn #_"ISeq" RT'arrayToList [#_"Object[]" a]
        (loop-when-recur [#_"ISeq" s nil #_"int" i (dec (alength a))] (<= 0 i) [(cast ISeq (RT'cons (aget a i), s)) (dec i)] => s)
    )

    (defn #_"Object[]" RT'object_array [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (make-array Object (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq) #_"int" size (RT'count s) #_"Object[]" a (make-array Object size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset a i (.first s))
                )
                a
            )
        )
    )

    (defn #_"Object[]" RT'toArray [#_"Object" coll]
        (cond
            (nil? coll)
                RT'EMPTY_ARRAY
            (instance? RT'OBJECTS_CLASS coll)
                (cast RT'OBJECTS_CLASS coll)
            (instance? Collection coll)
                (.toArray (cast Collection coll))
            (instance? Iterable coll)
                (let [#_"List" l (ArrayList.)]
                    (doseq [#_"Object" o (cast Iterable coll)]
                        (.add l, o)
                    )
                    (.toArray l)
                )
            (instance? Map coll)
                (.toArray (.entrySet (cast Map coll)))
            (instance? String coll)
                (let [#_"char[]" chars (.toCharArray (cast String coll))
                      #_"Object[]" a (make-array Object (alength chars))]
                    (dotimes [#_"int" i (alength chars)]
                        (aset a i (aget chars i))
                    )
                    a
                )
            (.isArray (.getClass coll))
                (let [#_"ISeq" s (RT'seq coll)
                      #_"Object[]" a (make-array Object (RT'count s))]
                    (loop-when-recur [#_"int" i 0 s s] (< i (alength a)) [(inc i) (.next s)]
                        (aset a i (.first s))
                    )
                    a
                )
            :else
                (throw (RuntimeException. (str "Unable to convert: " (.getClass coll) " to Object[]")))
        )
    )

    (defn #_"Object[]" RT'seqToArray [#_"ISeq" s]
        (let [#_"Object[]" a (make-array Object (RT'length s))]
            (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                (aset a i (.first s))
            )
            a
        )
    )

    (defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" s, #_"Object[]" passed]
        (let [#_"Object[]" a passed #_"int" n (RT'count s)
              a (if (< (alength a) n) (cast RT'OBJECTS_CLASS (Array/newInstance (.getComponentType (.getClass passed)), n)) a)]
            (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                (aset a i (.first s))
            )
            (when (< n (alength passed))
                (aset a n nil)
            )
            a
        )
    )

    (defn #_"Object" RT'seqToTypedArray-1 [#_"ISeq" s]
        (let [#_"Class" type (if (and (some? s) (some? (.first s))) (.getClass (.first s)) Object)]
            (RT'seqToTypedArray-2 type, s)
        )
    )

    (defn #_"Object" RT'seqToTypedArray-2 [#_"Class" type, #_"ISeq" s]
        (let [#_"Object" a (Array/newInstance type, (RT'length s))]
            (condp = type
                Integer/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'intCast-1o (.first s)))
                    )
                Byte/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'byteCast-1o (.first s)))
                    )
                Float/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'floatCast-1o (.first s)))
                    )
                Short/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'shortCast-1o (.first s)))
                    )
                Character/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'charCast-1o (.first s)))
                    )
                #_else
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (.first s))
                    )
            )
            a
        )
    )

    (defn #_"int" RT'length [#_"ISeq" s]
        (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)] => i)
    )

    (defn #_"int" RT'boundedLength [#_"ISeq" s, #_"int" limit]
        (loop-when-recur [#_"int" i 0 s s] (and (some? s) (<= i limit)) [(inc i) (.next s)] => i)
    )

    (defn #_"Character" RT'readRet [#_"int" ret]
        (when-not (= ret -1)
            (RT'box-1c (char ret))
        )
    )

    (defn #_"Character" RT'readChar [#_"Reader" r]
        (let [#_"int" ret (.read r)]
            (RT'readRet ret)
        )
    )

    (defn #_"Character" RT'peekChar [#_"Reader" r]
        (let [#_"int" ret
                (if (instance? PushbackReader r)
                    (let [ret (.read r) _ (.unread (cast PushbackReader r), ret)]
                        ret
                    )
                    (let [_ (.mark r, 1) ret (.read r) _ (.reset r)]
                        ret
                    )
                )]
            (RT'readRet ret)
        )
    )

    (defn #_"int" RT'getLineNumber [#_"Reader" r]
        (if (instance? LineNumberingPushbackReader r)
            (LineNumberingPushbackReader''getLineNumber (cast LineNumberingPushbackReader r))
            0
        )
    )

    (defn #_"int" RT'getColumnNumber [#_"Reader" r]
        (if (instance? LineNumberingPushbackReader r)
            (LineNumberingPushbackReader''getColumnNumber (cast LineNumberingPushbackReader r))
            0
        )
    )

    (defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" r]
        (if (RT'isLineNumberingReader r)
            (cast LineNumberingPushbackReader r)
            (LineNumberingPushbackReader'new-1 r)
        )
    )

    (defn #_"boolean" RT'isLineNumberingReader [#_"Reader" r] (instance? LineNumberingPushbackReader r))

    (defn #_"boolean" RT'isReduced [#_"Object" r] (instance? Reduced r))

    (defn #_"String" RT'printString [#_"Object" x]
        (let [#_"StringWriter" sw (StringWriter.)]
            (RT'print x, sw)
            (.toString sw)
        )
    )

    (defn #_"Object" RT'readString [#_"String" s]
        (let [#_"PushbackReader" r (PushbackReader. (java.io.StringReader. s))]
            (LispReader'read-1 r)
        )
    )

    (defn #_"void" RT'print [#_"Object" x, #_"Writer" w]
        (if (and (Var''isBound RT'PRINT_INITIALIZED) (RT'booleanCast-1o (.deref RT'PRINT_INITIALIZED)))
            (.invoke RT'PR_ON, x, w) ;; call multimethod
            (let [#_"boolean" readably (RT'booleanCast-1o (.deref RT'PRINT_READABLY))]
                (cond (nil? x)
                    (do
                        (.write w, "nil")
                    )
                    (or (instance? ISeq x) (instance? IPersistentList x))
                    (do
                        (.write w, \()
                        (RT'printInnerSeq (RT'seq x), w)
                        (.write w, \))
                    )
                    (instance? String x)
                        (let [#_"String" s (cast String x)]
                            (when readably => (.write w, s)
                                (.write w, \") ;; oops! "
                                (dotimes [#_"int" i (.length s)]
                                    (let [#_"char" c (.charAt s, i)]
                                        (case c
                                            \newline   (.write w, "\\n")
                                            \tab       (.write w, "\\t")
                                            \"         (.write w, "\\\"")
                                            \\         (.write w, "\\\\")
                                            \return    (.write w, "\\r")
                                            \formfeed  (.write w, "\\f")
                                            \backspace (.write w, "\\b")
                                                       (.write w, c)
                                        )
                                    )
                                )
                                (.write w, \") ;; oops! "
                            )
                        )
                    (instance? IPersistentMap x)
                    (do
                        (.write w, \{)
                        (loop-when-recur [#_"ISeq" s (RT'seq x)] (some? s) [(.next s)]
                            (let [#_"IMapEntry" e (cast IMapEntry (.first s))]
                                (RT'print (.key e), w)
                                (.write w, \space)
                                (RT'print (.val e), w)
                                (when (some? (.next s))
                                    (.write w, ", ")
                                )
                            )
                        )
                        (.write w, \})
                    )
                    (instance? IPersistentVector x)
                        (let [#_"IPersistentVector" a (cast IPersistentVector x)]
                            (.write w, \[)
                            (dotimes [#_"int" i (.count a)]
                                (RT'print (.nth a, i), w)
                                (when (< i (dec (.count a)))
                                    (.write w, \space)
                                )
                            )
                            (.write w, \])
                        )
                    (instance? IPersistentSet x)
                    (do
                        (.write w, "#{")
                        (loop-when-recur [#_"ISeq" s (RT'seq x)] (some? s) [(.next s)]
                            (RT'print (.first s), w)
                            (when (some? (.next s))
                                (.write w, \space)
                            )
                        )
                        (.write w, \})
                    )
                    (instance? Character x)
                        (let [#_"char" c (.charValue (cast Character x))]
                            (when readably => (.write w, c)
                                (.write w, \\)
                                (case c
                                    \newline   (.write w, "newline")
                                    \tab       (.write w, "tab")
                                    \space     (.write w, "space")
                                    \return    (.write w, "return")
                                    \formfeed  (.write w, "formfeed")
                                    \backspace (.write w, "backspace")
                                               (.write w, c)
                                )
                            )
                        )
                    (instance? Class x)
                    (do
                        (.write w, "#=")
                        (.write w, (.getName (cast Class x)))
                    )
                    (and (instance? BigDecimal x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, \M)
                    )
                    (and (instance? BigInt x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, \N)
                    )
                    (and (instance? BigInteger x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, "BIGINT")
                    )
                    (instance? Var x)
                        (let [#_"Var" v (cast Var x)]
                            (.write w, (str "#=(var " (:name (:ns v)) "/" (:sym v) ")"))
                        )
                    (instance? Pattern x)
                        (let [#_"Pattern" p (cast Pattern x)]
                            (.write w, (str "#\"" (.pattern p) "\""))
                        )
                    :else
                    (do
                        (.write w, (.toString x))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" RT'printInnerSeq [#_"ISeq" x, #_"Writer" w]
        (loop-when-recur [#_"ISeq" s x] (some? s) [(.next s)]
            (RT'print (.first s), w)
            (when (some? (.next s))
                (.write w, \space)
            )
        )
        nil
    )

    (defn #_"ClassLoader" RT'makeClassLoader []
        (cast ClassLoader
            (AccessController/doPrivileged
                (reify PrivilegedAction
                    #_foreign
                    (#_"Object" run [#_"PrivilegedAction" _self]
                        (DynamicClassLoader'new (RT'baseLoader))
                    )
                )
            )
        )
    )

    (defn #_"ClassLoader" RT'baseLoader []
        (if (Var''isBound Compiler'LOADER)
            (cast ClassLoader (.deref Compiler'LOADER))
            (.getContextClassLoader (Thread/currentThread))
        )
    )

    (defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (ClassLoader/getSystemResourceAsStream name)
            (.getResourceAsStream loader, name)
        )
    )

    (defn #_"URL" RT'getResource [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (ClassLoader/getSystemResource name)
            (.getResource loader, name)
        )
    )

    (defn #_"Class" RT'classForName-3 [#_"String" name, #_"boolean" load, #_"ClassLoader" loader]
        (let [#_"Class" c
                (when-not (instance? DynamicClassLoader loader)
                    (DynamicClassLoader'findInMemoryClass name)
                )]
            (or c (Class/forName name, load, loader))
        )
    )

    (defn #_"Class" RT'classForName-1 [#_"String" name]
        (RT'classForName-3 name, true, (RT'baseLoader))
    )

    (defn #_"Class" RT'classForNameNonLoading [#_"String" name]
        (RT'classForName-3 name, false, (RT'baseLoader))
    )

    (defn #_"Class" RT'loadClassForName [#_"String" name]
        (try
            (RT'classForNameNonLoading name)
            (RT'classForName-1 name)
            (catch ClassNotFoundException _
                nil
            )
        )
    )

    (defn #_"boolean" RT'aget_boolean [#_"boolean[]" a, #_"int" i] (aget a i))
    (defn #_"byte"    RT'aget_byte    [#_"byte[]"    a, #_"int" i] (aget a i))
    (defn #_"short"   RT'aget_short   [#_"short[]"   a, #_"int" i] (aget a i))
    (defn #_"char"    RT'aget_char    [#_"char[]"    a, #_"int" i] (aget a i))
    (defn #_"int"     RT'aget_int     [#_"int[]"     a, #_"int" i] (aget a i))
    (defn #_"long"    RT'aget_long    [#_"long[]"    a, #_"int" i] (aget a i))
    (defn #_"float"   RT'aget_float   [#_"float[]"   a, #_"int" i] (aget a i))
    (defn #_"double"  RT'aget_double  [#_"double[]"  a, #_"int" i] (aget a i))
    (defn #_"Object"  RT'aget_object  [#_"Object[]"  a, #_"int" i] (aget a i))

    (defn #_"boolean" RT'aset_boolean [#_"boolean[]" a, #_"int" i, #_"boolean" v] (aset a i v) v)
    (defn #_"byte"    RT'aset_byte    [#_"byte[]"    a, #_"int" i, #_"byte"    v] (aset a i v) v)
    (defn #_"short"   RT'aset_short   [#_"short[]"   a, #_"int" i, #_"short"   v] (aset a i v) v)
    (defn #_"char"    RT'aset_char    [#_"char[]"    a, #_"int" i, #_"char"    v] (aset a i v) v)
    (defn #_"int"     RT'aset_int     [#_"int[]"     a, #_"int" i, #_"int"     v] (aset a i v) v)
    (defn #_"long"    RT'aset_long    [#_"long[]"    a, #_"int" i, #_"long"    v] (aset a i v) v)
    (defn #_"float"   RT'aset_float   [#_"float[]"   a, #_"int" i, #_"float"   v] (aset a i v) v)
    (defn #_"double"  RT'aset_double  [#_"double[]"  a, #_"int" i, #_"double"  v] (aset a i v) v)
    (defn #_"Object"  RT'aset_object  [#_"Object[]"  a, #_"int" i, #_"Object"  v] (aset a i v) v)

    (defn #_"int" RT'alength_boolean [#_"boolean[]" a] (alength a))
    (defn #_"int" RT'alength_byte    [#_"byte[]"    a] (alength a))
    (defn #_"int" RT'alength_short   [#_"short[]"   a] (alength a))
    (defn #_"int" RT'alength_char    [#_"char[]"    a] (alength a))
    (defn #_"int" RT'alength_int     [#_"int[]"     a] (alength a))
    (defn #_"int" RT'alength_long    [#_"long[]"    a] (alength a))
    (defn #_"int" RT'alength_float   [#_"float[]"   a] (alength a))
    (defn #_"int" RT'alength_double  [#_"double[]"  a] (alength a))
    (defn #_"int" RT'alength_object  [#_"Object[]"  a] (alength a))

    (defn #_"boolean[]" RT'aclone_boolean [#_"boolean[]" a] (.clone a))
    (defn #_"byte[]"    RT'aclone_byte    [#_"byte[]"    a] (.clone a))
    (defn #_"short[]"   RT'aclone_short   [#_"short[]"   a] (.clone a))
    (defn #_"char[]"    RT'aclone_char    [#_"char[]"    a] (.clone a))
    (defn #_"int[]"     RT'aclone_int     [#_"int[]"     a] (.clone a))
    (defn #_"long[]"    RT'aclone_long    [#_"long[]"    a] (.clone a))
    (defn #_"float[]"   RT'aclone_float   [#_"float[]"   a] (.clone a))
    (defn #_"double[]"  RT'aclone_double  [#_"double[]"  a] (.clone a))
    (defn #_"Object[]"  RT'aclone_object  [#_"Object[]"  a] (.clone a))
)
)

(java-ns cloiure.lang.SeqIterator

(class-ns SeqIterator
    (def- #_"Object" SeqIterator'START (Object.))

    (defn #_"Iterator" SeqIterator'new [#_"Object" o]
        (let [#_"Object'" vs (volatile! SeqIterator'START) #_"Object'" vn (volatile! o)]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (some?
                        (condp identical? @vs
                            SeqIterator'START (do (vreset! vs nil) (vswap! vn RT'seq))
                            @vn (vswap! vn RT'next)
                            :else @vn
                        )
                    )
                )

                #_foreign
                (#_"Object" next [#_"Iterator" self]
                    (when (.hasNext self) => (throw (NoSuchElementException.))
                        (RT'first (vreset! vs @vn))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq
    (defn #_"StringSeq" StringSeq'create [#_"CharSequence" s]
        (when (pos? (.length s))
            (StringSeq'new nil, s, 0)
        )
    )

    (defn- #_"StringSeq" StringSeq'init []
        (hash-map
            #_"CharSequence" :s nil
            #_"int" :i 0
        )
    )

    (defn #_"StringSeq" StringSeq'new [#_"IPersistentMap" meta, #_"CharSequence" s, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (StringSeq'init))]
            (assoc this :s s :i i)
        )
    )

    #_override
    (defn #_"StringSeq" IObj'''withMeta--StringSeq [#_"StringSeq" this, #_"IPersistentMap" meta]
        (when-not (= meta (.meta this)) => this
            (StringSeq'new meta, (:s this), (:i this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--StringSeq [#_"StringSeq" this]
        (Character/valueOf (.charAt (:s this), (:i this)))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--StringSeq [#_"StringSeq" this]
        (when (< (inc (:i this)) (.length (:s this)))
            (StringSeq'new (:_meta this), (:s this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" IndexedSeq'''index--StringSeq [#_"StringSeq" this]
        (:i this)
    )

    #_override
    (defn #_"int" Counted'''count--StringSeq [#_"StringSeq" this]
        (- (.length (:s this)) (:i this))
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (defn #_"Symbol" Symbol'create-2 [#_"String" ns, #_"String" name]
        (Symbol'intern ns, name)
    )

    (defn #_"Symbol" Symbol'create-1 [#_"String" nsname]
        (Symbol'intern nsname)
    )

    (defn #_"Symbol" Symbol'intern
        ([#_"String" nsname]
            (let [#_"int" i (.indexOf nsname, \/)]
                (if (or (= i -1) (= nsname "/"))
                    (Symbol'new-2 nil, nsname)
                    (Symbol'new-2 (.substring nsname, 0, i), (.substring nsname, (inc i)))
                )
            )
        )
        ([#_"String" ns, #_"String" name]
            (Symbol'new-2 ns, name)
        )
    )

    (defn- #_"Symbol" Symbol'init []
        (hash-map
            #_"String" :ns nil
            #_"String" :name nil
            #_"int" :_hasheq 0
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Symbol" Symbol'new-2 [#_"String" ns_interned, #_"String" name_interned]
        (let [this (merge (AFn'new) (Symbol'init))]
            (assoc this :name name_interned :ns ns_interned :_meta nil)
        )
    )

    #_foreign
    (defn #_"String" toString---Symbol [#_"Symbol" this]
        (when (nil? (:_str this))
            (ร ass this (assoc this :_str (if (some? (:ns this)) (str (:ns this) "/" (:name this)) (:name this))))
        )
        (:_str this)
    )

    #_override
    (defn #_"String" Named'''getNamespace--Symbol [#_"Symbol" this]
        (:ns this)
    )

    #_override
    (defn #_"String" Named'''getName--Symbol [#_"Symbol" this]
        (:name this)
    )

    #_foreign
    (defn #_"boolean" equals---Symbol [#_"Symbol" this, #_"Object" o]
        (cond
            (= this o)
                true
            (instance? Symbol o)
                (let [#_"Symbol" symbol (cast Symbol o)]
                    (and (Util'equals (:ns this), (:ns symbol)) (.equals (:name this), (:name symbol)))
                )
            :else
                false
        )
    )

    #_foreign
    (defn #_"int" hashCode---Symbol [#_"Symbol" this]
        (Util'hashCombine (.hashCode (:name this)), (Util'hash (:ns this)))
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--Symbol [#_"Symbol" this]
        (when (zero? (:_hasheq this))
            (ร ass this (assoc this :_hasheq (Util'hashCombine (Murmur3'hashUnencodedChars (:name this)), (Util'hash (:ns this)))))
        )
        (:_hasheq this)
    )

    #_override
    (defn #_"Symbol" IObj'''withMeta--Symbol [#_"Symbol" this, #_"IPersistentMap" meta]
        (Symbol'new-3 meta, (:ns this), (:name this))
    )

    (defn- #_"Symbol" Symbol'new-3 [#_"IPersistentMap" meta, #_"String" ns, #_"String" name]
        (let [this (merge (AFn'new) (Symbol'init))]
            (assoc this :name name :ns ns :_meta meta)
        )
    )

    #_foreign
    (defn #_"int" compareTo---Symbol [#_"Symbol" this, #_"Object" o]
        (let [#_"Symbol" s (cast Symbol o)]
            (cond
                (.equals this, o)                       0
                (and (nil? (:ns this)) (some? (:ns s))) -1
                (nil? (:ns this))                       (.compareTo (:name this), (:name s))
                (nil? (:ns s))                          1
                :else
                    (let-when [#_"int" nsc (.compareTo (:ns this), (:ns s))] (zero? nsc) => nsc
                        (.compareTo (:name this), (:name s))
                    )
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Symbol [#_"Symbol" this, #_"Object" obj]
        (RT'get-2 obj, this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Symbol [#_"Symbol" this, #_"Object" obj, #_"Object" notFound]
        (RT'get-3 obj, this, notFound)
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--Symbol [#_"Symbol" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(class-ns MultiIterator
    (defn #_"Iterator" MultiIterator'new [#_"Iterator[]" iters]
        (reify Iterator
            #_foreign
            (#_"boolean" hasNext [#_"Iterator" _self]
                (loop-when [#_"int" i 0] (< i (alength iters)) => true
                    (and (.hasNext (aget iters i)) (recur (inc i)))
                )
            )

            #_foreign
            (#_"Object" next [#_"Iterator" _self]
                (let [#_"Object[]" a (make-array Object (alength iters))]
                    (dotimes [#_"int" i (alength iters)]
                        (aset a i (.next (aget iters i)))
                    )
                    (ArraySeq'new-2 a, 0)
                )
            )
        )
    )
)

(class-ns TransformerIterator
    (def- #_"Object" TransformerIterator'NONE (Object.))

    (defn- #_"Iterator" TransformerIterator'new [#_"IFn" xform, #_"Iterator" source, #_"boolean" multi?]
        #_volatile #_"buffer next completed"
        (let [#_"Queue" q (LinkedList.) #_"Object" vn (volatile! TransformerIterator'NONE) #_"boolean" vc (volatile! false)
              #_"IFn" xf
                (cast IFn (.invoke xform,
                    (fn #_"Object"
                        ([] nil)
                        ([#_"Object" r] r)
                        ([#_"Object" r, #_"Object" o] (.add q, o) r)
                    )
                ))]
            (reify Iterator
                #_foreign
                (#_"boolean" hasNext [#_"Iterator" _self]
                    (loop []
                        (cond
                            (not (identical? @vn TransformerIterator'NONE))
                                true
                            (not (.isEmpty q))
                                (do
                                    (vreset! vn (.remove q))
                                    (recur)
                                )
                            @vc
                                false
                            (.hasNext source)
                                (let [#_"Object" r
                                        (if multi?
                                            (.applyTo xf, (RT'cons nil, (.next source)))
                                            (.invoke xf, nil, (.next source))
                                        )]
                                    (when (RT'isReduced r)
                                        (.invoke xf, nil)
                                        (vreset! vc true)
                                    )
                                    (recur)
                                )
                            :else
                                (do
                                    (.invoke xf, nil)
                                    (vreset! vc true)
                                    (recur)
                                )
                        )
                    )
                )

                #_foreign
                (#_"Object" next [#_"Iterator" self]
                    (when (.hasNext self) => (throw (NoSuchElementException.))
                        (let [_ @vn]
                            (vreset! vn TransformerIterator'NONE)
                            _
                        )
                    )
                )
            )
        )
    )

    (defn #_"Iterator" TransformerIterator'create [#_"IFn" xform, #_"Iterator" source]
        (TransformerIterator'new xform, source, false)
    )

    (defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" xform, #_"List" sources]
        (let [#_"Iterator[]" iters (make-array Iterator (.size sources))]
            (dotimes [#_"int" i (.size sources)]
                (aset iters i (cast Iterator (.get sources, i)))
            )
            (TransformerIterator'new xform, (MultiIterator'new iters), true)
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(class-ns Tuple
    (def #_"int" Tuple'MAX_SIZE 6)

    (defn #_"IPersistentVector" Tuple'create
        ([] PersistentVector'EMPTY)
        ([#_"Object" v0] (RT'vector v0))
        ([#_"Object" v0, #_"Object" v1] (RT'vector v0, v1))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2] (RT'vector v0, v1, v2))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3] (RT'vector v0, v1, v2, v3))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4] (RT'vector v0, v1, v2, v3, v4))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4, #_"Object" v5] (RT'vector v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(class-ns Util
    (defn #_"boolean" Util'equiv-2oo [#_"Object" k1, #_"Object" k2]
        (cond
            (= k1 k2) true
            (nil? k1) false
            (and (instance? Number k1) (instance? Number k2)) (Numbers'equal (cast Number k1), (cast Number k2))
            (or (instance? IPersistentCollection k1) (instance? IPersistentCollection k2)) (Util'pcequiv k1, k2)
            :else (.equals k1, k2)
        )
    )

    (def #_"EquivPred" Util'equivNull
        (reify EquivPred
            #_override
            (#_"boolean" equiv [#_"EquivPred" _self, #_"Object" k1, #_"Object" k2]
                (nil? k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivEquals
        (reify EquivPred
            #_override
            (#_"boolean" equiv [#_"EquivPred" _self, #_"Object" k1, #_"Object" k2]
                (.equals k1, k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivNumber
        (reify EquivPred
            #_override
            (#_"boolean" equiv [#_"EquivPred" _self, #_"Object" k1, #_"Object" k2]
                (and (instance? Number k2) (Numbers'equal (cast Number k1), (cast Number k2)))
            )
        )
    )

    (def #_"EquivPred" Util'equivColl
        (reify EquivPred
            #_override
            (#_"boolean" equiv [#_"EquivPred" _self, #_"Object" k1, #_"Object" k2]
                (if (or (instance? IPersistentCollection k1) (instance? IPersistentCollection k2)) (Util'pcequiv k1, k2) (.equals k1, k2))
            )
        )
    )

    (defn #_"EquivPred" Util'equivPred [#_"Object" k1]
        (cond
            (nil? k1)                                         Util'equivNull
            (instance? Number k1)                             Util'equivNumber
            (or (instance? String k1) (instance? Symbol k1))  Util'equivEquals
            (or (instance? Collection k1) (instance? Map k1)) Util'equivColl
            :else                                             Util'equivEquals
        )
    )

    (defn #_"boolean" Util'equiv-2ll [#_"long" k1, #_"long" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2ol [#_"Object" k1, #_"long" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2lo [#_"long" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2dd [#_"double" k1, #_"double" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2od [#_"Object" k1, #_"double" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2do [#_"double" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2bb [#_"boolean" k1, #_"boolean" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2ob [#_"Object" k1, #_"boolean" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2bo [#_"boolean" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2cc [#_"char" c1, #_"char" c2]
        (= c1 c2)
    )

    (defn #_"boolean" Util'pcequiv [#_"Object" k1, #_"Object" k2]
        (if (instance? IPersistentCollection k1)
            (.equiv (cast IPersistentCollection k1), k2)
            (.equiv (cast IPersistentCollection k2), k1)
        )
    )

    (defn #_"boolean" Util'equals [#_"Object" k1, #_"Object" k2]
        (or (= k1 k2) (and (some? k1) (.equals k1, k2)))
    )

    (defn #_"boolean" Util'identical [#_"Object" k1, #_"Object" k2]
        (= k1 k2)
    )

    (defn #_"Class" Util'classOf [#_"Object" x]
        (when (some? x)
            (.getClass x)
        )
    )

    (defn #_"int" Util'compare [#_"Object" k1, #_"Object" k2]
        (cond
            (= k1 k2)             0
            (nil? k1)             -1
            (nil? k2)             1
            (instance? Number k1) (Numbers'compare (cast Number k1), (cast Number k2))
            :else                 (.compareTo (cast Comparable k1), k2)
        )
    )

    (defn #_"int" Util'hash [#_"Object" o]
        (cond
            (nil? o) 0
            :else    (.hashCode o)
        )
    )

    (defn #_"int" Util'hasheq [#_"Object" o]
        (cond
            (nil? o)              0
            (instance? IHashEq o) (.hasheq (cast IHashEq o))
            (instance? Number o)  (Numbers'hasheq (cast Number o))
            (instance? String o)  (Murmur3'hashInt (.hashCode o))
            :else                 (.hashCode o)
        )
    )

    (defn #_"int" Util'hashCombine [#_"int" seed, #_"int" hash]
        ;; a la boost
        (bit-xor seed (+ hash 0x9e3779b9 (<< seed 6) (>> seed 2)))
    )

    (defn #_"boolean" Util'isPrimitive [#_"Class" c]
        (and (some? c) (.isPrimitive c) (not (= c Void/TYPE)))
    )

    (defn #_"boolean" Util'isInteger [#_"Object" x]
        (or (instance? Integer x) (instance? Long x) (instance? BigInt x) (instance? BigInteger x))
    )

    (defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" rq, #_"ConcurrentHashMap<K, Reference<V>>" cache]
        ;; cleanup any dead entries
        (when (some? (.poll rq))
            (while (some? (.poll rq))
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" e (.entrySet cache)]
                (let-when [#_"Reference<V>" r (.getValue e)] (and (some? r) (nil? (.get r)))
                    (.remove cache, (.getKey e), r)
                )
            )
        )
        nil
    )
)
)

(java-ns cloiure.lang.Var

(class-ns TBox
    (defn- #_"TBox" TBox'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_"Thread" :thread nil
        )
    )

    (defn #_"TBox" TBox'new [#_"Thread" t, #_"Object" val]
        (let [this (TBox'init)]
            (assoc this :thread t :val val)
        )
    )
)

(class-ns Unbound
    (defn- #_"Unbound" Unbound'init []
        (hash-map
            #_"Var" :v nil
        )
    )

    (defn #_"Unbound" Unbound'new [#_"Var" v]
        (let [this (merge (AFn'new) (Unbound'init))]
            (assoc this :v v)
        )
    )

    #_foreign
    (defn #_"String" toString---Unbound [#_"Unbound" this]
        (str "Unbound: " (:v this))
    )

    #_override
    (defn #_"Object" AFn'''throwArity--Unbound [#_"Unbound" this, #_"int" n]
        (throw (IllegalStateException. (str "Attempting to call unbound fn: " (:v this))))
    )
)

(class-ns Frame
    (ยง def #_"Frame" Frame'TOP (Frame'new PersistentHashMap'EMPTY, nil))

    (defn- #_"Frame" Frame'init []
        (hash-map
            ;; Var->TBox
            #_"Associative" :bindings nil
            ;; Var->val
            #_"Frame" :prev nil
        )
    )

    (defn #_"Frame" Frame'new [#_"Associative" bindings, #_"Frame" prev]
        (let [this (Frame'init)]
            (assoc this :bindings bindings :prev prev)
        )
    )
)

(class-ns Var
    (def #_"ThreadLocal<Frame>" Var'dvals
        (proxy [ThreadLocal #_"<Frame>"] []
            #_foreign
            (#_"Frame" initialValue [#_"ThreadLocal<Frame>" #_this]
                Frame'TOP
            )
        )
    )

    #_volatile
    (def #_"int" Var'rev 0)

    (ยง def #_"Keyword" Var'privateKey (Keyword'intern (Symbol'intern nil, "private")))
    (ยง def #_"IPersistentMap" Var'privateMeta (PersistentArrayMap'new-1 (object-array [ Var'privateKey, Boolean/TRUE ])))
    (ยง def #_"Keyword" Var'macroKey (Keyword'intern (Symbol'intern nil, "macro")))
    (ยง def #_"Keyword" Var'nameKey (Keyword'intern (Symbol'intern nil, "name")))
    (ยง def #_"Keyword" Var'nsKey (Keyword'intern (Symbol'intern nil, "ns")))

    (defn #_"Object" Var'getThreadBindingFrame []
        (.get Var'dvals)
    )

    (defn #_"void" Var'resetThreadBindingFrame [#_"Object" frame]
        (.set Var'dvals, (cast Frame frame))
        nil
    )

    (defn #_"Var" Var'intern
        ([#_"Namespace" ns, #_"Symbol" sym]
            (Namespace''intern ns, sym)
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
            (Var'intern ns, sym, root, true)
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root, #_"boolean" replaceRoot]
            (let [#_"Var" v (Namespace''intern ns, sym)]
                (when (or (not (Var''hasRoot v)) replaceRoot)
                    (Var''bindRoot v, root)
                )
                v
            )
        )
    )

    (defn #_"Var" Var'internPrivate [#_"String" nsName, #_"String" sym]
        (let [#_"Namespace" ns (Namespace'findOrCreate (Symbol'intern nsName)) #_"Var" v (Var'intern ns, (Symbol'intern sym))]
            (Var''setMeta v, Var'privateMeta)
            v
        )
    )

    (defn #_"Var" Var'find [#_"Symbol" nsQualifiedSym]
        (when (some? (:ns nsQualifiedSym)) => (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
            (let [#_"Namespace" ns (Namespace'find (Symbol'intern (:ns nsQualifiedSym)))]
                (when (some? ns) => (throw (IllegalArgumentException. (str "No such namespace: " (:ns nsQualifiedSym))))
                    (Namespace''findInternedVar ns, (Symbol'intern (:name nsQualifiedSym)))
                )
            )
        )
    )

    (defn #_"Var" Var'create
        ([               ] (Var'new nil, nil      ))
        ([#_"Object" root] (Var'new nil, nil, root))
    )

    (defn- #_"Var" Var'init []
        (hash-map
            #_"Namespace" :ns nil
            #_"Symbol" :sym nil
            #_volatile
            #_"Object" :root nil
            #_volatile
            #_"boolean" :dynamic false
            #_transient
            #_"AtomicBoolean" :threadBound nil
        )
    )

    (defn #_"Var" Var'new
        ([#_"Namespace" ns, #_"Symbol" sym]
            (let [this (merge (ARef'new-0) (Var'init))
                  this (assoc this :ns ns :sym sym :threadBound (AtomicBoolean. false))
                  this (assoc this :root (Unbound'new this))]
                (Var''setMeta this, PersistentHashMap'EMPTY)
                this
            )
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
            (let [this (-> (Var'new ns, sym) (assoc :root root))]
                (ร ass Var'rev (inc Var'rev))
                this
            )
        )
    )

    #_method
    (defn #_"Var" Var''setDynamic-1 [#_"Var" this]
        (assoc this :dynamic true)
    )

    #_method
    (defn #_"Var" Var''setDynamic-2 [#_"Var" this, #_"boolean" b]
        (assoc this :dynamic b)
    )

    #_method
    (defn #_"boolean" Var''isDynamic [#_"Var" this]
        (:dynamic this)
    )

    #_foreign
    (defn #_"String" toString---Var [#_"Var" this]
        (if (some? (:ns this))
            (str "#'" (:name (:ns this)) "/" (:sym this))
            (str "#<Var: " (or (:sym this) "--unnamed--") ">")
        )
    )

    #_method
    (defn #_"boolean" Var''isBound [#_"Var" this]
        (or (Var''hasRoot this) (and (.get (:threadBound this)) (.containsKey (:bindings (.get Var'dvals)), this)))
    )

    #_method
    (defn #_"Object" Var''get [#_"Var" this]
        (if (.get (:threadBound this)) (.deref this) (:root this))
    )

    #_override
    (defn #_"Object" IDeref'''deref--Var [#_"Var" this]
        (let [#_"TBox" b (Var''getThreadBinding this)]
            (if (some? b) (:val b) (:root this))
        )
    )

    #_override
    (defn #_"void" IRef'''setValidator--Var [#_"Var" this, #_"IFn" vf]
        (when (Var''hasRoot this)
            (ARef''validate-3 this, vf, (:root this))
        )
        (ร ass this (assoc this :validator vf))
        nil
    )

    #_method
    (defn #_"Object" Var''alter [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (Var''set this, (.applyTo fn, (RT'cons (.deref this), args)))
        this
    )

    #_method
    (defn #_"Object" Var''set [#_"Var" this, #_"Object" val]
        (ARef''validate-3 this, (.getValidator this), val)
        (let [#_"TBox" b (Var''getThreadBinding this)]
            (when (some? b) => (throw (IllegalStateException. (str "Can't change/establish root binding of: " (:sym this) " with set")))
                (when (= (Thread/currentThread) (:thread b)) => (throw (IllegalStateException. (str "Can't set!: " (:sym this) " from non-binding thread")))
                    (ร ass b (assoc b :val val))
                    val
                )
            )
        )
    )

    #_override
    (defn #_"Object" Settable'''doSet--Var [#_"Var" this, #_"Object" val]
        (Var''set this, val)
    )

    #_override
    (defn #_"Object" Settable'''doReset--Var [#_"Var" this, #_"Object" val]
        (Var''bindRoot this, val)
        val
    )

    #_method
    (defn #_"void" Var''setMeta [#_"Var" this, #_"IPersistentMap" m]
        ;; ensure these basis keys
        (.resetMeta this, (-> m (.assoc Var'nameKey, (:sym this)) (.assoc Var'nsKey, (:ns this))))
        nil
    )

    #_method
    (defn #_"void" Var''setMacro [#_"Var" this]
        (.alterMeta this, RT'assoc, (RT'list-2 Var'macroKey, RT'T))
        nil
    )

    #_method
    (defn #_"boolean" Var''isMacro [#_"Var" this]
        (RT'booleanCast-1o (.valAt (.meta this), Var'macroKey))
    )

    #_method
    (defn #_"boolean" Var''isPublic [#_"Var" this]
        (not (RT'booleanCast-1o (.valAt (.meta this), Var'privateKey)))
    )

    #_method
    (defn #_"Object" Var''getRawRoot [#_"Var" this]
        (:root this)
    )

    #_method
    (defn #_"Object" Var''getTag [#_"Var" this]
        (.valAt (.meta this), RT'TAG_KEY)
    )

    #_method
    (defn #_"void" Var''setTag [#_"Var" this, #_"Symbol" tag]
        (.alterMeta this, RT'assoc, (RT'list-2 RT'TAG_KEY, tag))
        nil
    )

    #_method
    (defn #_"boolean" Var''hasRoot [#_"Var" this]
        (not (instance? Unbound (:root this)))
    )

    ;; binding root always clears macro flag
    #_method
    (defn #_"void" Var''bindRoot [#_"Var" this, #_"Object" root]
        (ยง sync this
            (ARef''validate-3 this, (.getValidator this), root)
            (let [#_"Object" oldroot (:root this)]
                (ร ass this (assoc this :root root))
                (ร ass Var'rev (inc Var'rev))
                (.alterMeta this, RT'dissoc, (RT'list-1 Var'macroKey))
                (ARef''notifyWatches this, oldroot, (:root this))
            )
        )
        nil
    )

    #_method
    (defn #_"void" Var''swapRoot [#_"Var" this, #_"Object" root]
        (ยง sync this
            (ARef''validate-3 this, (.getValidator this), root)
            (let [#_"Object" oldroot (:root this)]
                (ร ass this (assoc this :root root))
                (ร ass Var'rev (inc Var'rev))
                (ARef''notifyWatches this, oldroot, root)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Var''unbindRoot [#_"Var" this]
        (ยง sync this
            (ร ass this (assoc this :root (Unbound'new this)))
            (ร ass Var'rev (inc Var'rev))
        )
        nil
    )

    #_method
    (defn #_"void" Var''commuteRoot [#_"Var" this, #_"IFn" fn]
        (ยง sync this
            (let [#_"Object" newRoot (.invoke fn, (:root this))]
                (ARef''validate-3 this, (.getValidator this), newRoot)
                (let [#_"Object" oldroot (:root this)]
                    (ร ass this (assoc this :root newRoot))
                    (ร ass Var'rev (inc Var'rev))
                    (ARef''notifyWatches this, oldroot, newRoot)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"Object" Var''alterRoot [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (ยง sync this
            (let [#_"Object" newRoot (.applyTo fn, (RT'cons (:root this), args))]
                (ARef''validate-3 this, (.getValidator this), newRoot)
                (let [#_"Object" oldroot (:root this)]
                    (ร ass this (assoc this :root newRoot))
                    (ร ass Var'rev (inc Var'rev))
                    (ARef''notifyWatches this, oldroot, newRoot)
                    newRoot
                )
            )
        )
    )

    (defn #_"void" Var'pushThreadBindings [#_"Associative" bindings]
        (let [#_"Frame" f (.get Var'dvals)]
            (loop-when [#_"Associative" m (:bindings f) #_"ISeq" s (.seq bindings)] (some? s) => (.set Var'dvals, (Frame'new m, f))
                (let [#_"IMapEntry" e (cast IMapEntry (.first s)) #_"Var" v (cast Var (.key e))]
                    (when-not (:dynamic v)
                        (throw (IllegalStateException. (str "Can't dynamically bind non-dynamic var: " (:ns v) "/" (:sym v))))
                    )
                    (ARef''validate-3 v, (.getValidator v), (.val e))
                    (.set (:threadBound v), true)
                    (recur (.assoc m, v, (TBox'new (Thread/currentThread), (.val e))) (.next s))
                )
            )
        )
        nil
    )

    (defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" f (:prev (.get Var'dvals))]
            (cond
                (nil? f)        (throw (IllegalStateException. "Pop without matching push"))
                (= f Frame'TOP) (.remove Var'dvals)
                :else           (.set Var'dvals, f)
            )
        )
        nil
    )

    (defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" f (.get Var'dvals)]
            (loop-when [#_"IPersistentMap" m PersistentHashMap'EMPTY #_"ISeq" s (.seq (:bindings f))] (some? s) => m
                (let [#_"IMapEntry" e (cast IMapEntry (.first s)) #_"Var" v (cast Var (.key e)) #_"TBox" b (cast TBox (.val e))]
                    (recur (.assoc m, v, (:val b)) (.next s))
                )
            )
        )
    )

    #_method
    (defn #_"TBox" Var''getThreadBinding [#_"Var" this]
        (when (.get (:threadBound this))
            (when-let [#_"IMapEntry" e (.entryAt (:bindings (.get Var'dvals)), this)]
                (cast TBox (.val e))
            )
        )
    )

    #_method
    (defn #_"IFn" Var''fn [#_"Var" this]
        (cast IFn (.deref this))
    )

    #_foreign
    (defn #_"Object" call---Var [#_"Var" this]
        (.invoke this)
    )

    #_foreign
    (defn #_"void" run---Var [#_"Var" this]
        (.invoke this)
        nil
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--Var [#_"Var" this]
        (.invoke (Var''fn this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Var [#_"Var" this, #_"Object" arg1]
        (.invoke (Var''fn this), arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2]
        (.invoke (Var''fn this), arg1, arg2
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.invoke (Var''fn this), arg1, arg2, arg3
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.invoke (Var''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20,
            (cast RT'OBJECTS_CLASS args)
        )
    )

    #_override
    (defn #_"Object" IFn'''applyTo--Var [#_"Var" this, #_"ISeq" args]
        (.applyTo (Var''fn this), args)
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile
    (defn- #_"Volatile" Volatile'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"Volatile" Volatile'new [#_"Object" val]
        (let [this (Volatile'init)]
            (assoc this :val val)
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Volatile [#_"Volatile" this]
        (:val this)
    )

    #_method
    (defn #_"Object" Volatile''reset [#_"Volatile" this, #_"Object" newval]
        (ร ass this (assoc this :val newval))
        newval
    )
)
)

(java-ns cloiure.main

(class-ns main
    (ยง def- #_"Symbol" main'CLOIURE_MAIN (Symbol'intern "cloiure.main"))
    (ยง def- #_"Var" main'REQUIRE (RT'var "cloiure.core", "require"))
    (ยง def- #_"Var" main'MAIN (RT'var "cloiure.main", "main"))

    (defn #_"void" -main [#_"String[]" args]
        (.invoke main'REQUIRE, main'CLOIURE_MAIN)
        (.applyTo main'MAIN, (RT'seq args))
        nil
    )
)
)
