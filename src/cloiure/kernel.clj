(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

#_abstract
(class-ns AFn (§ implements IFn)
    (§ method Object call()
        (ß invoke())
    )

    (§ method void run()
        (ß invoke())
        nil
    )

    (§ method Object invoke()
        (ß throwArity(0))
    )

    (§ method Object invoke(Object arg1)
        (ß throwArity(1))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß throwArity(2))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß throwArity(3))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß throwArity(4))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß throwArity(5))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß throwArity(6))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß throwArity(7))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß throwArity(8))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß throwArity(9))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß throwArity(10))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß throwArity(11))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß throwArity(12))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß throwArity(13))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß throwArity(14))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß throwArity(15))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß throwArity(16))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß throwArity(17))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß throwArity(18))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß throwArity(19))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß throwArity(20))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß throwArity(21))
    )

    (§ method Object applyTo(ISeq arglist)
        (ß applyToHelper(this, Util.ret1(arglist, arglist = nil)))
    )

    (§ defn Object applyToHelper(IFn ifn, ISeq arglist)
        (§ switch (ß RT.boundedLength(arglist, 20))
            (§ case 0)
            (do
                (ß arglist = nil)
                (ß ifn.invoke())
            )
            (§ case 1)
            (do
                (ß ifn.invoke(Util.ret1(arglist.first(), arglist = nil)))
            )
            (§ case 2)
            (do
                (ß ifn.invoke(arglist.first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 3)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 4)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 5)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 6)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 7)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 8)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 9)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 10)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 11)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 12)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 13)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 14)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 15)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 16)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 17)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 18)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 19)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 20)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ default )
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        RT.seqToArray(Util.ret1(arglist.next(), arglist = nil))))
            )
        )
    )

    (§ method Object throwArity(int n)
        (§ let String name = getClass().getSimpleName())
        (§ throw new ArityException(n, Compiler.demunge(name)))
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    #_volatile
    (§ field MethodImplCache __methodImplCache)

    (§ method IPersistentMap meta()
        nil
    )

    (§ method IObj withMeta(IPersistentMap meta)
        (ß new RestFn()
            (§ reify
                #_protected
                (§ method Object doInvoke(Object args)
                    (ß AFunction.this.applyTo((ISeq) args))
                )

                (§ method IPersistentMap meta()
                    meta
                )

                (§ method IObj withMeta(IPersistentMap meta)
                    (ß AFunction.this.withMeta(meta))
                )

                (§ method int getRequiredArity()
                    0
                )
            )
        )
    )

    (§ method int compare(Object o1, Object o2)
        (§ let Object o = invoke(o1, o2))

        (§ if (ß o instanceof Boolean)
            (§ if (ß RT.booleanCast(o))
                (§ return -1)
            )
            (§ return (ß RT.booleanCast(invoke(o2, o1)) ? 1 :or 0))
        )

        (§ let Number n = (Number) o)
        (ß n.intValue())
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Agent (§ extends ARef)
    (class-ns ActionQueue
        (§ field IPersistentStack q)
        (§ field Throwable error) ;; non-null indicates fail state
        (§ def ActionQueue EMPTY = new ActionQueue(PersistentQueue.EMPTY, nil))

        (§ constructor ActionQueue(IPersistentStack q, Throwable error)
            (ß this.q = q)
            (ß this.error = error)
            this
        )
    )

    (§ def Keyword CONTINUE = Keyword.intern(nil, "continue"))
    (§ def Keyword FAIL = Keyword.intern(nil, "fail"))

    #_volatile
    (§ field Object state)
    (§ field AtomicReference<ActionQueue> aq = new AtomicReference<ActionQueue>(ActionQueue.EMPTY))

    #_volatile
    (§ field Keyword errorMode = CONTINUE)
    #_volatile
    (§ field IFn errorHandler = nil)

    (§ def- AtomicLong sendThreadPoolCounter = new AtomicLong(0))

    (§ def- AtomicLong sendOffThreadPoolCounter = new AtomicLong(0))

    #_volatile
    (§ def ExecutorService pooledExecutor = Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter)))

    #_volatile
    (§ def ExecutorService soloExecutor = Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter)))

    (§ def ThreadLocal<IPersistentVector> nested = new ThreadLocal<IPersistentVector>())

    (§ defn- ThreadFactory createThreadFactory(String format, AtomicLong threadPoolCounter)
        (ß new ThreadFactory()
            (§ reify
                (§ method Thread newThread(Runnable runnable)
                    (§ let Thread thread = new Thread(runnable))
                    (ß thread.setName(String.format(format, threadPoolCounter.getAndIncrement())))
                    thread
                )
            )
        )
    )

    (§ defn void shutdown()
        (ß soloExecutor.shutdown())
        (ß pooledExecutor.shutdown())
        nil
    )

    (class-ns Action (§ implements Runnable)
        (§ field Agent agent)
        (§ field IFn fn)
        (§ field ISeq args)
        (§ field Executor exec)

        (§ constructor Action(Agent agent, IFn fn, ISeq args, Executor exec)
            (ß this.agent = agent)
            (ß this.args = args)
            (ß this.fn = fn)
            (ß this.exec = exec)
            this
        )

        (§ method void execute()
            (§ try 
                (ß exec.execute(this))
            )
            (§ catch (ß Throwable error)
                (§ if (ß agent.errorHandler != nil)
                    (§ try 
                        (ß agent.errorHandler.invoke(agent, error))
                    )
                    (§ catch (ß Throwable e) ;; ignore errorHandler errors
                    )
                )
            )
            nil
        )

        (§ defn void doRun(Action action)
            (§ try 
                (ß nested.set(PersistentVector.EMPTY))

                (§ let Throwable error = nil)
                (§ try 
                    (§ let Object oldval = action.agent.state)
                    (§ let Object newval =  action.fn.applyTo(RT.cons(action.agent.state, action.args)))
                    (ß action.agent.setState(newval))
                    (ß action.agent.notifyWatches(oldval, newval))
                )
                (§ catch (ß Throwable e)
                    (ß error = e)
                )

                (§ if (ß error == nil)
                    (ß releasePendingSends())
                )
                (§ else 
                    (ß nested.set(nil)) ;; allow errorHandler to send
                    (§ if (ß action.agent.errorHandler != nil)
                        (§ try 
                            (ß action.agent.errorHandler.invoke(action.agent, error))
                        )
                        (§ catch (ß Throwable e) ;; ignore errorHandler errors
                        )
                    )
                    (§ if (ß action.agent.errorMode == CONTINUE)
                        (ß error = nil)
                    )
                )

                (§ let boolean popped = false)
                (§ let ActionQueue next = nil)
                (§ while (ß !popped)
                    (§ let ActionQueue prior = action.agent.aq.get())
                    (ß next = new ActionQueue(prior.q.pop(), error))
                    (ß popped = action.agent.aq.compareAndSet(prior, next))
                )

                (§ if (ß error == nil && next.q.count() > 0)
                    (ß ((Action) next.q.peek()).execute())
                )
            )
            (§ finally 
                (ß nested.set(nil))
            )
            nil
        )

        (§ method void run()
            (ß doRun(this))
            nil
        )
    )

    (§ constructor Agent(Object state)
        (§ this(state, nil))
        this
    )

    (§ constructor Agent(Object state, IPersistentMap meta)
        (§ super(meta))
        (ß setState(state))
        this
    )

    (§ method boolean setState(Object newState)
        (ß validate(newState))
        (§ let boolean ret = (state != newState))
        (ß state = newState)
        ret
    )

    (§ method Object deref()
        state
    )

    (§ method Throwable getError()
        (ß aq.get().error)
    )

    (§ method void setErrorMode(Keyword k)
        (ß errorMode = k)
        nil
    )

    (§ method Keyword getErrorMode()
        errorMode
    )

    (§ method void setErrorHandler(IFn f)
        (ß errorHandler = f)
        nil
    )

    (§ method IFn getErrorHandler()
        errorHandler
    )

    (§ method Object restart(Object newState, boolean clearActions)
        (§ sync (ß this)
            (§ if (ß getError() == nil)
                (§ throw Util.runtimeException("Agent does not need a restart"))
            )
            (ß validate(newState))
            (ß state = newState)

            (§ if (ß clearActions)
                (ß aq.set(ActionQueue.EMPTY))
            )
            (§ else 
                (§ let boolean restarted = false)
                (§ let ActionQueue prior = nil)
                (§ while (ß !restarted)
                    (ß prior = aq.get())
                    (ß restarted = aq.compareAndSet(prior, new ActionQueue(prior.q, nil)))
                )

                (§ if (ß prior.q.count() > 0)
                    (ß ((Action) prior.q.peek()).execute())
                )
            )

            newState
        )
    )

    (§ method Object dispatch(IFn fn, ISeq args, Executor exec)
        (§ let Throwable error = getError())
        (§ if (ß error != nil)
            (§ throw Util.runtimeException("Agent is failed, needs restart", error))
        )
        (§ let Action action = new Action(this, fn, args, exec))
        (ß dispatchAction(action))

        this
    )

    (§ defn void dispatchAction(Action action)
        (§ let LockingTransaction trans = LockingTransaction.getRunning())
        (§ if (ß trans != nil)
            (ß trans.enqueue(action))
        )
        (§ elseif (ß nested.get() != nil)
            (ß nested.set(nested.get().cons(action)))
        )
        (§ else 
            (ß action.agent.enqueue(action))
        )
        nil
    )

    (§ method void enqueue(Action action)
        (§ let boolean queued = false)
        (§ let ActionQueue prior = nil)
        (§ while (ß !queued)
            (ß prior = aq.get())
            (ß queued = aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error)))
        )

        (§ if (ß prior.q.count() == 0 && prior.error == nil)
            (ß action.execute())
        )
        nil
    )

    (§ method int getQueueCount()
        (ß aq.get().q.count())
    )

    (§ defn int releasePendingSends()
        (§ let IPersistentVector sends = nested.get())
        (§ if (ß sends == nil)
            (§ return 0)
        )
        (§ loop-when-recur [(ß int i = 0)] (ß i < sends.count()) [(ß i++)]
            (§ let Action a = (Action) sends.valAt(i))
            (ß a.agent.enqueue(a))
        )
        (ß nested.set(PersistentVector.EMPTY))
        (ß sends.count())
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    (§ method Object nth(int i)
        (§ if (ß i == 0)
            (ß key())
        )
        (§ elseif (ß i == 1)
            (ß val())
        )
        (§ else 
            (§ throw new IndexOutOfBoundsException())
        )
    )

    (§ method- IPersistentVector asVector()
        (ß LazilyPersistentVector.createOwning(key(), val()))
    )

    (§ method IPersistentVector assocN(int i, Object val)
        (ß asVector().assocN(i, val))
    )

    (§ method int count()
        2
    )

    (§ method ISeq seq()
        (ß asVector().seq())
    )

    (§ method IPersistentVector cons(Object o)
        (ß asVector().cons(o))
    )

    (§ method IPersistentCollection empty()
        nil
    )

    (§ method IPersistentStack pop()
        (ß LazilyPersistentVector.createOwning(key()))
    )

    (§ method Object setValue(Object value)
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method IPersistentCollection cons(Object o)
        (§ if (ß o instanceof Map.Entry)
            (§ let Map.Entry e = (Map.Entry) o)

            (§ return (ß assoc(e.getKey(), e.getValue())))
        )
        (§ elseif (ß o instanceof IPersistentVector)
            (§ let IPersistentVector v = (IPersistentVector) o)
            (§ if (ß v.count() != 2)
                (§ throw new IllegalArgumentException("Vector arg to map conj must be a pair"))
            )
            (§ return (ß assoc(v.nth(0), v.nth(1))))
        )

        (§ let IPersistentMap ret = this)
        (§ loop-when-recur [(ß ISeq es = RT.seq(o))] (ß es != nil) [(ß es = es.next())]
            (§ let Map.Entry e = (Map.Entry) es.first())
            (ß ret = ret.assoc(e.getKey(), e.getValue()))
        )
        ret
    )

    (§ method boolean equals(Object obj)
        (ß mapEquals(this, obj))
    )

    (§ defn boolean mapEquals(IPersistentMap m1, Object obj)
        (§ if (ß m1 == obj)
            (§ return true)
        )
        (§ if (ß !(obj instanceof Map))
            (§ return false)
        )
        (§ let Map m = (Map) obj)

        (§ if (ß m.size() != m1.count())
            (§ return false)
        )

        (§ loop-when-recur [(ß ISeq s = m1.seq())] (ß s != nil) [(ß s = s.next())]
            (§ let Map.Entry e = (Map.Entry) s.first())
            (§ let boolean found = m.containsKey(e.getKey()))

            (§ if (ß !found || !Util.equals(e.getValue(), m.get(e.getKey())))
                (§ return false)
            )
        )

        true
    )

    (§ method boolean equiv(Object obj)
        (§ if (ß !(obj instanceof Map))
            (§ return false)
        )
        (§ if (ß obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
            (§ return false)
        )

        (§ let Map m = (Map) obj)

        (§ if (ß m.size() != size())
            (§ return false)
        )

        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (§ let Map.Entry e = (Map.Entry) s.first())
            (§ let boolean found = m.containsKey(e.getKey()))

            (§ if (ß !found || !Util.equiv(e.getValue(), m.get(e.getKey())))
                (§ return false)
            )
        )

        true
    )

    (§ method int hashCode()
        (§ let int cached = this._hash)
        (§ if (ß cached == 0)
            (ß this._hash = cached = mapHash(this))
        )
        cached
    )

    (§ defn int mapHash(IPersistentMap m)
        (§ let int hash = 0)
        (§ loop-when-recur [(ß ISeq s = m.seq())] (ß s != nil) [(ß s = s.next())]
            (§ let Map.Entry e = (Map.Entry) s.first())
            (ß hash += ((e.getKey() == nil) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == nil) ? 0 :or e.getValue().hashCode()))
        )
        hash
    )

    (§ method int hasheq()
        (§ let int cached = this._hasheq)
        (§ if (ß cached == 0)
            (ß this._hasheq = cached = Murmur3.hashUnordered(this))
        )
        cached
    )

    (§ defn int mapHasheq(IPersistentMap m)
        (ß Murmur3.hashUnordered(m))
    )

    (class-ns KeySeq (§ extends ASeq)
        (§ field ISeq seq)
        (§ field Iterable iterable)

        (§ defn KeySeq create(ISeq seq)
            (§ if (ß seq == nil)
                (§ return nil)
            )
            (ß new KeySeq(seq, nil))
        )

        (§ defn KeySeq createFromMap(IPersistentMap map)
            (§ if (ß map == nil)
                (§ return nil)
            )
            (§ let ISeq seq = map.seq())
            (§ if (ß seq == nil)
                (§ return nil)
            )
            (ß new KeySeq(seq, map))
        )

        (§ constructor- KeySeq(ISeq seq, Iterable iterable)
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ constructor- KeySeq(IPersistentMap meta, ISeq seq, Iterable iterable)
            (§ super(meta))
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ method Object first()
            (ß ((Map.Entry) seq.first()).getKey())
        )

        (§ method ISeq next()
            (ß create(seq.next()))
        )

        (§ method KeySeq withMeta(IPersistentMap meta)
            (ß new KeySeq(meta, seq, iterable))
        )

        (§ method Iterator iterator()
            (§ if (ß iterable == nil)
                (§ return (ß super.iterator()))
            )

            (§ if (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).keyIterator()))
            )

            (§ let Iterator mapIter = iterable.iterator())
            (ß new Iterator()
                (§ reify
                    (§ method boolean hasNext()
                        (ß mapIter.hasNext())
                    )

                    (§ method Object next()
                        (ß ((Map.Entry)mapIter.next()).getKey())
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )
    )

    (class-ns ValSeq (§ extends ASeq)
        (§ field ISeq seq)
        (§ field Iterable iterable)

        (§ defn ValSeq create(ISeq seq)
            (§ if (ß seq == nil)
                (§ return nil)
            )
            (ß new ValSeq(seq, nil))
        )

        (§ defn ValSeq createFromMap(IPersistentMap map)
            (§ if (ß map == nil)
                (§ return nil)
            )
            (§ let ISeq seq = map.seq())
            (§ if (ß seq == nil)
                (§ return nil)
            )
            (ß new ValSeq(seq, map))
        )

        (§ constructor- ValSeq(ISeq seq, Iterable iterable)
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ constructor- ValSeq(IPersistentMap meta, ISeq seq, Iterable iterable)
            (§ super(meta))
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ method Object first()
            (ß ((Map.Entry) seq.first()).getValue())
        )

        (§ method ISeq next()
            (ß create(seq.next()))
        )

        (§ method ValSeq withMeta(IPersistentMap meta)
            (ß new ValSeq(meta, seq, iterable))
        )

        (§ method Iterator iterator()
            (§ if (ß iterable == nil)
                (§ return (ß super.iterator()))
            )

            (§ if (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).valIterator()))
            )

            (§ let Iterator mapIter = iterable.iterator())
            (ß new Iterator()
                (§ reify
                    (§ method boolean hasNext()
                        (ß mapIter.hasNext())
                    )

                    (§ method Object next()
                        (ß ((Map.Entry)mapIter.next()).getValue())
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )
    )

    (§ def IFn MAKE_ENTRY = new AFn()
        (§ reify
            (§ method Object invoke(Object key, Object val)
                (ß MapEntry.create(key, val))
            )
        )
    )

    (§ def IFn MAKE_KEY = new AFn()
        (§ reify
            (§ method Object invoke(Object key, Object val)
                key
            )
        )
    )

    (§ def IFn MAKE_VAL = new AFn()
        (§ reify
            (§ method Object invoke(Object key, Object val)
                val
            )
        )
    )

    (§ method Object invoke(Object arg1)
        (ß valAt(arg1))
    )

    (§ method Object invoke(Object arg1, Object notFound)
        (ß valAt(arg1, notFound))
    )

    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean containsValue(Object value)
        (ß values().contains(value))
    )

    (§ method Set entrySet()
        (ß new AbstractSet()
            (§ reify
                (§ method Iterator iterator()
                    (ß APersistentMap.this.iterator())
                )

                (§ method int size()
                    (ß count())
                )

                (§ method int hashCode()
                    (ß APersistentMap.this.hashCode())
                )

                (§ method boolean contains(Object o)
                    (§ if (ß o instanceof Entry)
                        (§ let Entry e = (Entry) o)
                        (§ let Entry found = entryAt(e.getKey()))
                        (§ if (ß found != nil && Util.equals(found.getValue(), e.getValue()))
                            (§ return true)
                        )
                    )
                    false
                )
            )
        )
    )

    (§ method Object get(Object key)
        (ß valAt(key))
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method Set keySet()
        (ß new AbstractSet()
            (§ reify
                (§ method Iterator iterator()
                    (§ let Iterator mi = APersistentMap.this.iterator())

                    (ß new Iterator()
                        (§ reify
                            (§ method boolean hasNext()
                                (ß mi.hasNext())
                            )

                            (§ method Object next()
                                (§ let Entry e = (Entry) mi.next())
                                (ß e.getKey())
                            )

                            (§ method void remove()
                                (§ throw new UnsupportedOperationException())
                            )
                        )
                    )
                )

                (§ method int size()
                    (ß count())
                )

                (§ method boolean contains(Object o)
                    (ß APersistentMap.this.containsKey(o))
                )
            )
        )
    )

    (§ method Object put(Object key, Object value)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void putAll(Map t)
        (§ throw new UnsupportedOperationException())
    )

    (§ method Object remove(Object key)
        (§ throw new UnsupportedOperationException())
    )

    (§ method int size()
        (ß count())
    )

    (§ method Collection values()
        (ß new AbstractCollection()
            (§ reify
                (§ method Iterator iterator()
                    (§ let Iterator mi = APersistentMap.this.iterator())

                    (ß new Iterator()
                        (§ reify
                            (§ method boolean hasNext()
                                (ß mi.hasNext())
                            )

                            (§ method Object next()
                                (§ let Entry e = (Entry) mi.next())
                                (ß e.getValue())
                            )

                            (§ method void remove()
                                (§ throw new UnsupportedOperationException())
                            )
                        )
                    )
                )

                (§ method int size()
                    (ß count())
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)
    (§ field IPersistentMap impl)

    #_protected
    (§ constructor APersistentSet(IPersistentMap impl)
        (ß this.impl = impl)
        this
    )

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method boolean contains(Object key)
        (ß impl.containsKey(key))
    )

    (§ method Object get(Object key)
        (ß impl.valAt(key))
    )

    (§ method int count()
        (ß impl.count())
    )

    (§ method ISeq seq()
        (ß RT.keys(impl))
    )

    (§ method Object invoke(Object arg1)
        (ß get(arg1))
    )

    (§ method boolean equals(Object obj)
        (ß setEquals(this, obj))
    )

    (§ defn boolean setEquals(IPersistentSet s1, Object obj)
        (§ if (ß s1 == obj)
            (§ return true)
        )
        (§ if (ß !(obj instanceof Set))
            (§ return false)
        )
        (§ let Set m = (Set) obj)

        (§ if (ß m.size() != s1.count())
            (§ return false)
        )

        (§ doseq [#_"Object" aM m]
            (§ if (ß !s1.contains(aM))
                (§ return false)
            )
        )

        true
    )

    (§ method boolean equiv(Object obj)
        (§ if (ß !(obj instanceof Set))
            (§ return false)
        )

        (§ let Set m = (Set) obj)

        (§ if (ß m.size() != size())
            (§ return false)
        )

        (§ doseq [#_"Object" aM m]
            (§ if (ß !contains(aM))
                (§ return false)
            )
        )

        true
    )

    (§ method int hashCode()
        (§ let int hash = this._hash)
        (§ if (ß hash == 0)
            (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (§ let Object e = s.first())
                (ß hash +=  Util.hash(e))
            )
            (ß this._hash = hash)
        )
        hash
    )

    (§ method int hasheq()
        (§ let int cached = this._hasheq)
        (§ if (ß cached == 0)
            (ß this._hasheq = cached = Murmur3.hashUnordered(this))
        )
        cached
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean containsAll(Collection c)
        (§ doseq [#_"Object" o c]
            (§ if (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method Iterator iterator()
        (§ if (ß impl instanceof IMapIterable)
            (ß ((IMapIterable)impl).keyIterator())
        )
        (§ else 
            (ß new Iterator()
                (§ reify
                    (§ field- Iterator iter = impl.iterator())

                    (§ method boolean hasNext()
                        (ß iter.hasNext())
                    )

                    (§ method Object next()
                        (ß ((IMapEntry)iter.next()).key())
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method ISeq seq()
        (§ if (ß count() > 0)
            (§ return (ß new Seq(this, 0)))
        )
        nil
    )

    (§ method ISeq rseq()
        (§ if (ß count() > 0)
            (§ return (ß new RSeq(this, count() - 1)))
        )
        nil
    )

    (§ defn boolean doEquals(IPersistentVector v, Object obj)
        (§ if (ß obj instanceof IPersistentVector)
            (§ let IPersistentVector ov = (IPersistentVector) obj)
            (§ if (ß ov.count() != v.count())
                (§ return false)
            )
            (§ loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++)]
                (§ if (ß !Util.equals(v.nth(i), ov.nth(i)))
                    (§ return false)
                )
            )
            (§ return true)
        )
        (§ elseif (ß obj instanceof List)
            (§ let Collection ma = (Collection) obj)
            (§ if (ß ma.size() != v.count() || ma.hashCode() != v.hashCode())
                (§ return false)
            )
            (§ loop-when-recur [(ß Iterator i1 = ((List) v).iterator(), i2 = ma.iterator())] (ß i1.hasNext()) [(ß )]
                (§ if (ß !Util.equals(i1.next(), i2.next()))
                    (§ return false)
                )
            )
            (§ return true)
        )
        (§ else 
            (§ if (ß !(obj instanceof Sequential))
                (§ return false)
            )
            (§ let ISeq ms = RT.seq(obj))
            (§ loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++, ms = ms.next())]
                (§ if (ß ms == nil || !Util.equals(v.nth(i), ms.first()))
                    (§ return false)
                )
            )
            (§ if (ß ms != nil)
                (§ return false)
            )
        )

        true
    )

    (§ defn boolean doEquiv(IPersistentVector v, Object obj)
        (§ if (ß obj instanceof IPersistentVector)
            (§ let IPersistentVector ov = (IPersistentVector) obj)
            (§ if (ß ov.count() != v.count())
                (§ return false)
            )
            (§ loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++)]
                (§ if (ß !Util.equiv(v.nth(i), ov.nth(i)))
                    (§ return false)
                )
            )
            (§ return true)
        )
        (§ elseif (ß obj instanceof List)
            (§ let Collection ma = (Collection) obj)
            (§ if (ß ma.size() != v.count())
                (§ return false)
            )
            (§ loop-when-recur [(ß Iterator i1 = ((List) v).iterator(), i2 = ma.iterator())] (ß i1.hasNext()) [(ß )]
                (§ if (ß !Util.equiv(i1.next(), i2.next()))
                    (§ return false)
                )
            )
            (§ return true)
        )
        (§ else 
            (§ if (ß !(obj instanceof Sequential))
                (§ return false)
            )
            (§ let ISeq ms = RT.seq(obj))
            (§ loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++, ms = ms.next())]
                (§ if (ß ms == nil || !Util.equiv(v.nth(i), ms.first()))
                    (§ return false)
                )
            )
            (§ if (ß ms != nil)
                (§ return false)
            )
        )

        true
    )

    (§ method boolean equals(Object obj)
        (§ if (ß obj == this)
            (§ return true)
        )
        (ß doEquals(this, obj))
    )

    (§ method boolean equiv(Object obj)
        (§ if (ß obj == this)
            (§ return true)
        )
        (ß doEquiv(this, obj))
    )

    (§ method int hashCode()
        (§ let int hash = this._hash)
        (§ if (ß hash == 0)
            (ß hash = 1)
            (§ loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                (§ let Object obj = nth(i))
                (ß hash = 31 * hash + ((obj == nil) ? 0 :or obj.hashCode()))
            )
            (ß this._hash = hash)
        )
        hash
    )

    (§ method int hasheq()
        (§ let int hash = this._hasheq)
        (§ if (ß hash == 0)
            (§ let int n)
            (ß hash = 1)

            (§ loop-when-recur [(ß n = 0)] (ß n < count()) [(ß ++n)]
                (ß hash = 31 * hash + Util.hasheq(nth(n)))
            )

            (ß this._hasheq = hash = Murmur3.mixCollHash(hash, n))
        )
        hash
    )

    (§ method Object get(int index)
        (ß nth(index))
    )

    (§ method Object nth(int i, Object notFound)
        (§ if (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    (§ method Object remove(int i)
        (§ throw new UnsupportedOperationException())
    )

    (§ method int indexOf(Object o)
        (§ loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
            (§ if (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    (§ method int lastIndexOf(Object o)
        (§ loop-when-recur [(ß int i = count() - 1)] (ß i >= 0) [(ß i--)]
            (§ if (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    (§ method ListIterator listIterator()
        (ß listIterator(0))
    )

    (§ method ListIterator listIterator(int index)
        (ß new ListIterator()
            (§ reify
                (§ let int nexti = index)

                (§ method boolean hasNext()
                    (ß (nexti < count()))
                )

                (§ method Object next()
                    (§ if (ß nexti < count())
                        (ß nth(nexti++))
                    )
                    (§ else 
                        (§ throw new NoSuchElementException())
                    )
                )

                (§ method boolean hasPrevious()
                    (ß (nexti > 0))
                )

                (§ method Object previous()
                    (§ if (ß nexti > 0)
                        (ß nth(--nexti))
                    )
                    (§ else 
                        (§ throw new NoSuchElementException())
                    )
                )

                (§ method int nextIndex()
                    nexti
                )

                (§ method int previousIndex()
                    (ß nexti - 1)
                )

                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )

                (§ method void set(Object o)
                    (§ throw new UnsupportedOperationException())
                )

                (§ method void add(Object o)
                    (§ throw new UnsupportedOperationException())
                )
            )
        )
    )

    (§ method Iterator rangedIterator(int start, int end)
        (ß new Iterator()
            (§ reify
                (§ let int i = start)

                (§ method boolean hasNext()
                    (ß (i < end))
                )

                (§ method Object next()
                    (§ if (ß i < end)
                        (ß nth(i++))
                    )
                    (§ else 
                        (§ throw new NoSuchElementException())
                    )
                )

                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )
        )
    )

    (§ method List subList(int fromIndex, int toIndex)
        (ß (List) RT.subvec(this, fromIndex, toIndex))
    )

    (§ method Object set(int i, Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void add(int i, Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(int i, Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method Object invoke(Object arg1)
        (§ if (ß Util.isInteger(arg1))
            (§ return (ß nth(((Number) arg1).intValue())))
        )
        (§ throw new IllegalArgumentException("Key must be integer"))
    )

    (§ method Iterator iterator()
        ;; todo - something more efficient
        (ß new Iterator()
            (§ reify
                (§ let int i = 0)

                (§ method boolean hasNext()
                    (ß (i < count()))
                )

                (§ method Object next()
                    (§ if (ß i < count())
                        (ß nth(i++))
                    )
                    (§ else 
                        (§ throw new NoSuchElementException())
                    )
                )

                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )
        )
    )

    (§ method Object peek()
        (§ if (ß count() > 0)
            (§ return (ß nth(count() - 1)))
        )
        nil
    )

    (§ method boolean containsKey(Object key)
        (§ if (ß !(Util.isInteger(key)))
            (§ return false)
        )
        (§ let int i = ((Number) key).intValue())
        (ß (i >= 0 && i < count()))
    )

    (§ method IMapEntry entryAt(Object key)
        (§ if (ß Util.isInteger(key))
            (§ let int i = ((Number) key).intValue())
            (§ if (ß i >= 0 && i < count())
                (§ return (ß (IMapEntry) MapEntry.create(key, nth(i))))
            )
        )
        nil
    )

    (§ method IPersistentVector assoc(Object key, Object val)
        (§ if (ß Util.isInteger(key))
            (§ let int i = ((Number) key).intValue())
            (§ return (ß assocN(i, val)))
        )
        (§ throw new IllegalArgumentException("Key must be integer"))
    )

    (§ method Object valAt(Object key, Object notFound)
        (§ if (ß Util.isInteger(key))
            (§ let int i = ((Number) key).intValue())
            (§ if (ß i >= 0 && i < count())
                (§ return (ß nth(i)))
            )
        )
        notFound
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method Object[] toArray()
        (§ let Object[] ret = new Object[count()])
        (§ loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
            (ß ret[i] = nth(i))
        )
        ret
    )

    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean containsAll(Collection c)
        (§ doseq [#_"Object" o c]
            (§ if (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method boolean contains(Object o)
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (§ if (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method int length()
        (ß count())
    )

    (§ method int compareTo(Object o)
        (§ let IPersistentVector v = (IPersistentVector) o)
        (§ if (ß count() < v.count())
            (§ return -1)
        )
        (§ elseif (ß count() > v.count())
            (§ return 1)
        )
        (§ loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
            (§ let int c = Util.compare(nth(i), v.nth(i)))
            (§ if (ß c != 0)
                (§ return c)
            )
        )
        0
    )

    (class-ns Seq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        ;; todo - something more efficient
        (§ field IPersistentVector v)
        (§ field int i)

        (§ constructor Seq(IPersistentVector v, int i)
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ constructor Seq(IPersistentMap meta, IPersistentVector v, int i)
            (§ super(meta))
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß v.nth(i))
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < v.count())
                (§ return (ß new APersistentVector.Seq(v, i + 1)))
            )
            nil
        )

        (§ method int index()
            i
        )

        (§ method int count()
            (ß v.count() - i)
        )

        (§ method APersistentVector.Seq withMeta(IPersistentMap meta)
            (ß new APersistentVector.Seq(meta, v, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = v.nth(i))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < v.count()) [(ß x++)]
                (ß ret = f.invoke(ret, v.nth(x)))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, v.nth(i)))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < v.count()) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, v.nth(x)))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )
    )

    (class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
        (§ field IPersistentVector v)
        (§ field int i)

        (§ constructor RSeq(IPersistentVector vector, int i)
            (ß this.v = vector)
            (ß this.i = i)
            this
        )

        (§ constructor RSeq(IPersistentMap meta, IPersistentVector v, int i)
            (§ super(meta))
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß v.nth(i))
        )

        (§ method ISeq next()
            (§ if (ß i > 0)
                (§ return (ß new APersistentVector.RSeq(v, i - 1)))
            )
            nil
        )

        (§ method int index()
            i
        )

        (§ method int count()
            (ß i + 1)
        )

        (§ method APersistentVector.RSeq withMeta(IPersistentMap meta)
            (ß new APersistentVector.RSeq(meta, v, i))
        )
    )

    (class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
        (§ field IPersistentVector v)
        (§ field int start)
        (§ field int end)
        (§ field IPersistentMap _meta)

        (§ constructor SubVector(IPersistentMap meta, IPersistentVector v, int start, int end)
            (ß this._meta = meta)

            (§ if (ß v instanceof APersistentVector.SubVector)
                (§ let APersistentVector.SubVector sv = (APersistentVector.SubVector) v)
                (ß start += sv.start)
                (ß end += sv.start)
                (ß v = sv.v)
            )
            (ß this.v = v)
            (ß this.start = start)
            (ß this.end = end)
            this
        )

        (§ method Iterator iterator()
            (§ if (ß v instanceof APersistentVector)
                (§ return (ß ((APersistentVector)v).rangedIterator(start, end)))
            )
            (ß super.iterator())
        )

        (§ method Object nth(int i)
            (§ if (ß (start + i >= end) || (i < 0))
                (§ throw new IndexOutOfBoundsException())
            )
            (ß v.nth(start + i))
        )

        (§ method IPersistentVector assocN(int i, Object val)
            (§ if (ß start + i > end)
                (§ throw new IndexOutOfBoundsException())
            )
            (§ elseif (ß start + i == end)
                (§ return (ß cons(val)))
            )
            (ß new SubVector(_meta, v.assocN(start + i, val), start, end))
        )

        (§ method int count()
            (ß end - start)
        )

        (§ method IPersistentVector cons(Object o)
            (ß new SubVector(_meta, v.assocN(end, o), start, end + 1))
        )

        (§ method IPersistentCollection empty()
            (ß PersistentVector.EMPTY.withMeta(meta()))
        )

        (§ method IPersistentStack pop()
            (§ if (ß end - 1 == start)
                (§ return (ß PersistentVector.EMPTY))
            )
            (ß new SubVector(_meta, v, start, end - 1))
        )

        (§ method SubVector withMeta(IPersistentMap meta)
            (§ if (ß meta == _meta)
                (§ return this)
            )
            (ß new SubVector(meta, v, start, end))
        )

        (§ method IPersistentMap meta()
            (ß _meta)
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    #_protected
    #_volatile
    (§ field IFn validator = nil)
    #_volatile
    (§ field- IPersistentMap watches = PersistentHashMap.EMPTY)

    (§ constructor ARef()
        (§ super())
        this
    )

    (§ constructor ARef(IPersistentMap meta)
        (§ super(meta))
        this
    )

    (§ method void validate(IFn vf, Object val)
        (§ try 
            (§ if (ß vf != nil && !RT.booleanCast(vf.invoke(val)))
                (§ throw new IllegalStateException("Invalid reference state"))
            )
        )
        (§ catch (ß RuntimeException re)
            (§ throw re)
        )
        (§ catch (ß Exception e)
            (§ throw new IllegalStateException("Invalid reference state", e))
        )
        nil
    )

    (§ method void validate(Object val)
        (ß validate(validator, val))
        nil
    )

    (§ method void setValidator(IFn vf)
        (ß validate(vf, deref()))
        (ß validator = vf)
        nil
    )

    (§ method IFn getValidator()
        validator
    )

    (§ method IPersistentMap getWatches()
        watches
    )

    (§ method IRef addWatch(Object key, IFn callback)
        (§ sync (ß this)
            (ß watches = watches.assoc(key, callback))
            this
        )
    )

    (§ method IRef removeWatch(Object key)
        (§ sync (ß this)
            (ß watches = watches.without(key))
            this
        )
    )

    (§ method void notifyWatches(Object oldval, Object newval)
        (§ let IPersistentMap ws = watches)
        (§ if (ß ws.count() > 0)
            (§ loop-when-recur [(ß ISeq s = ws.seq())] (ß s != nil) [(ß s = s.next())]
                (§ let Map.Entry e = (Map.Entry) s.first())
                (§ let IFn fn = (IFn) e.getValue())
                (§ if (ß fn != nil)
                    (ß fn.invoke(e.getKey(), this, oldval, newval))
                )
            )
        )
        nil
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (§ field- IPersistentMap _meta)

    (§ constructor AReference()
        (§ this(nil))
        this
    )

    (§ constructor AReference(IPersistentMap meta)
        (ß _meta = meta)
        this
    )

    (§ method IPersistentMap meta()
        (§ sync (ß this)
            (ß _meta)
        )
    )

    (§ method IPersistentMap alterMeta(IFn alter, ISeq args)
        (§ sync (ß this)
            (ß _meta = (IPersistentMap) alter.applyTo(new Cons(_meta, args)))
            (ß _meta)
        )
    )

    (§ method IPersistentMap resetMeta(IPersistentMap m)
        (§ sync (ß this)
            (ß _meta = m)
            m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (§ field int actual)

    (§ field String name)

    (§ constructor ArityException(int actual, String name)
        (§ this(actual, name, nil))
        this
    )

    (§ constructor ArityException(int actual, String name, Throwable cause)
        (§ super("Wrong number of args (" + actual + ") passed to: " + name, cause))
        (ß this.actual = actual)
        (ß this.name = name)
        this
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (§ field Object[] array)
    (§ field int off)
    (§ field int end)

    (§ constructor ArrayChunk(Object[] array)
        (§ this(array, 0, array.length))
        this
    )

    (§ constructor ArrayChunk(Object[] array, int off)
        (§ this(array, off, array.length))
        this
    )

    (§ constructor ArrayChunk(Object[] array, int off, int end)
        (ß this.array = array)
        (ß this.off = off)
        (ß this.end = end)
        this
    )

    (§ method Object nth(int i)
        (ß array[off + i])
    )

    (§ method Object nth(int i, Object notFound)
        (§ if (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    (§ method int count()
        (ß end - off)
    )

    (§ method IChunk dropFirst()
        (§ if (ß off == end)
            (§ throw new IllegalStateException("dropFirst of empty chunk"))
        )
        (ß new ArrayChunk(array, off + 1, end))
    )

    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = f.invoke(start, array[off]))
        (§ if (ß RT.isReduced(ret))
            (§ return ret)
        )
        (§ loop-when-recur [(ß int x = off + 1)] (ß x < end) [(ß x++)]
            (ß ret = f.invoke(ret, array[x]))
            (§ if (ß RT.isReduced(ret))
                (§ return ret)
            )
        )
        ret
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter (§ implements Iterator)
    (§ field Object[] array)
    (§ field int i)

    (§ def Iterator EMPTY_ITERATOR = new Iterator()
        (§ reify
            (§ method boolean hasNext()
                false
            )

            (§ method Object next()
                (§ throw new java.util.NoSuchElementException())
            )

            (§ method void remove()
                (§ throw new UnsupportedOperationException("remove() not supported"))
            )
        )
    )

    (§ defn Iterator create()
        (ß EMPTY_ITERATOR)
    )

    (§ defn Iterator create(Object... array)
        (§ if (ß array == nil || array.length == 0)
            (§ return (ß EMPTY_ITERATOR))
        )
        (ß new ArrayIter(array, 0))
    )

    (§ defn Iterator createFromObject(Object array)
        (§ if (ß array == nil || Array.getLength(array) == 0)
            (§ return (ß EMPTY_ITERATOR))
        )
        (§ let Class aclass = array.getClass())
        (§ if (ß aclass == int[].class)
            (§ return (ß new ArrayIter_int((int[]) array, 0)))
        )
        (§ if (ß aclass == float[].class)
            (§ return (ß new ArrayIter_float((float[]) array, 0)))
        )
        (§ if (ß aclass == double[].class)
            (§ return (ß new ArrayIter_double((double[]) array, 0)))
        )
        (§ if (ß aclass == long[].class)
            (§ return (ß new ArrayIter_long((long[]) array, 0)))
        )
        (§ if (ß aclass == byte[].class)
            (§ return (ß new ArrayIter_byte((byte[]) array, 0)))
        )
        (§ if (ß aclass == char[].class)
            (§ return (ß new ArrayIter_char((char[]) array, 0)))
        )
        (§ if (ß aclass == short[].class)
            (§ return (ß new ArrayIter_short((short[]) array, 0)))
        )
        (§ if (ß aclass == boolean[].class)
            (§ return (ß new ArrayIter_boolean((boolean[]) array, 0)))
        )
        (ß new ArrayIter(array, 0))
    )

    (§ constructor ArrayIter(Object array, int i)
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ method boolean hasNext()
        (ß (array != nil && i < array.length))
    )

    (§ method Object next()
        (§ if (ß array != nil && i < array.length)
            (§ return (ß array[i++]))
        )
        (§ throw new java.util.NoSuchElementException())
    )

    (§ method void remove()
        (§ throw new UnsupportedOperationException("remove() not supported"))
    )

    (class-ns ArrayIter_int (§ implements Iterator<Long>)
        (§ field int[] array)
        (§ field int i)

        (§ constructor ArrayIter_int(int[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Long next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_float (§ implements Iterator<Double>)
        (§ field float[] array)
        (§ field int i)

        (§ constructor ArrayIter_float(float[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Double next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß Double.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_double (§ implements Iterator<Double>)
        (§ field double[] array)
        (§ field int i)

        (§ constructor ArrayIter_double(double[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Double next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_long (§ implements Iterator<Long>)
        (§ field long[] array)
        (§ field int i)

        (§ constructor ArrayIter_long(long[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Long next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_byte (§ implements Iterator<Byte>)
        (§ field byte[] array)
        (§ field int i)

        (§ constructor ArrayIter_byte(byte[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Byte next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_char (§ implements Iterator<Character>)
        (§ field char[] array)
        (§ field int i)

        (§ constructor ArrayIter_char(char[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Character next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_short (§ implements Iterator<Long>)
        (§ field short[] array)
        (§ field int i)

        (§ constructor ArrayIter_short(short[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Long next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    (class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
        (§ field boolean[] array)
        (§ field int i)

        (§ constructor ArrayIter_boolean(boolean[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Boolean next()
            (§ if (ß array != nil && i < array.length)
                (§ return (ß Boolean.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ field Object[] array)
    (§ field int i)

    (§ defn ArraySeq create()
        nil
    )

    (§ defn ArraySeq create(Object... array)
        (§ if (ß array == nil || array.length == 0)
            (§ return nil)
        )
        (ß new ArraySeq(array, 0))
    )

    (§ defn ISeq createFromObject(Object array)
        (§ if (ß array == nil || Array.getLength(array) == 0)
            (§ return nil)
        )
        (§ let Class aclass = array.getClass())
        (§ if (ß aclass == int[].class)
            (§ return (ß new ArraySeq_int(nil, (int[]) array, 0)))
        )
        (§ if (ß aclass == float[].class)
            (§ return (ß new ArraySeq_float(nil, (float[]) array, 0)))
        )
        (§ if (ß aclass == double[].class)
            (§ return (ß new ArraySeq_double(nil, (double[]) array, 0)))
        )
        (§ if (ß aclass == long[].class)
            (§ return (ß new ArraySeq_long(nil, (long[]) array, 0)))
        )
        (§ if (ß aclass == byte[].class)
            (§ return (ß new ArraySeq_byte(nil, (byte[]) array, 0)))
        )
        (§ if (ß aclass == char[].class)
            (§ return (ß new ArraySeq_char(nil, (char[]) array, 0)))
        )
        (§ if (ß aclass == short[].class)
            (§ return (ß new ArraySeq_short(nil, (short[]) array, 0)))
        )
        (§ if (ß aclass == boolean[].class)
            (§ return (ß new ArraySeq_boolean(nil, (boolean[]) array, 0)))
        )
        (ß new ArraySeq(array, 0))
    )

    (§ constructor ArraySeq(Object array, int i)
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ constructor ArraySeq(IPersistentMap meta, Object array, int i)
        (§ super(meta))
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ method Object first()
        (§ if (ß array != nil)
            (§ return (ß array[i]))
        )
        nil
    )

    (§ method ISeq next()
        (§ if (ß array != nil && i + 1 < array.length)
            (§ return (ß new ArraySeq(array, i + 1)))
        )
        nil
    )

    (§ method int count()
        (§ if (ß array != nil)
            (§ return (ß array.length - i))
        )
        0
    )

    (§ method int index()
        i
    )

    (§ method ArraySeq withMeta(IPersistentMap meta)
        (ß new ArraySeq(meta, array, i))
    )

    (§ method Object reduce(IFn f)
        (§ if (ß array != nil)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            (§ return ret)
        )
        nil
    )

    (§ method Object reduce(IFn f, Object start)
        (§ if (ß array != nil)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            (§ return ret)
        )
        nil
    )

    (§ method int indexOf(Object o)
        (§ if (ß array != nil)
            (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (§ if (ß Util.equals(o, array[j]))
                    (§ return (ß j - i))
                )
            )
        )
        -1
    )

    (§ method int lastIndexOf(Object o)
        (§ if (ß array != nil)
            (§ if (ß o == nil)
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß array[j] == nil)
                        (§ return (ß j - i))
                    )
                )
            )
            (§ else 
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß o.equals(array[j]))
                        (§ return (ß j - i))
                    )
                )
            )
        )
        -1
    )

    (class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field int[] array)
        (§ field int i)

        (§ constructor ArraySeq_int(IPersistentMap meta, int[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_int(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_int withMeta(IPersistentMap meta)
            (ß new ArraySeq_int(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let int k = ((Number) o).intValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß k == array[j])
                        (§ return (ß j - i))
                    )
                )
            )

            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let int k = ((Number) o).intValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß k == array[j])
                        (§ return (ß j - i))
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field float[] array)
        (§ field int i)

        (§ constructor ArraySeq_float(IPersistentMap meta, float[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß Numbers.num(array[i]))
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_float(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_float withMeta(IPersistentMap meta)
            (ß new ArraySeq_float(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = Numbers.num(array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, Numbers.num(array[x])))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, Numbers.num(array[i])))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, Numbers.num(array[x])))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let float f = ((Number) o).floatValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß f == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let float f = ((Number) o).floatValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß f == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field double[] array)
        (§ field int i)

        (§ constructor ArraySeq_double(IPersistentMap meta, double[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_double(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_double withMeta(IPersistentMap meta)
            (ß new ArraySeq_double(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let double d = ((Number) o).doubleValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß d == array[j])
                        (§ return (ß j - i))
                    )
                )
            )

            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let double d = ((Number) o).doubleValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß d == array[j])
                        (§ return (ß j - i))
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field long[] array)
        (§ field int i)

        (§ constructor ArraySeq_long(IPersistentMap meta, long[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß Numbers.num(array[i]))
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_long(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_long withMeta(IPersistentMap meta)
            (ß new ArraySeq_long(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = Numbers.num(array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, Numbers.num(array[x])))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, Numbers.num(array[i])))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, Numbers.num(array[x])))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let long l = ((Number) o).longValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß l == array[j])
                        (§ return (ß j - i))
                    )
                )
            )

            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Number)
                (§ let long l = ((Number) o).longValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß l == array[j])
                        (§ return (ß j - i))
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field byte[] array)
        (§ field int i)

        (§ constructor ArraySeq_byte(IPersistentMap meta, byte[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_byte(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_byte withMeta(IPersistentMap meta)
            (ß new ArraySeq_byte(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Byte)
                (§ let byte b = ((Byte) o).byteValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß b == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Byte)
                (§ let byte b = ((Byte) o).byteValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß b == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field char[] array)
        (§ field int i)

        (§ constructor ArraySeq_char(IPersistentMap meta, char[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_char(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_char withMeta(IPersistentMap meta)
            (ß new ArraySeq_char(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Character)
                (§ let char c = ((Character) o).charValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß c == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Character)
                (§ let char c = ((Character) o).charValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß c == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field short[] array)
        (§ field int i)

        (§ constructor ArraySeq_short(IPersistentMap meta, short[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_short(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_short withMeta(IPersistentMap meta)
            (ß new ArraySeq_short(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Short)
                (§ let short s = ((Short) o).shortValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß s == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Short)
                (§ let short s = ((Short) o).shortValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß s == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field boolean[] array)
        (§ field int i)

        (§ constructor ArraySeq_boolean(IPersistentMap meta, boolean[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (§ if (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_boolean(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_boolean withMeta(IPersistentMap meta)
            (ß new ArraySeq_boolean(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )

        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, array[x]))
            )
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )

        (§ method int indexOf(Object o)
            (§ if (ß o instanceof Boolean)
                (§ let boolean b = ((Boolean) o).booleanValue())
                (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                    (§ if (ß b == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (§ if (ß o instanceof Boolean)
                (§ let boolean b = ((Boolean) o).booleanValue())
                (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                    (§ if (ß b == array[j])
                        (§ return (ß j - i))
                    )
                )
            )
            (§ if (ß o == nil)
                (§ return -1)
            )
            (§ loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (§ if (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    #_transient
    (§ field int _hash)
    #_transient
    (§ field int _hasheq)

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method IPersistentCollection empty()
        (ß PersistentList.EMPTY)
    )

    #_protected
    (§ constructor ASeq(IPersistentMap meta)
        (§ super(meta))
        this
    )

    #_protected
    (§ constructor ASeq()
        this
    )

    (§ method boolean equiv(Object obj)
        (§ if (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
            (§ if (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                (§ return false)
            )
        )
        (ß (ms == nil))
    )

    (§ method boolean equals(Object obj)
        (§ if (ß this == obj)
            (§ return true)
        )
        (§ if (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
            (§ if (ß ms == nil || !Util.equals(s.first(), ms.first()))
                (§ return false)
            )
        )
        (ß (ms == nil))
    )

    (§ method int hashCode()
        (§ if (ß _hash == 0)
            (§ let int hash = 1)
            (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (ß hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
            )
            (ß this._hash = hash)
        )
        (ß _hash)
    )

    (§ method int hasheq()
        (§ if (ß _hasheq == 0)
            (ß _hasheq = Murmur3.hashOrdered(this))
        )
        (ß _hasheq)
    )

    (§ method int count()
        (§ let int i = 1)
        (§ loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next(), i++)]
            (§ if (ß s instanceof Counted)
                (§ return (ß i + s.count()))
            )
        )
        i
    )

    (§ method ISeq seq()
        this
    )

    (§ method ISeq cons(Object o)
        (ß new Cons(o, this))
    )

    (§ method ISeq more()
        (§ let ISeq s = next())
        (§ if (ß s == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        s
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean containsAll(Collection c)
        (§ doseq [#_"Object" o c]
            (§ if (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (seq() == nil))
    )

    (§ method boolean contains(Object o)
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (§ if (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method Iterator iterator()
        (ß new SeqIterator(this))
    )

    (§ method- List reify()
        (ß Collections.unmodifiableList(new ArrayList(this)))
    )

    (§ method List subList(int fromIndex, int toIndex)
        (ß reify().subList(fromIndex, toIndex))
    )

    (§ method Object set(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    (§ method Object remove(int index)
        (§ throw new UnsupportedOperationException())
    )

    (§ method int indexOf(Object o)
        (§ let ISeq s = seq())
        (§ loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
            (§ if (ß Util.equiv(s.first(), o))
                (§ return i)
            )
        )
        -1
    )

    (§ method int lastIndexOf(Object o)
        (ß reify().lastIndexOf(o))
    )

    (§ method ListIterator listIterator()
        (ß reify().listIterator())
    )

    (§ method ListIterator listIterator(int index)
        (ß reify().listIterator(index))
    )

    (§ method Object get(int index)
        (ß RT.nth(this, index))
    )

    (§ method void add(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(int index, Collection c)
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.Associative

(§ interface Associative (§ extends IPersistentCollection, ILookup)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
    (§ abstract Associative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (§ field AtomicReference state)

    (§ constructor Atom(Object state)
        (ß this.state = new AtomicReference(state))
        this
    )

    (§ constructor Atom(Object state, IPersistentMap meta)
        (§ super(meta))
        (ß this.state = new AtomicReference(state))
        this
    )

    (§ method Object deref()
        (ß state.get())
    )

    (§ method Object swap(IFn f)
        (§ while true
            (§ let Object v = deref())
            (§ let Object newv = f.invoke(v))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(v, newv))
                (ß notifyWatches(v, newv))
                (§ return newv)
            )
        )
    )

    (§ method Object swap(IFn f, Object arg)
        (§ while true
            (§ let Object v = deref())
            (§ let Object newv = f.invoke(v, arg))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(v, newv))
                (ß notifyWatches(v, newv))
                (§ return newv)
            )
        )
    )

    (§ method Object swap(IFn f, Object arg1, Object arg2)
        (§ while true
            (§ let Object v = deref())
            (§ let Object newv = f.invoke(v, arg1, arg2))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(v, newv))
                (ß notifyWatches(v, newv))
                (§ return newv)
            )
        )
    )

    (§ method Object swap(IFn f, Object x, Object y, ISeq args)
        (§ while true
            (§ let Object v = deref())
            (§ let Object newv = f.applyTo(RT.listStar(v, x, y, args)))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(v, newv))
                (ß notifyWatches(v, newv))
                (§ return newv)
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f)
        (§ while true
            (§ let Object oldv = deref())
            (§ let Object newv = f.invoke(oldv))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(oldv, newv))
                (ß notifyWatches(oldv, newv))
                (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f, Object arg)
        (§ while true
            (§ let Object oldv = deref())
            (§ let Object newv = f.invoke(oldv, arg))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(oldv, newv))
                (ß notifyWatches(oldv, newv))
                (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f, Object arg1, Object arg2)
        (§ while true
            (§ let Object oldv = deref())
            (§ let Object newv = f.invoke(oldv, arg1, arg2))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(oldv, newv))
                (ß notifyWatches(oldv, newv))
                (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)
        (§ while true
            (§ let Object oldv = deref())
            (§ let Object newv = f.applyTo(RT.listStar(oldv, x, y, args)))
            (ß validate(newv))
            (§ if (ß state.compareAndSet(oldv, newv))
                (ß notifyWatches(oldv, newv))
                (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    (§ method boolean compareAndSet(Object oldv, Object newv)
        (ß validate(newv))
        (§ let boolean ret = state.compareAndSet(oldv, newv))
        (§ if (ß ret)
            (ß notifyWatches(oldv, newv))
        )
        ret
    )

    (§ method Object reset(Object newval)
        (§ let Object oldval = state.get())
        (ß validate(newval))
        (ß state.set(newval))
        (ß notifyWatches(oldval, newval))
        newval
    )

    (§ method IPersistentVector resetVals(Object newv)
        (ß validate(newv))
        (§ while true
            (§ let Object oldv = deref())
            (§ if (ß state.compareAndSet(oldv, newv))
                (ß notifyWatches(oldv, newv))
                (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

(§ import cloiure.lang.PersistentHashMap.INode)

#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    (§ abstract void ensureEditable())
    (§ abstract ITransientMap doAssoc(Object key, Object val))
    (§ abstract ITransientMap doWithout(Object key))
    (§ abstract Object doValAt(Object key, Object notFound))
    (§ abstract int doCount())
    (§ abstract IPersistentMap doPersistent())

    (§ method ITransientMap conj(Object o)
        (ß ensureEditable())
        (§ if (ß o instanceof Map.Entry)
            (§ let Map.Entry e = (Map.Entry) o)

            (§ return (ß assoc(e.getKey(), e.getValue())))
        )
        (§ elseif (ß o instanceof IPersistentVector)
            (§ let IPersistentVector v = (IPersistentVector) o)
            (§ if (ß v.count() != 2)
                (§ throw new IllegalArgumentException("Vector arg to map conj must be a pair"))
            )
            (§ return (ß assoc(v.nth(0), v.nth(1))))
        )

        (§ let ITransientMap ret = this)
        (§ loop-when-recur [(ß ISeq es = RT.seq(o))] (ß es != nil) [(ß es = es.next())]
            (§ let Map.Entry e = (Map.Entry) es.first())
            (ß ret = ret.assoc(e.getKey(), e.getValue()))
        )
        ret
    )

    (§ method Object invoke(Object arg1)
        (ß valAt(arg1))
    )

    (§ method Object invoke(Object arg1, Object notFound)
        (ß valAt(arg1, notFound))
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method ITransientMap assoc(Object key, Object val)
        (ß ensureEditable())
        (ß doAssoc(key, val))
    )

    (§ method ITransientMap without(Object key)
        (ß ensureEditable())
        (ß doWithout(key))
    )

    (§ method IPersistentMap persistent()
        (ß ensureEditable())
        (ß doPersistent())
    )

    (§ method Object valAt(Object key, Object notFound)
        (ß ensureEditable())
        (ß doValAt(key, notFound))
    )

    (§ def- Object NOT_FOUND = new Object())
    (§ method boolean containsKey(Object key)
        (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
    )
    (§ method IMapEntry entryAt(Object key)
        (§ let Object v = valAt(key, NOT_FOUND))
        (§ if (ß v != NOT_FOUND)
            (§ return (ß MapEntry.create(key, v)))
        )
        nil
    )

    (§ method int count()
        (ß ensureEditable())
        (ß doCount())
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    #_volatile
    (§ field ITransientMap impl)

    (§ constructor ATransientSet(ITransientMap impl)
        (ß this.impl = impl)
        this
    )

    (§ method int count()
        (ß impl.count())
    )

    (§ method ITransientSet conj(Object val)
        (§ let ITransientMap m = impl.assoc(val, val))
        (§ if (ß m != impl)
            (ß this.impl = m)
        )
        this
    )

    (§ method boolean contains(Object key)
        (ß (this != impl.valAt(key, this)))
    )

    (§ method ITransientSet disjoin(Object key)
        (§ let ITransientMap m = impl.without(key))
        (§ if (ß m != impl)
            (ß this.impl = m)
        )
        this
    )

    (§ method Object get(Object key)
        (ß impl.valAt(key))
    )

    (§ method Object invoke(Object key, Object notFound)
        (ß impl.valAt(key, notFound))
    )

    (§ method Object invoke(Object key)
        (ß impl.valAt(key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ field long lpart)
    (§ field BigInteger bipart)

    (§ def BigInt ZERO = new BigInt(0, nil))
    (§ def BigInt ONE = new BigInt(1, nil))

    ;; must follow Long
    (§ method int hashCode()
        (§ if (ß bipart == nil)
            (§ return (ß (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (ß bipart.hashCode())
    )

    (§ method int hasheq()
        (§ if (ß bipart == nil)
            (§ return (ß Murmur3.hashLong(lpart)))
        )
        (ß bipart.hashCode())
    )

    (§ method boolean equals(Object obj)
        (§ if (ß this == obj)
            (§ return true)
        )
        (§ if (ß obj instanceof BigInt)
            (§ let BigInt o = (BigInt) obj)
            (§ if (ß bipart == nil)
                (§ return (ß (o.bipart == nil && this.lpart == o.lpart)))
            )
            (§ return (ß (o.bipart != nil && this.bipart.equals(o.bipart))))
        )
        false
    )

    (§ constructor- BigInt(long lpart, BigInteger bipart)
        (ß this.lpart = lpart)
        (ß this.bipart = bipart)
        this
    )

    (§ defn BigInt fromBigInteger(BigInteger val)
        (§ if (ß val.bitLength() < 64)
            (ß new BigInt(val.longValue(), nil))
        )
        (§ else 
            (ß new BigInt(0, val))
        )
    )

    (§ defn BigInt fromLong(long val)
        (ß new BigInt(val, nil))
    )

    (§ method BigInteger toBigInteger()
        (§ if (ß bipart == nil)
            (ß BigInteger.valueOf(lpart))
        )
        (§ else 
            bipart
        )
    )

    (§ method BigDecimal toBigDecimal()
        (§ if (ß bipart == nil)
            (ß BigDecimal.valueOf(lpart))
        )
        (§ else 
            (ß new BigDecimal(bipart))
        )
    )

    (§ method int intValue()
        (§ if (ß bipart == nil)
            (ß (int) lpart)
        )
        (§ else 
            (ß bipart.intValue())
        )
    )

    (§ method long longValue()
        (§ if (ß bipart == nil)
            lpart
        )
        (§ else 
            (ß bipart.longValue())
        )
    )

    (§ method float floatValue()
        (§ if (ß bipart == nil)
            lpart
        )
        (§ else 
            (ß bipart.floatValue())
        )
    )

    (§ method double doubleValue()
        (§ if (ß bipart == nil)
            lpart
        )
        (§ else 
            (ß bipart.doubleValue())
        )
    )

    (§ method byte byteValue()
        (§ if (ß bipart == nil)
            (ß (byte) lpart)
        )
        (§ else 
            (ß bipart.byteValue())
        )
    )

    (§ method short shortValue()
        (§ if (ß bipart == nil)
            (ß (short) lpart)
        )
        (§ else 
            (ß bipart.shortValue())
        )
    )

    (§ defn BigInt valueOf(long val)
        (ß new BigInt(val, nil))
    )

    (§ method String toString()
        (§ if (ß bipart == nil)
            (§ return (ß String.valueOf(lpart)))
        )
        (ß bipart.toString())
    )

    (§ method int bitLength()
        (ß toBigInteger().bitLength())
    )

    (§ method BigInt add(BigInt y)
        (§ if (ß (bipart == nil) && (y.bipart == nil))
            (§ let long ret = lpart + y.lpart)
            (§ if (ß (ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0)
                (§ return (ß BigInt.valueOf(ret)))
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger())))
    )

    (§ method BigInt multiply(BigInt y)
        (§ if (ß (bipart == nil) && (y.bipart == nil))
            (§ let long ret = lpart * y.lpart)
            (§ if (ß y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE))
                (§ return (ß BigInt.valueOf(ret)))
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger())))
    )

    (§ method BigInt quotient(BigInt y)
        (§ if (ß (bipart == nil) && (y.bipart == nil))
            (§ if (ß lpart == Long.MIN_VALUE && y.lpart == -1)
                (§ return (ß BigInt.fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (ß BigInt.valueOf(lpart / y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger())))
    )

    (§ method BigInt remainder(BigInt y)
        (§ if (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß BigInt.valueOf(lpart % y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger())))
    )

    (§ method boolean lt(BigInt y)
        (§ if (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß (lpart < y.lpart)))
        )
        (ß (this.toBigInteger().compareTo(y.toBigInteger()) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (§ field T val)
    (§ field Binding rest)

    (§ constructor Binding(T val)
        (ß this.val = val)
        (ß this.rest = nil)
        this
    )

    (§ constructor Binding(T val, Binding rest)
        (ß this.val = val)
        (ß this.rest = rest)
        this
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (§ field Object val)

    (§ constructor Box(Object val)
        (ß this.val = val)
        this
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (§ field Object[] buffer)
    (§ field int end)

    (§ constructor ChunkBuffer(int capacity)
        (ß buffer = new Object[capacity])
        (ß end = 0)
        this
    )

    (§ method void add(Object o)
        (ß buffer[end++] = o)
        nil
    )

    (§ method IChunk chunk()
        (§ let ArrayChunk ret = new ArrayChunk(buffer, 0, end))
        (ß buffer = nil)
        ret
    )

    (§ method int count()
        end
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (§ field IChunk chunk)
    (§ field ISeq _more)

    (§ constructor ChunkedCons(IPersistentMap meta, IChunk chunk, ISeq more)
        (§ super(meta))
        (ß this.chunk = chunk)
        (ß this._more = more)
        this
    )

    (§ constructor ChunkedCons(IChunk chunk, ISeq more)
        (§ this(nil, chunk, more))
        this
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (ß meta != _meta)
            (§ return (ß new ChunkedCons(meta, chunk, _more)))
        )
        this
    )

    (§ method Object first()
        (ß chunk.nth(0))
    )

    (§ method ISeq next()
        (§ if (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (ß chunkedNext())
    )

    (§ method ISeq more()
        (§ if (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (§ if (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    (§ method IChunk chunkedFirst()
        chunk
    )

    (§ method ISeq chunkedNext()
        (ß chunkedMore().seq())
    )

    (§ method ISeq chunkedMore()
        (§ if (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

(class-ns Compile
    (§ def- String PATH_PROP = "cloiure.compile.path")
    (§ def- String REFLECTION_WARNING_PROP = "cloiure.compile.warn-on-reflection")
    (§ def- String UNCHECKED_MATH_PROP = "cloiure.compile.unchecked-math")

    (§ def- Var compile_path = RT.var("cloiure.core", "*compile-path*"))
    (§ def- Var compile = RT.var("cloiure.core", "compile"))
    (§ def- Var warn_on_reflection = RT.var("cloiure.core", "*warn-on-reflection*"))
    (§ def- Var unchecked_math = RT.var("cloiure.core", "*unchecked-math*"))

    (§ defn void main(String[] args) (§ throws IOException, ClassNotFoundException)
        (§ let OutputStreamWriter out = (OutputStreamWriter) RT.OUT.deref())
        (§ let PrintWriter err = RT.errPrintWriter())
        (§ let String path = System.getProperty(PATH_PROP))
        (§ let int count = args.length)

        (§ if (ß path == nil)
            (ß err.println("ERROR: Must set system property " + PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
            (ß System.exit(1))
        )

        (§ let boolean warnOnReflection = System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true"))
        (§ let String uncheckedMathProp = System.getProperty(UNCHECKED_MATH_PROP))
        (§ let Object uncheckedMath = Boolean.FALSE)
        (§ if (ß "true".equals(uncheckedMathProp))
            (ß uncheckedMath = Boolean.TRUE)
        )
        (§ elseif (ß "warn-on-boxed".equals(uncheckedMathProp))
            (ß uncheckedMath = Keyword.intern("warn-on-boxed"))
        )

        ;; force load to avoid transitive compilation during lazy load
        (ß RT.load("cloiure/core/specs/alpha"))

        (§ try 
            (ß Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath)))

            (§ doseq [#_"String" lib args]
                (ß out.write("Compiling " + lib + " to " + path + "\n"))
                (ß out.flush())
                (ß compile.invoke(Symbol.intern(lib)))
            )
        )
        (§ finally 
            (ß Var.popThreadBindings())
            (§ try 
                (ß out.flush())
            )
            (§ catch (ß IOException e)
                (ß e.printStackTrace(err))
            )
        )
        nil
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(class-ns Compiler (§ implements Opcodes)
    (§ def Symbol DEF = Symbol.intern("def"))
    (§ def Symbol LOOP = Symbol.intern("loop*"))
    (§ def Symbol RECUR = Symbol.intern("recur"))
    (§ def Symbol IF = Symbol.intern("if"))
    (§ def Symbol LET = Symbol.intern("let*"))
    (§ def Symbol LETFN = Symbol.intern("letfn*"))
    (§ def Symbol DO = Symbol.intern("do"))
    (§ def Symbol FN = Symbol.intern("fn*"))
    (§ def Symbol FNONCE = (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(nil, "once"), RT.T)))
    (§ def Symbol QUOTE = Symbol.intern("quote"))
    (§ def Symbol THE_VAR = Symbol.intern("var"))
    (§ def Symbol DOT = Symbol.intern("."))
    (§ def Symbol ASSIGN = Symbol.intern("set!"))
    (§ def Symbol TRY = Symbol.intern("try"))
    (§ def Symbol CATCH = Symbol.intern("catch"))
    (§ def Symbol FINALLY = Symbol.intern("finally"))
    (§ def Symbol THROW = Symbol.intern("throw"))
    (§ def Symbol MONITOR_ENTER = Symbol.intern("monitor-enter"))
    (§ def Symbol MONITOR_EXIT = Symbol.intern("monitor-exit"))
    (§ def Symbol IMPORT = Symbol.intern("cloiure.core", "import*"))
    (§ def Symbol DEFTYPE = Symbol.intern("deftype*"))
    (§ def Symbol CASE = Symbol.intern("case*"))

    (§ def Symbol CLASS = Symbol.intern("Class"))
    (§ def Symbol NEW = Symbol.intern("new"))
    (§ def Symbol THIS = Symbol.intern("this"))
    (§ def Symbol REIFY = Symbol.intern("reify*"))
    (§ def Symbol LIST = Symbol.intern("cloiure.core", "list"))
    (§ def Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map"))
    (§ def Symbol VECTOR = Symbol.intern("cloiure.core", "vector"))
    (§ def Symbol IDENTITY = Symbol.intern("cloiure.core", "identity"))

    (§ def Symbol _AMP_ = Symbol.intern("&"))
    (§ def Symbol ISEQ = Symbol.intern("cloiure.lang.ISeq"))

    (§ def Keyword loadNs = Keyword.intern(nil, "load-ns"))
    (§ def Keyword inlineKey = Keyword.intern(nil, "inline"))
    (§ def Keyword inlineAritiesKey = Keyword.intern(nil, "inline-arities"))
    (§ def Keyword staticKey = Keyword.intern(nil, "static"))
    (§ def Keyword arglistsKey = Keyword.intern(nil, "arglists"))
    (§ def Symbol INVOKE_STATIC = Symbol.intern("invokeStatic"))

    (§ def Keyword volatileKey = Keyword.intern(nil, "volatile"))
    (§ def Keyword implementsKey = Keyword.intern(nil, "implements"))
    (§ def String COMPILE_STUB_PREFIX = "compile__stub")

    (§ def Keyword protocolKey = Keyword.intern(nil, "protocol"))
    (§ def Keyword onKey = Keyword.intern(nil, "on"))
    (§ def Keyword dynamicKey = Keyword.intern("dynamic"))
    (§ def Keyword redefKey = Keyword.intern(nil, "redef"))

    (§ def Symbol NS = Symbol.intern("ns"))
    (§ def Symbol IN_NS = Symbol.intern("in-ns"))

    (§ def IPersistentMap specials = PersistentHashMap.create(
  #_map DEF, new DefExpr.Parser(),
  #_map LOOP, new LetExpr.Parser(),
  #_map RECUR, new RecurExpr.Parser(),
  #_map IF, new IfExpr.Parser(),
  #_map CASE, new CaseExpr.Parser(),
  #_map LET, new LetExpr.Parser(),
  #_map LETFN, new LetFnExpr.Parser(),
  #_map DO, new BodyExpr.Parser(),
  #_map FN, nil,
  #_map QUOTE, new ConstantExpr.Parser(),
  #_map THE_VAR, new TheVarExpr.Parser(),
  #_map IMPORT, new ImportExpr.Parser(),
  #_map DOT, new HostExpr.Parser(),
  #_map ASSIGN, new AssignExpr.Parser(),
  #_map DEFTYPE, new NewInstanceExpr.DeftypeParser(),
  #_map REIFY, new NewInstanceExpr.ReifyParser(),
  #_map TRY, new TryExpr.Parser(),
  #_map THROW, new ThrowExpr.Parser(),
  #_map MONITOR_ENTER, new MonitorEnterExpr.Parser(),
  #_map MONITOR_EXIT, new MonitorExitExpr.Parser(),
  #_map CATCH, nil,
  #_map FINALLY, nil,
  #_map NEW, new NewExpr.Parser(),
  #_map _AMP_, nil
    ))

    (§ def- int MAX_POSITIONAL_ARITY = 20)
    (§ def- Type OBJECT_TYPE)
    (§ def- Type KEYWORD_TYPE = Type.getType(Keyword.class))
    (§ def- Type VAR_TYPE = Type.getType(Var.class))
    (§ def- Type SYMBOL_TYPE = Type.getType(Symbol.class))
    (§ def- Type IFN_TYPE = Type.getType(IFn.class))
    (§ def- Type AFUNCTION_TYPE = Type.getType(AFunction.class))
    (§ def- Type RT_TYPE = Type.getType(RT.class))
    (§ def- Type NUMBERS_TYPE = Type.getType(Numbers.class))

    (§ def Type CLASS_TYPE = Type.getType(Class.class))
    (§ def Type NS_TYPE = Type.getType(Namespace.class))
    (§ def Type UTIL_TYPE = Type.getType(Util.class))
    (§ def Type REFLECTOR_TYPE = Type.getType(Reflector.class))
    (§ def Type THROWABLE_TYPE = Type.getType(Throwable.class))
    (§ def Type BOOLEAN_OBJECT_TYPE = Type.getType(Boolean.class))
    (§ def Type IPERSISTENTMAP_TYPE = Type.getType(IPersistentMap.class))
    (§ def Type IOBJ_TYPE = Type.getType(IObj.class))
    (§ def Type TUPLE_TYPE = Type.getType(Tuple.class))

    (§ def Method[] createTupleMethods =
    (§ array
        (ß Method.getMethod("cloiure.lang.IPersistentVector create()")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)"))
    ))

    (§ def- Type[][] ARG_TYPES)
    (§ def- Type[] EXCEPTION_TYPES = (§))

    (§ static
        (ß OBJECT_TYPE = Type.getType(Object.class))
        (ß ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][])
        (§ loop-when-recur [(ß int i = 0)] (ß i <= MAX_POSITIONAL_ARITY) [(ß ++i)]
            (§ let Type[] a = new Type[i])
            (§ loop-when-recur [(ß int j = 0)] (ß j < i) [(ß j++)]
                (ß a[j] = OBJECT_TYPE)
            )
            (ß ARG_TYPES[i] = a)
        )
        (§ let Type[] a = new Type[MAX_POSITIONAL_ARITY + 1])
        (§ loop-when-recur [(ß int j = 0)] (ß j < MAX_POSITIONAL_ARITY) [(ß j++)]
            (ß a[j] = OBJECT_TYPE)
        )
        (ß a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/Object;"))
        (ß ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a)
    )

    ;; symbol->localbinding
    (§ def Var LOCAL_ENV = Var.create(nil).setDynamic())

    ;; vector<localbinding>
    (§ def Var LOOP_LOCALS = Var.create().setDynamic())

    ;; Label
    (§ def Var LOOP_LABEL = Var.create().setDynamic())

    ;; vector<object>
    (§ def Var CONSTANTS = Var.create().setDynamic())

    ;; IdentityHashMap
    (§ def Var CONSTANT_IDS = Var.create().setDynamic())

    ;; vector<keyword>
    (§ def Var KEYWORD_CALLSITES = Var.create().setDynamic())

    ;; vector<var>
    (§ def Var PROTOCOL_CALLSITES = Var.create().setDynamic())

    ;; set<var>
    (§ def Var VAR_CALLSITES = Var.create().setDynamic())

    ;; keyword->constid
    (§ def Var KEYWORDS = Var.create().setDynamic())

    ;; var->constid
    (§ def Var VARS = Var.create().setDynamic())

    ;; FnFrame
    (§ def Var METHOD = Var.create(nil).setDynamic())

    ;; nil or not
    (§ def Var IN_CATCH_FINALLY = Var.create(nil).setDynamic())

    (§ def Var METHOD_RETURN_CONTEXT = Var.create(nil).setDynamic())

    (§ def Var NO_RECUR = Var.create(nil).setDynamic())

    ;; DynamicClassLoader
    (§ def Var LOADER = Var.create().setDynamic())

    ;; String
    (§ def Var SOURCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic())

    ;; String
    (§ def Var SOURCE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic())

    ;; String
    (§ def Var COMPILE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), nil).setDynamic())
    ;; boolean
    (§ def Var COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic())

    (§ def Var INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?")))

    (§ def Var ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations")))

    (§ def Keyword disableLocalsClearingKey = Keyword.intern("disable-locals-clearing"))
    (§ def Keyword directLinkingKey = Keyword.intern("direct-linking"))
    (§ def Keyword elideMetaKey = Keyword.intern("elide-meta"))

    (§ def Var COMPILER_OPTIONS)

    (§ defn Object getCompilerOption(Keyword k)
        (ß RT.get(COMPILER_OPTIONS.deref(), k))
    )

    (§ static
        (§ let Object compilerOptions = nil)

        (§ doseq [#_"Map.Entry" e (ß System.getProperties().entrySet())]
            (§ let String name = (String) e.getKey())
            (§ let String v = (String) e.getValue())
            (§ if (ß name.startsWith("cloiure.compiler."))
                (ß compilerOptions = RT.assoc(compilerOptions, RT.keyword(nil, name.substring(1 + name.lastIndexOf(\.))), RT.readString(v)))
            )
        )

        (ß COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic())
    )

    (§ defn Object elideMeta(Object m)
        (§ let Collection<Object> elides = (Collection<Object>) getCompilerOption(elideMetaKey))
        (§ if (ß elides != nil)
            (§ doseq [#_"Object" k elides]
                (ß m = RT.dissoc(m, k))
            )
        )
        m
    )

    ;; Integer
    (§ def Var LINE = Var.create(0).setDynamic())
    (§ def Var COLUMN = Var.create(0).setDynamic())

    (§ defn int lineDeref()
        (ß ((Number)LINE.deref()).intValue())
    )

    (§ defn int columnDeref()
        (ß ((Number)COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def Var LINE_BEFORE = Var.create(0).setDynamic())
    (§ def Var COLUMN_BEFORE = Var.create(0).setDynamic())
    (§ def Var LINE_AFTER = Var.create(0).setDynamic())
    (§ def Var COLUMN_AFTER = Var.create(0).setDynamic())

    ;; Integer
    (§ def Var NEXT_LOCAL_NUM = Var.create(0).setDynamic())

    ;; Integer
    (§ def Var RET_LOCAL_NUM = Var.create().setDynamic())

    (§ def Var COMPILE_STUB_SYM = Var.create(nil).setDynamic())
    (§ def Var COMPILE_STUB_CLASS = Var.create(nil).setDynamic())

    ;; PathNode chain
    (§ def Var CLEAR_PATH = Var.create(nil).setDynamic())

    ;; tail of PathNode chain
    (§ def Var CLEAR_ROOT = Var.create(nil).setDynamic())

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def Var CLEAR_SITES = Var.create(nil).setDynamic())

    #_non-static
    (§ enum C
        (§ item STATEMENT), ;; value ignored
        (§ item EXPRESSION), ;; value required
        (§ item RETURN), ;; tail position relative to enclosing recur frame
        (§ item EVAL)
    )

    #_private
    #_non-static
    (class-ns Recur
    )

    (§ def Class RECUR_CLASS = Recur.class)

    #_non-static
    (§ interface Expr
        (§ abstract Object eval())
        (§ abstract void emit(C context, ObjExpr objx, GeneratorAdapter gen))
        (§ abstract boolean hasJavaClass())
        (§ abstract Class getJavaClass())
    )

    #_abstract
    (class-ns UntypedExpr (§ implements Expr)
        (§ method Class getJavaClass()
            (§ throw new IllegalArgumentException("Has no Java class"))
        )

        (§ method boolean hasJavaClass()
            false
        )
    )

    #_non-static
    (§ interface IParser
        (§ abstract Expr parse(C context, Object form))
    )

    (§ defn boolean isSpecial(Object sym)
        (ß specials.containsKey(sym))
    )

    (§ defn boolean inTailCall(C context)
        (ß (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil))
    )

    (§ defn Symbol resolveSymbol(Symbol sym)
        ;; already qualified or classname?
        (§ if (ß sym.name.indexOf(\.) > 0)
            (§ return sym)
        )
        (§ if (ß sym.ns != nil)
            (§ let Namespace ns = namespaceFor(sym))
            (§ if (ß ns == nil || ((ns.name.name == nil) ? (sym.ns == nil) :or ns.name.name.equals(sym.ns)))
                (§ return sym)
            )
            (§ return (ß Symbol.intern(ns.name.name, sym.name)))
        )
        (§ let Object o = currentNS().getMapping(sym))
        (§ if (ß o == nil)
            (§ return (ß Symbol.intern(currentNS().name.name, sym.name)))
        )
        (§ elseif (ß o instanceof Class)
            (§ return (ß Symbol.intern(nil, ((Class) o).getName())))
        )
        (§ elseif (ß o instanceof Var)
            (§ let Var v = (Var) o)
            (§ return (ß Symbol.intern(v.ns.name.name, v.sym.name)))
        )
        nil
    )

    (class-ns DefExpr (§ implements Expr)
        (§ field Var var)
        (§ field Expr init)
        (§ field Expr meta)
        (§ field boolean initProvided)
        (§ field boolean isDynamic)
        (§ field boolean shadowsCoreMapping)
        (§ field String source)
        (§ field int line)
        (§ field int column)

        (§ def Method bindRootMethod = Method.getMethod("void bindRoot(Object)"))
        (§ def Method setTagMethod = Method.getMethod("void setTag(cloiure.lang.Symbol)"))
        (§ def Method setMetaMethod = Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)"))
        (§ def Method setDynamicMethod = Method.getMethod("cloiure.lang.Var setDynamic(boolean)"))
        (§ def Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String, String)"))
        (§ def Method internVar = Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

        (§ constructor DefExpr(String source, int line, int column, Var var, Expr init, Expr meta, boolean initProvided, boolean isDynamic, boolean shadowsCoreMapping)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.var = var)
            (ß this.init = init)
            (ß this.meta = meta)
            (ß this.isDynamic = isDynamic)
            (ß this.shadowsCoreMapping = shadowsCoreMapping)
            (ß this.initProvided = initProvided)
            this
        )

        (§ method- boolean includesExplicitMetadata(MapExpr expr)
            (§ loop-when-recur [(ß int i = 0)] (ß i < expr.keyvals.count()) [(ß i += 2)]
                (§ let Keyword k = ((KeywordExpr) expr.keyvals.nth(i)).k)
                (§ if (ß (k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY))
                    (§ return true)
                )
            )
            false
        )

        (§ method Object eval()
            (§ try 
                (§ if (ß initProvided)
                    (ß var.bindRoot(init.eval()))
                )
                (§ if (ß meta != nil)
                    (§ let IPersistentMap metaMap = (IPersistentMap) meta.eval())
                    (§ if (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                        (ß var.setMeta(metaMap))
                    )
                )
                (ß var.setDynamic(isDynamic))
            )
            (§ catch (ß Throwable e)
                (§ if (ß !(e instanceof CompilerException))
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else 
                    (§ throw (ß (CompilerException) e))
                )
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitVar(gen, var))

            (§ if (ß shadowsCoreMapping)
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "ns", NS_TYPE))
                (ß gen.swap())
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE))
                (ß gen.swap())
                (ß gen.invokeVirtual(NS_TYPE, internVar))
            )

            (§ if (ß isDynamic)
                (ß gen.push(isDynamic))
                (ß gen.invokeVirtual(VAR_TYPE, setDynamicMethod))
            )
            (§ if (ß meta != nil)
                (§ if (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                    (ß gen.dup())
                    (ß meta.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                    (ß gen.invokeVirtual(VAR_TYPE, setMetaMethod))
                )
            )
            (§ if (ß initProvided)
                (ß gen.dup())
                (§ if (ß init instanceof FnExpr)
                    (ß ((FnExpr)init).emitForDefn(objx, gen))
                )
                (§ else 
                    (ß init.emit(C.EXPRESSION, objx, gen))
                )
                (ß gen.invokeVirtual(VAR_TYPE, bindRootMethod))
            )

            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Var.class)
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                (§ let String docstring = nil)
                (§ if (ß RT.count(form) == 4 && (RT.third(form) instanceof String))
                    (ß docstring = (String) RT.third(form))
                    (ß form = RT.list(RT.first(form), RT.second(form), RT.fourth(form)))
                )
                (§ if (ß RT.count(form) > 3)
                    (§ throw Util.runtimeException("Too many arguments to def"))
                )
                (§ elseif (ß RT.count(form) < 2)
                    (§ throw Util.runtimeException("Too few arguments to def"))
                )
                (§ elseif (ß !(RT.second(form) instanceof Symbol))
                    (§ throw Util.runtimeException("First argument to def must be a Symbol"))
                )
                (§ let Symbol sym = (Symbol) RT.second(form))
                (§ let Var v = lookupVar(sym, true))
                (§ if (ß v == nil)
                    (§ throw Util.runtimeException("Can't refer to qualified var that doesn't exist"))
                )
                (§ let boolean shadowsCoreMapping = false)
                (§ if (ß !v.ns.equals(currentNS()))
                    (§ if (ß sym.ns == nil)
                        (ß v = currentNS().intern(sym))
                        (ß shadowsCoreMapping = true)
                        (ß registerVar(v))
                    )
                    (§ else 
                        (§ throw Util.runtimeException("Can't create defs outside of current ns"))
                    )
                )
                (§ let IPersistentMap mm = sym.meta())
                (§ let boolean isDynamic = RT.booleanCast(RT.get(mm, dynamicKey)))
                (§ if (ß isDynamic)
                    (ß v.setDynamic())
                )
                (§ if (ß !isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2)
                    (ß RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", sym, SOURCE_PATH.get(), LINE.get()))
                )
                (§ if (ß RT.booleanCast(RT.get(mm, arglistsKey)))
                    (§ let IPersistentMap vm = v.meta())
                    ;; drop quote
                    (ß vm = (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey))))
                    (ß v.setMeta(vm))
                )
                (§ let Object source_path = SOURCE_PATH.get())
                (ß source_path = (source_path == nil) ? "NO_SOURCE_FILE" :or source_path)
                (ß mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path))
                (§ if (ß docstring != nil)
                    (ß mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring))
                )
                (ß mm = (IPersistentMap) elideMeta(mm))
                (§ let Expr meta = (mm.count() == 0) ? nil :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm))
                (ß new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name), meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping))
            )
        )
    )

    (class-ns AssignExpr (§ implements Expr)
        (§ field AssignableExpr target)
        (§ field Expr val)

        (§ constructor AssignExpr(AssignableExpr target, Expr val)
            (ß this.target = target)
            (ß this.val = val)
            this
        )

        (§ method Object eval()
            (ß target.evalAssign(val))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß target.emitAssign(context, objx, gen, val))
            nil
        )

        (§ method boolean hasJavaClass()
            (ß val.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß val.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                (§ if (ß RT.length(form) != 3)
                    (§ throw new IllegalArgumentException("Malformed assignment, expecting (set! target val)"))
                )
                (§ let Expr target = analyze(C.EXPRESSION, RT.second(form)))
                (§ if (ß !(target instanceof AssignableExpr))
                    (§ throw new IllegalArgumentException("Invalid assignment target"))
                )
                (ß new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form))))
            )
        )
    )

    (class-ns VarExpr (§ implements Expr, AssignableExpr)
        (§ field Var var)
        (§ field Object tag)
        (§ def Method getMethod = Method.getMethod("Object get()"))
        (§ def Method setMethod = Method.getMethod("Object set(Object)"))

        (§ field Class jc)

        (§ constructor VarExpr(Var var, Symbol tag)
            (ß this.var = var)
            (ß this.tag = (tag != nil) ? tag :or var.getTag())
            this
        )

        (§ method Object eval()
            (ß var.deref())
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitVarValue(gen, var))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil))
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )

        (§ method Object evalAssign(Expr val)
            (ß var.set(val.eval()))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (ß objx.emitVar(gen, var))
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeVirtual(VAR_TYPE, setMethod))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns TheVarExpr (§ implements Expr)
        (§ field Var var)

        (§ constructor TheVarExpr(Var var)
            (ß this.var = var)
            this
        )

        (§ method Object eval()
            var
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitVar(gen, var))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Var.class)
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (§ let Symbol sym = (Symbol) RT.second(form))
                (§ let Var v = lookupVar(sym, false))
                (§ if (ß v != nil)
                    (§ return (ß new TheVarExpr(v)))
                )
                (§ throw Util.runtimeException("Unable to resolve var: " + sym + " in this context"))
            )
        )
    )

    (class-ns KeywordExpr (§ extends LiteralExpr)
        (§ field Keyword k)

        (§ constructor KeywordExpr(Keyword k)
            (ß this.k = k)
            this
        )

        (§ method Object val()
            k
        )

        (§ method Object eval()
            k
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitKeyword(gen, k))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Keyword.class)
        )
    )

    (class-ns ImportExpr (§ implements Expr)
        (§ field String c)

        (§ def Method forNameMethod = Method.getMethod("Class classForNameNonLoading(String)"))
        (§ def Method importClassMethod = Method.getMethod("Class importClass(Class)"))
        (§ def Method derefMethod = Method.getMethod("Object deref()"))

        (§ constructor ImportExpr(String c)
            (ß this.c = c)
            this
        )

        (§ method Object eval()
            (§ let Namespace ns = (Namespace) RT.CURRENT_NS.deref())
            (ß ns.importClass(RT.classForNameNonLoading(c)))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE))
            (ß gen.invokeVirtual(VAR_TYPE, derefMethod))
            (ß gen.checkCast(NS_TYPE))
            (ß gen.push(c))
            (ß gen.invokeStatic(RT_TYPE, forNameMethod))
            (ß gen.invokeVirtual(NS_TYPE, importClassMethod))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            false
        )

        (§ method Class getJavaClass()
            (§ throw new IllegalArgumentException("ImportExpr has no Java class"))
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (ß new ImportExpr((String) RT.second(form)))
            )
        )
    )

    #_abstract
    (class-ns LiteralExpr (§ implements Expr)
        (§ abstract Object val())

        (§ method Object eval()
            (ß val())
        )
    )

    (§ interface AssignableExpr
        (§ abstract Object evalAssign(Expr val))
        (§ abstract void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val))
    )

    (§ interface MaybePrimitiveExpr (§ extends Expr)
        (§ abstract boolean canEmitPrimitive())
        (§ abstract void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen))
    )

    #_abstract
    (class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ def Type BOOLEAN_TYPE = Type.getType(Boolean.class))
        (§ def Type CHAR_TYPE = Type.getType(Character.class))
        (§ def Type INTEGER_TYPE = Type.getType(Integer.class))
        (§ def Type LONG_TYPE = Type.getType(Long.class))
        (§ def Type FLOAT_TYPE = Type.getType(Float.class))
        (§ def Type DOUBLE_TYPE = Type.getType(Double.class))
        (§ def Type SHORT_TYPE = Type.getType(Short.class))
        (§ def Type BYTE_TYPE = Type.getType(Byte.class))
        (§ def Type NUMBER_TYPE = Type.getType(Number.class))

        (§ def Method charValueMethod = Method.getMethod("char charValue()"))
        (§ def Method booleanValueMethod = Method.getMethod("boolean booleanValue()"))

        (§ def Method charValueOfMethod = Method.getMethod("Character valueOf(char)"))
        (§ def Method intValueOfMethod = Method.getMethod("Integer valueOf(int)"))
        (§ def Method longValueOfMethod = Method.getMethod("Long valueOf(long)"))
        (§ def Method floatValueOfMethod = Method.getMethod("Float valueOf(float)"))
        (§ def Method doubleValueOfMethod = Method.getMethod("Double valueOf(double)"))
        (§ def Method shortValueOfMethod = Method.getMethod("Short valueOf(short)"))
        (§ def Method byteValueOfMethod = Method.getMethod("Byte valueOf(byte)"))

        (§ def Method intValueMethod = Method.getMethod("int intValue()"))
        (§ def Method longValueMethod = Method.getMethod("long longValue()"))
        (§ def Method floatValueMethod = Method.getMethod("float floatValue()"))
        (§ def Method doubleValueMethod = Method.getMethod("double doubleValue()"))
        (§ def Method byteValueMethod = Method.getMethod("byte byteValue()"))
        (§ def Method shortValueMethod = Method.getMethod("short shortValue()"))

        (§ def Method fromIntMethod = Method.getMethod("cloiure.lang.Num from(int)"))
        (§ def Method fromLongMethod = Method.getMethod("cloiure.lang.Num from(long)"))
        (§ def Method fromDoubleMethod = Method.getMethod("cloiure.lang.Num from(double)"))

        (§ defn void emitBoxReturn(ObjExpr objx, GeneratorAdapter gen, Class returnType)
            (§ if (ß returnType.isPrimitive())
                (§ if (ß returnType == boolean.class)
                    (§ let Label falseLabel = gen.newLabel())
                    (§ let Label endLabel = gen.newLabel())
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, falseLabel))
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                    (ß gen.goTo(endLabel))
                    (ß gen.mark(falseLabel))
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                    (ß gen.mark(endLabel))
                )
                (§ elseif (ß returnType == void.class)
                    (ß NIL_EXPR.emit(C.EXPRESSION, objx, gen))
                )
                (§ elseif (ß returnType == char.class)
                    (ß gen.invokeStatic(CHAR_TYPE, charValueOfMethod))
                )
                (§ else 
                    (§ if (ß returnType == int.class)
                        (ß gen.invokeStatic(INTEGER_TYPE, intValueOfMethod))
                    )
                    (§ elseif (ß returnType == float.class)
                        (ß gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod))
                    )
                    (§ elseif (ß returnType == double.class)
                        (ß gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod))
                    )
                    (§ elseif (ß returnType == long.class)
                        (ß gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)")))
                    )
                    (§ elseif (ß returnType == byte.class)
                        (ß gen.invokeStatic(BYTE_TYPE, byteValueOfMethod))
                    )
                    (§ elseif (ß returnType == short.class)
                        (ß gen.invokeStatic(SHORT_TYPE, shortValueOfMethod))
                    )
                )
            )
            nil
        )

        (§ defn void emitUnboxArg(ObjExpr objx, GeneratorAdapter gen, Class paramType)
            (§ if (ß paramType.isPrimitive())
                (§ if (ß paramType == boolean.class)
                    (ß gen.checkCast(BOOLEAN_TYPE))
                    (ß gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod))
                )
                (§ elseif (ß paramType == char.class)
                    (ß gen.checkCast(CHAR_TYPE))
                    (ß gen.invokeVirtual(CHAR_TYPE, charValueMethod))
                )
                (§ else 
                    (§ let Method m = nil)
                    (ß gen.checkCast(NUMBER_TYPE))
                    (§ if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                        (§ if (ß paramType == int.class)
                            (ß m = Method.getMethod("int uncheckedIntCast(Object)"))
                        )
                        (§ elseif (ß paramType == float.class)
                            (ß m = Method.getMethod("float uncheckedFloatCast(Object)"))
                        )
                        (§ elseif (ß paramType == double.class)
                            (ß m = Method.getMethod("double uncheckedDoubleCast(Object)"))
                        )
                        (§ elseif (ß paramType == long.class)
                            (ß m = Method.getMethod("long uncheckedLongCast(Object)"))
                        )
                        (§ elseif (ß paramType == byte.class)
                            (ß m = Method.getMethod("byte uncheckedByteCast(Object)"))
                        )
                        (§ elseif (ß paramType == short.class)
                            (ß m = Method.getMethod("short uncheckedShortCast(Object)"))
                        )
                    )
                    (§ else 
                        (§ if (ß paramType == int.class)
                            (ß m = Method.getMethod("int intCast(Object)"))
                        )
                        (§ elseif (ß paramType == float.class)
                            (ß m = Method.getMethod("float floatCast(Object)"))
                        )
                        (§ elseif (ß paramType == double.class)
                            (ß m = Method.getMethod("double doubleCast(Object)"))
                        )
                        (§ elseif (ß paramType == long.class)
                            (ß m = Method.getMethod("long longCast(Object)"))
                        )
                        (§ elseif (ß paramType == byte.class)
                            (ß m = Method.getMethod("byte byteCast(Object)"))
                        )
                        (§ elseif (ß paramType == short.class)
                            (ß m = Method.getMethod("short shortCast(Object)"))
                        )
                    )
                    (ß gen.invokeStatic(RT_TYPE, m))
                )
            )
            (§ else 
                (ß gen.checkCast(Type.getType(paramType)))
            )
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (. x fieldname-sym) or
                ;; (. x 0-ary-method)
                ;; (. x methodname-sym args+)
                ;; (. x (methodname-sym args?))
                (§ if (ß RT.length(form) < 3)
                    (§ throw new IllegalArgumentException("Malformed member expression, expecting (. target member ...)"))
                )
                ;; determine static or instance
                ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                (§ let int line = lineDeref())
                (§ let int column = columnDeref())
                (§ let String source = (String) SOURCE.deref())
                (§ let Class c = maybeClass(RT.second(form), false))
                ;; at this point c will be non-null if static
                (§ let Expr instance = nil)
                (§ if (ß c == nil)
                    (ß instance = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))
                )

                (§ let boolean maybeField = (RT.length(form) == 3) && (RT.third(form) instanceof Symbol))

                (§ if (ß maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == \-))
                    (§ let Symbol sym = (Symbol) RT.third(form))
                    (§ if (ß c != nil)
                        (ß maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0)
                    )
                    (§ elseif (ß instance != nil && instance.hasJavaClass() && instance.getJavaClass() != nil)
                        (ß maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0)
                    )
                )

                (§ if (ß maybeField) ;; field
                    (§ let Symbol sym = (((Symbol)RT.third(form)).name.charAt(0) == \-) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form))
                    (§ let Symbol tag = tagOf(form))
                    (§ if (ß c != nil)
                        (ß new StaticFieldExpr(line, column, c, munge(sym.name), tag))
                    )
                    (§ else 
                        (ß new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == \-)))
                    )
                )
                (§ else 
                    (§ let ISeq call = (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form))))
                    (§ if (ß !(RT.first(call) instanceof Symbol))
                        (§ throw new IllegalArgumentException("Malformed member expression"))
                    )
                    (§ let Symbol sym = (Symbol) RT.first(call))
                    (§ let Symbol tag = tagOf(form))
                    (§ let PersistentVector args = PersistentVector.EMPTY)
                    (§ let boolean tailPosition = inTailCall(context))
                    (§ loop-when-recur [(ß ISeq s = RT.next(call))] (ß s != nil) [(ß s = s.next())]
                        (ß args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                    )
                    (§ if (ß c != nil)
                        (ß new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition))
                    )
                    (§ else 
                        (ß new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition))
                    )
                )
            )
        )

        (§ defn Class maybeClass(Object form, boolean stringOk)
            (§ if (ß form instanceof Class)
                (§ return (ß (Class) form))
            )
            (§ let Class c = nil)
            (§ if (ß form instanceof Symbol)
                (§ let Symbol sym = (Symbol) form)
                (§ if (ß sym.ns == nil) ;; if ns-qualified can't be classname
                    (§ if (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                        (§ return (ß (Class) COMPILE_STUB_CLASS.get()))
                    )
                    (§ if (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
                        (ß c = RT.classForNameNonLoading(sym.name))
                    )
                    (§ else 
                        (§ let Object o = currentNS().getMapping(sym))
                        (§ if (ß o instanceof Class)
                            (ß c = (Class) o)
                        )
                        (§ elseif (ß LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form))
                            (§ return nil)
                        )
                        (§ else 
                            (§ try 
                                (ß c = RT.classForNameNonLoading(sym.name))
                            )
                            (§ catch (ß Exception e)
                                ;; aargh
                                ;; leave c set to nil -> return nil
                            )
                        )
                    )
                )
            )
            (§ elseif (ß stringOk && form instanceof String)
                (ß c = RT.classForNameNonLoading((String) form))
            )
            c
        )

        (§ defn Class maybeSpecialTag(Symbol sym)
            (§ let Class c = primClass(sym))
            (§ if (ß c != nil)
                (§ return c)
            )
            (§ elseif (ß sym.name.equals("objects"))
                (ß c = Object[].class)
            )
            (§ elseif (ß sym.name.equals("ints"))
                (ß c = int[].class)
            )
            (§ elseif (ß sym.name.equals("longs"))
                (ß c = long[].class)
            )
            (§ elseif (ß sym.name.equals("floats"))
                (ß c = float[].class)
            )
            (§ elseif (ß sym.name.equals("doubles"))
                (ß c = double[].class)
            )
            (§ elseif (ß sym.name.equals("chars"))
                (ß c = char[].class)
            )
            (§ elseif (ß sym.name.equals("shorts"))
                (ß c = short[].class)
            )
            (§ elseif (ß sym.name.equals("bytes"))
                (ß c = byte[].class)
            )
            (§ elseif (ß sym.name.equals("booleans"))
                (ß c = boolean[].class)
            )
            c
        )

        (§ defn Class tagToClass(Object tag)
            (§ let Class c = nil)
            (§ if (ß tag instanceof Symbol)
                (§ let Symbol sym = (Symbol) tag)
                (§ if (ß sym.ns == nil) ;; if ns-qualified can't be classname
                    (ß c = maybeSpecialTag(sym))
                )
            )
            (§ if (ß c == nil)
                (ß c = maybeClass(tag, true))
            )
            (§ if (ß c != nil)
                (§ return c)
            )
            (§ throw new IllegalArgumentException("Unable to resolve classname: " + tag))
        )
    )

    #_abstract
    (class-ns FieldExpr (§ extends HostExpr)
    )

    (class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ field Expr target)
        (§ field Class targetClass)
        (§ field java.lang.reflect.Field field)
        (§ field String fieldName)
        (§ field int line)
        (§ field int column)
        (§ field Symbol tag)
        (§ field boolean requireField)

        (§ def Method invokeNoArgInstanceMember = Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)"))
        (§ def Method setInstanceFieldMethod = Method.getMethod("Object setInstanceField(Object,String,Object)"))

        (§ field Class jc)

        (§ constructor InstanceFieldExpr(int line, int column, Expr target, String fieldName, Symbol tag, boolean requireField)
            (ß this.target = target)
            (ß this.targetClass = target.hasJavaClass() ? target.getJavaClass() :or nil)
            (ß this.field = (targetClass != nil) ? Reflector.getField(targetClass, fieldName, false) :or nil)
            (ß this.fieldName = fieldName)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.requireField = requireField)

            (§ if (ß field == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (§ if (ß targetClass == nil)
                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName))
                )
                (§ else 
                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName()))
                )
            )
            this
        )

        (§ method Object eval()
            (ß Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField))
        )

        (§ method boolean canEmitPrimitive()
            (ß (targetClass != nil && field != nil && Util.isPrimitive(field.getType())))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß targetClass != nil && field != nil)
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.checkCast(getType(targetClass)))
                (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
            )
            (§ else 
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß targetClass != nil && field != nil)
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.checkCast(getType(targetClass)))
                (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
                (§ if (ß context == C.STATEMENT)
                    (ß gen.pop())
                )
            )
            (§ else 
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.push(fieldName))
                (ß gen.push(requireField))
                (ß gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember))
                (§ if (ß context == C.STATEMENT)
                    (ß gen.pop())
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (field != nil || tag != nil))
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            jc
        )

        (§ method Object evalAssign(Expr val)
            (ß Reflector.setInstanceField(target.eval(), fieldName, val.eval()))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (§ if (ß targetClass != nil && field != nil)
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.checkCast(getType(targetClass)))
                (ß val.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.dupX1())
                (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
                (ß gen.putField(getType(targetClass), fieldName, Type.getType(field.getType())))
            )
            (§ else 
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.push(fieldName))
                (ß val.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ field String fieldName)
        (§ field Class c)
        (§ field java.lang.reflect.Field field)
        (§ field Symbol tag)

        (§ field int line)
        (§ field int column)

        (§ field Class jc)

        (§ constructor StaticFieldExpr(int line, int column, Class c, String fieldName, Symbol tag)
            (ß this.fieldName = fieldName)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.c = c)
            (§ try 
                (ß field = c.getField(fieldName))
            )
            (§ catch (ß NoSuchFieldException e)
                (§ throw Util.sneakyThrow(e))
            )
            (ß this.tag = tag)
            this
        )

        (§ method Object eval()
            (ß Reflector.getStaticField(c, fieldName))
        )

        (§ method boolean canEmitPrimitive()
            (ß Util.isPrimitive(field.getType()))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.visitLineNumber(line, gen.mark()))

            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            jc
        )

        (§ method Object evalAssign(Expr val)
            (ß Reflector.setStaticField(c, fieldName, val.eval()))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.dup())
            (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
            (ß gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (§ defn Class maybePrimitiveType(Expr e)
        (§ if (ß e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
            (§ let Class c = e.getJavaClass())
            (§ if (ß Util.isPrimitive(c))
                (§ return c)
            )
        )
        nil
    )

    (§ defn Class maybeJavaClass(Collection<Expr> exprs)
        (§ let Class match = nil)
        (§ try 
            (§ doseq [#_"Expr" e exprs]
                (§ if (ß e instanceof ThrowExpr)
                    (§ continue )
                )
                (§ if (ß !e.hasJavaClass())
                    (§ return nil)
                )
                (§ let Class c = e.getJavaClass())
                (§ if (ß match == nil)
                    (ß match = c)
                )
                (§ elseif (ß match != c)
                    (§ return nil)
                )
            )
        )
        (§ catch (ß Exception e)
            (§ return nil)
        )
        match
    )

    #_abstract
    (class-ns MethodExpr (§ extends HostExpr)
        (§ defn void emitArgsAsArray(IPersistentVector args, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.push(args.count()))
            (ß gen.newArray(OBJECT_TYPE))
            (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (ß gen.dup())
                (ß gen.push(i))
                (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                (ß gen.arrayStore(OBJECT_TYPE))
            )
            nil
        )

        (§ defn void emitTypedArgs(ObjExpr objx, GeneratorAdapter gen, Class[] parameterTypes, IPersistentVector args)
            (§ loop-when-recur [(ß int i = 0)] (ß i < parameterTypes.length) [(ß i++)]
                (§ let Expr e = (Expr) args.nth(i))
                (§ try 
                    (§ let Class primc = maybePrimitiveType(e))
                    (§ if (ß primc == parameterTypes[i])
                        (§ let MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                    )
                    (§ elseif (ß primc == int.class && parameterTypes[i] == long.class)
                        (§ let MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.visitInsn(I2L))
                    )
                    (§ elseif (ß primc == long.class && parameterTypes[i] == int.class)
                        (§ let MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (§ if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)")))
                        )
                        (§ else 
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                        )
                    )
                    (§ elseif (ß primc == float.class && parameterTypes[i] == double.class)
                        (§ let MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.visitInsn(F2D))
                    )
                    (§ elseif (ß primc == double.class && parameterTypes[i] == float.class)
                        (§ let MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.visitInsn(D2F))
                    )
                    (§ else 
                        (ß e.emit(C.EXPRESSION, objx, gen))
                        (ß HostExpr.emitUnboxArg(objx, gen, parameterTypes[i]))
                    )
                )
                (§ catch (ß Exception e1)
                    (§ throw Util.sneakyThrow(e1))
                )
            )
            nil
        )
    )

    (class-ns InstanceMethodExpr (§ extends MethodExpr)
        (§ field Expr target)
        (§ field String methodName)
        (§ field IPersistentVector args)
        (§ field String source)
        (§ field int line)
        (§ field int column)
        (§ field Symbol tag)
        (§ field boolean tailPosition)
        (§ field java.lang.reflect.Method method)

        (§ field Class jc)

        (§ def Method invokeInstanceMethodMethod = Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])"))

        (§ constructor InstanceMethodExpr(String source, int line, int column, Symbol tag, Expr target, String methodName, IPersistentVector args, boolean tailPosition)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.args = args)
            (ß this.methodName = methodName)
            (ß this.target = target)
            (ß this.tag = tag)
            (ß this.tailPosition = tailPosition)
            (§ if (ß target.hasJavaClass() && target.getJavaClass() != nil)
                (§ let List methods = Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false))
                (§ if (ß methods.isEmpty())
                    (ß method = nil)
                    (§ if (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName()))
                    )
                )
                (§ else 
                    (§ let int methodidx = 0)
                    (§ if (ß methods.size() > 1)
                        (§ let ArrayList<Class[]> params = new ArrayList())
                        (§ let ArrayList<Class> rets = new ArrayList())
                        (§ loop-when-recur [(ß int i = 0)] (ß i < methods.size()) [(ß i++)]
                            (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))
                            (ß params.add(m.getParameterTypes()))
                            (ß rets.add(m.getReturnType()))
                        )
                        (ß methodidx = getMatchingParams(methodName, params, args, rets))
                    )
                    (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))
                    (§ if (ß m != nil && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                        ;; public method of non-public class, try to find it in hierarchy
                        (ß m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m))
                    )
                    (ß method = m)
                    (§ if (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args)))
                    )
                )
            )
            (§ else 
                (ß method = nil)
                (§ if (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), line, column, methodName))
                )
            )
            this
        )

        (§ method Object eval()
            (§ try 
                (§ let Object targetval = target.eval())
                (§ let Object[] argvals = new Object[args.count()])
                (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß argvals[i] = ((Expr) args.nth(i)).eval())
                )
                (§ if (ß method != nil)
                    (§ let LinkedList ms = new LinkedList())
                    (ß ms.add(method))
                    (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)))
                )
                (ß Reflector.invokeInstanceMethod(targetval, methodName, argvals))
            )
            (§ catch (ß Throwable e)
                (§ if (ß !(e instanceof CompilerException))
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else 
                    (§ throw (ß (CompilerException) e))
                )
            )
        )

        (§ method boolean canEmitPrimitive()
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß method != nil)
                (§ let Type type = Type.getType(method.getDeclaringClass()))
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.checkCast(type))
                (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (ß gen.visitLineNumber(line, gen.mark()))
                (§ if (ß tailPosition && !objx.canBeDirect)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearThis(gen))
                )
                (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                (§ if (ß method.getDeclaringClass().isInterface())
                    (ß gen.invokeInterface(type, m))
                )
                (§ else 
                    (ß gen.invokeVirtual(type, m))
                )
            )
            (§ else 
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß method != nil)
                (§ let Type type = Type.getType(method.getDeclaringClass()))
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.checkCast(type))
                (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (ß gen.visitLineNumber(line, gen.mark()))
                (§ if (ß context == C.RETURN)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearLocals(gen))
                )
                (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                (§ if (ß method.getDeclaringClass().isInterface())
                    (ß gen.invokeInterface(type, m))
                )
                (§ else 
                    (ß gen.invokeVirtual(type, m))
                )
                (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
            )
            (§ else 
                (ß target.emit(C.EXPRESSION, objx, gen))
                (ß gen.push(methodName))
                (ß emitArgsAsArray(args, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (§ if (ß context == C.RETURN)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearLocals(gen))
                )
                (ß gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (method != nil || tag != nil))
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            jc
        )
    )

    (class-ns StaticMethodExpr (§ extends MethodExpr)
        (§ field Class c)
        (§ field String methodName)
        (§ field IPersistentVector args)
        (§ field String source)
        (§ field int line)
        (§ field int column)
        (§ field java.lang.reflect.Method method)
        (§ field Symbol tag)
        (§ field boolean tailPosition)

        (§ def Method forNameMethod = Method.getMethod("Class classForName(String)"))
        (§ def Method invokeStaticMethodMethod = Method.getMethod("Object invokeStaticMethod(Class,String,Object[])"))
        (§ def Keyword warnOnBoxedKeyword = Keyword.intern("warn-on-boxed"))

        (§ field Class jc)

        (§ constructor StaticMethodExpr(String source, int line, int column, Symbol tag, Class c, String methodName, IPersistentVector args, boolean tailPosition)
            (ß this.c = c)
            (ß this.methodName = methodName)
            (ß this.args = args)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.tailPosition = tailPosition)

            (§ let List methods = Reflector.getMethods(c, args.count(), methodName, true))
            (§ if (ß methods.isEmpty())
                (§ throw new IllegalArgumentException("No matching method: " + methodName))
            )

            (§ let int methodidx = 0)
            (§ if (ß methods.size() > 1)
                (§ let ArrayList<Class[]> params = new ArrayList())
                (§ let ArrayList<Class> rets = new ArrayList())
                (§ loop-when-recur [(ß int i = 0)] (ß i < methods.size()) [(ß i++)]
                    (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))
                    (ß params.add(m.getParameterTypes()))
                    (ß rets.add(m.getReturnType()))
                )
                (ß methodidx = getMatchingParams(methodName, params, args, rets))
            )
            (ß method = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))
            (§ if (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args)))
            )
            (§ if (ß method != nil && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method))
                (ß RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), line, column, method.toString()))
            )
            this
        )

        (§ defn boolean isBoxedMath(java.lang.reflect.Method m)
            (§ let Class c = m.getDeclaringClass())
            (§ if (ß c.equals(Numbers.class))
                (§ let WarnBoxedMath boxedMath = m.getAnnotation(WarnBoxedMath.class))
                (§ if (ß boxedMath != nil)
                    (§ return (ß boxedMath.value()))
                )

                (§ let Class[] argTypes = m.getParameterTypes())
                (§ doseq [#_"Class" argType argTypes]
                    (§ if (ß argType.equals(Object.class) || argType.equals(Number.class))
                        (§ return true)
                    )
                )
            )
            false
        )

        (§ method Object eval()
            (§ try 
                (§ let Object[] argvals = new Object[args.count()])
                (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß argvals[i] = ((Expr) args.nth(i)).eval())
                )
                (§ if (ß method != nil)
                    (§ let LinkedList ms = new LinkedList())
                    (ß ms.add(method))
                    (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, nil, argvals)))
                )
                (ß Reflector.invokeStaticMethod(c, methodName, argvals))
            )
            (§ catch (ß Throwable e)
                (§ if (ß !(e instanceof CompilerException))
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else 
                    (§ throw (ß (CompilerException) e))
                )
            )
        )

        (§ method boolean canEmitPrimitive()
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        (§ method boolean canEmitIntrinsicPredicate()
            (ß (method != nil && RT.get(Intrinsics.preds, method.toString()) != nil))
        )

        (§ method void emitIntrinsicPredicate(C context, ObjExpr objx, GeneratorAdapter gen, Label falseLabel)
            (ß gen.visitLineNumber(line, gen.mark()))
            (§ if (ß method != nil)
                (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (§ if (ß context == C.RETURN)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearLocals(gen))
                )
                (§ let Object[] predOps = (Object[]) RT.get(Intrinsics.preds, method.toString()))
                (§ loop-when-recur [(ß int i = 0)] (ß i < predOps.length - 1) [(ß i++)]
                    (ß gen.visitInsn((Integer)predOps[i]))
                )
                (ß gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel))
            )
            (§ else 
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß method != nil)
                (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (ß gen.visitLineNumber(line, gen.mark()))
                (§ if (ß context == C.RETURN)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearLocals(gen))
                )
                (§ let Object ops = RT.get(Intrinsics.ops, method.toString()))
                (§ if (ß ops != nil)
                    (§ if (ß ops instanceof Object[])
                        (§ doseq [#_"Object" op (ß (Object[])ops)]
                            (ß gen.visitInsn((Integer) op))
                        )
                    )
                    (§ else 
                        (ß gen.visitInsn((Integer) ops))
                    )
                )
                (§ else 
                    (§ let Type type = Type.getType(c))
                    (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                    (ß gen.invokeStatic(type, m))
                )
            )
            (§ else 
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß method != nil)
                (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (ß gen.visitLineNumber(line, gen.mark()))
                (§ if (ß tailPosition && !objx.canBeDirect)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearThis(gen))
                )
                (§ let Type type = Type.getType(c))
                (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                (ß gen.invokeStatic(type, m))
                (§ let Class retClass = method.getReturnType())
                (§ if (ß context == C.STATEMENT)
                    (§ if (ß retClass == long.class || retClass == double.class)
                        (ß gen.pop2())
                    )
                    (§ elseif (ß retClass != void.class)
                        (ß gen.pop())
                    )
                )
                (§ else 
                    (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                )
            )
            (§ else 
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.push(c.getName()))
                (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                (ß gen.push(methodName))
                (ß emitArgsAsArray(args, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (§ if (ß context == C.RETURN)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearLocals(gen))
                )
                (ß gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod))
                (§ if (ß context == C.STATEMENT)
                    (ß gen.pop())
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (method != nil || tag != nil))
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            jc
        )
    )

    (class-ns UnresolvedVarExpr (§ implements Expr)
        (§ field Symbol symbol)

        (§ constructor UnresolvedVarExpr(Symbol symbol)
            (ß this.symbol = symbol)
            this
        )

        (§ method boolean hasJavaClass()
            false
        )

        (§ method Class getJavaClass()
            (§ throw new IllegalArgumentException("UnresolvedVarExpr has no Java class"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            nil
        )

        (§ method Object eval()
            (§ throw new IllegalArgumentException("UnresolvedVarExpr cannot be evalled"))
        )
    )

    (class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
        (§ field Number n)
        (§ field int id)

        (§ constructor NumberExpr(Number n)
            (ß this.n = n)
            (ß this.id = registerConstant(n))
            this
        )

        (§ method Object val()
            n
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß context != C.STATEMENT)
                (ß objx.emitConstant(gen, id))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (§ if (ß n instanceof Integer)
                (ß long.class)
            )
            (§ elseif (ß n instanceof Double)
                (ß double.class)
            )
            (§ elseif (ß n instanceof Long)
                (ß long.class)
            )
            (§ else 
                (§ throw new IllegalStateException("Unsupported Number type: " + n.getClass().getName()))
            )
        )

        (§ method boolean canEmitPrimitive()
            true
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß n instanceof Integer)
                (ß gen.push(n.longValue()))
            )
            (§ elseif (ß n instanceof Double)
                (ß gen.push(n.doubleValue()))
            )
            (§ elseif (ß n instanceof Long)
                (ß gen.push(n.longValue()))
            )
            nil
        )

        (§ defn Expr parse(Number form)
            (§ if (ß form instanceof Integer || form instanceof Double || form instanceof Long)
                (ß new NumberExpr(form))
            )
            (§ else 
                (ß new ConstantExpr(form))
            )
        )
    )

    (class-ns ConstantExpr (§ extends LiteralExpr)
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        (§ field Object v)
        (§ field int id)

        (§ constructor ConstantExpr(Object v)
            (ß this.v = v)
            (ß this.id = registerConstant(v))
            this
        )

        (§ method Object val()
            v
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitConstant(gen, id))

            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß Modifier.isPublic(v.getClass().getModifiers()))
        )

        (§ method Class getJavaClass()
            (§ if (ß v instanceof APersistentMap)
                (ß APersistentMap.class)
            )
            (§ elseif (ß v instanceof APersistentSet)
                (ß APersistentSet.class)
            )
            (§ elseif (ß v instanceof APersistentVector)
                (ß APersistentVector.class)
            )
            (§ else 
                (ß v.getClass())
            )
        )

        (class-ns Parser (§ implements IParser)
            (§ def Keyword formKey = Keyword.intern("form"))

            (§ method Expr parse(C context, Object form)
                (§ let int argCount = RT.count(form) - 1)
                (§ if (ß argCount != 1)
                    (§ let IPersistentMap exData = new PersistentArrayMap(new Object[] (§ formKey, form )))
                    (§ throw new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData))
                )
                (§ let Object v = RT.second(form))

                (§ if (ß v == nil)
                    (§ return (ß NIL_EXPR))
                )
                (§ elseif (ß v == Boolean.TRUE)
                    (§ return (ß TRUE_EXPR))
                )
                (§ elseif (ß v == Boolean.FALSE)
                    (§ return (ß FALSE_EXPR))
                )
                (§ if (ß v instanceof Number)
                    (ß NumberExpr.parse((Number)v))
                )
                (§ elseif (ß v instanceof String)
                    (ß new StringExpr((String) v))
                )
                (§ elseif (ß v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0)
                    (ß new EmptyExpr(v))
                )
                (§ else 
                    (ß new ConstantExpr(v))
                )
            )
        )
    )

    (class-ns NilExpr (§ extends LiteralExpr)
        (§ method Object val()
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            nil
        )
    )

    (§ def NilExpr NIL_EXPR = new NilExpr())

    (class-ns BooleanExpr (§ extends LiteralExpr)
        (§ field boolean val)

        (§ constructor BooleanExpr(boolean val)
            (ß this.val = val)
            this
        )

        (§ method Object val()
            (ß val ? RT.T :or RT.F)
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß val)
                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
            )
            (§ else 
                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Boolean.class)
        )
    )

    (§ def BooleanExpr TRUE_EXPR = new BooleanExpr(true))
    (§ def BooleanExpr FALSE_EXPR = new BooleanExpr(false))

    (class-ns StringExpr (§ extends LiteralExpr)
        (§ field String str)

        (§ constructor StringExpr(String str)
            (ß this.str = str)
            this
        )

        (§ method Object val()
            str
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß context != C.STATEMENT)
                (ß gen.push(str))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß String.class)
        )
    )

    (class-ns MonitorEnterExpr (§ extends UntypedExpr)
        (§ field Expr target)

        (§ constructor MonitorEnterExpr(Expr target)
            (ß this.target = target)
            this
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval monitor-enter"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorEnter())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (ß new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns MonitorExitExpr (§ extends UntypedExpr)
        (§ field Expr target)

        (§ constructor MonitorExitExpr(Expr target)
            (ß this.target = target)
            this
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval monitor-exit"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorExit())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (ß new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns TryExpr (§ implements Expr)
        (§ field Expr tryExpr)
        (§ field Expr finallyExpr)
        (§ field PersistentVector catchExprs)
        (§ field int retLocal)
        (§ field int finallyLocal)

        (class-ns CatchClause
            (§ field Class c)
            (§ field LocalBinding lb)
            (§ field Expr handler)
            (§ field Label label)
            (§ field Label endLabel)

            (§ constructor CatchClause(Class c, LocalBinding lb, Expr handler)
                (ß this.c = c)
                (ß this.lb = lb)
                (ß this.handler = handler)
                this
            )
        )

        (§ constructor TryExpr(Expr tryExpr, PersistentVector catchExprs, Expr finallyExpr, int retLocal, int finallyLocal)
            (ß this.tryExpr = tryExpr)
            (ß this.catchExprs = catchExprs)
            (ß this.finallyExpr = finallyExpr)
            (ß this.retLocal = retLocal)
            (ß this.finallyLocal = finallyLocal)
            this
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval try"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label startTry = gen.newLabel())
            (§ let Label endTry = gen.newLabel())
            (§ let Label end = gen.newLabel())
            (§ let Label ret = gen.newLabel())
            (§ let Label finallyLabel = gen.newLabel())
            (§ loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (ß clause.label = gen.newLabel())
                (ß clause.endLabel = gen.newLabel())
            )

            (ß gen.mark(startTry))
            (ß tryExpr.emit(context, objx, gen))
            (§ if (ß context != C.STATEMENT)
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
            )
            (ß gen.mark(endTry))
            (§ if (ß finallyExpr != nil)
                (ß finallyExpr.emit(C.STATEMENT, objx, gen))
            )
            (ß gen.goTo(ret))

            (§ loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (ß gen.mark(clause.label))
                ;; exception should be on stack
                ;; put in clause local
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx))
                (ß clause.handler.emit(context, objx, gen))
                (§ if (ß context != C.STATEMENT)
                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                )
                (ß gen.mark(clause.endLabel))

                (§ if (ß finallyExpr != nil)
                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                )
                (ß gen.goTo(ret))
            )
            (§ if (ß finallyExpr != nil)
                (ß gen.mark(finallyLabel))
                ;; exception should be on stack
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal))
                (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal))
                (ß gen.throwException())
            )
            (ß gen.mark(ret))
            (§ if (ß context != C.STATEMENT)
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal))
            )
            (ß gen.mark(end))
            (§ loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (ß gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace(\., \/)))
            )
            (§ if (ß finallyExpr != nil)
                (ß gen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))
                (§ loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                    (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                    (ß gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, nil))
                )
            )
            (§ loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (ß gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", nil, clause.label, clause.endLabel, clause.lb.idx))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß tryExpr.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß tryExpr.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                (§ if (ß context != C.RETURN)
                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                ;; (try try-expr* catch-expr* finally-expr?)
                ;; catch-expr: (catch class sym expr*)
                ;; finally-expr: (finally expr*)

                (§ let PersistentVector body = PersistentVector.EMPTY)
                (§ let PersistentVector catches = PersistentVector.EMPTY)
                (§ let Expr bodyExpr = nil)
                (§ let Expr finallyExpr = nil)
                (§ let boolean caught = false)

                (§ let int retLocal = getAndIncLocalNum())
                (§ let int finallyLocal = getAndIncLocalNum())
                (§ loop-when-recur [(ß ISeq fs = form.next())] (ß fs != nil) [(ß fs = fs.next())]
                    (§ let Object f = fs.first())
                    (§ let Object op = (f instanceof ISeq) ? ((ISeq) f).first() :or nil)
                    (§ if (ß !Util.equals(op, CATCH) && !Util.equals(op, FINALLY))
                        (§ if (ß caught)
                            (§ throw Util.runtimeException("Only catch or finally clause can follow catch in try expression"))
                        )
                        (ß body = body.cons(f))
                    )
                    (§ else 
                        (§ if (ß bodyExpr == nil)
                            (§ try 
                                (ß Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil)))
                                (ß bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                            )
                            (§ finally 
                                (ß Var.popThreadBindings())
                            )
                        )

                        (§ if (ß Util.equals(op, CATCH))
                            (§ let Class c = HostExpr.maybeClass(RT.second(f), false))
                            (§ if (ß c == nil)
                                (§ throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(f)))
                            )
                            (§ if (ß !(RT.third(f) instanceof Symbol))
                                (§ throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f)))
                            )
                            (§ let Symbol sym = (Symbol) RT.third(f))
                            (§ if (ß sym.getNamespace() != nil)
                                (§ throw Util.runtimeException("Can't bind qualified name:" + sym))
                            )

                            (§ let IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T))
                            (§ try 
                                (ß Var.pushThreadBindings(dynamicBindings))
                                (§ let LocalBinding lb = registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or nil), nil, false))
                                (§ let Expr handler = (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f)))))
                                (ß catches = catches.cons(new CatchClause(c, lb, handler)))
                            )
                            (§ finally 
                                (ß Var.popThreadBindings())
                            )
                            (ß caught = true)
                        )
                        (§ else  ;; finally
                            (§ if (ß fs.next() != nil)
                                (§ throw Util.runtimeException("finally clause must be last in try expression"))
                            )
                            (§ try 
                                (ß Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T)))
                                (ß finallyExpr = (new BodyExpr.Parser()).parse(C.STATEMENT, RT.next(f)))
                            )
                            (§ finally 
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
                (§ if (ß bodyExpr == nil)
                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                    ;; return a body expr directly
                    (§ try 
                        (ß Var.pushThreadBindings(RT.map(NO_RECUR, true)))
                        (ß bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                    )
                    (§ finally 
                        (ß Var.popThreadBindings())
                    )
                    (§ return bodyExpr)
                )

                (ß new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal))
            )
        )
    )

    (class-ns ThrowExpr (§ extends UntypedExpr)
        (§ field Expr excExpr)

        (§ constructor ThrowExpr(Expr excExpr)
            (ß this.excExpr = excExpr)
            this
        )

        (§ method Object eval()
            (§ throw Util.runtimeException("Can't eval throw"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß excExpr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(THROWABLE_TYPE))
            (ß gen.throwException())
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (§ if (ß context == C.EVAL)
                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )
                (§ elseif (ß RT.count(form) == 1)
                    (§ throw Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance"))
                )
                (§ elseif (ß RT.count(form) > 2)
                    (§ throw Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance"))
                )
                (ß new ThrowExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (§ defn boolean subsumes(Class[] c1, Class[] c2)
        ;; presumes matching lengths
        (§ let Boolean better = false)
        (§ loop-when-recur [(ß int i = 0)] (ß i < c1.length) [(ß i++)]
            (§ if (ß c1[i] != c2[i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                (§ if (ß !c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i]))
                    (ß better = true)
                )
                (§ else 
                    (§ return false)
                )
            )
        )
        better
    )

    (§ defn String getTypeStringForArgs(IPersistentVector args)
        (§ let StringBuilder sb = new StringBuilder())
        (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
            (§ let Expr arg = (Expr) args.nth(i))
            (§ if (ß i > 0)
                (ß sb.append(", "))
            )
            (ß sb.append((arg.hasJavaClass() && arg.getJavaClass() != nil) ? arg.getJavaClass().getName() :or "unknown"))
        )
        (ß sb.toString())
    )

    (§ defn int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs, List<Class> rets)
        ;; presumes matching lengths
        (§ let int matchIdx = -1)
        (§ let boolean tied = false)
        (§ let boolean foundExact = false)
        (§ loop-when-recur [(ß int i = 0)] (ß i < paramlists.size()) [(ß i++)]
            (§ let boolean match = true)
            (§ let ISeq aseq = argexprs.seq())
            (§ let int exact = 0)
            (§ loop-when-recur [(ß int p = 0)] (ß match && p < argexprs.count() && aseq != nil) [(ß ++p, aseq = aseq.next())]
                (§ let Expr arg = (Expr) aseq.first())
                (§ let Class aclass = arg.hasJavaClass() ? arg.getJavaClass() :or Object.class)
                (§ let Class pclass = paramlists.get(i)[p])
                (§ if (ß arg.hasJavaClass() && aclass == pclass)
                    (ß exact++)
                )
                (§ else 
                    (ß match = Reflector.paramArgTypeMatch(pclass, aclass))
                )
            )
            (§ if (ß exact == argexprs.count())
                (§ if (ß !foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                    (ß matchIdx = i)
                )
                (ß tied = false)
                (ß foundExact = true)
            )
            (§ elseif (ß match && !foundExact)
                (§ if (ß matchIdx == -1)
                    (ß matchIdx = i)
                )
                (§ else 
                    (§ if (ß subsumes(paramlists.get(i), paramlists.get(matchIdx)))
                        (ß matchIdx = i)
                        (ß tied = false)
                    )
                    (§ elseif (ß Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
                        (§ if (ß rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                            (ß matchIdx = i)
                        )
                    )
                    (§ elseif (ß !(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
                        (ß tied = true)
                    )
                )
            )
        )
        (§ if (ß tied)
            (§ throw new IllegalArgumentException("More than one matching method found: " + methodName))
        )

        matchIdx
    )

    (class-ns NewExpr (§ implements Expr)
        (§ field IPersistentVector args)
        (§ field Constructor ctor)
        (§ field Class c)

        (§ def Method invokeConstructorMethod = Method.getMethod("Object invokeConstructor(Class,Object[])"))
        (§ def Method forNameMethod = Method.getMethod("Class classForName(String)"))

        (§ constructor NewExpr(Class c, IPersistentVector args, int line, int column)
            (ß this.args = args)
            (ß this.c = c)
            (§ let Constructor[] allctors = c.getConstructors())
            (§ let ArrayList ctors = new ArrayList())
            (§ let ArrayList<Class[]> params = new ArrayList())
            (§ let ArrayList<Class> rets = new ArrayList())
            (§ loop-when-recur [(ß int i = 0)] (ß i < allctors.length) [(ß i++)]
                (§ let Constructor ctor = allctors[i])
                (§ if (ß ctor.getParameterTypes().length == args.count())
                    (ß ctors.add(ctor))
                    (ß params.add(ctor.getParameterTypes()))
                    (ß rets.add(c))
                )
            )
            (§ if (ß ctors.isEmpty())
                (§ throw new IllegalArgumentException("No matching ctor found for " + c))
            )

            (§ let int ctoridx = 0)
            (§ if (ß ctors.size() > 1)
                (ß ctoridx = getMatchingParams(c.getName(), params, args, rets))
            )

            (ß this.ctor = (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or nil)
            (§ if (ß ctor == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), line, column, c.getName()))
            )
            this
        )

        (§ method Object eval()
            (§ let Object[] argvals = new Object[args.count()])
            (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (ß argvals[i] = ((Expr) args.nth(i)).eval())
            )
            (§ if (ß this.ctor != nil)
                (§ try 
                    (§ return (ß ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))))
                )
                (§ catch (ß Exception e)
                    (§ throw Util.sneakyThrow(e))
                )
            )
            (ß Reflector.invokeConstructor(c, argvals))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß this.ctor != nil)
                (§ let Type type = getType(c))
                (ß gen.newInstance(type))
                (ß gen.dup())
                (ß MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args))
                (ß gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor))))
            )
            (§ else 
                (ß gen.push(destubClassName(c.getName())))
                (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                (ß gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            c
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let int line = lineDeref())
                (§ let int column = columnDeref())
                (§ let ISeq form = (ISeq) frm)
                ;; (new Classname args...)
                (§ if (ß form.count() < 2)
                    (§ throw Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)"))
                )
                (§ let Class c = HostExpr.maybeClass(RT.second(form), false))
                (§ if (ß c == nil)
                    (§ throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(form)))
                )
                (§ let PersistentVector args = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß ISeq s = RT.next(RT.next(form)))] (ß s != nil) [(ß s = s.next())]
                    (ß args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                )
                (ß new NewExpr(c, args, line, column))
            )
        )
    )

    (class-ns MetaExpr (§ implements Expr)
        (§ field Expr expr)
        (§ field Expr meta)

        (§ def Type IOBJ_TYPE = Type.getType(IObj.class))
        (§ def Method withMetaMethod = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

        (§ constructor MetaExpr(Expr expr, Expr meta)
            (ß this.expr = expr)
            (ß this.meta = meta)
            this
        )

        (§ method Object eval()
            (ß ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval()))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IOBJ_TYPE))
            (ß meta.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
            (ß gen.invokeInterface(IOBJ_TYPE, withMetaMethod))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß expr.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß expr.getJavaClass())
        )
    )

    (class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Expr testExpr)
        (§ field Expr thenExpr)
        (§ field Expr elseExpr)
        (§ field int line)
        (§ field int column)

        (§ constructor IfExpr(int line, int column, Expr testExpr, Expr thenExpr, Expr elseExpr)
            (ß this.testExpr = testExpr)
            (ß this.thenExpr = thenExpr)
            (ß this.elseExpr = elseExpr)
            (ß this.line = line)
            (ß this.column = column)
            this
        )

        (§ method Object eval()
            (§ let Object t = testExpr.eval())
            (§ if (ß t != nil && t != Boolean.FALSE)
                (§ return (ß thenExpr.eval()))
            )
            (ß elseExpr.eval())
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, false))
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, true))
            nil
        )

        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (§ let Label nullLabel = gen.newLabel())
            (§ let Label falseLabel = gen.newLabel())
            (§ let Label endLabel = gen.newLabel())

            (ß gen.visitLineNumber(line, gen.mark()))

            (§ if (ß testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
                (ß ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel))
            )
            (§ elseif (ß maybePrimitiveType(testExpr) == boolean.class)
                (ß ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen))
                (ß gen.ifZCmp(gen.EQ, falseLabel))
            )
            (§ else 
                (ß testExpr.emit(C.EXPRESSION, objx, gen))
                (ß gen.dup())
                (ß gen.ifNull(nullLabel))
                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                (ß gen.visitJumpInsn(IF_ACMPEQ, falseLabel))
            )
            (§ if (ß emitUnboxed)
                (ß ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen))
            )
            (§ else 
                (ß thenExpr.emit(context, objx, gen))
            )
            (ß gen.goTo(endLabel))
            (ß gen.mark(nullLabel))
            (ß gen.pop())
            (ß gen.mark(falseLabel))
            (§ if (ß emitUnboxed)
                (ß ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen))
            )
            (§ else 
                (ß elseExpr.emit(context, objx, gen))
            )
            (ß gen.mark(endLabel))
            nil
        )

        (§ method boolean hasJavaClass()
            (ß thenExpr.hasJavaClass()
                && elseExpr.hasJavaClass()
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                    || thenExpr.getJavaClass() == RECUR_CLASS
                    || elseExpr.getJavaClass() == RECUR_CLASS
                    || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
                    || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive())))
        )

        (§ method boolean canEmitPrimitive()
            (§ try 
                (ß thenExpr instanceof MaybePrimitiveExpr
                    && elseExpr instanceof MaybePrimitiveExpr
                    && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                            || thenExpr.getJavaClass() == RECUR_CLASS
                            || elseExpr.getJavaClass() == RECUR_CLASS)
                    && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                    && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive())
            )
            (§ catch (ß Exception e)
                false
            )
        )

        (§ method Class getJavaClass()
            (§ let Class thenClass = thenExpr.getJavaClass())
            (§ if (ß thenClass != nil && thenClass != RECUR_CLASS)
                (§ return thenClass)
            )
            (ß elseExpr.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (if test then) or (if test then else)
                (§ if (ß form.count() > 4)
                    (§ throw Util.runtimeException("Too many arguments to if"))
                )
                (§ elseif (ß form.count() < 3)
                    (§ throw Util.runtimeException("Too few arguments to if"))
                )
                (§ let PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))
                (§ let Expr testexpr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))
                (§ let Expr thenexpr, elseexpr)
                (§ try 
                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                    (ß thenexpr = analyze(context, RT.third(form)))
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )
                (§ try 
                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                    (ß elseexpr = analyze(context, RT.fourth(form)))
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )
                (ß new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr))
            )
        )
    )

    (§ def IPersistentMap CHAR_MAP = PersistentHashMap.create(
      #_map \-, "_",
      #_map \:, "_COLON_",
      #_map \+, "_PLUS_",
      #_map \>, "_GT_",
      #_map \<, "_LT_",
      #_map \=, "_EQ_",
      #_map \~, "_TILDE_",
      #_map \!, "_BANG_",
      #_map \@, "_CIRCA_",
      #_map \#, "_SHARP_",
      #_map \', "_SINGLEQUOTE_",
      #_map \", "_DOUBLEQUOTE_", ;; oops! "
      #_map \%, "_PERCENT_",
      #_map \^, "_CARET_",
      #_map \&, "_AMPERSAND_",
      #_map \*, "_STAR_",
      #_map \|, "_BAR_",
      #_map \{, "_LBRACE_",
      #_map \}, "_RBRACE_",
      #_map \[, "_LBRACK_",
      #_map \], "_RBRACK_",
      #_map \/, "_SLASH_",
      #_map \\, "_BSLASH_",
      #_map \?, "_QMARK_"
    ))

    (§ def IPersistentMap DEMUNGE_MAP)
    (§ def Pattern DEMUNGE_PATTERN)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (§ let IPersistentMap m = RT.map("$", \/))
        (§ loop-when-recur [(ß ISeq s = RT.seq(CHAR_MAP))] (ß s != nil) [(ß s = s.next())]
            (§ let IMapEntry e = (IMapEntry) s.first())
            (§ let Character origCh = (Character) e.key())
            (§ let String escapeStr = (String) e.val())
            (ß m = m.assoc(escapeStr, origCh))
        )
        (ß DEMUNGE_MAP = m)

        ;; DEMUNGE_PATTERN searches for the first of any occurrence of
        ;; the strings that are keys of DEMUNGE_MAP.
        ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
        ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
        ;; as desired.  Sorting string keys of DEMUNGE_MAP from longest to
        ;; shortest ensures correct matching behavior, even if some strings are
        ;; prefixes of others.
        (§ let Object[] mungeStrs = RT.toArray(RT.keys(m)))
        (ß Arrays.sort(mungeStrs, new Comparator()
            (§ reify
                (§ method int compare(Object s1, Object s2)
                    (ß ((String) s2).length() - ((String) s1).length())
                )
            ))
        )
        (§ let StringBuilder sb = new StringBuilder())
        (§ let boolean first = true)
        (§ doseq [#_"Object" s mungeStrs]
            (§ let String escapeStr = (String) s)
            (§ if (ß !first)
                (ß sb.append("|"))
            )
            (ß first = false)
            (ß sb.append("\\Q"))
            (ß sb.append(escapeStr))
            (ß sb.append("\\E"))
        )
        (ß DEMUNGE_PATTERN = Pattern.compile(sb.toString()))
    )

    (§ defn String munge(String name)
        (§ let StringBuilder sb = new StringBuilder())
        (§ doseq [#_"char" c (ß name.toCharArray())]
            (§ let String sub = (String) CHAR_MAP.valAt(c))
            (§ if (ß sub != nil)
                (ß sb.append(sub))
            )
            (§ else 
                (ß sb.append(c))
            )
        )
        (ß sb.toString())
    )

    (§ defn String demunge(String mungedName)
        (§ let StringBuilder sb = new StringBuilder())
        (§ let Matcher m = DEMUNGE_PATTERN.matcher(mungedName))
        (§ let int lastMatchEnd = 0)
        (§ while (ß m.find())
            (§ let int start = m.start())
            (§ let int end = m.end())
            ;; Keep everything before the match
            (ß sb.append(mungedName.substring(lastMatchEnd, start)))
            (ß lastMatchEnd = end)
            ;; Replace the match with DEMUNGE_MAP result
            (§ let Character origCh = (Character) DEMUNGE_MAP.valAt(m.group()))
            (ß sb.append(origCh))
        )
        ;; Keep everything after the last match
        (ß sb.append(mungedName.substring(lastMatchEnd)))
        (ß sb.toString())
    )

    (class-ns EmptyExpr (§ implements Expr)
        (§ field Object coll)

        (§ def Type HASHMAP_TYPE = Type.getType(PersistentArrayMap.class))
        (§ def Type HASHSET_TYPE = Type.getType(PersistentHashSet.class))
        (§ def Type VECTOR_TYPE = Type.getType(PersistentVector.class))
        (§ def Type IVECTOR_TYPE = Type.getType(IPersistentVector.class))
        (§ def Type TUPLE_TYPE = Type.getType(Tuple.class))
        (§ def Type LIST_TYPE = Type.getType(PersistentList.class))
        (§ def Type EMPTY_LIST_TYPE = Type.getType(PersistentList.EmptyList.class))

        (§ constructor EmptyExpr(Object coll)
            (ß this.coll = coll)
            this
        )

        (§ method Object eval()
            coll
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß coll instanceof IPersistentList)
                (ß gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE))
            )
            (§ elseif (ß coll instanceof IPersistentVector)
                (ß gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE))
            )
            (§ elseif (ß coll instanceof IPersistentMap)
                (ß gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE))
            )
            (§ elseif (ß coll instanceof IPersistentSet)
                (ß gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE))
            )
            (§ else 
                (§ throw new UnsupportedOperationException("Unknown Collection type"))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (§ if (ß coll instanceof IPersistentList)
                (ß IPersistentList.class)
            )
            (§ elseif (ß coll instanceof IPersistentVector)
                (ß IPersistentVector.class)
            )
            (§ elseif (ß coll instanceof IPersistentMap)
                (ß IPersistentMap.class)
            )
            (§ elseif (ß coll instanceof IPersistentSet)
                (ß IPersistentSet.class)
            )
            (§ else 
                (§ throw new UnsupportedOperationException("Unknown Collection type"))
            )
        )
    )

    (class-ns ListExpr (§ implements Expr)
        (§ field IPersistentVector args)

        (§ def Method arrayToListMethod = Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])"))

        (§ constructor ListExpr(IPersistentVector args)
            (ß this.args = args)
            this
        )

        (§ method Object eval()
            (§ let IPersistentVector ret = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (ß ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
            )
            (ß ret.seq())
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß MethodExpr.emitArgsAsArray(args, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, arrayToListMethod))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentList.class)
        )
    )

    (class-ns MapExpr (§ implements Expr)
        (§ field IPersistentVector keyvals)

        (§ def Method mapMethod = Method.getMethod("cloiure.lang.IPersistentMap map(Object[])"))
        (§ def Method mapUniqueKeysMethod = Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

        (§ constructor MapExpr(IPersistentVector keyvals)
            (ß this.keyvals = keyvals)
            this
        )

        (§ method Object eval()
            (§ let Object[] ret = new Object[keyvals.count()])
            (§ loop-when-recur [(ß int i = 0)] (ß i < keyvals.count()) [(ß i++)]
                (ß ret[i] = ((Expr) keyvals.nth(i)).eval())
            )
            (ß RT.map(ret))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let boolean allKeysConstant = true)
            (§ let boolean allConstantKeysUnique = true)
            (§ let IPersistentSet constantKeys = PersistentHashSet.EMPTY)
            (§ loop-when-recur [(ß int i = 0)] (ß i < keyvals.count()) [(ß i+=2)]
                (§ let Expr k = (Expr) keyvals.nth(i))
                (§ if (ß k instanceof LiteralExpr)
                    (§ let Object kval = k.eval())
                    (§ if (ß constantKeys.contains(kval))
                        (ß allConstantKeysUnique = false)
                    )
                    (§ else 
                        (ß constantKeys = (IPersistentSet)constantKeys.cons(kval))
                    )
                )
                (§ else 
                    (ß allKeysConstant = false)
                )
            )
            (ß MethodExpr.emitArgsAsArray(keyvals, objx, gen))
            (§ if (ß (allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2))
                (ß gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod))
            )
            (§ else 
                (ß gen.invokeStatic(RT_TYPE, mapMethod))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentMap.class)
        )

        (§ defn Expr parse(C context, IPersistentMap form)
            (§ let IPersistentVector keyvals = PersistentVector.EMPTY)
            (§ let boolean keysConstant = true)
            (§ let boolean valsConstant = true)
            (§ let boolean allConstantKeysUnique = true)
            (§ let IPersistentSet constantKeys = PersistentHashSet.EMPTY)
            (§ loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                (§ let IMapEntry e = (IMapEntry) s.first())
                (§ let Expr k = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key()))
                (§ let Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val()))
                (ß keyvals = (IPersistentVector) keyvals.cons(k))
                (ß keyvals = (IPersistentVector) keyvals.cons(v))
                (§ if (ß k instanceof LiteralExpr)
                    (§ let Object kval = k.eval())
                    (§ if (ß constantKeys.contains(kval))
                        (ß allConstantKeysUnique = false)
                    )
                    (§ else 
                        (ß constantKeys = (IPersistentSet)constantKeys.cons(kval))
                    )
                )
                (§ else 
                    (ß keysConstant = false)
                )
                (§ if (ß !(v instanceof LiteralExpr))
                    (ß valsConstant = false)
                )
            )

            (§ let Expr ret = new MapExpr(keyvals))
            (§ if (ß form instanceof IObj && ((IObj) form).meta() != nil)
                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
            )
            (§ elseif (ß keysConstant)
                ;; TBD: Add more detail to exception thrown below.
                (§ if (ß !allConstantKeysUnique)
                    (§ throw new IllegalArgumentException("Duplicate constant keys in map"))
                )
                (§ if (ß valsConstant)
                    (§ let IPersistentMap m = PersistentArrayMap.EMPTY)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < keyvals.length()) [(ß i += 2)]
                        (ß m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val()))
                    )
                    (ß new ConstantExpr(m))
                )
                (§ else 
                    ret
                )
            )
            (§ else 
                ret
            )
        )
    )

    (class-ns SetExpr (§ implements Expr)
        (§ field IPersistentVector keys)

        (§ def Method setMethod = Method.getMethod("cloiure.lang.IPersistentSet set(Object[])"))

        (§ constructor SetExpr(IPersistentVector keys)
            (ß this.keys = keys)
            this
        )

        (§ method Object eval()
            (§ let Object[] ret = new Object[keys.count()])
            (§ loop-when-recur [(ß int i = 0)] (ß i < keys.count()) [(ß i++)]
                (ß ret[i] = ((Expr) keys.nth(i)).eval())
            )
            (ß RT.set(ret))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß MethodExpr.emitArgsAsArray(keys, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, setMethod))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentSet.class)
        )

        (§ defn Expr parse(C context, IPersistentSet form)
            (§ let IPersistentVector keys = PersistentVector.EMPTY)
            (§ let boolean constant = true)

            (§ loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                (§ let Object e = s.first())
                (§ let Expr expr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e))
                (ß keys = (IPersistentVector) keys.cons(expr))
                (§ if (ß !(expr instanceof LiteralExpr))
                    (ß constant = false)
                )
            )
            (§ let Expr ret = new SetExpr(keys))
            (§ if (ß form instanceof IObj && ((IObj) form).meta() != nil)
                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
            )
            (§ elseif (ß constant)
                (§ let IPersistentSet set = PersistentHashSet.EMPTY)
                (§ loop-when-recur [(ß int i = 0)] (ß i < keys.count()) [(ß i++)]
                    (§ let LiteralExpr ve = (LiteralExpr)keys.nth(i))
                    (ß set = (IPersistentSet)set.cons(ve.val()))
                )
                (ß new ConstantExpr(set))
            )
            (§ else 
                ret
            )
        )
    )

    (class-ns VectorExpr (§ implements Expr)
        (§ field IPersistentVector args)

        (§ def Method vectorMethod = Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])"))

        (§ constructor VectorExpr(IPersistentVector args)
            (ß this.args = args)
            this
        )

        (§ method Object eval()
            (§ let IPersistentVector ret = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (ß ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
            )
            ret
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß args.count() <= Tuple.MAX_SIZE)
                (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                )
                (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
            )
            (§ else 
                (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                (ß gen.invokeStatic(RT_TYPE, vectorMethod))
            )

            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentVector.class)
        )

        (§ defn Expr parse(C context, IPersistentVector form)
            (§ let boolean constant = true)

            (§ let IPersistentVector args = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß int i = 0)] (ß i < form.count()) [(ß i++)]
                (§ let Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i)))
                (ß args = (IPersistentVector) args.cons(v))
                (§ if (ß !(v instanceof LiteralExpr))
                    (ß constant = false)
                )
            )
            (§ let Expr ret = new VectorExpr(args))
            (§ if (ß form instanceof IObj && ((IObj) form).meta() != nil)
                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
            )
            (§ elseif (ß constant)
                (§ let IPersistentVector rv = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (§ let LiteralExpr ve = (LiteralExpr)args.nth(i))
                    (ß rv = rv.cons(ve.val()))
                )
                (ß new ConstantExpr(rv))
            )
            (§ else 
                ret
            )
        )
    )

    (class-ns KeywordInvokeExpr (§ implements Expr)
        (§ field KeywordExpr kw)
        (§ field Object tag)
        (§ field Expr target)
        (§ field int line)
        (§ field int column)
        (§ field int siteIndex)
        (§ field String source)

        (§ def Type ILOOKUP_TYPE = Type.getType(ILookup.class))

        (§ field Class jc)

        (§ constructor KeywordInvokeExpr(String source, int line, int column, Symbol tag, KeywordExpr kw, Expr target)
            (ß this.source = source)
            (ß this.kw = kw)
            (ß this.target = target)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.siteIndex = registerKeywordCallsite(kw.k))
            this
        )

        (§ method Object eval()
            (§ try 
                (ß kw.k.invoke(target.eval()))
            )
            (§ catch (ß Throwable e)
                (§ if (ß !(e instanceof CompilerException))
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else 
                    (§ throw (ß (CompilerException) e))
                )
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label endLabel = gen.newLabel())
            (§ let Label faultLabel = gen.newLabel())

            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE))
            (ß gen.dup()) ;; thunk, thunk
            (ß target.emit(C.EXPRESSION, objx, gen)) ;; thunk, thunk, target
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.dupX2()) ;; target, thunk, thunk, target
            (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; target, thunk, result
            (ß gen.dupX2()) ;; result, target, thunk, result
            (ß gen.visitJumpInsn(IF_ACMPEQ, faultLabel)) ;; result, target
            (ß gen.pop()) ;; result
            (ß gen.goTo(endLabel))

            (ß gen.mark(faultLabel)) ;; result, target
            (ß gen.swap()) ;; target, result
            (ß gen.pop()) ;; target
            (ß gen.dup()) ;; target, target
            (ß gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
            (ß gen.swap()) ;; target, site, target
            (ß gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
            (ß gen.dup()) ;; target, new-thunk, new-thunk
            (ß gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
            (ß gen.swap()) ;; new-thunk, target
            (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; result

            (ß gen.mark(endLabel))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil))
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )
    )

    (class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Expr expr)
        (§ field Class c)

        (§ constructor InstanceOfExpr(Class c, Expr expr)
            (ß this.expr = expr)
            (ß this.c = c)
            this
        )

        (§ method Object eval()
            (§ if (ß c.isInstance(expr.eval()))
                (§ return (ß RT.T))
            )
            (ß RT.F)
        )

        (§ method boolean canEmitPrimitive()
            true
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.instanceOf(getType(c)))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß emitUnboxed(context, objx, gen))
            (ß HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Boolean.TYPE)
        )
    )

    (class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Type target)
        (§ field Class retClass)
        (§ field Class[] paramclasses)
        (§ field Type[] paramtypes)
        (§ field IPersistentVector args)
        (§ field boolean variadic)
        (§ field boolean tailPosition)
        (§ field Object tag)

        (§ field Class jc)

        (§ constructor StaticInvokeExpr(Type target, Class retClass, Class[] paramclasses, Type[] paramtypes, boolean variadic, IPersistentVector args, Object tag, boolean tailPosition)
            (ß this.target = target)
            (ß this.retClass = retClass)
            (ß this.paramclasses = paramclasses)
            (ß this.paramtypes = paramtypes)
            (ß this.args = args)
            (ß this.variadic = variadic)
            (ß this.tailPosition = tailPosition)
            (ß this.tag = tag)
            this
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval StaticInvokeExpr"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß emitUnboxed(context, objx, gen))
            (§ if (ß context != C.STATEMENT)
                (ß HostExpr.emitBoxReturn(objx, gen, retClass))
            )
            (§ if (ß context == C.STATEMENT)
                (§ if (ß retClass == long.class || retClass == double.class)
                    (ß gen.pop2())
                )
                (§ else 
                    (ß gen.pop())
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, retClass))
            )
            jc
        )

        (§ method boolean canEmitPrimitive()
            (ß retClass.isPrimitive())
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Method ms = new Method("invokeStatic", getReturnType(), paramtypes))
            (§ if (ß variadic)
                (§ loop-when-recur [(ß int i = 0)] (ß i < paramclasses.length - 1) [(ß i++)]
                    (§ let Expr e = (Expr) args.nth(i))
                    (§ if (ß maybePrimitiveType(e) == paramclasses[i])
                        (ß ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen))
                    )
                    (§ else 
                        (ß e.emit(C.EXPRESSION, objx, gen))
                        (ß HostExpr.emitUnboxArg(objx, gen, paramclasses[i]))
                    )
                )
                (§ let IPersistentVector restArgs = RT.subvec(args, paramclasses.length - 1, args.count()))
                (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                (ß gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])")))
            )
            (§ else 
                (ß MethodExpr.emitTypedArgs(objx, gen, paramclasses, args))
            )

            (§ if (ß tailPosition && !objx.canBeDirect)
                (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                (ß method.emitClearThis(gen))
            )

            (ß gen.invokeStatic(target, ms))
            nil
        )

        (§ method- Type getReturnType()
            (ß Type.getType(retClass))
        )

        (§ defn Expr parse(Var v, ISeq args, Object tag, boolean tailPosition)
            (§ if (ß !v.isBound() || v.get() == nil)
                (§ return nil)
            )
            (§ let Class c = v.get().getClass())
            (§ let String cname = c.getName())

            (§ let java.lang.reflect.Method[] allmethods = c.getMethods())

            (§ let boolean variadic = false)
            (§ let int argcount = RT.count(args))
            (§ let java.lang.reflect.Method method = nil)
            (§ doseq [#_"java.lang.reflect.Method" m allmethods]
                (§ if (ß Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic"))
                    (§ let Class[] params = m.getParameterTypes())
                    (§ if (ß argcount == params.length)
                        (ß method = m)
                        (ß variadic = (argcount > 0 && params[params.length - 1] == ISeq.class))
                        (§ break )
                    )
                    (§ elseif (ß argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class)
                        (ß method = m)
                        (ß variadic = true)
                        (§ break )
                    )
                )
            )
            (§ if (ß method == nil)
                (§ return nil)
            )

            (§ let Class retClass = method.getReturnType())

            (§ let Class[] paramClasses = method.getParameterTypes())
            (§ let Type[] paramTypes = new Type[paramClasses.length])

            (§ loop-when-recur [(ß int i = 0)] (ß i < paramClasses.length) [(ß i++)]
                (ß paramTypes[i] = Type.getType(paramClasses[i]))
            )

            (§ let Type target = Type.getType(c))

            (§ let PersistentVector argv = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                (ß argv = argv.cons(analyze(C.EXPRESSION, s.first())))
            )

            (ß new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition))
        )
    )

    (class-ns InvokeExpr (§ implements Expr)
        (§ field Expr fexpr)
        (§ field Object tag)
        (§ field IPersistentVector args)
        (§ field int line)
        (§ field int column)
        (§ field boolean tailPosition)
        (§ field String source)

        (§ field boolean isProtocol = false)
        (§ field boolean isDirect = false)
        (§ field int siteIndex = -1)
        (§ field Class protocolOn)
        (§ field java.lang.reflect.Method onMethod)

        (§ def Keyword onKey = Keyword.intern("on"))
        (§ def Keyword methodMapKey = Keyword.intern("method-map"))

        (§ field Class jc)

        (§ defn Object sigTag(int argcount, Var v)
            (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
            (§ let Object sigTag = nil)
            (§ loop-when-recur [(ß ISeq s = RT.seq(arglists))] (ß s != nil) [(ß s = s.next())]
                (§ let APersistentVector sig = (APersistentVector) s.first())
                (§ let int restOffset = sig.indexOf(_AMP_))
                (§ if (ß argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))
                    (§ return (ß tagOf(sig)))
                )
            )
            nil
        )

        (§ constructor InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition)
            (ß this.source = source)
            (ß this.fexpr = fexpr)
            (ß this.args = args)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tailPosition = tailPosition)

            (§ if (ß fexpr instanceof VarExpr)
                (§ let Var fvar = ((VarExpr)fexpr).var)
                (§ let Var pvar =  (Var)RT.get(fvar.meta(), protocolKey))
                (§ if (ß pvar != nil && PROTOCOL_CALLSITES.isBound())
                    (ß this.isProtocol = true)
                    (ß this.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var))
                    (§ let Object pon = RT.get(pvar.get(), onKey))
                    (ß this.protocolOn = HostExpr.maybeClass(pon, false))
                    (§ if (ß this.protocolOn != nil)
                        (§ let IPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey))
                        (§ let Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym)))
                        (§ if (ß mmapVal == nil)
                            (§ throw new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)"))
                        )
                        (§ let String mname = munge(mmapVal.sym.toString()))
                        (§ let List methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false))
                        (§ if (ß methods.size() != 1)
                            (§ throw new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym))
                        )
                        (ß this.onMethod = (java.lang.reflect.Method) methods.get(0))
                    )
                )
            )

            (§ if (ß tag != nil)
                (ß this.tag = tag)
            )
            (§ elseif (ß fexpr instanceof VarExpr)
                (§ let Var v = ((VarExpr) fexpr).var)
                (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
                (§ let Object sigTag = sigTag(args.count(), v))
                (ß this.tag = (sigTag == nil) ? ((VarExpr) fexpr).tag :or sigTag)
            )
            (§ else 
                (ß this.tag = nil)
            )
            this
        )

        (§ method Object eval()
            (§ try 
                (§ let IFn fn = (IFn) fexpr.eval())
                (§ let PersistentVector argvs = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß argvs = argvs.cons(((Expr) args.nth(i)).eval()))
                )
                (ß fn.applyTo(RT.seq(Util.ret1(argvs, argvs = nil))))
            )
            (§ catch (ß Throwable e)
                (§ if (ß !(e instanceof CompilerException))
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else 
                    (§ throw (ß (CompilerException) e))
                )
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß isProtocol)
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß emitProto(context, objx, gen))
            )
            (§ else 
                (ß fexpr.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitLineNumber(line, gen.mark()))
                (ß gen.checkCast(IFN_TYPE))
                (ß emitArgsAndCall(0, context, objx, gen))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method void emitProto(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label onLabel = gen.newLabel())
            (§ let Label callLabel = gen.newLabel())
            (§ let Label endLabel = gen.newLabel())

            (§ let Var v = ((VarExpr)fexpr).var)

            (§ let Expr e = (Expr) args.nth(0))
            (ß e.emit(C.EXPRESSION, objx, gen))
            (ß gen.dup()) ;; target, target
            (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
            (ß gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target, class, cached-class
            (ß gen.visitJumpInsn(IF_ACMPEQ, callLabel)) ;; target
            (§ if (ß protocolOn != nil)
                (ß gen.dup()) ;; target, target
                (ß gen.instanceOf(Type.getType(protocolOn)))
                (ß gen.ifZCmp(GeneratorAdapter.NE, onLabel))
            )

            (ß gen.dup()) ;; target, target
            (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
            (ß gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target

            (ß gen.mark(callLabel)) ;; target
            (ß objx.emitVar(gen, v))
            (ß gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))) ;; target, proto-fn
            (ß gen.swap())
            (ß emitArgsAndCall(1, context, objx, gen))
            (ß gen.goTo(endLabel))

            (ß gen.mark(onLabel)) ;; target
            (§ if (ß protocolOn != nil)
                (ß gen.checkCast(Type.getType(protocolOn)))
                (ß MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count())))
                (§ if (ß context == C.RETURN)
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (ß method.emitClearLocals(gen))
                )
                (§ let Method m = new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod)))
                (ß gen.invokeInterface(Type.getType(protocolOn), m))
                (ß HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType()))
            )
            (ß gen.mark(endLabel))
            nil
        )

        (§ method void emitArgsAndCall(int firstArgToEmit, C context, ObjExpr objx, GeneratorAdapter gen)
            (§ loop-when-recur [(ß int i = firstArgToEmit)] (ß i < Math.min(MAX_POSITIONAL_ARITY, args.count())) [(ß i++)]
                (§ let Expr e = (Expr) args.nth(i))
                (ß e.emit(C.EXPRESSION, objx, gen))
            )
            (§ if (ß args.count() > MAX_POSITIONAL_ARITY)
                (§ let PersistentVector restArgs = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß int i = MAX_POSITIONAL_ARITY)] (ß i < args.count()) [(ß i++)]
                    (ß restArgs = restArgs.cons(args.nth(i)))
                )
                (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
            )
            (ß gen.visitLineNumber(line, gen.mark()))

            (§ if (ß tailPosition && !objx.canBeDirect)
                (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                (ß method.emitClearThis(gen))
            )

            (ß gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())])))
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil))
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )

        (§ defn Expr parse(C context, ISeq form)
            (§ let boolean tailPosition = inTailCall(context))
            (§ if (ß context != C.EVAL)
                (ß context = C.EXPRESSION)
            )
            (§ let Expr fexpr = analyze(context, form.first()))
            (§ if (ß fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3)
                (§ let Expr sexpr = analyze(C.EXPRESSION, RT.second(form)))
                (§ if (ß sexpr instanceof ConstantExpr)
                    (§ let Object val = ((ConstantExpr) sexpr).val())
                    (§ if (ß val instanceof Class)
                        (§ return (ß new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))))
                    )
                )
            )

            (§ if (ß RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL)
                (§ let Var v = ((VarExpr)fexpr).var)
                (§ if (ß !v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false)))
                    (§ let Symbol formtag = tagOf(form))
                    (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
                    (§ let int arity = RT.count(form.next()))
                    (§ let Object sigtag = sigTag(arity, v))
                    (§ let Object vtag = RT.get(RT.meta(v), RT.TAG_KEY))
                    (§ let Expr ret = StaticInvokeExpr.parse(v, RT.next(form), (formtag != nil) ? formtag :or (sigtag != nil) ? sigtag :or vtag, tailPosition))
                    (§ if (ß ret != nil)
                        (§ return ret)
                    )
                )
            )

            (§ if (ß fexpr instanceof VarExpr && context != C.EVAL)
                (§ let Var v = ((VarExpr)fexpr).var)
                (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
                (§ let int arity = RT.count(form.next()))
                (§ loop-when-recur [(ß ISeq s = RT.seq(arglists))] (ß s != nil) [(ß s = s.next())]
                    (§ let IPersistentVector args = (IPersistentVector) s.first())
                    (§ if (ß args.count() == arity)
                        (§ let String primc = FnMethod.primInterface(args))
                        (§ if (ß primc != nil)
                            (§ return (ß analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"), ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))), form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))))
                        )
                        (§ break )
                    )
                )
            )

            (§ if (ß fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound())
                (§ let Expr target = analyze(context, RT.second(form)))
                (§ return (ß new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)))
            )
            (§ let PersistentVector args = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß ISeq s = RT.seq(form.next()))] (ß s != nil) [(ß s = s.next())]
                (ß args = args.cons(analyze(context, s.first())))
            )

            (ß new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition))
        )
    )

    (class-ns SourceDebugExtensionAttribute (§ extends Attribute)
        (§ constructor SourceDebugExtensionAttribute()
            (§ super("SourceDebugExtension"))
            this
        )

        (§ method void writeSMAP(ClassWriter cw, String smap)
            (§ let ByteVector bv = write(cw, nil, -1, -1, -1))
            (ß bv.putUTF8(smap))
            nil
        )
    )

    (class-ns FnExpr (§ extends ObjExpr)
        (§ def Type aFnType = Type.getType(AFunction.class))
        (§ def Type restFnType = Type.getType(RestFn.class))

        ;; if there is a variadic overload (there can only be one) it is stored here
        (§ field FnMethod variadicMethod = nil)
        (§ field IPersistentCollection methods)
        (§ field- boolean hasPrimSigs)
        (§ field- boolean hasMeta)
        (§ field- boolean hasEnclosingMethod)

        (§ field Class jc)

        (§ constructor FnExpr(Object tag)
            (§ super(tag))
            this
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method boolean supportsMeta()
            hasMeta
        )

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or AFunction.class)
            )
            jc
        )

        #_protected
        (§ method void emitMethods(ClassVisitor cv)
            ;; override of invoke/doInvoke for each method
            (§ loop-when-recur [(ß ISeq s = RT.seq(methods))] (ß s != nil) [(ß s = s.next())]
                (§ let ObjMethod method = (ObjMethod) s.first())
                (ß method.emit(this, cv))
            )

            (§ if (ß isVariadic())
                (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), nil, nil, cv))
                (ß gen.visitCode())
                (ß gen.push(variadicMethod.reqParms.count()))
                (ß gen.returnValue())
                (ß gen.endMethod())
            )
            nil
        )

        (§ defn Expr parse(C context, ISeq form, String name)
            (§ let ISeq origForm = form)
            (§ let FnExpr fn = new FnExpr(tagOf(form)))
            (§ let Keyword retkey = Keyword.intern(nil, "rettag"))
            (§ let Object rettag = RT.get(RT.meta(form), retkey))
            (ß fn.src = form)
            (§ let ObjMethod enclosingMethod = (ObjMethod) METHOD.deref())
            (ß fn.hasEnclosingMethod = enclosingMethod != nil)
            (§ if (ß ((IMeta) form.first()).meta() != nil)
                (ß fn.onceOnly = RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(nil, "once"))))
            )

            (§ let String basename = ((enclosingMethod != nil) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$")

            (§ let Symbol nm = nil)

            (§ if (ß RT.second(form) instanceof Symbol)
                (ß nm = (Symbol) RT.second(form))
                (ß name = nm.name + "__" + RT.nextID())
            )
            (§ else 
                (§ if (ß name == nil)
                    (ß name = "fn__" + RT.nextID())
                )
                (§ elseif (ß enclosingMethod != nil)
                    (ß name += "__" + RT.nextID())
                )
            )

            (§ let String simpleName = munge(name).replace(".", "_DOT_"))

            (ß fn.name = basename + simpleName)
            (ß fn.internalName = fn.name.replace(\., \/))
            (ß fn.objtype = Type.getObjectType(fn.internalName))
            (§ let ArrayList<String> prims = new ArrayList())
            (§ try 
                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map CONSTANTS, PersistentVector.EMPTY,
                      #_map CONSTANT_IDS, new IdentityHashMap(),
                      #_map KEYWORDS, PersistentHashMap.EMPTY,
                      #_map VARS, PersistentHashMap.EMPTY,
                      #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                      #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                      #_map VAR_CALLSITES, emptyVarCallSites(),
                      #_map NO_RECUR, nil
                )))

                ;; arglist might be preceded by symbol naming this fn
                (§ if (ß nm != nil)
                    (ß fn.thisName = nm.name)
                    (ß form = RT.cons(FN, RT.next(RT.next(form))))
                )

                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                ;; turn former into latter
                (§ if (ß RT.second(form) instanceof IPersistentVector)
                    (ß form = RT.list(FN, RT.next(form)))
                )
                (ß fn.line = lineDeref())
                (ß fn.column = columnDeref())
                (§ let FnMethod[] methodArray = new FnMethod[MAX_POSITIONAL_ARITY + 1])
                (§ let FnMethod variadicMethod = nil)
                (§ let boolean usesThis = false)
                (§ loop-when-recur [(ß ISeq s = RT.next(form))] (ß s != nil) [(ß s = RT.next(s))]
                    (§ let FnMethod f = FnMethod.parse(fn, (ISeq) RT.first(s), rettag))
                    (§ if (ß f.usesThis)
                        (ß usesThis = true)
                    )
                    (§ if (ß f.isVariadic())
                        (§ if (ß variadicMethod == nil)
                            (ß variadicMethod = f)
                        )
                        (§ else 
                            (§ throw Util.runtimeException("Can't have more than 1 variadic overload"))
                        )
                    )
                    (§ elseif (ß methodArray[f.reqParms.count()] == nil)
                        (ß methodArray[f.reqParms.count()] = f)
                    )
                    (§ else 
                        (§ throw Util.runtimeException("Can't have 2 overloads with same arity"))
                    )
                    (§ if (ß f.prim != nil)
                        (ß prims.add(f.prim))
                    )
                )
                (§ if (ß variadicMethod != nil)
                    (§ loop-when-recur [(ß int i = variadicMethod.reqParms.count() + 1)] (ß i <= MAX_POSITIONAL_ARITY) [(ß i++)]
                        (§ if (ß methodArray[i] != nil)
                            (§ throw Util.runtimeException("Can't have fixed arity function with more params than variadic function"))
                        )
                    )
                )

                (ß fn.canBeDirect = (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis))

                (§ let IPersistentCollection methods = nil)
                (§ loop-when-recur [(ß int i = 0)] (ß i < methodArray.length) [(ß i++)]
                    (§ if (ß methodArray[i] != nil)
                        (ß methods = RT.conj(methods, methodArray[i]))
                    )
                )
                (§ if (ß variadicMethod != nil)
                    (ß methods = RT.conj(methods, variadicMethod))
                )

                (§ if (ß fn.canBeDirect)
                    (§ doseq [#_"FnMethod" fm (ß (Collection<FnMethod>)methods)]
                        (§ if (ß fm.locals != nil)
                            (§ doseq [#_"LocalBinding" lb (ß (Collection<LocalBinding>)RT.keys(fm.locals))]
                                (§ if (ß lb.isArg)
                                    (ß lb.idx -= 1)
                                )
                            )
                        )
                    )
                )

                (ß fn.methods = methods)
                (ß fn.variadicMethod = variadicMethod)
                (ß fn.keywords = (IPersistentMap) KEYWORDS.deref())
                (ß fn.vars = (IPersistentMap) VARS.deref())
                (ß fn.constants = (PersistentVector) CONSTANTS.deref())
                (ß fn.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                (ß fn.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                (ß fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())

                (ß fn.constantsID = RT.nextID())
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
            (ß fn.hasPrimSigs = prims.size() > 0)
            (§ let IPersistentMap fmeta = RT.meta(origForm))
            (§ if (ß fmeta != nil)
                (ß fmeta = fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey))
            )

            (ß fn.hasMeta = RT.count(fmeta) > 0)

            (§ try 
                (ß fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? nil :or prims.toArray(new String[prims.size()]), fn.onceOnly))
            )
            (§ catch (ß IOException e)
                (§ throw Util.sneakyThrow(e))
            )
            (ß fn.getCompiledClass())

            (§ if (ß fn.supportsMeta())
                (ß new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta)))
            )
            (§ else 
                fn
            )
        )

        (§ method ObjMethod variadicMethod()
            variadicMethod
        )

        (§ method boolean isVariadic()
            (ß (variadicMethod != nil))
        )

        (§ method IPersistentCollection methods()
            methods
        )

        (§ method void emitForDefn(ObjExpr objx, GeneratorAdapter gen)
            (ß emit(C.EXPRESSION, objx, gen))
            nil
        )
    )

    (class-ns ObjExpr (§ implements Expr)
        (§ def String CONST_PREFIX = "const__")

        (§ field String name)
        (§ field String internalName)
        (§ field String thisName)
        (§ field Type objtype)
        (§ field Object tag)
        ;; localbinding->itself
        (§ field IPersistentMap closes = PersistentHashMap.EMPTY)
        ;; localbndingexprs
        (§ field IPersistentVector closesExprs = PersistentVector.EMPTY)
        ;; symbols
        (§ field IPersistentSet volatiles = PersistentHashSet.EMPTY)

        ;; symbol->lb
        (§ field IPersistentMap fields = nil)

        ;; hinted fields
        (§ field IPersistentVector hintedFields = PersistentVector.EMPTY)

        ;; Keyword->KeywordExpr
        (§ field IPersistentMap keywords = PersistentHashMap.EMPTY)
        (§ field IPersistentMap vars = PersistentHashMap.EMPTY)
        (§ field Class compiledClass)
        (§ field int line)
        (§ field int column)
        (§ field PersistentVector constants)
        (§ field IPersistentSet usedConstants = PersistentHashSet.EMPTY)

        (§ field int constantsID)
        (§ field int altCtorDrops = 0)

        (§ field IPersistentVector keywordCallsites)
        (§ field IPersistentVector protocolCallsites)
        (§ field IPersistentSet varCallsites)
        (§ field boolean onceOnly = false)

        (§ field Object src)

        (§ field IPersistentMap opts = PersistentHashMap.EMPTY)

        (§ def Method voidctor = Method.getMethod("void <init>()"))
        #_protected
        (§ field IPersistentMap classMeta)
        #_protected
        (§ field boolean canBeDirect)

        (§ method String name()
            name
        )

        (§ method String internalName()
            internalName
        )

        (§ method String thisName()
            thisName
        )

        (§ method Type objtype()
            objtype
        )

        (§ method IPersistentMap closes()
            closes
        )

        (§ method IPersistentMap keywords()
            keywords
        )

        (§ method IPersistentMap vars()
            vars
        )

        (§ method Class compiledClass()
            compiledClass
        )

        (§ method int line()
            line
        )

        (§ method int column()
            column
        )

        (§ method PersistentVector constants()
            constants
        )

        (§ method int constantsID()
            constantsID
        )

        (§ def Method kwintern = Method.getMethod("cloiure.lang.Keyword intern(String, String)"))
        (§ def Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String)"))
        (§ def Method varintern = Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)"))

        (§ def Type DYNAMIC_CLASSLOADER_TYPE = Type.getType(DynamicClassLoader.class))
        (§ def Method getClassMethod = Method.getMethod("Class getClass()"))
        (§ def Method getClassLoaderMethod = Method.getMethod("ClassLoader getClassLoader()"))
        (§ def Method getConstantsMethod = Method.getMethod("Object[] getConstants(int)"))
        (§ def Method readStringMethod = Method.getMethod("Object readString(String)"))

        (§ def Type ILOOKUP_SITE_TYPE = Type.getType(ILookupSite.class))
        (§ def Type ILOOKUP_THUNK_TYPE = Type.getType(ILookupThunk.class))
        (§ def Type KEYWORD_LOOKUPSITE_TYPE = Type.getType(KeywordLookupSite.class))

        (§ field- DynamicClassLoader loader)
        (§ field- byte[] bytecode)

        (§ constructor ObjExpr(Object tag)
            (ß this.tag = tag)
            this
        )

        (§ defn String trimGenID(String name)
            (§ let int i = name.lastIndexOf("__"))
            (ß (i == -1) ? name :or name.substring(0, i))
        )

        (§ method Type[] ctorTypes()
            (§ let IPersistentVector tv = !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE))
            (§ loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ if (ß lb.getPrimitiveType() != nil)
                    (ß tv = tv.cons(Type.getType(lb.getPrimitiveType())))
                )
                (§ else 
                    (ß tv = tv.cons(OBJECT_TYPE))
                )
            )
            (§ let Type[] ret = new Type[tv.count()])
            (§ loop-when-recur [(ß int i = 0)] (ß i < tv.count()) [(ß i++)]
                (ß ret[i] = (Type) tv.nth(i))
            )
            ret
        )

        (§ method void compile(String superName, String[] interfaceNames, boolean oneTimeUse) (§ throws IOException)
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            (§ let ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS))
            (§ let ClassVisitor cv = cw)
            (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, superName, interfaceNames))
            (§ let String source = (String) SOURCE.deref())
            (§ let int lineBefore = (Integer) LINE_BEFORE.deref())
            (§ let int lineAfter = (Integer) LINE_AFTER.deref() + 1)
            (§ let int columnBefore = (Integer) COLUMN_BEFORE.deref())
            (§ let int columnAfter = (Integer) COLUMN_AFTER.deref() + 1)

            (§ if (ß source != nil && SOURCE_PATH.deref() != nil)
                (§ let String smap = "SMAP\n"
                    + ((source.lastIndexOf(\.) > 0) ? source.substring(0, source.lastIndexOf(\.)) :or source) ;; :or simpleName
                    + ".java\n"
                    + "Cloiure\n"
                    + "*S Cloiure\n"
                    + "*F\n"
                    + "+ 1 " + source + "\n"
                    + (String) SOURCE_PATH.deref() + "\n"
                    + "*L\n"
                    + String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore)
                    + "*E")
                (ß cv.visitSource(source, smap))
            )
            (ß addAnnotation(cv, classMeta))

            (§ if (ß supportsMeta())
                (ß cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
            )
            ;; instance fields for closed-overs
            (§ loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ if (ß isDeftype())
                    (§ let int access = isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL))
                    (§ let FieldVisitor fv)
                    (§ if (ß lb.getPrimitiveType() != nil)
                        (ß fv = cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                    )
                    (§ else 
                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                        (ß fv = cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                    )
                    (ß addAnnotation(fv, RT.meta(lb.sym)))
                )
                (§ else 
                    ;; todo - only enable this non-private+writability for letfns where we need it
                    (§ if (ß lb.getPrimitiveType() != nil)
                        (ß cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                    )
                    (§ else 
                        (ß cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                    )
                )
            )

            ;; static fields for callsites and thunks
            (§ loop-when-recur [(ß int i = 0)] (ß i < protocolCallsites.count()) [(ß i++)]
                (ß cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), nil, nil))
            )

            ;; ctor that takes closed-overs and inits base + fields
            (§ let Method m = new Method("<init>", Type.VOID_TYPE, ctorTypes()))
            (§ let GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))
            (§ let Label start = ctorgen.newLabel())
            (§ let Label end = ctorgen.newLabel())
            (ß ctorgen.visitCode())
            (ß ctorgen.visitLineNumber(line, ctorgen.mark()))
            (ß ctorgen.visitLabel(start))
            (ß ctorgen.loadThis())
            (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))

            (§ if (ß supportsMeta())
                (ß ctorgen.loadThis())
                (ß ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1))
                (ß ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE))
            )

            (§ let int a = supportsMeta() ? 2 :or 1)
            (§ loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next(), ++a)]
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (ß ctorgen.loadThis())
                (§ let Class primc = lb.getPrimitiveType())
                (§ if (ß primc != nil)
                    (ß ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a))
                    (ß ctorgen.putField(objtype, lb.name, Type.getType(primc)))
                    (§ if (ß primc == Long.TYPE || primc == Double.TYPE)
                        (ß ++a)
                    )
                )
                (§ else 
                    (ß ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a))
                    (ß ctorgen.putField(objtype, lb.name, OBJECT_TYPE))
                )
                (ß closesExprs = closesExprs.cons(new LocalBindingExpr(lb, nil)))
            )

            (ß ctorgen.visitLabel(end))

            (ß ctorgen.returnValue())

            (ß ctorgen.endMethod())

            (§ if (ß altCtorDrops > 0)
                ;; ctor that takes closed-overs and inits base + fields
                (§ let Type[] ctorTypes = ctorTypes())
                (§ let Type[] altCtorTypes = new Type[ctorTypes.length-altCtorDrops])
                (§ loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                    (ß altCtorTypes[i] = ctorTypes[i])
                )
                (§ let Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (ß ctorgen.visitCode())
                (ß ctorgen.loadThis())
                (ß ctorgen.loadArgs())

                (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (ß ctorgen.returnValue())
                (ß ctorgen.endMethod())

                ;; alt ctor no __hash, __hasheq
                (ß altCtorTypes = new Type[ctorTypes.length-2])
                (§ loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                    (ß altCtorTypes[i] = ctorTypes[i])
                )

                (ß alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (ß ctorgen.visitCode())
                (ß ctorgen.loadThis())
                (ß ctorgen.loadArgs())

                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (ß ctorgen.returnValue())
                (ß ctorgen.endMethod())
            )

            (§ if (ß supportsMeta())
                ;; ctor that takes closed-overs but not meta
                (§ let Type[] ctorTypes = ctorTypes())
                (§ let Type[] noMetaCtorTypes = new Type[ctorTypes.length-1])
                (§ loop-when-recur [(ß int i = 1)] (ß i < ctorTypes.length) [(ß i++)]
                    (ß noMetaCtorTypes[i - 1] = ctorTypes[i])
                )
                (§ let Method alt = new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes))
                (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (ß ctorgen.visitCode())
                (ß ctorgen.loadThis())
                (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; nil meta
                (ß ctorgen.loadArgs())
                (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (ß ctorgen.returnValue())
                (ß ctorgen.endMethod())

                ;; meta()
                (§ let Method meth = Method.getMethod("cloiure.lang.IPersistentMap meta()"))

                (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))
                (ß gen.visitCode())
                (ß gen.loadThis())
                (ß gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE))

                (ß gen.returnValue())
                (ß gen.endMethod())

                ;; withMeta()
                (ß meth = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                (ß gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))
                (ß gen.visitCode())
                (ß gen.newInstance(objtype))
                (ß gen.dup())
                (ß gen.loadArg(0))

                (§ loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next(), ++a)]
                    (§ let LocalBinding lb = (LocalBinding) s.first())
                    (ß gen.loadThis())
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ if (ß primc != nil)
                        (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                    )
                    (§ else 
                        (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                    )
                )

                (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))
                (ß gen.returnValue())
                (ß gen.endMethod())
            )

            (ß emitStatics(cv))
            (ß emitMethods(cv))

            ;; static fields for constants
            (§ loop-when-recur [(ß int i = 0)] (ß i < constants.count()) [(ß i++)]
                (§ if (ß usedConstants.contains(i))
                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), nil, nil))
                )
            )

            ;; static fields for lookup sites
            (§ loop-when-recur [(ß int i = 0)] (ß i < keywordCallsites.count()) [(ß i++)]
                (ß cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                (ß cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
            )

            ;; static init for constants, keywords and vars
            (§ let GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))
            (ß clinitgen.visitCode())
            (ß clinitgen.visitLineNumber(line, clinitgen.mark()))

            (§ if (ß constants.count() > 0)
                (ß emitConstants(clinitgen))
            )

            (§ if (ß keywordCallsites.count() > 0)
                (ß emitKeywordCallsites(clinitgen))
            )

            (§ if (ß isDeftype() && RT.booleanCast(RT.get(opts, loadNs)))
                (§ let String nsname = ((Symbol)RT.second(src)).getNamespace())
                (§ if (ß !nsname.equals("cloiure.core"))
                    (ß clinitgen.push("cloiure.core"))
                    (ß clinitgen.push("require"))
                    (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                    (ß clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")))
                    (ß clinitgen.checkCast(IFN_TYPE))
                    (ß clinitgen.push(nsname))
                    (ß clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)")))
                    (ß clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)")))
                    (ß clinitgen.pop())
                )
            )

            (ß clinitgen.returnValue())

            (ß clinitgen.endMethod())

            ;; end of class
            (ß cv.visitEnd())

            (ß bytecode = cw.toByteArray())
            (§ if (ß RT.booleanCast(COMPILE_FILES.deref()))
                (ß writeClassFile(internalName, bytecode))
            )
            nil
        )

        (§ method- void emitKeywordCallsites(GeneratorAdapter clinitgen)
            (§ loop-when-recur [(ß int i = 0)] (ß i < keywordCallsites.count()) [(ß i++)]
                (§ let Keyword k = (Keyword) keywordCallsites.nth(i))
                (ß clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE))
                (ß clinitgen.dup())
                (ß emitValue(k, clinitgen))
                (ß clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)")))
                (ß clinitgen.dup())
                (ß clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE))
                (ß clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE))
            )
            nil
        )

        #_protected
        (§ method void emitStatics(ClassVisitor gen)
            nil
        )

        #_protected
        (§ method void emitMethods(ClassVisitor gen)
            nil
        )

        (§ method void emitListAsObjectArray(Object value, GeneratorAdapter gen)
            (ß gen.push(((List) value).size()))
            (ß gen.newArray(OBJECT_TYPE))
            (§ let int i = 0)
            (§ loop-when-recur [(ß Iterator it = ((List) value).iterator())] (ß it.hasNext()) [(ß i++)]
                (ß gen.dup())
                (ß gen.push(i))
                (ß emitValue(it.next(), gen))
                (ß gen.arrayStore(OBJECT_TYPE))
            )
            nil
        )

        (§ method void emitValue(Object value, GeneratorAdapter gen)
            (§ let boolean partial = true)

            (§ if (ß value == nil)
                (ß gen.visitInsn(Opcodes.ACONST_NULL))
            )
            (§ elseif (ß value instanceof String)
                (ß gen.push((String) value))
            )
            (§ elseif (ß value instanceof Boolean)
                (§ if (ß ((Boolean) value).booleanValue())
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                )
                (§ else 
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                )
            )
            (§ elseif (ß value instanceof Integer)
                (ß gen.push(((Integer) value).intValue()))
                (ß gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)")))
            )
            (§ elseif (ß value instanceof Long)
                (ß gen.push(((Long) value).longValue()))
                (ß gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)")))
            )
            (§ elseif (ß value instanceof Double)
                (ß gen.push(((Double) value).doubleValue()))
                (ß gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)")))
            )
            (§ elseif (ß value instanceof Character)
                (ß gen.push(((Character) value).charValue()))
                (ß gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)")))
            )
            (§ elseif (ß value instanceof Class)
                (§ let Class cc = (Class)value)
                (§ if (ß cc.isPrimitive())
                    (§ let Type bt)
                    (§ if (ß cc == boolean.class)
                        (ß bt = Type.getType(Boolean.class))
                    )
                    (§ elseif (ß cc == byte.class)
                        (ß bt = Type.getType(Byte.class))
                    )
                    (§ elseif (ß cc == char.class)
                        (ß bt = Type.getType(Character.class))
                    )
                    (§ elseif (ß cc == double.class)
                        (ß bt = Type.getType(Double.class))
                    )
                    (§ elseif (ß cc == float.class)
                        (ß bt = Type.getType(Float.class))
                    )
                    (§ elseif (ß cc == int.class)
                        (ß bt = Type.getType(Integer.class))
                    )
                    (§ elseif (ß cc == long.class)
                        (ß bt = Type.getType(Long.class))
                    )
                    (§ elseif (ß cc == short.class)
                        (ß bt = Type.getType(Short.class))
                    )
                    (§ else 
                        (§ throw Util.runtimeException("Can't embed unknown primitive in code: " + value))
                    )
                    (ß gen.getStatic(bt, "TYPE", Type.getType(Class.class)))
                )
                (§ else 
                    (ß gen.push(destubClassName(cc.getName())))
                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                )
            )
            (§ elseif (ß value instanceof Symbol)
                (ß gen.push(((Symbol) value).ns))
                (ß gen.push(((Symbol) value).name))
                (ß gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)")))
            )
            (§ elseif (ß value instanceof Keyword)
                (ß gen.push(((Keyword) value).sym.ns))
                (ß gen.push(((Keyword) value).sym.name))
                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)")))
            )
            (§ elseif (ß value instanceof Var)
                (§ let Var var = (Var) value)
                (ß gen.push(var.ns.name.toString()))
                (ß gen.push(var.sym.toString()))
                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
            )
            (§ elseif (ß value instanceof IType)
                (§ let Method ctor = new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0])))
                (ß gen.newInstance(Type.getType(value.getClass())))
                (ß gen.dup())
                (§ let IPersistentVector fields = (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§)))
                (§ loop-when-recur [(ß ISeq s = RT.seq(fields))] (ß s != nil) [(ß s = s.next())]
                    (§ let Symbol field = (Symbol) s.first())
                    (§ let Class k = tagClass(tagOf(field)))
                    (§ let Object val = Reflector.getInstanceField(value, munge(field.name)))
                    (ß emitValue(val, gen))

                    (§ if (ß k.isPrimitive())
                        (§ let Type b = Type.getType(boxClass(k)))
                        (§ let String p = Type.getType(k).getDescriptor())
                        (§ let String n = k.getName())

                        (ß gen.invokeVirtual(b, new Method(n+"Value", "()"+p)))
                    )
                )
                (ß gen.invokeConstructor(Type.getType(value.getClass()), ctor))
            )
            (§ elseif (ß value instanceof IRecord)
                (§ let Method createMethod = Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))
                (ß emitValue(PersistentArrayMap.create((java.util.Map) value), gen))
                (ß gen.invokeStatic(getType(value.getClass()), createMethod))
            )
            (§ elseif (ß value instanceof IPersistentMap)
                (§ let List entries = new ArrayList())
                (§ doseq [#_"Map.Entry" entry (ß (Set<Map.Entry>) ((Map) value).entrySet())]
                    (ß entries.add(entry.getKey()))
                    (ß entries.add(entry.getValue()))
                )
                (ß emitListAsObjectArray(entries, gen))
                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
            )
            (§ elseif (ß value instanceof IPersistentVector)
                (§ let IPersistentVector args = (IPersistentVector) value)
                (§ if (ß args.count() <= Tuple.MAX_SIZE)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                        (ß emitValue(args.nth(i), gen))
                    )
                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                )
                (§ else 
                    (ß emitListAsObjectArray(value, gen))
                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                )
            )
            (§ elseif (ß value instanceof PersistentHashSet)
                (§ let ISeq vs = RT.seq(value))
                (§ if (ß vs == nil)
                    (ß gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class)))
                )
                (§ else 
                    (ß emitListAsObjectArray(vs, gen))
                    (ß gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                )
            )
            (§ elseif (ß value instanceof ISeq || value instanceof IPersistentList)
                (ß emitListAsObjectArray(value, gen))
                (ß gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])")))
                (ß gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
            )
            (§ elseif (ß value instanceof Pattern)
                (ß emitValue(value.toString(), gen))
                (ß gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)")))
            )
            (§ else 
                (§ let String cs = nil)
                (§ try 
                    (ß cs = RT.printString(value))
                )
                (§ catch (ß Exception e)
                    (§ throw Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value))
                )
                (§ if (ß cs.length() == 0)
                    (§ throw Util.runtimeException("Can't embed unreadable object in code: " + value))
                )

                (§ if (ß cs.startsWith("#<"))
                    (§ throw Util.runtimeException("Can't embed unreadable object in code: " + cs))
                )

                (ß gen.push(cs))
                (ß gen.invokeStatic(RT_TYPE, readStringMethod))
                (ß partial = false)
            )

            (§ if (ß partial)
                (§ if (ß value instanceof IObj && RT.count(((IObj) value).meta()) > 0)
                    (ß gen.checkCast(IOBJ_TYPE))
                    (§ let Object m = ((IObj) value).meta())
                    (ß emitValue(elideMeta(m), gen))
                    (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                    (ß gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                )
            )
            nil
        )

        (§ method void emitConstants(GeneratorAdapter clinitgen)
            (§ try 
                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                (§ loop-when-recur [(ß int i = 0)] (ß i < constants.count()) [(ß i++)]
                    (§ if (ß usedConstants.contains(i))
                        (ß emitValue(constants.nth(i), clinitgen))
                        (ß clinitgen.checkCast(constantType(i)))
                        (ß clinitgen.putStatic(objtype, constantName(i), constantType(i)))
                    )
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
            nil
        )

        (§ method boolean isMutable(LocalBinding lb)
            (ß isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable"))))
        )

        (§ method boolean isVolatile(LocalBinding lb)
            (ß RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable"))))
        )

        (§ method boolean isDeftype()
            (ß (fields != nil))
        )

        (§ method boolean supportsMeta()
            (ß !isDeftype())
        )

        (§ method void emitClearCloses(GeneratorAdapter gen)
            nil
        )

        (§ method Class getCompiledClass()
            (§ sync (ß this)
                (§ if (ß compiledClass == nil)
                    (ß loader = (DynamicClassLoader) LOADER.deref())
                    (ß compiledClass = loader.defineClass(name, bytecode, src))
                )
                compiledClass
            )
        )

        (§ method Object eval()
            (§ if (ß isDeftype())
                (§ return nil)
            )
            (§ try 
                (ß getCompiledClass().newInstance())
            )
            (§ catch (ß Exception e)
                (§ throw Util.sneakyThrow(e))
            )
        )

        (§ method void emitLetFnInits(GeneratorAdapter gen, ObjExpr objx, IPersistentSet letFnLocals)
            ;; objx arg is enclosing objx, not this
            (ß gen.checkCast(objtype))

            (§ loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ if (ß letFnLocals.contains(lb))
                    (§ let Class primc = lb.getPrimitiveType())
                    (ß gen.dup())
                    (§ if (ß primc != nil)
                        (ß objx.emitUnboxedLocal(gen, lb))
                        (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                    )
                    (§ else 
                        (ß objx.emitLocal(gen, lb, false))
                        (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
            )
            (ß gen.pop())
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            (§ if (ß isDeftype())
                (ß gen.visitInsn(Opcodes.ACONST_NULL))
            )
            (§ else 
                (ß gen.newInstance(objtype))
                (ß gen.dup())
                (§ if (ß supportsMeta())
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                )
                (§ loop-when-recur [(ß ISeq s = RT.seq(closesExprs))] (ß s != nil) [(ß s = s.next())]
                    (§ let LocalBindingExpr lbe = (LocalBindingExpr) s.first())
                    (§ let LocalBinding lb = lbe.b)
                    (§ if (ß lb.getPrimitiveType() != nil)
                        (ß objx.emitUnboxedLocal(gen, lb))
                    )
                    (§ else 
                        (ß objx.emitLocal(gen, lb, lbe.shouldClear))
                    )
                )
                (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes())))
            )
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ field Class jc)

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr.tagToClass(tag) :or IFn.class)
            )
            jc
        )

        (§ method void emitAssignLocal(GeneratorAdapter gen, LocalBinding lb, Expr val)
            (§ if (ß !isMutable(lb))
                (§ throw new IllegalArgumentException("Cannot assign to non-mutable: " + lb.name))
            )
            (§ let Class primc = lb.getPrimitiveType())
            (ß gen.loadThis())
            (§ if (ß primc != nil)
                (§ if (ß !(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive()))
                    (§ throw new IllegalArgumentException("Must assign primitive to primitive mutable: " + lb.name))
                )
                (§ let MaybePrimitiveExpr me = (MaybePrimitiveExpr) val)
                (ß me.emitUnboxed(C.EXPRESSION, this, gen))
                (ß gen.putField(objtype, lb.name, Type.getType(primc)))
            )
            (§ else 
                (ß val.emit(C.EXPRESSION, this, gen))
                (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
            )
            nil
        )

        (§ method- void emitLocal(GeneratorAdapter gen, LocalBinding lb, boolean clear)
            (§ if (ß closes.containsKey(lb))
                (§ let Class primc = lb.getPrimitiveType())
                (ß gen.loadThis())
                (§ if (ß primc != nil)
                    (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                    (ß HostExpr.emitBoxReturn(this, gen, primc))
                )
                (§ else 
                    (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                    (§ if (ß onceOnly && clear && lb.canBeCleared)
                        (ß gen.loadThis())
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
            )
            (§ else 
                (§ let int argoff = canBeDirect ? 0 :or 1)
                (§ let Class primc = lb.getPrimitiveType())
                (§ if (ß lb.isArg)
                    (ß gen.loadArg(lb.idx-argoff))
                    (§ if (ß primc != nil)
                        (ß HostExpr.emitBoxReturn(this, gen, primc))
                    )
                    (§ elseif (ß clear && lb.canBeCleared)
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.storeArg(lb.idx - argoff))
                    )
                )
                (§ else 
                    (§ if (ß primc != nil)
                        (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                        (ß HostExpr.emitBoxReturn(this, gen, primc))
                    )
                    (§ else 
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx))
                        (§ if (ß clear && lb.canBeCleared)
                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                        )
                    )
                )
            )
            nil
        )

        (§ method- void emitUnboxedLocal(GeneratorAdapter gen, LocalBinding lb)
            (§ let int argoff = canBeDirect ? 0 :or 1)
            (§ let Class primc = lb.getPrimitiveType())
            (§ if (ß closes.containsKey(lb))
                (ß gen.loadThis())
                (ß gen.getField(objtype, lb.name, Type.getType(primc)))
            )
            (§ elseif (ß lb.isArg)
                (ß gen.loadArg(lb.idx-argoff))
            )
            (§ else 
                (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
            )
            nil
        )

        (§ method void emitVar(GeneratorAdapter gen, Var var)
            (§ let Integer i = (Integer) vars.valAt(var))
            (ß emitConstant(gen, i))
            nil
        )

        (§ def Method varGetMethod = Method.getMethod("Object get()"))
        (§ def Method varGetRawMethod = Method.getMethod("Object getRawRoot()"))

        (§ method void emitVarValue(GeneratorAdapter gen, Var v)
            (§ let Integer i = (Integer) vars.valAt(v))
            (§ if (ß !v.isDynamic())
                (ß emitConstant(gen, i))
                (ß gen.invokeVirtual(VAR_TYPE, varGetRawMethod))
            )
            (§ else 
                (ß emitConstant(gen, i))
                (ß gen.invokeVirtual(VAR_TYPE, varGetMethod))
            )
            nil
        )

        (§ method void emitKeyword(GeneratorAdapter gen, Keyword k)
            (§ let Integer i = (Integer) keywords.valAt(k))
            (ß emitConstant(gen, i))
            nil
        )

        (§ method void emitConstant(GeneratorAdapter gen, int id)
            (ß usedConstants = (IPersistentSet) usedConstants.cons(id))
            (ß gen.getStatic(objtype, constantName(id), constantType(id)))
            nil
        )

        (§ method String constantName(int id)
            (ß CONST_PREFIX + id)
        )

        (§ method String siteName(int n)
            (ß "__site__" + n)
        )

        (§ method String siteNameStatic(int n)
            (ß siteName(n) + "__")
        )

        (§ method String thunkName(int n)
            (ß "__thunk__" + n)
        )

        (§ method String cachedClassName(int n)
            (ß "__cached_class__" + n)
        )

        (§ method String cachedVarName(int n)
            (ß "__cached_var__" + n)
        )

        (§ method String varCallsiteName(int n)
            (ß "__var__callsite__" + n)
        )

        (§ method String thunkNameStatic(int n)
            (ß thunkName(n) + "__")
        )

        (§ method Type constantType(int id)
            (§ let Object o = constants.nth(id))
            (§ let Class c = cloiure.lang.Util.classOf(o))
            (§ if (ß c!= nil && Modifier.isPublic(c.getModifiers()))
                ;; can't emit derived fn types due to visibility
                (§ if (ß LazySeq.class.isAssignableFrom(c))
                    (§ return (ß Type.getType(ISeq.class)))
                )
                (§ elseif (ß c == Keyword.class)
                    (§ return (ß Type.getType(Keyword.class)))
                )
                (§ elseif (ß RestFn.class.isAssignableFrom(c))
                    (§ return (ß Type.getType(RestFn.class)))
                )
                (§ elseif (ß AFn.class.isAssignableFrom(c))
                    (§ return (ß Type.getType(AFn.class)))
                )
                (§ elseif (ß c == Var.class)
                    (§ return (ß Type.getType(Var.class)))
                )
                (§ elseif (ß c == String.class)
                    (§ return (ß Type.getType(String.class)))
                )
            )
            (ß OBJECT_TYPE)
        )
    )

    #_non-static
    (§ enum PATHTYPE
        (§ item PATH),
        (§ item BRANCH)
    )

    (class-ns PathNode
        (§ field PATHTYPE type)
        (§ field PathNode parent)

        (§ constructor PathNode(PATHTYPE type, PathNode parent)
            (ß this.type = type)
            (ß this.parent = parent)
            this
        )
    )

    (§ defn PathNode clearPathRoot()
        (ß (PathNode) CLEAR_ROOT.get())
    )

    #_non-static
    (§ enum PSTATE
        (§ item REQ),
        (§ item REST),
        (§ item DONE)
    )

    (class-ns FnMethod (§ extends ObjMethod)
        ;; localbinding->localbinding
        (§ field PersistentVector reqParms = PersistentVector.EMPTY)
        (§ field LocalBinding restParm = nil)
        (§ field Type[] argtypes)
        (§ field Class[] argclasses)
        (§ field Class retClass)
        (§ field String prim)

        (§ constructor FnMethod(ObjExpr objx, ObjMethod parent)
            (§ super(objx, parent))
            this
        )

        (§ defn char classChar(Object x)
            (§ let Class c = nil)
            (§ if (ß x instanceof Class)
                (ß c = (Class) x)
            )
            (§ elseif (ß x instanceof Symbol)
                (ß c = primClass((Symbol) x))
            )
            (§ if (ß c == nil || !c.isPrimitive())
                (§ return (ß \O))
            )
            (§ if (ß c == long.class)
                (§ return (ß \L))
            )
            (§ if (ß c == double.class)
                (§ return (ß \D))
            )
            (§ throw new IllegalArgumentException("Only long and double primitives are supported"))
        )

        (§ defn String primInterface(IPersistentVector arglist)
            (§ let StringBuilder sb = new StringBuilder())
            (§ loop-when-recur [(ß int i = 0)] (ß i < arglist.count()) [(ß i++)]
                (ß sb.append(classChar(tagOf(arglist.nth(i)))))
            )
            (ß sb.append(classChar(tagOf(arglist))))
            (§ let String ret = sb.toString())
            (§ let boolean prim = ret.contains("L") || ret.contains("D"))
            (§ if (ß prim && arglist.count() > 4)
                (§ throw new IllegalArgumentException("fns taking primitives support only 4 or fewer args"))
            )
            (§ if (ß prim)
                (§ return (ß "cloiure.lang.IFn$" + ret))
            )
            nil
        )

        (§ defn FnMethod parse(ObjExpr objx, ISeq form, Object rettag)
            ;; ([args] body...)
            (§ let IPersistentVector parms = (IPersistentVector) RT.first(form))
            (§ let ISeq body = RT.next(form))
            (§ try 
                (§ let FnMethod method = new FnMethod(objx, (ObjMethod) METHOD.deref()))
                (ß method.line = lineDeref())
                (ß method.column = columnDeref())
                ;; register as the current method and set up a new env frame
                (§ let PathNode pnode =  (PathNode) CLEAR_PATH.get())
                (§ if (ß pnode == nil)
                    (ß pnode = new PathNode(PATHTYPE.PATH, nil))
                )
                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map METHOD, method,
                      #_map LOCAL_ENV, LOCAL_ENV.deref(),
                      #_map LOOP_LOCALS, nil,
                      #_map NEXT_LOCAL_NUM, 0,
                      #_map CLEAR_PATH, pnode,
                      #_map CLEAR_ROOT, pnode,
                      #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                      #_map METHOD_RETURN_CONTEXT, RT.T
                )))

                (ß method.prim = primInterface(parms))
                (§ if (ß method.prim != nil)
                    (ß method.prim = method.prim.replace(\., \/))
                )

                (§ if (ß rettag instanceof String)
                    (ß rettag = Symbol.intern(nil, (String) rettag))
                )
                (§ if (ß !(rettag instanceof Symbol))
                    (ß rettag = nil)
                )
                (§ if (ß rettag != nil)
                    (§ let String retstr = ((Symbol)rettag).getName())
                    (§ if (ß !(retstr.equals("long") || retstr.equals("double")))
                        (ß rettag = nil)
                    )
                )
                (ß method.retClass = tagClass((tagOf(parms) != nil) ? tagOf(parms) :or rettag))
                (§ if (ß method.retClass.isPrimitive())
                    (§ if (ß !(method.retClass == double.class || method.retClass == long.class))
                        (§ throw new IllegalArgumentException("Only long and double primitives are supported"))
                    )
                )
                (§ else 
                    (ß method.retClass = Object.class)
                )
                ;; register 'this' as local 0
                (§ if (ß objx.thisName != nil)
                    (ß registerLocal(Symbol.intern(objx.thisName), nil, nil, false))
                )
                (§ else 
                    (ß getAndIncLocalNum())
                )
                (§ let PSTATE state = PSTATE.REQ)
                (§ let PersistentVector argLocals = PersistentVector.EMPTY)
                (§ let ArrayList<Type> argtypes = new ArrayList())
                (§ let ArrayList<Class> argclasses = new ArrayList())
                (§ loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                    (§ if (ß !(parms.nth(i) instanceof Symbol))
                        (§ throw new IllegalArgumentException("fn params must be Symbols"))
                    )
                    (§ let Symbol p = (Symbol) parms.nth(i))
                    (§ if (ß p.getNamespace() != nil)
                        (§ throw Util.runtimeException("Can't use qualified name as parameter: " + p))
                    )
                    (§ if (ß p.equals(_AMP_))
                        (§ if (ß state == PSTATE.REQ)
                            (ß state = PSTATE.REST)
                        )
                        (§ else 
                            (§ throw Util.runtimeException("Invalid parameter list"))
                        )
                    )
                    (§ else 
                        (§ let Class pc = primClass(tagClass(tagOf(p))))
                        (§ if (ß pc.isPrimitive() && !(pc == double.class || pc == long.class))
                            (§ throw new IllegalArgumentException("Only long and double primitives are supported: " + p))
                        )

                        (§ if (ß state == PSTATE.REST && tagOf(p) != nil)
                            (§ throw Util.runtimeException("& arg cannot have type hint"))
                        )
                        (§ if (ß state == PSTATE.REST && method.prim != nil)
                            (§ throw Util.runtimeException("fns taking primitives cannot be variadic"))
                        )

                        (§ if (ß state == PSTATE.REST)
                            (ß pc = ISeq.class)
                        )
                        (ß argtypes.add(Type.getType(pc)))
                        (ß argclasses.add(pc))
                        (§ let LocalBinding lb = pc.isPrimitive() ? registerLocal(p, nil, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), nil, true))
                        (ß argLocals = argLocals.cons(lb))
                        (§ switch (ß state)
                            (§ case REQ)
                            (do
                                (ß method.reqParms = method.reqParms.cons(lb))
                                (§ break )
                            )
                            (§ case REST)
                            (do
                                (ß method.restParm = lb)
                                (ß state = PSTATE.DONE)
                                (§ break )
                            )
                            (§ default )
                            (do
                                (§ throw Util.runtimeException("Unexpected parameter"))
                            )
                        )
                    )
                )
                (§ if (ß method.reqParms.count() > MAX_POSITIONAL_ARITY)
                    (§ throw Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params"))
                )
                (ß LOOP_LOCALS.set(argLocals))
                (ß method.argLocals = argLocals)
                (ß method.argtypes = argtypes.toArray(new Type[argtypes.size()]))
                (ß method.argclasses = argclasses.toArray(new Class[argtypes.size()]))
                (§ if (ß method.prim != nil)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < method.argclasses.length) [(ß i++)]
                        (§ if (ß method.argclasses[i] == long.class || method.argclasses[i] == double.class)
                            (ß getAndIncLocalNum())
                        )
                    )
                )
                (ß method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                method
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )

        (§ method void emit(ObjExpr fn, ClassVisitor cv)
            (§ if (ß fn.canBeDirect)
                (ß doEmitStatic(fn, cv))
            )
            (§ elseif (ß prim != nil)
                (ß doEmitPrim(fn, cv))
            )
            (§ else 
                (ß doEmit(fn, cv))
            )
            nil
        )

        (§ method void doEmitStatic(ObjExpr fn, ClassVisitor cv)
            (§ let Type returnType = Type.getType(retClass))

            (§ let Method ms = new Method("invokeStatic", returnType, argtypes))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
                    ms,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv))
            (ß gen.visitCode())
            (§ let Label loopLabel = gen.mark())
            (ß gen.visitLineNumber(line, loopLabel))
            (§ try 
                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                (ß emitBody(objx, gen, retClass, body))

                (§ let Label end = gen.mark())
                (§ loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )

            (ß gen.returnValue())
            (ß gen.endMethod())

            ;; generate the regular invoke, calling the static method
            (§ let Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))

            (ß gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv))
            (ß gen.visitCode())
            (§ loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                (ß gen.loadArg(i))
                (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                (§ if (ß !argclasses[i].isPrimitive())
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    (ß gen.storeArg(i))
                )
            )
            (§ let Label callLabel = gen.mark())
            (ß gen.visitLineNumber(line, callLabel))
            (ß gen.invokeStatic(objx.objtype, ms))
            (ß gen.box(returnType))

            (ß gen.returnValue())
            (ß gen.endMethod())

            ;; generate primInvoke if prim
            (§ if (ß prim != nil)
                (§ if (ß retClass == double.class || retClass == long.class)
                    (ß returnType = getReturnType())
                )
                (§ let else returnType = OBJECT_TYPE)

                (§ let Method pm = new Method("invokePrim", returnType, argtypes))

                (ß gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                        pm,
                        nil,
                        ;; todo don't hardwire this
                        EXCEPTION_TYPES,
                        cv))
                (ß gen.visitCode())
                (§ loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                    (ß gen.loadArg(i))
                    (§ if (ß !argclasses[i].isPrimitive())
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.storeArg(i))
                    )
                )
                (ß gen.invokeStatic(objx.objtype, ms))

                (ß gen.returnValue())
                (ß gen.endMethod())
            )
            nil
        )

        (§ method void doEmitPrim(ObjExpr fn, ClassVisitor cv)
            (§ let Type returnType)
            (§ if (ß retClass == double.class || retClass == long.class)
                (ß returnType = getReturnType())
            )
            (§ else 
                (ß returnType = OBJECT_TYPE)
            )
            (§ let Method ms = new Method("invokePrim", returnType, argtypes))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                    ms,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv))
            (ß gen.visitCode())

            (§ let Label loopLabel = gen.mark())
            (ß gen.visitLineNumber(line, loopLabel))
            (§ try 
                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                (ß emitBody(objx, gen, retClass, body))

                (§ let Label end = gen.mark())
                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                (§ loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )

            (ß gen.returnValue())
            (ß gen.endMethod())

            ;; generate the regular invoke, calling the prim method
            (§ let Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))

            (ß gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv))
            (ß gen.visitCode())
            (ß gen.loadThis())
            (§ loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                (ß gen.loadArg(i))
                (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
            )
            (ß gen.invokeInterface(Type.getType("L"+prim+";"), ms))
            (ß gen.box(getReturnType()))

            (ß gen.returnValue())
            (ß gen.endMethod())
            nil
        )

        (§ method void doEmit(ObjExpr fn, ClassVisitor cv)
            (§ let Method m = new Method(getMethodName(), getReturnType(), getArgTypes()))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv))
            (ß gen.visitCode())

            (§ let Label loopLabel = gen.mark())
            (ß gen.visitLineNumber(line, loopLabel))
            (§ try 
                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                (ß body.emit(C.RETURN, fn, gen))
                (§ let Label end = gen.mark())

                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                (§ loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )

            (ß gen.returnValue())
            (ß gen.endMethod())
            nil
        )

        (§ method PersistentVector reqParms()
            reqParms
        )

        (§ method LocalBinding restParm()
            restParm
        )

        (§ method boolean isVariadic()
            (ß (restParm != nil))
        )

        (§ method int numParams()
            (ß reqParms.count() + (isVariadic() ? 1 :or 0))
        )

        (§ method String getMethodName()
            (ß isVariadic() ? "doInvoke" :or "invoke")
        )

        (§ method Type getReturnType()
            (§ if (ß prim != nil) ;; objx.isStatic
                (§ return (ß Type.getType(retClass)))
            )
            (ß OBJECT_TYPE)
        )

        (§ method Type[] getArgTypes()
            (§ if (ß isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
                (§ let Type[] ret = new Type[MAX_POSITIONAL_ARITY + 1])
                (§ loop-when-recur [(ß int i = 0)] (ß i < MAX_POSITIONAL_ARITY + 1) [(ß i++)]
                    (ß ret[i] = OBJECT_TYPE)
                )
                (§ return ret)
            )
            (ß ARG_TYPES[numParams()])
        )

        (§ method void emitClearLocals(GeneratorAdapter gen)
            nil
        )
    )

    #_abstract
    (class-ns ObjMethod
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        (§ field ObjMethod parent)
        ;; localbinding->localbinding
        (§ field IPersistentMap locals = nil)
        ;; num->localbinding
        (§ field IPersistentMap indexlocals = nil)
        (§ field Expr body = nil)
        (§ field ObjExpr objx)
        (§ field PersistentVector argLocals)
        (§ field int maxLocal = 0)
        (§ field int line)
        (§ field int column)
        (§ field boolean usesThis = false)
        (§ field PersistentHashSet localsUsedInCatchFinally = PersistentHashSet.EMPTY)
        #_protected
        (§ field IPersistentMap methodMeta)

        (§ method IPersistentMap locals()
            locals
        )

        (§ method Expr body()
            body
        )

        (§ method ObjExpr objx()
            objx
        )

        (§ method PersistentVector argLocals()
            argLocals
        )

        (§ method int maxLocal()
            maxLocal
        )

        (§ method int line()
            line
        )

        (§ method int column()
            column
        )

        (§ constructor ObjMethod(ObjExpr objx, ObjMethod parent)
            (ß this.parent = parent)
            (ß this.objx = objx)
            this
        )

        (§ defn void emitBody(ObjExpr objx, GeneratorAdapter gen, Class retClass, Expr body)
            (§ let MaybePrimitiveExpr be = (MaybePrimitiveExpr) body)
            (§ if (ß Util.isPrimitive(retClass) && be.canEmitPrimitive())
                (§ let Class bc = maybePrimitiveType(be))
                (§ if (ß bc == retClass)
                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                )
                (§ elseif (ß retClass == long.class && bc == int.class)
                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                    (ß gen.visitInsn(I2L))
                )
                (§ elseif (ß retClass == double.class && bc == float.class)
                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                    (ß gen.visitInsn(F2D))
                )
                (§ elseif (ß retClass == int.class && bc == long.class)
                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                )
                (§ elseif (ß retClass == float.class && bc == double.class)
                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                    (ß gen.visitInsn(D2F))
                )
                (§ else 
                    (§ throw new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass()))
                )
            )
            (§ else 
                (ß body.emit(C.RETURN, objx, gen))
                (§ if (ß retClass == void.class)
                    (ß gen.pop())
                )
                (§ else 
                    (ß gen.unbox(Type.getType(retClass)))
                )
            )
            nil
        )

        (§ abstract int numParams())
        (§ abstract String getMethodName())
        (§ abstract Type getReturnType())
        (§ abstract Type[] getArgTypes())

        (§ method void emit(ObjExpr fn, ClassVisitor cv)
            (§ let Method m = new Method(getMethodName(), getReturnType(), getArgTypes()))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv))
            (ß gen.visitCode())

            (§ let Label loopLabel = gen.mark())
            (ß gen.visitLineNumber(line, loopLabel))
            (§ try 
                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                (ß body.emit(C.RETURN, fn, gen))
                (§ let Label end = gen.mark())
                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                (§ loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )

            (ß gen.returnValue())
            (ß gen.endMethod())
            nil
        )

        (§ method void emitClearLocals(GeneratorAdapter gen)
            nil
        )

        (§ method void emitClearLocalsOld(GeneratorAdapter gen)
            (§ loop-when-recur [(ß int i = 0)] (ß i < argLocals.count()) [(ß i++)]
                (§ let LocalBinding lb = (LocalBinding) argLocals.nth(i))
                (§ if (ß !localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == nil)
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    (ß gen.storeArg(lb.idx - 1))
                )
            )
            (§ loop-when-recur [(ß int i = numParams() + 1)] (ß i < maxLocal + 1) [(ß i++)]
                (§ if (ß !localsUsedInCatchFinally.contains(i))
                    (§ let LocalBinding b = (LocalBinding) RT.get(indexlocals, i))
                    (§ if (ß b == nil || maybePrimitiveType(b.init) == nil)
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i))
                    )
                )
            )
            nil
        )

        (§ method void emitClearThis(GeneratorAdapter gen)
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (ß gen.visitVarInsn(Opcodes.ASTORE, 0))
            nil
        )
    )

    (class-ns LocalBinding
        (§ field Symbol sym)
        (§ field Symbol tag)
        (§ field Expr init)
        (§ field int idx)
        (§ field String name)
        (§ field boolean isArg)
        (§ field PathNode clearPathRoot)
        (§ field boolean canBeCleared = !RT.booleanCast(getCompilerOption(disableLocalsClearingKey)))
        (§ field boolean recurMistmatch = false)
        (§ field boolean used = false)

        (§ constructor LocalBinding(int num, Symbol sym, Symbol tag, Expr init, boolean isArg, PathNode clearPathRoot)
            (§ if (ß maybePrimitiveType(init) != nil && tag != nil)
                (§ throw new UnsupportedOperationException("Can't type hint a local with a primitive initializer"))
            )
            (ß this.idx = num)
            (ß this.sym = sym)
            (ß this.tag = tag)
            (ß this.init = init)
            (ß this.isArg = isArg)
            (ß this.clearPathRoot = clearPathRoot)
            (ß name = munge(sym.name))
            this
        )

        (§ field Boolean hjc)

        (§ method boolean hasJavaClass()
            (§ if (ß hjc == nil)
                (§ if (ß init != nil && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                    (ß hjc =  false)
                )
                (§ else 
                    (ß hjc = (tag != nil || (init != nil && init.hasJavaClass())))
                )
            )
            hjc
        )

        (§ field Class jc)

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or init.getJavaClass())
            )
            jc
        )

        (§ method Class getPrimitiveType()
            (ß maybePrimitiveType(init))
        )
    )

    (class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
        (§ field LocalBinding b)
        (§ field Symbol tag)

        (§ field PathNode clearPath)
        (§ field PathNode clearRoot)
        (§ field boolean shouldClear = false)

        (§ constructor LocalBindingExpr(LocalBinding b, Symbol tag)
            (§ if (ß b.getPrimitiveType() != nil && tag != nil)
                (§ throw new UnsupportedOperationException("Can't type hint a primitive local"))
            )
            (ß this.b = b)
            (ß this.tag = tag)

            (ß this.clearPath = (PathNode)CLEAR_PATH.get())
            (ß this.clearRoot = (PathNode)CLEAR_ROOT.get())
            (§ let IPersistentCollection sites = (IPersistentCollection) RT.get(CLEAR_SITES.get(), b))
            (ß b.used = true)

            (§ if (ß b.idx > 0)
                (§ if (ß sites != nil)
                    (§ loop-when-recur [(ß ISeq s = sites.seq())] (ß s != nil) [(ß s = s.next())]
                        (§ let LocalBindingExpr o = (LocalBindingExpr) s.first())
                        (§ let PathNode common = commonPath(clearPath, o.clearPath))
                        (§ if (ß common != nil && common.type == PATHTYPE.PATH)
                            (ß o.shouldClear = false)
                        )
                    )
                )

                (§ if (ß clearRoot == b.clearPathRoot)
                    (ß this.shouldClear = true)
                    (ß sites = RT.conj(sites, this))
                    (ß CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites)))
                )
            )
            this
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval locals"))
        )

        (§ method boolean canEmitPrimitive()
            (ß (b.getPrimitiveType() != nil))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitUnboxedLocal(gen, b))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, shouldClear))
            )
            nil
        )

        (§ method Object evalAssign(Expr val)
            (§ throw new UnsupportedOperationException("Can't eval locals"))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (ß objx.emitAssignLocal(gen, b, val))
            (§ if (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, false))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil || b.hasJavaClass()))
        )

        (§ field Class jc)

        (§ method Class getJavaClass()
            (§ if (ß jc == nil)
                (§ if (ß tag != nil)
                    (ß jc = HostExpr.tagToClass(tag))
                )
                (§ else 
                    (ß jc = b.getJavaClass())
                )
            )
            jc
        )
    )

    (class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field PersistentVector exprs)

        (§ method PersistentVector exprs()
            exprs
        )

        (§ constructor BodyExpr(PersistentVector exprs)
            (ß this.exprs = exprs)
            this
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frms)
                (§ let ISeq forms = (ISeq) frms)
                (§ if (ß Util.equals(RT.first(forms), DO))
                    (ß forms = RT.next(forms))
                )
                (§ let PersistentVector exprs = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß )] (ß forms != nil) [(ß forms = forms.next())]
                    (§ let Expr e = (context != C.EVAL && (context == C.STATEMENT || forms.next() != nil)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first()))
                    (ß exprs = exprs.cons(e))
                )
                (§ if (ß exprs.count() == 0)
                    (ß exprs = exprs.cons(NIL_EXPR))
                )
                (ß new BodyExpr(exprs))
            )
        )

        (§ method Object eval()
            (§ let Object ret = nil)
            (§ doseq [#_"Object" o exprs]
                (§ let Expr e = (Expr) o)
                (ß ret = e.eval())
            )
            ret
        )

        (§ method boolean canEmitPrimitive()
            (ß (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive()))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ loop-when-recur [(ß int i = 0)] (ß i < exprs.count() - 1) [(ß i++)]
                (§ let Expr e = (Expr) exprs.nth(i))
                (ß e.emit(C.STATEMENT, objx, gen))
            )
            (§ let MaybePrimitiveExpr last = (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1))
            (ß last.emitUnboxed(context, objx, gen))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ loop-when-recur [(ß int i = 0)] (ß i < exprs.count() - 1) [(ß i++)]
                (§ let Expr e = (Expr) exprs.nth(i))
                (ß e.emit(C.STATEMENT, objx, gen))
            )
            (§ let Expr last = (Expr) exprs.nth(exprs.count() - 1))
            (ß last.emit(context, objx, gen))
            nil
        )

        (§ method boolean hasJavaClass()
            (ß lastExpr().hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß lastExpr().getJavaClass())
        )

        (§ method- Expr lastExpr()
            (ß (Expr) exprs.nth(exprs.count() - 1))
        )
    )

    (class-ns BindingInit
        (§ field LocalBinding binding)
        (§ field Expr init)

        (§ method LocalBinding binding()
            binding
        )

        (§ method Expr init()
            init
        )

        (§ constructor BindingInit(LocalBinding binding, Expr init)
            (ß this.binding = binding)
            (ß this.init = init)
            this
        )
    )

    (class-ns LetFnExpr (§ implements Expr)
        (§ field PersistentVector bindingInits)
        (§ field Expr body)

        (§ constructor LetFnExpr(PersistentVector bindingInits, Expr body)
            (ß this.bindingInits = bindingInits)
            (ß this.body = body)
            this
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (letfns* [var (fn [args] body) ...] body...)
                (§ if (ß !(RT.second(form) instanceof IPersistentVector))
                    (§ throw new IllegalArgumentException("Bad binding form, expected vector"))
                )

                (§ let IPersistentVector bindings = (IPersistentVector) RT.second(form))
                (§ if (ß (bindings.count() % 2) != 0)
                    (§ throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs"))
                )

                (§ let ISeq body = RT.next(RT.next(form)))

                (§ if (ß context == C.EVAL)
                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                (§ let IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))

                (§ try 
                    (ß Var.pushThreadBindings(dynamicBindings))

                    ;; pre-seed env (like Lisp labels)
                    (§ let PersistentVector lbs = PersistentVector.EMPTY)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                        (§ if (ß !(bindings.nth(i) instanceof Symbol))
                            (§ throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i)))
                        )
                        (§ let Symbol sym = (Symbol) bindings.nth(i))
                        (§ if (ß sym.getNamespace() != nil)
                            (§ throw Util.runtimeException("Can't let qualified name: " + sym))
                        )
                        (§ let LocalBinding lb = registerLocal(sym, tagOf(sym), nil, false))
                        (ß lb.canBeCleared = false)
                        (ß lbs = lbs.cons(lb))
                    )
                    (§ let PersistentVector bindingInits = PersistentVector.EMPTY)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                        (§ let Symbol sym = (Symbol) bindings.nth(i))
                        (§ let Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))
                        (§ let LocalBinding lb = (LocalBinding) lbs.nth(i / 2))
                        (ß lb.init = init)
                        (§ let BindingInit bi = new BindingInit(lb, init))
                        (ß bindingInits = bindingInits.cons(bi))
                    )
                    (ß new LetFnExpr(bindingInits, (new BodyExpr.Parser()).parse(context, body)))
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )
            )
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval letfns"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (ß gen.visitInsn(Opcodes.ACONST_NULL))
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
            )

            (§ let IPersistentSet lbset = PersistentHashSet.EMPTY)

            (§ loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (ß lbset = (IPersistentSet) lbset.cons(bi.binding))
                (ß bi.init.emit(C.EXPRESSION, objx, gen))
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
            )

            (§ loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (§ let ObjExpr fe = (ObjExpr) bi.init)
                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx))
                (ß fe.emitLetFnInits(gen, objx, lbset))
            )

            (§ let Label loopLabel = gen.mark())

            (ß body.emit(context, objx, gen))

            (§ let Label end = gen.mark())
            (§ loop-when-recur [(ß ISeq bis = bindingInits.seq())] (ß bis != nil) [(ß bis = bis.next())]
                (§ let BindingInit bi = (BindingInit) bis.first())
                (§ let String lname = bi.binding.name)
                (§ if (ß lname.endsWith("__auto__"))
                    (ß lname += RT.nextID())
                )
                (§ let Class primc = maybePrimitiveType(bi.init))
                (§ if (ß primc != nil)
                    (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, loopLabel, end, bi.binding.idx))
                )
                (§ else 
                    (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, loopLabel, end, bi.binding.idx))
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß body.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß body.getJavaClass())
        )
    )

    (class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field PersistentVector bindingInits)
        (§ field Expr body)
        (§ field boolean isLoop)

        (§ constructor LetExpr(PersistentVector bindingInits, Expr body, boolean isLoop)
            (ß this.bindingInits = bindingInits)
            (ß this.body = body)
            (ß this.isLoop = isLoop)
            this
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (let [var val var2 val2 ...] body...)
                (§ let boolean isLoop = RT.first(form).equals(LOOP))
                (§ if (ß !(RT.second(form) instanceof IPersistentVector))
                    (§ throw new IllegalArgumentException("Bad binding form, expected vector"))
                )

                (§ let IPersistentVector bindings = (IPersistentVector) RT.second(form))
                (§ if (ß (bindings.count() % 2) != 0)
                    (§ throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs"))
                )

                (§ let ISeq body = RT.next(RT.next(form)))

                (§ if (ß context == C.EVAL || (context == C.EXPRESSION && isLoop))
                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                (§ let IPersistentMap backupMethodLocals = method.locals)
                (§ let IPersistentMap backupMethodIndexLocals = method.indexlocals)
                (§ let IPersistentVector recurMismatches = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß int i = 0)] (ß i < bindings.count() / 2) [(ß i++)]
                    (ß recurMismatches = recurMismatches.cons(RT.F))
                )

                ;; may repeat once for each binding with a mismatch, return breaks
                (§ while true
                    (§ let IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))
                    (ß method.locals = backupMethodLocals)
                    (ß method.indexlocals = backupMethodIndexLocals)

                    (§ let PathNode looproot = new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))
                    (§ let PathNode clearroot = new PathNode(PATHTYPE.PATH, looproot))
                    (§ let PathNode clearpath = new PathNode(PATHTYPE.PATH, looproot))
                    (§ if (ß isLoop)
                        (ß dynamicBindings = dynamicBindings.assoc(LOOP_LOCALS, nil))
                    )

                    (§ try 
                        (ß Var.pushThreadBindings(dynamicBindings))

                        (§ let PersistentVector bindingInits = PersistentVector.EMPTY)
                        (§ let PersistentVector loopLocals = PersistentVector.EMPTY)
                        (§ loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                            (§ if (ß !(bindings.nth(i) instanceof Symbol))
                                (§ throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i)))
                            )
                            (§ let Symbol sym = (Symbol) bindings.nth(i))
                            (§ if (ß sym.getNamespace() != nil)
                                (§ throw Util.runtimeException("Can't let qualified name: " + sym))
                            )
                            (§ let Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))
                            (§ if (ß isLoop)
                                (§ if (ß recurMismatches != nil && RT.booleanCast(recurMismatches.nth(i / 2)))
                                    (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "box", RT.vector(init), false))
                                    (§ if (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                        (ß RT.errPrintWriter().println("Auto-boxing loop arg: " + sym))
                                    )
                                )
                                (§ elseif (ß maybePrimitiveType(init) == int.class)
                                    (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "longCast", RT.vector(init), false))
                                )
                                (§ elseif (ß maybePrimitiveType(init) == float.class)
                                    (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "doubleCast", RT.vector(init), false))
                                )
                            )
                            ;; sequential enhancement of env (like Lisp let*)
                            (§ try 
                                (§ if (ß isLoop)
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, nil)))
                                )
                                (§ let LocalBinding lb = registerLocal(sym, tagOf(sym), init, false))
                                (§ let BindingInit bi = new BindingInit(lb, init))
                                (ß bindingInits = bindingInits.cons(bi))
                                (§ if (ß isLoop)
                                    (ß loopLocals = loopLocals.cons(lb))
                                )
                            )
                            (§ finally 
                                (§ if (ß isLoop)
                                    (ß Var.popThreadBindings())
                                )
                            )
                        )
                        (§ if (ß isLoop)
                            (ß LOOP_LOCALS.set(loopLocals))
                        )
                        (§ let Expr bodyExpr)
                        (§ let boolean moreMismatches = false)
                        (§ try 
                            (§ if (ß isLoop)
                                (§ let Object methodReturnContext = (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil)
                                (ß Var.pushThreadBindings(RT.map(
                                      #_map CLEAR_PATH, clearpath,
                                      #_map CLEAR_ROOT, clearroot,
                                      #_map NO_RECUR, nil,
                                      #_map METHOD_RETURN_CONTEXT, methodReturnContext
                                )))
                            )
                            (ß bodyExpr = (new BodyExpr.Parser()).parse(isLoop ? C.RETURN :or context, body))
                        )
                        (§ finally 
                            (§ if (ß isLoop)
                                (ß Var.popThreadBindings())
                                (§ loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                                    (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                                    (§ if (ß lb.recurMistmatch)
                                        (ß recurMismatches = (IPersistentVector)recurMismatches.assoc(i, RT.T))
                                        (ß moreMismatches = true)
                                    )
                                )
                            )
                        )
                        (§ if (ß !moreMismatches)
                            (§ return (ß new LetExpr(bindingInits, bodyExpr, isLoop)))
                        )
                    )
                    (§ finally 
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval let/loop"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, false))
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, true))
            nil
        )

        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (§ let HashMap<BindingInit, Label> bindingLabels = new HashMap())
            (§ loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (§ let Class primc = maybePrimitiveType(bi.init))
                (§ if (ß primc != nil)
                    (ß ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx))
                )
                (§ else 
                    (ß bi.init.emit(C.EXPRESSION, objx, gen))
                    (§ if (ß !bi.binding.used && bi.binding.canBeCleared)
                        (ß gen.pop())
                    )
                    (§ else 
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                    )
                )
                (ß bindingLabels.put(bi, gen.mark()))
            )
            (§ let Label loopLabel = gen.mark())
            (§ if (ß isLoop)
                (§ try 
                    (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel)))
                    (§ if (ß emitUnboxed)
                        (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                    )
                    (§ else 
                        (ß body.emit(context, objx, gen))
                    )
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )
            )
            (§ else 
                (§ if (ß emitUnboxed)
                    (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                )
                (§ else 
                    (ß body.emit(context, objx, gen))
                )
            )
            (§ let Label end = gen.mark())
            (§ loop-when-recur [(ß ISeq bis = bindingInits.seq())] (ß bis != nil) [(ß bis = bis.next())]
                (§ let BindingInit bi = (BindingInit) bis.first())
                (§ let String lname = bi.binding.name)
                (§ if (ß lname.endsWith("__auto__"))
                    (ß lname += RT.nextID())
                )
                (§ let Class primc = maybePrimitiveType(bi.init))
                (§ if (ß primc != nil)
                    (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, bindingLabels.get(bi), end, bi.binding.idx))
                )
                (§ else 
                    (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, bindingLabels.get(bi), end, bi.binding.idx))
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß body.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß body.getJavaClass())
        )

        (§ method boolean canEmitPrimitive()
            (ß (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive()))
        )
    )

    (class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field IPersistentVector args)
        (§ field IPersistentVector loopLocals)

        (§ field int line)
        (§ field int column)
        (§ field String source)

        (§ constructor RecurExpr(IPersistentVector loopLocals, IPersistentVector args, int line, int column, String source)
            (ß this.loopLocals = loopLocals)
            (ß this.args = args)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.source = source)
            this
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval recur"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label loopLabel = (Label) LOOP_LABEL.deref())
            (§ if (ß loopLabel == nil)
                (§ throw new IllegalStateException())
            )
            (§ loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                (§ let Expr arg = (Expr) args.nth(i))
                (§ if (ß lb.getPrimitiveType() != nil)
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ let Class pc = maybePrimitiveType(arg))
                    (§ if (ß pc == primc)
                        (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                    )
                    (§ elseif (ß primc == long.class && pc == int.class)
                        (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.visitInsn(I2L))
                    )
                    (§ elseif (ß primc == double.class && pc == float.class)
                        (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.visitInsn(F2D))
                    )
                    (§ elseif (ß primc == int.class && pc == long.class)
                        (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                    )
                    (§ elseif (ß primc == float.class && pc == double.class)
                        (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.visitInsn(D2F))
                    )
                    (§ else 
                        (§ throw new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName()))
                    )
                )
                (§ else 
                    (ß arg.emit(C.EXPRESSION, objx, gen))
                )
            )

            (§ loop-when-recur [(ß int i = loopLocals.count() - 1)] (ß i >= 0) [(ß i--)]
                (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                (§ let Class primc = lb.getPrimitiveType())
                (§ if (ß lb.isArg)
                    (ß gen.storeArg(lb.idx - (objx.canBeDirect ? 0 :or 1)))
                )
                (§ else 
                    (§ if (ß primc != nil)
                        (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx))
                    )
                    (§ else 
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                    )
                )
            )

            (ß gen.goTo(loopLabel))
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß RECUR_CLASS)
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let int line = lineDeref())
                (§ let int column = columnDeref())
                (§ let String source = (String) SOURCE.deref())

                (§ let ISeq form = (ISeq) frm)
                (§ let IPersistentVector loopLocals = (IPersistentVector) LOOP_LOCALS.deref())
                (§ if (ß context != C.RETURN || loopLocals == nil)
                    (§ throw new UnsupportedOperationException("Can only recur from tail position"))
                )
                (§ if (ß NO_RECUR.deref() != nil)
                    (§ throw new UnsupportedOperationException("Cannot recur across try"))
                )
                (§ let PersistentVector args = PersistentVector.EMPTY)
                (§ loop-when-recur [(ß ISeq s = RT.seq(form.next()))] (ß s != nil) [(ß s = s.next())]
                    (ß args = args.cons(analyze(C.EXPRESSION, s.first())))
                )
                (§ if (ß args.count() != loopLocals.count())
                    (§ throw new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count())))
                )
                (§ loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                    (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ if (ß primc != nil)
                        (§ let boolean mismatch = false)
                        (§ let Class pc = maybePrimitiveType((Expr) args.nth(i)))
                        (§ if (ß primc == long.class)
                            (§ if (ß !(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class))
                                (ß mismatch = true)
                            )
                        )
                        (§ elseif (ß primc == double.class)
                            (§ if (ß !(pc == double.class || pc == float.class))
                                (ß mismatch = true)
                            )
                        )
                        (§ if (ß mismatch)
                            (ß lb.recurMistmatch = true)
                            (§ if (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                (ß RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + ((pc != nil) ? pc.getName() :or "Object") + ", needed: " + primc.getName()))
                            )
                        )
                    )
                )
                (ß new RecurExpr(loopLocals, args, line, column, source))
            )
        )

        (§ method boolean canEmitPrimitive()
            true
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß emit(context, objx, gen))
            nil
        )
    )

    (§ defn- LocalBinding registerLocal(Symbol sym, Symbol tag, Expr init, boolean isArg)
        (§ let int num = getAndIncLocalNum())
        (§ let LocalBinding b = new LocalBinding(num, sym, tag, init, isArg, clearPathRoot()))
        (§ let IPersistentMap localsMap = (IPersistentMap) LOCAL_ENV.deref())
        (ß LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b)))
        (§ let ObjMethod method = (ObjMethod) METHOD.deref())
        (ß method.locals = (IPersistentMap) RT.assoc(method.locals, b, b))
        (ß method.indexlocals = (IPersistentMap) RT.assoc(method.indexlocals, num, b))
        b
    )

    (§ defn- int getAndIncLocalNum()
        (§ let int num = ((Number) NEXT_LOCAL_NUM.deref()).intValue())
        (§ let ObjMethod m = (ObjMethod) METHOD.deref())
        (§ if (ß num > m.maxLocal)
            (ß m.maxLocal = num)
        )
        (ß NEXT_LOCAL_NUM.set(num + 1))
        num
    )

    (§ defn Expr analyze(C context, Object form)
        (ß analyze(context, form, nil))
    )

    (§ defn- Expr analyze(C context, Object form, String name)
        ;; todo symbol macro expansion?
        (§ try 
            (§ if (ß form instanceof LazySeq)
                (§ let Object mform = form)
                (ß form = RT.seq(form))
                (§ if (ß form == nil)
                    (ß form = PersistentList.EMPTY)
                )
                (ß form = ((IObj)form).withMeta(RT.meta(mform)))
            )
            (§ if (ß form == nil)
                (§ return (ß NIL_EXPR))
            )
            (§ elseif (ß form == Boolean.TRUE)
                (§ return (ß TRUE_EXPR))
            )
            (§ elseif (ß form == Boolean.FALSE)
                (§ return (ß FALSE_EXPR))
            )
            (§ let Class fclass = form.getClass())
            (§ if (ß fclass == Symbol.class)
                (§ return (ß analyzeSymbol((Symbol) form)))
            )
            (§ elseif (ß fclass == Keyword.class)
                (§ return (ß registerKeyword((Keyword) form)))
            )
            (§ elseif (ß form instanceof Number)
                (§ return (ß NumberExpr.parse((Number) form)))
            )
            (§ elseif (ß fclass == String.class)
                (§ return (ß new StringExpr(((String) form).intern())))
            )
            (§ elseif (ß form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0)
                (§ let Expr ret = new EmptyExpr(form))
                (§ if (ß RT.meta(form) != nil)
                    (ß ret = new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                )
                (§ return ret)
            )
            (§ elseif (ß form instanceof ISeq)
                (§ return (ß analyzeSeq(context, (ISeq) form, name)))
            )
            (§ elseif (ß form instanceof IPersistentVector)
                (§ return (ß VectorExpr.parse(context, (IPersistentVector) form)))
            )
            (§ elseif (ß form instanceof IRecord)
                (§ return (ß new ConstantExpr(form)))
            )
            (§ elseif (ß form instanceof IType)
                (§ return (ß new ConstantExpr(form)))
            )
            (§ elseif (ß form instanceof IPersistentMap)
                (§ return (ß MapExpr.parse(context, (IPersistentMap) form)))
            )
            (§ elseif (ß form instanceof IPersistentSet)
                (§ return (ß SetExpr.parse(context, (IPersistentSet) form)))
            )

            (ß new ConstantExpr(form))
        )
        (§ catch (ß Throwable e)
            (§ if (ß !(e instanceof CompilerException))
                (§ throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e))
            )
            (§ else 
                (§ throw (ß (CompilerException) e))
            )
        )
    )

    (class-ns CompilerException (§ extends RuntimeException)
        (§ field String source)

        (§ field int line)

        (§ constructor CompilerException(String source, int line, int column, Throwable cause)
            (§ super(errorMsg(source, line, column, cause.toString()), cause))
            (ß this.source = source)
            (ß this.line = line)
            this
        )

        (§ method String toString()
            (ß getMessage())
        )
    )

    (§ defn Var isMacro(Object op)
        ;; no local macros for now
        (§ if (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (§ if (ß op instanceof Symbol || op instanceof Var)
            (§ let Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false))
            (§ if (ß v != nil && v.isMacro())
                (§ if (ß v.ns != currentNS() && !v.isPublic())
                    (§ throw new IllegalStateException("var: " + v + " is not public"))
                )
                (§ return v)
            )
        )
        nil
    )

    (§ defn IFn isInline(Object op, int arity)
        ;; no local inlines for now
        (§ if (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (§ if (ß op instanceof Symbol || op instanceof Var)
            (§ let Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false))
            (§ if (ß v != nil)
                (§ if (ß v.ns != currentNS() && !v.isPublic())
                    (§ throw new IllegalStateException("var: " + v + " is not public"))
                )
                (§ let IFn ret = (IFn) RT.get(v.meta(), inlineKey))
                (§ if (ß ret != nil)
                    (§ let IFn arityPred = (IFn) RT.get(v.meta(), inlineAritiesKey))
                    (§ if (ß arityPred == nil || RT.booleanCast(arityPred.invoke(arity)))
                        (§ return ret)
                    )
                )
            )
        )
        nil
    )

    (§ defn boolean namesStaticMember(Symbol sym)
        (ß (sym.ns != nil && namespaceFor(sym) == nil))
    )

    (§ defn Object preserveTag(ISeq src, Object dst)
        (§ let Symbol tag = tagOf(src))
        (§ if (ß tag != nil && dst instanceof IObj)
            (§ let IPersistentMap meta = RT.meta(dst))
            (§ return (ß ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))))
        )
        dst
    )

    #_volatile
    (§ def- Var MACRO_CHECK = nil)
    #_volatile
    (§ def- boolean MACRO_CHECK_LOADING = false)
    (§ def- Object MACRO_CHECK_LOCK = new Object())

    (§ defn- Var ensureMacroCheck() (§ throws ClassNotFoundException, IOException)
        (§ if (ß MACRO_CHECK == nil)
            (§ sync (ß MACRO_CHECK_LOCK)
                (§ if (ß MACRO_CHECK == nil)
                    (ß MACRO_CHECK_LOADING = true)
                    (ß RT.load("cloiure/spec/alpha"))
                    (ß RT.load("cloiure/core/specs/alpha"))
                    (ß MACRO_CHECK = Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check")))
                    (ß MACRO_CHECK_LOADING = false)
                )
            )
        )
        (ß MACRO_CHECK)
    )

    (§ defn void checkSpecs(Var v, ISeq form)
        (§ if (ß RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
            (§ try 
                (ß ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next()))))
            )
            (§ catch (ß Exception e)
                (§ throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e))
            )
        )
        nil
    )

    (§ defn Object macroexpand1(Object x)
        (§ if (ß x instanceof ISeq)
            (§ let ISeq form = (ISeq) x)
            (§ let Object op = RT.first(form))
            (§ if (ß isSpecial(op))
                (§ return x)
            )
            ;; macro expansion
            (§ let Var v = isMacro(op))
            (§ if (ß v != nil)
                (ß checkSpecs(v, form))

                (§ try 
                    (§ let ISeq args = RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next())))
                    (§ return (ß v.applyTo(args)))
                )
                (§ catch (ß ArityException e)
                    ;; hide the 2 extra params for a macro
                    (§ throw new ArityException(e.actual - 2, e.name))
                )
            )
            (§ else 
                (§ if (ß op instanceof Symbol)
                    (§ let Symbol sym = (Symbol) op)
                    (§ let String sname = sym.name)
                    ;; (.substring s 2 5) => (. s substring 2 5)
                    (§ if (ß sym.name.charAt(0) == \.)
                        (§ if (ß RT.length(form) < 2)
                            (§ throw new IllegalArgumentException("Malformed member expression, expecting (.member target ...)"))
                        )
                        (§ let Symbol meth = Symbol.intern(sname.substring(1)))
                        (§ let Object target = RT.second(form))
                        (§ if (ß HostExpr.maybeClass(target, false) != nil)
                            (ß target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS)))
                        )
                        (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))))
                    )
                    (§ elseif (ß namesStaticMember(sym))
                        (§ let Symbol target = Symbol.intern(sym.ns))
                        (§ let Class c = HostExpr.maybeClass(target, false))
                        (§ if (ß c != nil)
                            (§ let Symbol meth = Symbol.intern(sym.name))
                            (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next()))))
                        )
                    )
                    (§ else 
                        ;; (s.substring 2 5) => (. s substring 2 5)
                        ;; also (package.class.name ...) (. package.class name ...)
                        (§ let int idx = sname.lastIndexOf(\.))
                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                        (§ if (ß idx == sname.length() - 1)
                            (§ return (ß RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())))
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn Object macroexpand(Object form)
        (§ let Object exf = macroexpand1(form))
        (§ if (ß exf != form)
            (§ return (ß macroexpand(exf)))
        )
        form
    )

    (§ defn- Expr analyzeSeq(C context, ISeq form, String name)
        (§ let Object line = lineDeref())
        (§ let Object column = columnDeref())
        (§ if (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
            (ß line = RT.meta(form).valAt(RT.LINE_KEY))
        )
        (§ if (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
            (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
        )
        (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
        (§ try 
            (§ let Object me = macroexpand1(form))
            (§ if (ß me != form)
                (§ return (ß analyze(context, me, name)))
            )

            (§ let Object op = RT.first(form))
            (§ if (ß op == nil)
                (§ throw new IllegalArgumentException("Can't call nil, form: " + form))
            )
            (§ let IFn inline = isInline(op, RT.count(RT.next(form))))
            (§ if (ß inline != nil)
                (§ return (ß analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))))
            )
            (§ let IParser p)
            (§ if (ß op.equals(FN))
                (ß FnExpr.parse(context, form, name))
            )
            (§ elseif (ß (p = (IParser) specials.valAt(op)) != nil)
                (ß p.parse(context, form))
            )
            (§ else 
                (ß InvokeExpr.parse(context, form))
            )
        )
        (§ catch (ß Throwable e)
            (§ if (ß !(e instanceof CompilerException))
                (§ throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e))
            )
            (§ else 
                (§ throw (ß (CompilerException) e))
            )
        )
        (§ finally 
            (ß Var.popThreadBindings())
        )
    )

    (§ defn String errorMsg(String source, int line, int column, String s)
        (ß String.format("%s, compiling:(%s:%d:%d)", s, source, line, column))
    )

    (§ defn Object eval(Object form)
        (ß eval(form, true))
    )

    (§ defn Object eval(Object form, boolean freshLoader)
        (§ let boolean createdLoader = false)
        (§ if (ß true) ;; !LOADER.isBound()
            (ß Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader())))
            (ß createdLoader = true)
        )
        (§ try 
            (§ let Object line = lineDeref())
            (§ let Object column = columnDeref())
            (§ if (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                (ß line = RT.meta(form).valAt(RT.LINE_KEY))
            )
            (§ if (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
            )
            (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
            (§ try 
                (ß form = macroexpand(form))
                (§ if (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                    (§ let ISeq s = RT.next(form))
                    (§ loop-when-recur [(ß )] (ß RT.next(s) != nil) [(ß s = RT.next(s))]
                        (ß eval(RT.first(s), false))
                    )
                    (ß eval(RT.first(s), false))
                )
                (§ elseif (ß (form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def"))))
                    (§ let ObjExpr fexpr = (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID()))
                    (§ let IFn fn = (IFn) fexpr.eval())
                    (ß fn.invoke())
                )
                (§ else 
                    (§ let Expr expr = analyze(C.EVAL, form))
                    (ß expr.eval())
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )
        (§ finally 
            (§ if (ß createdLoader)
                (ß Var.popThreadBindings())
            )
        )
    )

    (§ defn- int registerConstant(Object o)
        (§ if (ß !CONSTANTS.isBound())
            (§ return -1)
        )
        (§ let PersistentVector v = (PersistentVector) CONSTANTS.deref())
        (§ let IdentityHashMap<Object, Integer> ids = (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref())
        (§ let Integer i = ids.get(o))
        (§ if (ß i != nil)
            (§ return i)
        )
        (ß CONSTANTS.set(RT.conj(v, o)))
        (ß ids.put(o, v.count()))
        (ß v.count())
    )

    (§ defn- KeywordExpr registerKeyword(Keyword keyword)
        (§ if (ß !KEYWORDS.isBound())
            (§ return (ß new KeywordExpr(keyword)))
        )

        (§ let IPersistentMap keywordsMap = (IPersistentMap) KEYWORDS.deref())
        (§ let Object id = RT.get(keywordsMap, keyword))
        (§ if (ß id == nil)
            (ß KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword))))
        )
        (ß new KeywordExpr(keyword))
    )

    (§ defn- int registerKeywordCallsite(Keyword keyword)
        (§ if (ß !KEYWORD_CALLSITES.isBound())
            (§ throw new IllegalAccessError("KEYWORD_CALLSITES is not bound"))
        )

        (§ let IPersistentVector keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())

        (ß keywordCallsites = keywordCallsites.cons(keyword))
        (ß KEYWORD_CALLSITES.set(keywordCallsites))
        (ß keywordCallsites.count() - 1)
    )

    (§ defn- int registerProtocolCallsite(Var v)
        (§ if (ß !PROTOCOL_CALLSITES.isBound())
            (§ throw new IllegalAccessError("PROTOCOL_CALLSITES is not bound"))
        )

        (§ let IPersistentVector protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())

        (ß protocolCallsites = protocolCallsites.cons(v))
        (ß PROTOCOL_CALLSITES.set(protocolCallsites))
        (ß protocolCallsites.count() - 1)
    )

    (§ defn- void registerVarCallsite(Var v)
        (§ if (ß !VAR_CALLSITES.isBound())
            (§ throw new IllegalAccessError("VAR_CALLSITES is not bound"))
        )

        (§ let IPersistentCollection varCallsites = (IPersistentCollection) VAR_CALLSITES.deref())

        (ß varCallsites = varCallsites.cons(v))
        (ß VAR_CALLSITES.set(varCallsites))
        nil
    )

    (§ defn ISeq fwdPath(PathNode p1)
        (§ let ISeq ret = nil)
        (§ loop-when-recur [(ß )] (ß p1 != nil) [(ß p1 = p1.parent)]
            (ß ret = RT.cons(p1, ret))
        )
        ret
    )

    (§ defn PathNode commonPath(PathNode n1, PathNode n2)
        (§ let ISeq xp = fwdPath(n1))
        (§ let ISeq yp = fwdPath(n2))
        (§ if (ß RT.first(xp) != RT.first(yp))
            (§ return nil)
        )
        (§ while (ß RT.second(xp) != nil && RT.second(xp) == RT.second(yp))
            (ß xp = xp.next())
            (ß yp = yp.next())
        )
        (ß (PathNode) RT.first(xp))
    )

    (§ defn void addAnnotation(Object visitor, IPersistentMap meta)
        (§ if (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta))
        )
        nil
    )

    (§ defn void addParameterAnnotation(Object visitor, IPersistentMap meta, int i)
        (§ if (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta, i))
        )
        nil
    )

    (§ defn- Expr analyzeSymbol(Symbol sym)
        (§ let Symbol tag = tagOf(sym))
        (§ if (ß sym.ns == nil) ;; ns-qualified syms are always Vars
            (§ let LocalBinding b = referenceLocal(sym))
            (§ if (ß b != nil)
                (§ return (ß new LocalBindingExpr(b, tag)))
            )
        )
        (§ elseif (ß namespaceFor(sym) == nil)
            (§ let Symbol nsSym = Symbol.intern(sym.ns))
            (§ let Class c = HostExpr.maybeClass(nsSym, false))
            (§ if (ß c != nil)
                (§ if (ß Reflector.getField(c, sym.name, true) != nil)
                    (§ return (ß new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)))
                )
                (§ throw Util.runtimeException("Unable to find static field: " + sym.name + " in " + c))
            )
        )
        (§ let Object o = resolve(sym))
        (§ if (ß o instanceof Var)
            (§ let Var v = (Var) o)
            (§ if (ß isMacro(v) != nil)
                (§ throw Util.runtimeException("Can't take value of a macro: " + v))
            )
            (§ if (ß RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
                (§ return (ß analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))))
            )
            (ß registerVar(v))
            (§ return (ß new VarExpr(v, tag)))
        )
        (§ elseif (ß o instanceof Class)
            (§ return (ß new ConstantExpr(o)))
        )
        (§ elseif (ß o instanceof Symbol)
            (§ return (ß new UnresolvedVarExpr((Symbol) o)))
        )

        (§ throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context"))
    )

    (§ defn String destubClassName(String className)
        ;; skip over prefix + '.' or '/'
        (§ if (ß className.startsWith(COMPILE_STUB_PREFIX))
            (§ return (ß className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        className
    )

    (§ defn Type getType(Class c)
        (§ let String descriptor = Type.getType(c).getDescriptor())
        (§ if (ß descriptor.startsWith("L"))
            (ß descriptor = "L" + destubClassName(descriptor.substring(1)))
        )
        (ß Type.getType(descriptor))
    )

    (§ defn Object resolve(Symbol sym, boolean allowPrivate)
        (ß resolveIn(currentNS(), sym, allowPrivate))
    )

    (§ defn Object resolve(Symbol sym)
        (ß resolveIn(currentNS(), sym, false))
    )

    (§ defn Namespace namespaceFor(Symbol sym)
        (ß namespaceFor(currentNS(), sym))
    )

    (§ defn Namespace namespaceFor(Namespace inns, Symbol sym)
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (§ let Symbol nsSym = Symbol.intern(sym.ns))
        (§ let Namespace ns = inns.lookupAlias(nsSym))
        (§ if (ß ns == nil)
            ;; ...otherwise check the Namespaces map.
            (ß ns = Namespace.find(nsSym))
        )
        ns
    )

    (§ defn Object resolveIn(Namespace n, Symbol sym, boolean allowPrivate)
        ;; note - ns-qualified vars must already exist
        (§ if (ß sym.ns != nil)
            (§ let Namespace ns = namespaceFor(n, sym))
            (§ if (ß ns == nil)
                (§ throw Util.runtimeException("No such namespace: " + sym.ns))
            )

            (§ let Var v = ns.findInternedVar(Symbol.intern(sym.name)))
            (§ if (ß v == nil)
                (§ throw Util.runtimeException("No such var: " + sym))
            )
            (§ elseif (ß v.ns != currentNS() && !v.isPublic() && !allowPrivate)
                (§ throw new IllegalStateException("var: " + sym + " is not public"))
            )
            v
        )
        (§ elseif (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
            (ß RT.classForName(sym.name))
        )
        (§ elseif (ß sym.equals(NS))
            (ß RT.NS_VAR)
        )
        (§ elseif (ß sym.equals(IN_NS))
            (ß RT.IN_NS_VAR)
        )
        (§ else 
            (§ if (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                (§ return (ß COMPILE_STUB_CLASS.get()))
            )
            (§ let Object o = n.getMapping(sym))
            (§ if (ß o == nil)
                (§ if (ß RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
                    (§ return sym)
                )
                (§ else 
                    (§ throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context"))
                )
            )
            o
        )
    )

    (§ defn Object maybeResolveIn(Namespace n, Symbol sym)
        ;; note - ns-qualified vars must already exist
        (§ if (ß sym.ns != nil)
            (§ let Namespace ns = namespaceFor(n, sym))
            (§ if (ß ns == nil)
                (§ return nil)
            )
            (§ let Var v = ns.findInternedVar(Symbol.intern(sym.name)))
            (§ if (ß v == nil)
                (§ return nil)
            )
            v
        )
        (§ elseif (ß sym.name.indexOf(\.) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == \[)
            (ß RT.classForName(sym.name))
        )
        (§ elseif (ß sym.equals(NS))
            (ß RT.NS_VAR)
        )
        (§ elseif (ß sym.equals(IN_NS))
            (ß RT.IN_NS_VAR)
        )
        (§ else 
            (§ let Object o = n.getMapping(sym))
            o
        )
    )

    (§ defn Var lookupVar(Symbol sym, boolean internNew, boolean registerMacro)
        (§ let Var var = nil)

        ;; note - ns-qualified vars in other namespaces must already exist
        (§ if (ß sym.ns != nil)
            (§ let Namespace ns = namespaceFor(sym))
            (§ if (ß ns == nil)
                (§ return nil)
            )
            (§ let Symbol name = Symbol.intern(sym.name))
            (§ if (ß internNew && ns == currentNS())
                (ß var = currentNS().intern(name))
            )
            (§ else 
                (ß var = ns.findInternedVar(name))
            )
        )
        (§ elseif (ß sym.equals(NS))
            (ß var = RT.NS_VAR)
        )
        (§ elseif (ß sym.equals(IN_NS))
            (ß var = RT.IN_NS_VAR)
        )
        (§ else 
            ;; is it mapped?
            (§ let Object o = currentNS().getMapping(sym))
            (§ if (ß o == nil)
                ;; introduce a new var in the current ns
                (§ if (ß internNew)
                    (ß var = currentNS().intern(Symbol.intern(sym.name)))
                )
            )
            (§ elseif (ß o instanceof Var)
                (ß var = (Var) o)
            )
            (§ else 
                (§ throw Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o))
            )
        )
        (§ if (ß var != nil && (!var.isMacro() || registerMacro))
            (ß registerVar(var))
        )
        var
    )

    (§ defn Var lookupVar(Symbol sym, boolean internNew)
        (ß lookupVar(sym, internNew, true))
    )

    (§ defn- void registerVar(Var var)
        (§ if (ß !VARS.isBound())
            (§ return nil)
        )
        (§ let IPersistentMap varsMap = (IPersistentMap) VARS.deref())
        (§ let Object id = RT.get(varsMap, var))
        (§ if (ß id == nil)
            (ß VARS.set(RT.assoc(varsMap, var, registerConstant(var))))
        )
        nil
    )

    (§ defn Namespace currentNS()
        (ß (Namespace) RT.CURRENT_NS.deref())
    )

    (§ defn void closeOver(LocalBinding b, ObjMethod method)
        (§ if (ß b != nil && method != nil)
            (§ let LocalBinding lb = (LocalBinding) RT.get(method.locals, b))
            (§ if (ß lb == nil)
                (ß method.objx.closes = (IPersistentMap) RT.assoc(method.objx.closes, b, b))
                (ß closeOver(b, method.parent))
            )
            (§ else 
                (§ if (ß lb.idx == 0)
                    (ß method.usesThis = true)
                )
                (§ if (ß IN_CATCH_FINALLY.deref() != nil)
                    (ß method.localsUsedInCatchFinally = (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx))
                )
            )
        )
        nil
    )

    (§ defn LocalBinding referenceLocal(Symbol sym)
        (§ if (ß !LOCAL_ENV.isBound())
            (§ return nil)
        )
        (§ let LocalBinding b = (LocalBinding) RT.get(LOCAL_ENV.deref(), sym))
        (§ if (ß b != nil)
            (§ let ObjMethod method = (ObjMethod) METHOD.deref())
            (§ if (ß b.idx == 0)
                (ß method.usesThis = true)
            )
            (ß closeOver(b, method))
        )
        b
    )

    (§ defn- Symbol tagOf(Object o)
        (§ let Object tag = RT.get(RT.meta(o), RT.TAG_KEY))
        (§ if (ß tag instanceof Symbol)
            (§ return (ß (Symbol) tag))
        )
        (§ elseif (ß tag instanceof String)
            (§ return (ß Symbol.intern(nil, (String) tag)))
        )
        nil
    )

    (§ defn Object loadFile(String file) (§ throws IOException)
        (§ let FileInputStream f = new FileInputStream(file))
        (§ try 
            (ß load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName()))
        )
        (§ finally 
            (ß f.close())
        )
    )

    (§ defn Object load(Reader rdr)
        (ß load(rdr, nil, "NO_SOURCE_FILE"))
    )

    (§ defn void consumeWhitespaces(LineNumberingPushbackReader pushbackReader)
        (§ let int ch = LispReader.read1(pushbackReader))
        (§ while (ß LispReader.isWhitespace(ch))
            (ß ch = LispReader.read1(pushbackReader))
        )
        (ß LispReader.unread(pushbackReader, ch))
        nil
    )

    (§ def- Object OPTS_COND_ALLOWED = RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW))

    (§ defn- Object readerOpts(String sourceName)
        (§ if (ß sourceName != nil && sourceName.endsWith(".clic"))
            (ß OPTS_COND_ALLOWED)
        )
        (§ else 
            nil
        )
    )

    (§ defn Object load(Reader rdr, String sourcePath, String sourceName)
        (§ let Object EOF = new Object())
        (§ let Object ret = nil)
        (§ let LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))
        (ß consumeWhitespaces(pushbackReader))
        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map LOADER, RT.makeClassLoader(),
              #_map SOURCE_PATH, sourcePath,
              #_map SOURCE, sourceName,
              #_map METHOD, nil,
              #_map LOCAL_ENV, nil,
              #_map LOOP_LOCALS, nil,
              #_map NEXT_LOCAL_NUM, 0,
              #_map RT.READEVAL, RT.T,
              #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
              #_map LINE_BEFORE, pushbackReader.getLineNumber(),
              #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
              #_map LINE_AFTER, pushbackReader.getLineNumber(),
              #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
              #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
              #_map RT.DATA_READERS, RT.DATA_READERS.deref()
        )))

        (§ let Object readerOpts = readerOpts(sourceName))
        (§ try 
            (§ loop-when-recur [(ß Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))] (ß r != EOF) [(ß r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))]
                (ß consumeWhitespaces(pushbackReader))
                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                (ß ret = eval(r, false))
                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
            )
        )
        (§ catch (ß LispReader.ReaderException e)
            (§ throw new CompilerException(sourcePath, e.line, e.column, e.getCause()))
        )
        (§ catch (ß Throwable e)
            (§ if (ß !(e instanceof CompilerException))
                (§ throw new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e))
            )
            (§ else 
                (§ throw (ß (CompilerException) e))
            )
        )
        (§ finally 
            (ß Var.popThreadBindings())
        )
        ret
    )

    (§ defn void writeClassFile(String internalName, byte[] bytecode) (§ throws IOException)
        (§ let String genPath = (String) COMPILE_PATH.deref())
        (§ if (ß genPath == nil)
            (§ throw Util.runtimeException("*compile-path* not set"))
        )
        (§ let String[] dirs = internalName.split("/"))
        (§ let String p = genPath)
        (§ loop-when-recur [(ß int i = 0)] (ß i < dirs.length - 1) [(ß i++)]
            (ß p += File.separator + dirs[i])
            (ß (new File(p)).mkdir())
        )
        (§ let String path = genPath + File.separator + internalName + ".class")
        (§ let File cf = new File(path))
        (ß cf.createNewFile())
        (§ let FileOutputStream cfs = new FileOutputStream(cf))
        (§ try 
            (ß cfs.write(bytecode))
            (ß cfs.flush())
        )
        (§ finally 
            (ß cfs.close())
        )
        nil
    )

    (§ defn void pushNS()
        (ß Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil)))
        nil
    )

    (§ defn void pushNSandLoader(ClassLoader loader)
        (ß Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T)))
        nil
    )

    (§ defn ILookupThunk getLookupThunk(Object target, Keyword k)
        nil
    )

    (§ defn void compile1(GeneratorAdapter gen, ObjExpr objx, Object form)
        (§ let Object line = lineDeref())
        (§ let Object column = columnDeref())
        (§ if (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
            (ß line = RT.meta(form).valAt(RT.LINE_KEY))
        )
        (§ if (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
            (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
        )
        (ß Var.pushThreadBindings(RT.map(
              #_map LINE, line, COLUMN, column,
              #_map LOADER, RT.makeClassLoader()
        )))
        (§ try 
            (ß form = macroexpand(form))
            (§ if (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                (§ loop-when-recur [(ß ISeq s = RT.next(form))] (ß s != nil) [(ß s = RT.next(s))]
                    (ß compile1(gen, objx, RT.first(s)))
                )
            )
            (§ else 
                (§ let Expr expr = analyze(C.EVAL, form))
                (ß objx.keywords = (IPersistentMap) KEYWORDS.deref())
                (ß objx.vars = (IPersistentMap) VARS.deref())
                (ß objx.constants = (PersistentVector) CONSTANTS.deref())
                (ß expr.emit(C.EXPRESSION, objx, gen))
                (ß expr.eval())
            )
        )
        (§ finally 
            (ß Var.popThreadBindings())
        )
        nil
    )

    (§ defn Object compile(Reader rdr, String sourcePath, String sourceName) (§ throws IOException)
        (§ if (ß COMPILE_PATH.deref() == nil)
            (§ throw Util.runtimeException("*compile-path* not set"))
        )

        (§ let Object EOF = new Object())
        (§ let Object ret = nil)
        (§ let LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))
        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map SOURCE_PATH, sourcePath,
              #_map SOURCE, sourceName,
              #_map METHOD, nil,
              #_map LOCAL_ENV, nil,
              #_map LOOP_LOCALS, nil,
              #_map NEXT_LOCAL_NUM, 0,
              #_map RT.READEVAL, RT.T,
              #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
              #_map LINE_BEFORE, pushbackReader.getLineNumber(),
              #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
              #_map LINE_AFTER, pushbackReader.getLineNumber(),
              #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
              #_map CONSTANTS, PersistentVector.EMPTY,
              #_map CONSTANT_IDS, new IdentityHashMap(),
              #_map KEYWORDS, PersistentHashMap.EMPTY,
              #_map VARS, PersistentHashMap.EMPTY,
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
              #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
              #_map RT.DATA_READERS, RT.DATA_READERS.deref()
        )))

        (§ try 
            ;; generate loader class
            (§ let ObjExpr objx = new ObjExpr(nil))
            (ß objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf(\.)) + RT.LOADER_SUFFIX)

            (ß objx.objtype = Type.getObjectType(objx.internalName))
            (§ let ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS))
            (§ let ClassVisitor cv = cw)
            (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, nil, "java/lang/Object", nil))

            ;; static load method
            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), nil, nil, cv))
            (ß gen.visitCode())

            (§ let Object readerOpts = readerOpts(sourceName))
            (§ loop-when-recur [(ß Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))] (ß r != EOF) [(ß r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))]
                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                (ß compile1(gen, objx, r))
                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
            )
            ;; end of load
            (ß gen.returnValue())
            (ß gen.endMethod())

            ;; static fields for constants
            (§ loop-when-recur [(ß int i = 0)] (ß i < objx.constants.count()) [(ß i++)]
                (§ if (ß objx.usedConstants.contains(i))
                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), nil, nil))
                )
            )

            (§ let int INITS_PER = 100)
            (§ let int numInits =  objx.constants.count() / INITS_PER)
            (§ if (ß objx.constants.count() % INITS_PER != 0)
                (ß ++numInits)
            )

            (§ loop-when-recur [(ß int n = 0)] (ß n < numInits) [(ß n++)]
                (§ let GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), nil, nil, cv))
                (ß clinitgen.visitCode())
                (§ try 
                    (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                    (§ loop-when-recur [(ß int i = n * INITS_PER)] (ß i < objx.constants.count() && i < (n + 1) * INITS_PER) [(ß i++)]
                        (§ if (ß objx.usedConstants.contains(i))
                            (ß objx.emitValue(objx.constants.nth(i), clinitgen))
                            (ß clinitgen.checkCast(objx.constantType(i)))
                            (ß clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i)))
                        )
                    )
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )
                (ß clinitgen.returnValue())
                (ß clinitgen.endMethod())
            )

            ;; static init for constants, keywords and vars
            (§ let GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))
            (ß clinitgen.visitCode())
            (§ let Label startTry = clinitgen.newLabel())
            (§ let Label endTry = clinitgen.newLabel())
            (§ let Label end = clinitgen.newLabel())
            (§ let Label finallyLabel = clinitgen.newLabel())

            (§ loop-when-recur [(ß int n = 0)] (ß n < numInits) [(ß n++)]
                (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()")))
            )

            (ß clinitgen.push(objx.internalName.replace(\/, \.)))
            (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
            (ß clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()")))
            (ß clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)")))
            (ß clinitgen.mark(startTry))
            (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()")))
            (ß clinitgen.mark(endTry))
            (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
            (ß clinitgen.goTo(end))

            (ß clinitgen.mark(finallyLabel))
            ;; exception should be on stack
            (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
            (ß clinitgen.throwException())
            (ß clinitgen.mark(end))
            (ß clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))

            ;; end of static init
            (ß clinitgen.returnValue())
            (ß clinitgen.endMethod())

            ;; end of class
            (ß cv.visitEnd())

            (ß writeClassFile(objx.internalName, cw.toByteArray()))
        )
        (§ catch (ß LispReader.ReaderException e)
            (§ throw new CompilerException(sourcePath, e.line, e.column, e.getCause()))
        )
        (§ finally 
            (ß Var.popThreadBindings())
        )
        ret
    )

    (class-ns NewInstanceExpr (§ extends ObjExpr)
        (§ field IPersistentCollection methods)

        (§ field Map<IPersistentVector, java.lang.reflect.Method> mmap)
        (§ field Map<IPersistentVector, Set<Class>> covariants)

        (§ constructor NewInstanceExpr(Object tag)
            (§ super(tag))
            this
        )

        (class-ns DeftypeParser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq rform = (ISeq) frm)
                ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                (ß rform = RT.next(rform))
                (§ let String tagname = ((Symbol) rform.first()).getName())
                (ß rform = rform.next())
                (§ let Symbol classname = (Symbol) rform.first())
                (ß rform = rform.next())
                (§ let IPersistentVector fields = (IPersistentVector) rform.first())
                (ß rform = rform.next())
                (§ let IPersistentMap opts = PersistentHashMap.EMPTY)
                (§ while (ß rform != nil && rform.first() instanceof Keyword)
                    (ß opts = opts.assoc(rform.first(), RT.second(rform)))
                    (ß rform = rform.next().next())
                )

                (§ let ObjExpr ret = build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, nil, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts))
                ret
            )
        )

        (class-ns ReifyParser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                (§ let ISeq form = (ISeq) frm)
                (§ let ObjMethod enclosingMethod = (ObjMethod) METHOD.deref())
                (§ let String basename = (enclosingMethod != nil) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$"))
                (§ let String simpleName = "reify__" + RT.nextID())
                (§ let String classname = basename + simpleName)

                (§ let ISeq rform = RT.next(form))

                (§ let IPersistentVector interfaces = ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj")))

                (ß rform = RT.next(rform))

                (§ let ObjExpr ret = build(interfaces, nil, nil, classname, Symbol.intern(classname), nil, rform, frm, nil))
                (§ if (ß frm instanceof IObj && ((IObj) frm).meta() != nil)
                    (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta())))
                )
                (§ else 
                    ret
                )
            )
        )

        (§ defn ObjExpr build(IPersistentVector interfaceSyms, IPersistentVector fieldSyms, Symbol thisSym, String tagName, Symbol className, Symbol typeTag, ISeq methodForms, Object frm, IPersistentMap opts)
            (§ let NewInstanceExpr ret = new NewInstanceExpr(nil))

            (ß ret.src = frm)
            (ß ret.name = className.toString())
            (ß ret.classMeta = RT.meta(className))
            (ß ret.internalName = ret.name.replace(\., \/))
            (ß ret.objtype = Type.getObjectType(ret.internalName))
            (ß ret.opts = opts)

            (§ if (ß thisSym != nil)
                (ß ret.thisName = thisSym.name)
            )

            (§ if (ß fieldSyms != nil)
                (§ let IPersistentMap fmap = PersistentHashMap.EMPTY)
                (§ let Object[] closesvec = new Object[2 * fieldSyms.count()])
                (§ loop-when-recur [(ß int i = 0)] (ß i < fieldSyms.count()) [(ß i++)]
                    (§ let Symbol sym = (Symbol) fieldSyms.nth(i))
                    (§ let LocalBinding lb = new LocalBinding(-1, sym, nil, new MethodParamExpr(tagClass(tagOf(sym))), false, nil))
                    (ß fmap = fmap.assoc(sym, lb))
                    (ß closesvec[i * 2] = lb)
                    (ß closesvec[i * 2 + 1] = lb)
                )

                ;; todo - inject __meta et al into closes - when?
                ;; use array map to preserve ctor order
                (ß ret.closes = new PersistentArrayMap(closesvec))
                (ß ret.fields = fmap)
                (§ loop-when-recur [(ß int i = fieldSyms.count() - 1)] (ß i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq"))) [(ß --i)]
                    (ß ret.altCtorDrops++)
                )
            )

            (§ let PersistentVector interfaces = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß ISeq s = RT.seq(interfaceSyms))] (ß s != nil) [(ß s = s.next())]
                (§ let Class c = (Class) resolve((Symbol) s.first()))
                (§ if (ß !c.isInterface())
                    (§ throw new IllegalArgumentException("only interfaces are supported, had: " + c.getName()))
                )
                (ß interfaces = interfaces.cons(c))
            )
            (§ let Class superClass = Object.class)
            (§ let Map[] mc = gatherMethods(superClass, RT.seq(interfaces)))
            (§ let Map overrideables = mc[0])
            (§ let Map covariants = mc[1])
            (ß ret.mmap = overrideables)
            (ß ret.covariants = covariants)

            (§ let String[] inames = interfaceNames(interfaces))

            (§ let Class stub = compileStub(slashname(superClass), ret, inames, frm))
            (§ let Symbol thistag = Symbol.intern(nil, stub.getName()))

            (§ try 
                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map CONSTANTS, PersistentVector.EMPTY,
                      #_map CONSTANT_IDS, new IdentityHashMap(),
                      #_map KEYWORDS, PersistentHashMap.EMPTY,
                      #_map VARS, PersistentHashMap.EMPTY,
                      #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                      #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                      #_map VAR_CALLSITES, emptyVarCallSites(),
                      #_map NO_RECUR, nil
                )))
                (§ if (ß ret.isDeftype())
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                          #_map METHOD, nil,
                          #_map LOCAL_ENV, ret.fields,
                          #_map COMPILE_STUB_SYM, Symbol.intern(nil, tagName),
                          #_map COMPILE_STUB_CLASS, stub
                    )))

                    (ß ret.hintedFields = RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops))
                )

                ;; now (methodname [args] body)*
                (ß ret.line = lineDeref())
                (ß ret.column = columnDeref())
                (§ let IPersistentCollection methods = nil)
                (§ loop-when-recur [(ß ISeq s = methodForms)] (ß s != nil) [(ß s = RT.next(s))]
                    (§ let NewInstanceMethod m = NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables))
                    (ß methods = RT.conj(methods, m))
                )

                (ß ret.methods = methods)
                (ß ret.keywords = (IPersistentMap) KEYWORDS.deref())
                (ß ret.vars = (IPersistentMap) VARS.deref())
                (ß ret.constants = (PersistentVector) CONSTANTS.deref())
                (ß ret.constantsID = RT.nextID())
                (ß ret.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                (ß ret.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                (ß ret.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())
            )
            (§ finally 
                (§ if (ß ret.isDeftype())
                    (ß Var.popThreadBindings())
                )
                (ß Var.popThreadBindings())
            )

            (§ try 
                (ß ret.compile(slashname(superClass), inames, false))
            )
            (§ catch (ß IOException e)
                (§ throw Util.sneakyThrow(e))
            )
            (ß ret.getCompiledClass())
            ret
        )

        ;;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;;
        (§ defn Class compileStub(String superName, NewInstanceExpr ret, String[] interfaceNames, Object frm)
            (§ let ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS))
            (§ let ClassVisitor cv = cw)
            (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, nil, superName, interfaceNames))

            ;; instance fields for closed-overs
            (§ loop-when-recur [(ß ISeq s = RT.keys(ret.closes))] (ß s != nil) [(ß s = s.next())]
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ let int access = ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL))
                (§ if (ß lb.getPrimitiveType() != nil)
                    (ß cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                )
                (§ else 
                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                    (ß cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                )
            )

            ;; ctor that takes closed-overs and does nothing
            (§ let Method m = new Method("<init>", Type.VOID_TYPE, ret.ctorTypes()))
            (§ let GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))
            (ß ctorgen.visitCode())
            (ß ctorgen.loadThis())
            (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))
            (ß ctorgen.returnValue())
            (ß ctorgen.endMethod())

            (§ if (ß ret.altCtorDrops > 0)
                (§ let Type[] ctorTypes = ret.ctorTypes())
                (§ let Type[] altCtorTypes = new Type[ctorTypes.length-ret.altCtorDrops])
                (§ loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                    (ß altCtorTypes[i] = ctorTypes[i])
                )
                (§ let Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (ß ctorgen.visitCode())
                (ß ctorgen.loadThis())
                (ß ctorgen.loadArgs())

                (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (ß ctorgen.returnValue())
                (ß ctorgen.endMethod())

                ;; alt ctor no __hash, __hasheq
                (ß altCtorTypes = new Type[ctorTypes.length-2])
                (§ loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                    (ß altCtorTypes[i] = ctorTypes[i])
                )

                (ß alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (ß ctorgen.visitCode())
                (ß ctorgen.loadThis())
                (ß ctorgen.loadArgs())

                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (ß ctorgen.returnValue())
                (ß ctorgen.endMethod())
            )
            ;; end of class
            (ß cv.visitEnd())

            (§ let byte[] bytecode = cw.toByteArray())
            (§ let DynamicClassLoader loader = (DynamicClassLoader) LOADER.deref())
            (ß loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm))
        )

        (§ defn String[] interfaceNames(IPersistentVector interfaces)
            (§ let int icnt = interfaces.count())
            (§ let String[] inames = (icnt > 0) ? new String[icnt] :or nil)
            (§ loop-when-recur [(ß int i = 0)] (ß i < icnt) [(ß i++)]
                (ß inames[i] = slashname((Class) interfaces.nth(i)))
            )
            inames
        )

        (§ defn String slashname(Class c)
            (ß c.getName().replace(\., \/))
        )

        #_protected
        (§ method void emitStatics(ClassVisitor cv)
            (§ if (ß this.isDeftype())
                ;; getBasis()
                (§ let Method meth = Method.getMethod("cloiure.lang.IPersistentVector getBasis()"))
                (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, nil, nil, cv))
                (ß emitValue(hintedFields, gen))
                (ß gen.returnValue())
                (ß gen.endMethod())

                (§ if (ß this.isDeftype() && this.fields.count() > this.hintedFields.count())
                    ;; create(IPersistentMap)
                    (§ let String className = name.replace(\., \/))
                    (§ let int i = 1)
                    (§ let int fieldCount = hintedFields.count())

                    (§ let MethodVisitor mv = cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", nil, nil))
                    (ß mv.visitCode())

                    (§ loop-when-recur [(ß ISeq s = RT.seq(hintedFields))] (ß s != nil) [(ß s = s.next(), i++)]
                        (§ let String bName = ((Symbol)s.first()).name)
                        (§ let Class k = tagClass(tagOf(s.first())))

                        (ß mv.visitVarInsn(ALOAD, 0))
                        (ß mv.visitLdcInsn(bName))
                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                        (ß mv.visitInsn(ACONST_NULL))
                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                        (§ if (ß k.isPrimitive())
                            (ß mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName()))
                        )
                        (ß mv.visitVarInsn(ASTORE, i))
                        (ß mv.visitVarInsn(ALOAD, 0))
                        (ß mv.visitLdcInsn(bName))
                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                        (ß mv.visitVarInsn(ASTORE, 0))
                    )

                    (ß mv.visitTypeInsn(Opcodes.NEW, className))
                    (ß mv.visitInsn(DUP))

                    (§ let Method ctor = new Method("<init>", Type.VOID_TYPE, ctorTypes()))

                    (§ if (ß hintedFields.count() > 0)
                        (§ loop-when-recur [(ß i = 1)] (ß i <= fieldCount) [(ß i++)]
                            (ß mv.visitVarInsn(ALOAD, i))
                            (§ let Class k = tagClass(tagOf(hintedFields.nth(i - 1))))
                            (§ if (ß k.isPrimitive())
                                (§ let String b = Type.getType(boxClass(k)).getInternalName())
                                (§ let String p = Type.getType(k).getDescriptor())
                                (§ let String n = k.getName())

                                (ß mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p))
                            )
                        )
                    )

                    (ß mv.visitInsn(ACONST_NULL)) ;; __meta
                    (ß mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                    (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                    (ß mv.visitInsn(ICONST_0)) ;; __hash
                    (ß mv.visitInsn(ICONST_0)) ;; __hasheq
                    (ß mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor()))
                    (ß mv.visitInsn(ARETURN))
                    (ß mv.visitMaxs(4 + fieldCount, 1 + fieldCount))
                    (ß mv.visitEnd())
                )
            )
            nil
        )

        #_protected
        (§ method void emitMethods(ClassVisitor cv)
            (§ loop-when-recur [(ß ISeq s = RT.seq(methods))] (ß s != nil) [(ß s = s.next())]
                (§ let ObjMethod method = (ObjMethod) s.first())
                (ß method.emit(this, cv))
            )
            ;; emit bridge methods
            (§ doseq [#_"Map.Entry<IPersistentVector, Set<Class>>" (ß e covariants.entrySet())]
                (§ let java.lang.reflect.Method m = mmap.get(e.getKey()))
                (§ let Class[] params = m.getParameterTypes())
                (§ let Type[] argTypes = new Type[params.length])

                (§ loop-when-recur [(ß int i = 0)] (ß i < params.length) [(ß i++)]
                    (ß argTypes[i] = Type.getType(params[i]))
                )

                (§ let Method target = new Method(m.getName(), Type.getType(m.getReturnType()), argTypes))

                (§ doseq [#_"Class" retType (ß e.getValue())]
                    (§ let Method meth = new Method(m.getName(), Type.getType(retType), argTypes))

                    (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE,
                            meth,
                            nil,
                            ;; todo don't hardwire this
                            EXCEPTION_TYPES,
                            cv))
                    (ß gen.visitCode())
                    (ß gen.loadThis())
                    (ß gen.loadArgs())
                    (ß gen.invokeInterface(Type.getType(m.getDeclaringClass()), target))
                    (ß gen.returnValue())
                    (ß gen.endMethod())
                )
            )
            nil
        )

        (§ defn IPersistentVector msig(java.lang.reflect.Method m)
            (ß RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType()))
        )

        (§ defn void considerMethod(java.lang.reflect.Method m, Map mm)
            (§ let IPersistentVector mk = msig(m))
            (§ let int mods = m.getModifiers())

            (§ if (ß !(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods)))
                (ß mm.put(mk, m))
            )
            nil
        )

        (§ defn void gatherMethods(Class c, Map mm)
            (§ loop-when-recur [(ß )] (ß c != nil) [(ß c = c.getSuperclass())]
                (§ doseq [#_"java.lang.reflect.Method" m (ß c.getDeclaredMethods())]
                    (ß considerMethod(m, mm))
                )
                (§ doseq [#_"java.lang.reflect.Method" m (ß c.getMethods())]
                    (ß considerMethod(m, mm))
                )
            )
            nil
        )

        (§ defn Map[] gatherMethods(Class sc, ISeq interfaces)
            (§ let Map allm = new HashMap())
            (ß gatherMethods(sc, allm))
            (§ loop-when-recur [(ß )] (ß interfaces != nil) [(ß interfaces = interfaces.next())]
                (ß gatherMethods((Class) interfaces.first(), allm))
            )

            (§ let Map<IPersistentVector, java.lang.reflect.Method> mm = new HashMap<IPersistentVector, java.lang.reflect.Method>())
            (§ let Map<IPersistentVector, Set<Class>> covariants = new HashMap<IPersistentVector, Set<Class>>())
            (§ doseq [#_"Object" o (ß allm.entrySet())]
                (§ let Map.Entry e = (Map.Entry) o)
                (§ let IPersistentVector mk = (IPersistentVector) e.getKey())
                (ß mk = (IPersistentVector) mk.pop())
                (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())
                (§ if (ß mm.containsKey(mk)) ;; covariant return
                    (§ let Set<Class> cvs = covariants.get(mk))
                    (§ if (ß cvs == nil)
                        (ß cvs = new HashSet<Class>())
                        (ß covariants.put(mk, cvs))
                    )
                    (§ let java.lang.reflect.Method om = mm.get(mk))
                    (§ if (ß om.getReturnType().isAssignableFrom(m.getReturnType()))
                        (ß cvs.add(om.getReturnType()))
                        (ß mm.put(mk, m))
                    )
                    (§ else 
                        (ß cvs.add(m.getReturnType()))
                    )
                )
                (§ else 
                    (ß mm.put(mk, m))
                )
            )
            (ß new Map[] (§ mm, covariants ))
        )
    )

    (class-ns NewInstanceMethod (§ extends ObjMethod)
        (§ field String name)
        (§ field Type[] argTypes)
        (§ field Type retType)
        (§ field Class retClass)
        (§ field Class[] exclasses)

        (§ def Symbol dummyThis = Symbol.intern(nil, "dummy_this_dlskjsdfower"))
        (§ field- IPersistentVector parms)

        (§ constructor NewInstanceMethod(ObjExpr objx, ObjMethod parent)
            (§ super(objx, parent))
            this
        )

        (§ method int numParams()
            (ß argLocals.count())
        )

        (§ method String getMethodName()
            name
        )

        (§ method Type getReturnType()
            retType
        )

        (§ method Type[] getArgTypes()
            argTypes
        )

        (§ defn IPersistentVector msig(String name, Class[] paramTypes)
            (ß RT.vector(name, RT.seq(paramTypes)))
        )

        (§ defn NewInstanceMethod parse(ObjExpr objx, ISeq form, Symbol thistag, Map overrideables)
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            (§ let NewInstanceMethod method = new NewInstanceMethod(objx, (ObjMethod) METHOD.deref()))
            (§ let Symbol dotname = (Symbol)RT.first(form))
            (§ let Symbol name = (Symbol) Symbol.intern(nil, munge(dotname.name)).withMeta(RT.meta(dotname)))
            (§ let IPersistentVector parms = (IPersistentVector) RT.second(form))
            (§ if (ß parms.count() == 0)
                (§ throw new IllegalArgumentException("Must supply at least one argument for 'this' in: " + dotname))
            )
            (§ let Symbol thisName = (Symbol) parms.nth(0))
            (ß parms = RT.subvec(parms, 1, parms.count()))
            (§ let ISeq body = RT.next(RT.next(form)))
            (§ try 
                (ß method.line = lineDeref())
                (ß method.column = columnDeref())
                ;; register as the current method and set up a new env frame
                (§ let PathNode pnode =  new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))
                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map METHOD, method,
                      #_map LOCAL_ENV, LOCAL_ENV.deref(),
                      #_map LOOP_LOCALS, nil,
                      #_map NEXT_LOCAL_NUM, 0,
                      #_map CLEAR_PATH, pnode,
                      #_map CLEAR_ROOT, pnode,
                      #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                      #_map METHOD_RETURN_CONTEXT, RT.T
                )))

                ;; register 'this' as local 0
                (§ if (ß thisName != nil)
                    (ß registerLocal((thisName == nil) ? dummyThis:thisName, thistag, nil, false))
                )
                (§ else 
                    (ß getAndIncLocalNum())
                )

                (§ let PersistentVector argLocals = PersistentVector.EMPTY)
                (ß method.retClass = tagClass(tagOf(name)))
                (ß method.argTypes = new Type[parms.count()])
                (§ let boolean hinted = tagOf(name) != nil)
                (§ let Class[] pclasses = new Class[parms.count()])
                (§ let Symbol[] psyms = new Symbol[parms.count()])

                (§ loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                    (§ if (ß !(parms.nth(i) instanceof Symbol))
                        (§ throw new IllegalArgumentException("params must be Symbols"))
                    )
                    (§ let Symbol p = (Symbol) parms.nth(i))
                    (§ let Object tag = tagOf(p))
                    (§ if (ß tag != nil)
                        (ß hinted = true)
                    )
                    (§ if (ß p.getNamespace() != nil)
                        (ß p = Symbol.intern(p.name))
                    )
                    (§ let Class pclass = tagClass(tag))
                    (ß pclasses[i] = pclass)
                    (ß psyms[i] = p)
                )
                (§ let Map matches = findMethodsWithNameAndArity(name.name, parms.count(), overrideables))
                (§ let Object mk = msig(name.name, pclasses))
                (§ let java.lang.reflect.Method m = nil)
                (§ if (ß matches.size() > 0)
                    ;; multiple methods
                    (§ if (ß matches.size() > 1)
                        ;; must be hinted and match one method
                        (§ if (ß !hinted)
                            (§ throw new IllegalArgumentException("Must hint overloaded method: " + name.name))
                        )
                        (ß m = (java.lang.reflect.Method) matches.get(mk))
                        (§ if (ß m == nil)
                            (§ throw new IllegalArgumentException("Can't find matching overloaded method: " + name.name))
                        )
                        (§ if (ß m.getReturnType() != method.retClass)
                            (§ throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName()))
                        )
                    )
                    (§ else  ;; one match
                        ;; if hinted, validate match
                        (§ if (ß hinted)
                            (ß m = (java.lang.reflect.Method) matches.get(mk))
                            (§ if (ß m == nil)
                                (§ throw new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match."))
                            )
                            (§ if (ß m.getReturnType() != method.retClass)
                                (§ throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName()))
                            )
                        )
                        (§ else  ;; adopt found method sig
                            (ß m = (java.lang.reflect.Method) matches.values().iterator().next())
                            (ß method.retClass = m.getReturnType())
                            (ß pclasses = m.getParameterTypes())
                        )
                    )
                )
                (§ else 
                    (§ throw new IllegalArgumentException("Can't define method not in interfaces: " + name.name))
                )

                ;; validate unque name+arity among additional methods

                (ß method.retType = Type.getType(method.retClass))
                (ß method.exclasses = m.getExceptionTypes())

                (§ loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                    (§ let LocalBinding lb = registerLocal(psyms[i], nil, new MethodParamExpr(pclasses[i]), true))
                    (ß argLocals = argLocals.assocN(i, lb))
                    (ß method.argTypes[i] = Type.getType(pclasses[i]))
                )
                (§ loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                    (§ if (ß pclasses[i] == long.class || pclasses[i] == double.class)
                        (ß getAndIncLocalNum())
                    )
                )
                (ß LOOP_LOCALS.set(argLocals))
                (ß method.name = name.name)
                (ß method.methodMeta = RT.meta(name))
                (ß method.parms = parms)
                (ß method.argLocals = argLocals)
                (ß method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                method
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )

        (§ defn- Map findMethodsWithNameAndArity(String name, int arity, Map mm)
            (§ let Map ret = new HashMap())
            (§ doseq [#_"Object" o (ß mm.entrySet())]
                (§ let Map.Entry e = (Map.Entry) o)
                (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())
                (§ if (ß name.equals(m.getName()) && m.getParameterTypes().length == arity)
                    (ß ret.put(e.getKey(), e.getValue()))
                )
            )
            ret
        )

        (§ defn- Map findMethodsWithName(String name, Map mm)
            (§ let Map ret = new HashMap())
            (§ doseq [#_"Object" o (ß mm.entrySet())]
                (§ let Map.Entry e = (Map.Entry) o)
                (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())
                (§ if (ß name.equals(m.getName()))
                    (ß ret.put(e.getKey(), e.getValue()))
                )
            )
            ret
        )

        (§ method void emit(ObjExpr obj, ClassVisitor cv)
            (§ let Method m = new Method(getMethodName(), getReturnType(), getArgTypes()))

            (§ let Type[] extypes = nil)
            (§ if (ß exclasses.length > 0)
                (ß extypes = new Type[exclasses.length])
                (§ loop-when-recur [(ß int i = 0)] (ß i < exclasses.length) [(ß i++)]
                    (ß extypes[i] = Type.getType(exclasses[i]))
                )
            )
            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, extypes, cv))
            (ß addAnnotation(gen, methodMeta))
            (§ loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                (§ let IPersistentMap meta = RT.meta(parms.nth(i)))
                (ß addParameterAnnotation(gen, meta, i))
            )
            (ß gen.visitCode())

            (§ let Label loopLabel = gen.mark())

            (ß gen.visitLineNumber(line, loopLabel))
            (§ try 
                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                (ß emitBody(objx, gen, retClass, body))
                (§ let Label end = gen.mark())
                (ß gen.visitLocalVariable("this", obj.objtype.getDescriptor(), nil, loopLabel, end, 0))
                (§ loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (ß gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )

            (ß gen.returnValue())
            (ß gen.endMethod())
            nil
        )
    )

    (§ defn boolean inty(Class c)
        (ß (c == int.class || c == short.class || c == byte.class || c == char.class))
    )

    (§ defn Class retType(Class tc, Class ret)
        (§ if (ß tc == nil)
            (§ return ret)
        )
        (§ if (ß ret == nil)
            (§ return tc)
        )
        (§ if (ß ret.isPrimitive() && tc.isPrimitive())
            (§ if (ß (inty(ret) && inty(tc)) || (ret == tc))
                (§ return tc)
            )
            (§ throw new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead"))
        )
        tc
    )

    (§ defn Class primClass(Symbol sym)
        (§ if (ß sym == nil)
            (§ return nil)
        )
        (§ let Class c = nil)
        (§ if (ß sym.name.equals("int"))
            (ß c = int.class)
        )
        (§ elseif (ß sym.name.equals("long"))
            (ß c = long.class)
        )
        (§ elseif (ß sym.name.equals("float"))
            (ß c = float.class)
        )
        (§ elseif (ß sym.name.equals("double"))
            (ß c = double.class)
        )
        (§ elseif (ß sym.name.equals("char"))
            (ß c = char.class)
        )
        (§ elseif (ß sym.name.equals("short"))
            (ß c = short.class)
        )
        (§ elseif (ß sym.name.equals("byte"))
            (ß c = byte.class)
        )
        (§ elseif (ß sym.name.equals("boolean"))
            (ß c = boolean.class)
        )
        (§ elseif (ß sym.name.equals("void"))
            (ß c = void.class)
        )
        c
    )

    (§ defn Class tagClass(Object tag)
        (§ if (ß tag == nil)
            (§ return (ß Object.class))
        )
        (§ let Class c = nil)
        (§ if (ß tag instanceof Symbol)
            (ß c = primClass((Symbol) tag))
        )
        (§ if (ß c == nil)
            (ß c = HostExpr.tagToClass(tag))
        )
        c
    )

    (§ defn Class primClass(Class c)
        (ß c.isPrimitive() ? c :or Object.class)
    )

    (§ defn Class boxClass(Class p)
        (§ if (ß !p.isPrimitive())
            (§ return p)
        )

        (§ let Class c = nil)

        (§ if (ß p == Integer.TYPE)
            (ß c = Integer.class)
        )
        (§ elseif (ß p == Long.TYPE)
            (ß c = Long.class)
        )
        (§ elseif (ß p == Float.TYPE)
            (ß c = Float.class)
        )
        (§ elseif (ß p == Double.TYPE)
            (ß c = Double.class)
        )
        (§ elseif (ß p == Character.TYPE)
            (ß c = Character.class)
        )
        (§ elseif (ß p == Short.TYPE)
            (ß c = Short.class)
        )
        (§ elseif (ß p == Byte.TYPE)
            (ß c = Byte.class)
        )
        (§ elseif (ß p == Boolean.TYPE)
            (ß c = Boolean.class)
        )

        c
    )

    (class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Class c)

        (§ constructor MethodParamExpr(Class c)
            (ß this.c = c)
            this
        )

        (§ method Object eval()
            (§ throw Util.runtimeException("Can't eval"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ throw Util.runtimeException("Can't emit"))
        )

        (§ method boolean hasJavaClass()
            (ß (c != nil))
        )

        (§ method Class getJavaClass()
            c
        )

        (§ method boolean canEmitPrimitive()
            (ß Util.isPrimitive(c))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ throw Util.runtimeException("Can't emit"))
        )
    )

    (class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field LocalBindingExpr expr)
        (§ field int shift, mask, low, high)
        (§ field Expr defaultExpr)
        (§ field SortedMap<Integer, Expr> tests)
        (§ field HashMap<Integer, Expr> thens)
        (§ field Keyword switchType)
        (§ field Keyword testType)
        (§ field Set<Integer> skipCheck)
        (§ field Class returnType)
        (§ field int line)
        (§ field int column)

        (§ def Type NUMBER_TYPE = Type.getType(Number.class))
        (§ def Method intValueMethod = Method.getMethod("int intValue()"))

        (§ def Method hashMethod = Method.getMethod("int hash(Object)"))
        (§ def Method hashCodeMethod = Method.getMethod("int hashCode()"))
        (§ def Method equivMethod = Method.getMethod("boolean equiv(Object, Object)"))
        (§ def Keyword compactKey = Keyword.intern(nil, "compact"))
        (§ def Keyword sparseKey = Keyword.intern(nil, "sparse"))
        (§ def Keyword hashIdentityKey = Keyword.intern(nil, "hash-identity"))
        (§ def Keyword hashEquivKey = Keyword.intern(nil, "hash-equiv"))
        (§ def Keyword intKey = Keyword.intern(nil, "int"))

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        (§ constructor CaseExpr(int line, int column, LocalBindingExpr expr, int shift, int mask, int low, int high, Expr defaultExpr, SortedMap<Integer, Expr> tests, HashMap<Integer, Expr> thens, Keyword switchType, Keyword testType, Set<Integer> skipCheck)
            (ß this.expr = expr)
            (ß this.shift = shift)
            (ß this.mask = mask)
            (ß this.low = low)
            (ß this.high = high)
            (ß this.defaultExpr = defaultExpr)
            (ß this.tests = tests)
            (ß this.thens = thens)
            (ß this.line = line)
            (ß this.column = column)
            (§ if (ß switchType != compactKey && switchType != sparseKey)
                (§ throw new IllegalArgumentException("Unexpected switch type: "+switchType))
            )
            (ß this.switchType = switchType)
            (§ if (ß testType != intKey && testType != hashEquivKey && testType != hashIdentityKey)
                (§ throw new IllegalArgumentException("Unexpected test type: "+switchType))
            )
            (ß this.testType = testType)
            (ß this.skipCheck = skipCheck)
            (§ let Collection<Expr> returns = new ArrayList(thens.values()))
            (ß returns.add(defaultExpr))
            (ß this.returnType = maybeJavaClass(returns))
            (§ if (ß RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), line, column))
            )
            this
        )

        (§ method boolean hasJavaClass()
            (ß (returnType != nil))
        )

        (§ method boolean canEmitPrimitive()
            (ß Util.isPrimitive(returnType))
        )

        (§ method Class getJavaClass()
            returnType
        )

        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval case"))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, false))
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, true))
            nil
        )

        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (§ let Label defaultLabel = gen.newLabel())
            (§ let Label endLabel = gen.newLabel())
            (§ let SortedMap<Integer, Label> labels = new TreeMap())

            (§ doseq [#_"Integer" i (ß tests.keySet())]
                (ß labels.put(i, gen.newLabel()))
            )

            (ß gen.visitLineNumber(line, gen.mark()))

            (§ let Class primExprClass = maybePrimitiveType(expr))
            (§ let Type primExprType = (primExprClass == nil) ? nil :or Type.getType(primExprClass))

            (§ if (ß testType == intKey)
                (ß emitExprForInts(objx, gen, primExprType, defaultLabel))
            )
            (§ else 
                (ß emitExprForHashes(objx, gen))
            )

            (§ if (ß switchType == sparseKey)
                (§ let Label[] la = new Label[labels.size()])
                (ß la = labels.values().toArray(la))
                (§ let int[] ints = Numbers.int_array(tests.keySet()))
                (ß gen.visitLookupSwitchInsn(defaultLabel, ints, la))
            )
            (§ else 
                (§ let Label[] la = new Label[(high - low) + 1])
                (§ loop-when-recur [(ß int i = low)] (ß i <= high) [(ß i++)]
                    (ß la[i - low] = labels.containsKey(i) ? labels.get(i) :or defaultLabel)
                )
                (ß gen.visitTableSwitchInsn(low, high, defaultLabel, la))
            )

            (§ doseq [#_"Integer" i (ß labels.keySet())]
                (ß gen.mark(labels.get(i)))
                (§ if (ß testType == intKey)
                    (ß emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                )
                (§ elseif (ß RT.contains(skipCheck, i) == RT.T)
                    (ß emitExpr(objx, gen, thens.get(i), emitUnboxed))
                )
                (§ else 
                    (ß emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                )
                (ß gen.goTo(endLabel))
            )

            (ß gen.mark(defaultLabel))
            (ß emitExpr(objx, gen, defaultExpr, emitUnboxed))
            (ß gen.mark(endLabel))
            (§ if (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method- boolean isShiftMasked()
            (ß (mask != 0))
        )

        (§ method- void emitShiftMask(GeneratorAdapter gen)
            (§ if (ß isShiftMasked())
                (ß gen.push(shift))
                (ß gen.visitInsn(ISHR))
                (ß gen.push(mask))
                (ß gen.visitInsn(IAND))
            )
            nil
        )

        (§ method- void emitExprForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Label defaultLabel)
            (§ if (ß exprType == nil)
                (§ if (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column))
                )
                (ß expr.emit(C.EXPRESSION, objx, gen))
                (ß gen.instanceOf(NUMBER_TYPE))
                (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                (ß expr.emit(C.EXPRESSION, objx, gen))
                (ß gen.checkCast(NUMBER_TYPE))
                (ß gen.invokeVirtual(NUMBER_TYPE, intValueMethod))
                (ß emitShiftMask(gen))
            )
            (§ elseif (ß exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                (ß gen.cast(exprType, Type.INT_TYPE))
                (ß emitShiftMask(gen))
            )
            (§ else 
                (ß gen.goTo(defaultLabel))
            )
            nil
        )

        (§ method- void emitThenForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
            (§ if (ß exprType == nil)
                (ß expr.emit(C.EXPRESSION, objx, gen))
                (ß test.emit(C.EXPRESSION, objx, gen))
                (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                (ß emitExpr(objx, gen, then, emitUnboxed))
            )
            (§ elseif (ß exprType == Type.LONG_TYPE)
                (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                (ß emitExpr(objx, gen, then, emitUnboxed))
            )
            (§ elseif (ß exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (§ if (ß isShiftMasked())
                    (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.cast(exprType, Type.LONG_TYPE))
                    (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                )
                ;; else direct match
                (ß emitExpr(objx, gen, then, emitUnboxed))
            )
            (§ else 
                (ß gen.goTo(defaultLabel))
            )
            nil
        )

        (§ method- void emitExprForHashes(ObjExpr objx, GeneratorAdapter gen)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeStatic(UTIL_TYPE, hashMethod))
            (ß emitShiftMask(gen))
            nil
        )

        (§ method- void emitThenForHashes(ObjExpr objx, GeneratorAdapter gen, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß test.emit(C.EXPRESSION, objx, gen))
            (§ if (ß testType == hashIdentityKey)
                (ß gen.visitJumpInsn(IF_ACMPNE, defaultLabel))
            )
            (§ else 
                (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
            )
            (ß emitExpr(objx, gen, then, emitUnboxed))
            nil
        )

        (§ defn- void emitExpr(ObjExpr objx, GeneratorAdapter gen, Expr expr, boolean emitUnboxed)
            (§ if (ß emitUnboxed && expr instanceof MaybePrimitiveExpr)
                (ß ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen))
            )
            (§ else 
                (ß expr.emit(C.EXPRESSION, objx, gen))
            )
            nil
        )

        (class-ns Parser (§ implements IParser)
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                (§ if (ß context == C.EVAL)
                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )
                (§ let IPersistentVector args = LazilyPersistentVector.create(form.next()))

                (§ let Object exprForm = args.nth(0))
                (§ let int shift = ((Number)args.nth(1)).intValue())
                (§ let int mask = ((Number)args.nth(2)).intValue())
                (§ let Object defaultForm = args.nth(3))
                (§ let Map caseMap = (Map)args.nth(4))
                (§ let Keyword switchType = ((Keyword)args.nth(5)))
                (§ let Keyword testType = ((Keyword)args.nth(6)))
                (§ let Set skipCheck = (RT.count(args) < 8) ? nil :or (Set)args.nth(7))

                (§ let ISeq keys = RT.keys(caseMap))
                (§ let int low = ((Number)RT.first(keys)).intValue())
                (§ let int high = ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue())

                (§ let LocalBindingExpr testexpr = (LocalBindingExpr) analyze(C.EXPRESSION, exprForm))
                (ß testexpr.shouldClear = false)

                (§ let SortedMap<Integer, Expr> tests = new TreeMap())
                (§ let HashMap<Integer, Expr> thens = new HashMap())

                (§ let PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))

                (§ doseq [#_"Object" o (ß caseMap.entrySet())]
                    (§ let Map.Entry e = (Map.Entry) o)
                    (§ let Integer minhash = ((Number)e.getKey()).intValue())
                    (§ let Object pair = e.getValue()) ;; [test-val then-expr]
                    (§ let Expr testExpr = (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair)))
                    (ß tests.put(minhash, testExpr))

                    (§ let Expr thenExpr)
                    (§ try 
                        (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                        (ß thenExpr = analyze(context, RT.second(pair)))
                    )
                    (§ finally 
                        (ß Var.popThreadBindings())
                    )
                    (ß thens.put(minhash, thenExpr))
                )

                (§ let Expr defaultExpr)
                (§ try 
                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                    (ß defaultExpr = analyze(context, args.nth(3)))
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )

                (§ let int line = ((Number)LINE.deref()).intValue())
                (§ let int column = ((Number)COLUMN.deref()).intValue())
                (ß new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck))
            )
        )
    )

    (§ defn IPersistentCollection emptyVarCallSites()
        (ß PersistentHashSet.EMPTY)
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (§ field- Object _first)
    (§ field- ISeq _more)

    (§ constructor Cons(Object first, ISeq _more)
        (ß this._first = first)
        (ß this._more = _more)
        this
    )

    (§ constructor Cons(IPersistentMap meta, Object _first, ISeq _more)
        (§ super(meta))
        (ß this._first = _first)
        (ß this._more = _more)
        this
    )

    (§ method Object first()
        (ß _first)
    )

    (§ method ISeq next()
        (ß more().seq())
    )

    (§ method ISeq more()
        (§ if (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    (§ method int count()
        (ß 1 + RT.count(_more))
    )

    (§ method Cons withMeta(IPersistentMap meta)
        (ß new Cons(meta, _first, _more))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ interface Counted
    (§ abstract int count())
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (§ field- ISeq all) ;; never nil
    (§ field- ISeq prev)
    #_volatile
    (§ field- ISeq _current) ;; lazily realized
    #_volatile
    (§ field- ISeq _next) ;; cached

    (§ constructor- Cycle(ISeq all, ISeq prev, ISeq current)
        (ß this.all = all)
        (ß this.prev = prev)
        (ß this._current = current)
        this
    )

    (§ constructor- Cycle(IPersistentMap meta, ISeq all, ISeq prev, ISeq current, ISeq next)
        (§ super(meta))
        (ß this.all = all)
        (ß this.prev = prev)
        (ß this._current = current)
        (ß this._next = next)
        this
    )

    (§ defn ISeq create(ISeq vals)
        (§ if (ß vals == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Cycle(vals, nil, vals))
    )

    ;; realization for use of current
    (§ method- ISeq current()
        (§ if (ß _current == nil)
            (§ let ISeq current = prev.next())
            (ß _current = (current == nil) ? all :or current)
        )
        (ß _current)
    )

    (§ method boolean isRealized()
        (ß (_current != nil))
    )

    (§ method Object first()
        (ß current().first())
    )

    (§ method ISeq next()
        (§ if (ß _next == nil)
            (ß _next = new Cycle(all, current(), nil))
        )
        (ß _next)
    )

    (§ method Cycle withMeta(IPersistentMap meta)
        (ß new Cycle(meta, all, prev, _current, _next))
    )

    (§ method Object reduce(IFn f)
        (§ let ISeq s = current())
        (§ let Object ret = s.first())
        (§ while true
            (ß s = s.next())
            (§ if (ß s == nil)
                (ß s = all)
            )
            (ß ret = f.invoke(ret, s.first()))
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
        )
    )

    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = start)
        (§ let ISeq s = current())
        (§ while true
            (ß ret = f.invoke(ret, s.first()))
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            (ß s = s.next())
            (§ if (ß s == nil)
                (ß s = all)
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    #_volatile
    (§ field Object val)
    #_volatile
    (§ field Throwable exception)
    #_volatile
    (§ field IFn fn)

    (§ constructor Delay(IFn fn)
        (ß this.fn = fn)
        (ß this.val = nil)
        (ß this.exception = nil)
        this
    )

    (§ defn Object force(Object x)
        (ß (x instanceof Delay) ? ((Delay) x).deref() :or x)
    )

    (§ method Object deref()
        (§ if (ß fn != nil)
            (§ sync (ß this)
                ;; double check
                (§ if (ß fn != nil)
                    (§ try 
                        (ß val = fn.invoke())
                    )
                    (§ catch (ß Throwable t)
                        (ß exception = t)
                    )
                    (ß fn = nil)
                )
            )
        )
        (§ if (ß exception != nil)
            (§ throw Util.sneakyThrow(exception))
        )
        val
    )

    (§ method boolean isRealized()
        (§ sync (ß this)
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (§ field HashMap<Integer, Object[]> constantVals = new HashMap<Integer, Object[]>())
    (§ def ConcurrentHashMap<String, Reference<Class>>classCache = new ConcurrentHashMap<String, Reference<Class> >())

    (§ def URL[] EMPTY_URLS = new URL[] (§))

    (§ def ReferenceQueue rq = new ReferenceQueue())

    (§ constructor DynamicClassLoader()
        ;; pseudo test in lieu of hasContextClassLoader()
        (§ super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == nil || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader()))
        this
    )

    (§ constructor DynamicClassLoader(ClassLoader parent)
        (§ super(EMPTY_URLS, parent))
        this
    )

    (§ method Class defineClass(String name, byte[] bytes, Object srcForm)
        (ß Util.clearCache(rq, classCache))
        (§ let Class c = defineClass(name, bytes, 0, bytes.length))
        (ß classCache.put(name, new SoftReference(c, rq)))
        c
    )

    (§ defn Class<?> findInMemoryClass(String name)
        (§ let Reference<Class> cr = classCache.get(name))
        (§ if (ß cr != nil)
            (§ let Class c = cr.get())
            (§ if (ß c != nil)
                (§ return c)
            )
            (§ else 
                (ß classCache.remove(name, cr))
            )
        )
        nil
    )

    #_protected
    (§ method Class<?>findClass(String name) (§ throws ClassNotFoundException)
        (§ let Class c = findInMemoryClass(name))
        (§ if (ß c != nil)
            c
        )
        (§ else 
            (ß super.findClass(name))
        )
    )

    #_protected
    (§ method Class<?> loadClass(String name, boolean resolve) (§ throws ClassNotFoundException)
        (§ sync (ß this)
            (§ let Class c = findLoadedClass(name))
            (§ if (ß c == nil)
                (ß c = findInMemoryClass(name))
                (§ if (ß c == nil)
                    (ß c = super.loadClass(name, false))
                )
            )
            (§ if (ß resolve)
                (ß resolveClass(c))
            )
            c
        )
    )

    (§ method void registerConstants(int id, Object[] val)
        (ß constantVals.put(id, val))
        nil
    )

    (§ method Object[] getConstants(int id)
        (ß constantVals.get(id))
    )

    (§ method void addURL(URL url)
        (ß super.addURL(url))
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReader
    (§ def IFn[] macros = new IFn[256])
    (§ def IFn[] dispatchMacros = new IFn[256])
    (§ def Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (§ def Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (§ def Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)"))
    (§ def Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    (§ def IFn taggedReader = new TaggedReader())

    (§ static
        (ß macros[\"] = new StringReader()) ;; oops! "
        (ß macros[\;] = new CommentReader())
        (ß macros[\^] = new MetaReader())
        (ß macros[\(] = new ListReader())
        (ß macros[\)] = new UnmatchedDelimiterReader())
        (ß macros[\[] = new VectorReader())
        (ß macros[\]] = new UnmatchedDelimiterReader())
        (ß macros[\{] = new MapReader())
        (ß macros[\}] = new UnmatchedDelimiterReader())
        (ß macros[\\] = new CharacterReader())
        (ß macros[\#] = new DispatchReader())

        (ß dispatchMacros[\#] = new SymbolicValueReader())
        (ß dispatchMacros[\^] = new MetaReader())
        (ß dispatchMacros[\{] = new SetReader())
        (ß dispatchMacros[\<] = new UnreadableReader())
        (ß dispatchMacros[\_] = new DiscardReader())
        (ß dispatchMacros[\:] = new NamespaceMapReader())
    )

    (§ defn boolean nonConstituent(int ch)
        (ß (ch == \@ || ch == \` || ch == \~))
    )

    (§ defn Object readString(String s, IPersistentMap opts)
        (§ let PushbackReader r = new PushbackReader(new java.io.StringReader(s)))
        (ß read(r, opts))
    )

    (§ defn boolean isWhitespace(int ch)
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn void unread(PushbackReader r, int ch)
        (§ if (ß ch != -1)
            (§ try 
                (ß r.unread(ch))
            )
            (§ catch (ß IOException e)
                (§ throw Util.sneakyThrow(e))
            )
        )
        nil
    )

    (class-ns ReaderException (§ extends RuntimeException)
        (§ field int line)
        (§ field int column)

        (§ constructor ReaderException(int line, int column, Throwable cause)
            (§ super(cause))
            (ß this.line = line)
            (ß this.column = column)
            this
        )
    )

    (§ defn int read1(Reader r)
        (§ try 
            (ß r.read())
        )
        (§ catch (ß IOException e)
            (§ throw Util.sneakyThrow(e))
        )
    )

    (§ def Keyword EOF = Keyword.intern(nil, "eof"))

    (§ defn Object read(PushbackReader r, IPersistentMap opts)
        (ß read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts))
    )

    (§ defn Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
        (§ try 
            (§ while true
                (§ let int ch = read1(r))

                (§ while (ß isWhitespace(ch))
                    (ß ch = read1(r))
                )

                (§ if (ß ch == -1)
                    (§ if (ß eofIsError)
                        (§ throw Util.runtimeException("EOF while reading"))
                    )
                    (§ return eofValue)
                )

                (§ if (ß Character.isDigit(ch))
                    (§ let Object n = readNumber(r, (char) ch))
                    (§ if (ß RT.suppressRead())
                        (§ return nil)
                    )
                    (§ return n)
                )

                (§ let IFn macroFn = getMacro(ch))
                (§ if (ß macroFn != nil)
                    (§ let Object ret = macroFn.invoke(r, (char) ch, opts))
                    (§ if (ß RT.suppressRead())
                        (§ return nil)
                    )
                    ;; no op macros return the reader
                    (§ if (ß ret == r)
                        (§ continue )
                    )
                    (§ return ret)
                )

                (§ if (ß ch == \+ || ch == \-)
                    (§ let int ch2 = read1(r))
                    (§ if (ß Character.isDigit(ch2))
                        (ß unread(r, ch2))
                        (§ let Object n = readNumber(r, (char) ch))
                        (§ if (ß RT.suppressRead())
                            (§ return nil)
                        )
                        (§ return n)
                    )
                    (ß unread(r, ch2))
                )

                (§ let String token = readToken(r, (char) ch, true))
                (§ if (ß RT.suppressRead())
                    (§ return nil)
                )
                (§ return (ß interpretToken(token)))
            )
        )
        (§ catch (ß Exception e)
            (§ if (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                (§ throw Util.sneakyThrow(e))
            )
            (§ let LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r)
            (§ throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e))
        )
    )

    (§ defn- String readToken(PushbackReader r, char initch, boolean leadConstituent)
        (§ let StringBuilder sb = new StringBuilder())
        (§ if (ß leadConstituent && nonConstituent(initch))
            (§ throw Util.runtimeException("Invalid leading character: " + (char)initch))
        )

        (ß sb.append(initch))

        (§ while true
            (§ let int ch = read1(r))

            (§ if (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                (ß unread(r, ch))
                (§ return (ß sb.toString()))
            )
            (§ elseif (ß nonConstituent(ch))
                (§ throw Util.runtimeException("Invalid constituent character: " + (char)ch))
            )
            (ß sb.append((char) ch))
        )
    )

    (§ defn- Object readNumber(PushbackReader r, char initch)
        (§ let StringBuilder sb = new StringBuilder())
        (ß sb.append(initch))

        (§ while true
            (§ let int ch = read1(r))
            (§ if (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                (ß unread(r, ch))
                (§ break )
            )
            (ß sb.append((char) ch))
        )

        (§ let String s = sb.toString())
        (§ let Object n = matchNumber(s))
        (§ if (ß n == nil)
            (§ throw new NumberFormatException("Invalid number: " + s))
        )
        n
    )

    (§ defn- int readUnicodeChar(String token, int offset, int length, int base)
        (§ if (ß token.length() != offset + length)
            (§ throw new IllegalArgumentException("Invalid unicode character: \\" + token))
        )
        (§ let int uc = 0)
        (§ loop-when-recur [(ß int i = offset)] (ß i < offset + length) [(ß ++i)]
            (§ let int d = Character.digit(token.charAt(i), base))
            (§ if (ß d == -1)
                (§ throw new IllegalArgumentException("Invalid digit: " + token.charAt(i)))
            )
            (ß uc = uc * base + d)
        )
        (ß (char) uc)
    )

    (§ defn- int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
        (§ let int uc = Character.digit(initch, base))
        (§ if (ß uc == -1)
            (§ throw new IllegalArgumentException("Invalid digit: " + (char) initch))
        )
        (§ let int i = 1)
        (§ loop-when-recur [(ß )] (ß i < length) [(ß ++i)]
            (§ let int ch = read1(r))
            (§ if (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                (ß unread(r, ch))
                (§ break )
            )
            (§ let int d = Character.digit(ch, base))
            (§ if (ß d == -1)
                (§ throw new IllegalArgumentException("Invalid digit: " + (char) ch))
            )
            (ß uc = uc * base + d)
        )
        (§ if (ß i != length && exact)
            (§ throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length))
        )
        uc
    )

    (§ defn- Object interpretToken(String s)
        (§ if (ß s.equals("nil"))
            (§ return nil)
        )
        (§ elseif (ß s.equals("true"))
            (§ return (ß RT.T))
        )
        (§ elseif (ß s.equals("false"))
            (§ return (ß RT.F))
        )

        (§ let Object ret = nil)

        (ß ret = matchSymbol(s))
        (§ if (ß ret != nil)
            (§ return ret)
        )

        (§ throw Util.runtimeException("Invalid token: " + s))
    )

    (§ defn- Object matchSymbol(String s)
        (§ let Matcher m = symbolPat.matcher(s))
        (§ if (ß m.matches())
            (§ let int gc = m.groupCount())
            (§ let String ns = m.group(1))
            (§ let String name = m.group(2))
            (§ if (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                (§ return nil)
            )
            (§ if (ß s.startsWith("::"))
                (§ return nil)
            )
            (§ let boolean isKeyword = s.charAt(0) == \:)
            (§ let Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0)))
            (§ if (ß isKeyword)
                (§ return (ß Keyword.intern(sym)))
            )
            (§ return sym)
        )
        nil
    )

    (§ defn- Object matchNumber(String s)
        (§ let Matcher m = intPat.matcher(s))
        (§ if (ß m.matches())
            (§ if (ß m.group(2) != nil)
                (§ if (ß m.group(8) != nil)
                    (§ return (ß BigInt.ZERO))
                )
                (§ return (ß Numbers.num(0)))
            )
            (§ let boolean negate = m.group(1).equals("-"))
            (§ let String n)
            (§ let int radix = 10)
            (§ if (ß (n = m.group(3)) != nil)
                (ß radix = 10)
            )
            (§ elseif (ß (n = m.group(4)) != nil)
                (ß radix = 16)
            )
            (§ elseif (ß (n = m.group(5)) != nil)
                (ß radix = 8)
            )
            (§ elseif (ß (n = m.group(7)) != nil)
                (ß radix = Integer.parseInt(m.group(6)))
            )
            (§ if (ß n == nil)
                (§ return nil)
            )
            (§ let BigInteger bn = new BigInteger(n, radix))
            (§ if (ß negate)
                (ß bn = bn.negate())
            )
            (§ if (ß m.group(8) != nil)
                (§ return (ß BigInt.fromBigInteger(bn)))
            )
            (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
        )
        (ß m = floatPat.matcher(s))
        (§ if (ß m.matches())
            (§ if (ß m.group(4) != nil)
                (§ return (ß new BigDecimal(m.group(1))))
            )
            (§ return (ß Double.parseDouble(s)))
        )
        (ß m = ratioPat.matcher(s))
        (§ if (ß m.matches())
            (§ let String numerator = m.group(1))
            (§ if (ß numerator.startsWith("+"))
                (ß numerator = numerator.substring(1))
            )

            (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
        )
        nil
    )

    (§ defn- IFn getMacro(int ch)
        (§ if (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- boolean isMacro(int ch)
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- boolean isTerminatingMacro(int ch)
        (ß (ch != \# && ch != \' && isMacro(ch)))
    )

    (class-ns StringReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object doublequote, Object opts)
            (§ let StringBuilder sb = new StringBuilder())
            (§ let Reader r = (Reader) reader)

            (§ loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                (§ if (ß ch == -1)
                    (§ throw Util.runtimeException("EOF while reading string"))
                )
                (§ if (ß ch == \\) ;; escape
                    (ß ch = read1(r))
                    (§ if (ß ch == -1)
                        (§ throw Util.runtimeException("EOF while reading string"))
                    )
                    (§ switch (ß ch)
                        (§ case \t)
                        (do
                            (ß ch = \tab)
                            (§ break )
                        )
                        (§ case \r)
                        (do
                            (ß ch = \return)
                            (§ break )
                        )
                        (§ case \n)
                        (do
                            (ß ch = \newline)
                            (§ break )
                        )
                        (§ case \\)
                        (do
                            (§ break )
                        )
                        (§ case \") ;; oops! "
                        (do
                            (§ break )
                        )
                        (§ case \b)
                        (do
                            (ß ch = \backspace)
                            (§ break )
                        )
                        (§ case \f)
                        (do
                            (ß ch = \formfeed)
                            (§ break )
                        )
                        (§ case \u)
                        (do
                            (ß ch = read1(r))
                            (§ if (ß Character.digit(ch, 16) == -1)
                                (§ throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch))
                            )
                            (ß ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (§ if (ß Character.isDigit(ch))
                                (ß ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                (§ if (ß ch > 0377)
                                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                                )
                            )
                            (§ else 
                                (§ throw Util.runtimeException("Unsupported escape character: \\" + (char) ch))
                            )
                            (§ break )
                        )
                    )
                )
                (ß sb.append((char) ch))
            )
            (ß sb.toString())
        )
    )

    (class-ns CommentReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object semicolon, Object opts)
            (§ let Reader r = (Reader) reader)
            (§ let int ch)
            (§ loop
                (ß ch = read1(r))
                (§ recur-if (ch != -1 && ch != \newline && ch != \return))
            )
            r
        )
    )

    (class-ns DiscardReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object underscore, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß read(r, true, nil, true, opts))
            r
        )
    )

    (class-ns NamespaceMapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object colon, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)

            ;; Read ns symbol
            (§ let Object sym = read(r, true, nil, false, opts))
            (§ if (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                (§ throw new RuntimeException("Namespaced map must specify a valid namespace: " + sym))
            )
            (§ let String ns = ((Symbol)sym).getName())

            ;; Read map
            (§ let int nextChar = read1(r))
            (§ while (ß isWhitespace(nextChar))
                (ß nextChar = read1(r))
            )
            (§ if (ß \{ != nextChar)
                (§ throw new RuntimeException("Namespaced map must specify a map"))
            )
            (§ let List kvs = readDelimitedList(\}, r, true, opts))
            (§ if (ß (kvs.size() & 1) == 1)
                (§ throw Util.runtimeException("Namespaced map literal must contain an even number of forms"))
            )

            ;; Construct output map
            (§ let Object[] a = new Object[kvs.size()])
            (§ let Iterator iter = kvs.iterator())
            (§ loop-when-recur [(ß int i = 0)] (ß iter.hasNext()) [(ß i += 2)]
                (§ let Object key = iter.next())
                (§ let Object val = iter.next())

                (§ if (ß key instanceof Keyword)
                    (§ let Keyword kw = (Keyword) key)
                    (§ if (ß kw.getNamespace() == nil)
                        (ß key = Keyword.intern(ns, kw.getName()))
                    )
                    (§ elseif (ß kw.getNamespace().equals("_"))
                        (ß key = Keyword.intern(nil, kw.getName()))
                    )
                )
                (§ elseif (ß key instanceof Symbol)
                    (§ let Symbol s = (Symbol) key)
                    (§ if (ß s.getNamespace() == nil)
                        (ß key = Symbol.intern(ns, s.getName()))
                    )
                    (§ elseif (ß s.getNamespace().equals("_"))
                        (ß key = Symbol.intern(nil, s.getName()))
                    )
                )
                (ß a[i] = key)
                (ß a[i + 1] = val)
            )
            (ß RT.map(a))
        )
    )

    (class-ns DispatchReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object hash, Object opts)
            (§ let int ch = read1((Reader) reader))
            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let IFn fn = dispatchMacros[ch])

            (§ if (ß fn == nil)
                ;; try tagged reader
                (§ if (ß Character.isLetter(ch))
                    (ß unread((PushbackReader) reader, ch))
                    (§ return (ß taggedReader.invoke(reader, ch, opts)))
                )

                (§ throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch)))
            )
            (ß fn.invoke(reader, ch, opts))
        )
    )

    (class-ns MetaReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object caret, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (ß r instanceof LineNumberingPushbackReader)
                (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ let Object meta = read(r, true, nil, true, opts))
            (§ if (ß meta instanceof Symbol || meta instanceof String)
                (ß meta = RT.map(RT.TAG_KEY, meta))
            )
            (§ elseif (ß meta instanceof Keyword)
                (ß meta = RT.map(meta, RT.T))
            )
            (§ elseif (ß !(meta instanceof IPersistentMap))
                (§ throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map"))
            )

            (§ let Object o = read(r, true, nil, true, opts))
            (§ if (ß o instanceof IMeta)
                (§ if (ß line != -1 && o instanceof ISeq)
                    (ß meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                )
                (§ if (ß o instanceof IReference)
                    (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                    (§ return o)
                )
                (§ let Object ometa = RT.meta(o))
                (§ loop-when-recur [(ß ISeq s = RT.seq(meta))] (ß s != nil) [(ß s = s.next())]
                    (§ let IMapEntry kv = (IMapEntry) s.first())
                    (ß ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                )
                (ß ((IObj) o).withMeta((IPersistentMap) ometa))
            )
            (§ else 
                (§ throw new IllegalArgumentException("Metadata can only be applied to IMetas"))
            )
        )
    )

    (class-ns CharacterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object backslash, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let String token = readToken(r, (char) ch, false))
            (§ if (ß token.length() == 1)
                (§ return (ß Character.valueOf(token.charAt(0))))
            )
            (§ elseif (ß token.equals("newline"))
                (§ return (ß \newline))
            )
            (§ elseif (ß token.equals("space"))
                (§ return (ß \space))
            )
            (§ elseif (ß token.equals("tab"))
                (§ return (ß \tab))
            )
            (§ elseif (ß token.equals("backspace"))
                (§ return (ß \backspace))
            )
            (§ elseif (ß token.equals("formfeed"))
                (§ return (ß \formfeed))
            )
            (§ elseif (ß token.equals("return"))
                (§ return (ß \return))
            )
            (§ elseif (ß token.startsWith("u"))
                (§ let char c = (char) readUnicodeChar(token, 1, 4, 16))
                (§ if (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                    (§ throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16)))
                )
                (§ return c)
            )
            (§ elseif (ß token.startsWith("o"))
                (§ let int len = token.length() - 1)
                (§ if (ß len > 3)
                    (§ throw Util.runtimeException("Invalid octal escape sequence length: " + len))
                )
                (§ let int uc = readUnicodeChar(token, 1, len, 8))
                (§ if (ß uc > 0377)
                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                )
                (§ return (ß (char) uc))
            )
            (§ throw Util.runtimeException("Unsupported character: \\" + token))
        )
    )

    (class-ns ListReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (ß r instanceof LineNumberingPushbackReader)
                (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ let List list = readDelimitedList(\), r, true, opts))
            (§ if (ß list.isEmpty())
                (§ return (ß PersistentList.EMPTY))
            )
            (§ let IObj s = (IObj) PersistentList.create(list))
            s
        )
    )

    (class-ns VectorReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts)))
        )
    )

    (class-ns MapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object[] a = readDelimitedList(\}, r, true, opts).toArray())
            (§ if (ß (a.length & 1) == 1)
                (§ throw Util.runtimeException("Map literal must contain an even number of forms"))
            )
            (ß RT.map(a))
        )
    )

    (class-ns SetReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftbracket, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts)))
        )
    )

    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object rightdelim, Object opts)
            (§ throw Util.runtimeException("Unmatched delimiter: " + rightdelim))
        )
    )

    (class-ns UnreadableReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftangle, Object opts)
            (§ throw Util.runtimeException("Unreadable form"))
        )
    )

    (class-ns SymbolicValueReader (§ extends AFn)
        (§ def IPersistentMap specials = PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        ))

        (§ method Object invoke(Object reader, Object quote, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts))

            (§ if (ß !(o instanceof Symbol))
                (§ throw Util.runtimeException("Invalid token: ##" + o))
            )
            (§ if (ß !(specials.containsKey(o)))
                (§ throw Util.runtimeException("Unknown symbolic value: ##" + o))
            )

            (ß specials.valAt(o))
        )
    )

    (§ defn List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts)
        (§ let int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)

        (§ let ArrayList a = new ArrayList())

        (§ while true
            (§ let int ch = read1(r))

            (§ while (ß isWhitespace(ch))
                (ß ch = read1(r))
            )

            (§ if (ß ch == -1)
                (§ if (ß firstline < 0)
                    (§ throw Util.runtimeException("EOF while reading"))
                )
                (§ else 
                    (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                )
            )

            (§ if (ß ch == delim)
                (§ break )
            )

            (§ let IFn macroFn = getMacro(ch))
            (§ if (ß macroFn != nil)
                (§ let Object mret = macroFn.invoke(r, (char) ch, opts))
                ;; no op macros return the reader
                (§ if (ß mret != r)
                    (ß a.add(mret))
                )
            )
            (§ else 
                (ß unread(r, ch))

                (§ let Object o = read(r, true, nil, isRecursive, opts))
                (§ if (ß o != r)
                    (ß a.add(o))
                )
            )
        )

        a
    )

    (class-ns TaggedReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object firstChar, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object name = read(r, true, nil, false, opts))
            (§ if (ß !(name instanceof Symbol))
                (§ throw new RuntimeException("Reader tag must be a symbol"))
            )
            (§ let Symbol sym = (Symbol)name)
            (ß readTagged(r, sym, (IPersistentMap) opts))
        )

        (§ def Keyword READERS = Keyword.intern(nil, "readers"))
        (§ def Keyword DEFAULT = Keyword.intern(nil, "default"))

        (§ method- Object readTagged(PushbackReader reader, Symbol tag, IPersistentMap opts)
            (§ let Object o = read(reader, true, nil, true, opts))

            (§ let ILookup readers = (ILookup)RT.get(opts, READERS))
            (§ let IFn dataReader = (IFn)RT.get(readers, tag))
            (§ if (ß dataReader == nil)
                (ß dataReader = (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag))
            )
            (§ if (ß dataReader == nil)
                (§ let IFn defaultReader = (IFn)RT.get(opts, DEFAULT))
                (§ if (ß defaultReader != nil)
                    (ß defaultReader.invoke(tag, o))
                )
                (§ else 
                    (§ throw new RuntimeException("No reader function for tag " + tag.toString()))
                )
            )
            (§ else 
                (ß dataReader.invoke(o))
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeq (§ extends ASeq)
    (§ field Enumeration iter)
    (§ field State state)

    (class-ns State
        #_volatile
        (§ field Object val)
        #_volatile
        (§ field Object _rest)
    )

    (§ defn EnumerationSeq create(Enumeration iter)
        (§ if (ß iter.hasMoreElements())
            (§ return (ß new EnumerationSeq(iter)))
        )
        nil
    )

    (§ constructor EnumerationSeq(Enumeration iter)
        (ß this.iter = iter)
        (ß state = new State())
        (ß this.state.val = state)
        (ß this.state._rest = state)
        this
    )

    (§ constructor EnumerationSeq(IPersistentMap meta, Enumeration iter, State state)
        (§ super(meta))
        (ß this.iter = iter)
        (ß this.state = state)
        this
    )

    (§ method Object first()
        (§ if (ß state.val == state)
            (§ sync (ß state)
                (§ if (ß state.val == state)
                    (ß state.val = iter.nextElement())
                )
            )
        )
        (ß state.val)
    )

    (§ method ISeq next()
        (§ if (ß state._rest == state)
            (§ sync (ß state)
                (§ if (ß state._rest == state)
                    (ß first())
                    (ß state._rest = create(iter))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    (§ method EnumerationSeq withMeta(IPersistentMap meta)
        (ß new EnumerationSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (§ field IPersistentMap data)

    (§ constructor ExceptionInfo(String s, IPersistentMap data)
        (§ this(s, data, nil))
        this
    )

    (§ constructor ExceptionInfo(String s, IPersistentMap data, Throwable throwable)
        ;; nil cause is equivalent to not passing a cause
        (§ super(s, throwable))
        (§ if (ß data != nil)
            (ß this.data = data)
        )
        (§ else 
            (§ throw new IllegalArgumentException("Additional data must be non-nil."))
        )
        this
    )

    (§ method IPersistentMap getData()
        data
    )

    (§ method String toString()
        (ß "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString())
    )
)
)

(java-ns cloiure.lang.Fn

(§ interface Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (§ field Var v)
    (§ field ClassLoader loader)
    (§ field String fnClassName)
    (§ field IFn fn)

    (§ constructor FnLoaderThunk(Var v, String fnClassName)
        (ß this.v = v)
        (ß this.loader = (ClassLoader) RT.FN_LOADER_VAR.get())
        (ß this.fnClassName = fnClassName)
        (ß fn = nil)
        this
    )

    (§ method Object invoke(Object arg1)
        (ß load())
        (ß fn.invoke(arg1))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß load())
        (ß fn.invoke(arg1, arg2))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß load())
        (ß fn.invoke(arg1, arg2, arg3))
    )

    #_protected
    (§ method Object doInvoke(Object args)
        (ß load())
        (ß fn.applyTo((ISeq) args))
    )

    (§ method- void load()
        (§ if (ß fn == nil)
            (§ try 
                (ß fn = (IFn) Class.forName(fnClassName, true, loader).newInstance())
            )
            (§ catch (ß Exception e)
                (§ throw Util.sneakyThrow(e))
            )
            (ß v.root = fn)
        )
        nil
    )

    (§ method int getRequiredArity()
        0
    )

    (§ method IObj withMeta(IPersistentMap meta)
        this
    )

    (§ method IPersistentMap meta()
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ interface IAtom
    (§ abstract Object swap(IFn f))
    (§ abstract Object swap(IFn f, Object arg))
    (§ abstract Object swap(IFn f, Object arg1, Object arg2))
    (§ abstract Object swap(IFn f, Object x, Object y, ISeq args))
    (§ abstract boolean compareAndSet(Object oldv, Object newv))
    (§ abstract Object reset(Object newval))
)
)

(java-ns cloiure.lang.IAtom2

(§ interface IAtom2 (§ extends IAtom)
    (§ abstract IPersistentVector swapVals(IFn f))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg1, Object arg2))
    (§ abstract IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args))
    (§ abstract IPersistentVector resetVals(Object newv))
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ interface IBlockingDeref
    (§ abstract Object deref(long ms, Object timeoutValue))
)
)

(java-ns cloiure.lang.IChunk

(§ interface IChunk (§ extends Indexed)
    (§ abstract IChunk dropFirst())
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ interface IChunkedSeq (§ extends ISeq, Sequential)
    (§ abstract IChunk chunkedFirst())
    (§ abstract ISeq chunkedNext())
    (§ abstract ISeq chunkedMore())
)
)

(java-ns cloiure.lang.IDeref

(§ interface IDeref
    (§ abstract Object deref())
)
)

(java-ns cloiure.lang.IEditableCollection

(§ interface IEditableCollection
    (§ abstract ITransientCollection asTransient())
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ interface IExceptionInfo
    (§ abstract IPersistentMap getData())
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ interface IFn (§ extends Callable, Runnable)
    (§ abstract Object invoke())
    (§ abstract Object invoke(Object arg1))
    (§ abstract Object invoke(Object arg1, Object arg2))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args))

    (§ abstract Object applyTo(ISeq arglist))

    (§ interface L
        (§ abstract long invokePrim())
    )

    (§ interface D
        (§ abstract double invokePrim())
    )

    (§ interface OL
        (§ abstract long invokePrim(Object arg0))
    )

    (§ interface OD
        (§ abstract double invokePrim(Object arg0))
    )

    (§ interface LO
        (§ abstract Object invokePrim(long arg0))
    )

    (§ interface LL
        (§ abstract long invokePrim(long arg0))
    )

    (§ interface LD
        (§ abstract double invokePrim(long arg0))
    )

    (§ interface DO
        (§ abstract Object invokePrim(double arg0))
    )

    (§ interface DL
        (§ abstract long invokePrim(double arg0))
    )

    (§ interface DD
        (§ abstract double invokePrim(double arg0))
    )

    (§ interface OOL
        (§ abstract long invokePrim(Object arg0, Object arg1))
    )

    (§ interface OOD
        (§ abstract double invokePrim(Object arg0, Object arg1))
    )

    (§ interface OLO
        (§ abstract Object invokePrim(Object arg0, long arg1))
    )

    (§ interface OLL
        (§ abstract long invokePrim(Object arg0, long arg1))
    )

    (§ interface OLD
        (§ abstract double invokePrim(Object arg0, long arg1))
    )

    (§ interface ODO
        (§ abstract Object invokePrim(Object arg0, double arg1))
    )

    (§ interface ODL
        (§ abstract long invokePrim(Object arg0, double arg1))
    )

    (§ interface ODD
        (§ abstract double invokePrim(Object arg0, double arg1))
    )

    (§ interface LOO
        (§ abstract Object invokePrim(long arg0, Object arg1))
    )

    (§ interface LOL
        (§ abstract long invokePrim(long arg0, Object arg1))
    )

    (§ interface LOD
        (§ abstract double invokePrim(long arg0, Object arg1))
    )

    (§ interface LLO
        (§ abstract Object invokePrim(long arg0, long arg1))
    )

    (§ interface LLL
        (§ abstract long invokePrim(long arg0, long arg1))
    )

    (§ interface LLD
        (§ abstract double invokePrim(long arg0, long arg1))
    )

    (§ interface LDO
        (§ abstract Object invokePrim(long arg0, double arg1))
    )

    (§ interface LDL
        (§ abstract long invokePrim(long arg0, double arg1))
    )

    (§ interface LDD
        (§ abstract double invokePrim(long arg0, double arg1))
    )

    (§ interface DOO
        (§ abstract Object invokePrim(double arg0, Object arg1))
    )

    (§ interface DOL
        (§ abstract long invokePrim(double arg0, Object arg1))
    )

    (§ interface DOD
        (§ abstract double invokePrim(double arg0, Object arg1))
    )

    (§ interface DLO
        (§ abstract Object invokePrim(double arg0, long arg1))
    )

    (§ interface DLL
        (§ abstract long invokePrim(double arg0, long arg1))
    )

    (§ interface DLD
        (§ abstract double invokePrim(double arg0, long arg1))
    )

    (§ interface DDO
        (§ abstract Object invokePrim(double arg0, double arg1))
    )

    (§ interface DDL
        (§ abstract long invokePrim(double arg0, double arg1))
    )

    (§ interface DDD
        (§ abstract double invokePrim(double arg0, double arg1))
    )

    (§ interface OOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2))
    )

    (§ interface OOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2))
    )

    (§ interface OOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OODL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OODD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface OLDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface OLDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface ODOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface ODDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface ODDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface LOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LOLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LOLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LODO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LODL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LODD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LLOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LLDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LLDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LDOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface LDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface LDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface DOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DOLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DOLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DODO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DODL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DODD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DLOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DLDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DLDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DDOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface DDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface DDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface OOOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface OOOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface OOOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOODL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOODD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOLOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLOL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLOD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OOLDL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OOLDD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OODOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODOL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODOD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODLL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODLD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OODDL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OODDD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OLOOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOLO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLOLL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLOLD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLODO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLODL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLODD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLOL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLOD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLLDL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLLDD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLDOO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDOL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDOD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDLO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDLL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDLD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface OLDDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface OLDDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface ODOOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOLO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODOLL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODOLD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODODO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODODL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODODD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODLOO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLOL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLOD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLDO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODLDL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODLDD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODDOO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDOL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDOD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDLO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDLL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDLD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface ODDDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface ODDDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LOOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOOLL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOOLD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOODO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOODL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOODD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOLOO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLOL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLOD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLDO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LOLDL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LOLDD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LODOO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODOL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODOD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODLO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODLL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODLD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODDO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LODDL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LODDD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LLOOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOLO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLOLL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLOLD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLODO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLODL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLODD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLLOO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLOL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLOD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLDO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLLDL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLLDD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLDOO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDOL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDOD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDLO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDLL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDLD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LLDDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LLDDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LDOOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOLO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDOLL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDOLD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDODO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDODL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDODD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDLOO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLOL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLOD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLDO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDLDL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDLDD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDDOO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDOL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDOD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDLO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDLL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDLD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LDDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LDDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DOOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOOLL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOOLD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOODO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOODL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOODD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOLOO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLOL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLOD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLDO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DOLDL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DOLDD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DODOO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODOL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODOD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODLO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODLL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODLD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODDO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DODDL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DODDD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DLOOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOLO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLOLL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLOLD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLODO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLODL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLODD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLLOO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLOL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLOD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLDO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLLDL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLLDD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLDOO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDOL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDOD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDLO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDLL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDLD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DLDDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DLDDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DDOOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOLO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDOLL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDOLD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDODO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDODL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDODD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDLOO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLOL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLOD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLDO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDLDL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDLDD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDDOO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDOL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDOD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDLO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDLL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDLD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DDDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DDDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, double arg3))
    )
)
)

(java-ns cloiure.lang.IHashEq

(§ interface IHashEq
    (§ abstract int hasheq())
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ interface IKeywordLookup
    (§ abstract ILookupThunk getLookupThunk(Keyword k))
)
)

(java-ns cloiure.lang.IKVReduce

(§ interface IKVReduce
    (§ abstract Object kvreduce(IFn f, Object init))
)
)

(java-ns cloiure.lang.ILookup

(§ interface ILookup
    (§ abstract Object valAt(Object key))
    (§ abstract Object valAt(Object key, Object notFound))
)
)

(java-ns cloiure.lang.ILookupSite

(§ interface ILookupSite
    (§ abstract ILookupThunk fault(Object target))
)
)

(java-ns cloiure.lang.ILookupThunk

(§ interface ILookupThunk
    (§ abstract Object get(Object target))
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ interface IMapEntry (§ extends Map).Entry
    (§ abstract Object key())
    (§ abstract Object val())
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ interface IMapIterable
    (§ abstract Iterator keyIterator())
    (§ abstract Iterator valIterator())
)
)

(java-ns cloiure.lang.IMeta

(§ interface IMeta
    (§ abstract IPersistentMap meta())
)
)

(java-ns cloiure.lang.Indexed

(§ interface Indexed (§ extends Counted)
    (§ abstract Object nth(int i))
    (§ abstract Object nth(int i, Object notFound))
)
)

(java-ns cloiure.lang.IndexedSeq

(§ interface IndexedSeq (§ extends ISeq, Sequential, Counted)
    (§ abstract int index())
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

(class-ns Intrinsics (§ implements Opcodes)
    (§ defn- Object[] oa(Object... arr)
        arr
    )

    (§ def IPersistentMap ops = RT.map(
      #_map "public static double cloiure.lang.Numbers.add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.and(long,long)", LAND,
      #_map "public static long cloiure.lang.Numbers.or(long,long)", LOR,
      #_map "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
      #_map "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
      #_map "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
      #_map "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
      #_map "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
      #_map "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
      #_map "public static double cloiure.lang.Numbers.minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
      #_map "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
      #_map "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
      #_map "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
      #_map "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
      #_map "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
      #_map "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
      #_map "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
      #_map "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
      #_map "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

      #_map "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
      #_map "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
      #_map "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
      #_map "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
      #_map "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
      #_map "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
      #_map "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
      #_map "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
      #_map "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
      #_map "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

      #_map "public static double cloiure.lang.RT.doubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.doubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.doubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.doubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
      #_map "public static long cloiure.lang.RT.longCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.longCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(int)", I2L,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    ))

    ;; map to instructions terminated with comparator for branch to false
    (§ def IPersistentMap preds = RT.map(
      #_map "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
      #_map "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
      #_map "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
      #_map "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

      #_map "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    ))
)
)

(java-ns cloiure.lang.IObj

(§ interface IObj (§ extends IMeta)
    (§ abstract IObj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.IPending

(§ interface IPending
    (§ abstract boolean isRealized())
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ interface IPersistentCollection (§ extends Seqable)
    (§ abstract int count())
    (§ abstract IPersistentCollection cons(Object o))
    (§ abstract IPersistentCollection empty())
    (§ abstract boolean equiv(Object o))
)
)

(java-ns cloiure.lang.IPersistentList

(§ interface IPersistentList (§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ interface IPersistentMap (§ extends Iterable, Associative, Counted)
    (§ abstract IPersistentMap assoc(Object key, Object val))
    (§ abstract IPersistentMap assocEx(Object key, Object val))
    (§ abstract IPersistentMap without(Object key))
)
)

(java-ns cloiure.lang.IPersistentSet

(§ interface IPersistentSet (§ extends IPersistentCollection, Counted)
    (§ abstract IPersistentSet disjoin(Object key))
    (§ abstract boolean contains(Object key))
    (§ abstract Object get(Object key))
)
)

(java-ns cloiure.lang.IPersistentStack

(§ interface IPersistentStack (§ extends IPersistentCollection)
    (§ abstract Object peek())
    (§ abstract IPersistentStack pop())
)
)

(java-ns cloiure.lang.IPersistentVector

(§ interface IPersistentVector (§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    (§ abstract int length())
    (§ abstract IPersistentVector assocN(int i, Object val))
    (§ abstract IPersistentVector cons(Object o))
)
)

(java-ns cloiure.lang.IProxy

(§ interface IProxy
    (§ abstract void __initCloiureFnMappings(IPersistentMap m))
    (§ abstract void __updateCloiureFnMappings(IPersistentMap m))
    (§ abstract IPersistentMap __getCloiureFnMappings())
)
)

(java-ns cloiure.lang.IRecord

(§ interface IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ interface IReduce (§ extends IReduceInit)
    (§ abstract Object reduce(IFn f))
)
)

(java-ns cloiure.lang.IReduceInit

(§ interface IReduceInit
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IRef

(§ interface IRef (§ extends IDeref)
    (§ abstract void setValidator(IFn vf))
    (§ abstract IFn getValidator())
    (§ abstract IPersistentMap getWatches())
    (§ abstract IRef addWatch(Object key, IFn callback))
    (§ abstract IRef removeWatch(Object key))
)
)

(java-ns cloiure.lang.IReference

(§ interface IReference (§ extends IMeta)
    (§ abstract IPersistentMap alterMeta(IFn alter, ISeq args))
    (§ abstract IPersistentMap resetMeta(IPersistentMap m))
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ interface ISeq (§ extends IPersistentCollection)
    (§ abstract Object first())
    (§ abstract ISeq next())
    (§ abstract ISeq more())
    (§ abstract ISeq cons(Object o))
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (§ def- Object UNREALIZED_SEED = new Object())
    (§ field- IFn f) ;; never nil
    (§ field- Object prevSeed)
    #_volatile
    (§ field- Object _seed) ;; lazily realized
    #_volatile
    (§ field- ISeq _next) ;; cached

    (§ constructor- Iterate(IFn f, Object prevSeed, Object seed)
        (ß this.f = f)
        (ß this.prevSeed = prevSeed)
        (ß this._seed = seed)
        this
    )

    (§ constructor- Iterate(IPersistentMap meta, IFn f, Object prevSeed, Object seed, ISeq next)
        (§ super(meta))
        (ß this.f = f)
        (ß this.prevSeed = prevSeed)
        (ß this._seed = seed)
        (ß this._next = next)
        this
    )

    (§ defn ISeq create(IFn f, Object seed)
        (ß new Iterate(f, nil, seed))
    )

    (§ method boolean isRealized()
        (ß (_seed != UNREALIZED_SEED))
    )

    (§ method Object first()
        (§ if (ß _seed == UNREALIZED_SEED)
            (ß _seed = f.invoke(prevSeed))
        )
        (ß _seed)
    )

    (§ method ISeq next()
        (§ if (ß _next == nil)
            (ß _next = new Iterate(f, first(), UNREALIZED_SEED))
        )
        (ß _next)
    )

    (§ method Iterate withMeta(IPersistentMap meta)
        (ß new Iterate(meta, f, prevSeed, _seed, _next))
    )

    (§ method Object reduce(IFn rf)
        (§ let Object first = first())
        (§ let Object ret = first)
        (§ let Object v = f.invoke(first))
        (§ while true
            (ß ret = rf.invoke(ret, v))
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            (ß v = f.invoke(v))
        )
    )

    (§ method Object reduce(IFn rf, Object start)
        (§ let Object ret = start)
        (§ let Object v = first())
        (§ while true
            (ß ret = rf.invoke(ret, v))
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            (ß v = f.invoke(v))
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeq (§ extends ASeq)
    (§ field Iterator iter)
    (§ field State state)

    (class-ns State
        #_volatile
        (§ field Object val)
        #_volatile
        (§ field Object _rest)
    )

    (§ defn IteratorSeq create(Iterator iter)
        (§ if (ß iter.hasNext())
            (§ return (ß new IteratorSeq(iter)))
        )
        nil
    )

    (§ constructor IteratorSeq(Iterator iter)
        (ß this.iter = iter)
        (ß state = new State())
        (ß this.state.val = state)
        (ß this.state._rest = state)
        this
    )

    (§ constructor IteratorSeq(IPersistentMap meta, Iterator iter, State state)
        (§ super(meta))
        (ß this.iter = iter)
        (ß this.state = state)
        this
    )

    (§ method Object first()
        (§ if (ß state.val == state)
            (§ sync (ß state)
                (§ if (ß state.val == state)
                    (ß state.val = iter.next())
                )
            )
        )
        (ß state.val)
    )

    (§ method ISeq next()
        (§ if (ß state._rest == state)
            (§ sync (ß state)
                (§ if (ß state._rest == state)
                    (ß first())
                    (ß state._rest = create(iter))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    (§ method IteratorSeq withMeta(IPersistentMap meta)
        (ß new IteratorSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ interface ITransientAssociative (§ extends ITransientCollection, ILookup)
    (§ abstract ITransientAssociative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ interface ITransientAssociative2 (§ extends ITransientAssociative)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
)
)

(java-ns cloiure.lang.ITransientCollection

(§ interface ITransientCollection
    (§ abstract ITransientCollection conj(Object val))
    (§ abstract IPersistentCollection persistent())
)
)

(java-ns cloiure.lang.ITransientMap

(§ interface ITransientMap (§ extends ITransientAssociative, Counted)
    (§ abstract ITransientMap assoc(Object key, Object val))
    (§ abstract ITransientMap without(Object key))
    (§ abstract IPersistentMap persistent())
)
)

(java-ns cloiure.lang.ITransientSet

(§ interface ITransientSet (§ extends ITransientCollection, Counted)
    (§ abstract ITransientSet disjoin(Object key))
    (§ abstract boolean contains(Object key))
    (§ abstract Object get(Object key))
)
)

(java-ns cloiure.lang.ITransientVector

(§ interface ITransientVector (§ extends ITransientAssociative, Indexed)
    (§ abstract ITransientVector assocN(int i, Object val))
    (§ abstract ITransientVector pop())
)
)

(java-ns cloiure.lang.IType

(§ interface IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (§ def- ConcurrentHashMap<Symbol, Reference<Keyword>> table = new ConcurrentHashMap())

    (§ def ReferenceQueue rq = new ReferenceQueue())

    (§ field Symbol sym)
    (§ field int hasheq)
    #_transient
    (§ field String _str)

    (§ defn Keyword intern(Symbol sym)
        (§ let Keyword k = nil)
        (§ let Reference<Keyword> existingRef = table.get(sym))
        (§ if (ß existingRef == nil)
            (ß Util.clearCache(rq, table))
            (§ if (ß sym.meta() != nil)
                (ß sym = (Symbol) sym.withMeta(nil))
            )
            (ß k = new Keyword(sym))
            (ß existingRef = table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq)))
        )
        (§ if (ß existingRef == nil)
            (§ return k)
        )
        (§ let Keyword existingk = existingRef.get())
        (§ if (ß existingk != nil)
            (§ return existingk)
        )
        ;; entry died in the interim, do over
        (ß table.remove(sym, existingRef))
        (ß intern(sym))
    )

    (§ defn Keyword intern(String ns, String name)
        (ß intern(Symbol.intern(ns, name)))
    )

    (§ defn Keyword intern(String nsname)
        (ß intern(Symbol.intern(nsname)))
    )

    (§ constructor- Keyword(Symbol sym)
        (ß this.sym = sym)
        (ß hasheq = sym.hasheq() + 0x9e3779b9)
        this
    )

    (§ defn Keyword find(Symbol sym)
        (§ let Reference<Keyword> ref = table.get(sym))
        (§ if (ß ref != nil)
            (ß ref.get())
        )
        (§ else 
            nil
        )
    )

    (§ defn Keyword find(String ns, String name)
        (ß find(Symbol.intern(ns, name)))
    )

    (§ defn Keyword find(String nsname)
        (ß find(Symbol.intern(nsname)))
    )

    (§ method int hashCode()
        (ß sym.hashCode() + 0x9e3779b9)
    )

    (§ method int hasheq()
        hasheq
    )

    (§ method String toString()
        (§ if (ß _str == nil)
            (ß _str = (":" + sym))
        )
        (ß _str)
    )

    (§ method Object throwArity()
        (§ throw new IllegalArgumentException("Wrong number of args passed to keyword: " + toString()))
    )

    (§ method Object call()
        (ß throwArity())
    )

    (§ method void run()
        (§ throw new UnsupportedOperationException())
    )

    (§ method Object invoke()
        (ß throwArity())
    )

    (§ method int compareTo(Object o)
        (ß sym.compareTo(((Keyword) o).sym))
    )

    (§ method String getNamespace()
        (ß sym.getNamespace())
    )

    (§ method String getName()
        (ß sym.getName())
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    (§ method Object invoke(Object obj)
        (§ if (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this)))
        )
        (ß RT.get(obj, this))
    )

    (§ method Object invoke(Object obj, Object notFound)
        (§ if (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this, notFound)))
        )
        (ß RT.get(obj, this, notFound))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß throwArity())
    )

    (§ method Object applyTo(ISeq arglist)
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (§ field Keyword k)

    (§ constructor KeywordLookupSite(Keyword k)
        (ß this.k = k)
        this
    )

    (§ method ILookupThunk fault(Object target)
        (§ if (ß target instanceof IKeywordLookup)
            (§ return (ß install(target)))
        )
        (§ elseif (ß target instanceof ILookup)
            (§ return (ß ilookupThunk(target.getClass())))
        )
        this
    )

    (§ method Object get(Object target)
        (§ if (ß target instanceof IKeywordLookup || target instanceof ILookup)
            (§ return this)
        )
        (ß RT.get(target, k))
    )

    (§ method- ILookupThunk ilookupThunk(Class c)
        (ß new ILookupThunk()
            (§ reify
                (§ method Object get(Object target)
                    (§ if (ß target != nil && target.getClass() == c)
                        (§ return (ß ((ILookup) target).valAt(k)))
                    )
                    this
                )
            )
        )
    )

    (§ method- ILookupThunk install(Object target)
        (§ let ILookupThunk t = ((IKeywordLookup)target).getLookupThunk(k))
        (§ if (ß t != nil)
            (§ return t)
        )
        (ß ilookupThunk(target.getClass()))
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(class-ns LazilyPersistentVector
    (§ defn IPersistentVector createOwning(Object... items)
        (§ if (ß items.length <= 32)
            (§ return (ß new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)))
        )
        (ß PersistentVector.create(items))
    )

    (§ defn int fcount(Object c)
        (§ if (ß c instanceof Counted)
            (§ return (ß ((Counted) c).count()))
        )
        (ß ((Collection)c).size())
    )

    (§ defn IPersistentVector create(Object obj)
        (§ if (ß obj instanceof IReduceInit)
            (ß PersistentVector.create((IReduceInit) obj))
        )
        (§ elseif (ß obj instanceof ISeq)
            (ß PersistentVector.create(RT.seq(obj)))
        )
        (§ elseif (ß obj instanceof Iterable)
            (ß PersistentVector.create((Iterable)obj))
        )
        (§ else 
            (ß createOwning(RT.toArray(obj)))
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (§ field- IFn fn)
    (§ field- Object sv)
    (§ field- ISeq s)

    (§ constructor LazySeq(IFn fn)
        (ß this.fn = fn)
        this
    )

    (§ constructor- LazySeq(IPersistentMap meta, ISeq s)
        (§ super(meta))
        (ß this.fn = nil)
        (ß this.s = s)
        this
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (ß new LazySeq(meta, seq()))
    )

    (§ method Object sval()
        (§ sync (ß this)
            (§ if (ß fn != nil)
                (ß sv = fn.invoke())
                (ß fn = nil)
            )
            (§ if (ß sv != nil)
                (§ return sv)
            )
            s
        )
    )

    (§ method ISeq seq()
        (§ sync (ß this)
            (ß sval())
            (§ if (ß sv != nil)
                (§ let Object ls = sv)
                (ß sv = nil)
                (§ while (ß ls instanceof LazySeq)
                    (ß ls = ((LazySeq)ls).sval())
                )
                (ß s = RT.seq(ls))
            )
            s
        )
    )

    (§ method int count()
        (§ let int c = 0)
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (ß ++c)
        )
        c
    )

    (§ method Object first()
        (ß seq())
        (§ if (ß s == nil)
            (§ return nil)
        )
        (ß s.first())
    )

    (§ method ISeq next()
        (ß seq())
        (§ if (ß s == nil)
            (§ return nil)
        )
        (ß s.next())
    )

    (§ method ISeq more()
        (ß seq())
        (§ if (ß s == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß s.more())
    )

    (§ method ISeq cons(Object o)
        (ß RT.cons(o, seq()))
    )

    (§ method IPersistentCollection empty()
        (ß PersistentList.EMPTY)
    )

    (§ method boolean equiv(Object o)
        (§ let ISeq s = seq())
        (§ if (ß s != nil)
            (ß s.equiv(o))
        )
        (§ else 
            (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
        )
    )

    (§ method int hashCode()
        (§ let ISeq s = seq())
        (§ if (ß s == nil)
            (§ return 1)
        )
        (ß Util.hash(s))
    )

    (§ method int hasheq()
        (ß Murmur3.hashOrdered(this))
    )

    (§ method boolean equals(Object o)
        (§ let ISeq s = seq())
        (§ if (ß s != nil)
            (ß s.equals(o))
        )
        (§ else 
            (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
        )
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean containsAll(Collection c)
        (§ doseq [#_"Object" o c]
            (§ if (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (seq() == nil))
    )

    (§ method boolean contains(Object o)
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (§ if (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method Iterator iterator()
        (ß new SeqIterator(this))
    )

    (§ method- List reify()
        (ß new ArrayList(this))
    )

    (§ method List subList(int fromIndex, int toIndex)
        (ß reify().subList(fromIndex, toIndex))
    )

    (§ method Object set(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    (§ method Object remove(int index)
        (§ throw new UnsupportedOperationException())
    )

    (§ method int indexOf(Object o)
        (§ let ISeq s = seq())
        (§ loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
            (§ if (ß Util.equiv(s.first(), o))
                (§ return i)
            )
        )
        -1
    )

    (§ method int lastIndexOf(Object o)
        (ß reify().lastIndexOf(o))
    )

    (§ method ListIterator listIterator()
        (ß reify().listIterator())
    )

    (§ method ListIterator listIterator(int index)
        (ß reify().listIterator(index))
    )

    (§ method Object get(int index)
        (ß RT.nth(this, index))
    )

    (§ method void add(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(int index, Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean isRealized()
        (§ sync (ß this)
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.

    (§ def- int newline = (int) \newline)

    (§ field- boolean _atLineStart = true)
    (§ field- boolean _prev)
    (§ field- int _columnNumber = 1)

    (§ constructor LineNumberingPushbackReader(Reader r)
        (§ super(new LineNumberReader(r)))
        this
    )

    (§ constructor LineNumberingPushbackReader(Reader r, int size)
        (§ super(new LineNumberReader(r, size)))
        this
    )

    (§ method int getLineNumber()
        (ß ((LineNumberReader) in).getLineNumber() + 1)
    )

    (§ method void setLineNumber(int line)
        (ß ((LineNumberReader) in).setLineNumber(line - 1))
        nil
    )

    (§ method int getColumnNumber()
        (ß _columnNumber)
    )

    (§ method int read() (§ throws IOException)
        (§ let int c = super.read())
        (ß _prev = _atLineStart)
        (§ if (ß (c == newline) || (c == -1))
            (ß _atLineStart = true)
            (ß _columnNumber = 1)
        )
        (§ else 
            (ß _atLineStart = false)
            (ß _columnNumber++)
        )
        c
    )

    (§ method void unread(int c) (§ throws IOException)
        (ß super.unread(c))
        (ß _atLineStart = _prev)
        (ß _columnNumber--)
        nil
    )

    (§ method String readLine() (§ throws IOException)
        (§ let int c = read())
        (§ let String line)
        (§ switch (ß c)
            (§ case -1)
            (do
                (ß line = nil)
                (§ break )
            )
            (§ case newline)
            (do
                (ß line = "")
                (§ break )
            )
            (§ default )
            (do
                (§ let String first = String.valueOf((char) c))
                (§ let String rest = ((LineNumberReader)in).readLine())
                (ß line = (rest == nil) ? first :or first + rest)
                (ß _prev = false)
                (ß _atLineStart = true)
                (ß _columnNumber = 1)
                (§ break )
            )
        )
        line
    )

    (§ method boolean atLineStart()
        (ß _atLineStart)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns LispReader
    (§ def Symbol QUOTE = Symbol.intern("quote"))
    (§ def Symbol THE_VAR = Symbol.intern("var"))

    (§ def Symbol UNQUOTE = Symbol.intern("cloiure.core", "unquote"))
    (§ def Symbol UNQUOTE_SPLICING = Symbol.intern("cloiure.core", "unquote-splicing"))
    (§ def Symbol CONCAT = Symbol.intern("cloiure.core", "concat"))
    (§ def Symbol SEQ = Symbol.intern("cloiure.core", "seq"))
    (§ def Symbol LIST = Symbol.intern("cloiure.core", "list"))
    (§ def Symbol APPLY = Symbol.intern("cloiure.core", "apply"))
    (§ def Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map"))
    (§ def Symbol HASHSET = Symbol.intern("cloiure.core", "hash-set"))
    (§ def Symbol VECTOR = Symbol.intern("cloiure.core", "vector"))
    (§ def Symbol WITH_META = Symbol.intern("cloiure.core", "with-meta"))
    (§ def Symbol META = Symbol.intern("cloiure.core", "meta"))
    (§ def Symbol DEREF = Symbol.intern("cloiure.core", "deref"))
    (§ def Symbol READ_COND = Symbol.intern("cloiure.core", "read-cond"))
    (§ def Symbol READ_COND_SPLICING = Symbol.intern("cloiure.core", "read-cond-splicing"))
    (§ def Keyword UNKNOWN = Keyword.intern(nil, "unknown"))

    (§ def IFn[] macros = new IFn[256])
    (§ def IFn[] dispatchMacros = new IFn[256])

    (§ def Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (§ def Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (§ def Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)"))
    (§ def Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def Var GENSYM_ENV = Var.create(nil).setDynamic())
    ;; sorted-map num->gensymbol
    (§ def Var ARG_ENV = Var.create(nil).setDynamic())
    (§ def IFn ctorReader = new CtorReader())

    ;; Dynamic var set to true in a read-cond context
    (§ def Var READ_COND_ENV = Var.create(nil).setDynamic())

    (§ static
        (ß macros[\"] = new StringReader()) ;; oops! "
        (ß macros[\;] = new CommentReader())
        (ß macros[\'] = new WrappingReader(QUOTE))
        (ß macros[\@] = new WrappingReader(DEREF))
        (ß macros[\^] = new MetaReader())
        (ß macros[\`] = new SyntaxQuoteReader())
        (ß macros[\~] = new UnquoteReader())
        (ß macros[\(] = new ListReader())
        (ß macros[\)] = new UnmatchedDelimiterReader())
        (ß macros[\[] = new VectorReader())
        (ß macros[\]] = new UnmatchedDelimiterReader())
        (ß macros[\{] = new MapReader())
        (ß macros[\}] = new UnmatchedDelimiterReader())
        (ß macros[\\] = new CharacterReader())
        (ß macros[\%] = new ArgReader())
        (ß macros[\#] = new DispatchReader())

        (ß dispatchMacros[\^] = new MetaReader())
        (ß dispatchMacros[\#] = new SymbolicValueReader())
        (ß dispatchMacros[\'] = new VarReader())
        (ß dispatchMacros[\"] = new RegexReader()) ;; oops! "
        (ß dispatchMacros[\(] = new FnReader())
        (ß dispatchMacros[\{] = new SetReader())
        (ß dispatchMacros[\=] = new EvalReader())
        (ß dispatchMacros[\!] = new CommentReader())
        (ß dispatchMacros[\<] = new UnreadableReader())
        (ß dispatchMacros[\_] = new DiscardReader())
        (ß dispatchMacros[\?] = new ConditionalReader())
        (ß dispatchMacros[\:] = new NamespaceMapReader())
    )

    (§ interface Resolver
        (§ abstract Symbol currentNS())
        (§ abstract Symbol resolveClass(Symbol sym))
        (§ abstract Symbol resolveAlias(Symbol sym))
        (§ abstract Symbol resolveVar(Symbol sym))
    )

    (§ defn boolean isWhitespace(int ch)
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn void unread(PushbackReader r, int ch)
        (§ if (ß ch != -1)
            (§ try 
                (ß r.unread(ch))
            )
            (§ catch (ß IOException e)
                (§ throw Util.sneakyThrow(e))
            )
        )
        nil
    )

    (class-ns ReaderException (§ extends RuntimeException)
        (§ field int line)
        (§ field int column)

        (§ constructor ReaderException(int line, int column, Throwable cause)
            (§ super(cause))
            (ß this.line = line)
            (ß this.column = column)
            this
        )
    )

    (§ defn int read1(Reader r)
        (§ try 
            (ß r.read())
        )
        (§ catch (ß IOException e)
            (§ throw Util.sneakyThrow(e))
        )
    )

    ;; Reader opts
    (§ def Keyword OPT_EOF = Keyword.intern(nil, "eof"))
    (§ def Keyword OPT_FEATURES = Keyword.intern(nil, "features"))
    (§ def Keyword OPT_READ_COND = Keyword.intern(nil, "read-cond"))

    ;; EOF special value to throw on eof
    (§ def Keyword EOFTHROW = Keyword.intern(nil, "eofthrow"))

    ;; Platform features - always installed
    (§ def- Keyword PLATFORM_KEY = Keyword.intern(nil, "cli"))
    (§ def- Object PLATFORM_FEATURES = PersistentHashSet.create(PLATFORM_KEY))

    ;; Reader conditional options - use with :read-cond
    (§ def Keyword COND_ALLOW = Keyword.intern(nil, "allow"))
    (§ def Keyword COND_PRESERVE = Keyword.intern(nil, "preserve"))

    (§ defn Object read(PushbackReader r, Object opts)
        (§ let boolean eofIsError = true)
        (§ let Object eofValue = nil)
        (§ if (ß opts != nil && opts instanceof IPersistentMap)
            (§ let Object eof = ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW))
            (§ if (ß !EOFTHROW.equals(eof))
                (ß eofIsError = false)
                (ß eofValue = eof)
            )
        )
        (ß read(r, eofIsError, eofValue, false, opts))
    )

    (§ defn Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive)
        (ß read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY))
    )

    (§ defn Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, nil, (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts, Object pendingForms)
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- Object ensurePending(Object pendingForms)
        (§ if (ß pendingForms == nil)
            (ß new LinkedList())
        )
        (§ else 
            pendingForms
        )
    )

    (§ defn- Object installPlatformFeature(Object opts)
        (§ if (ß opts == nil)
            (ß RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
        )
        (§ else 
            (§ let IPersistentMap mopts = (IPersistentMap) opts)
            (§ let Object features = mopts.valAt(OPT_FEATURES))
            (§ if (ß features == nil)
                (ß mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
            )
            (§ else 
                (ß mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY)))
            )
        )
    )

    (§ defn- Object read(PushbackReader r, boolean eofIsError, Object eofValue, Character returnOn, Object returnOnValue, boolean isRecursive, Object opts, Object pendingForms, Resolver resolver)
        (§ if (ß RT.READEVAL.deref() == UNKNOWN)
            (§ throw Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown"))
        )

        (ß opts = installPlatformFeature(opts))

        (§ try 
            (§ while true
                (§ if (ß pendingForms instanceof List && !((List)pendingForms).isEmpty())
                    (§ return (ß ((List)pendingForms).remove(0)))
                )

                (§ let int ch = read1(r))

                (§ while (ß isWhitespace(ch))
                    (ß ch = read1(r))
                )

                (§ if (ß ch == -1)
                    (§ if (ß eofIsError)
                        (§ throw Util.runtimeException("EOF while reading"))
                    )
                    (§ return eofValue)
                )

                (§ if (ß returnOn != nil && (returnOn.charValue() == ch))
                    (§ return returnOnValue)
                )

                (§ if (ß Character.isDigit(ch))
                    (§ let Object n = readNumber(r, (char) ch))
                    (§ return n)
                )

                (§ let IFn macroFn = getMacro(ch))
                (§ if (ß macroFn != nil)
                    (§ let Object ret = macroFn.invoke(r, (char) ch, opts, pendingForms))
                    ;; no op macros return the reader
                    (§ if (ß ret == r)
                        (§ continue )
                    )
                    (§ return ret)
                )

                (§ if (ß ch == \+ || ch == \-)
                    (§ let int ch2 = read1(r))
                    (§ if (ß Character.isDigit(ch2))
                        (ß unread(r, ch2))
                        (§ let Object n = readNumber(r, (char) ch))
                        (§ return n)
                    )
                    (ß unread(r, ch2))
                )

                (§ let String token = readToken(r, (char) ch))
                (§ return (ß interpretToken(token, resolver)))
            )
        )
        (§ catch (ß Exception e)
            (§ if (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                (§ throw Util.sneakyThrow(e))
            )
            (§ let LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r)
            (§ throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e))
        )
    )

    (§ defn- String readToken(PushbackReader r, char initch)
        (§ let StringBuilder sb = new StringBuilder())
        (ß sb.append(initch))

        (§ while true
            (§ let int ch = read1(r))
            (§ if (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                (ß unread(r, ch))
                (§ return (ß sb.toString()))
            )
            (ß sb.append((char) ch))
        )
    )

    (§ defn- Object readNumber(PushbackReader r, char initch)
        (§ let StringBuilder sb = new StringBuilder())
        (ß sb.append(initch))

        (§ while true
            (§ let int ch = read1(r))
            (§ if (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                (ß unread(r, ch))
                (§ break )
            )
            (ß sb.append((char) ch))
        )

        (§ let String s = sb.toString())
        (§ let Object n = matchNumber(s))
        (§ if (ß n == nil)
            (§ throw new NumberFormatException("Invalid number: " + s))
        )
        n
    )

    (§ defn- int readUnicodeChar(String token, int offset, int length, int base)
        (§ if (ß token.length() != offset + length)
            (§ throw new IllegalArgumentException("Invalid unicode character: \\" + token))
        )
        (§ let int uc = 0)
        (§ loop-when-recur [(ß int i = offset)] (ß i < offset + length) [(ß ++i)]
            (§ let int d = Character.digit(token.charAt(i), base))
            (§ if (ß d == -1)
                (§ throw new IllegalArgumentException("Invalid digit: " + token.charAt(i)))
            )
            (ß uc = uc * base + d)
        )
        (ß (char) uc)
    )

    (§ defn- int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
        (§ let int uc = Character.digit(initch, base))
        (§ if (ß uc == -1)
            (§ throw new IllegalArgumentException("Invalid digit: " + (char) initch))
        )
        (§ let int i = 1)
        (§ loop-when-recur [(ß )] (ß i < length) [(ß ++i)]
            (§ let int ch = read1(r))
            (§ if (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                (ß unread(r, ch))
                (§ break )
            )
            (§ let int d = Character.digit(ch, base))
            (§ if (ß d == -1)
                (§ throw new IllegalArgumentException("Invalid digit: " + (char) ch))
            )
            (ß uc = uc * base + d)
        )
        (§ if (ß i != length && exact)
            (§ throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length))
        )
        uc
    )

    (§ defn- Object interpretToken(String s, Resolver resolver)
        (§ if (ß s.equals("nil"))
            (§ return nil)
        )
        (§ elseif (ß s.equals("true"))
            (§ return (ß RT.T))
        )
        (§ elseif (ß s.equals("false"))
            (§ return (ß RT.F))
        )
        (§ let Object ret = nil)

        (ß ret = matchSymbol(s, resolver))
        (§ if (ß ret != nil)
            (§ return ret)
        )

        (§ throw Util.runtimeException("Invalid token: " + s))
    )

    (§ defn- Object matchSymbol(String s, Resolver resolver)
        (§ let Matcher m = symbolPat.matcher(s))
        (§ if (ß m.matches())
            (§ let int gc = m.groupCount())
            (§ let String ns = m.group(1))
            (§ let String name = m.group(2))
            (§ if (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                (§ return nil)
            )
            (§ if (ß s.startsWith("::"))
                (§ let Symbol ks = Symbol.intern(s.substring(2)))
                (§ if (ß resolver != nil)
                    (§ let Symbol nsym)
                    (§ if (ß ks.ns != nil)
                        (ß nsym = resolver.resolveAlias(Symbol.intern(ks.ns)))
                    )
                    (§ else 
                        (ß nsym = resolver.currentNS())
                    )
                    ;; auto-resolving keyword
                    (§ if (ß nsym != nil)
                        (§ return (ß Keyword.intern(nsym.name, ks.name)))
                    )
                    (§ else 
                        (§ return nil)
                    )
                )
                (§ else 
                    (§ let Namespace kns)
                    (§ if (ß ks.ns != nil)
                        (ß kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns)))
                    )
                    (§ else 
                        (ß kns = Compiler.currentNS())
                    )
                    ;; auto-resolving keyword
                    (§ if (ß kns != nil)
                        (§ return (ß Keyword.intern(kns.name.name, ks.name)))
                    )
                    (§ else 
                        (§ return nil)
                    )
                )
            )
            (§ let boolean isKeyword = (s.charAt(0) == \:))
            (§ let Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0)))
            (§ if (ß isKeyword)
                (§ return (ß Keyword.intern(sym)))
            )
            (§ return sym)
        )
        nil
    )

    (§ defn- Object matchNumber(String s)
        (§ let Matcher m = intPat.matcher(s))
        (§ if (ß m.matches())
            (§ if (ß m.group(2) != nil)
                (§ if (ß m.group(8) != nil)
                    (§ return (ß BigInt.ZERO))
                )
                (§ return (ß Numbers.num(0)))
            )
            (§ let boolean negate = m.group(1).equals("-"))
            (§ let String n)
            (§ let int radix = 10)
            (§ if (ß (n = m.group(3)) != nil)
                (ß radix = 10)
            )
            (§ elseif (ß (n = m.group(4)) != nil)
                (ß radix = 16)
            )
            (§ elseif (ß (n = m.group(5)) != nil)
                (ß radix = 8)
            )
            (§ elseif (ß (n = m.group(7)) != nil)
                (ß radix = Integer.parseInt(m.group(6)))
            )
            (§ if (ß n == nil)
                (§ return nil)
            )
            (§ let BigInteger bn = new BigInteger(n, radix))
            (§ if (ß negate)
                (ß bn = bn.negate())
            )
            (§ if (ß m.group(8) != nil)
                (§ return (ß BigInt.fromBigInteger(bn)))
            )
            (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
        )
        (ß m = floatPat.matcher(s))
        (§ if (ß m.matches())
            (§ if (ß m.group(4) != nil)
                (§ return (ß new BigDecimal(m.group(1))))
            )
            (§ return (ß Double.parseDouble(s)))
        )
        (ß m = ratioPat.matcher(s))
        (§ if (ß m.matches())
            (§ let String numerator = m.group(1))
            (§ if (ß numerator.startsWith("+"))
                (ß numerator = numerator.substring(1))
            )
            (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
        )
        nil
    )

    (§ defn- IFn getMacro(int ch)
        (§ if (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- boolean isMacro(int ch)
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- boolean isTerminatingMacro(int ch)
        (ß (ch != \# && ch != \' && ch != \% && isMacro(ch)))
    )

    (class-ns RegexReader (§ extends AFn)
        (§ def StringReader stringrdr = new StringReader())

        (§ method Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
            (§ let StringBuilder sb = new StringBuilder())
            (§ let Reader r = (Reader) reader)
            (§ loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                (§ if (ß ch == -1)
                    (§ throw Util.runtimeException("EOF while reading regex"))
                )
                (ß sb.append((char) ch))
                (§ if (ß ch == \\) ;; escape
                    (ß ch = read1(r))
                    (§ if (ß ch == -1)
                        (§ throw Util.runtimeException("EOF while reading regex"))
                    )
                    (ß sb.append((char) ch))
                )
            )
            (ß Pattern.compile(sb.toString()))
        )
    )

    (class-ns StringReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
            (§ let StringBuilder sb = new StringBuilder())
            (§ let Reader r = (Reader) reader)

            (§ loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                (§ if (ß ch == -1)
                    (§ throw Util.runtimeException("EOF while reading string"))
                )
                (§ if (ß ch == \\) ;; escape
                    (ß ch = read1(r))
                    (§ if (ß ch == -1)
                        (§ throw Util.runtimeException("EOF while reading string"))
                    )
                    (§ switch (ß ch)
                        (§ case \t)
                        (do
                            (ß ch = \tab)
                            (§ break )
                        )
                        (§ case \r)
                        (do
                            (ß ch = \return)
                            (§ break )
                        )
                        (§ case \n)
                        (do
                            (ß ch = \newline)
                            (§ break )
                        )
                        (§ case \\)
                        (do
                            (§ break )
                        )
                        (§ case \") ;; oops! "
                        (do
                            (§ break )
                        )
                        (§ case \b)
                        (do
                            (ß ch = \backspace)
                            (§ break )
                        )
                        (§ case \f)
                        (do
                            (ß ch = \formfeed)
                            (§ break )
                        )
                        (§ case \u)
                        (do
                            (ß ch = read1(r))
                            (§ if (ß Character.digit(ch, 16) == -1)
                                (§ throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch))
                            )
                            (ß ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (§ if (ß Character.isDigit(ch))
                                (ß ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                (§ if (ß ch > 0377)
                                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                                )
                            )
                            (§ else 
                                (§ throw Util.runtimeException("Unsupported escape character: \\" + (char) ch))
                            )
                            (§ break )
                        )
                    )
                )
                (ß sb.append((char) ch))
            )
            (ß sb.toString())
        )
    )

    (class-ns CommentReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object semicolon, Object opts, Object pendingForms)
            (§ let Reader r = (Reader) reader)
            (§ let int ch)
            (§ loop
                (ß ch = read1(r))
                (§ recur-if (ch != -1 && ch != \newline && ch != \return))
            )
            r
        )
    )

    (class-ns DiscardReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object underscore, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))
            r
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    (class-ns NamespaceMapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object colon, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)

            (§ let boolean auto = false)
            (§ let int autoChar = read1(r))
            (§ if (ß autoChar == \:)
                (ß auto = true)
            )
            (§ else 
                (ß unread(r, autoChar))
            )

            (§ let Object sym = nil)
            (§ let int nextChar = read1(r))
            (§ if (ß isWhitespace(nextChar)) ;; the #:: { } case or an error
                (§ if (ß auto)
                    (§ while (ß isWhitespace(nextChar))
                        (ß nextChar = read1(r))
                    )
                    (§ if (ß nextChar != \{)
                        (ß unread(r, nextChar))
                        (§ throw Util.runtimeException("Namespaced map must specify a namespace"))
                    )
                )
                (§ else 
                    (ß unread(r, nextChar))
                    (§ throw Util.runtimeException("Namespaced map must specify a namespace"))
                )
            )
            (§ elseif (ß nextChar != \{) ;; #:foo { } or #::foo { }
                (ß unread(r, nextChar))
                (ß sym = read(r, true, nil, false, opts, pendingForms))
                (ß nextChar = read1(r))
                (§ while (ß isWhitespace(nextChar))
                    (ß nextChar = read1(r))
                )
            )
            (§ if (ß nextChar != \{)
                (§ throw Util.runtimeException("Namespaced map must specify a map"))
            )

            ;; Resolve autoresolved ns
            (§ let String ns)
            (§ if (ß auto)
                (§ let Resolver resolver = (Resolver) RT.READER_RESOLVER.deref())
                (§ if (ß sym == nil)
                    (§ if (ß resolver != nil)
                        (ß ns = resolver.currentNS().name)
                    )
                    (§ else 
                        (ß ns = Compiler.currentNS().getName().getName())
                    )
                )
                (§ elseif (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                    (§ throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym))
                )
                (§ else 
                    (§ let Symbol resolvedNS)
                    (§ if (ß resolver != nil)
                        (ß resolvedNS = resolver.resolveAlias((Symbol) sym))
                    )
                    (§ else 
                        (§ let Namespace rns = Compiler.currentNS().lookupAlias((Symbol)sym))
                        (ß resolvedNS = (rns != nil) ? rns.getName() :or nil)
                    )

                    (§ if (ß resolvedNS == nil)
                        (§ throw Util.runtimeException("Unknown auto-resolved namespace alias: " + sym))
                    )
                    (§ else 
                        (ß ns = resolvedNS.getName())
                    )
                )
            )
            (§ elseif (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                (§ throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym))
            )
            (§ else 
                (ß ns = ((Symbol)sym).getName())
            )

            ;; Read map
            (§ let List kvs = readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))
            (§ if (ß (kvs.size() & 1) == 1)
                (§ throw Util.runtimeException("Namespaced map literal must contain an even number of forms"))
            )

            ;; Construct output map
            (§ let Object[] a = new Object[kvs.size()])
            (§ let Iterator iter = kvs.iterator())
            (§ loop-when-recur [(ß int i = 0)] (ß iter.hasNext()) [(ß i += 2)]
                (§ let Object key = iter.next())
                (§ let Object val = iter.next())

                (§ if (ß key instanceof Keyword)
                    (§ let Keyword kw = (Keyword) key)
                    (§ if (ß kw.getNamespace() == nil)
                        (ß key = Keyword.intern(ns, kw.getName()))
                    )
                    (§ elseif (ß kw.getNamespace().equals("_"))
                        (ß key = Keyword.intern(nil, kw.getName()))
                    )
                )
                (§ elseif (ß key instanceof Symbol)
                    (§ let Symbol s = (Symbol) key)
                    (§ if (ß s.getNamespace() == nil)
                        (ß key = Symbol.intern(ns, s.getName()))
                    )
                    (§ elseif (ß s.getNamespace().equals("_"))
                        (ß key = Symbol.intern(nil, s.getName()))
                    )
                )
                (ß a[i] = key)
                (ß a[i + 1] = val)
            )
            (ß RT.map(a))
        )
    )

    (class-ns SymbolicValueReader (§ extends AFn)
        (§ def IPersistentMap  specials = PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        ))

        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))

            (§ if (ß !(o instanceof Symbol))
                (§ throw Util.runtimeException("Invalid token: ##" + o))
            )
            (§ if (ß !(specials.containsKey(o)))
                (§ throw Util.runtimeException("Unknown symbolic value: ##" + o))
            )

            (ß specials.valAt(o))
        )
    )

    (class-ns WrappingReader (§ extends AFn)
        (§ field Symbol sym)

        (§ constructor WrappingReader(Symbol sym)
            (ß this.sym = sym)
            this
        )

        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (ß RT.list(sym, o))
        )
    )

    (class-ns DeprecatedWrappingReader (§ extends AFn)
        (§ field Symbol sym)
        (§ field String macro)

        (§ constructor DeprecatedWrappingReader(Symbol sym, String macro)
            (ß this.sym = sym)
            (ß this.macro = macro)
            this
        )

        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (ß System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead"))
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (ß RT.list(sym, o))
        )
    )

    (class-ns VarReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (ß RT.list(THE_VAR, o))
        )
    )

    (class-ns DispatchReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object hash, Object opts, Object pendingForms)
            (§ let int ch = read1((Reader) reader))
            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let IFn fn = dispatchMacros[ch])

            ;; Try the ctor reader first
            (§ if (ß fn == nil)
                (ß unread((PushbackReader) reader, ch))
                (ß pendingForms = ensurePending(pendingForms))
                (§ let Object result = ctorReader.invoke(reader, ch, opts, pendingForms))

                (§ if (ß result != nil)
                    (§ return result)
                )
                (§ else 
                    (§ throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch)))
                )
            )
            (ß fn.invoke(reader, ch, opts, pendingForms))
        )
    )

    (§ defn Symbol garg(int n)
        (ß Symbol.intern(nil, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#"))
    )

    (class-ns FnReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object lparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ if (ß ARG_ENV.deref() != nil)
                (§ throw new IllegalStateException("Nested #()s are not allowed"))
            )
            (§ try 
                (ß Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY)))
                (ß unread(r, \())
                (§ let Object form = read(r, true, nil, true, opts, ensurePending(pendingForms)))

                (§ let PersistentVector args = PersistentVector.EMPTY)
                (§ let PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref())
                (§ let ISeq rargs = argsyms.rseq())
                (§ if (ß rargs != nil)
                    (§ let int higharg = (Integer) ((Map.Entry) rargs.first()).getKey())
                    (§ if (ß higharg > 0)
                        (§ loop-when-recur [(ß int i = 1)] (ß i <= higharg) [(ß ++i)]
                            (§ let Object sym = argsyms.valAt(i))
                            (§ if (ß sym == nil)
                                (ß sym = garg(i))
                            )
                            (ß args = args.cons(sym))
                        )
                    )
                    (§ let Object restsym = argsyms.valAt(-1))
                    (§ if (ß restsym != nil)
                        (ß args = args.cons(Compiler._AMP_))
                        (ß args = args.cons(restsym))
                    )
                )
                (ß RT.list(Compiler.FN, args, form))
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )
    )

    (§ defn Symbol registerArg(int n)
        (§ let PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref())
        (§ if (ß argsyms == nil)
            (§ throw new IllegalStateException("arg literal not in #()"))
        )
        (§ let Symbol ret = (Symbol) argsyms.valAt(n))
        (§ if (ß ret == nil)
            (ß ret = garg(n))
            (ß ARG_ENV.set(argsyms.assoc(n, ret)))
        )
        ret
    )

    (class-ns ArgReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object pct, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ if (ß ARG_ENV.deref() == nil)
                (§ return (ß interpretToken(readToken(r, \%), nil)))
            )
            (§ let int ch = read1(r))
            (ß unread(r, ch))
            ;; % alone is first arg
            (§ if (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                (§ return (ß registerArg(1)))
            )
            (§ let Object n = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ if (ß n.equals(Compiler._AMP_))
                (§ return (ß registerArg(-1)))
            )
            (§ if (ß !(n instanceof Number))
                (§ throw new IllegalStateException("arg literal must be %, %& or %integer"))
            )
            (ß registerArg(((Number) n).intValue()))
        )
    )

    (class-ns MetaReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object caret, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (ß r instanceof LineNumberingPushbackReader)
                (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (ß pendingForms = ensurePending(pendingForms))
            (§ let Object meta = read(r, true, nil, true, opts, pendingForms))
            (§ if (ß meta instanceof Symbol || meta instanceof String)
                (ß meta = RT.map(RT.TAG_KEY, meta))
            )
            (§ elseif (ß meta instanceof Keyword)
                (ß meta = RT.map(meta, RT.T))
            )
            (§ elseif (ß !(meta instanceof IPersistentMap))
                (§ throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map"))
            )

            (§ let Object o = read(r, true, nil, true, opts, pendingForms))
            (§ if (ß o instanceof IMeta)
                (§ if (ß line != -1 && o instanceof ISeq)
                    (ß meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                )
                (§ if (ß o instanceof IReference)
                    (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                    (§ return o)
                )
                (§ let Object ometa = RT.meta(o))
                (§ loop-when-recur [(ß ISeq s = RT.seq(meta))] (ß s != nil) [(ß s = s.next())]
                    (§ let IMapEntry kv = (IMapEntry) s.first())
                    (ß ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                )
                (ß ((IObj) o).withMeta((IPersistentMap) ometa))
            )
            (§ else 
                (§ throw new IllegalArgumentException("Metadata can only be applied to IMetas"))
            )
        )
    )

    (class-ns SyntaxQuoteReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object backquote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ try 
                (ß Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY)))

                (§ let Object form = read(r, true, nil, true, opts, ensurePending(pendingForms)))
                (ß syntaxQuote(form))
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )

        (§ defn Object syntaxQuote(Object form)
            (§ let Object ret)
            (§ if (ß Compiler.isSpecial(form))
                (ß ret = RT.list(Compiler.QUOTE, form))
            )
            (§ elseif (ß form instanceof Symbol)
                (§ let Resolver resolver = (Resolver) RT.READER_RESOLVER.deref())
                (§ let Symbol sym = (Symbol) form)
                (§ if (ß sym.ns == nil && sym.name.endsWith("#"))
                    (§ let IPersistentMap gmap = (IPersistentMap) GENSYM_ENV.deref())
                    (§ if (ß gmap == nil)
                        (§ throw new IllegalStateException("Gensym literal not in syntax-quote"))
                    )
                    (§ let Symbol gs = (Symbol) gmap.valAt(sym))
                    (§ if (ß gs == nil)
                        (ß GENSYM_ENV.set(gmap.assoc(sym, gs = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__"))))
                    )
                    (ß sym = gs)
                )
                (§ elseif (ß sym.ns == nil && sym.name.endsWith("."))
                    (§ let Symbol csym = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1)))
                    (§ if (ß resolver != nil)
                        (§ let Symbol rc = resolver.resolveClass(csym))
                        (§ if (ß rc != nil)
                            (ß csym = rc)
                        )
                    )
                    (§ else 
                        (ß csym = Compiler.resolveSymbol(csym))
                    )
                    (ß sym = Symbol.intern(nil, csym.name.concat(".")))
                )
                (§ elseif (ß sym.ns == nil && sym.name.startsWith("."))
                    ;; Simply quote method names.
                )
                (§ elseif (ß resolver != nil)
                    (§ let Symbol nsym = nil)
                    (§ if (ß sym.ns != nil)
                        (§ let Symbol alias = Symbol.intern(nil, sym.ns))
                        (ß nsym = resolver.resolveClass(alias))
                        (§ if (ß nsym == nil)
                            (ß nsym = resolver.resolveAlias(alias))
                        )
                    )
                    (§ if (ß nsym != nil)
                        ;; Classname/foo -> package.qualified.Classname/foo
                        (ß sym = Symbol.intern(nsym.name, sym.name))
                    )
                    (§ elseif (ß sym.ns == nil)
                        (§ let Symbol rsym = resolver.resolveClass(sym))
                        (§ if (ß rsym == nil)
                            (ß rsym = resolver.resolveVar(sym))
                        )
                        (§ if (ß rsym != nil)
                            (ß sym = rsym)
                        )
                        (§ else 
                            (ß sym = Symbol.intern(resolver.currentNS().name, sym.name))
                        )
                    )
                    ;; leave alone if qualified
                )
                (§ else 
                    (§ let Object maybeClass = nil)
                    (§ if (ß sym.ns != nil)
                        (ß maybeClass = Compiler.currentNS().getMapping(Symbol.intern(nil, sym.ns)))
                    )
                    (§ if (ß maybeClass instanceof Class)
                        ;; Classname/foo -> package.qualified.Classname/foo
                        (ß sym = Symbol.intern(((Class)maybeClass).getName(), sym.name))
                    )
                    (§ else 
                        (ß sym = Compiler.resolveSymbol(sym))
                    )
                )
                (ß ret = RT.list(Compiler.QUOTE, sym))
            )
            (§ elseif (ß isUnquote(form))
                (§ return (ß RT.second(form)))
            )
            (§ elseif (ß isUnquoteSplicing(form))
                (§ throw new IllegalStateException("splice not in list"))
            )
            (§ elseif (ß form instanceof IPersistentCollection)
                (§ if (ß form instanceof IRecord)
                    (ß ret = form)
                )
                (§ elseif (ß form instanceof IPersistentMap)
                    (§ let IPersistentVector keyvals = flattenMap(form))
                    (ß ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq())))))
                )
                (§ elseif (ß form instanceof IPersistentVector)
                    (ß ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq())))))
                )
                (§ elseif (ß form instanceof IPersistentSet)
                    (ß ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq())))))
                )
                (§ elseif (ß form instanceof ISeq || form instanceof IPersistentList)
                    (§ let ISeq seq = RT.seq(form))
                    (§ if (ß seq == nil)
                        (ß ret = RT.cons(LIST, nil))
                    )
                    (§ else 
                        (ß ret = RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq))))
                    )
                )
                (§ else 
                    (§ throw new UnsupportedOperationException("Unknown Collection type"))
                )
            )
            (§ elseif (ß form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String)
                (ß ret = form)
            )
            (§ else 
                (ß ret = RT.list(Compiler.QUOTE, form))
            )

            (§ if (ß form instanceof IObj && RT.meta(form) != nil)
                ;; filter line and column numbers
                (§ let IPersistentMap newMeta = ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY))
                (§ if (ß newMeta.count() > 0)
                    (§ return (ß RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))))
                )
            )
            ret
        )

        (§ defn- ISeq sqExpandList(ISeq seq)
            (§ let PersistentVector ret = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß )] (ß seq != nil) [(ß seq = seq.next())]
                (§ let Object item = seq.first())
                (§ if (ß isUnquote(item))
                    (ß ret = ret.cons(RT.list(LIST, RT.second(item))))
                )
                (§ elseif (ß isUnquoteSplicing(item))
                    (ß ret = ret.cons(RT.second(item)))
                )
                (§ else 
                    (ß ret = ret.cons(RT.list(LIST, syntaxQuote(item))))
                )
            )
            (ß ret.seq())
        )

        (§ defn- IPersistentVector flattenMap(Object form)
            (§ let IPersistentVector keyvals = PersistentVector.EMPTY)
            (§ loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                (§ let IMapEntry e = (IMapEntry) s.first())
                (ß keyvals = (IPersistentVector) keyvals.cons(e.key()))
                (ß keyvals = (IPersistentVector) keyvals.cons(e.val()))
            )
            keyvals
        )
    )

    (§ defn boolean isUnquoteSplicing(Object form)
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING))
    )

    (§ defn boolean isUnquote(Object form)
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE))
    )

    (class-ns UnquoteReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object comma, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (ß pendingForms = ensurePending(pendingForms))
            (§ if (ß ch == \@)
                (§ let Object o = read(r, true, nil, true, opts, pendingForms))
                (ß RT.list(UNQUOTE_SPLICING, o))
            )
            (§ else 
                (ß unread(r, ch))
                (§ let Object o = read(r, true, nil, true, opts, pendingForms))
                (ß RT.list(UNQUOTE, o))
            )
        )
    )

    (class-ns CharacterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object backslash, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let String token = readToken(r, (char) ch))
            (§ if (ß token.length() == 1)
                (§ return (ß Character.valueOf(token.charAt(0))))
            )
            (§ elseif (ß token.equals("newline"))
                (§ return (ß \newline))
            )
            (§ elseif (ß token.equals("space"))
                (§ return (ß \space))
            )
            (§ elseif (ß token.equals("tab"))
                (§ return (ß \tab))
            )
            (§ elseif (ß token.equals("backspace"))
                (§ return (ß \backspace))
            )
            (§ elseif (ß token.equals("formfeed"))
                (§ return (ß \formfeed))
            )
            (§ elseif (ß token.equals("return"))
                (§ return (ß \return))
            )
            (§ elseif (ß token.startsWith("u"))
                (§ let char c = (char) readUnicodeChar(token, 1, 4, 16))
                (§ if (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                    (§ throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16)))
                )
                (§ return c)
            )
            (§ elseif (ß token.startsWith("o"))
                (§ let int len = token.length() - 1)
                (§ if (ß len > 3)
                    (§ throw Util.runtimeException("Invalid octal escape sequence length: " + len))
                )
                (§ let int uc = readUnicodeChar(token, 1, len, 8))
                (§ if (ß uc > 0377)
                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                )
                (§ return (ß (char) uc))
            )
            (§ throw Util.runtimeException("Unsupported character: \\" + token))
        )
    )

    (class-ns ListReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (ß r instanceof LineNumberingPushbackReader)
                (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ let List list = readDelimitedList(\), r, true, opts, ensurePending(pendingForms)))
            (§ if (ß list.isEmpty())
                (§ return (ß PersistentList.EMPTY))
            )
            (§ let IObj s = (IObj) PersistentList.create(list))
            (§ if (ß line != -1)
                (ß s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column)))
            )
            (§ else 
                s
            )
        )
    )

    (class-ns EvalReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object eq, Object opts, Object pendingForms)
            (§ if (ß !RT.booleanCast(RT.READEVAL.deref()))
                (§ throw Util.runtimeException("EvalReader not allowed when *read-eval* is false."))
            )

            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ if (ß o instanceof Symbol)
                (ß RT.classForName(o.toString()))
            )
            (§ elseif (ß o instanceof IPersistentList)
                (§ let Symbol fs = (Symbol) RT.first(o))
                (§ if (ß fs.equals(THE_VAR))
                    (§ let Symbol vs = (Symbol) RT.second(o))
                    (§ return (ß RT.var(vs.ns, vs.name)))
                )
                (§ if (ß fs.name.endsWith("."))
                    (§ let Object[] args = RT.toArray(RT.next(o)))
                    (§ return (ß Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)))
                )
                (§ if (ß Compiler.namesStaticMember(fs))
                    (§ let Object[] args = RT.toArray(RT.next(o)))
                    (§ return (ß Reflector.invokeStaticMethod(fs.ns, fs.name, args)))
                )
                (§ let Object v = Compiler.maybeResolveIn(Compiler.currentNS(), fs))
                (§ if (ß v instanceof Var)
                    (§ return (ß ((IFn) v).applyTo(RT.next(o))))
                )
                (§ throw Util.runtimeException("Can't resolve " + fs))
            )
            (§ else 
                (§ throw new IllegalArgumentException("Unsupported #= form"))
            )
        )
    )

    (class-ns VectorReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts, ensurePending(pendingForms))))
        )
    )

    (class-ns MapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object[] a = readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)).toArray())
            (§ if (ß (a.length & 1) == 1)
                (§ throw Util.runtimeException("Map literal must contain an even number of forms"))
            )
            (ß RT.map(a))
        )
    )

    (class-ns SetReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftbracket, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts, ensurePending(pendingForms))))
        )
    )

    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object rightdelim, Object opts, Object pendingForms)
            (§ throw Util.runtimeException("Unmatched delimiter: " + rightdelim))
        )
    )

    (class-ns UnreadableReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftangle, Object opts, Object pendingForms)
            (§ throw Util.runtimeException("Unreadable form"))
        )
    )

    ;; Sentinel values for reading lists
    (§ def- Object READ_EOF = new Object())
    (§ def- Object READ_FINISHED = new Object())

    (§ defn List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts, Object pendingForms)
        (§ let int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)

        (§ let ArrayList a = new ArrayList())
        (§ let Resolver resolver = (Resolver) RT.READER_RESOLVER.deref())

        (§ while true
            (§ let Object form = read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver))

            (§ if (ß form == READ_EOF)
                (§ if (ß firstline < 0)
                    (§ throw Util.runtimeException("EOF while reading"))
                )
                (§ else 
                    (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                )
            )
            (§ elseif (ß form == READ_FINISHED)
                (§ return a)
            )

            (ß a.add(form))
        )
    )

    (class-ns CtorReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object firstChar, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (ß pendingForms = ensurePending(pendingForms))
            (§ let Object name = read(r, true, nil, false, opts, pendingForms))
            (§ if (ß !(name instanceof Symbol))
                (§ throw new RuntimeException("Reader tag must be a symbol"))
            )
            (§ let Symbol sym = (Symbol)name)
            (§ let Object form = read(r, true, nil, true, opts, pendingForms))

            (§ if (ß isPreserveReadCond(opts) || RT.suppressRead())
                (ß TaggedLiteral.create(sym, form))
            )
            (§ else 
                (ß sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms))
            )
        )

        (§ method- Object readTagged(Object o, Symbol tag, Object opts, Object pendingForms)
            (§ let ILookup data_readers = (ILookup)RT.DATA_READERS.deref())
            (§ let IFn data_reader = (IFn)RT.get(data_readers, tag))
            (§ if (ß data_reader == nil)
                (ß data_readers = (ILookup)RT.DEFAULT_DATA_READERS.deref())
                (ß data_reader = (IFn)RT.get(data_readers, tag))
                (§ if (ß data_reader == nil)
                    (§ let IFn default_reader = (IFn)RT.DEFAULT_DATA_READER_FN.deref())
                    (§ if (ß default_reader != nil)
                        (§ return (ß default_reader.invoke(tag, o)))
                    )
                    (§ else 
                        (§ throw new RuntimeException("No reader function for tag " + tag.toString()))
                    )
                )
            )

            (ß data_reader.invoke(o))
        )

        (§ method- Object readRecord(Object form, Symbol recordName, Object opts, Object pendingForms)
            (§ let boolean readeval = RT.booleanCast(RT.READEVAL.deref()))

            (§ if (ß !readeval)
                (§ throw Util.runtimeException("Record construction syntax can only be used when *read-eval* == true"))
            )

            (§ let Class recordClass = RT.classForNameNonLoading(recordName.toString()))

            (§ let boolean shortForm = true)

            (§ if (ß form instanceof IPersistentMap)
                (ß shortForm = false)
            )
            (§ elseif (ß form instanceof IPersistentVector)
                (ß shortForm = true)
            )
            (§ else 
                (§ throw Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\""))
            )

            (§ let Object ret = nil)
            (§ let Constructor[] allctors = ((Class)recordClass).getConstructors())

            (§ if (ß shortForm)
                (§ let IPersistentVector recordEntries = (IPersistentVector)form)
                (§ let boolean ctorFound = false)
                (§ doseq [#_"Constructor" ctor allctors]
                    (§ if (ß ctor.getParameterTypes().length == recordEntries.count())
                        (ß ctorFound = true)
                    )
                )

                (§ if (ß !ctorFound)
                    (§ throw Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count()))
                )

                (ß ret = Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries)))
            )
            (§ else 
                (§ let IPersistentMap vals = (IPersistentMap)form)
                (§ loop-when-recur [(ß ISeq s = RT.keys(vals))] (ß s != nil) [(ß s = s.next())]
                    (§ if (ß !(s.first() instanceof Keyword))
                        (§ throw Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString()))
                    )
                )
                (ß ret = Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ vals )))
            )

            ret
        )
    )

    (§ defn boolean isPreserveReadCond(Object opts)
        (§ if (ß RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap)
            (§ let Object readCond = ((IPersistentMap) opts).valAt(OPT_READ_COND))
            (ß COND_PRESERVE.equals(readCond))
        )
        (§ else 
            false
        )
    )

    (class-ns ConditionalReader (§ extends AFn)
        (§ def- Object READ_STARTED = new Object())
        (§ def Keyword DEFAULT_FEATURE = Keyword.intern(nil, "default"))
        (§ def IPersistentSet RESERVED_FEATURES = RT.set(Keyword.intern(nil, "else"), Keyword.intern(nil, "none")))

        (§ defn boolean hasFeature(Object feature, Object opts)
            (§ if (ß !(feature instanceof Keyword))
                (§ throw Util.runtimeException("Feature should be a keyword: " + feature))
            )

            (§ if (ß DEFAULT_FEATURE.equals(feature))
                (§ return true)
            )

            (§ let IPersistentSet custom = (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES))
            (ß (custom != nil && custom.contains(feature)))
        )

        (§ defn Object readCondDelimited(PushbackReader r, boolean splicing, Object opts, Object pendingForms)
            (§ let Object result = READ_STARTED)
            (§ let Object form) ;; The most recently ready form
            (§ let boolean toplevel = (pendingForms == nil))
            (ß pendingForms = ensurePending(pendingForms))

            (§ let int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)

            (§ while true
                (§ if (ß result == READ_STARTED)
                    ;; Read the next feature
                    (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, nil))

                    (§ if (ß form == READ_EOF)
                        (§ if (ß firstline < 0)
                            (§ throw Util.runtimeException("EOF while reading"))
                        )
                        (§ else 
                            (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                        )
                    )
                    (§ elseif (ß form == READ_FINISHED)
                        (§ break ) ;; read-cond form is done
                    )

                    (§ if (ß RESERVED_FEATURES.contains(form))
                        (§ throw Util.runtimeException("Feature name " + form + " is reserved."))
                    )

                    (§ if (ß hasFeature(form, opts))
                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                        (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                        (§ if (ß form == READ_EOF)
                            (§ if (ß firstline < 0)
                                (§ throw Util.runtimeException("EOF while reading"))
                            )
                            (§ else 
                                (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                            )
                        )
                        (§ elseif (ß form == READ_FINISHED)
                            (§ if (ß firstline < 0)
                                (§ throw Util.runtimeException("read-cond requires an even number of forms."))
                            )
                            (§ else 
                                (§ throw Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms"))
                            )
                        )
                        (§ else 
                            (ß result = form)
                        )
                    )
                )

                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                (§ try 
                    (ß Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T)))
                    (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                    (§ if (ß form == READ_EOF)
                        (§ if (ß firstline < 0)
                            (§ throw Util.runtimeException("EOF while reading"))
                        )
                        (§ else 
                            (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                        )
                    )
                    (§ elseif (ß form == READ_FINISHED)
                        (§ break )
                    )
                )
                (§ finally 
                    (ß Var.popThreadBindings())
                )
            )

            (§ if (ß result == READ_STARTED) ;; no features matched
                (§ return r)
            )

            (§ if (ß splicing)
                (§ if (ß !(result instanceof List))
                    (§ throw Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List"))
                )

                (§ if (ß toplevel)
                    (§ throw Util.runtimeException("Reader conditional splicing not allowed at the top level."))
                )

                (ß ((List)pendingForms).addAll(0, (List)result))

                r
            )
            (§ else 
                result
            )
        )

        (§ defn- void checkConditionalAllowed(Object opts)
            (§ let IPersistentMap mopts = (IPersistentMap)opts)
            (§ if (ß !(opts != nil && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND)))))
                (§ throw Util.runtimeException("Conditional read not allowed"))
            )
            nil
        )

        (§ method Object invoke(Object reader, Object mode, Object opts, Object pendingForms)
            (ß checkConditionalAllowed(opts))

            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )

            (§ let boolean splicing = false)

            (§ if (ß ch == \@)
                (ß splicing = true)
                (ß ch = read1(r))
            )

            (§ while (ß isWhitespace(ch))
                (ß ch = read1(r))
            )

            (§ if (ß ch == -1)
                (§ throw Util.runtimeException("EOF while reading character"))
            )

            (§ if (ß ch != \()
                (§ throw Util.runtimeException("read-cond body must be a list"))
            )

            (§ try 
                (ß Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T)))

                (§ if (ß isPreserveReadCond(opts))
                    (§ let IFn listReader = getMacro(ch)) ;; should always be a list
                    (§ let Object form = listReader.invoke(r, ch, opts, ensurePending(pendingForms)))

                    (ß ReaderConditional.create(form, splicing))
                )
                (§ else 
                    (ß readCondDelimited(r, splicing, opts, pendingForms))
                )
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(§ anno @SuppressWarnings((§ "SynchronizeOnNonFinalField" )))
(class-ns LockingTransaction
    (§ def int RETRY_LIMIT = 10000)
    (§ def int LOCK_WAIT_MSECS = 100)
    (§ def long BARGE_WAIT_NANOS = 10 * 1000000)

    (§ def int RUNNING = 0)
    (§ def int COMMITTING = 1)
    (§ def int RETRY = 2)
    (§ def int KILLED = 3)
    (§ def int COMMITTED = 4)

    (§ def ThreadLocal<LockingTransaction> transaction = new ThreadLocal<LockingTransaction>())

    (class-ns RetryEx (§ extends Error)
    )

    (class-ns AbortException (§ extends Exception)
    )

    (class-ns Info
        (§ field AtomicInteger status)
        (§ field long startPoint)
        (§ field CountDownLatch latch)

        (§ constructor Info(int status, long startPoint)
            (ß this.status = new AtomicInteger(status))
            (ß this.startPoint = startPoint)
            (ß this.latch = new CountDownLatch(1))
            this
        )

        (§ method boolean running()
            (§ let int s = status.get())
            (ß (s == RUNNING || s == COMMITTING))
        )
    )

    (class-ns CFn
        (§ field IFn fn)
        (§ field ISeq args)

        (§ constructor CFn(IFn fn, ISeq args)
            (ß this.fn = fn)
            (ß this.args = args)
            this
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (§ def- AtomicLong lastPoint = new AtomicLong())

    (§ method void getReadPoint()
        (ß readPoint = lastPoint.incrementAndGet())
        nil
    )

    (§ method long getCommitPoint()
        (ß lastPoint.incrementAndGet())
    )

    (§ method void stop(int status)
        (§ if (ß info != nil)
            (§ sync (ß info)
                (ß info.status.set(status))
                (ß info.latch.countDown())
            )
            (ß info = nil)
            (ß vals.clear())
            (ß sets.clear())
            (ß commutes.clear())
        )
        nil
    )

    (§ field Info info)
    (§ field long readPoint)
    (§ field long startPoint)
    (§ field long startTime)

    (§ field RetryEx retryex = new RetryEx())
    (§ field ArrayList<Agent.Action> actions = new ArrayList<Agent.Action>())
    (§ field HashMap<Ref, Object> vals = new HashMap<Ref, Object>())
    (§ field HashSet<Ref> sets = new HashSet<Ref>())
    (§ field TreeMap<Ref, ArrayList<CFn>> commutes = new TreeMap<Ref, ArrayList<CFn>>())

    (§ field HashSet<Ref> ensures = new HashSet<Ref>()) ;; all hold readLock

    (§ method void tryWriteLock(Ref ref)
        (§ try 
            (§ if (ß !ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
                (§ throw retryex)
            )
        )
        (§ catch (ß InterruptedException e)
            (§ throw retryex)
        )
        nil
    )

    ;; returns the most recent val
    (§ method Object lock(Ref ref)
        ;; can't upgrade readLock, so release it
        (ß releaseIfEnsured(ref))

        (§ let boolean unlocked = true)
        (§ try 
            (ß tryWriteLock(ref))
            (ß unlocked = false)

            (§ if (ß ref.tvals != nil && ref.tvals.point > readPoint)
                (§ throw retryex)
            )
            (§ let Info refinfo = ref.tinfo)

            ;; write lock conflict
            (§ if (ß refinfo != nil && refinfo != info && refinfo.running())
                (§ if (ß !barge(refinfo))
                    (ß ref.lock.writeLock().unlock())
                    (ß unlocked = true)
                    (§ return (ß blockAndBail(refinfo)))
                )
            )
            (ß ref.tinfo = info)
            (ß (ref.tvals == nil) ? nil :or ref.tvals.val)
        )
        (§ finally 
            (§ if (ß !unlocked)
                (ß ref.lock.writeLock().unlock())
            )
        )
    )

    (§ method- Object blockAndBail(Info refinfo)
        ;; stop prior to blocking
        (ß stop(RETRY))
        (§ try 
            (ß refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
        )
        (§ catch (ß InterruptedException e)
            ;; ignore
        )
        (§ throw retryex)
    )

    (§ method- void releaseIfEnsured(Ref ref)
        (§ if (ß ensures.contains(ref))
            (ß ensures.remove(ref))
            (ß ref.lock.readLock().unlock())
        )
        nil
    )

    (§ method void abort() (§ throws AbortException)
        (ß stop(KILLED))
        (§ throw new AbortException())
    )

    (§ method- boolean bargeTimeElapsed()
        (ß (System.nanoTime() - startTime > BARGE_WAIT_NANOS))
    )

    (§ method- boolean barge(Info refinfo)
        (§ let boolean barged = false)
        ;; if this transaction is older, try to abort the other
        (§ if (ß bargeTimeElapsed() && startPoint < refinfo.startPoint)
            (ß barged = refinfo.status.compareAndSet(RUNNING, KILLED))
            (§ if (ß barged)
                (ß refinfo.latch.countDown())
            )
        )
        barged
    )

    (§ defn LockingTransaction getEx()
        (§ let LockingTransaction t = transaction.get())
        (§ if (ß t == nil || t.info == nil)
            (§ throw new IllegalStateException("No transaction running"))
        )
        t
    )

    (§ defn boolean isRunning()
        (ß (getRunning() != nil))
    )

    (§ defn LockingTransaction getRunning()
        (§ let LockingTransaction t = transaction.get())
        (§ if (ß t == nil || t.info == nil)
            (§ return nil)
        )
        t
    )

    (§ defn Object runInTransaction(Callable fn) (§ throws Exception)
        (§ let LockingTransaction t = transaction.get())
        (§ let Object ret)
        (§ if (ß t == nil)
            (ß transaction.set(t = new LockingTransaction()))
            (§ try 
                (ß ret = t.run(fn))
            )
            (§ finally 
                (ß transaction.remove())
            )
        )
        (§ else 
            (§ if (ß t.info != nil)
                (ß ret = fn.call())
            )
            (§ else 
                (ß ret = t.run(fn))
            )
        )

        ret
    )

    (class-ns Notify
        (§ field Ref ref)
        (§ field Object oldval)
        (§ field Object newval)

        (§ constructor Notify(Ref ref, Object oldval, Object newval)
            (ß this.ref = ref)
            (ß this.oldval = oldval)
            (ß this.newval = newval)
            this
        )
    )

    (§ method Object run(Callable fn) (§ throws Exception)
        (§ let boolean done = false)
        (§ let Object ret = nil)
        (§ let ArrayList<Ref> locked = new ArrayList<Ref>())
        (§ let ArrayList<Notify> notify = new ArrayList<Notify>())

        (§ loop-when-recur [(ß int i = 0)] (ß !done && i < RETRY_LIMIT) [(ß i++)]
            (§ try 
                (ß getReadPoint())
                (§ if (ß i == 0)
                    (ß startPoint = readPoint)
                    (ß startTime = System.nanoTime())
                )
                (ß info = new Info(RUNNING, startPoint))
                (ß ret = fn.call())
                ;; make sure no one has killed us before this point, and can't from now on
                (§ if (ß info.status.compareAndSet(RUNNING, COMMITTING))
                    (§ doseq [#_"Map.Entry<Ref, ArrayList<CFn>>" (ß e commutes.entrySet())]
                        (§ let Ref ref = e.getKey())
                        (§ if (ß sets.contains(ref))
                            (§ continue )
                        )

                        (§ let boolean wasEnsured = ensures.contains(ref))
                        ;; can't upgrade readLock, so release it
                        (ß releaseIfEnsured(ref))
                        (ß tryWriteLock(ref))
                        (ß locked.add(ref))
                        (§ if (ß wasEnsured && ref.tvals != nil && ref.tvals.point > readPoint)
                            (§ throw retryex)
                        )

                        (§ let Info refinfo = ref.tinfo)
                        (§ if (ß refinfo != nil && refinfo != info && refinfo.running())
                            (§ if (ß !barge(refinfo))
                                (§ throw retryex)
                            )
                        )
                        (§ let Object val = (ref.tvals == nil) ? nil :or ref.tvals.val)
                        (ß vals.put(ref, val))
                        (§ doseq [#_"CFn" f (ß e.getValue())]
                            (ß vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args))))
                        )
                    )
                    (§ doseq [#_"Ref" ref sets]
                        (ß tryWriteLock(ref))
                        (ß locked.add(ref))
                    )

                    ;; validate and enqueue notifications
                    (§ doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                        (§ let Ref ref = e.getKey())
                        (ß ref.validate(ref.getValidator(), e.getValue()))
                    )

                    ;; at this point, all values calced, all refs to be written locked
                    ;; no more client code to be called
                    (§ let long commitPoint = getCommitPoint())
                    (§ doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                        (§ let Ref ref = e.getKey())
                        (§ let Object oldval = (ref.tvals == nil) ? nil :or ref.tvals.val)
                        (§ let Object newval = e.getValue())
                        (§ let int hcount = ref.histCount())

                        (§ if (ß ref.tvals == nil)
                            (ß ref.tvals = new Ref.TVal(newval, commitPoint))
                        )
                        (§ elseif (ß (ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory)
                            (ß ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals))
                            (ß ref.faults.set(0))
                        )
                        (§ else 
                            (ß ref.tvals = ref.tvals.next)
                            (ß ref.tvals.val = newval)
                            (ß ref.tvals.point = commitPoint)
                        )
                        (§ if (ß ref.getWatches().count() > 0)
                            (ß notify.add(new Notify(ref, oldval, newval)))
                        )
                    )

                    (ß done = true)
                    (ß info.status.set(COMMITTED))
                )
            )
            (§ catch (ß RetryEx retry)
                ;; eat this so we retry rather than fall out
            )
            (§ finally 
                (§ loop-when-recur [(ß int k = locked.size() - 1)] (ß k >= 0) [(ß --k)]
                    (ß locked.get(k).lock.writeLock().unlock())
                )
                (ß locked.clear())
                (§ doseq [#_"Ref" r ensures]
                    (ß r.lock.readLock().unlock())
                )
                (ß ensures.clear())
                (ß stop(done ? COMMITTED :or RETRY))
                (§ try 
                    (§ if (ß done) ;; re-dispatch out of transaction
                        (§ doseq [#_"Notify" n notify]
                            (ß n.ref.notifyWatches(n.oldval, n.newval))
                        )
                        (§ doseq [#_"Agent.Action" action actions]
                            (ß Agent.dispatchAction(action))
                        )
                    )
                )
                (§ finally 
                    (ß notify.clear())
                    (ß actions.clear())
                )
            )
        )
        (§ if (ß !done)
            (§ throw Util.runtimeException("Transaction failed after reaching retry limit"))
        )
        ret
    )

    (§ method void enqueue(Agent.Action action)
        (ß actions.add(action))
        nil
    )

    (§ method Object doGet(Ref ref)
        (§ if (ß !info.running())
            (§ throw retryex)
        )
        (§ if (ß vals.containsKey(ref))
            (§ return (ß vals.get(ref)))
        )
        (§ try 
            (ß ref.lock.readLock().lock())
            (§ if (ß ref.tvals == nil)
                (§ throw new IllegalStateException(ref.toString() + " is unbound."))
            )
            (§ let Ref.TVal ver = ref.tvals)
            (§ loop
                (§ if (ß ver.point <= readPoint)
                    (§ return (ß ver.val))
                )
                (§ recur-if ((ver = ver.prior) != ref.tvals))
            )
        )
        (§ finally 
            (ß ref.lock.readLock().unlock())
        )
        ;; no version of val precedes the read point
        (ß ref.faults.incrementAndGet())
        (§ throw retryex)
    )

    (§ method Object doSet(Ref ref, Object val)
        (§ if (ß !info.running())
            (§ throw retryex)
        )
        (§ if (ß commutes.containsKey(ref))
            (§ throw new IllegalStateException("Can't set after commute"))
        )
        (§ if (ß !sets.contains(ref))
            (ß sets.add(ref))
            (ß lock(ref))
        )
        (ß vals.put(ref, val))
        val
    )

    (§ method void doEnsure(Ref ref)
        (§ if (ß !info.running())
            (§ throw retryex)
        )
        (§ if (ß ensures.contains(ref))
            (§ return nil)
        )
        (ß ref.lock.readLock().lock())

        ;; someone completed a write after our snapshot
        (§ if (ß ref.tvals != nil && ref.tvals.point > readPoint)
            (ß ref.lock.readLock().unlock())
            (§ throw retryex)
        )

        (§ let Info refinfo = ref.tinfo)

        ;; writer exists
        (§ if (ß refinfo != nil && refinfo.running())
            (ß ref.lock.readLock().unlock())

            (§ if (ß refinfo != info) ;; not us, ensure is doomed
                (ß blockAndBail(refinfo))
            )
        )
        (§ else 
            (ß ensures.add(ref))
        )
        nil
    )

    (§ method Object doCommute(Ref ref, IFn fn, ISeq args)
        (§ if (ß !info.running())
            (§ throw retryex)
        )
        (§ if (ß !vals.containsKey(ref))
            (§ let Object val = nil)
            (§ try 
                (ß ref.lock.readLock().lock())
                (ß val = (ref.tvals == nil) ? nil :or ref.tvals.val)
            )
            (§ finally 
                (ß ref.lock.readLock().unlock())
            )
            (ß vals.put(ref, val))
        )
        (§ let ArrayList<CFn> fns = commutes.get(ref))
        (§ if (ß fns == nil)
            (ß commutes.put(ref, fns = new ArrayList<CFn>()))
        )
        (ß fns.add(new CFn(fn, args)))
        (§ let Object ret = fn.applyTo(RT.cons(vals.get(ref), args)))
        (ß vals.put(ref, ret))
        ret
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (§ def- int CHUNK_SIZE = 32)

    ;; Invariants guarantee this is never an empty or infinite seq
    (§ field long start)
    (§ field long end)
    (§ field long step)
    (§ field BoundsCheck boundsCheck)

    #_volatile
    (§ field- LongChunk _chunk) ;; lazy
    #_volatile
    (§ field- ISeq _chunkNext) ;; lazy
    #_volatile
    (§ field- ISeq _next) ;; cached

    #_private
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(long val))
    )

    (§ defn- BoundsCheck positiveStep(long end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(long val)
                    (ß (val >= end))
                )
            )
        )
    )

    (§ defn- BoundsCheck negativeStep(long end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(long val)
                    (ß (val <= end))
                )
            )
        )
    )

    (§ constructor- LongRange(long start, long end, long step, BoundsCheck boundsCheck)
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        this
    )

    (§ constructor- LongRange(long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ constructor- LongRange(IPersistentMap meta, long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
        (§ super(meta))
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ defn ISeq create(long end)
        (§ if (ß end > 0)
            (§ return (ß new LongRange(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn ISeq create(long start, long end)
        (§ if (ß start >= end)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new LongRange(start, end, 1, positiveStep(end)))
    )

    (§ defn ISeq create(long start, long end, long step)
        (§ if (ß step > 0)
            (§ if (ß end <= start)
                (§ return (ß PersistentList.EMPTY))
            )
            (ß new LongRange(start, end, step, positiveStep(end)))
        )
        (§ elseif (ß step < 0)
            (§ if (ß end >= start)
                (§ return (ß PersistentList.EMPTY))
            )
            (ß new LongRange(start, end, step, negativeStep(end)))
        )
        (§ else 
            (§ if (ß end == start)
                (§ return (ß PersistentList.EMPTY))
            )
            (ß Repeat.create(start))
        )
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (ß meta == _meta)
            (§ return this)
        )
        (ß new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext))
    )

    (§ method Object first()
        start
    )

    (§ method void forceChunk()
        (§ if (ß _chunk != nil)
            (§ return nil)
        )

        (§ let long count)
        (§ try 
            (ß count = rangeCount(start, end, step))
        )
        (§ catch (ß ArithmeticException e)
            ;; size of total range is > Long.MAX_VALUE so must step to count
            ;; this only happens in pathological range cases like:
            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
            (ß count = steppingCount(start, end, step))
        )

        (§ if (ß count > CHUNK_SIZE) ;; not last chunk
            (§ let long nextStart = start + (step * CHUNK_SIZE)) ;; cannot overflow, must be < end
            (ß _chunkNext = new LongRange(nextStart, end, step, boundsCheck))
            (ß _chunk = new LongChunk(start, step, CHUNK_SIZE))
        )
        (§ else  ;; last chunk
            (ß _chunk = new LongChunk(start, step, (int) count)) ;; count must be <= CHUNK_SIZE
        )
        nil
    )

    (§ method ISeq next()
        (§ if (ß _next != nil)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (§ if (ß _chunk.count() > 1)
            (§ let LongChunk smallerChunk = _chunk.dropFirst())
            (ß _next = new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext))
            (§ return (ß _next))
        )
        (ß chunkedNext())
    )

    (§ method IChunk chunkedFirst()
        (ß forceChunk())
        (ß _chunk)
    )

    (§ method ISeq chunkedNext()
        (ß chunkedMore().seq())
    )

    (§ method ISeq chunkedMore()
        (ß forceChunk())
        (§ if (ß _chunkNext == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    (§ method long steppingCount(long start, long end, long step)
        (§ let long count = 1)
        (§ let long s = start)
        (§ while (ß count <= CHUNK_SIZE)
            (§ try 
                (ß s = Numbers.add(s, step))
                (§ if (ß boundsCheck.exceededBounds(s))
                    (§ break )
                )
                (§ else 
                    (ß count++)
                )
            )
            (§ catch (ß ArithmeticException e)
                (§ break )
            )
        )
        count
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    (§ method long rangeCount(long start, long end, long step)
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (ß Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step)
    )

    (§ method int count()
        (§ try 
            (§ let long c = rangeCount(start, end, step))
            (§ if (ß c > Integer.MAX_VALUE)
                (ß Numbers.throwIntOverflow())
            )
            (§ else 
                (ß (int) c)
            )
        )
        (§ catch (ß ArithmeticException e)
            ;; rare case from large range or step, fall back to iterating and counting
            (§ let Iterator iter = this.iterator())
            (§ let long count = 0)
            (§ while (ß iter.hasNext())
                (ß iter.next())
                (ß count++)
            )

            (§ if (ß count > Integer.MAX_VALUE)
                (ß Numbers.throwIntOverflow())
            )
            (§ else 
                (ß (int)count)
            )
        )
    )

    (§ method Object reduce(IFn f)
        (§ let Object acc = start)
        (§ let long i = start + step)
        (§ while (ß !boundsCheck.exceededBounds(i))
            (ß acc = f.invoke(acc, i))
            (§ if (ß acc instanceof Reduced)
                (§ return (ß ((Reduced)acc).deref()))
            )
            (ß i += step)
        )
        acc
    )

    (§ method Object reduce(IFn f, Object val)
        (§ let Object acc = val)
        (§ let long i = start)
        (§ loop
            (ß acc = f.invoke(acc, i))
            (§ if (ß RT.isReduced(acc))
                (§ return (ß ((Reduced)acc).deref()))
            )
            (ß i += step)
            (§ recur-if (!boundsCheck.exceededBounds(i)))
        )
        acc
    )

    (§ method Iterator iterator()
        (ß new LongRangeIterator())
    )

    #_non-static
    (class-ns LongRangeIterator (§ implements Iterator)
        (§ field- long next)
        (§ field- boolean hasNext)

        (§ constructor LongRangeIterator()
            (ß this.next = start)
            (ß this.hasNext = true)
            this
        )

        (§ method boolean hasNext()
            hasNext
        )

        (§ method Object next()
            (§ if (ß hasNext)
                (§ let long ret = next)
                (§ try 
                    (ß next = Numbers.add(next, step))
                    (ß hasNext = !boundsCheck.exceededBounds(next))
                )
                (§ catch (ß ArithmeticException e)
                    (ß hasNext = false)
                )
                ret
            )
            (§ else 
                (§ throw new NoSuchElementException())
            )
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    #_private
    (class-ns LongChunk (§ implements IChunk)
        (§ field long start)
        (§ field long step)
        (§ field int count)

        (§ constructor LongChunk(long start, long step, int count)
            (ß this.start = start)
            (ß this.step = step)
            (ß this.count = count)
            this
        )

        (§ method long first()
            start
        )

        (§ method Object nth(int i)
            (ß start + (i * step))
        )

        (§ method Object nth(int i, Object notFound)
            (§ if (ß i >= 0 && i < count)
                (§ return (ß start + (i * step)))
            )
            notFound
        )

        (§ method int count()
            count
        )

        (§ method LongChunk dropFirst()
            (§ if (ß count <= 1)
                (§ throw new IllegalStateException("dropFirst of empty chunk"))
            )
            (ß new LongChunk(start + step, step, count - 1))
        )

        (§ method Object reduce(IFn f, Object init)
            (§ let long x = start)
            (§ let Object ret = init)
            (§ loop-when-recur [(ß int i = 0)] (ß i < count) [(ß i++)]
                (ß ret = f.invoke(ret, x))
                (§ if (ß RT.isReduced(ret))
                    (§ return ret)
                )
                (ß x += step)
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (§ field Object _key)
    (§ field Object _val)

    (§ defn MapEntry create(Object key, Object val)
        (ß new MapEntry(key, val))
    )

    (§ constructor MapEntry(Object key, Object val)
        (ß this._key = key)
        (ß this._val = val)
        this
    )

    (§ method Object key()
        (ß _key)
    )

    (§ method Object val()
        (ß _val)
    )

    (§ method Object getKey()
        (ß key())
    )

    (§ method Object getValue()
        (ß val())
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ interface MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns MethodImplCache
    (class-ns Entry
        (§ field Class c)
        (§ field IFn fn)

        (§ constructor Entry(Class c, IFn fn)
            (ß this.c = c)
            (ß this.fn = fn)
            this
        )
    )

    (§ field IPersistentMap protocol)
    (§ field Keyword methodk)
    (§ field int shift)
    (§ field int mask)
    (§ field Object[] table) ;; [class, entry. class, entry ...]
    (§ field Map map)

    (§ field Entry mre = nil)

    (§ constructor MethodImplCache(IPersistentMap protocol, Keyword methodk)
        (§ this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY))
        this
    )

    (§ constructor MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table)
        (ß this.protocol = protocol)
        (ß this.methodk = methodk)
        (ß this.shift = shift)
        (ß this.mask = mask)
        (ß this.table = table)
        (ß this.map = nil)
        this
    )

    (§ constructor MethodImplCache(IPersistentMap protocol, Keyword methodk, Map map)
        (ß this.protocol = protocol)
        (ß this.methodk = methodk)
        (ß this.shift = 0)
        (ß this.mask = 0)
        (ß this.table = nil)
        (ß this.map = map)
        this
    )

    (§ method IFn fnFor(Class c)
        (§ let Entry last = mre)
        (§ if (ß last != nil && last.c == c)
            (§ return (ß last.fn))
        )
        (ß findFnFor(c))
    )

    (§ method IFn findFnFor(Class c)
        (§ if (ß map != nil)
            (§ let Entry e = (Entry) map.get(c))
            (ß mre = e)
            (ß (e != nil) ? e.fn :or nil)
        )
        (§ else 
            (§ let int idx = ((Util.hash(c) >> shift) & mask) << 1)
            (§ if (ß idx < table.length && table[idx] == c)
                (§ let Entry e = ((Entry) table[idx + 1]))
                (ß mre = e)
                (§ return (ß (e != nil) ? e.fn :or nil))
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ field IFn dispatchFn)
    (§ field Object defaultDispatchVal)
    (§ field IRef hierarchy)
    (§ field String name)
    (§ field ReentrantReadWriteLock rw)

    #_volatile
    (§ field IPersistentMap methodTable)
    #_volatile
    (§ field IPersistentMap preferTable)
    #_volatile
    (§ field IPersistentMap methodCache)
    #_volatile
    (§ field Object cachedHierarchy)

    (§ def Var assoc = RT.var("cloiure.core", "assoc"))
    (§ def Var dissoc = RT.var("cloiure.core", "dissoc"))
    (§ def Var isa = RT.var("cloiure.core", "isa?"))
    (§ def Var parents = RT.var("cloiure.core", "parents"))

    (§ constructor MultiFn(String name, IFn dispatchFn, Object defaultDispatchVal, IRef hierarchy)
        (ß this.rw = new ReentrantReadWriteLock())
        (ß this.name = name)
        (ß this.dispatchFn = dispatchFn)
        (ß this.defaultDispatchVal = defaultDispatchVal)
        (ß this.methodTable = PersistentHashMap.EMPTY)
        (ß this.methodCache = getMethodTable())
        (ß this.preferTable = PersistentHashMap.EMPTY)
        (ß this.hierarchy = hierarchy)
        (ß cachedHierarchy = nil)
        this
    )

    (§ method MultiFn reset()
        (ß rw.writeLock().lock())
        (§ try 
            (ß methodTable = methodCache = preferTable = PersistentHashMap.EMPTY)
            (ß cachedHierarchy = nil)
            this
        )
        (§ finally 
            (ß rw.writeLock().unlock())
        )
    )

    (§ method MultiFn addMethod(Object dispatchVal, IFn method)
        (ß rw.writeLock().lock())
        (§ try 
            (ß methodTable = getMethodTable().assoc(dispatchVal, method))
            (ß resetCache())
            this
        )
        (§ finally 
            (ß rw.writeLock().unlock())
        )
    )

    (§ method MultiFn removeMethod(Object dispatchVal)
        (ß rw.writeLock().lock())
        (§ try 
            (ß methodTable = getMethodTable().without(dispatchVal))
            (ß resetCache())
            this
        )
        (§ finally 
            (ß rw.writeLock().unlock())
        )
    )

    (§ method MultiFn preferMethod(Object dispatchValX, Object dispatchValY)
        (ß rw.writeLock().lock())
        (§ try 
            (§ if (ß prefers(dispatchValY, dispatchValX))
                (§ throw new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX)))
            )
            (ß preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY)))
            (ß resetCache())
            this
        )
        (§ finally 
            (ß rw.writeLock().unlock())
        )
    )

    (§ method- boolean prefers(Object x, Object y)
        (§ let IPersistentSet xprefs = (IPersistentSet) getPreferTable().valAt(x))
        (§ if (ß xprefs != nil && xprefs.contains(y))
            (§ return true)
        )
        (§ loop-when-recur [(ß ISeq ps = RT.seq(parents.invoke(y)))] (ß ps != nil) [(ß ps = ps.next())]
            (§ if (ß prefers(x, ps.first()))
                (§ return true)
            )
        )
        (§ loop-when-recur [(ß ISeq ps = RT.seq(parents.invoke(x)))] (ß ps != nil) [(ß ps = ps.next())]
            (§ if (ß prefers(ps.first(), y))
                (§ return true)
            )
        )
        false
    )

    (§ method- boolean isA(Object x, Object y)
        (ß RT.booleanCast(isa.invoke(hierarchy.deref(), x, y)))
    )

    (§ method- boolean dominates(Object x, Object y)
        (ß prefers(x, y) || isA(x, y))
    )

    (§ method- IPersistentMap resetCache()
        (ß rw.writeLock().lock())
        (§ try 
            (ß methodCache = getMethodTable())
            (ß cachedHierarchy = hierarchy.deref())
            methodCache
        )
        (§ finally 
            (ß rw.writeLock().unlock())
        )
    )

    (§ method IFn getMethod(Object dispatchVal)
        (§ if (ß cachedHierarchy != hierarchy.deref())
            (ß resetCache())
        )
        (§ let IFn targetFn = (IFn) methodCache.valAt(dispatchVal))
        (§ if (ß targetFn != nil)
            (§ return targetFn)
        )
        (ß findAndCacheBestMethod(dispatchVal))
    )

    (§ method- IFn getFn(Object dispatchVal)
        (§ let IFn targetFn = getMethod(dispatchVal))
        (§ if (ß targetFn == nil)
            (§ throw new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal)))
        )
        targetFn
    )

    (§ method- IFn findAndCacheBestMethod(Object dispatchVal)
        (ß rw.readLock().lock())
        (§ let Object bestValue)
        (§ let IPersistentMap mt = methodTable)
        (§ let IPersistentMap pt = preferTable)
        (§ let Object ch = cachedHierarchy)
        (§ try 
            (§ let Map.Entry bestEntry = nil)
            (§ doseq [#_"Object" o (ß getMethodTable())]
                (§ let Map.Entry e = (Map.Entry) o)
                (§ if (ß isA(dispatchVal, e.getKey()))
                    (§ if (ß bestEntry == nil || dominates(e.getKey(), bestEntry.getKey()))
                        (ß bestEntry = e)
                    )
                    (§ if (ß !dominates(bestEntry.getKey(), e.getKey()))
                        (§ throw new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey())))
                    )
                )
            )
            (§ if (ß bestEntry == nil)
                (ß bestValue = methodTable.valAt(defaultDispatchVal))
                (§ if (ß bestValue == nil)
                    (§ return nil)
                )
            )
            (§ else 
                (ß bestValue = bestEntry.getValue())
            )
        )
        (§ finally 
            (ß rw.readLock().unlock())
        )

        ;; ensure basis has stayed stable throughout, else redo
        (ß rw.writeLock().lock())
        (§ try 
            (§ if (ß mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
                ;; place in cache
                (ß methodCache = methodCache.assoc(dispatchVal, bestValue))
                (ß (IFn) bestValue)
            )
            (§ else 
                (ß resetCache())
                (ß findAndCacheBestMethod(dispatchVal))
            )
        )
        (§ finally 
            (ß rw.writeLock().unlock())
        )
    )

    (§ method Object invoke()
        (ß getFn(dispatchFn.invoke()).invoke())
    )

    (§ method Object invoke(Object arg1)
        (ß getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, arg1 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß getFn(dispatchFn.invoke(arg1, arg2)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20, args)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                    args))
    )

    (§ method IPersistentMap getMethodTable()
        methodTable
    )

    (§ method IPersistentMap getPreferTable()
        preferTable
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
(class-ns Murmur3
    (§ def- int seed = 0)
    (§ def- int C1 = 0xcc9e2d51)
    (§ def- int C2 = 0x1b873593)

    (§ defn int hashInt(int input)
        (§ if (ß input == 0)
            (§ return 0)
        )
        (§ let int k1 = mixK1(input))
        (§ let int h1 = mixH1(seed, k1))

        (ß fmix(h1, 4))
    )

    (§ defn int hashLong(long input)
        (§ if (ß input == 0)
            (§ return 0)
        )
        (§ let int low = (int) input)
        (§ let int high = (int) (input >>> 32))

        (§ let int k1 = mixK1(low))
        (§ let int h1 = mixH1(seed, k1))

        (ß k1 = mixK1(high))
        (ß h1 = mixH1(h1, k1))

        (ß fmix(h1, 8))
    )

    (§ defn int hashUnencodedChars(CharSequence input)
        (§ let int h1 = seed)

        ;; step through the CharSequence 2 chars at a time
        (§ loop-when-recur [(ß int i = 1)] (ß i < input.length()) [(ß i += 2)]
            (§ let int k1 = input.charAt(i - 1) | (input.charAt(i) << 16))
            (ß k1 = mixK1(k1))
            (ß h1 = mixH1(h1, k1))
        )

        ;; deal with any remaining characters
        (§ if (ß (input.length() & 1) == 1)
            (§ let int k1 = input.charAt(input.length() - 1))
            (ß k1 = mixK1(k1))
            (ß h1 ^= k1)
        )

        (ß fmix(h1, 2 * input.length()))
    )

    (§ defn int mixCollHash(int hash, int count)
        (§ let int h1 = seed)
        (§ let int k1 = mixK1(hash))
        (ß h1 = mixH1(h1, k1))
        (ß fmix(h1, count))
    )

    (§ defn int hashOrdered(Iterable xs)
        (§ let int n = 0)
        (§ let int hash = 1)

        (§ doseq [#_"Object" x xs]
            (ß hash = 31 * hash + Util.hasheq(x))
            (ß ++n)
        )

        (ß mixCollHash(hash, n))
    )

    (§ defn int hashUnordered(Iterable xs)
        (§ let int hash = 0)
        (§ let int n = 0)
        (§ doseq [#_"Object" x xs]
            (ß hash += Util.hasheq(x))
            (ß ++n)
        )

        (ß mixCollHash(hash, n))
    )

    (§ defn- int mixK1(int k1)
        (ß k1 *= C1)
        (ß k1 = Integer.rotateLeft(k1, 15))
        (ß k1 *= C2)
        k1
    )

    (§ defn- int mixH1(int h1, int k1)
        (ß h1 ^= k1)
        (ß h1 = Integer.rotateLeft(h1, 13))
        (ß h1 = h1 * 5 + 0xe6546b64)
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (§ defn- int fmix(int h1, int length)
        (ß h1 ^= length)
        (ß h1 ^= h1 >>> 16)
        (ß h1 *= 0x85ebca6b)
        (ß h1 ^= h1 >>> 13)
        (ß h1 *= 0xc2b2ae35)
        (ß h1 ^= h1 >>> 16)
        h1
    )
)
)

(java-ns cloiure.lang.Named

(§ interface Named
    (§ abstract String getNamespace())
    (§ abstract String getName())
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (§ field Symbol name)

    #_transient
    (§ field AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>())
    #_transient
    (§ field AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>())

    (§ def ConcurrentHashMap<Symbol, Namespace> namespaces = new ConcurrentHashMap<Symbol, Namespace>())

    (§ method String toString()
        (ß name.toString())
    )

    (§ constructor Namespace(Symbol name)
        (§ super(name.meta()))
        (ß this.name = name)
        (ß mappings.set(RT.DEFAULT_IMPORTS))
        (ß aliases.set(RT.map()))
        this
    )

    (§ defn ISeq all()
        (ß RT.seq(namespaces.values()))
    )

    (§ method Symbol getName()
        name
    )

    (§ method IPersistentMap getMappings()
        (ß mappings.get())
    )

    (§ method Var intern(Symbol sym)
        (§ if (ß sym.ns != nil)
            (§ throw new IllegalArgumentException("Can't intern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ let Object o)
        (§ let Var v = nil)
        (§ while (ß (o = map.valAt(sym)) == nil)
            (§ if (ß v == nil)
                (ß v = new Var(this, sym))
            )
            (§ let IPersistentMap newMap = map.assoc(sym, v))
            (ß mappings.compareAndSet(map, newMap))
            (ß map = getMappings())
        )
        (§ if (ß o instanceof Var && ((Var) o).ns == this)
            (§ return (ß (Var) o))
        )

        (§ if (ß v == nil)
            (ß v = new Var(this, sym))
        )

        (ß warnOrFailOnReplace(sym, o, v))

        (§ while (ß !mappings.compareAndSet(map, map.assoc(sym, v)))
            (ß map = getMappings())
        )

        v
    )

    (§ method- void warnOrFailOnReplace(Symbol sym, Object o, Object v)
        (§ if (ß o instanceof Var)
            (§ let Namespace ns = ((Var)o).ns)
            (§ if (ß ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOIURE_NS))
                (§ return nil)
            )
            (§ if (ß ns != RT.CLOIURE_NS)
                (§ throw new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name))
            )
        )
        (ß RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v))
        nil
    )

    (§ method Object reference(Symbol sym, Object val)
        (§ if (ß sym.ns != nil)
            (§ throw new IllegalArgumentException("Can't intern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ let Object o)
        (§ while (ß (o = map.valAt(sym)) == nil)
            (§ let IPersistentMap newMap = map.assoc(sym, val))
            (ß mappings.compareAndSet(map, newMap))
            (ß map = getMappings())
        )
        (§ if (ß o == val)
            (§ return o)
        )

        (ß warnOrFailOnReplace(sym, o, val))

        (§ while (ß !mappings.compareAndSet(map, map.assoc(sym, val)))
            (ß map = getMappings())
        )

        val
    )

    (§ defn boolean areDifferentInstancesOfSameClassName(Class cls1, Class cls2)
        (ß (cls1 != cls2) && (cls1.getName().equals(cls2.getName())))
    )

    (§ method Class referenceClass(Symbol sym, Class val)
        (§ if (ß sym.ns != nil)
            (§ throw new IllegalArgumentException("Can't intern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ let Class c = (Class) map.valAt(sym))
        (§ while (ß (c == nil) || (areDifferentInstancesOfSameClassName(c, val)))
            (§ let IPersistentMap newMap = map.assoc(sym, val))
            (ß mappings.compareAndSet(map, newMap))
            (ß map = getMappings())
            (ß c = (Class) map.valAt(sym))
        )
        (§ if (ß c == val)
            (§ return c)
        )

        (§ throw new IllegalStateException(sym + " already refers to: " + c + " in namespace: " + name))
    )

    (§ method void unmap(Symbol sym)
        (§ if (ß sym.ns != nil)
            (§ throw new IllegalArgumentException("Can't unintern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ while (ß map.containsKey(sym))
            (§ let IPersistentMap newMap = map.without(sym))
            (ß mappings.compareAndSet(map, newMap))
            (ß map = getMappings())
        )
        nil
    )

    (§ method Class importClass(Symbol sym, Class c)
        (ß referenceClass(sym, c))
    )

    (§ method Class importClass(Class c)
        (§ let String n = c.getName())
        (ß importClass(Symbol.intern(n.substring(n.lastIndexOf(\.) + 1)), c))
    )

    (§ method Var refer(Symbol sym, Var var)
        (ß (Var) reference(sym, var))
    )

    (§ defn Namespace findOrCreate(Symbol name)
        (§ let Namespace ns = namespaces.get(name))
        (§ if (ß ns != nil)
            (§ return ns)
        )
        (§ let Namespace newns = new Namespace(name))
        (ß ns = namespaces.putIfAbsent(name, newns))
        (ß (ns == nil) ? newns :or ns)
    )

    (§ defn Namespace remove(Symbol name)
        (§ if (ß name.equals(RT.CLOIURE_NS.name))
            (§ throw new IllegalArgumentException("Cannot remove cloiure namespace"))
        )
        (ß namespaces.remove(name))
    )

    (§ defn Namespace find(Symbol name)
        (ß namespaces.get(name))
    )

    (§ method Object getMapping(Symbol name)
        (ß mappings.get().valAt(name))
    )

    (§ method Var findInternedVar(Symbol symbol)
        (§ let Object o = mappings.get().valAt(symbol))
        (§ if (ß o != nil && o instanceof Var && ((Var) o).ns == this)
            (§ return (ß (Var) o))
        )
        nil
    )

    (§ method IPersistentMap getAliases()
        (ß aliases.get())
    )

    (§ method Namespace lookupAlias(Symbol alias)
        (§ let IPersistentMap map = getAliases())
        (ß (Namespace) map.valAt(alias))
    )

    (§ method void addAlias(Symbol alias, Namespace ns)
        (§ if (ß alias == nil || ns == nil)
            (§ throw new NullPointerException("Expecting Symbol + Namespace"))
        )
        (§ let IPersistentMap map = getAliases())
        (§ while (ß !map.containsKey(alias))
            (§ let IPersistentMap newMap = map.assoc(alias, ns))
            (ß aliases.compareAndSet(map, newMap))
            (ß map = getAliases())
        )
        ;; you can rebind an alias, but only to the initially-aliased namespace.
        (§ if (ß !map.valAt(alias).equals(ns))
            (§ throw new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias)))
        )
        nil
    )

    (§ method void removeAlias(Symbol alias)
        (§ let IPersistentMap map = getAliases())
        (§ while (ß map.containsKey(alias))
            (§ let IPersistentMap newMap = map.without(alias))
            (ß aliases.compareAndSet(map, newMap))
            (ß map = getAliases())
        )
        nil
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Numbers
    (§ interface Ops
        (§ abstract Ops combine(Ops y))
        (§ abstract Ops opsWith(LongOps x))
        (§ abstract Ops opsWith(DoubleOps x))
        (§ abstract Ops opsWith(RatioOps x))
        (§ abstract Ops opsWith(BigIntOps x))
        (§ abstract Ops opsWith(BigDecimalOps x))
        (§ abstract boolean isZero(Number x))
        (§ abstract boolean isPos(Number x))
        (§ abstract boolean isNeg(Number x))
        (§ abstract Number add(Number x, Number y))
        (§ abstract Number addP(Number x, Number y))
        (§ abstract Number multiply(Number x, Number y))
        (§ abstract Number multiplyP(Number x, Number y))
        (§ abstract Number divide(Number x, Number y))
        (§ abstract Number quotient(Number x, Number y))
        (§ abstract Number remainder(Number x, Number y))
        (§ abstract boolean equiv(Number x, Number y))
        (§ abstract boolean lt(Number x, Number y))
        (§ abstract boolean lte(Number x, Number y))
        (§ abstract boolean gte(Number x, Number y))
        (§ abstract Number negate(Number x))
        (§ abstract Number negateP(Number x))
        (§ abstract Number inc(Number x))
        (§ abstract Number incP(Number x))
        (§ abstract Number dec(Number x))
        (§ abstract Number decP(Number x))
    )

    #_abstract
    (class-ns OpsP (§ implements Ops)
        (§ method Number addP(Number x, Number y)
            (ß add(x, y))
        )

        (§ method Number multiplyP(Number x, Number y)
            (ß multiply(x, y))
        )

        (§ method Number negateP(Number x)
            (ß negate(x))
        )

        (§ method Number incP(Number x)
            (ß inc(x))
        )

        (§ method Number decP(Number x)
            (ß dec(x))
        )
    )

    (§ defn boolean isZero(Object x)
        (ß ops(x).isZero((Number)x))
    )

    (§ defn boolean isPos(Object x)
        (ß ops(x).isPos((Number)x))
    )

    (§ defn boolean isNeg(Object x)
        (ß ops(x).isNeg((Number)x))
    )

    (§ defn Number minus(Object x)
        (ß ops(x).negate((Number)x))
    )

    (§ defn Number minusP(Object x)
        (ß ops(x).negateP((Number)x))
    )

    (§ defn Number inc(Object x)
        (ß ops(x).inc((Number)x))
    )

    (§ defn Number incP(Object x)
        (ß ops(x).incP((Number)x))
    )

    (§ defn Number dec(Object x)
        (ß ops(x).dec((Number)x))
    )

    (§ defn Number decP(Object x)
        (ß ops(x).decP((Number)x))
    )

    (§ defn Number add(Object x, Object y)
        (ß ops(x).combine(ops(y)).add((Number)x, (Number)y))
    )

    (§ defn Number addP(Object x, Object y)
        (ß ops(x).combine(ops(y)).addP((Number)x, (Number)y))
    )

    (§ defn Number minus(Object x, Object y)
        (§ let Ops yops = ops(y))
        (ß ops(x).combine(yops).add((Number)x, yops.negate((Number)y)))
    )

    (§ defn Number minusP(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ let Number negativeY = yops.negateP((Number) y))
        (§ let Ops negativeYOps = ops(negativeY))
        (ß ops(x).combine(negativeYOps).addP((Number)x, negativeY))
    )

    (§ defn Number multiply(Object x, Object y)
        (ß ops(x).combine(ops(y)).multiply((Number)x, (Number)y))
    )

    (§ defn Number multiplyP(Object x, Object y)
        (ß ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y))
    )

    (§ defn Number divide(Object x, Object y)
        (§ if (ß isNaN(x))
            (§ return (ß (Number)x))
        )
        (§ elseif (ß isNaN(y))
            (§ return (ß (Number)y))
        )
        (§ let Ops yops = ops(y))
        (§ if (ß yops.isZero((Number)y))
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (ß ops(x).combine(yops).divide((Number)x, (Number)y))
    )

    (§ defn Number quotient(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ if (ß yops.isZero((Number) y))
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (ß ops(x).combine(yops).quotient((Number)x, (Number)y))
    )

    (§ defn Number remainder(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ if (ß yops.isZero((Number) y))
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (ß ops(x).combine(yops).remainder((Number)x, (Number)y))
    )

    (§ defn double quotient(double n, double d)
        (§ if (ß d == 0)
            (§ throw new ArithmeticException("Divide by zero"))
        )

        (§ let double q = n / d)
        (§ if (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
            (ß (double)(long) q)
        )
        (§ else  ;; bigint quotient
            (ß new BigDecimal(q).toBigInteger().doubleValue())
        )
    )

    (§ defn double remainder(double n, double d)
        (§ if (ß d == 0)
            (§ throw new ArithmeticException("Divide by zero"))
        )

        (§ let double q = n / d)
        (§ if (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
            (ß (n - ((long) q) * d))
        )
        (§ else  ;; bigint quotient
            (§ let Number bq = new BigDecimal(q).toBigInteger())
            (ß (n - bq.doubleValue() * d))
        )
    )

    (§ defn boolean equiv(Object x, Object y)
        (ß equiv((Number) x, (Number) y))
    )

    (§ defn boolean equiv(Number x, Number y)
        (ß ops(x).combine(ops(y)).equiv(x, y))
    )

    (§ defn boolean equal(Number x, Number y)
        (ß (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y)))
    )

    (§ defn boolean lt(Object x, Object y)
        (ß ops(x).combine(ops(y)).lt((Number)x, (Number)y))
    )

    (§ defn boolean lte(Object x, Object y)
        (ß ops(x).combine(ops(y)).lte((Number)x, (Number)y))
    )

    (§ defn boolean gt(Object x, Object y)
        (ß ops(x).combine(ops(y)).lt((Number)y, (Number)x))
    )

    (§ defn boolean gte(Object x, Object y)
        (ß ops(x).combine(ops(y)).gte((Number)x, (Number)y))
    )

    (§ defn int compare(Number x, Number y)
        (§ let Ops ops = ops(x).combine(ops(y)))
        (§ if (ß ops.lt(x, y))
            (§ return -1)
        )
        (§ elseif (ß ops.lt(y, x))
            (§ return 1)
        )
        0
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn BigInt toBigInt(Object x)
        (§ if (ß x instanceof BigInt)
            (§ return (ß (BigInt) x))
        )
        (§ if (ß x instanceof BigInteger)
            (ß BigInt.fromBigInteger((BigInteger) x))
        )
        (§ else 
            (ß BigInt.fromLong(((Number) x).longValue()))
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn BigInteger toBigInteger(Object x)
        (§ if (ß x instanceof BigInteger)
            (ß (BigInteger) x)
        )
        (§ elseif (ß x instanceof BigInt)
            (ß ((BigInt) x).toBigInteger())
        )
        (§ else 
            (ß BigInteger.valueOf(((Number) x).longValue()))
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn BigDecimal toBigDecimal(Object x)
        (§ if (ß x instanceof BigDecimal)
            (ß (BigDecimal) x)
        )
        (§ elseif (ß x instanceof BigInt)
            (§ let BigInt bi = (BigInt) x)
            (§ if (ß bi.bipart == nil)
                (ß BigDecimal.valueOf(bi.lpart))
            )
            (§ else 
                (ß new BigDecimal(bi.bipart))
            )
        )
        (§ elseif (ß x instanceof BigInteger)
            (ß new BigDecimal((BigInteger) x))
        )
        (§ elseif (ß x instanceof Double)
            (ß new BigDecimal(((Number) x).doubleValue()))
        )
        (§ elseif (ß x instanceof Float)
            (ß new BigDecimal(((Number) x).doubleValue()))
        )
        (§ elseif (ß x instanceof Ratio)
            (§ let Ratio r = (Ratio)x)
            (ß (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator))
        )
        (§ else 
            (ß BigDecimal.valueOf(((Number) x).longValue()))
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn Ratio toRatio(Object x)
        (§ if (ß x instanceof Ratio)
            (§ return (ß (Ratio) x))
        )
        (§ elseif (ß x instanceof BigDecimal)
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ let BigInteger bv = bx.unscaledValue())
            (§ let int scale = bx.scale())
            (§ if (ß scale < 0)
                (§ return (ß new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)))
            )
            (§ else 
                (§ return (ß new Ratio(bv, BigInteger.TEN.pow(scale))))
            )
        )
        (ß new Ratio(toBigInteger(x), BigInteger.ONE))
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn Number rationalize(Number x)
        (§ if (ß x instanceof Float || x instanceof Double)
            (§ return (ß rationalize(BigDecimal.valueOf(x.doubleValue()))))
        )
        (§ elseif (ß x instanceof BigDecimal)
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ let BigInteger bv = bx.unscaledValue())
            (§ let int scale = bx.scale())
            (§ if (ß scale < 0)
                (§ return (ß BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))))
            )
            (§ else 
                (§ return (ß divide(bv, BigInteger.TEN.pow(scale))))
            )
        )
        x
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn Number reduceBigInt(BigInt val)
        (§ if (ß val.bipart == nil)
            (ß num(val.lpart))
        )
        (§ else 
            (ß val.bipart)
        )
    )

    (§ defn Number divide(BigInteger n, BigInteger d)
        (§ if (ß d.equals(BigInteger.ZERO))
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (§ let BigInteger gcd = n.gcd(d))
        (§ if (ß gcd.equals(BigInteger.ZERO))
            (§ return (ß BigInt.ZERO))
        )
        (ß n = n.divide(gcd))
        (ß d = d.divide(gcd))
        (§ if (ß d.equals(BigInteger.ONE))
            (§ return (ß BigInt.fromBigInteger(n)))
        )
        (§ elseif (ß d.equals(BigInteger.ONE.negate()))
            (§ return (ß BigInt.fromBigInteger(n.negate())))
        )
        (ß new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d)))
    )

    (§ defn int shiftLeftInt(int x, int n)
        (ß x << n)
    )

    (§ defn long shiftLeft(Object x, Object y)
        (ß shiftLeft(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn long shiftLeft(Object x, long y)
        (ß shiftLeft(bitOpsCast(x), y))
    )
    (§ defn long shiftLeft(long x, Object y)
        (ß shiftLeft(x, bitOpsCast(y)))
    )
    (§ defn long shiftLeft(long x, long n)
        (ß x << n)
    )

    (§ defn int shiftRightInt(int x, int n)
        (ß x >> n)
    )

    (§ defn long shiftRight(Object x, Object y)
        (ß shiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn long shiftRight(Object x, long y)
        (ß shiftRight(bitOpsCast(x), y))
    )
    (§ defn long shiftRight(long x, Object y)
        (ß shiftRight(x, bitOpsCast(y)))
    )
    (§ defn long shiftRight(long x, long n)
        (ß x >> n)
    )

    (§ defn int unsignedShiftRightInt(int x, int n)
        (ß x >>> n)
    )

    (§ defn long unsignedShiftRight(Object x, Object y)
        (ß unsignedShiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn long unsignedShiftRight(Object x, long y)
        (ß unsignedShiftRight(bitOpsCast(x), y))
    )
    (§ defn long unsignedShiftRight(long x, Object y)
        (ß unsignedShiftRight(x, bitOpsCast(y)))
    )
    (§ defn long unsignedShiftRight(long x, long n)
        (ß x >>> n)
    )

    (class-ns LongOps (§ implements Ops)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            (ß RATIO_OPS)
        )

        (§ method Ops opsWith(BigIntOps x)
            (ß BIGINT_OPS)
        )

        (§ method Ops opsWith(BigDecimalOps x)
            (ß BIGDECIMAL_OPS)
        )

        (§ method boolean isZero(Number x)
            (ß (x.longValue() == 0))
        )

        (§ method boolean isPos(Number x)
            (ß (x.longValue() > 0))
        )

        (§ method boolean isNeg(Number x)
            (ß (x.longValue() < 0))
        )

        (§ method Number add(Number x, Number y)
            (ß num(Numbers.add(x.longValue(), y.longValue())))
        )

        (§ method Number addP(Number x, Number y)
            (§ let long lx = x.longValue(), ly = y.longValue())
            (§ let long ret = lx + ly)
            (§ if (ß (ret :xor lx) < 0 && (ret :xor ly) < 0)
                (§ return (ß BIGINT_OPS.add(x, y)))
            )
            (ß num(ret))
        )

        (§ method Number multiply(Number x, Number y)
            (ß num(Numbers.multiply(x.longValue(), y.longValue())))
        )

        (§ method Number multiplyP(Number x, Number y)
            (§ let long lx = x.longValue(), ly = y.longValue())
            (§ if (ß lx == Long.MIN_VALUE && ly < 0)
                (§ return (ß BIGINT_OPS.multiply(x, y)))
            )
            (§ let long ret = lx * ly)
            (§ if (ß ly != 0 && ret/ly != lx)
                (§ return (ß BIGINT_OPS.multiply(x, y)))
            )
            (ß num(ret))
        )

        (§ defn long gcd(long u, long v)
            (§ while (ß v != 0)
                (§ let long r = u % v)
                (ß u = v)
                (ß v = r)
            )
            u
        )

        (§ method Number divide(Number x, Number y)
            (§ let long n = x.longValue())
            (§ let long val = y.longValue())
            (§ let long gcd = gcd(n, val))
            (§ if (ß gcd == 0)
                (§ return (ß num(0)))
            )

            (ß n = n / gcd)
            (§ let long d = val / gcd)
            (§ if (ß d == 1)
                (§ return (ß num(n)))
            )
            (§ if (ß d < 0)
                (ß n = -n)
                (ß d = -d)
            )
            (ß new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d)))
        )

        (§ method Number quotient(Number x, Number y)
            (ß num(x.longValue() / y.longValue()))
        )

        (§ method Number remainder(Number x, Number y)
            (ß num(x.longValue() % y.longValue()))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß (x.longValue() == y.longValue()))
        )

        (§ method boolean lt(Number x, Number y)
            (ß (x.longValue() < y.longValue()))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (x.longValue() <= y.longValue()))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (x.longValue() >= y.longValue()))
        )

        (§ method Number negate(Number x)
            (§ let long val = x.longValue())
            (ß num(Numbers.minus(val)))
        )

        (§ method Number negateP(Number x)
            (§ let long val = x.longValue())
            (§ if (ß val > Long.MIN_VALUE)
                (§ return (ß num(-val)))
            )
            (ß BigInt.fromBigInteger(BigInteger.valueOf(val).negate()))
        )

        (§ method Number inc(Number x)
            (§ let long val = x.longValue())
            (ß num(Numbers.inc(val)))
        )

        (§ method Number incP(Number x)
            (§ let long val = x.longValue())
            (§ if (ß val < Long.MAX_VALUE)
                (§ return (ß num(val + 1)))
            )
            (ß BIGINT_OPS.inc(x))
        )

        (§ method Number dec(Number x)
            (§ let long val = x.longValue())
            (ß num(Numbers.dec(val)))
        )

        (§ method Number decP(Number x)
            (§ let long val = x.longValue())
            (§ if (ß val > Long.MIN_VALUE)
                (§ return (ß num(val - 1)))
            )
            (ß BIGINT_OPS.dec(x))
        )
    )

    (class-ns DoubleOps (§ extends OpsP)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            this
        )

        (§ method Ops opsWith(RatioOps x)
            this
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            this
        )

        (§ method boolean isZero(Number x)
            (ß (x.doubleValue() == 0))
        )

        (§ method boolean isPos(Number x)
            (ß (x.doubleValue() > 0))
        )

        (§ method boolean isNeg(Number x)
            (ß (x.doubleValue() < 0))
        )

        (§ method Number add(Number x, Number y)
            (ß Double.valueOf(x.doubleValue() + y.doubleValue()))
        )

        (§ method Number multiply(Number x, Number y)
            (ß Double.valueOf(x.doubleValue() * y.doubleValue()))
        )

        (§ method Number divide(Number x, Number y)
            (ß Double.valueOf(x.doubleValue() / y.doubleValue()))
        )

        (§ method Number quotient(Number x, Number y)
            (ß Numbers.quotient(x.doubleValue(), y.doubleValue()))
        )

        (§ method Number remainder(Number x, Number y)
            (ß Numbers.remainder(x.doubleValue(), y.doubleValue()))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß (x.doubleValue() == y.doubleValue()))
        )

        (§ method boolean lt(Number x, Number y)
            (ß (x.doubleValue() < y.doubleValue()))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (x.doubleValue() <= y.doubleValue()))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (x.doubleValue() >= y.doubleValue()))
        )

        (§ method Number negate(Number x)
            (ß Double.valueOf(-x.doubleValue()))
        )

        (§ method Number inc(Number x)
            (ß Double.valueOf(x.doubleValue() + 1))
        )

        (§ method Number dec(Number x)
            (ß Double.valueOf(x.doubleValue() - 1))
        )
    )

    (class-ns RatioOps (§ extends OpsP)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            this
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            (ß BIGDECIMAL_OPS)
        )

        (§ method boolean isZero(Number x)
            (§ let Ratio r = (Ratio) x)
            (ß (r.numerator.signum() == 0))
        )

        (§ method boolean isPos(Number x)
            (§ let Ratio r = (Ratio) x)
            (ß (r.numerator.signum() > 0))
        )

        (§ method boolean isNeg(Number x)
            (§ let Ratio r = (Ratio) x)
            (ß (r.numerator.signum() < 0))
        )

        (§ defn Number normalizeRet(Number ret, Number x, Number y)
            ret
        )

        (§ method Number add(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let Number ret = divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator)))
            (ß normalizeRet(ret, x, y))
        )

        (§ method Number multiply(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let Number ret = Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator)))
            (ß normalizeRet(ret, x, y))
        )

        (§ method Number divide(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let Number ret = Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator)))
            (ß normalizeRet(ret, x, y))
        )

        (§ method Number quotient(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))
            (ß normalizeRet(BigInt.fromBigInteger(q), x, y))
        )

        (§ method Number remainder(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))
            (§ let Number ret = Numbers.minus(x, Numbers.multiply(q, y)))
            (ß normalizeRet(ret, x, y))
        )

        (§ method boolean equiv(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (ß (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator)))
        )

        (§ method boolean lt(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (ß Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
        )

        (§ method boolean lte(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (ß Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
        )

        (§ method boolean gte(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (ß Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
        )

        (§ method Number negate(Number x)
            (§ let Ratio r = (Ratio) x)
            (ß new Ratio(r.numerator.negate(), r.denominator))
        )

        (§ method Number inc(Number x)
            (ß Numbers.add(x, 1))
        )

        (§ method Number dec(Number x)
            (ß Numbers.add(x, -1))
        )
    )

    (class-ns BigIntOps (§ extends OpsP)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            (ß RATIO_OPS)
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            (ß BIGDECIMAL_OPS)
        )

        (§ method boolean isZero(Number x)
            (§ let BigInt bx = toBigInt(x))
            (§ if (ß bx.bipart == nil)
                (§ return (ß (bx.lpart == 0)))
            )
            (ß (bx.bipart.signum() == 0))
        )

        (§ method boolean isPos(Number x)
            (§ let BigInt bx = toBigInt(x))
            (§ if (ß bx.bipart == nil)
                (§ return (ß (bx.lpart > 0)))
            )
            (ß (bx.bipart.signum() > 0))
        )

        (§ method boolean isNeg(Number x)
            (§ let BigInt bx = toBigInt(x))
            (§ if (ß bx.bipart == nil)
                (§ return (ß (bx.lpart < 0)))
            )
            (ß (bx.bipart.signum() < 0))
        )

        (§ method Number add(Number x, Number y)
            (ß toBigInt(x).add(toBigInt(y)))
        )

        (§ method Number multiply(Number x, Number y)
            (ß toBigInt(x).multiply(toBigInt(y)))
        )

        (§ method Number divide(Number x, Number y)
            (ß Numbers.divide(toBigInteger(x), toBigInteger(y)))
        )

        (§ method Number quotient(Number x, Number y)
            (ß toBigInt(x).quotient(toBigInt(y)))
        )

        (§ method Number remainder(Number x, Number y)
            (ß toBigInt(x).remainder(toBigInt(y)))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß toBigInt(x).equals(toBigInt(y)))
        )

        (§ method boolean lt(Number x, Number y)
            (ß toBigInt(x).lt(toBigInt(y)))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) <= 0))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) >= 0))
        )

        (§ method Number negate(Number x)
            (ß BigInt.fromBigInteger(toBigInteger(x).negate()))
        )

        (§ method Number inc(Number x)
            (§ let BigInteger bx = toBigInteger(x))
            (ß BigInt.fromBigInteger(bx.add(BigInteger.ONE)))
        )

        (§ method Number dec(Number x)
            (§ let BigInteger bx = toBigInteger(x))
            (ß BigInt.fromBigInteger(bx.subtract(BigInteger.ONE)))
        )
    )

    (class-ns BigDecimalOps (§ extends OpsP)
        (§ def Var MATH_CONTEXT = RT.MATH_CONTEXT)

        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            this
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            this
        )

        (§ method boolean isZero(Number x)
            (§ let BigDecimal bx = (BigDecimal) x)
            (ß (bx.signum() == 0))
        )

        (§ method boolean isPos(Number x)
            (§ let BigDecimal bx = (BigDecimal) x)
            (ß (bx.signum() > 0))
        )

        (§ method boolean isNeg(Number x)
            (§ let BigDecimal bx = (BigDecimal) x)
            (ß (bx.signum() < 0))
        )

        (§ method Number add(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (ß (mc == nil) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc))
        )

        (§ method Number multiply(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (ß (mc == nil) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc))
        )

        (§ method Number divide(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (ß (mc == nil) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc))
        )

        (§ method Number quotient(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (ß (mc == nil) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc))
        )

        (§ method Number remainder(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (ß (mc == nil) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0))
        )

        (§ method boolean lt(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0))
        )

        (§ method Number negate(Number x)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (ß (mc == nil) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc))
        )

        (§ method Number inc(Number x)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ let BigDecimal bx = (BigDecimal) x)
            (ß (mc == nil) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc))
        )

        (§ method Number dec(Number x)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ let BigDecimal bx = (BigDecimal) x)
            (ß (mc == nil) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc))
        )
    )

    (§ def LongOps LONG_OPS = new LongOps())
    (§ def DoubleOps DOUBLE_OPS = new DoubleOps())
    (§ def RatioOps RATIO_OPS = new RatioOps())
    (§ def BigIntOps BIGINT_OPS = new BigIntOps())
    (§ def BigDecimalOps BIGDECIMAL_OPS = new BigDecimalOps())

    (§ enum Category
        (§ item INTEGER),
        (§ item FLOATING),
        (§ item DECIMAL),
        (§ item RATIO)
    )

    (§ defn Ops ops(Object x)
        (§ let Class xc = x.getClass())

        (§ if (ß xc == Long.class)
            (ß LONG_OPS)
        )
        (§ elseif (ß xc == Double.class)
            (ß DOUBLE_OPS)
        )
        (§ elseif (ß xc == Integer.class)
            (ß LONG_OPS)
        )
        (§ elseif (ß xc == Float.class)
            (ß DOUBLE_OPS)
        )
        (§ elseif (ß xc == BigInt.class)
            (ß BIGINT_OPS)
        )
        (§ elseif (ß xc == BigInteger.class)
            (ß BIGINT_OPS)
        )
        (§ elseif (ß xc == Ratio.class)
            (ß RATIO_OPS)
        )
        (§ elseif (ß xc == BigDecimal.class)
            (ß BIGDECIMAL_OPS)
        )
        (§ else 
            (ß LONG_OPS)
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int hasheqFrom(Number x, Class xc)
        (§ if (ß xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE)))
            (§ let long lpart = x.longValue())
            (§ return (ß Murmur3.hashLong(lpart)))
        )
        (§ if (ß xc == BigDecimal.class)
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode.  Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (§ if (ß isZero(x))
                (§ return (ß BigDecimal.ZERO.hashCode()))
            )
            (§ else 
                (§ return (ß ((BigDecimal) x).stripTrailingZeros().hashCode()))
            )
        )
        (§ if (ß xc == Float.class && x.equals((§ float -0.0)))
            (§ return 0) ;; match 0.0f
        )
        (ß x.hashCode())
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int hasheq(Number x)
        (§ let Class xc = x.getClass())

        (§ if (ß xc == Long.class)
            (§ let long lpart = x.longValue())
            (§ return (ß Murmur3.hashLong(lpart)))
        )
        (§ if (ß xc == Double.class)
            (§ if (ß x.equals(-0.0))
                (§ return 0) ;; match 0.0
            )
            (§ return (ß x.hashCode()))
        )
        (ß hasheqFrom(x, xc))
    )

    (§ defn Category category(Object x)
        (§ let Class xc = x.getClass())

        (§ if (ß xc == Integer.class)
            (ß Category.INTEGER)
        )
        (§ elseif (ß xc == Double.class)
            (ß Category.FLOATING)
        )
        (§ elseif (ß xc == Long.class)
            (ß Category.INTEGER)
        )
        (§ elseif (ß xc == Float.class)
            (ß Category.FLOATING)
        )
        (§ elseif (ß xc == BigInt.class)
            (ß Category.INTEGER)
        )
        (§ elseif (ß xc == Ratio.class)
            (ß Category.RATIO)
        )
        (§ elseif (ß xc == BigDecimal.class)
            (ß Category.DECIMAL)
        )
        (§ else 
            (ß Category.INTEGER)
        )
    )

    (§ defn long bitOpsCast(Object x)
        (§ let Class xc = x.getClass())

        (§ if (ß xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
            (§ return (ß RT.longCast(x)))
        )
        ;; no bignums, no decimals
        (§ throw new IllegalArgumentException("bit operation not supported for: " + xc))
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn float[] float_array(int size, Object init)
        (§ let float[] ret = new float[size])
        (§ if (ß init instanceof Number)
            (§ let float f = ((Number) init).floatValue())
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = f)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).floatValue())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn float[] float_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new float[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let float[] ret = new float[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).floatValue())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn double[] double_array(int size, Object init)
        (§ let double[] ret = new double[size])
        (§ if (ß init instanceof Number)
            (§ let double f = ((Number) init).doubleValue())
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = f)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).doubleValue())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn double[] double_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new double[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let double[] ret = new double[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).doubleValue())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int[] int_array(int size, Object init)
        (§ let int[] ret = new int[size])
        (§ if (ß init instanceof Number)
            (§ let int f = ((Number) init).intValue())
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = f)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).intValue())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int[] int_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new int[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let int[] ret = new int[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).intValue())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn long[] long_array(int size, Object init)
        (§ let long[] ret = new long[size])
        (§ if (ß init instanceof Number)
            (§ let long f = ((Number) init).longValue())
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = f)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).longValue())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn long[] long_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new long[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let long[] ret = new long[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).longValue())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn short[] short_array(int size, Object init)
        (§ let short[] ret = new short[size])
        (§ if (ß init instanceof Short)
            (§ let short s = (Short) init)
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = s)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).shortValue())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn short[] short_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new short[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let short[] ret = new short[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).shortValue())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn char[] char_array(int size, Object init)
        (§ let char[] ret = new char[size])
        (§ if (ß init instanceof Character)
            (§ let char c = (Character) init)
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = c)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = (Character) s.first())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn char[] char_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new char[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let char[] ret = new char[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = (Character) s.first())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn byte[] byte_array(int size, Object init)
        (§ let byte[] ret = new byte[size])
        (§ if (ß init instanceof Byte)
            (§ let byte b = (Byte) init)
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = b)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).byteValue())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn byte[] byte_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new byte[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let byte[] ret = new byte[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = ((Number) s.first()).byteValue())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn boolean[] boolean_array(int size, Object init)
        (§ let boolean[] ret = new boolean[size])
        (§ if (ß init instanceof Boolean)
            (§ let boolean b = (Boolean) init)
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                (ß ret[i] = b)
            )
        )
        (§ else 
            (§ let ISeq s = RT.seq(init))
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = (Boolean)s.first())
            )
        )
        ret
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn boolean[] boolean_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new boolean[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let boolean[] ret = new boolean[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = (Boolean)s.first())
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn boolean[] booleans(Object array)
        (ß (boolean[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn byte[] bytes(Object array)
        (ß (byte[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn char[] chars(Object array)
        (ß (char[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn short[] shorts(Object array)
        (ß (short[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn float[] floats(Object array)
        (ß (float[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn double[] doubles(Object array)
        (ß (double[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int[] ints(Object array)
        (ß (int[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn long[] longs(Object array)
        (ß (long[]) array)
    )

    (§ defn Number num(Object x)
        (ß (Number) x)
    )

    (§ defn Number num(float x)
        (ß Float.valueOf(x))
    )

    (§ defn Number num(double x)
        (ß Double.valueOf(x))
    )

    (§ defn double add(double x, double y)
        (ß x + y)
    )

    (§ defn double addP(double x, double y)
        (ß x + y)
    )

    (§ defn double minus(double x, double y)
        (ß x - y)
    )

    (§ defn double minusP(double x, double y)
        (ß x - y)
    )

    (§ defn double minus(double x)
        (ß -x)
    )

    (§ defn double minusP(double x)
        (ß -x)
    )

    (§ defn double inc(double x)
        (ß x + 1)
    )

    (§ defn double incP(double x)
        (ß x + 1)
    )

    (§ defn double dec(double x)
        (ß x - 1)
    )

    (§ defn double decP(double x)
        (ß x - 1)
    )

    (§ defn double multiply(double x, double y)
        (ß x * y)
    )

    (§ defn double multiplyP(double x, double y)
        (ß x * y)
    )

    (§ defn double divide(double x, double y)
        (ß x / y)
    )

    (§ defn boolean equiv(double x, double y)
        (ß (x == y))
    )

    (§ defn boolean lt(double x, double y)
        (ß (x < y))
    )

    (§ defn boolean lte(double x, double y)
        (ß (x <= y))
    )

    (§ defn boolean gt(double x, double y)
        (ß (x > y))
    )

    (§ defn boolean gte(double x, double y)
        (ß (x >= y))
    )

    (§ defn boolean isPos(double x)
        (ß (x > 0))
    )

    (§ defn boolean isNeg(double x)
        (ß (x < 0))
    )

    (§ defn boolean isZero(double x)
        (ß (x == 0))
    )

    (§ defn int throwIntOverflow()
        (§ throw new ArithmeticException("integer overflow"))
    )

    (§ defn int unchecked_int_add(int x, int y)
        (ß x + y)
    )

    (§ defn int unchecked_int_subtract(int x, int y)
        (ß x - y)
    )

    (§ defn int unchecked_int_negate(int x)
        (ß -x)
    )

    (§ defn int unchecked_int_inc(int x)
        (ß x + 1)
    )

    (§ defn int unchecked_int_dec(int x)
        (ß x - 1)
    )

    (§ defn int unchecked_int_multiply(int x, int y)
        (ß x * y)
    )

    (§ defn long not(Object x)
        (ß not(bitOpsCast(x)))
    )

    (§ defn long not(long x)
        (ß ~x)
    )

    (§ defn long and(Object x, Object y)
        (ß and(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long and(Object x, long y)
        (ß and(bitOpsCast(x), y))
    )

    (§ defn long and(long x, Object y)
        (ß and(x, bitOpsCast(y)))
    )

    (§ defn long and(long x, long y)
        (ß x & y)
    )

    (§ defn long or(Object x, Object y)
        (ß or(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long or(Object x, long y)
        (ß or(bitOpsCast(x), y))
    )

    (§ defn long or(long x, Object y)
        (ß or(x, bitOpsCast(y)))
    )

    (§ defn long or(long x, long y)
        (ß x | y)
    )

    (§ defn long xor(Object x, Object y)
        (ß xor(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long xor(Object x, long y)
        (ß xor(bitOpsCast(x), y))
    )

    (§ defn long xor(long x, Object y)
        (ß xor(x, bitOpsCast(y)))
    )

    (§ defn long xor(long x, long y)
        (ß x :xor y)
    )

    (§ defn long andNot(Object x, Object y)
        (ß andNot(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long andNot(Object x, long y)
        (ß andNot(bitOpsCast(x), y))
    )

    (§ defn long andNot(long x, Object y)
        (ß andNot(x, bitOpsCast(y)))
    )

    (§ defn long andNot(long x, long y)
        (ß x & ~y)
    )

    (§ defn long clearBit(Object x, Object y)
        (ß clearBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long clearBit(Object x, long y)
        (ß clearBit(bitOpsCast(x), y))
    )

    (§ defn long clearBit(long x, Object y)
        (ß clearBit(x, bitOpsCast(y)))
    )

    (§ defn long clearBit(long x, long n)
        (ß x & ~(1 << n))
    )

    (§ defn long setBit(Object x, Object y)
        (ß setBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long setBit(Object x, long y)
        (ß setBit(bitOpsCast(x), y))
    )

    (§ defn long setBit(long x, Object y)
        (ß setBit(x, bitOpsCast(y)))
    )

    (§ defn long setBit(long x, long n)
        (ß x | (1 << n))
    )

    (§ defn long flipBit(Object x, Object y)
        (ß flipBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long flipBit(Object x, long y)
        (ß flipBit(bitOpsCast(x), y))
    )

    (§ defn long flipBit(long x, Object y)
        (ß flipBit(x, bitOpsCast(y)))
    )

    (§ defn long flipBit(long x, long n)
        (ß x :xor (1 << n))
    )

    (§ defn boolean testBit(Object x, Object y)
        (ß testBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn boolean testBit(Object x, long y)
        (ß testBit(bitOpsCast(x), y))
    )

    (§ defn boolean testBit(long x, Object y)
        (ß testBit(x, bitOpsCast(y)))
    )

    (§ defn boolean testBit(long x, long n)
        (ß ((x & (1 << n)) != 0))
    )

    (§ defn int unchecked_int_divide(int x, int y)
        (ß x / y)
    )

    (§ defn int unchecked_int_remainder(int x, int y)
        (ß x % y)
    )

    (§ defn Number num(long x)
        (ß Long.valueOf(x))
    )

    (§ defn long unchecked_add(long x, long y)
        (ß x + y)
    )

    (§ defn long unchecked_minus(long x, long y)
        (ß x - y)
    )

    (§ defn long unchecked_multiply(long x, long y)
        (ß x * y)
    )

    (§ defn long unchecked_minus(long x)
        (ß -x)
    )

    (§ defn long unchecked_inc(long x)
        (ß x + 1)
    )

    (§ defn long unchecked_dec(long x)
        (ß x - 1)
    )

    (§ defn Number unchecked_add(Object x, Object y)
        (ß add(x, y))
    )

    (§ defn Number unchecked_minus(Object x, Object y)
        (ß minus(x, y))
    )

    (§ defn Number unchecked_multiply(Object x, Object y)
        (ß multiply(x, y))
    )

    (§ defn Number unchecked_minus(Object x)
        (ß minus(x))
    )

    (§ defn Number unchecked_inc(Object x)
        (ß inc(x))
    )

    (§ defn Number unchecked_dec(Object x)
        (ß dec(x))
    )

    (§ defn double unchecked_add(double x, double y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(double x, double y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(double x, double y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_minus(double x)
        (ß minus(x))
    )

    (§ defn double unchecked_inc(double x)
        (ß inc(x))
    )

    (§ defn double unchecked_dec(double x)
        (ß dec(x))
    )

    (§ defn double unchecked_add(double x, Object y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(double x, Object y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(double x, Object y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_add(Object x, double y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(Object x, double y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(Object x, double y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_add(double x, long y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(double x, long y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(double x, long y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_add(long x, double y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(long x, double y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(long x, double y)
        (ß multiply(x, y))
    )

    (§ defn Number unchecked_add(long x, Object y)
        (ß add(x, y))
    )

    (§ defn Number unchecked_minus(long x, Object y)
        (ß minus(x, y))
    )

    (§ defn Number unchecked_multiply(long x, Object y)
        (ß multiply(x, y))
    )

    (§ defn Number unchecked_add(Object x, long y)
        (ß add(x, y))
    )

    (§ defn Number unchecked_minus(Object x, long y)
        (ß minus(x, y))
    )

    (§ defn Number unchecked_multiply(Object x, long y)
        (ß multiply(x, y))
    )

    (§ defn Number quotient(double x, Object y)
        (ß quotient((Object)x, y))
    )

    (§ defn Number quotient(Object x, double y)
        (ß quotient(x, (Object)y))
    )

    (§ defn Number quotient(long x, Object y)
        (ß quotient((Object)x, y))
    )

    (§ defn Number quotient(Object x, long y)
        (ß quotient(x, (Object)y))
    )

    (§ defn double quotient(double x, long y)
        (ß quotient(x, (double)y))
    )

    (§ defn double quotient(long x, double y)
        (ß quotient((double)x, y))
    )

    (§ defn Number remainder(double x, Object y)
        (ß remainder((Object)x, y))
    )

    (§ defn Number remainder(Object x, double y)
        (ß remainder(x, (Object)y))
    )

    (§ defn Number remainder(long x, Object y)
        (ß remainder((Object)x, y))
    )

    (§ defn Number remainder(Object x, long y)
        (ß remainder(x, (Object)y))
    )

    (§ defn double remainder(double x, long y)
        (ß remainder(x, (double)y))
    )

    (§ defn double remainder(long x, double y)
        (ß remainder((double)x, y))
    )

    (§ defn long add(long x, long y)
        (§ let long ret = x + y)
        (§ if (ß (ret :xor x) < 0 && (ret :xor y) < 0)
            (§ return (ß throwIntOverflow()))
        )
        ret
    )

    (§ defn Number addP(long x, long y)
        (§ let long ret = x + y)
        (§ if (ß (ret :xor x) < 0 && (ret :xor y) < 0)
            (§ return (ß addP((Number)x, (Number)y)))
        )
        (ß num(ret))
    )

    (§ defn long minus(long x, long y)
        (§ let long ret = x - y)
        (§ if (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
            (§ return (ß throwIntOverflow()))
        )
        ret
    )

    (§ defn Number minusP(long x, long y)
        (§ let long ret = x - y)
        (§ if (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
            (§ return (ß minusP((Number)x, (Number)y)))
        )
        (ß num(ret))
    )

    (§ defn long minus(long x)
        (§ if (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß -x)
    )

    (§ defn Number minusP(long x)
        (§ if (ß x == Long.MIN_VALUE)
            (§ return (ß BigInt.fromBigInteger(BigInteger.valueOf(x).negate())))
        )
        (ß num(-x))
    )

    (§ defn long inc(long x)
        (§ if (ß x == Long.MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x + 1)
    )

    (§ defn Number incP(long x)
        (§ if (ß x == Long.MAX_VALUE)
            (§ return (ß BIGINT_OPS.inc(x)))
        )
        (ß num(x + 1))
    )

    (§ defn long dec(long x)
        (§ if (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x - 1)
    )

    (§ defn Number decP(long x)
        (§ if (ß x == Long.MIN_VALUE)
            (§ return (ß BIGINT_OPS.dec(x)))
        )
        (ß num(x - 1))
    )

    (§ defn long multiply(long x, long y)
        (§ if (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (§ let long ret = x * y)
        (§ if (ß y != 0 && ret/y != x)
            (§ return (ß throwIntOverflow()))
        )
        ret
    )

    (§ defn Number multiplyP(long x, long y)
        (§ if (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß multiplyP((Number)x, (Number)y)))
        )
        (§ let long ret = x * y)
        (§ if (ß y != 0 && ret/y != x)
            (§ return (ß multiplyP((Number)x, (Number)y)))
        )
        (ß num(ret))
    )

    (§ defn long quotient(long x, long y)
        (ß x / y)
    )

    (§ defn long remainder(long x, long y)
        (ß x % y)
    )

    (§ defn boolean equiv(long x, long y)
        (ß (x == y))
    )

    (§ defn boolean lt(long x, long y)
        (ß (x < y))
    )

    (§ defn boolean lte(long x, long y)
        (ß (x <= y))
    )

    (§ defn boolean gt(long x, long y)
        (ß (x > y))
    )

    (§ defn boolean gte(long x, long y)
        (ß (x >= y))
    )

    (§ defn boolean isPos(long x)
        (ß (x > 0))
    )

    (§ defn boolean isNeg(long x)
        (ß (x < 0))
    )

    (§ defn boolean isZero(long x)
        (ß (x == 0))
    )

    ;; overload resolution

    (§ defn Number add(long x, Object y)
        (ß add((Object)x, y))
    )

    (§ defn Number add(Object x, long y)
        (ß add(x, (Object)y))
    )

    (§ defn Number addP(long x, Object y)
        (ß addP((Object)x, y))
    )

    (§ defn Number addP(Object x, long y)
        (ß addP(x, (Object)y))
    )

    (§ defn double add(double x, Object y)
        (ß add(x, ((Number)y).doubleValue()))
    )

    (§ defn double add(Object x, double y)
        (ß add(((Number)x).doubleValue(), y))
    )

    (§ defn double add(double x, long y)
        (ß x + y)
    )

    (§ defn double add(long x, double y)
        (ß x + y)
    )

    (§ defn double addP(double x, Object y)
        (ß addP(x, ((Number)y).doubleValue()))
    )

    (§ defn double addP(Object x, double y)
        (ß addP(((Number)x).doubleValue(), y))
    )

    (§ defn double addP(double x, long y)
        (ß x + y)
    )

    (§ defn double addP(long x, double y)
        (ß x + y)
    )

    (§ defn Number minus(long x, Object y)
        (ß minus((Object)x, y))
    )

    (§ defn Number minus(Object x, long y)
        (ß minus(x, (Object)y))
    )

    (§ defn Number minusP(long x, Object y)
        (ß minusP((Object)x, y))
    )

    (§ defn Number minusP(Object x, long y)
        (ß minusP(x, (Object)y))
    )

    (§ defn double minus(double x, Object y)
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn double minus(Object x, double y)
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn double minus(double x, long y)
        (ß x - y)
    )

    (§ defn double minus(long x, double y)
        (ß x - y)
    )

    (§ defn double minusP(double x, Object y)
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn double minusP(Object x, double y)
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn double minusP(double x, long y)
        (ß x - y)
    )

    (§ defn double minusP(long x, double y)
        (ß x - y)
    )

    (§ defn Number multiply(long x, Object y)
        (ß multiply((Object)x, y))
    )

    (§ defn Number multiply(Object x, long y)
        (ß multiply(x, (Object)y))
    )

    (§ defn Number multiplyP(long x, Object y)
        (ß multiplyP((Object)x, y))
    )

    (§ defn Number multiplyP(Object x, long y)
        (ß multiplyP(x, (Object)y))
    )

    (§ defn double multiply(double x, Object y)
        (ß multiply(x, ((Number)y).doubleValue()))
    )

    (§ defn double multiply(Object x, double y)
        (ß multiply(((Number)x).doubleValue(), y))
    )

    (§ defn double multiply(double x, long y)
        (ß x * y)
    )

    (§ defn double multiply(long x, double y)
        (ß x * y)
    )

    (§ defn double multiplyP(double x, Object y)
        (ß multiplyP(x, ((Number)y).doubleValue()))
    )

    (§ defn double multiplyP(Object x, double y)
        (ß multiplyP(((Number)x).doubleValue(), y))
    )

    (§ defn double multiplyP(double x, long y)
        (ß x * y)
    )

    (§ defn double multiplyP(long x, double y)
        (ß x * y)
    )

    (§ defn Number divide(long x, Object y)
        (ß divide((Object)x, y))
    )

    (§ defn Number divide(Object x, long y)
        (ß divide(x, (Object)y))
    )

    (§ defn double divide(double x, Object y)
        (ß x / ((Number)y).doubleValue())
    )

    (§ defn double divide(Object x, double y)
        (ß ((Number)x).doubleValue() / y)
    )

    (§ defn double divide(double x, long y)
        (ß x / y)
    )

    (§ defn double divide(long x, double y)
        (ß x / y)
    )

    (§ defn Number divide(long x, long y)
        (ß divide((Number)x, (Number)y))
    )

    (§ defn boolean lt(long x, Object y)
        (ß lt((Object)x, y))
    )

    (§ defn boolean lt(Object x, long y)
        (ß lt(x, (Object)y))
    )

    (§ defn boolean lt(double x, Object y)
        (ß (x < ((Number)y).doubleValue()))
    )

    (§ defn boolean lt(Object x, double y)
        (ß (((Number)x).doubleValue() < y))
    )

    (§ defn boolean lt(double x, long y)
        (ß (x < y))
    )

    (§ defn boolean lt(long x, double y)
        (ß (x < y))
    )

    (§ defn boolean lte(long x, Object y)
        (ß lte((Object)x, y))
    )

    (§ defn boolean lte(Object x, long y)
        (ß lte(x, (Object)y))
    )

    (§ defn boolean lte(double x, Object y)
        (ß (x <= ((Number)y).doubleValue()))
    )

    (§ defn boolean lte(Object x, double y)
        (ß (((Number)x).doubleValue() <= y))
    )

    (§ defn boolean lte(double x, long y)
        (ß (x <= y))
    )

    (§ defn boolean lte(long x, double y)
        (ß (x <= y))
    )

    (§ defn boolean gt(long x, Object y)
        (ß gt((Object)x, y))
    )

    (§ defn boolean gt(Object x, long y)
        (ß gt(x, (Object)y))
    )

    (§ defn boolean gt(double x, Object y)
        (ß (x > ((Number)y).doubleValue()))
    )

    (§ defn boolean gt(Object x, double y)
        (ß (((Number)x).doubleValue() > y))
    )

    (§ defn boolean gt(double x, long y)
        (ß (x > y))
    )

    (§ defn boolean gt(long x, double y)
        (ß (x > y))
    )

    (§ defn boolean gte(long x, Object y)
        (ß gte((Object)x, y))
    )

    (§ defn boolean gte(Object x, long y)
        (ß gte(x, (Object)y))
    )

    (§ defn boolean gte(double x, Object y)
        (ß (x >= ((Number)y).doubleValue()))
    )

    (§ defn boolean gte(Object x, double y)
        (ß (((Number)x).doubleValue() >= y))
    )

    (§ defn boolean gte(double x, long y)
        (ß (x >= y))
    )

    (§ defn boolean gte(long x, double y)
        (ß (x >= y))
    )

    (§ defn boolean equiv(long x, Object y)
        (ß equiv((Object)x, y))
    )

    (§ defn boolean equiv(Object x, long y)
        (ß equiv(x, (Object)y))
    )

    (§ defn boolean equiv(double x, Object y)
        (ß (x == ((Number)y).doubleValue()))
    )

    (§ defn boolean equiv(Object x, double y)
        (ß (((Number)x).doubleValue() == y))
    )

    (§ defn boolean equiv(double x, long y)
        (ß (x == y))
    )

    (§ defn boolean equiv(long x, double y)
        (ß (x == y))
    )

    (§ defn boolean isNaN(Object x)
        (ß (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN())
    )

    (§ defn double max(double x, double y)
        (ß Math.max(x, y))
    )

    (§ defn Object max(double x, long y)
        (§ if (ß Double.isNaN(x))
            (§ return x)
        )
        (§ if (ß x > y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object max(double x, Object y)
        (§ if (ß Double.isNaN(x))
            (§ return x)
        )
        (§ elseif (ß isNaN(y))
            (§ return y)
        )
        (§ if (ß x > ((Number)y).doubleValue())
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object max(long x, double y)
        (§ if (ß Double.isNaN(y))
            (§ return y)
        )
        (§ if (ß x > y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn long max(long x, long y)
        (§ if (ß x > y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object max(long x, Object y)
        (§ if (ß isNaN(y))
            (§ return y)
        )
        (§ if (ß gt(x, y))
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object max(Object x, long y)
        (§ if (ß isNaN(x))
            (§ return x)
        )
        (§ if (ß gt(x, y))
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object max(Object x, double y)
        (§ if (ß isNaN(x))
            (§ return x)
        )
        (§ elseif (ß Double.isNaN(y))
            (§ return y)
        )
        (§ if (ß ((Number)x).doubleValue() > y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object max(Object x, Object y)
        (§ if (ß isNaN(x))
            (§ return x)
        )
        (§ elseif (ß isNaN(y))
            (§ return y)
        )
        (§ if (ß gt(x, y))
            x
        )
        (§ else 
            y
        )
    )

    (§ defn double min(double x, double y)
        (ß Math.min(x, y))
    )

    (§ defn Object min(double x, long y)
        (§ if (ß Double.isNaN(x))
            (§ return x)
        )
        (§ if (ß x < y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object min(double x, Object y)
        (§ if (ß Double.isNaN(x))
            (§ return x)
        )
        (§ elseif (ß isNaN(y))
            (§ return y)
        )
        (§ if (ß x < ((Number)y).doubleValue())
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object min(long x, double y)
        (§ if (ß Double.isNaN(y))
            (§ return y)
        )
        (§ if (ß x < y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn long min(long x, long y)
        (§ if (ß x < y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object min(long x, Object y)
        (§ if (ß isNaN(y))
            (§ return y)
        )
        (§ if (ß lt(x, y))
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object min(Object x, long y)
        (§ if (ß isNaN(x))
            (§ return x)
        )
        (§ if (ß lt(x, y))
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object min(Object x, double y)
        (§ if (ß isNaN(x))
            (§ return x)
        )
        (§ elseif (ß Double.isNaN(y))
            (§ return y)
        )
        (§ if (ß ((Number)x).doubleValue() < y)
            x
        )
        (§ else 
            y
        )
    )

    (§ defn Object min(Object x, Object y)
        (§ if (ß isNaN(x))
            (§ return x)
        )
        (§ elseif (ß isNaN(y))
            (§ return y)
        )
        (§ if (ß lt(x, y))
            x
        )
        (§ else 
            y
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (§ field IPersistentMap _meta)

    (§ constructor Obj(IPersistentMap meta)
        (ß this._meta = meta)
        this
    )

    (§ constructor Obj()
        (ß _meta = nil)
        this
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (§ abstract Obj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ field Object[] array)
    (§ def int HASHTABLE_THRESHOLD = 16)

    (§ def PersistentArrayMap EMPTY = new PersistentArrayMap())
    (§ field- IPersistentMap _meta)

    (§ defn IPersistentMap create(Map other)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ doseq [#_"Object" o (ß other.entrySet())]
            (§ let Map.Entry e = (Entry) o)
            (ß ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (ß ret.persistent())
    )

    #_protected
    (§ constructor PersistentArrayMap()
        (ß this.array = new Object[] (§))
        (ß this._meta = nil)
        this
    )

    (§ method PersistentArrayMap withMeta(IPersistentMap meta)
        (ß new PersistentArrayMap(meta, array))
    )

    (§ method PersistentArrayMap create(Object... init)
        (ß new PersistentArrayMap(meta(), init))
    )

    (§ method IPersistentMap createHT(Object[] init)
        (ß PersistentHashMap.create(meta(), init))
    )

    (§ defn PersistentArrayMap createWithCheck(Object[] init)
        (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
            (§ loop-when-recur [(ß int j = i + 2)] (ß j < init.length) [(ß j += 2)]
                (§ if (ß equalKey(init[i], init[j]))
                    (§ throw new IllegalArgumentException("Duplicate key: " + init[i]))
                )
            )
        )
        (ß new PersistentArrayMap(init))
    )

    (§ defn PersistentArrayMap createAsIfByAssoc(Object[] init)
        (§ if (ß (init.length & 1) == 1)
            (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1])))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (§ let int n = 0)
        (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
            (§ let boolean duplicateKey = false)
            (§ loop-when-recur [(ß int j = 0)] (ß j < i) [(ß j += 2)]
                (§ if (ß equalKey(init[i], init[j]))
                    (ß duplicateKey = true)
                    (§ break )
                )
            )
            (§ if (ß !duplicateKey)
                (ß n += 2)
            )
        )
        (§ if (ß n < init.length)
            ;; Create a new shorter array with unique keys, and
            ;; the last value associated with each key.  To behave
            ;; like assoc, the first occurrence of each key must
            ;; be used, since its metadata may be different than
            ;; later equal keys.
            (§ let Object[] nodups = new Object[n])
            (§ let int m = 0)
            (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (§ let boolean duplicateKey = false)
                (§ loop-when-recur [(ß int j = 0)] (ß j < m) [(ß j += 2)]
                    (§ if (ß equalKey(init[i], nodups[j]))
                        (ß duplicateKey = true)
                        (§ break )
                    )
                )
                (§ if (ß !duplicateKey)
                    (§ let int j)
                    (§ loop-when-recur [(ß j = init.length - 2)] (ß j >= i) [(ß j -= 2)]
                        (§ if (ß equalKey(init[i], init[j]))
                            (§ break )
                        )
                    )
                    (ß nodups[m] = init[i])
                    (ß nodups[m + 1] = init[j + 1])
                    (ß m += 2)
                )
            )
            (§ if (ß m != n)
                (§ throw new IllegalArgumentException("Internal error: m=" + m))
            )
            (ß init = nodups)
        )
        (ß new PersistentArrayMap(init))
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ constructor PersistentArrayMap(Object[] init)
        (ß this.array = init)
        (ß this._meta = nil)
        this
    )

    (§ constructor PersistentArrayMap(IPersistentMap meta, Object[] init)
        (ß this._meta = meta)
        (ß this.array = init)
        this
    )

    (§ method int count()
        (ß array.length / 2)
    )

    (§ method boolean containsKey(Object key)
        (ß (indexOf(key) >= 0))
    )

    (§ method IMapEntry entryAt(Object key)
        (§ let int i = indexOf(key))
        (§ if (ß i >= 0)
            (§ return (ß (IMapEntry) MapEntry.create(array[i], array[i + 1])))
        )
        nil
    )

    (§ method IPersistentMap assocEx(Object key, Object val)
        (§ let int i = indexOf(key))
        (§ let Object[] newArray)
        (§ if (ß i >= 0)
            (§ throw Util.runtimeException("Key already present"))
        )
        (§ else  ;; didn't have key, grow
            (§ if (ß array.length > HASHTABLE_THRESHOLD)
                (§ return (ß createHT(array).assocEx(key, val)))
            )
            (ß newArray = new Object[array.length + 2])
            (§ if (ß array.length > 0)
                (ß System.arraycopy(array, 0, newArray, 2, array.length))
            )
            (ß newArray[0] = key)
            (ß newArray[1] = val)
        )
        (ß create(newArray))
    )

    (§ method IPersistentMap assoc(Object key, Object val)
        (§ let int i = indexOf(key))
        (§ let Object[] newArray)
        (§ if (ß i >= 0) ;; already have key, same-sized replacement
            (§ if (ß array[i + 1] == val) ;; no change, no op
                (§ return this)
            )
            (ß newArray = array.clone())
            (ß newArray[i + 1] = val)
        )
        (§ else  ;; didn't have key, grow
            (§ if (ß array.length > HASHTABLE_THRESHOLD)
                (§ return (ß createHT(array).assoc(key, val)))
            )
            (ß newArray = new Object[array.length + 2])
            (§ if (ß array.length > 0)
                (ß System.arraycopy(array, 0, newArray, 0, array.length))
            )
            (ß newArray[newArray.length - 2] = key)
            (ß newArray[newArray.length - 1] = val)
        )
        (ß create(newArray))
    )

    (§ method IPersistentMap without(Object key)
        (§ let int i = indexOf(key))
        (§ if (ß i >= 0) ;; have key, will remove
            (§ let int newlen = array.length - 2)
            (§ if (ß newlen == 0)
                (§ return (ß empty()))
            )
            (§ let Object[] newArray = new Object[newlen])
            (ß System.arraycopy(array, 0, newArray, 0, i))
            (ß System.arraycopy(array, i + 2, newArray, i, newlen - i))
            (§ return (ß create(newArray)))
        )
        ;; don't have key, no op
        this
    )

    (§ method IPersistentMap empty()
        (ß (IPersistentMap) EMPTY.withMeta(meta()))
    )

    (§ method Object valAt(Object key, Object notFound)
        (§ let int i = indexOf(key))
        (§ if (ß i >= 0)
            (§ return (ß array[i + 1]))
        )
        notFound
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method int capacity()
        (ß count())
    )

    (§ method- int indexOfObject(Object key)
        (§ let Util.EquivPred ep = Util.equivPred(key))
        (§ loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
            (§ if (ß ep.equiv(key, array[i]))
                (§ return i)
            )
        )
        -1
    )

    (§ method- int indexOf(Object key)
        (§ if (ß key instanceof Keyword)
            (§ loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                (§ if (ß key == array[i])
                    (§ return i)
                )
            )
            -1
        )
        (§ else 
            (ß indexOfObject(key))
        )
    )

    (§ defn boolean equalKey(Object k1, Object k2)
        (§ if (ß k1 instanceof Keyword)
            (§ return (ß (k1 == k2)))
        )
        (ß Util.equiv(k1, k2))
    )

    (§ method Iterator iterator()
        (ß new Iter(array, APersistentMap.MAKE_ENTRY))
    )

    (§ method Iterator keyIterator()
        (ß new Iter(array, APersistentMap.MAKE_KEY))
    )

    (§ method Iterator valIterator()
        (ß new Iter(array, APersistentMap.MAKE_VAL))
    )

    (§ method ISeq seq()
        (§ if (ß array.length > 0)
            (§ return (ß new Seq(array, 0)))
        )
        nil
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (class-ns Seq (§ extends ASeq) (§ implements Counted)
        (§ field Object[] array)
        (§ field int i)

        (§ constructor Seq(Object[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ constructor Seq(IPersistentMap meta, Object[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        (§ method ISeq next()
            (§ if (ß i + 2 < array.length)
                (§ return (ß new Seq(array, i + 2)))
            )
            nil
        )

        (§ method int count()
            (ß (array.length - i) / 2)
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (ß new Seq(meta, array, i))
        )
    )

    (class-ns Iter (§ implements Iterator)
        (§ field IFn f)
        (§ field Object[] array)
        (§ field int i)

        ;; for iterator
        (§ constructor Iter(Object[] array, IFn f)
            (§ this(array, -2, f))
            this
        )

        ;; for entryAt
        (§ constructor Iter(Object[] array, int i, IFn f)
            (ß this.array = array)
            (ß this.i = i)
            (ß this.f = f)
            this
        )

        (§ method boolean hasNext()
            (ß (i < array.length - 2))
        )

        (§ method Object next()
            (§ try 
                (ß i += 2)
                (ß f.invoke(array[i], array[i + 1]))
            )
            (§ catch (ß IndexOutOfBoundsException e)
                (§ throw new NoSuchElementException())
            )
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    (§ method Object kvreduce(IFn f, Object init)
        (§ loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
            (ß init = f.invoke(init, array[i], array[i + 1]))
            (§ if (ß RT.isReduced(init))
                (§ return (ß ((IDeref)init).deref()))
            )
        )
        init
    )

    (§ method ITransientMap asTransient()
        (ß new TransientArrayMap(array))
    )

    (class-ns TransientArrayMap (§ extends ATransientMap)
        #_volatile
        (§ field int len)
        (§ field Object[] array)
        #_volatile
        (§ field Thread owner)

        (§ constructor TransientArrayMap(Object[] array)
            (ß this.owner = Thread.currentThread())
            (ß this.array = new Object[Math.max(HASHTABLE_THRESHOLD, array.length)])
            (ß System.arraycopy(array, 0, this.array, 0, array.length))
            (ß this.len = array.length)
            this
        )

        (§ method- int indexOf(Object key)
            (§ loop-when-recur [(ß int i = 0)] (ß i < len) [(ß i += 2)]
                (§ if (ß equalKey(array[i], key))
                    (§ return i)
                )
            )
            -1
        )

        (§ method ITransientMap doAssoc(Object key, Object val)
            (§ let int i = indexOf(key))
            (§ if (ß i >= 0) ;; already have key,
                (§ if (ß array[i + 1] != val) ;; no change, no op
                    (ß array[i + 1] = val)
                )
            )
            (§ else  ;; didn't have key, grow
                (§ if (ß len >= array.length)
                    (§ return (ß PersistentHashMap.create(array).asTransient().assoc(key, val)))
                )
                (ß array[len++] = key)
                (ß array[len++] = val)
            )
            this
        )

        (§ method ITransientMap doWithout(Object key)
            (§ let int i = indexOf(key))
            (§ if (ß i >= 0) ;; have key, will remove
                (§ if (ß len >= 2)
                    (ß array[i] = array[len - 2])
                    (ß array[i + 1] = array[len - 1])
                )
                (ß len -= 2)
            )
            this
        )

        (§ method Object doValAt(Object key, Object notFound)
            (§ let int i = indexOf(key))
            (§ if (ß i >= 0)
                (§ return (ß array[i + 1]))
            )
            notFound
        )

        (§ method int doCount()
            (ß len / 2)
        )

        (§ method IPersistentMap doPersistent()
            (ß ensureEditable())
            (ß owner = nil)
            (§ let Object[] a = new Object[len])
            (ß System.arraycopy(array, 0, a, 0, len))
            (ß new PersistentArrayMap(a))
        )

        (§ method void ensureEditable()
            (§ if (ß owner == nil)
                (§ throw new IllegalAccessError("Transient used after persistent! call"))
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ field int count)
    (§ field INode root)
    (§ field boolean hasNull)
    (§ field Object nullValue)
    (§ field IPersistentMap _meta)

    (§ def PersistentHashMap EMPTY = new PersistentHashMap(0, nil, false, nil))
    (§ def- Object NOT_FOUND = new Object())

    (§ defn IPersistentMap create(Map other)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ doseq [#_"Object" o (ß other.entrySet())]
            (§ let Map.Entry e = (Entry) o)
            (ß ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (ß ret.persistent())
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn PersistentHashMap create(Object... init)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
            (ß ret = ret.assoc(init[i], init[i + 1]))
        )
        (ß (PersistentHashMap) ret.persistent())
    )

    (§ defn PersistentHashMap createWithCheck(Object... init)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
            (ß ret = ret.assoc(init[i], init[i + 1]))
            (§ if (ß ret.count() != i / 2 + 1)
                (§ throw new IllegalArgumentException("Duplicate key: " + init[i]))
            )
        )
        (ß (PersistentHashMap) ret.persistent())
    )

    (§ defn PersistentHashMap create(ISeq items)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
            (§ if (ß items.next() == nil)
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (ß ret = ret.assoc(items.first(), RT.second(items)))
        )
        (ß (PersistentHashMap) ret.persistent())
    )

    (§ defn PersistentHashMap createWithCheck(ISeq items)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß items != nil) [(ß items = items.next().next(), ++i)]
            (§ if (ß items.next() == nil)
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (ß ret = ret.assoc(items.first(), RT.second(items)))
            (§ if (ß ret.count() != i + 1)
                (§ throw new IllegalArgumentException("Duplicate key: " + items.first()))
            )
        )
        (ß (PersistentHashMap) ret.persistent())
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn PersistentHashMap create(IPersistentMap meta, Object... init)
        (ß create(init).withMeta(meta))
    )

    (§ constructor PersistentHashMap(int count, INode root, boolean hasNull, Object nullValue)
        (ß this.count = count)
        (ß this.root = root)
        (ß this.hasNull = hasNull)
        (ß this.nullValue = nullValue)
        (ß this._meta = nil)
        this
    )

    (§ constructor PersistentHashMap(IPersistentMap meta, int count, INode root, boolean hasNull, Object nullValue)
        (ß this._meta = meta)
        (ß this.count = count)
        (ß this.root = root)
        (ß this.hasNull = hasNull)
        (ß this.nullValue = nullValue)
        this
    )

    (§ defn int hash(Object k)
        (ß Util.hasheq(k))
    )

    (§ method boolean containsKey(Object key)
        (§ if (ß key == nil)
            (§ return hasNull)
        )
        (ß (root != nil) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false)
    )

    (§ method IMapEntry entryAt(Object key)
        (§ if (ß key == nil)
            (§ return (ß hasNull ? (IMapEntry) MapEntry.create(nil, nullValue) :or nil))
        )
        (ß (root != nil) ? root.find(0, hash(key), key) :or nil)
    )

    (§ method IPersistentMap assoc(Object key, Object val)
        (§ if (ß key == nil)
            (§ if (ß hasNull && val == nullValue)
                (§ return this)
            )
            (§ return (ß new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)))
        )
        (§ let Box addedLeaf = new Box(nil))
        (§ let INode newroot = ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf))
        (§ if (ß newroot == root)
            (§ return this)
        )
        (ß new PersistentHashMap(meta(), (addedLeaf.val == nil) ? count :or count + 1, newroot, hasNull, nullValue))
    )

    (§ method Object valAt(Object key, Object notFound)
        (§ if (ß key == nil)
            (§ return (ß hasNull ? nullValue :or notFound))
        )
        (ß (root != nil) ? root.find(0, hash(key), key, notFound) :or notFound)
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method IPersistentMap assocEx(Object key, Object val)
        (§ if (ß containsKey(key))
            (§ throw Util.runtimeException("Key already present"))
        )
        (ß assoc(key, val))
    )

    (§ method IPersistentMap without(Object key)
        (§ if (ß key == nil)
            (§ return (ß hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        (§ if (ß root == nil)
            (§ return this)
        )
        (§ let INode newroot = root.without(0, hash(key), key))
        (§ if (ß newroot == root)
            (§ return this)
        )
        (ß new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue))
    )

    (§ def Iterator EMPTY_ITER = new Iterator()
        (§ reify
            (§ method boolean hasNext()
                false
            )

            (§ method Object next()
                (§ throw new NoSuchElementException())
            )

            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )
    )

    (§ method- Iterator iterator(IFn f)
        (§ let Iterator rootIter = (root == nil) ? EMPTY_ITER :or root.iterator(f))
        (§ if (ß hasNull)
            (ß new Iterator()
                (§ reify
                    (§ field- boolean seen = false)

                    (§ method boolean hasNext()
                        (§ if (ß !seen)
                            true
                        )
                        (§ else 
                            (ß rootIter.hasNext())
                        )
                    )

                    (§ method Object next()
                        (§ if (ß !seen)
                            (ß seen = true)
                            (ß f.invoke(nil, nullValue))
                        )
                        (§ else 
                            (ß rootIter.next())
                        )
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )
        (§ else 
            rootIter
        )
    )

    (§ method Iterator iterator()
        (ß iterator(APersistentMap.MAKE_ENTRY))
    )

    (§ method Iterator keyIterator()
        (ß iterator(APersistentMap.MAKE_KEY))
    )

    (§ method Iterator valIterator()
        (ß iterator(APersistentMap.MAKE_VAL))
    )

    (§ method Object kvreduce(IFn f, Object init)
        (ß init = hasNull ? f.invoke(init, nil, nullValue) :or init)
        (§ if (ß RT.isReduced(init))
            (§ return (ß ((IDeref)init).deref()))
        )
        (§ if (ß root != nil)
            (ß init = root.kvreduce(f, init))
            (§ if (ß RT.isReduced(init))
                (§ return (ß ((IDeref)init).deref()))
            )
            (§ else 
                (§ return init)
            )
        )
        init
    )

    (§ method Object fold(long n, IFn combinef, IFn reducef, IFn fjinvoke, IFn fjtask, IFn fjfork, IFn fjjoin)
        ;; we are ignoring n for now
        (§ let Callable top = new Callable()
            (§ reify
                (§ method Object call() (§ throws Exception)
                    (§ let Object ret = combinef.invoke())
                    (§ if (ß root != nil)
                        (ß ret = combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin)))
                    )
                    (ß hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), nil, nullValue)) :or ret)
                )
            )
        )
        (ß fjinvoke.invoke(top))
    )

    (§ method int count()
        count
    )

    (§ method ISeq seq()
        (§ let ISeq s = (root != nil) ? root.nodeSeq() :or nil)
        (ß hasNull ? new Cons(MapEntry.create(nil, nullValue), s) :or s)
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ defn int mask(int hash, int shift)
        (ß (hash >>> shift) & 0x01f)
    )

    (§ method PersistentHashMap withMeta(IPersistentMap meta)
        (ß new PersistentHashMap(meta, count, root, hasNull, nullValue))
    )

    (§ method TransientHashMap asTransient()
        (ß new TransientHashMap(this))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (class-ns TransientHashMap (§ extends ATransientMap)
        (§ field AtomicReference<Thread> edit)
        #_volatile
        (§ field INode root)
        #_volatile
        (§ field int count)
        #_volatile
        (§ field boolean hasNull)
        #_volatile
        (§ field Object nullValue)
        (§ field Box leafFlag = new Box(nil))

        (§ constructor TransientHashMap(PersistentHashMap m)
            (§ this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue))
            this
        )

        (§ constructor TransientHashMap(AtomicReference<Thread> edit, INode root, int count, boolean hasNull, Object nullValue)
            (ß this.edit = edit)
            (ß this.root = root)
            (ß this.count = count)
            (ß this.hasNull = hasNull)
            (ß this.nullValue = nullValue)
            this
        )

        (§ method ITransientMap doAssoc(Object key, Object val)
            (§ if (ß key == nil)
                (§ if (ß this.nullValue != val)
                    (ß this.nullValue = val)
                )
                (§ if (ß !hasNull)
                    (ß this.count++)
                    (ß this.hasNull = true)
                )
                (§ return this)
            )
            (ß leafFlag.val = nil)
            (§ let INode n = ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag))
            (§ if (ß n != this.root)
                (ß this.root = n)
            )
            (§ if (ß leafFlag.val != nil)
                (ß this.count++)
            )
            this
        )

        (§ method ITransientMap doWithout(Object key)
            (§ if (ß key == nil)
                (§ if (ß !hasNull)
                    (§ return this)
                )
                (ß hasNull = false)
                (ß nullValue = nil)
                (ß this.count--)
                (§ return this)
            )
            (§ if (ß root == nil)
                (§ return this)
            )
            (ß leafFlag.val = nil)
            (§ let INode n = root.without(edit, 0, hash(key), key, leafFlag))
            (§ if (ß n != root)
                (ß this.root = n)
            )
            (§ if (ß leafFlag.val != nil)
                (ß this.count--)
            )
            this
        )

        (§ method IPersistentMap doPersistent()
            (ß edit.set(nil))
            (ß new PersistentHashMap(count, root, hasNull, nullValue))
        )

        (§ method Object doValAt(Object key, Object notFound)
            (§ if (ß key == nil)
                (§ if (ß hasNull)
                    (§ return nullValue)
                )
                (§ else 
                    (§ return notFound)
                )
            )
            (§ if (ß root == nil)
                (§ return notFound)
            )
            (ß root.find(0, hash(key), key, notFound))
        )

        (§ method int doCount()
            count
        )

        (§ method void ensureEditable()
            (§ if (ß edit.get() == nil)
                (§ throw new IllegalAccessError("Transient used after persistent! call"))
            )
            nil
        )
    )

    (§ interface INode
        (§ abstract INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(int shift, int hash, Object key))
        (§ abstract IMapEntry find(int shift, int hash, Object key))
        (§ abstract Object find(int shift, int hash, Object key, Object notFound))
        (§ abstract ISeq nodeSeq())
        (§ abstract INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf))
        (§ abstract Object kvreduce(IFn f, Object init))
        (§ abstract Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin))
        ;; returns the result of (f [k v]) for each iterated element
        (§ abstract Iterator iterator(IFn f))
    )

    (class-ns ArrayNode (§ implements INode)
        (§ field int count)
        (§ field INode[] array)
        (§ field AtomicReference<Thread> edit)

        (§ constructor ArrayNode(AtomicReference<Thread> edit, int count, INode[] array)
            (ß this.array = array)
            (ß this.edit = edit)
            (ß this.count = count)
            this
        )

        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (ß node == nil)
                (§ return (ß new ArrayNode(nil, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))))
            )
            (§ let INode n = node.assoc(shift + 5, hash, key, val, addedLeaf))
            (§ if (ß n == node)
                (§ return this)
            )
            (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
        )

        (§ method INode without(int shift, int hash, Object key)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (ß node == nil)
                (§ return this)
            )
            (§ let INode n = node.without(shift + 5, hash, key))
            (§ if (ß n == node)
                (§ return this)
            )
            (§ if (ß n == nil)
                (§ if (ß count <= 8) ;; shrink
                    (§ return (ß pack(nil, idx)))
                )
                (ß new ArrayNode(nil, count - 1, cloneAndSet(array, idx, n)))
            )
            (§ else 
                (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
            )
        )

        (§ method IMapEntry find(int shift, int hash, Object key)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (ß node == nil)
                (§ return nil)
            )
            (ß node.find(shift + 5, hash, key))
        )

        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (ß node == nil)
                (§ return notFound)
            )
            (ß node.find(shift + 5, hash, key, notFound))
        )

        (§ method ISeq nodeSeq()
            (ß Seq.create(array))
        )

        (§ method Iterator iterator(IFn f)
            (ß new Iter(array, f))
        )

        (§ method Object kvreduce(IFn f, Object init)
            (§ doseq [#_"INode" node array]
                (§ if (ß node != nil)
                    (ß init = node.kvreduce(f, init))
                    (§ if (ß RT.isReduced(init))
                        (§ return init)
                    )
                )
            )
            init
        )

        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (§ let List<Callable> tasks = new ArrayList())
            (§ doseq [#_"INode" node array]
                (§ if (ß node != nil)
                    (ß tasks.add(new Callable()
                        (§ reify
                            (§ method Object call() (§ throws Exception)
                                (ß node.fold(combinef, reducef, fjtask, fjfork, fjjoin))
                            )
                        ))
                    )
                )
            )

            (ß foldTasks(tasks, combinef, fjtask, fjfork, fjjoin))
        )

        (§ defn Object foldTasks(List<Callable> tasks, IFn combinef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (§ if (ß tasks.isEmpty())
                (§ return (ß combinef.invoke()))
            )

            (§ if (ß tasks.size() == 1)
                (§ let Object ret = nil)
                (§ try 
                    (§ return (ß tasks.get(0).call()))
                )
                (§ catch (ß Exception e)
                    (§ throw Util.sneakyThrow(e))
                )
            )

            (§ let List<Callable> t1 = tasks.subList(0, tasks.size() / 2))
            (§ let List<Callable> t2 = tasks.subList(tasks.size() / 2, tasks.size()))

            (§ let Object forked = fjfork.invoke(fjtask.invoke(new Callable()
                (§ reify
                    (§ method Object call() (§ throws Exception)
                        (ß foldTasks(t2, combinef, fjtask, fjfork, fjjoin))
                    )
                )))
            )

            (ß combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked)))
        )

        (§ method- ArrayNode ensureEditable(AtomicReference<Thread> edit)
            (§ if (ß this.edit == edit)
                (§ return this)
            )
            (ß new ArrayNode(edit, count, this.array.clone()))
        )

        (§ method- ArrayNode editAndSet(AtomicReference<Thread> edit, int i, INode n)
            (§ let ArrayNode editable = ensureEditable(edit))
            (ß editable.array[i] = n)
            editable
        )

        (§ method- INode pack(AtomicReference<Thread> edit, int idx)
            (§ let Object[] newArray = new Object[2 * (count - 1)])
            (§ let int j = 1)
            (§ let int bitmap = 0)
            (§ loop-when-recur [(ß int i = 0)] (ß i < idx) [(ß i++)]
                (§ if (ß array[i] != nil)
                    (ß newArray[j] = array[i])
                    (ß bitmap |= 1 << i)
                    (ß j += 2)
                )
            )
            (§ loop-when-recur [(ß int i = idx + 1)] (ß i < array.length) [(ß i++)]
                (§ if (ß array[i] != nil)
                    (ß newArray[j] = array[i])
                    (ß bitmap |= 1 << i)
                    (ß j += 2)
                )
            )
            (ß new BitmapIndexedNode(edit, bitmap, newArray))
        )

        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (ß node == nil)
                (§ let ArrayNode editable = editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)))
                (ß editable.count++)
                (§ return editable)
            )
            (§ let INode n = node.assoc(edit, shift + 5, hash, key, val, addedLeaf))
            (§ if (ß n == node)
                (§ return this)
            )
            (ß editAndSet(edit, idx, n))
        )

        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (ß node == nil)
                (§ return this)
            )
            (§ let INode n = node.without(edit, shift + 5, hash, key, removedLeaf))
            (§ if (ß n == node)
                (§ return this)
            )
            (§ if (ß n == nil)
                (§ if (ß count <= 8) ;; shrink
                    (§ return (ß pack(edit, idx)))
                )
                (§ let ArrayNode editable = editAndSet(edit, idx, n))
                (ß editable.count--)
                (§ return editable)
            )
            (ß editAndSet(edit, idx, n))
        )

        (class-ns Seq (§ extends ASeq)
            (§ field INode[] nodes)
            (§ field int i)
            (§ field ISeq s)

            (§ defn ISeq create(INode[] nodes)
                (ß create(nil, nodes, 0, nil))
            )

            (§ defn- ISeq create(IPersistentMap meta, INode[] nodes, int i, ISeq s)
                (§ if (ß s != nil)
                    (§ return (ß new Seq(meta, nodes, i, s)))
                )
                (§ loop-when-recur [(ß int j = i)] (ß j < nodes.length) [(ß j++)]
                    (§ if (ß nodes[j] != nil)
                        (§ let ISeq ns = nodes[j].nodeSeq())
                        (§ if (ß ns != nil)
                            (§ return (ß new Seq(meta, nodes, j + 1, ns)))
                        )
                    )
                )
                nil
            )

            (§ constructor- Seq(IPersistentMap meta, INode[] nodes, int i, ISeq s)
                (§ super(meta))
                (ß this.nodes = nodes)
                (ß this.i = i)
                (ß this.s = s)
                this
            )

            (§ method Obj withMeta(IPersistentMap meta)
                (ß new Seq(meta, nodes, i, s))
            )

            (§ method Object first()
                (ß s.first())
            )

            (§ method ISeq next()
                (ß create(nil, nodes, i, s.next()))
            )
        )

        (class-ns Iter (§ implements Iterator)
            (§ field- INode[] array)
            (§ field- IFn f)
            (§ field- int i = 0)
            (§ field- Iterator nestedIter)

            (§ constructor- Iter(INode[] array, IFn f)
                (ß this.array = array)
                (ß this.f = f)
                this
            )

            (§ method boolean hasNext()
                (§ while true
                    (§ if (ß nestedIter != nil)
                        (§ if (ß nestedIter.hasNext())
                            (§ return true)
                        )
                        (§ else 
                            (ß nestedIter = nil)
                        )
                    )

                    (§ if (ß i < array.length)
                        (§ let INode node = array[i++])
                        (§ if (ß node != nil)
                            (ß nestedIter = node.iterator(f))
                        )
                    )
                    (§ else 
                        (§ return false)
                    )
                )
            )

            (§ method Object next()
                (§ if (ß hasNext())
                    (ß nestedIter.next())
                )
                (§ else 
                    (§ throw new NoSuchElementException())
                )
            )

            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )
    )

    (class-ns BitmapIndexedNode (§ implements INode)
        (§ def BitmapIndexedNode EMPTY = new BitmapIndexedNode(nil, 0, new Object[0]))

        (§ field int bitmap)
        (§ field Object[] array)
        (§ field AtomicReference<Thread> edit)

        (§ method int index(int bit)
            (ß Integer.bitCount(bitmap & (bit - 1)))
        )

        (§ constructor BitmapIndexedNode(AtomicReference<Thread> edit, int bitmap, Object[] array)
            (ß this.bitmap = bitmap)
            (ß this.array = array)
            (ß this.edit = edit)
            this
        )

        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int bit = bitpos(hash, shift))
            (§ let int idx = index(bit))
            (§ if (ß (bitmap & bit) != 0)
                (§ let Object keyOrNull = array[2 * idx])
                (§ let Object valOrNode = array[2 * idx + 1])
                (§ if (ß keyOrNull == nil)
                    (§ let INode n = ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf))
                    (§ if (ß n == valOrNode)
                        (§ return this)
                    )
                    (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                )
                (§ if (ß Util.equiv(key, keyOrNull))
                    (§ if (ß val == valOrNode)
                        (§ return this)
                    )
                    (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, val))))
                )
                (ß addedLeaf.val = addedLeaf)
                (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx, nil, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val))))
            )
            (§ else 
                (§ let int n = Integer.bitCount(bitmap))
                (§ if (ß n >= 16)
                    (§ let INode[] nodes = new INode[32])
                    (§ let int jdx = mask(hash, shift))
                    (ß nodes[jdx] = EMPTY.assoc(shift + 5, hash, key, val, addedLeaf))
                    (§ let int j = 0)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < 32) [(ß i++)]
                        (§ if (ß ((bitmap >>> i) & 1) != 0)
                            (§ if (ß array[j] == nil)
                                (ß nodes[i] = (INode) array[j + 1])
                            )
                            (§ else 
                                (ß nodes[i] = EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                            )
                            (ß j += 2)
                        )
                    )
                    (ß new ArrayNode(nil, n + 1, nodes))
                )
                (§ else 
                    (§ let Object[] newArray = new Object[2 * (n + 1)])
                    (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                    (ß newArray[2 * idx] = key)
                    (ß addedLeaf.val = addedLeaf)
                    (ß newArray[2 * idx + 1] = val)
                    (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                    (ß new BitmapIndexedNode(nil, bitmap | bit, newArray))
                )
            )
        )

        (§ method INode without(int shift, int hash, Object key)
            (§ let int bit = bitpos(hash, shift))
            (§ if (ß (bitmap & bit) == 0)
                (§ return this)
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (ß keyOrNull == nil)
                (§ let INode n = ((INode) valOrNode).without(shift + 5, hash, key))
                (§ if (ß n == valOrNode)
                    (§ return this)
                )
                (§ if (ß n != nil)
                    (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                )
                (§ if (ß bitmap == bit)
                    (§ return nil)
                )
                (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
            )
            (§ if (ß Util.equiv(key, keyOrNull))
                ;; TODO: collapse
                (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
            )
            this
        )

        (§ method IMapEntry find(int shift, int hash, Object key)
            (§ let int bit = bitpos(hash, shift))
            (§ if (ß (bitmap & bit) == 0)
                (§ return nil)
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (ß keyOrNull == nil)
                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key)))
            )
            (§ if (ß Util.equiv(key, keyOrNull))
                (§ return (ß (IMapEntry) MapEntry.create(keyOrNull, valOrNode)))
            )
            nil
        )

        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (§ let int bit = bitpos(hash, shift))
            (§ if (ß (bitmap & bit) == 0)
                (§ return notFound)
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (ß keyOrNull == nil)
                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key, notFound)))
            )
            (§ if (ß Util.equiv(key, keyOrNull))
                (§ return valOrNode)
            )
            notFound
        )

        (§ method ISeq nodeSeq()
            (ß NodeSeq.create(array))
        )

        (§ method Iterator iterator(IFn f)
            (ß new NodeIter(array, f))
        )

        (§ method Object kvreduce(IFn f, Object init)
            (ß NodeSeq.kvreduce(array, f, init))
        )

        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        (§ method- BitmapIndexedNode ensureEditable(AtomicReference<Thread> edit)
            (§ if (ß this.edit == edit)
                (§ return this)
            )
            (§ let int n = Integer.bitCount(bitmap))
            (§ let Object[] newArray = new Object[(n >= 0) ? 2 * (n + 1) :or 4]) ;; make room for next assoc
            (ß System.arraycopy(array, 0, newArray, 0, 2 * n))
            (ß new BitmapIndexedNode(edit, bitmap, newArray))
        )

        (§ method- BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
            (§ let BitmapIndexedNode editable = ensureEditable(edit))
            (ß editable.array[i] = a)
            editable
        )

        (§ method- BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
            (§ let BitmapIndexedNode editable = ensureEditable(edit))
            (ß editable.array[i] = a)
            (ß editable.array[j] = b)
            editable
        )

        (§ method- BitmapIndexedNode editAndRemovePair(AtomicReference<Thread> edit, int bit, int i)
            (§ if (ß bitmap == bit)
                (§ return nil)
            )
            (§ let BitmapIndexedNode editable = ensureEditable(edit))
            (ß editable.bitmap ^= bit)
            (ß System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1)))
            (ß editable.array[editable.array.length - 2] = nil)
            (ß editable.array[editable.array.length - 1] = nil)
            editable
        )

        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int bit = bitpos(hash, shift))
            (§ let int idx = index(bit))
            (§ if (ß (bitmap & bit) != 0)
                (§ let Object keyOrNull = array[2 * idx])
                (§ let Object valOrNode = array[2 * idx + 1])
                (§ if (ß keyOrNull == nil)
                    (§ let INode n = ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf))
                    (§ if (ß n == valOrNode)
                        (§ return this)
                    )
                    (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                )
                (§ if (ß Util.equiv(key, keyOrNull))
                    (§ if (ß val == valOrNode)
                        (§ return this)
                    )
                    (§ return (ß editAndSet(edit, 2 * idx + 1, val)))
                )
                (ß addedLeaf.val = addedLeaf)
                (ß editAndSet(edit, 2 * idx, nil, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val)))
            )
            (§ else 
                (§ let int n = Integer.bitCount(bitmap))
                (§ if (ß n * 2 < array.length)
                    (ß addedLeaf.val = addedLeaf)
                    (§ let BitmapIndexedNode editable = ensureEditable(edit))
                    (ß System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx)))
                    (ß editable.array[2 * idx] = key)
                    (ß editable.array[2 * idx + 1] = val)
                    (ß editable.bitmap |= bit)
                    (§ return editable)
                )
                (§ if (ß n >= 16)
                    (§ let INode[] nodes = new INode[32])
                    (§ let int jdx = mask(hash, shift))
                    (ß nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf))
                    (§ let int j = 0)
                    (§ loop-when-recur [(ß int i = 0)] (ß i < 32) [(ß i++)]
                        (§ if (ß ((bitmap >>> i) & 1) != 0)
                            (§ if (ß array[j] == nil)
                                (ß nodes[i] = (INode) array[j + 1])
                            )
                            (§ else 
                                (ß nodes[i] = EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                            )
                            (ß j += 2)
                        )
                    )
                    (ß new ArrayNode(edit, n + 1, nodes))
                )
                (§ else 
                    (§ let Object[] newArray = new Object[2 * (n + 4)])
                    (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                    (ß newArray[2 * idx] = key)
                    (ß addedLeaf.val = addedLeaf)
                    (ß newArray[2 * idx + 1] = val)
                    (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                    (§ let BitmapIndexedNode editable = ensureEditable(edit))
                    (ß editable.array = newArray)
                    (ß editable.bitmap |= bit)
                    editable
                )
            )
        )

        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (§ let int bit = bitpos(hash, shift))
            (§ if (ß (bitmap & bit) == 0)
                (§ return this)
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (ß keyOrNull == nil)
                (§ let INode n = ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf))
                (§ if (ß n == valOrNode)
                    (§ return this)
                )
                (§ if (ß n != nil)
                    (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                )
                (§ if (ß bitmap == bit)
                    (§ return nil)
                )
                (§ return (ß editAndRemovePair(edit, bit, idx)))
            )
            (§ if (ß Util.equiv(key, keyOrNull))
                (ß removedLeaf.val = removedLeaf)
                ;; TODO: collapse
                (§ return (ß editAndRemovePair(edit, bit, idx)))
            )
            this
        )
    )

    (class-ns HashCollisionNode (§ implements INode)
        (§ field int hash)
        (§ field int count)
        (§ field Object[] array)
        (§ field AtomicReference<Thread> edit)

        (§ constructor HashCollisionNode(AtomicReference<Thread> edit, int hash, int count, Object... array)
            (ß this.edit = edit)
            (ß this.hash = hash)
            (ß this.count = count)
            (ß this.array = array)
            this
        )

        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ if (ß hash == this.hash)
                (§ let int idx = findIndex(key))
                (§ if (ß idx != -1)
                    (§ if (ß array[idx + 1] == val)
                        (§ return this)
                    )
                    (§ return (ß new HashCollisionNode(nil, hash, count, cloneAndSet(array, idx + 1, val))))
                )
                (§ let Object[] newArray = new Object[2 * (count + 1)])
                (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                (ß newArray[2 * count] = key)
                (ß newArray[2 * count + 1] = val)
                (ß addedLeaf.val = addedLeaf)
                (§ return (ß new HashCollisionNode(edit, hash, count + 1, newArray)))
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(nil, bitpos(this.hash, shift), new Object[] (§ nil, this )).assoc(shift, hash, key, val, addedLeaf))
        )

        (§ method INode without(int shift, int hash, Object key)
            (§ let int idx = findIndex(key))
            (§ if (ß idx == -1)
                (§ return this)
            )
            (§ if (ß count == 1)
                (§ return nil)
            )
            (ß new HashCollisionNode(nil, hash, count - 1, removePair(array, idx / 2)))
        )

        (§ method IMapEntry find(int shift, int hash, Object key)
            (§ let int idx = findIndex(key))
            (§ if (ß idx < 0)
                (§ return nil)
            )
            (§ if (ß Util.equiv(key, array[idx]))
                (§ return (ß (IMapEntry) MapEntry.create(array[idx], array[idx + 1])))
            )
            nil
        )

        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (§ let int idx = findIndex(key))
            (§ if (ß idx < 0)
                (§ return notFound)
            )
            (§ if (ß Util.equiv(key, array[idx]))
                (§ return (ß array[idx + 1]))
            )
            notFound
        )

        (§ method ISeq nodeSeq()
            (ß NodeSeq.create(array))
        )

        (§ method Iterator iterator(IFn f)
            (ß new NodeIter(array, f))
        )

        (§ method Object kvreduce(IFn f, Object init)
            (ß NodeSeq.kvreduce(array, f, init))
        )

        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        (§ method int findIndex(Object key)
            (§ loop-when-recur [(ß int i = 0)] (ß i < 2 * count) [(ß i += 2)]
                (§ if (ß Util.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )

        (§ method- HashCollisionNode ensureEditable(AtomicReference<Thread> edit)
            (§ if (ß this.edit == edit)
                (§ return this)
            )
            (§ let Object[] newArray = new Object[2 * (count + 1)]) ;; make room for next assoc
            (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
            (ß new HashCollisionNode(edit, hash, count, newArray))
        )

        (§ method- HashCollisionNode ensureEditable(AtomicReference<Thread> edit, int count, Object[] array)
            (§ if (ß this.edit == edit)
                (ß this.array = array)
                (ß this.count = count)
                (§ return this)
            )
            (ß new HashCollisionNode(edit, hash, count, array))
        )

        (§ method- HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
            (§ let HashCollisionNode editable = ensureEditable(edit))
            (ß editable.array[i] = a)
            editable
        )

        (§ method- HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
            (§ let HashCollisionNode editable = ensureEditable(edit))
            (ß editable.array[i] = a)
            (ß editable.array[j] = b)
            editable
        )

        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ if (ß hash == this.hash)
                (§ let int idx = findIndex(key))
                (§ if (ß idx != -1)
                    (§ if (ß array[idx + 1] == val)
                        (§ return this)
                    )
                    (§ return (ß editAndSet(edit, idx + 1, val)))
                )
                (§ if (ß array.length > 2 * count)
                    (ß addedLeaf.val = addedLeaf)
                    (§ let HashCollisionNode editable = editAndSet(edit, 2 * count, key, 2 * count + 1, val))
                    (ß editable.count++)
                    (§ return editable)
                )
                (§ let Object[] newArray = new Object[array.length + 2])
                (ß System.arraycopy(array, 0, newArray, 0, array.length))
                (ß newArray[array.length] = key)
                (ß newArray[array.length + 1] = val)
                (ß addedLeaf.val = addedLeaf)
                (§ return (ß ensureEditable(edit, count + 1, newArray)))
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ nil, this, nil, nil )).assoc(edit, shift, hash, key, val, addedLeaf))
        )

        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (§ let int idx = findIndex(key))
            (§ if (ß idx == -1)
                (§ return this)
            )
            (ß removedLeaf.val = removedLeaf)
            (§ if (ß count == 1)
                (§ return nil)
            )
            (§ let HashCollisionNode editable = ensureEditable(edit))
            (ß editable.array[idx] = editable.array[2 * count - 2])
            (ß editable.array[idx + 1] = editable.array[2 * count - 1])
            (ß editable.array[2 * count - 2] = editable.array[2 * count - 1] = nil)
            (ß editable.count--)
            editable
        )
    )

    (§ defn- INode[] cloneAndSet(INode[] array, int i, INode a)
        (§ let INode[] clone = array.clone())
        (ß clone[i] = a)
        clone
    )

    (§ defn- Object[] cloneAndSet(Object[] array, int i, Object a)
        (§ let Object[] clone = array.clone())
        (ß clone[i] = a)
        clone
    )

    (§ defn- Object[] cloneAndSet(Object[] array, int i, Object a, int j, Object b)
        (§ let Object[] clone = array.clone())
        (ß clone[i] = a)
        (ß clone[j] = b)
        clone
    )

    (§ defn- Object[] removePair(Object[] array, int i)
        (§ let Object[] newArray = new Object[array.length - 2])
        (ß System.arraycopy(array, 0, newArray, 0, 2 * i))
        (ß System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i))
        newArray
    )

    (§ defn- INode createNode(int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
        (§ let int key1hash = hash(key1))
        (§ if (ß key1hash == key2hash)
            (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
        )
        (§ let Box addedLeaf = new Box(nil))
        (§ let AtomicReference<Thread> edit = new AtomicReference<Thread>())
        (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
    )

    (§ defn- INode createNode(AtomicReference<Thread> edit, int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
        (§ let int key1hash = hash(key1))
        (§ if (ß key1hash == key2hash)
            (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
        )
        (§ let Box addedLeaf = new Box(nil))
        (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
    )

    (§ defn- int bitpos(int hash, int shift)
        (ß 1 << mask(hash, shift))
    )

    (class-ns NodeIter (§ implements Iterator)
        (§ def- Object NULL = new Object())
        (§ field Object[] array)
        (§ field IFn f)
        (§ field- int i = 0)
        (§ field- Object nextEntry = NULL)
        (§ field- Iterator nextIter)

        (§ constructor NodeIter(Object[] array, IFn f)
            (ß this.array = array)
            (ß this.f = f)
            this
        )

        (§ method- boolean advance()
            (§ while (ß i < array.length)
                (§ let Object key = array[i])
                (§ let Object nodeOrVal = array[i + 1])
                (ß i += 2)
                (§ if (ß key != nil)
                    (ß nextEntry = f.invoke(key, nodeOrVal))
                    (§ return true)
                )
                (§ elseif (ß nodeOrVal != nil)
                    (§ let Iterator iter = ((INode) nodeOrVal).iterator(f))
                    (§ if (ß iter != nil && iter.hasNext())
                        (ß nextIter = iter)
                        (§ return true)
                    )
                )
            )
            false
        )

        (§ method boolean hasNext()
            (§ if (ß nextEntry != NULL || nextIter != nil)
                (§ return true)
            )
            (ß advance())
        )

        (§ method Object next()
            (§ let Object ret = nextEntry)
            (§ if (ß ret != NULL)
                (ß nextEntry = NULL)
                (§ return ret)
            )
            (§ elseif (ß nextIter != nil)
                (ß ret = nextIter.next())
                (§ if (ß !nextIter.hasNext())
                    (ß nextIter = nil)
                )
                (§ return ret)
            )
            (§ elseif (ß advance())
                (§ return (ß next()))
            )
            (§ throw new NoSuchElementException())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    (class-ns NodeSeq (§ extends ASeq)
        (§ field Object[] array)
        (§ field int i)
        (§ field ISeq s)

        (§ constructor NodeSeq(Object[] array, int i)
            (§ this(nil, array, i, nil))
            this
        )

        (§ defn ISeq create(Object[] array)
            (ß create(array, 0, nil))
        )

        (§ defn Object kvreduce(Object[] array, IFn f, Object init)
            (§ loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                (§ if (ß array[i] != nil)
                    (ß init = f.invoke(init, array[i], array[i + 1]))
                )
                (§ else 
                    (§ let INode node = (INode) array[i + 1])
                    (§ if (ß node != nil)
                        (ß init = node.kvreduce(f, init))
                    )
                )
                (§ if (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            init
        )

        (§ defn- ISeq create(Object[] array, int i, ISeq s)
            (§ if (ß s != nil)
                (§ return (ß new NodeSeq(nil, array, i, s)))
            )
            (§ loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j+=2)]
                (§ if (ß array[j] != nil)
                    (§ return (ß new NodeSeq(nil, array, j, nil)))
                )
                (§ let INode node = (INode) array[j + 1])
                (§ if (ß node != nil)
                    (§ let ISeq nodeSeq = node.nodeSeq())
                    (§ if (ß nodeSeq != nil)
                        (§ return (ß new NodeSeq(nil, array, j + 2, nodeSeq)))
                    )
                )
            )
            nil
        )

        (§ constructor NodeSeq(IPersistentMap meta, Object[] array, int i, ISeq s)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            (ß this.s = s)
            this
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (ß new NodeSeq(meta, array, i, s))
        )

        (§ method Object first()
            (§ if (ß s != nil)
                (§ return (ß s.first()))
            )
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        (§ method ISeq next()
            (§ if (ß s != nil)
                (§ return (ß create(array, i, s.next())))
            )
            (ß create(array, i + 2, nil))
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def PersistentHashSet EMPTY = new PersistentHashSet(nil, PersistentHashMap.EMPTY))

    (§ field IPersistentMap _meta)

    (§ defn PersistentHashSet create(Object... init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i++)]
            (ß ret = (ITransientSet)ret.conj(init[i]))
        )
        (ß (PersistentHashSet)ret.persistent())
    )

    (§ defn PersistentHashSet create(List init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ doseq [#_"Object" key init]
            (ß ret = (ITransientSet) ret.conj(key))
        )
        (ß (PersistentHashSet)ret.persistent())
    )

    (§ defn PersistentHashSet create(ISeq items)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
            (ß ret = (ITransientSet) ret.conj(items.first()))
        )
        (ß (PersistentHashSet)ret.persistent())
    )

    (§ defn PersistentHashSet createWithCheck(Object... init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i++)]
            (ß ret = (ITransientSet) ret.conj(init[i]))
            (§ if (ß ret.count() != i + 1)
                (§ throw new IllegalArgumentException("Duplicate key: " + init[i]))
            )
        )
        (ß (PersistentHashSet) ret.persistent())
    )

    (§ defn PersistentHashSet createWithCheck(List init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ let int i = 0)
        (§ doseq [#_"Object" key init]
            (ß ret = (ITransientSet) ret.conj(key))
            (§ if (ß ret.count() != i + 1)
                (§ throw new IllegalArgumentException("Duplicate key: " + key))
            )
            (ß ++i)
        )
        (ß (PersistentHashSet) ret.persistent())
    )

    (§ defn PersistentHashSet createWithCheck(ISeq items)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß items != nil) [(ß items = items.next(), ++i)]
            (ß ret = (ITransientSet) ret.conj(items.first()))
            (§ if (ß ret.count() != i + 1)
                (§ throw new IllegalArgumentException("Duplicate key: " + items.first()))
            )
        )
        (ß (PersistentHashSet) ret.persistent())
    )

    (§ constructor PersistentHashSet(IPersistentMap meta, IPersistentMap impl)
        (§ super(impl))
        (ß this._meta = meta)
        this
    )

    (§ method IPersistentSet disjoin(Object key)
        (§ if (ß contains(key))
            (§ return (ß new PersistentHashSet(meta(), impl.without(key))))
        )
        this
    )

    (§ method IPersistentSet cons(Object o)
        (§ if (ß contains(o))
            (§ return this)
        )
        (ß new PersistentHashSet(meta(), impl.assoc(o, o)))
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentHashSet withMeta(IPersistentMap meta)
        (ß new PersistentHashSet(meta, impl))
    )

    (§ method ITransientCollection asTransient()
        (ß new TransientHashSet(((PersistentHashMap) impl).asTransient()))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (class-ns TransientHashSet (§ extends ATransientSet)
        (§ constructor TransientHashSet(ITransientMap impl)
            (§ super(impl))
            this
        )

        (§ method IPersistentCollection persistent()
            (ß new PersistentHashSet(nil, impl.persistent()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ field- Object _first)
    (§ field- IPersistentList _rest)
    (§ field- int _count)

    (class-ns Primordial (§ extends RestFn)
        (§ method int getRequiredArity()
            0
        )

        #_protected
        (§ method Object doInvoke(Object args)
            (§ if (ß args instanceof ArraySeq)
                (§ let Object[] argsarray = ((ArraySeq) args).array)
                (§ let IPersistentList ret = EMPTY)
                (§ loop-when-recur [(ß int i = argsarray.length - 1)] (ß i >= ((ArraySeq)args).i) [(ß --i)]
                    (ß ret = (IPersistentList) ret.cons(argsarray[i]))
                )
                (§ return ret)
            )
            (§ let LinkedList list = new LinkedList())
            (§ loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                (ß list.add(s.first()))
            )
            (ß create(list))
        )

        (§ defn Object invokeStatic(ISeq args)
            (§ if (ß args instanceof ArraySeq)
                (§ let Object[] argsarray = ((ArraySeq) args).array)
                (§ let IPersistentList ret = EMPTY)
                (§ loop-when-recur [(ß int i = argsarray.length - 1)] (ß i >= 0) [(ß --i)]
                    (ß ret = (IPersistentList) ret.cons(argsarray[i]))
                )
                (§ return ret)
            )
            (§ let LinkedList list = new LinkedList())
            (§ loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                (ß list.add(s.first()))
            )
            (ß create(list))
        )

        (§ method IObj withMeta(IPersistentMap meta)
            (§ throw new UnsupportedOperationException())
        )

        (§ method IPersistentMap meta()
            nil
        )
    )

    (§ def IFn creator = new Primordial())

    (§ def EmptyList EMPTY = new EmptyList(nil))

    (§ constructor PersistentList(Object first)
        (ß this._first = first)
        (ß this._rest = nil)

        (ß this._count = 1)
        this
    )

    (§ constructor PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count)
        (§ super(meta))
        (ß this._first = _first)
        (ß this._rest = _rest)
        (ß this._count = _count)
        this
    )

    (§ defn IPersistentList create(List init)
        (§ let IPersistentList ret = EMPTY)
        (§ loop-when-recur [(ß ListIterator i = init.listIterator(init.size()))] (ß i.hasPrevious()) [(ß )]
            (ß ret = (IPersistentList) ret.cons(i.previous()))
        )
        ret
    )

    (§ method Object first()
        (ß _first)
    )

    (§ method ISeq next()
        (§ if (ß _count == 1)
            (§ return nil)
        )
        (ß (ISeq) _rest)
    )

    (§ method Object peek()
        (ß first())
    )

    (§ method IPersistentList pop()
        (§ if (ß _rest == nil)
            (§ return (ß EMPTY.withMeta(_meta)))
        )
        (ß _rest)
    )

    (§ method int count()
        (ß _count)
    )

    (§ method PersistentList cons(Object o)
        (ß new PersistentList(meta(), o, this, _count + 1))
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentList withMeta(IPersistentMap meta)
        (§ if (ß meta != _meta)
            (§ return (ß new PersistentList(meta, _first, _rest, _count)))
        )
        this
    )

    (§ method Object reduce(IFn f)
        (§ let Object ret = first())
        (§ loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next())]
            (ß ret = f.invoke(ret, s.first()))
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
        )
        ret
    )

    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = f.invoke(start, first()))
        (§ loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next())]
            (§ if (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            (ß ret = f.invoke(ret, s.first()))
        )
        (§ if (ß RT.isReduced(ret))
            (§ return (ß ((IDeref)ret).deref()))
        )
        ret
    )

    (class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
        (§ def int hasheq = Murmur3.hashOrdered(Collections.EMPTY_LIST))

        (§ method int hashCode()
            1
        )

        (§ method int hasheq()
            hasheq
        )

        (§ method String toString()
            (ß "()")
        )

        (§ method boolean equals(Object o)
            (ß ((o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )

        (§ method boolean equiv(Object o)
            (ß equals(o))
        )

        (§ constructor EmptyList(IPersistentMap meta)
            (§ super(meta))
            this
        )

        (§ method Object first()
            nil
        )

        (§ method ISeq next()
            nil
        )

        (§ method ISeq more()
            this
        )

        (§ method PersistentList cons(Object o)
            (ß new PersistentList(meta(), o, nil, 1))
        )

        (§ method IPersistentCollection empty()
            this
        )

        (§ method EmptyList withMeta(IPersistentMap meta)
            (§ if (ß meta != meta())
                (§ return (ß new EmptyList(meta)))
            )
            this
        )

        (§ method Object peek()
            nil
        )

        (§ method IPersistentList pop()
            (§ throw new IllegalStateException("Can't pop empty list"))
        )

        (§ method int count()
            0
        )

        (§ method ISeq seq()
            nil
        )

        (§ method int size()
            0
        )

        (§ method boolean isEmpty()
            true
        )

        (§ method boolean contains(Object o)
            false
        )

        (§ method Iterator iterator()
            (ß new Iterator()
                (§ reify
                    (§ method boolean hasNext()
                        false
                    )

                    (§ method Object next()
                        (§ throw new NoSuchElementException())
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )

        (§ method Object[] toArray()
            (ß RT.EMPTY_ARRAY)
        )

        (§ method boolean add(Object o)
            (§ throw new UnsupportedOperationException())
        )

        (§ method boolean remove(Object o)
            (§ throw new UnsupportedOperationException())
        )

        (§ method boolean addAll(Collection collection)
            (§ throw new UnsupportedOperationException())
        )

        (§ method void clear()
            (§ throw new UnsupportedOperationException())
        )

        (§ method boolean retainAll(Collection collection)
            (§ throw new UnsupportedOperationException())
        )

        (§ method boolean removeAll(Collection collection)
            (§ throw new UnsupportedOperationException())
        )

        (§ method boolean containsAll(Collection collection)
            (ß collection.isEmpty())
        )

        (§ method Object[] toArray(Object[] objects)
            (§ if (ß objects.length > 0)
                (ß objects[0] = nil)
            )
            objects
        )

        (§ method- List reify()
            (ß Collections.unmodifiableList(new ArrayList(this)))
        )

        (§ method List subList(int fromIndex, int toIndex)
            (ß reify().subList(fromIndex, toIndex))
        )

        (§ method Object set(int index, Object element)
            (§ throw new UnsupportedOperationException())
        )

        (§ method Object remove(int index)
            (§ throw new UnsupportedOperationException())
        )

        (§ method int indexOf(Object o)
            (§ let ISeq s = seq())
            (§ loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                (§ if (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (ß reify().lastIndexOf(o))
        )

        (§ method ListIterator listIterator()
            (ß reify().listIterator())
        )

        (§ method ListIterator listIterator(int index)
            (ß reify().listIterator(index))
        )

        (§ method Object get(int index)
            (ß RT.nth(this, index))
        )

        (§ method void add(int index, Object element)
            (§ throw new UnsupportedOperationException())
        )

        (§ method boolean addAll(int index, Collection c)
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def PersistentQueue EMPTY = new PersistentQueue(nil, 0, nil, nil))

    (§ field int cnt)
    (§ field ISeq f)
    (§ field PersistentVector r)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ constructor PersistentQueue(IPersistentMap meta, int cnt, ISeq f, PersistentVector r)
        (§ super(meta))
        (ß this.cnt = cnt)
        (ß this.f = f)
        (ß this.r = r)
        this
    )

    (§ method boolean equiv(Object obj)
        (§ if (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
            (§ if (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                (§ return false)
            )
        )
        (ß (ms == nil))
    )

    (§ method boolean equals(Object obj)
        (§ if (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
            (§ if (ß ms == nil || !Util.equals(s.first(), ms.first()))
                (§ return false)
            )
        )
        (ß (ms == nil))
    )

    (§ method int hashCode()
        (§ let int hash = this._hash)
        (§ if (ß hash == 0)
            (ß hash = 1)
            (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (ß hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
            )
            (ß this._hash = hash)
        )
        hash
    )

    (§ method int hasheq()
        (§ let int cached = this._hasheq)
        (§ if (ß cached == 0)
            (ß this._hasheq = cached = Murmur3.hashOrdered(this))
        )
        cached
    )

    (§ method Object peek()
        (ß RT.first(f))
    )

    (§ method PersistentQueue pop()
        (§ if (ß f == nil) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (§ let ISeq f1 = f.next())
        (§ let PersistentVector r1 = r)
        (§ if (ß f1 == nil)
            (ß f1 = RT.seq(r))
            (ß r1 = nil)
        )
        (ß new PersistentQueue(meta(), cnt - 1, f1, r1))
    )

    (§ method int count()
        cnt
    )

    (§ method ISeq seq()
        (§ if (ß f == nil)
            (§ return nil)
        )
        (ß new Seq(f, RT.seq(r)))
    )

    (§ method PersistentQueue cons(Object o)
        (§ if (ß f == nil) ;; empty
            (ß new PersistentQueue(meta(), cnt + 1, RT.list(o), nil))
        )
        (§ else 
            (ß new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector.EMPTY).cons(o)))
        )
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentQueue withMeta(IPersistentMap meta)
        (ß new PersistentQueue(meta, cnt, f, r))
    )

    (class-ns Seq (§ extends ASeq)
        (§ field ISeq f)
        (§ field ISeq rseq)

        (§ constructor Seq(ISeq f, ISeq rseq)
            (ß this.f = f)
            (ß this.rseq = rseq)
            this
        )

        (§ constructor Seq(IPersistentMap meta, ISeq f, ISeq rseq)
            (§ super(meta))
            (ß this.f = f)
            (ß this.rseq = rseq)
            this
        )

        (§ method Object first()
            (ß f.first())
        )

        (§ method ISeq next()
            (§ let ISeq f1 = f.next())
            (§ let ISeq r1 = rseq)
            (§ if (ß f1 == nil)
                (§ if (ß rseq == nil)
                    (§ return nil)
                )
                (ß f1 = rseq)
                (ß r1 = nil)
            )
            (ß new Seq(f1, r1))
        )

        (§ method int count()
            (ß RT.count(f) + RT.count(rseq))
        )

        (§ method Seq withMeta(IPersistentMap meta)
            (ß new Seq(meta, f, rseq))
        )
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    (§ method boolean containsAll(Collection c)
        (§ doseq [#_"Object" o c]
            (§ if (ß contains(o))
                (§ return true)
            )
        )
        false
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method boolean contains(Object o)
        (§ loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (§ if (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method Iterator iterator()
        (ß new Iterator()
            (§ reify
                (§ field- ISeq fseq = f)
                (§ field- Iterator riter = (r != nil) ? r.iterator() :or nil)

                (§ method boolean hasNext()
                    (ß ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext())))
                )

                (§ method Object next()
                    (§ if (ß fseq != nil)
                        (§ let Object ret = fseq.first())
                        (ß fseq = fseq.next())
                        ret
                    )
                    (§ elseif (ß riter != nil && riter.hasNext())
                        (ß riter.next())
                    )
                    (§ else 
                        (§ throw new NoSuchElementException())
                    )
                )

                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ field Comparator comp)
    (§ field Node tree)
    (§ field int _count)
    (§ field IPersistentMap _meta)

    (§ def PersistentTreeMap EMPTY = new PersistentTreeMap())

    (§ defn IPersistentMap create(Map other)
        (§ let IPersistentMap ret = EMPTY)
        (§ doseq [#_"Object" o (ß other.entrySet())]
            (§ let Map.Entry e = (Entry) o)
            (ß ret = ret.assoc(e.getKey(), e.getValue()))
        )
        ret
    )

    (§ constructor PersistentTreeMap()
        (§ this(RT.DEFAULT_COMPARATOR))
        this
    )

    (§ method PersistentTreeMap withMeta(IPersistentMap meta)
        (ß new PersistentTreeMap(meta, comp, tree, _count))
    )

    (§ constructor- PersistentTreeMap(Comparator comp)
        (§ this(nil, comp))
        this
    )

    (§ constructor PersistentTreeMap(IPersistentMap meta, Comparator comp)
        (ß this.comp = comp)
        (ß this._meta = meta)
        (ß tree = nil)
        (ß _count = 0)
        this
    )

    (§ constructor PersistentTreeMap(IPersistentMap meta, Comparator comp, Node tree, int _count)
        (ß this._meta = meta)
        (ß this.comp = comp)
        (ß this.tree = tree)
        (ß this._count = _count)
        this
    )

    (§ defn PersistentTreeMap create(ISeq items)
        (§ let IPersistentMap ret = EMPTY)
        (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
            (§ if (ß items.next() == nil)
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (ß ret = ret.assoc(items.first(), RT.second(items)))
        )
        (ß (PersistentTreeMap) ret)
    )

    (§ defn PersistentTreeMap create(Comparator comp, ISeq items)
        (§ let IPersistentMap ret = new PersistentTreeMap(comp))
        (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
            (§ if (ß items.next() == nil)
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (ß ret = ret.assoc(items.first(), RT.second(items)))
        )
        (ß (PersistentTreeMap) ret)
    )

    (§ method boolean containsKey(Object key)
        (ß (entryAt(key) != nil))
    )

    (§ method boolean equals(Object obj)
        (§ try 
            (ß super.equals(obj))
        )
        (§ catch (ß ClassCastException e)
            false
        )
    )

    (§ method boolean equiv(Object obj)
        (§ try 
            (ß super.equiv(obj))
        )
        (§ catch (ß ClassCastException e)
            false
        )
    )

    (§ method PersistentTreeMap assocEx(Object key, Object val)
        (§ let Box found = new Box(nil))
        (§ let Node t = add(tree, key, val, found))
        (§ if (ß t == nil) ;; nil == already contains key
            (§ throw Util.runtimeException("Key already present"))
        )
        (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
    )

    (§ method PersistentTreeMap assoc(Object key, Object val)
        (§ let Box found = new Box(nil))
        (§ let Node t = add(tree, key, val, found))
        (§ if (ß t == nil) ;; nil == already contains key
            (§ let Node foundNode = (Node) found.val)
            (§ if (ß foundNode.val() == val) ;; note only get same collection on identity of val, not equals()
                (§ return this)
            )
            (§ return (ß new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())))
        )
        (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
    )

    (§ method PersistentTreeMap without(Object key)
        (§ let Box found = new Box(nil))
        (§ let Node t = remove(tree, key, found))
        (§ if (ß t == nil)
            (§ if (ß found.val == nil) ;; nil == doesn't contain key
                (§ return this)
            )
            ;; empty
            (§ return (ß new PersistentTreeMap(meta(), comp)))
        )
        (ß new PersistentTreeMap(comp, t.blacken(), _count - 1, meta()))
    )

    (§ method ISeq seq()
        (§ if (ß _count > 0)
            (§ return (ß Seq.create(tree, true, _count)))
        )
        nil
    )

    (§ method IPersistentCollection empty()
        (ß new PersistentTreeMap(meta(), comp))
    )

    (§ method ISeq rseq()
        (§ if (ß _count > 0)
            (§ return (ß Seq.create(tree, false, _count)))
        )
        nil
    )

    (§ method Comparator comparator()
        comp
    )

    (§ method Object entryKey(Object entry)
        (ß ((IMapEntry) entry).key())
    )

    (§ method ISeq seq(boolean ascending)
        (§ if (ß _count > 0)
            (§ return (ß Seq.create(tree, ascending, _count)))
        )
        nil
    )

    (§ method ISeq seqFrom(Object key, boolean ascending)
        (§ if (ß _count > 0)
            (§ let ISeq stack = nil)
            (§ let Node t = tree)
            (§ while (ß t != nil)
                (§ let int c = doCompare(key, t.key))
                (§ if (ß c == 0)
                    (ß stack = RT.cons(t, stack))
                    (§ return (ß new Seq(stack, ascending)))
                )
                (§ elseif (ß ascending)
                    (§ if (ß c < 0)
                        (ß stack = RT.cons(t, stack))
                        (ß t = t.left())
                    )
                    (§ else 
                        (ß t = t.right())
                    )
                )
                (§ else 
                    (§ if (ß c > 0)
                        (ß stack = RT.cons(t, stack))
                        (ß t = t.right())
                    )
                    (§ else 
                        (ß t = t.left())
                    )
                )
            )
            (§ if (ß stack != nil)
                (§ return (ß new Seq(stack, ascending)))
            )
        )
        nil
    )

    (§ method NodeIterator iterator()
        (ß new NodeIterator(tree, true))
    )

    (§ method Object kvreduce(IFn f, Object init)
        (§ if (ß tree != nil)
            (ß init = tree.kvreduce(f, init))
        )
        (§ if (ß RT.isReduced(init))
            (ß init = ((IDeref)init).deref())
        )
        init
    )

    (§ method NodeIterator reverseIterator()
        (ß new NodeIterator(tree, false))
    )

    (§ method Iterator keys()
        (ß keys(iterator()))
    )

    (§ method Iterator vals()
        (ß vals(iterator()))
    )

    (§ method Iterator keys(NodeIterator it)
        (ß new KeyIterator(it))
    )

    (§ method Iterator vals(NodeIterator it)
        (ß new ValIterator(it))
    )

    (§ method Object minKey()
        (§ let Node t = min())
        (ß (t != nil) ? t.key :or nil)
    )

    (§ method Node min()
        (§ let Node t = tree)
        (§ if (ß t != nil)
            (§ while (ß t.left() != nil)
                (ß t = t.left())
            )
        )
        t
    )

    (§ method Object maxKey()
        (§ let Node t = max())
        (ß (t != nil) ? t.key :or nil)
    )

    (§ method Node max()
        (§ let Node t = tree)
        (§ if (ß t != nil)
            (§ while (ß t.right() != nil)
                (ß t = t.right())
            )
        )
        t
    )

    (§ method int depth()
        (ß depth(tree))
    )

    (§ method int depth(Node t)
        (§ if (ß t == nil)
            (§ return 0)
        )
        (ß 1 + Math.max(depth(t.left()), depth(t.right())))
    )

    (§ method Object valAt(Object key, Object notFound)
        (§ let Node n = entryAt(key))
        (ß (n != nil) ? n.val() :or notFound)
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method int capacity()
        (ß _count)
    )

    (§ method int count()
        (ß _count)
    )

    (§ method Node entryAt(Object key)
        (§ let Node t = tree)
        (§ while (ß t != nil)
            (§ let int c = doCompare(key, t.key))
            (§ if (ß c == 0)
                (§ return t)
            )
            (§ elseif (ß c < 0)
                (ß t = t.left())
            )
            (§ else 
                (ß t = t.right())
            )
        )
        t
    )

    (§ method int doCompare(Object k1, Object k2)
        (ß comp.compare(k1, k2))
    )

    (§ method Node add(Node t, Object key, Object val, Box found)
        (§ if (ß t == nil)
            (§ if (ß val == nil)
                (§ return (ß new Red(key)))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (§ let int c = doCompare(key, t.key))
        (§ if (ß c == 0)
            (ß found.val = t)
            (§ return nil)
        )
        (§ let Node ins = (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found))
        (§ if (ß ins == nil) ;; found below
            (§ return nil)
        )
        (§ if (ß c < 0)
            (§ return (ß t.addLeft(ins)))
        )
        (ß t.addRight(ins))
    )

    (§ method Node remove(Node t, Object key, Box found)
        (§ if (ß t == nil)
            (§ return nil) ;; not found indicator
        )
        (§ let int c = doCompare(key, t.key))
        (§ if (ß c == 0)
            (ß found.val = t)
            (§ return (ß append(t.left(), t.right())))
        )
        (§ let Node del = (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found))
        (§ if (ß del == nil && found.val == nil) ;; not found below
            (§ return nil)
        )
        (§ if (ß c < 0)
            (§ if (ß t.left() instanceof Black)
                (§ return (ß balanceLeftDel(t.key, t.val(), del, t.right())))
            )
            (§ else 
                (§ return (ß red(t.key, t.val(), del, t.right())))
            )
        )
        (§ if (ß t.right() instanceof Black)
            (§ return (ß balanceRightDel(t.key, t.val(), t.left(), del)))
        )
        (ß red(t.key, t.val(), t.left(), del))
    )

    (§ defn Node append(Node left, Node right)
        (§ if (ß left == nil)
            right
        )
        (§ elseif (ß right == nil)
            left
        )
        (§ elseif (ß left instanceof Red)
            (§ if (ß right instanceof Red)
                (§ let Node app = append(left.right(), right.left()))
                (§ if (ß app instanceof Red)
                    (ß red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right())))
                )
                (§ else 
                    (ß red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right())))
                )
            )
            (§ else 
                (ß red(left.key, left.val(), left.left(), append(left.right(), right)))
            )
        )
        (§ elseif (ß right instanceof Red)
            (ß red(right.key, right.val(), append(left, right.left()), right.right()))
        )
        (§ else  ;; black/black
            (§ let Node app = append(left.right(), right.left()))
            (§ if (ß app instanceof Red)
                (ß red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right())))
            )
            (§ else 
                (ß balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right())))
            )
        )
    )

    (§ defn Node balanceLeftDel(Object key, Object val, Node del, Node right)
        (§ if (ß del instanceof Red)
            (ß red(key, val, del.blacken(), right))
        )
        (§ elseif (ß right instanceof Black)
            (ß rightBalance(key, val, del, right.redden()))
        )
        (§ elseif (ß right instanceof Red && right.left() instanceof Black)
            (ß red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden())))
        )
        (§ else 
            (§ throw new UnsupportedOperationException("Invariant violation"))
        )
    )

    (§ defn Node balanceRightDel(Object key, Object val, Node left, Node del)
        (§ if (ß del instanceof Red)
            (ß red(key, val, left, del.blacken()))
        )
        (§ elseif (ß left instanceof Black)
            (ß leftBalance(key, val, left.redden(), del))
        )
        (§ elseif (ß left instanceof Red && left.right() instanceof Black)
            (ß red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del)))
        )
        (§ else 
            (§ throw new UnsupportedOperationException("Invariant violation"))
        )
    )

    (§ defn Node leftBalance(Object key, Object val, Node ins, Node right)
        (§ if (ß ins instanceof Red && ins.left() instanceof Red)
            (ß red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right)))
        )
        (§ elseif (ß ins instanceof Red && ins.right() instanceof Red)
            (ß red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right)))
        )
        (§ else 
            (ß black(key, val, ins, right))
        )
    )

    (§ defn Node rightBalance(Object key, Object val, Node left, Node ins)
        (§ if (ß ins instanceof Red && ins.right() instanceof Red)
            (ß red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken()))
        )
        (§ elseif (ß ins instanceof Red && ins.left() instanceof Red)
            (ß red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right())))
        )
        (§ else 
            (ß black(key, val, left, ins))
        )
    )

    (§ method Node replace(Node t, Object key, Object val)
        (§ let int c = doCompare(key, t.key))
        (ß t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right()))
    )

    (§ constructor PersistentTreeMap(Comparator comp, Node tree, int count, IPersistentMap meta)
        (ß this._meta = meta)
        (ß this.comp = comp)
        (ß this.tree = tree)
        (ß this._count = count)
        this
    )

    (§ defn Red red(Object key, Object val, Node left, Node right)
        (§ if (ß left == nil && right == nil)
            (§ if (ß val == nil)
                (§ return (ß new Red(key)))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (§ if (ß val == nil)
            (§ return (ß new RedBranch(key, left, right)))
        )
        (ß new RedBranchVal(key, val, left, right))
    )

    (§ defn Black black(Object key, Object val, Node left, Node right)
        (§ if (ß left == nil && right == nil)
            (§ if (ß val == nil)
                (§ return (ß new Black(key)))
            )
            (§ return (ß new BlackVal(key, val)))
        )
        (§ if (ß val == nil)
            (§ return (ß new BlackBranch(key, left, right)))
        )
        (ß new BlackBranchVal(key, val, left, right))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    #_abstract
    (class-ns Node (§ extends AMapEntry)
        (§ field Object key)

        (§ constructor Node(Object key)
            (ß this.key = key)
            this
        )

        (§ method Object key()
            key
        )

        (§ method Object val()
            nil
        )

        (§ method Object getKey()
            (ß key())
        )

        (§ method Object getValue()
            (ß val())
        )

        (§ method Node left()
            nil
        )

        (§ method Node right()
            nil
        )

        (§ abstract Node addLeft(Node ins))
        (§ abstract Node addRight(Node ins))
        (§ abstract Node removeLeft(Node del))
        (§ abstract Node removeRight(Node del))
        (§ abstract Node blacken())
        (§ abstract Node redden())

        (§ method Node balanceLeft(Node parent)
            (ß black(parent.key, parent.val(), this, parent.right()))
        )

        (§ method Node balanceRight(Node parent)
            (ß black(parent.key, parent.val(), parent.left(), this))
        )

        (§ abstract Node replace(Object key, Object val, Node left, Node right))

        (§ method Object kvreduce(IFn f, Object init)
            (§ if (ß left() != nil)
                (ß init = left().kvreduce(f, init))
                (§ if (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            (ß init = f.invoke(init, key(), val()))
            (§ if (ß RT.isReduced(init))
                (§ return init)
            )

            (§ if (ß right() != nil)
                (ß init = right().kvreduce(f, init))
            )
            init
        )
    )

    (class-ns Black (§ extends Node)
        (§ constructor Black(Object key)
            (§ super(key))
            this
        )

        (§ method Node addLeft(Node ins)
            (ß ins.balanceLeft(this))
        )

        (§ method Node addRight(Node ins)
            (ß ins.balanceRight(this))
        )

        (§ method Node removeLeft(Node del)
            (ß balanceLeftDel(key, val(), del, right()))
        )

        (§ method Node removeRight(Node del)
            (ß balanceRightDel(key, val(), left(), del))
        )

        (§ method Node blacken()
            this
        )

        (§ method Node redden()
            (ß new Red(key))
        )

        (§ method Node replace(Object key, Object val, Node left, Node right)
            (ß black(key, val, left, right))
        )
    )

    (class-ns BlackVal (§ extends Black)
        (§ field Object val)

        (§ constructor BlackVal(Object key, Object val)
            (§ super(key))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node redden()
            (ß new RedVal(key, val))
        )
    )

    (class-ns BlackBranch (§ extends Black)
        (§ field Node left)

        (§ field Node right)

        (§ constructor BlackBranch(Object key, Node left, Node right)
            (§ super(key))
            (ß this.left = left)
            (ß this.right = right)
            this
        )

        (§ method Node left()
            left
        )

        (§ method Node right()
            right
        )

        (§ method Node redden()
            (ß new RedBranch(key, left, right))
        )
    )

    (class-ns BlackBranchVal (§ extends BlackBranch)
        (§ field Object val)

        (§ constructor BlackBranchVal(Object key, Object val, Node left, Node right)
            (§ super(key, left, right))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node redden()
            (ß new RedBranchVal(key, val, left, right))
        )
    )

    (class-ns Red (§ extends Node)
        (§ constructor Red(Object key)
            (§ super(key))
            this
        )

        (§ method Node addLeft(Node ins)
            (ß red(key, val(), ins, right()))
        )

        (§ method Node addRight(Node ins)
            (ß red(key, val(), left(), ins))
        )

        (§ method Node removeLeft(Node del)
            (ß red(key, val(), del, right()))
        )

        (§ method Node removeRight(Node del)
            (ß red(key, val(), left(), del))
        )

        (§ method Node blacken()
            (ß new Black(key))
        )

        (§ method Node redden()
            (§ throw new UnsupportedOperationException("Invariant violation"))
        )

        (§ method Node replace(Object key, Object val, Node left, Node right)
            (ß red(key, val, left, right))
        )
    )

    (class-ns RedVal (§ extends Red)
        (§ field Object val)

        (§ constructor RedVal(Object key, Object val)
            (§ super(key))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node blacken()
            (ß new BlackVal(key, val))
        )
    )

    (class-ns RedBranch (§ extends Red)
        (§ field Node left)

        (§ field Node right)

        (§ constructor RedBranch(Object key, Node left, Node right)
            (§ super(key))
            (ß this.left = left)
            (ß this.right = right)
            this
        )

        (§ method Node left()
            left
        )

        (§ method Node right()
            right
        )

        (§ method Node balanceLeft(Node parent)
            (§ if (ß left instanceof Red)
                (ß red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right())))
            )
            (§ elseif (ß right instanceof Red)
                (ß red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right())))
            )
            (§ else 
                (ß super.balanceLeft(parent))
            )
        )

        (§ method Node balanceRight(Node parent)
            (§ if (ß right instanceof Red)
                (ß red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken()))
            )
            (§ elseif (ß left instanceof Red)
                (ß red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right)))
            )
            (§ else 
                (ß super.balanceRight(parent))
            )
        )

        (§ method Node blacken()
            (ß new BlackBranch(key, left, right))
        )
    )

    (class-ns RedBranchVal (§ extends RedBranch)
        (§ field Object val)

        (§ constructor RedBranchVal(Object key, Object val, Node left, Node right)
            (§ super(key, left, right))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node blacken()
            (ß new BlackBranchVal(key, val, left, right))
        )
    )

    (class-ns Seq (§ extends ASeq)
        (§ field ISeq stack)
        (§ field boolean asc)
        (§ field int cnt)

        (§ constructor Seq(ISeq stack, boolean asc)
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = -1)
            this
        )

        (§ constructor Seq(ISeq stack, boolean asc, int cnt)
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = cnt)
            this
        )

        (§ constructor Seq(IPersistentMap meta, ISeq stack, boolean asc, int cnt)
            (§ super(meta))
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = cnt)
            this
        )

        (§ defn Seq create(Node t, boolean asc, int cnt)
            (ß new Seq(push(t, nil, asc), asc, cnt))
        )

        (§ defn ISeq push(Node t, ISeq stack, boolean asc)
            (§ while (ß t != nil)
                (ß stack = RT.cons(t, stack))
                (ß t = asc ? t.left() :or t.right())
            )
            stack
        )

        (§ method Object first()
            (ß stack.first())
        )

        (§ method ISeq next()
            (§ let Node t = (Node) stack.first())
            (§ let ISeq nextstack = push(asc ? t.right() :or t.left(), stack.next(), asc))
            (§ if (ß nextstack != nil)
                (§ return (ß new Seq(nextstack, asc, cnt - 1)))
            )
            nil
        )

        (§ method int count()
            (§ if (ß cnt < 0)
                (§ return (ß super.count()))
            )
            cnt
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (ß new Seq(meta, stack, asc, cnt))
        )
    )

    (class-ns NodeIterator (§ implements Iterator)
        (§ field Stack stack = new Stack())
        (§ field boolean asc)

        (§ constructor NodeIterator(Node t, boolean asc)
            (ß this.asc = asc)
            (ß push(t))
            this
        )

        (§ method void push(Node t)
            (§ while (ß t != nil)
                (ß stack.push(t))
                (ß t = asc ? t.left() :or t.right())
            )
            nil
        )

        (§ method boolean hasNext()
            (ß !stack.isEmpty())
        )

        (§ method Object next()
            (§ try 
                (§ let Node t = (Node) stack.pop())
                (ß push(asc ? t.right() :or t.left()))
                t
            )
            (§ catch (ß EmptyStackException e)
                (§ throw new NoSuchElementException())
            )
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    (class-ns KeyIterator (§ implements Iterator)
        (§ field NodeIterator it)

        (§ constructor KeyIterator(NodeIterator it)
            (ß this.it = it)
            this
        )

        (§ method boolean hasNext()
            (ß it.hasNext())
        )

        (§ method Object next()
            (ß ((Node) it.next()).key)
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    (class-ns ValIterator (§ implements Iterator)
        (§ field NodeIterator it)

        (§ constructor ValIterator(NodeIterator it)
            (ß this.it = it)
            this
        )

        (§ method boolean hasNext()
            (ß it.hasNext())
        )

        (§ method Object next()
            (ß ((Node) it.next()).val())
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def PersistentTreeSet EMPTY = new PersistentTreeSet(nil, PersistentTreeMap.EMPTY))

    (§ field IPersistentMap _meta)

    (§ defn PersistentTreeSet create(ISeq items)
        (§ let PersistentTreeSet ret = EMPTY)
        (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
            (ß ret = (PersistentTreeSet) ret.cons(items.first()))
        )
        ret
    )

    (§ defn PersistentTreeSet create(Comparator comp, ISeq items)
        (§ let PersistentTreeSet ret = new PersistentTreeSet(nil, new PersistentTreeMap(nil, comp)))
        (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
            (ß ret = (PersistentTreeSet) ret.cons(items.first()))
        )
        ret
    )

    (§ constructor PersistentTreeSet(IPersistentMap meta, IPersistentMap impl)
        (§ super(impl))
        (ß this._meta = meta)
        this
    )

    (§ method boolean equals(Object obj)
        (§ try 
            (ß super.equals(obj))
        )
        (§ catch (ß ClassCastException e)
            false
        )
    )

    (§ method boolean equiv(Object obj)
        (§ try 
            (ß super.equiv(obj))
        )
        (§ catch (ß ClassCastException e)
            false
        )
    )

    (§ method IPersistentSet disjoin(Object key)
        (§ if (ß contains(key))
            (§ return (ß new PersistentTreeSet(meta(), impl.without(key))))
        )
        this
    )

    (§ method IPersistentSet cons(Object o)
        (§ if (ß contains(o))
            (§ return this)
        )
        (ß new PersistentTreeSet(meta(), impl.assoc(o, o)))
    )

    (§ method IPersistentCollection empty()
        (ß new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty()))
    )

    (§ method ISeq rseq()
        (ß APersistentMap.KeySeq.create(((Reversible) impl).rseq()))
    )

    (§ method PersistentTreeSet withMeta(IPersistentMap meta)
        (ß new PersistentTreeSet(meta, impl))
    )

    (§ method Comparator comparator()
        (ß ((Sorted)impl).comparator())
    )

    (§ method Object entryKey(Object entry)
        entry
    )

    (§ method ISeq seq(boolean ascending)
        (§ let PersistentTreeMap m = (PersistentTreeMap) impl)
        (ß RT.keys(m.seq(ascending)))
    )

    (§ method ISeq seqFrom(Object key, boolean ascending)
        (§ let PersistentTreeMap m = (PersistentTreeMap) impl)
        (ß RT.keys(m.seqFrom(key, ascending)))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (class-ns Node
        #_transient
        (§ field AtomicReference<Thread> edit)
        (§ field Object[] array)

        (§ constructor Node(AtomicReference<Thread> edit, Object[] array)
            (ß this.edit = edit)
            (ß this.array = array)
            this
        )

        (§ constructor Node(AtomicReference<Thread> edit)
            (ß this.edit = edit)
            (ß this.array = new Object[32])
            this
        )
    )

    (§ def AtomicReference<Thread> NOEDIT = new AtomicReference<Thread>(nil))
    (§ def Node EMPTY_NODE = new Node(NOEDIT, new Object[32]))

    (§ field int cnt)
    (§ field int shift)
    (§ field Node root)
    (§ field Object[] tail)
    (§ field IPersistentMap _meta)

    (§ def PersistentVector EMPTY = new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§)))

    (§ def- IFn TRANSIENT_VECTOR_CONJ = new AFn()
        (§ reify
            (§ method Object invoke(Object coll, Object val)
                (ß ((ITransientVector)coll).conj(val))
            )
            (§ method Object invoke(Object coll)
                coll
            )
        )
    )

    (§ defn PersistentVector adopt(Object [] items)
        (ß new PersistentVector(items.length, 5, EMPTY_NODE, items))
    )

    (§ defn PersistentVector create(IReduceInit items)
        (§ let TransientVector ret = EMPTY.asTransient())
        (ß items.reduce(TRANSIENT_VECTOR_CONJ, ret))
        (ß ret.persistent())
    )

    (§ defn PersistentVector create(ISeq items)
        (§ let Object[] arr = new Object[32])
        (§ let int i = 0)
        (§ loop-when-recur [(ß )] (ß items != nil && i < 32) [(ß items = items.next())]
            (ß arr[i++] = items.first())
        )

        (§ if (ß items != nil) ;; >32, construct with array directly
            (§ let PersistentVector start = new PersistentVector(32, 5, EMPTY_NODE, arr))
            (§ let TransientVector ret = start.asTransient())
            (§ loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = ret.conj(items.first()))
            )
            (ß ret.persistent())
        )
        (§ elseif (ß i == 32) ;; exactly 32, skip copy
            (ß new PersistentVector(32, 5, EMPTY_NODE, arr))
        )
        (§ else  ;; <32, copy to minimum array and construct
            (§ let Object[] arr2 = new Object[i])
            (ß System.arraycopy(arr, 0, arr2, 0, i))
            (ß new PersistentVector(i, 5, EMPTY_NODE, arr2))
        )
    )

    (§ defn PersistentVector create(List list)
        (§ let int size = list.size())
        (§ if (ß size <= 32)
            (§ return (ß new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())))
        )

        (§ let TransientVector ret = EMPTY.asTransient())
        (§ loop-when-recur [(ß int i = 0)] (ß i < size) [(ß i++)]
            (ß ret = ret.conj(list.get(i)))
        )
        (ß ret.persistent())
    )

    (§ defn PersistentVector create(Iterable items)
        ;; optimize common case
        (§ if (ß items instanceof ArrayList)
            (§ return (ß create((ArrayList)items)))
        )

        (§ let Iterator iter = items.iterator())
        (§ let TransientVector ret = EMPTY.asTransient())
        (§ while (ß iter.hasNext())
            (ß ret = ret.conj(iter.next()))
        )
        (ß ret.persistent())
    )

    (§ defn PersistentVector create(Object... items)
        (§ let TransientVector ret = EMPTY.asTransient())
        (§ doseq [#_"Object" item items]
            (ß ret = ret.conj(item))
        )
        (ß ret.persistent())
    )

    (§ constructor PersistentVector(int cnt, int shift, Node root, Object[] tail)
        (ß this._meta = nil)
        (ß this.cnt = cnt)
        (ß this.shift = shift)
        (ß this.root = root)
        (ß this.tail = tail)
        this
    )

    (§ constructor PersistentVector(IPersistentMap meta, int cnt, int shift, Node root, Object[] tail)
        (ß this._meta = meta)
        (ß this.cnt = cnt)
        (ß this.shift = shift)
        (ß this.root = root)
        (ß this.tail = tail)
        this
    )

    (§ method TransientVector asTransient()
        (ß new TransientVector(this))
    )

    (§ method int tailoff()
        (§ if (ß cnt < 32)
            (§ return 0)
        )
        (ß ((cnt - 1) >>> 5) << 5)
    )

    (§ method Object[] arrayFor(int i)
        (§ if (ß i >= 0 && i < cnt)
            (§ if (ß i >= tailoff())
                (§ return tail)
            )
            (§ let Node node = root)
            (§ loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                (ß node = (Node) node.array[(i >>> level) & 0x01f])
            )
            (§ return (ß node.array))
        )
        (§ throw new IndexOutOfBoundsException())
    )

    (§ method Object nth(int i)
        (§ let Object[] node = arrayFor(i))
        (ß node[i & 0x01f])
    )

    (§ method Object nth(int i, Object notFound)
        (§ if (ß i >= 0 && i < cnt)
            (§ return (ß nth(i)))
        )
        notFound
    )

    (§ method PersistentVector assocN(int i, Object val)
        (§ if (ß i >= 0 && i < cnt)
            (§ if (ß i >= tailoff())
                (§ let Object[] newTail = new Object[tail.length])
                (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                (ß newTail[i & 0x01f] = val)

                (§ return (ß new PersistentVector(meta(), cnt, shift, root, newTail)))
            )

            (§ return (ß new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)))
        )
        (§ if (ß i == cnt)
            (§ return (ß cons(val)))
        )
        (§ throw new IndexOutOfBoundsException())
    )

    (§ defn- Node doAssoc(int level, Node node, int i, Object val)
        (§ let Node ret = new Node(node.edit, node.array.clone()))
        (§ if (ß level == 0)
            (ß ret.array[i & 0x01f] = val)
        )
        (§ else 
            (§ let int subidx = (i >>> level) & 0x01f)
            (ß ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
        )
        ret
    )

    (§ method int count()
        cnt
    )

    (§ method PersistentVector withMeta(IPersistentMap meta)
        (ß new PersistentVector(meta, cnt, shift, root, tail))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (§ method PersistentVector cons(Object val)
        ;; room in tail?
        (§ if (ß cnt - tailoff() < 32)
            (§ let Object[] newTail = new Object[tail.length + 1])
            (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
            (ß newTail[tail.length] = val)
            (§ return (ß new PersistentVector(meta(), cnt + 1, shift, root, newTail)))
        )
        ;; full tail, push into tree
        (§ let Node newroot)
        (§ let Node tailnode = new Node(root.edit, tail))
        (§ let int newshift = shift)
        ;; overflow root?
        (§ if (ß (cnt >>> 5) > (1 << shift))
            (ß newroot = new Node(root.edit))
            (ß newroot.array[0] = root)
            (ß newroot.array[1] = newPath(root.edit, shift, tailnode))
            (ß newshift += 5)
        )
        (§ else 
            (ß newroot = pushTail(shift, root, tailnode))
        )
        (ß new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ val )))
    )

    (§ method- Node pushTail(int level, Node parent, Node tailnode)
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (§ let int subidx = ((cnt - 1) >>> level) & 0x01f)
        (§ let Node ret = new Node(parent.edit, parent.array.clone()))
        (§ let Node nodeToInsert)
        (§ if (ß level == 5)
            (ß nodeToInsert = tailnode)
        )
        (§ else 
            (§ let Node child = (Node) parent.array[subidx])
            (ß nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
        )
        (ß ret.array[subidx] = nodeToInsert)
        ret
    )

    (§ defn- Node newPath(AtomicReference<Thread> edit, int level, Node node)
        (§ if (ß level == 0)
            (§ return node)
        )
        (§ let Node ret = new Node(edit))
        (ß ret.array[0] = newPath(edit, level - 5, node))
        ret
    )

    (§ method IChunkedSeq chunkedSeq()
        (§ if (ß count() == 0)
            (§ return nil)
        )
        (ß new ChunkedSeq(this, 0, 0))
    )

    (§ method ISeq seq()
        (ß chunkedSeq())
    )

    (§ anno @Override)
    (§ method Iterator rangedIterator(int start, int end)
        (ß new Iterator()
            (§ reify
                (§ let int i = start)
                (§ let int base = i - (i%32))
                (§ let Object[] array = (start < count()) ? arrayFor(i) :or nil)

                (§ method boolean hasNext()
                    (ß (i < end))
                )

                (§ method Object next()
                    (§ if (ß i < end)
                        (§ if (ß i - base == 32)
                            (ß array = arrayFor(i))
                            (ß base += 32)
                        )
                        (ß array[i++ & 0x01f])
                    )
                    (§ else 
                        (§ throw new NoSuchElementException())
                    )
                )

                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )
        )
    )

    (§ method Iterator iterator()
        (ß rangedIterator(0, count()))
    )

    (§ method Object reduce(IFn f)
        (§ let Object init)
        (§ if (ß cnt > 0)
            (ß init = arrayFor(0)[0])
        )
        (§ else 
            (§ return (ß f.invoke()))
        )
        (§ let int step = 0)
        (§ loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
            (§ let Object[] array = arrayFor(i))
            (§ loop-when-recur [(ß int j = (i == 0) ? 1 :or 0)] (ß j < array.length) [(ß ++j)]
                (ß init = f.invoke(init, array[j]))
                (§ if (ß RT.isReduced(init))
                    (§ return (ß ((IDeref)init).deref()))
                )
            )
            (ß step = array.length)
        )
        init
    )

    (§ method Object reduce(IFn f, Object init)
        (§ let int step = 0)
        (§ loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
            (§ let Object[] array = arrayFor(i))
            (§ loop-when-recur [(ß int j = 0)] (ß j < array.length) [(ß ++j)]
                (ß init = f.invoke(init, array[j]))
                (§ if (ß RT.isReduced(init))
                    (§ return (ß ((IDeref)init).deref()))
                )
            )
            (ß step = array.length)
        )
        init
    )

    (§ method Object kvreduce(IFn f, Object init)
        (§ let int step = 0)
        (§ loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
            (§ let Object[] array = arrayFor(i))
            (§ loop-when-recur [(ß int j = 0)] (ß j < array.length) [(ß ++j)]
                (ß init = f.invoke(init, j + i, array[j]))
                (§ if (ß RT.isReduced(init))
                    (§ return (ß ((IDeref)init).deref()))
                )
            )
            (ß step = array.length)
        )
        init
    )

    (class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
        (§ field PersistentVector vec)
        (§ field Object[] node)
        (§ field int i)
        (§ field int offset)

        (§ constructor ChunkedSeq(PersistentVector vec, int i, int offset)
            (ß this.vec = vec)
            (ß this.i = i)
            (ß this.offset = offset)
            (ß this.node = vec.arrayFor(i))
            this
        )

        (§ constructor ChunkedSeq(IPersistentMap meta, PersistentVector vec, Object[] node, int i, int offset)
            (§ super(meta))
            (ß this.vec = vec)
            (ß this.node = node)
            (ß this.i = i)
            (ß this.offset = offset)
            this
        )

        (§ constructor ChunkedSeq(PersistentVector vec, Object[] node, int i, int offset)
            (ß this.vec = vec)
            (ß this.node = node)
            (ß this.i = i)
            (ß this.offset = offset)
            this
        )

        (§ method IChunk chunkedFirst()
            (ß new ArrayChunk(node, offset))
        )

        (§ method ISeq chunkedNext()
            (§ if (ß i + node.length < vec.cnt)
                (§ return (ß new ChunkedSeq(vec, i + node.length, 0)))
            )
            nil
        )

        (§ method ISeq chunkedMore()
            (§ let ISeq s = chunkedNext())
            (§ if (ß s == nil)
                (§ return (ß PersistentList.EMPTY))
            )
            s
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (§ if (ß meta == this._meta)
                (§ return this)
            )
            (ß new ChunkedSeq(meta, vec, node, i, offset))
        )

        (§ method Object first()
            (ß node[offset])
        )

        (§ method ISeq next()
            (§ if (ß offset + 1 < node.length)
                (§ return (ß new ChunkedSeq(vec, node, i, offset + 1)))
            )
            (ß chunkedNext())
        )

        (§ method int count()
            (ß vec.cnt - (i + offset))
        )
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentVector pop()
        (§ if (ß cnt == 0)
            (§ throw new IllegalStateException("Can't pop empty vector"))
        )
        (§ if (ß cnt == 1)
            (§ return (ß EMPTY.withMeta(meta())))
        )
        (§ if (ß cnt - tailoff() > 1)
            (§ let Object[] newTail = new Object[tail.length - 1])
            (ß System.arraycopy(tail, 0, newTail, 0, newTail.length))
            (§ return (ß new PersistentVector(meta(), cnt - 1, shift, root, newTail)))
        )
        (§ let Object[] newtail = arrayFor(cnt - 2))

        (§ let Node newroot = popTail(shift, root))
        (§ let int newshift = shift)
        (§ if (ß newroot == nil)
            (ß newroot = EMPTY_NODE)
        )
        (§ if (ß shift > 5 && newroot.array[1] == nil)
            (ß newroot = (Node) newroot.array[0])
            (ß newshift -= 5)
        )
        (ß new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail))
    )

    (§ method- Node popTail(int level, Node node)
        (§ let int subidx = ((cnt - 2) >>> level) & 0x01f)
        (§ if (ß level > 5)
            (§ let Node newchild = popTail(level - 5, (Node) node.array[subidx]))
            (§ if (ß newchild == nil && subidx == 0)
                nil
            )
            (§ else 
                (§ let Node ret = new Node(root.edit, node.array.clone()))
                (ß ret.array[subidx] = newchild)
                ret
            )
        )
        (§ elseif (ß subidx == 0)
            nil
        )
        (§ else 
            (§ let Node ret = new Node(root.edit, node.array.clone()))
            (ß ret.array[subidx] = nil)
            ret
        )
    )

    (class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
        #_volatile
        (§ field int cnt)
        #_volatile
        (§ field int shift)
        #_volatile
        (§ field Node root)
        #_volatile
        (§ field Object[] tail)

        (§ constructor TransientVector(int cnt, int shift, Node root, Object[] tail)
            (ß this.cnt = cnt)
            (ß this.shift = shift)
            (ß this.root = root)
            (ß this.tail = tail)
            this
        )

        (§ constructor TransientVector(PersistentVector v)
            (§ this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail)))
            this
        )

        (§ method int count()
            (ß ensureEditable())
            cnt
        )

        (§ method Node ensureEditable(Node node)
            (§ if (ß node.edit == root.edit)
                (§ return node)
            )
            (ß new Node(root.edit, node.array.clone()))
        )

        (§ method void ensureEditable()
            (§ if (ß root.edit.get() == nil)
                (§ throw new IllegalAccessError("Transient used after persistent! call"))
            )
            nil
        )

        (§ defn Node editableRoot(Node node)
            (ß new Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone()))
        )

        (§ method PersistentVector persistent()
            (ß ensureEditable())
            (ß root.edit.set(nil))
            (§ let Object[] trimmedTail = new Object[cnt - tailoff()])
            (ß System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length))
            (ß new PersistentVector(cnt, shift, root, trimmedTail))
        )

        (§ defn Object[] editableTail(Object[] tl)
            (§ let Object[] ret = new Object[32])
            (ß System.arraycopy(tl, 0, ret, 0, tl.length))
            ret
        )

        (§ method TransientVector conj(Object val)
            (ß ensureEditable())
            (§ let int i = cnt)
            ;; room in tail?
            (§ if (ß i - tailoff() < 32)
                (ß tail[i & 0x01f] = val)
                (ß ++cnt)
                (§ return this)
            )
            ;; full tail, push into tree
            (§ let Node newroot)
            (§ let Node tailnode = new Node(root.edit, tail))
            (ß tail = new Object[32])
            (ß tail[0] = val)
            (§ let int newshift = shift)
            ;; overflow root?
            (§ if (ß (cnt >>> 5) > (1 << shift))
                (ß newroot = new Node(root.edit))
                (ß newroot.array[0] = root)
                (ß newroot.array[1] = newPath(root.edit, shift, tailnode))
                (ß newshift += 5)
            )
            (§ else 
                (ß newroot = pushTail(shift, root, tailnode))
            )
            (ß root = newroot)
            (ß shift = newshift)
            (ß ++cnt)
            this
        )

        (§ method- Node pushTail(int level, Node parent, Node tailnode)
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            (ß parent = ensureEditable(parent))
            (§ let int subidx = ((cnt - 1) >>> level) & 0x01f)
            (§ let Node ret = parent)
            (§ let Node nodeToInsert)
            (§ if (ß level == 5)
                (ß nodeToInsert = tailnode)
            )
            (§ else 
                (§ let Node child = (Node) parent.array[subidx])
                (ß nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
            )
            (ß ret.array[subidx] = nodeToInsert)
            ret
        )

        (§ method- int tailoff()
            (§ if (ß cnt < 32)
                (§ return 0)
            )
            (ß ((cnt - 1) >>> 5) << 5)
        )

        (§ method- Object[] arrayFor(int i)
            (§ if (ß i >= 0 && i < cnt)
                (§ if (ß i >= tailoff())
                    (§ return tail)
                )
                (§ let Node node = root)
                (§ loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                    (ß node = (Node) node.array[(i >>> level) & 0x01f])
                )
                (§ return (ß node.array))
            )
            (§ throw new IndexOutOfBoundsException())
        )

        (§ method- Object[] editableArrayFor(int i)
            (§ if (ß i >= 0 && i < cnt)
                (§ if (ß i >= tailoff())
                    (§ return tail)
                )
                (§ let Node node = root)
                (§ loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                    (ß node = ensureEditable((Node) node.array[(i >>> level) & 0x01f]))
                )
                (§ return (ß node.array))
            )
            (§ throw new IndexOutOfBoundsException())
        )

        (§ method Object valAt(Object key)
            ;; note - relies on ensureEditable in 2-arg valAt
            (ß valAt(key, nil))
        )

        (§ method Object valAt(Object key, Object notFound)
            (ß ensureEditable())
            (§ if (ß Util.isInteger(key))
                (§ let int i = ((Number) key).intValue())
                (§ if (ß i >= 0 && i < cnt)
                    (§ return (ß nth(i)))
                )
            )
            notFound
        )

        (§ def- Object NOT_FOUND = new Object())

        (§ method boolean containsKey(Object key)
            (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
        )

        (§ method IMapEntry entryAt(Object key)
            (§ let Object v = valAt(key, NOT_FOUND))
            (§ if (ß v != NOT_FOUND)
                (§ return (ß MapEntry.create(key, v)))
            )
            nil
        )

        (§ method Object invoke(Object arg1)
            ;; note - relies on ensureEditable in nth
            (§ if (ß Util.isInteger(arg1))
                (§ return (ß nth(((Number) arg1).intValue())))
            )
            (§ throw new IllegalArgumentException("Key must be integer"))
        )

        (§ method Object nth(int i)
            (ß ensureEditable())
            (§ let Object[] node = arrayFor(i))
            (ß node[i & 0x01f])
        )

        (§ method Object nth(int i, Object notFound)
            (§ if (ß i >= 0 && i < count())
                (§ return (ß nth(i)))
            )
            notFound
        )

        (§ method TransientVector assocN(int i, Object val)
            (ß ensureEditable())
            (§ if (ß i >= 0 && i < cnt)
                (§ if (ß i >= tailoff())
                    (ß tail[i & 0x01f] = val)
                    (§ return this)
                )

                (ß root = doAssoc(shift, root, i, val))
                (§ return this)
            )
            (§ if (ß i == cnt)
                (§ return (ß conj(val)))
            )
            (§ throw new IndexOutOfBoundsException())
        )

        (§ method TransientVector assoc(Object key, Object val)
            ;; note - relies on ensureEditable in assocN
            (§ if (ß Util.isInteger(key))
                (§ let int i = ((Number) key).intValue())
                (§ return (ß assocN(i, val)))
            )
            (§ throw new IllegalArgumentException("Key must be integer"))
        )

        (§ method- Node doAssoc(int level, Node node, int i, Object val)
            (ß node = ensureEditable(node))
            (§ let Node ret = node)
            (§ if (ß level == 0)
                (ß ret.array[i & 0x01f] = val)
            )
            (§ else 
                (§ let int subidx = (i >>> level) & 0x01f)
                (ß ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
            )
            ret
        )

        (§ method TransientVector pop()
            (ß ensureEditable())
            (§ if (ß cnt == 0)
                (§ throw new IllegalStateException("Can't pop empty vector"))
            )
            (§ if (ß cnt == 1)
                (ß cnt = 0)
                (§ return this)
            )
            (§ let int i = cnt - 1)
            ;; pop in tail?
            (§ if (ß (i & 0x01f) > 0)
                (ß --cnt)
                (§ return this)
            )

            (§ let Object[] newtail = editableArrayFor(cnt - 2))

            (§ let Node newroot = popTail(shift, root))
            (§ let int newshift = shift)
            (§ if (ß newroot == nil)
                (ß newroot = new Node(root.edit))
            )
            (§ if (ß shift > 5 && newroot.array[1] == nil)
                (ß newroot = ensureEditable((Node) newroot.array[0]))
                (ß newshift -= 5)
            )
            (ß root = newroot)
            (ß shift = newshift)
            (ß --cnt)
            (ß tail = newtail)
            this
        )

        (§ method- Node popTail(int level, Node node)
            (ß node = ensureEditable(node))
            (§ let int subidx = ((cnt - 2) >>> level) & 0x01f)
            (§ if (ß level > 5)
                (§ let Node newchild = popTail(level - 5, (Node) node.array[subidx]))
                (§ if (ß newchild == nil && subidx == 0)
                    nil
                )
                (§ else 
                    (§ let Node ret = node)
                    (ß ret.array[subidx] = newchild)
                    ret
                )
            )
            (§ elseif (ß subidx == 0)
                nil
            )
            (§ else 
                (§ let Node ret = node)
                (ß ret.array[subidx] = nil)
                ret
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    ;; method-name-string->fn
    (§ field IPersistentMap fns)

    (§ constructor ProxyHandler(IPersistentMap fns)
        (ß this.fns = fns)
        this
    )

    (§ method Object invoke(Object proxy, Method method, Object[] args) (§ throws Throwable)
        (§ let Class rt = method.getReturnType())
        (§ let IFn fn = (IFn) fns.valAt(method.getName()))
        (§ if (ß fn == nil)
            (§ if (ß rt == Void.TYPE)
                (§ return nil)
            )
            (§ elseif (ß method.getName().equals("equals"))
                (§ return (ß (proxy == args[0])))
            )
            (§ elseif (ß method.getName().equals("hashCode"))
                (§ return (ß System.identityHashCode(proxy)))
            )
            (§ elseif (ß method.getName().equals("toString"))
                (§ return (ß "Proxy: " + System.identityHashCode(proxy)))
            )
            (§ throw new UnsupportedOperationException())
        )
        (§ let Object ret = fn.applyTo(ArraySeq.create(args)))
        (§ if (ß rt == Void.TYPE)
            (§ return nil)
        )
        (§ elseif (ß rt.isPrimitive())
            (§ if (ß rt == Character.TYPE)
                (§ return ret)
            )
            (§ elseif (ß rt == Integer.TYPE)
                (§ return (ß ((Number) ret).intValue()))
            )
            (§ elseif (ß rt == Long.TYPE)
                (§ return (ß ((Number) ret).longValue()))
            )
            (§ elseif (ß rt == Float.TYPE)
                (§ return (ß ((Number) ret).floatValue()))
            )
            (§ elseif (ß rt == Double.TYPE)
                (§ return (ß ((Number) ret).doubleValue()))
            )
            (§ elseif (ß rt == Boolean.TYPE && !(ret instanceof Boolean))
                (§ return (ß (ret == nil) ? Boolean.FALSE :or Boolean.TRUE))
            )
            (§ elseif (ß rt == Byte.TYPE)
                (§ return (ß (byte) ((Number) ret).intValue()))
            )
            (§ elseif (ß rt == Short.TYPE)
                (§ return (ß (short) ((Number) ret).intValue()))
            )
        )
        ret
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (§ def- int CHUNK_SIZE = 32)

    ;; Invariants guarantee this is never an "empty" seq
    (§ field Object end)
    (§ field Object start)
    (§ field Object step)
    (§ field BoundsCheck boundsCheck)

    #_volatile
    (§ field- IChunk _chunk) ;; lazy
    #_volatile
    (§ field- ISeq _chunkNext) ;; lazy
    #_volatile
    (§ field- ISeq _next) ;; cached

    #_private
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(Object val))
    )

    (§ defn- BoundsCheck positiveStep(Object end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(Object val)
                    (ß Numbers.gte(val, end))
                )
            )
        )
    )

    (§ defn- BoundsCheck negativeStep(Object end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(Object val)
                    (ß Numbers.lte(val, end))
                )
            )
        )
    )

    (§ constructor- Range(Object start, Object end, Object step, BoundsCheck boundsCheck)
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        this
    )

    (§ constructor- Range(Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ constructor- Range(IPersistentMap meta, Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
        (§ super(meta))
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ defn ISeq create(Object end)
        (§ if (ß Numbers.isPos(end))
            (§ return (ß new Range(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn ISeq create(Object start, Object end)
        (ß create(start, end, 1))
    )

    (§ defn ISeq create(Object start, Object end, Object step)
        (§ if (ß (Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end))
            (§ return (ß PersistentList.EMPTY))
        )
        (§ if (ß Numbers.isZero(step))
            (§ return (ß Repeat.create(start)))
        )
        (ß new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end)))
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (ß meta == _meta)
            (§ return this)
        )
        (ß new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext))
    )

    (§ method Object first()
        start
    )

    (§ method void forceChunk()
        (§ if (ß _chunk != nil)
            (§ return nil)
        )

        (§ let Object[] arr = new Object[CHUNK_SIZE])
        (§ let int n = 0)
        (§ let Object val = start)
        (§ while (ß n < CHUNK_SIZE)
            (ß arr[n++] = val)
            (ß val = Numbers.addP(val, step))
            (§ if (ß boundsCheck.exceededBounds(val))
                ;; partial last chunk
                (ß _chunk = new ArrayChunk(arr, 0, n))
                (§ return nil)
            )
        )

        ;; full last chunk
        (§ if (ß boundsCheck.exceededBounds(val))
            (ß _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
            (§ return nil)
        )

        ;; full intermediate chunk
        (ß _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
        (ß _chunkNext = new Range(val, end, step, boundsCheck))
        nil
    )

    (§ method ISeq next()
        (§ if (ß _next != nil)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (§ if (ß _chunk.count() > 1)
            (§ let IChunk smallerChunk = _chunk.dropFirst())
            (ß _next = new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext))
            (§ return (ß _next))
        )
        (ß chunkedNext())
    )

    (§ method IChunk chunkedFirst()
        (ß forceChunk())
        (ß _chunk)
    )

    (§ method ISeq chunkedNext()
        (ß chunkedMore().seq())
    )

    (§ method ISeq chunkedMore()
        (ß forceChunk())
        (§ if (ß _chunkNext == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    (§ method Object reduce(IFn f)
        (§ let Object acc = start)
        (§ let Number i = Numbers.addP(start, step))
        (§ while (ß !boundsCheck.exceededBounds(i))
            (ß acc = f.invoke(acc, i))
            (§ if (ß RT.isReduced(acc))
                (§ return (ß ((Reduced)acc).deref()))
            )
            (ß i = Numbers.addP(i, step))
        )
        acc
    )

    (§ method Object reduce(IFn f, Object val)
        (§ let Object acc = val)
        (§ let Object i = start)
        (§ while (ß !boundsCheck.exceededBounds(i))
            (ß acc = f.invoke(acc, i))
            (§ if (ß RT.isReduced(acc))
                (§ return (ß ((Reduced)acc).deref()))
            )
            (ß i = Numbers.addP(i, step))
        )
        acc
    )

    (§ method Iterator iterator()
        (ß new RangeIterator())
    )

    #_private
    #_non-static
    (class-ns RangeIterator (§ implements Iterator)
        (§ field- Object next)

        (§ constructor RangeIterator()
            (ß this.next = start)
            this
        )

        (§ method boolean hasNext()
            (ß (!boundsCheck.exceededBounds(next)))
        )

        (§ method Object next()
            (§ if (ß hasNext())
                (§ let Object ret = next)
                (ß next = Numbers.addP(next, step))
                ret
            )
            (§ else 
                (§ throw new NoSuchElementException())
            )
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (§ field BigInteger numerator)
    (§ field BigInteger denominator)

    (§ constructor Ratio(BigInteger numerator, BigInteger denominator)
        (ß this.numerator = numerator)
        (ß this.denominator = denominator)
        this
    )

    (§ method boolean equals(Object arg0)
        (ß (arg0 != nil && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator)))
    )

    (§ method int hashCode()
        (ß numerator.hashCode() :xor denominator.hashCode())
    )

    (§ method String toString()
        (ß numerator.toString() + "/" + denominator.toString())
    )

    (§ method int intValue()
        (ß (int) doubleValue())
    )

    (§ method long longValue()
        (ß bigIntegerValue().longValue())
    )

    (§ method float floatValue()
        (ß (float)doubleValue())
    )

    (§ method double doubleValue()
        (ß decimalValue(MathContext.DECIMAL64).doubleValue())
    )

    (§ method BigDecimal decimalValue()
        (ß decimalValue(MathContext.UNLIMITED))
    )

    (§ method BigDecimal decimalValue(MathContext mc)
        (§ let BigDecimal numerator = new BigDecimal(this.numerator))
        (§ let BigDecimal denominator = new BigDecimal(this.denominator))

        (ß numerator.divide(denominator, mc))
    )

    (§ method BigInteger bigIntegerValue()
        (ß numerator.divide(denominator))
    )

    (§ method int compareTo(Object o)
        (§ let Number other = (Number)o)
        (ß Numbers.compare(this, other))
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def Keyword FORM_KW = Keyword.intern("form"))
    (§ def Keyword SPLICING_KW = Keyword.intern("splicing?"))

    (§ field Object form)
    (§ field Boolean splicing)

    (§ defn ReaderConditional create(Object form, boolean splicing)
        (ß new ReaderConditional(form, splicing))
    )

    (§ constructor- ReaderConditional(Object form, boolean splicing)
        (ß this.form = form)
        (ß this.splicing = splicing)
        this
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method Object valAt(Object key, Object notFound)
        (§ if (ß FORM_KW.equals(key))
            (ß this.form)
        )
        (§ elseif (ß SPLICING_KW.equals(key))
            (ß this.splicing)
        )
        (§ else 
            notFound
        )
    )

    (§ anno @Override)
    (§ method boolean equals(Object o)
        (§ if (ß this == o)
            (§ return true)
        )
        (§ if (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (§ let ReaderConditional that = (ReaderConditional) o)

        (§ if (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
            (§ return false)
        )
        (§ if (ß (splicing != nil) ? !splicing.equals(that.splicing) :or that.splicing != nil)
            (§ return false)
        )
        true
    )

    (§ anno @Override)
    (§ method int hashCode()
        (§ let int result = Util.hash(form))
        (ß result = 31 * result + Util.hash(splicing))
        result
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (§ field int i = 0)
    (§ field int basecnt)
    (§ field ILookup rec)
    (§ field IPersistentVector basefields)
    (§ field Iterator extmap)

    (§ constructor RecordIterator(ILookup rec, IPersistentVector basefields, Iterator extmap)
        (ß this.rec = rec)
        (ß this.basefields = basefields)
        (ß this.basecnt = basefields.count())
        (ß this.extmap = extmap)
        this
    )

    (§ method boolean hasNext()
        (§ if (ß i < basecnt)
            true
        )
        (§ else 
            (ß extmap.hasNext())
        )
    )

    (§ method Object next()
        (§ if (ß i < basecnt)
            (§ let Object k = basefields.nth(i))
            (ß i++)
            (ß MapEntry.create(k, rec.valAt(k)))
        )
        (§ else 
            (ß extmap.next())
        )
    )

    (§ method void remove()
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (§ field Object val)

    (§ constructor Reduced(Object val)
        (ß this.val = val)
        this
    )

    (§ method Object deref()
        val
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (§ method int compareTo(Ref ref)
        (§ if (ß this.id == ref.id)
            0
        )
        (§ elseif (ß this.id < ref.id)
            -1
        )
        (§ else 
            1
        )
    )

    (§ method int getMinHistory()
        minHistory
    )

    (§ method Ref setMinHistory(int minHistory)
        (ß this.minHistory = minHistory)
        this
    )

    (§ method int getMaxHistory()
        maxHistory
    )

    (§ method Ref setMaxHistory(int maxHistory)
        (ß this.maxHistory = maxHistory)
        this
    )

    (class-ns TVal
        (§ field Object val)
        (§ field long point)
        (§ field TVal prior)
        (§ field TVal next)

        (§ constructor TVal(Object val, long point, TVal prior)
            (ß this.val = val)
            (ß this.point = point)
            (ß this.prior = prior)
            (ß this.next = prior.next)
            (ß this.prior.next = this)
            (ß this.next.prior = this)
            this
        )

        (§ constructor TVal(Object val, long point)
            (ß this.val = val)
            (ß this.point = point)
            (ß this.next = this)
            (ß this.prior = this)
            this
        )
    )

    (§ field TVal tvals)
    (§ field AtomicInteger faults)
    (§ field ReentrantReadWriteLock lock)
    (§ field LockingTransaction.Info tinfo)
    (§ field long id)

    #_volatile
    (§ field int minHistory = 0)
    #_volatile
    (§ field int maxHistory = 10)

    (§ def AtomicLong ids = new AtomicLong())

    (§ constructor Ref(Object initVal)
        (§ this(initVal, nil))
        this
    )

    (§ constructor Ref(Object initVal, IPersistentMap meta)
        (§ super(meta))
        (ß this.id = ids.getAndIncrement())
        (ß this.faults = new AtomicInteger())
        (ß this.lock = new ReentrantReadWriteLock())
        (ß tvals = new TVal(initVal, 0))
        this
    )

    ;; the latest val

    ;; ok out of transaction
    (§ method Object currentVal()
        (§ try 
            (ß lock.readLock().lock())
            (§ if (ß tvals != nil)
                (§ return (ß tvals.val))
            )
            (§ throw new IllegalStateException(this.toString() + " is unbound."))
        )
        (§ finally 
            (ß lock.readLock().unlock())
        )
    )

    (§ method Object deref()
        (§ let LockingTransaction t = LockingTransaction.getRunning())
        (§ if (ß t == nil)
            (§ return (ß currentVal()))
        )
        (ß t.doGet(this))
    )

    (§ method Object set(Object val)
        (ß LockingTransaction.getEx().doSet(this, val))
    )

    (§ method Object commute(IFn fn, ISeq args)
        (ß LockingTransaction.getEx().doCommute(this, fn, args))
    )

    (§ method Object alter(IFn fn, ISeq args)
        (§ let LockingTransaction t = LockingTransaction.getEx())
        (ß t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args))))
    )

    (§ method void touch()
        (ß LockingTransaction.getEx().doEnsure(this))
        nil
    )

    (§ method boolean isBound()
        (§ try 
            (ß lock.readLock().lock())
            (ß (tvals != nil))
        )
        (§ finally 
            (ß lock.readLock().unlock())
        )
    )

    (§ method void trimHistory()
        (§ try 
            (ß lock.writeLock().lock())
            (§ if (ß tvals != nil)
                (ß tvals.next = tvals)
                (ß tvals.prior = tvals)
            )
        )
        (§ finally 
            (ß lock.writeLock().unlock())
        )
        nil
    )

    (§ method int getHistoryCount()
        (§ try 
            (ß lock.writeLock().lock())
            (ß histCount())
        )
        (§ finally 
            (ß lock.writeLock().unlock())
        )
    )

    (§ method int histCount()
        (§ if (ß tvals == nil)
            0
        )
        (§ else 
            (§ let int count = 0)
            (§ loop-when-recur [(ß TVal tv = tvals.next)] (ß tv != tvals) [(ß tv = tv.next)]
                (ß count++)
            )
            count
        )
    )

    (§ method IFn fn()
        (ß (IFn) deref())
    )

    (§ method Object call()
        (ß invoke())
    )

    (§ method void run()
        (ß invoke())
        nil
    )

    (§ method Object invoke()
        (ß fn().invoke())
    )

    (§ method Object invoke(Object arg1)
        (ß fn().invoke(arg1))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß fn().invoke(arg1, arg2))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß fn().invoke(arg1, arg2, arg3))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß fn().invoke(arg1, arg2, arg3, arg4))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args))
    )

    (§ method Object applyTo(ISeq arglist)
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

(class-ns Reflector
    (§ defn Object invokeInstanceMethod(Object target, String methodName, Object[] args)
        (§ let Class c = target.getClass())
        (§ let List methods = getMethods(c, args.length, methodName, false))
        (ß invokeMatchingMethod(methodName, methods, target, args))
    )

    (§ defn- Throwable getCauseOrElse(Exception e)
        (§ if (ß e.getCause() != nil)
            (§ return (ß e.getCause()))
        )
        e
    )

    (§ defn- RuntimeException throwCauseOrElseException(Exception e)
        (§ if (ß e.getCause() != nil)
            (§ throw Util.sneakyThrow(e.getCause()))
        )
        (§ throw Util.sneakyThrow(e))
    )

    (§ defn- String noMethodReport(String methodName, Object target)
        (ß "No matching method found: " + methodName + ((target == nil) ? "" :or " for " + target.getClass()))
    )

    (§ defn Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
        (§ let Method m = nil)
        (§ let Object[] boxedArgs = nil)
        (§ if (ß methods.isEmpty())
            (§ throw new IllegalArgumentException(noMethodReport(methodName, target)))
        )
        (§ elseif (ß methods.size() == 1)
            (ß m = (Method) methods.get(0))
            (ß boxedArgs = boxArgs(m.getParameterTypes(), args))
        )
        (§ else  ;; overloaded w/same arity
            (§ let Method foundm = nil)
            (§ loop-when-recur [(ß Iterator i = methods.iterator())] (ß i.hasNext()) [(ß )]
                (ß m = (Method) i.next())

                (§ let Class[] params = m.getParameterTypes())
                (§ if (ß isCongruent(params, args))
                    (§ if (ß foundm == nil || Compiler.subsumes(params, foundm.getParameterTypes()))
                        (ß foundm = m)
                        (ß boxedArgs = boxArgs(params, args))
                    )
                )
            )
            (ß m = foundm)
        )
        (§ if (ß m == nil)
            (§ throw new IllegalArgumentException(noMethodReport(methodName, target)))
        )

        (§ if (ß !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
            ;; public method of non-public class, try to find it in hierarchy
            (§ let Method oldm = m)
            (ß m = getAsMethodOfPublicBase(target.getClass(), m))
            (§ if (ß m == nil)
                (§ throw new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString()))
            )
        )
        (§ try 
            (ß prepRet(m.getReturnType(), m.invoke(target, boxedArgs)))
        )
        (§ catch (ß Exception e)
            (§ throw Util.sneakyThrow(getCauseOrElse(e)))
        )
    )

    (§ defn Method getAsMethodOfPublicBase(Class c, Method m)
        (§ doseq [#_"Class" iface (ß c.getInterfaces())]
            (§ doseq [#_"Method" im (ß iface.getMethods())]
                (§ if (ß isMatch(im, m))
                    (§ return im)
                )
            )
        )
        (§ let Class sc = c.getSuperclass())
        (§ if (ß sc == nil)
            (§ return nil)
        )
        (§ doseq [#_"Method" scm (ß sc.getMethods())]
            (§ if (ß isMatch(scm, m))
                (§ return scm)
            )
        )
        (ß getAsMethodOfPublicBase(sc, m))
    )

    (§ defn boolean isMatch(Method lhs, Method rhs)
        (§ if (ß !lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers()))
            (§ return false)
        )

        (§ let Class[] types1 = lhs.getParameterTypes())
        (§ let Class[] types2 = rhs.getParameterTypes())
        (§ if (ß types1.length != types2.length)
            (§ return false)
        )

        (§ let boolean match = true)
        (§ loop-when-recur [(ß int i = 0)] (ß i < types1.length) [(ß ++i)]
            (§ if (ß !types1[i].isAssignableFrom(types2[i]))
                (ß match = false)
                (§ break )
            )
        )
        match
    )

    (§ defn Object invokeConstructor(Class c, Object[] args)
        (§ try 
            (§ let Constructor[] allctors = c.getConstructors())
            (§ let ArrayList ctors = new ArrayList())
            (§ loop-when-recur [(ß int i = 0)] (ß i < allctors.length) [(ß i++)]
                (§ let Constructor ctor = allctors[i])
                (§ if (ß ctor.getParameterTypes().length == args.length)
                    (ß ctors.add(ctor))
                )
            )
            (§ if (ß ctors.isEmpty())
                (§ throw new IllegalArgumentException("No matching ctor found for " + c))
            )
            (§ elseif (ß ctors.size() == 1)
                (§ let Constructor ctor = (Constructor) ctors.get(0))
                (ß ctor.newInstance(boxArgs(ctor.getParameterTypes(), args)))
            )
            (§ else  ;; overloaded w/same arity
                (§ loop-when-recur [(ß Iterator iterator = ctors.iterator())] (ß iterator.hasNext()) [(ß )]
                    (§ let Constructor ctor = (Constructor) iterator.next())
                    (§ let Class[] params = ctor.getParameterTypes())
                    (§ if (ß isCongruent(params, args))
                        (§ let Object[] boxedArgs = boxArgs(params, args))
                        (§ return (ß ctor.newInstance(boxedArgs)))
                    )
                )
                (§ throw new IllegalArgumentException("No matching ctor found for " + c))
            )
        )
        (§ catch (ß Exception e)
            (§ throw Util.sneakyThrow(getCauseOrElse(e)))
        )
    )

    (§ defn Object invokeStaticMethodVariadic(String className, String methodName, Object... args)
        (ß invokeStaticMethod(className, methodName, args))
    )

    (§ defn Object invokeStaticMethod(String className, String methodName, Object[] args)
        (§ let Class c = RT.classForName(className))
        (ß invokeStaticMethod(c, methodName, args))
    )

    (§ defn Object invokeStaticMethod(Class c, String methodName, Object[] args)
        (§ if (ß methodName.equals("new"))
            (§ return (ß invokeConstructor(c, args)))
        )
        (§ let List methods = getMethods(c, args.length, methodName, true))
        (ß invokeMatchingMethod(methodName, methods, nil, args))
    )

    (§ defn Object getStaticField(String className, String fieldName)
        (§ let Class c = RT.classForName(className))
        (ß getStaticField(c, fieldName))
    )

    (§ defn Object getStaticField(Class c, String fieldName)
        (§ let Field f = getField(c, fieldName, true))
        (§ if (ß f != nil)
            (§ try 
                (§ return (ß prepRet(f.getType(), f.get(nil))))
            )
            (§ catch (ß IllegalAccessException e)
                (§ throw Util.sneakyThrow(e))
            )
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c))
    )

    (§ defn Object setStaticField(String className, String fieldName, Object val)
        (§ let Class c = RT.classForName(className))
        (ß setStaticField(c, fieldName, val))
    )

    (§ defn Object setStaticField(Class c, String fieldName, Object val)
        (§ let Field f = getField(c, fieldName, true))
        (§ if (ß f != nil)
            (§ try 
                (ß f.set(nil, boxArg(f.getType(), val)))
            )
            (§ catch (ß IllegalAccessException e)
                (§ throw Util.sneakyThrow(e))
            )
            (§ return val)
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c))
    )

    (§ defn Object getInstanceField(Object target, String fieldName)
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, fieldName, false))
        (§ if (ß f != nil)
            (§ try 
                (§ return (ß prepRet(f.getType(), f.get(target))))
            )
            (§ catch (ß IllegalAccessException e)
                (§ throw Util.sneakyThrow(e))
            )
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass()))
    )

    (§ defn Object setInstanceField(Object target, String fieldName, Object val)
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, fieldName, false))
        (§ if (ß f != nil)
            (§ try 
                (ß f.set(target, boxArg(f.getType(), val)))
            )
            (§ catch (ß IllegalAccessException e)
                (§ throw Util.sneakyThrow(e))
            )
            (§ return val)
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass()))
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (§ defn Object invokeNoArgInstanceMember(Object target, String name)
        (ß invokeNoArgInstanceMember(target, name, false))
    )

    (§ defn Object invokeNoArgInstanceMember(Object target, String name, boolean requireField)
        (§ let Class c = target.getClass())

        (§ if (ß requireField)
            (§ let Field f = getField(c, name, false))
            (§ if (ß f != nil)
                (ß getInstanceField(target, name))
            )
            (§ else 
                (§ throw new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass()))
            )
        )
        (§ else 
            (§ let List meths = getMethods(c, 0, name, false))
            (§ if (ß meths.size() > 0)
                (ß invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY))
            )
            (§ else 
                (ß getInstanceField(target, name))
            )
        )
    )

    (§ defn Object invokeInstanceMember(Object target, String name)
        ;; check for field first
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, name, false))
        (§ if (ß f != nil) ;; field get
            (§ try 
                (§ return (ß prepRet(f.getType(), f.get(target))))
            )
            (§ catch (ß IllegalAccessException e)
                (§ throw Util.sneakyThrow(e))
            )
        )
        (ß invokeInstanceMethod(target, name, RT.EMPTY_ARRAY))
    )

    (§ defn Object invokeInstanceMember(String name, Object target, Object arg1)
        ;; check for field first
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, name, false))
        (§ if (ß f != nil) ;; field set
            (§ try 
                (ß f.set(target, boxArg(f.getType(), arg1)))
            )
            (§ catch (ß IllegalAccessException e)
                (§ throw Util.sneakyThrow(e))
            )
            (§ return arg1)
        )
        (ß invokeInstanceMethod(target, name, new Object[] (§ arg1 )))
    )

    (§ defn Object invokeInstanceMember(String name, Object target, Object... args)
        (ß invokeInstanceMethod(target, name, args))
    )

    (§ defn Field getField(Class c, String name, boolean getStatics)
        (§ let Field[] allfields = c.getFields())
        (§ loop-when-recur [(ß int i = 0)] (ß i < allfields.length) [(ß i++)]
            (§ if (ß name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
                (§ return (ß allfields[i]))
            )
        )
        nil
    )

    (§ defn List getMethods(Class c, int arity, String name, boolean getStatics)
        (§ let Method[] allmethods = c.getMethods())
        (§ let ArrayList methods = new ArrayList())
        (§ let ArrayList bridgeMethods = new ArrayList())
        (§ loop-when-recur [(ß int i = 0)] (ß i < allmethods.length) [(ß i++)]
            (§ let Method method = allmethods[i])
            (§ if (ß name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity)
                (§ try 
                    (§ if (ß method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method))
                        (ß bridgeMethods.add(method))
                    )
                    (§ else 
                        (ß methods.add(method))
                    )
                )
                (§ catch (ß NoSuchMethodException e)
                )
            )
        )

        (§ if (ß methods.isEmpty())
            (ß methods.addAll(bridgeMethods))
        )
        (§ if (ß !getStatics && c.isInterface())
            (ß allmethods = Object.class.getMethods())
            (§ loop-when-recur [(ß int i = 0)] (ß i < allmethods.length) [(ß i++)]
                (§ if (ß name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity)
                    (ß methods.add(allmethods[i]))
                )
            )
        )
        methods
    )

    (§ defn Object boxArg(Class paramType, Object arg)
        (§ if (ß !paramType.isPrimitive())
            (§ return (ß paramType.cast(arg)))
        )
        (§ elseif (ß paramType == boolean.class)
            (§ return (ß Boolean.class.cast(arg)))
        )
        (§ elseif (ß paramType == char.class)
            (§ return (ß Character.class.cast(arg)))
        )
        (§ elseif (ß arg instanceof Number)
            (§ let Number n = (Number) arg)
            (§ if (ß paramType == int.class)
                (§ return (ß n.intValue()))
            )
            (§ elseif (ß paramType == float.class)
                (§ return (ß n.floatValue()))
            )
            (§ elseif (ß paramType == double.class)
                (§ return (ß n.doubleValue()))
            )
            (§ elseif (ß paramType == long.class)
                (§ return (ß n.longValue()))
            )
            (§ elseif (ß paramType == short.class)
                (§ return (ß n.shortValue()))
            )
            (§ elseif (ß paramType == byte.class)
                (§ return (ß n.byteValue()))
            )
        )
        (§ throw new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName()))
    )

    (§ defn Object[] boxArgs(Class[] params, Object[] args)
        (§ if (ß params.length == 0)
            (§ return nil)
        )
        (§ let Object[] ret = new Object[params.length])
        (§ loop-when-recur [(ß int i = 0)] (ß i < params.length) [(ß i++)]
            (§ let Object arg = args[i])
            (§ let Class paramType = params[i])
            (ß ret[i] = boxArg(paramType, arg))
        )
        ret
    )

    (§ defn boolean paramArgTypeMatch(Class paramType, Class argType)
        (§ if (ß argType == nil)
            (§ return (ß !paramType.isPrimitive()))
        )
        (§ if (ß paramType == argType || paramType.isAssignableFrom(argType))
            (§ return true)
        )
        (§ if (ß paramType == int.class)
            (§ return (ß argType == Integer.class
                || argType == long.class
                || argType == Long.class
                || argType == short.class
                || argType == byte.class))
        )
        (§ elseif (ß paramType == float.class)
            (§ return (ß argType == Float.class
                || argType == double.class))
        )
        (§ elseif (ß paramType == double.class)
            (§ return (ß argType == Double.class
                || argType == float.class))
        )
        (§ elseif (ß paramType == long.class)
            (§ return (ß argType == Long.class
                || argType == int.class
                || argType == short.class
                || argType == byte.class))
        )
        (§ elseif (ß paramType == char.class)
            (§ return (ß argType == Character.class))
        )
        (§ elseif (ß paramType == short.class)
            (§ return (ß argType == Short.class))
        )
        (§ elseif (ß paramType == byte.class)
            (§ return (ß argType == Byte.class))
        )
        (§ elseif (ß paramType == boolean.class)
            (§ return (ß argType == Boolean.class))
        )
        false
    )

    (§ defn boolean isCongruent(Class[] params, Object[] args)
        (§ let boolean ret = false)
        (§ if (ß args == nil)
            (§ return (ß (params.length == 0)))
        )
        (§ if (ß params.length == args.length)
            (ß ret = true)
            (§ loop-when-recur [(ß int i = 0)] (ß ret && i < params.length) [(ß i++)]
                (§ let Object arg = args[i])
                (§ let Class argType = (arg == nil) ? nil :or arg.getClass())
                (§ let Class paramType = params[i])
                (ß ret = paramArgTypeMatch(paramType, argType))
            )
        )
        ret
    )

    (§ defn Object prepRet(Class c, Object x)
        (§ if (ß !(c.isPrimitive() || c == Boolean.class))
            (§ return x)
        )
        (§ if (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE))
        )
        x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (§ def- long INFINITE = -1)

    (§ field- long count) ;; always INFINITE or >0
    (§ field- Object val)
    #_volatile
    (§ field- ISeq _next) ;; cached

    (§ constructor- Repeat(long count, Object val)
        (ß this.count = count)
        (ß this.val = val)
        this
    )

    (§ constructor- Repeat(IPersistentMap meta, long count, Object val)
        (§ super(meta))
        (ß this.count = count)
        (ß this.val = val)
        this
    )

    (§ defn Repeat create(Object val)
        (ß new Repeat(INFINITE, val))
    )

    (§ defn ISeq create(long count, Object val)
        (§ if (ß count <= 0)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Repeat(count, val))
    )

    (§ method Object first()
        val
    )

    (§ method ISeq next()
        (§ if (ß _next == nil)
            (§ if (ß count > 1)
                (ß _next = new Repeat(count - 1, val))
            )
            (§ elseif (ß count == INFINITE)
                (ß _next = this)
            )
        )
        (ß _next)
    )

    (§ method Repeat withMeta(IPersistentMap meta)
        (ß new Repeat(meta, count, val))
    )

    (§ method Object reduce(IFn f)
        (§ let Object ret = val)
        (§ if (ß count == INFINITE)
            (§ while true
                (ß ret = f.invoke(ret, val))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
        )
        (§ else 
            (§ loop-when-recur [(ß long i = 1)] (ß i < count) [(ß i++)]
                (ß ret = f.invoke(ret, val))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )
    )

    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = start)
        (§ if (ß count == INFINITE)
            (§ while true
                (ß ret = f.invoke(ret, val))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
        )
        (§ else 
            (§ loop-when-recur [(ß long i = 0)] (ß i < count) [(ß i++)]
                (ß ret = f.invoke(ret, val))
                (§ if (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_abstract
(class-ns RestFn (§ extends AFunction)
    (§ abstract int getRequiredArity())

    #_protected
    (§ method Object doInvoke(Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object arg20, Object args)
        nil
    )

    (§ method Object applyTo(ISeq args)
        (§ if (ß RT.boundedLength(args, getRequiredArity()) <= getRequiredArity())
            (§ return (ß AFn.applyToHelper(this, Util.ret1(args, args = nil))))
        )
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (§ return (ß doInvoke(Util.ret1(args, args = nil))))
            )
            (§ case 1)
            (do
                (§ return (ß doInvoke(args.first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 2)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 3)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 4)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 5)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 6)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 7)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 8)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 9)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 10)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 11)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 12)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 13)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 14)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 15)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 16)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 17)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 18)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 19)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 20)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
        )
        (ß throwArity(-1))
    )

    (§ method Object invoke()
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(nil))
            )
            (§ default )
            (do
                (ß throwArity(0))
            )
        )
    )

    (§ method Object invoke(Object arg1)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(Util.ret1(arg1, arg1 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(1))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(2))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    ArraySeq.create(
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(3))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    ArraySeq.create(
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    ArraySeq.create(
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(4))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(5))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(6))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(7))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(8))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(9))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(10))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(11))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(12))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(13))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(14))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(15))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(16))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(17))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(18))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(19))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil),
                        Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                        ArraySeq.create(
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(20))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ontoArrayPrepend(args,
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil),
                        Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                        ArraySeq.create(args)))
            )
            (§ default )
            (do
                (ß throwArity(21))
            )
        )
    )

    #_protected
    (§ defn ISeq ontoArrayPrepend(Object[] array, Object... args)
        (§ let ISeq ret = ArraySeq.create(array))
        (§ loop-when-recur [(ß int i = args.length - 1)] (ß i >= 0) [(ß --i)]
            (ß ret = RT.cons(args[i], ret))
        )
        ret
    )

    #_protected
    (§ defn ISeq findKey(Object key, ISeq args)
        (§ while (ß args != nil)
            (§ if (ß key == args.first())
                (§ return (ß args.next()))
            )
            (ß args = RT.next(args))
            (ß args = RT.next(args))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(§ interface Reversible
    (§ abstract ISeq rseq())
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

(class-ns RT
    (§ def Boolean T = Boolean.TRUE)
    (§ def Boolean F = Boolean.FALSE)
    (§ def String LOADER_SUFFIX = "__init")

    ;; simple-symbol->class
    (§ def IPersistentMap DEFAULT_IMPORTS = map(
      #_map Symbol.intern("Boolean"), Boolean.class,
      #_map Symbol.intern("Byte"), Byte.class,
      #_map Symbol.intern("Character"), Character.class,
      #_map Symbol.intern("Class"), Class.class,
      #_map Symbol.intern("ClassLoader"), ClassLoader.class,
      #_map Symbol.intern("Compiler"), Compiler.class,
      #_map Symbol.intern("Double"), Double.class,
      #_map Symbol.intern("Enum"), Enum.class,
      #_map Symbol.intern("Float"), Float.class,
      #_map Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
      #_map Symbol.intern("Integer"), Integer.class,
      #_map Symbol.intern("Long"), Long.class,
      #_map Symbol.intern("Math"), Math.class,
      #_map Symbol.intern("Number"), Number.class,
      #_map Symbol.intern("Object"), Object.class,
      #_map Symbol.intern("Package"), Package.class,
      #_map Symbol.intern("Process"), Process.class,
      #_map Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
      #_map Symbol.intern("Runtime"), Runtime.class,
      #_map Symbol.intern("RuntimePermission"), RuntimePermission.class,
      #_map Symbol.intern("SecurityManager"), SecurityManager.class,
      #_map Symbol.intern("Short"), Short.class,
      #_map Symbol.intern("StackTraceElement"), StackTraceElement.class,
      #_map Symbol.intern("StrictMath"), StrictMath.class,
      #_map Symbol.intern("String"), String.class,
      #_map Symbol.intern("StringBuffer"), StringBuffer.class,
      #_map Symbol.intern("StringBuilder"), StringBuilder.class,
      #_map Symbol.intern("System"), System.class,
      #_map Symbol.intern("Thread"), Thread.class,
      #_map Symbol.intern("ThreadGroup"), ThreadGroup.class,
      #_map Symbol.intern("ThreadLocal"), ThreadLocal.class,
      #_map Symbol.intern("Throwable"), Throwable.class,
      #_map Symbol.intern("Void"), Void.class,
      #_map Symbol.intern("Appendable"), Appendable.class,
      #_map Symbol.intern("CharSequence"), CharSequence.class,
      #_map Symbol.intern("Cloneable"), Cloneable.class,
      #_map Symbol.intern("Comparable"), Comparable.class,
      #_map Symbol.intern("Iterable"), Iterable.class,
      #_map Symbol.intern("Readable"), Readable.class,
      #_map Symbol.intern("Runnable"), Runnable.class,
      #_map Symbol.intern("Callable"), Callable.class,
      #_map Symbol.intern("BigInteger"), BigInteger.class,
      #_map Symbol.intern("BigDecimal"), BigDecimal.class,
      #_map Symbol.intern("ArithmeticException"), ArithmeticException.class,
      #_map Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
      #_map Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
      #_map Symbol.intern("ClassCastException"), ClassCastException.class,
      #_map Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
      #_map Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
      #_map Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
      #_map Symbol.intern("Exception"), Exception.class,
      #_map Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
      #_map Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
      #_map Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
      #_map Symbol.intern("IllegalStateException"), IllegalStateException.class,
      #_map Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
      #_map Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
      #_map Symbol.intern("InstantiationException"), InstantiationException.class,
      #_map Symbol.intern("InterruptedException"), InterruptedException.class,
      #_map Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
      #_map Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
      #_map Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
      #_map Symbol.intern("NullPointerException"), NullPointerException.class,
      #_map Symbol.intern("NumberFormatException"), NumberFormatException.class,
      #_map Symbol.intern("RuntimeException"), RuntimeException.class,
      #_map Symbol.intern("SecurityException"), SecurityException.class,
      #_map Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
      #_map Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
      #_map Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
      #_map Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
      #_map Symbol.intern("AssertionError"), AssertionError.class,
      #_map Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
      #_map Symbol.intern("ClassFormatError"), ClassFormatError.class,
      #_map Symbol.intern("Error"), Error.class,
      #_map Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
      #_map Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
      #_map Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
      #_map Symbol.intern("InstantiationError"), InstantiationError.class,
      #_map Symbol.intern("InternalError"), InternalError.class,
      #_map Symbol.intern("LinkageError"), LinkageError.class,
      #_map Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
      #_map Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
      #_map Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
      #_map Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
      #_map Symbol.intern("StackOverflowError"), StackOverflowError.class,
      #_map Symbol.intern("ThreadDeath"), ThreadDeath.class,
      #_map Symbol.intern("UnknownError"), UnknownError.class,
      #_map Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
      #_map Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
      #_map Symbol.intern("VerifyError"), VerifyError.class,
      #_map Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
      #_map Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
      #_map Symbol.intern("Thread$State"), Thread.State.class,
      #_map Symbol.intern("Deprecated"), Deprecated.class,
      #_map Symbol.intern("Override"), Override.class,
      #_map Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    ))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (§ def Charset UTF8 = Charset.forName("UTF-8"))

    (§ defn Object readTrueFalseUnknown(String s)
        (§ if (ß s.equals("true"))
            (§ return (ß Boolean.TRUE))
        )
        (§ elseif (ß s.equals("false"))
            (§ return (ß Boolean.FALSE))
        )
        (ß Keyword.intern(nil, "unknown"))
    )

    (§ def Namespace CLOIURE_NS = Namespace.findOrCreate(Symbol.intern("cloiure.core")))
    (§ def Var OUT = Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic())
    (§ def Var IN = Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic())
    (§ def Var ERR = Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic())
    (§ def Keyword TAG_KEY = Keyword.intern(nil, "tag"))
    (§ def Keyword CONST_KEY = Keyword.intern(nil, "const"))
    (§ def Var AGENT = Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), nil).setDynamic())
    (§ def Object readeval = readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true")))
    (§ def Var READEVAL = Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"),  readeval).setDynamic())
    (§ def Var DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic())
    (§ def Var DEFAULT_DATA_READER_FN = Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic())
    (§ def Var DEFAULT_DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map()))
    (§ def Var SUPPRESS_READ = Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), nil).setDynamic())
    (§ def Var ASSERT = Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic())
    (§ def Var MATH_CONTEXT = Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), nil).setDynamic())
    (§ def Keyword LINE_KEY = Keyword.intern(nil, "line"))
    (§ def Keyword COLUMN_KEY = Keyword.intern(nil, "column"))
    (§ def Keyword FILE_KEY = Keyword.intern(nil, "file"))
    (§ def Keyword DECLARED_KEY = Keyword.intern(nil, "declared"))
    (§ def Keyword DOC_KEY = Keyword.intern(nil, "doc"))
    (§ def Var USE_CONTEXT_CLASSLOADER = Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic())
    ;; boolean
    (§ def Var UNCHECKED_MATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic())

    (§ def Symbol LOAD_FILE = Symbol.intern("load-file"))
    (§ def Symbol IN_NAMESPACE = Symbol.intern("in-ns"))
    (§ def Symbol NAMESPACE = Symbol.intern("ns"))
    (§ def Symbol IDENTICAL = Symbol.intern("identical?"))
    (§ def Var CMD_LINE_ARGS = Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), nil).setDynamic())
    ;; symbol
    (§ def Var CURRENT_NS = Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic())

    (§ def Var FLUSH_ON_NEWLINE = Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic())
    (§ def Var PRINT_META = Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic())
    (§ def Var PRINT_READABLY = Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic())
    (§ def Var PRINT_DUP = Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic())
    (§ def Var WARN_ON_REFLECTION = Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic())
    (§ def Var ALLOW_UNRESOLVED_VARS = Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic())
    (§ def Var READER_RESOLVER = Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), nil).setDynamic())

    (§ def Var IN_NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F))
    (§ def Var NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("ns"), F))
    (§ def Var FN_LOADER_VAR = Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), nil).setDynamic())
    (§ def Var PRINT_INITIALIZED = Var.intern(CLOIURE_NS, Symbol.intern("print-initialized")))
    (§ def Var PR_ON = Var.intern(CLOIURE_NS, Symbol.intern("pr-on")))

    (§ def IFn inNamespace = new AFn()
        (§ reify
            (§ method Object invoke(Object arg1)
                (§ let Symbol nsname = (Symbol) arg1)
                (§ let Namespace ns = Namespace.findOrCreate(nsname))
                (ß CURRENT_NS.set(ns))
                ns
            )
        )
    )

    (§ def IFn bootNamespace = new AFn()
        (§ reify
            (§ method Object invoke(Object __form, Object __env, Object arg1)
                (§ let Symbol nsname = (Symbol) arg1)
                (§ let Namespace ns = Namespace.findOrCreate(nsname))
                (ß CURRENT_NS.set(ns))
                ns
            )
        )
    )

    (§ defn List<String> processCommandLine(String[] args)
        (§ let List<String> arglist = Arrays.asList(args))
        (§ let int split = arglist.indexOf("--"))
        (§ if (ß split >= 0)
            (ß CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length))))
            (§ return (ß arglist.subList(0, split)))
        )
        arglist
    )

    ;; duck typing stderr plays nice with e.g. swank
    (§ defn PrintWriter errPrintWriter()
        (§ let Writer w = (Writer) ERR.deref())
        (§ if (ß w instanceof PrintWriter)
            (ß (PrintWriter) w)
        )
        (§ else 
            (ß new PrintWriter(w))
        )
    )

    (§ def Object[] EMPTY_ARRAY = new Object[] (§))
    (§ def Comparator DEFAULT_COMPARATOR = new DefaultComparator())

    #_private
    (class-ns DefaultComparator (§ implements Comparator)
        (§ method int compare(Object o1, Object o2)
            (ß Util.compare(o1, o2))
        )
    )

    (§ def AtomicInteger id = new AtomicInteger(1))

    (§ defn void addURL(Object url) (§ throws MalformedURLException)
        (§ let URL u = (url instanceof String) ? (new URL((String) url)) :or (URL) url)
        (§ let ClassLoader ccl = Thread.currentThread().getContextClassLoader())
        (§ if (ß ccl instanceof DynamicClassLoader)
            (ß ((DynamicClassLoader)ccl).addURL(u))
        )
        (§ else 
            (§ throw new IllegalAccessError("Context classloader is not a DynamicClassLoader"))
        )
        nil
    )

    (§ def boolean checkSpecAsserts = Boolean.getBoolean("cloiure.spec.check-asserts"))
    (§ def boolean instrumentMacros = ! Boolean.getBoolean("cloiure.spec.skip-macros"))
    #_volatile
    (§ def boolean CHECK_SPECS = false)

    (§ static
        (§ let Keyword arglistskw = Keyword.intern(nil, "arglists"))
        (§ let Symbol namesym = Symbol.intern("name"))
        (ß OUT.setTag(Symbol.intern("java.io.Writer")))
        (ß CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace")))
        (ß AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil")))
        (ß AGENT.setTag(Symbol.intern("cloiure.lang.Agent")))
        (ß MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext")))
        (§ let Var nv = Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace))
        (ß nv.setMacro())
        (§ let Var v)
        (ß v = Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace))
        (ß v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym)))))
        (ß v = Var.intern(CLOIURE_NS, LOAD_FILE, new AFn()
            (§ reify
                (§ method Object invoke(Object arg1)
                    (§ try 
                        (ß Compiler.loadFile((String) arg1))
                    )
                    (§ catch (ß IOException e)
                        (§ throw Util.sneakyThrow(e))
                    )
                )
            ))
        )
        (ß v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym)))))
        (§ try 
            (ß doInit())
        )
        (§ catch (ß Exception e)
            (§ throw Util.sneakyThrow(e))
        )

        (ß CHECK_SPECS = RT.instrumentMacros)
    )

    (§ defn Keyword keyword(String ns, String name)
        (ß Keyword.intern((Symbol.intern(ns, name))))
    )

    (§ defn Var var(String ns, String name)
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name)))
    )

    (§ defn Var var(String ns, String name, Object init)
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name), init))
    )

    (§ defn void loadResourceScript(String name) (§ throws IOException)
        (ß loadResourceScript(name, true))
        nil
    )

    (§ defn void maybeLoadResourceScript(String name) (§ throws IOException)
        (ß loadResourceScript(name, false))
        nil
    )

    (§ defn void loadResourceScript(String name, boolean failIfNotFound) (§ throws IOException)
        (ß loadResourceScript(RT.class, name, failIfNotFound))
        nil
    )

    (§ defn void loadResourceScript(Class c, String name) (§ throws IOException)
        (ß loadResourceScript(c, name, true))
        nil
    )

    (§ defn void loadResourceScript(Class c, String name, boolean failIfNotFound) (§ throws IOException)
        (§ let int slash = name.lastIndexOf(\/))
        (§ let String file = (slash >= 0) ? name.substring(slash + 1) :or name)
        (§ let InputStream ins = resourceAsStream(baseLoader(), name))
        (§ if (ß ins != nil)
            (§ try 
                (ß Compiler.load(new InputStreamReader(ins, UTF8), name, file))
            )
            (§ finally 
                (ß ins.close())
            )
        )
        (§ elseif (ß failIfNotFound)
            (§ throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + name))
        )
        nil
    )

    (§ defn void init()
        (ß RT.errPrintWriter().println("No need to call RT.init() anymore"))
        nil
    )

    (§ defn long lastModified(URL url, String libfile) (§ throws IOException)
        (§ let URLConnection connection = url.openConnection())
        (§ try 
            (§ if (ß url.getProtocol().equals("jar"))
                (ß ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime())
            )
            (§ else 
                (ß connection.getLastModified())
            )
        )
        (§ finally 
            (§ let InputStream ins = connection.getInputStream())
            (§ if (ß ins != nil)
                (ß ins.close())
            )
        )
    )

    (§ defn void compile(String cljfile) (§ throws IOException)
        (§ let InputStream ins = resourceAsStream(baseLoader(), cljfile))
        (§ if (ß ins != nil)
            (§ try 
                (ß Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/"))))
            )
            (§ finally 
                (ß ins.close())
            )
        )
        (§ else 
            (§ throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + cljfile))
        )
        nil
    )

    (§ defn void load(String scriptbase) (§ throws IOException, ClassNotFoundException)
        (ß load(scriptbase, true))
        nil
    )

    (§ defn void load(String scriptbase, boolean failIfNotFound) (§ throws IOException, ClassNotFoundException)
        (§ let String classfile = scriptbase + LOADER_SUFFIX + ".class")
        (§ let String cljfile = scriptbase + ".cli")
        (§ let String scriptfile = cljfile)
        (§ let URL classURL = getResource(baseLoader(), classfile))
        (§ let URL cljURL = getResource(baseLoader(), scriptfile))
        (§ if (ß cljURL == nil)
            (ß scriptfile = scriptbase + ".clic")
            (ß cljURL = getResource(baseLoader(), scriptfile))
        )
        (§ let boolean loaded = false)

        (§ if (ß (classURL != nil && (cljURL == nil || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == nil)
            (§ try 
                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map CURRENT_NS, CURRENT_NS.deref(),
                      #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                      #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                )))
                (ß loaded = (loadClassForName(scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil))
            )
            (§ finally 
                (ß Var.popThreadBindings())
            )
        )
        (§ if (ß !loaded && cljURL != nil)
            (§ if (ß booleanCast(Compiler.COMPILE_FILES.deref()))
                (ß compile(scriptfile))
            )
            (§ else 
                (ß loadResourceScript(RT.class, scriptfile))
            )
        )
        (§ elseif (ß !loaded && failIfNotFound)
            (§ throw new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile, scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or "")))
        )
        nil
    )

    (§ defn void doInit() (§ throws ClassNotFoundException, IOException)
        (ß load("cloiure/core"))

        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map CURRENT_NS, CURRENT_NS.deref(),
              #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        )))
        (§ try 
            (§ let Symbol USER = Symbol.intern("user"))
            (§ let Symbol CLOIURE = Symbol.intern("cloiure.core"))

            (§ let Var in_ns = var("cloiure.core", "in-ns"))
            (§ let Var refer = var("cloiure.core", "refer"))
            (ß in_ns.invoke(USER))
            (ß refer.invoke(CLOIURE))
            (ß maybeLoadResourceScript("user.cli"))

            ;; start socket servers
            (§ let Var require = var("cloiure.core", "require"))
            (§ let Symbol SERVER = Symbol.intern("cloiure.core.server"))
            (ß require.invoke(SERVER))
            (§ let Var start_servers = var("cloiure.core.server", "start-servers"))
            (ß start_servers.invoke(System.getProperties()))
        )
        (§ finally 
            (ß Var.popThreadBindings())
        )
        nil
    )

    (§ defn int nextID()
        (ß id.getAndIncrement())
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (§ defn void loadLibrary(String libname)
        (ß System.loadLibrary(libname))
        nil
    )

    (§ def- int CHUNK_SIZE = 32)

    (§ defn ISeq chunkIteratorSeq(Iterator iter)
        (§ if (ß iter.hasNext())
            (§ return (ß new LazySeq(new AFn()
                (§ reify
                    (§ method Object invoke()
                        (§ let Object[] arr = new Object[CHUNK_SIZE])
                        (§ let int n = 0)
                        (§ while (ß iter.hasNext() && n < CHUNK_SIZE)
                            (ß arr[n++] = iter.next())
                        )
                        (ß new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter)))
                    )
                )))
            )
        )
        nil
    )

    (§ defn ISeq seq(Object coll)
        (§ if (ß coll instanceof ASeq)
            (ß (ASeq) coll)
        )
        (§ elseif (ß coll instanceof LazySeq)
            (ß ((LazySeq) coll).seq())
        )
        (§ else 
            (ß seqFrom(coll))
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (§ defn ISeq seqFrom(Object coll)
        (§ if (ß coll instanceof Seqable)
            (ß ((Seqable) coll).seq())
        )
        (§ elseif (ß coll == nil)
            nil
        )
        (§ elseif (ß coll instanceof Iterable)
            (ß chunkIteratorSeq(((Iterable) coll).iterator()))
        )
        (§ elseif (ß coll.getClass().isArray())
            (ß ArraySeq.createFromObject(coll))
        )
        (§ elseif (ß coll instanceof CharSequence)
            (ß StringSeq.create((CharSequence) coll))
        )
        (§ elseif (ß coll instanceof Map)
            (ß seq(((Map) coll).entrySet()))
        )
        (§ else 
            (§ let Class c = coll.getClass())
            (§ let Class sc = c.getSuperclass())
            (§ throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName()))
        )
    )

    (§ defn boolean canSeq(Object coll)
        (ß coll instanceof ISeq
            || coll instanceof Seqable
            || coll == nil
            || coll instanceof Iterable
            || coll.getClass().isArray()
            || coll instanceof CharSequence
            || coll instanceof Map)
    )

    (§ defn Iterator iter(Object coll)
        (§ if (ß coll instanceof Iterable)
            (ß ((Iterable)coll).iterator())
        )
        (§ elseif (ß coll == nil)
            (ß new Iterator()
                (§ reify
                    (§ method boolean hasNext()
                        false
                    )

                    (§ method Object next()
                        (§ throw new NoSuchElementException())
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )
        (§ elseif (ß coll instanceof Map)
            (ß ((Map)coll).entrySet().iterator())
        )
        (§ elseif (ß coll instanceof String)
            (§ let String s = (String) coll)
            (ß new Iterator()
                (§ reify
                    (§ let int i = 0)

                    (§ method boolean hasNext()
                        (ß (i < s.length()))
                    )

                    (§ method Object next()
                        (ß s.charAt(i++))
                    )

                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )
            )
        )
        (§ elseif (ß coll.getClass().isArray())
            (ß ArrayIter.createFromObject(coll))
        )
        (§ else 
            (ß iter(seq(coll)))
        )
    )

    (§ defn Object seqOrElse(Object o)
        (ß (seq(o) == nil) ? nil :or o)
    )

    (§ defn ISeq keys(Object coll)
        (§ if (ß coll instanceof IPersistentMap)
            (ß APersistentMap.KeySeq.createFromMap((IPersistentMap)coll))
        )
        (§ else 
            (ß APersistentMap.KeySeq.create(seq(coll)))
        )
    )

    (§ defn ISeq vals(Object coll)
        (§ if (ß coll instanceof IPersistentMap)
            (ß APersistentMap.ValSeq.createFromMap((IPersistentMap)coll))
        )
        (§ else 
            (ß APersistentMap.ValSeq.create(seq(coll)))
        )
    )

    (§ defn IPersistentMap meta(Object x)
        (§ if (ß x instanceof IMeta)
            (§ return (ß ((IMeta) x).meta()))
        )
        nil
    )

    (§ defn int count(Object o)
        (§ if (ß o instanceof Counted)
            (§ return (ß ((Counted) o).count()))
        )
        (ß countFrom(Util.ret1(o, o = nil)))
    )

    (§ defn int countFrom(Object o)
        (§ if (ß o == nil)
            (§ return 0)
        )
        (§ elseif (ß o instanceof IPersistentCollection)
            (§ let ISeq s = seq(o))
            (ß o = nil)
            (§ let int i = 0)
            (§ loop-when-recur [(ß )] (ß s != nil) [(ß s = s.next())]
                (§ if (ß s instanceof Counted)
                    (§ return (ß i + s.count()))
                )
                (ß i++)
            )
            (§ return i)
        )
        (§ elseif (ß o instanceof CharSequence)
            (§ return (ß ((CharSequence) o).length()))
        )
        (§ elseif (ß o instanceof Collection)
            (§ return (ß ((Collection) o).size()))
        )
        (§ elseif (ß o instanceof Map)
            (§ return (ß ((Map) o).size()))
        )
        (§ elseif (ß o instanceof Map.Entry)
            (§ return 2)
        )
        (§ elseif (ß o.getClass().isArray())
            (§ return (ß Array.getLength(o)))
        )

        (§ throw new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName()))
    )

    (§ defn IPersistentCollection conj(IPersistentCollection coll, Object x)
        (§ if (ß coll == nil)
            (§ return (ß new PersistentList(x)))
        )
        (ß coll.cons(x))
    )

    (§ defn ISeq cons(Object x, Object coll)
        (§ if (ß coll == nil)
            (ß new PersistentList(x))
        )
        (§ elseif (ß coll instanceof ISeq)
            (ß new Cons(x, (ISeq) coll))
        )
        (§ else 
            (ß new Cons(x, seq(coll)))
        )
    )

    (§ defn Object first(Object x)
        (§ if (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).first()))
        )
        (§ let ISeq seq = seq(x))
        (§ if (ß seq == nil)
            (§ return nil)
        )
        (ß seq.first())
    )

    (§ defn Object second(Object x)
        (ß first(next(x)))
    )

    (§ defn Object third(Object x)
        (ß first(next(next(x))))
    )

    (§ defn Object fourth(Object x)
        (ß first(next(next(next(x)))))
    )

    (§ defn ISeq next(Object x)
        (§ if (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).next()))
        )
        (§ let ISeq seq = seq(x))
        (§ if (ß seq == nil)
            (§ return nil)
        )
        (ß seq.next())
    )

    (§ defn ISeq more(Object x)
        (§ if (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).more()))
        )
        (§ let ISeq seq = seq(x))
        (§ if (ß seq == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß seq.more())
    )

    (§ defn Object peek(Object x)
        (§ if (ß x == nil)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).peek())
    )

    (§ defn Object pop(Object x)
        (§ if (ß x == nil)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).pop())
    )

    (§ defn Object get(Object coll, Object key)
        (§ if (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key)))
        )
        (ß getFrom(coll, key))
    )

    (§ defn Object getFrom(Object coll, Object key)
        (§ if (ß coll == nil)
            (§ return nil)
        )
        (§ elseif (ß coll instanceof Map)
            (§ let Map m = (Map) coll)
            (§ return (ß m.get(key)))
        )
        (§ elseif (ß coll instanceof IPersistentSet)
            (§ let IPersistentSet set = (IPersistentSet) coll)
            (§ return (ß set.get(key)))
        )
        (§ elseif (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (§ let int n = ((Number) key).intValue())
            (§ if (ß n >= 0 && n < count(coll))
                (§ return (ß nth(coll, n)))
            )
            (§ return nil)
        )
        (§ elseif (ß coll instanceof ITransientSet)
            (§ let ITransientSet set = (ITransientSet) coll)
            (§ return (ß set.get(key)))
        )

        nil
    )

    (§ defn Object get(Object coll, Object key, Object notFound)
        (§ if (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key, notFound)))
        )
        (ß getFrom(coll, key, notFound))
    )

    (§ defn Object getFrom(Object coll, Object key, Object notFound)
        (§ if (ß coll == nil)
            (§ return notFound)
        )
        (§ elseif (ß coll instanceof Map)
            (§ let Map m = (Map) coll)
            (§ if (ß m.containsKey(key))
                (§ return (ß m.get(key)))
            )
            (§ return notFound)
        )
        (§ elseif (ß coll instanceof IPersistentSet)
            (§ let IPersistentSet set = (IPersistentSet) coll)
            (§ if (ß set.contains(key))
                (§ return (ß set.get(key)))
            )
            (§ return notFound)
        )
        (§ elseif (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (§ let int n = ((Number) key).intValue())
            (§ return (ß (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound))
        )
        (§ elseif (ß coll instanceof ITransientSet)
            (§ let ITransientSet set = (ITransientSet) coll)
            (§ if (ß set.contains(key))
                (§ return (ß set.get(key)))
            )
            (§ return notFound)
        )
        notFound
    )

    (§ defn Associative assoc(Object coll, Object key, Object val)
        (§ if (ß coll == nil)
            (§ return (ß new PersistentArrayMap(new Object[] (§ key, val ))))
        )
        (ß ((Associative) coll).assoc(key, val))
    )

    (§ defn Object contains(Object coll, Object key)
        (§ if (ß coll == nil)
            (§ return (ß F))
        )
        (§ elseif (ß coll instanceof Associative)
            (§ return (ß ((Associative) coll).containsKey(key) ? T :or F))
        )
        (§ elseif (ß coll instanceof IPersistentSet)
            (§ return (ß ((IPersistentSet) coll).contains(key) ? T :or F))
        )
        (§ elseif (ß coll instanceof Map)
            (§ let Map m = (Map) coll)
            (§ return (ß m.containsKey(key) ? T :or F))
        )
        (§ elseif (ß coll instanceof Set)
            (§ let Set s = (Set) coll)
            (§ return (ß s.contains(key) ? T :or F))
        )
        (§ elseif (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (§ let int n = ((Number) key).intValue())
            (§ return (ß (n >= 0 && n < count(coll)) ? T :or F))
        )
        (§ elseif (ß coll instanceof ITransientSet)
            (§ return (ß ((ITransientSet)coll).contains(key) ? T :or F))
        )
        (§ elseif (ß coll instanceof ITransientAssociative2)
            (§ return (ß (((ITransientAssociative2)coll).containsKey(key)) ? T :or F))
        )
        (§ throw new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName()))
    )

    (§ defn Object find(Object coll, Object key)
        (§ if (ß coll == nil)
            (§ return nil)
        )
        (§ elseif (ß coll instanceof Associative)
            (§ return (ß ((Associative) coll).entryAt(key)))
        )
        (§ elseif (ß coll instanceof Map)
            (§ let Map m = (Map) coll)
            (§ if (ß m.containsKey(key))
                (§ return (ß MapEntry.create(key, m.get(key))))
            )
            (§ return nil)
        )
        (§ elseif (ß coll instanceof ITransientAssociative2)
            (§ return (ß ((ITransientAssociative2) coll).entryAt(key)))
        )
        (§ throw new IllegalArgumentException("find not supported on type: " + coll.getClass().getName()))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (§ defn ISeq findKey(Keyword key, ISeq keyvals)
        (§ while (ß keyvals != nil)
            (§ let ISeq r = keyvals.next())
            (§ if (ß r == nil)
                (§ throw Util.runtimeException("Malformed keyword argslist"))
            )
            (§ if (ß keyvals.first() == key)
                (§ return r)
            )
            (ß keyvals = r.next())
        )
        nil
    )

    (§ defn Object dissoc(Object coll, Object key)
        (§ if (ß coll == nil)
            (§ return nil)
        )
        (ß ((IPersistentMap) coll).without(key))
    )

    (§ defn Object nth(Object coll, int n)
        (§ if (ß coll instanceof Indexed)
            (§ return (ß ((Indexed) coll).nth(n)))
        )
        (ß nthFrom(Util.ret1(coll, coll = nil), n))
    )

    (§ defn Object nthFrom(Object coll, int n)
        (§ if (ß coll == nil)
            nil
        )
        (§ elseif (ß coll instanceof CharSequence)
            (ß Character.valueOf(((CharSequence) coll).charAt(n)))
        )
        (§ elseif (ß coll.getClass().isArray())
            (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n)))
        )
        (§ elseif (ß coll instanceof RandomAccess)
            (ß ((List) coll).get(n))
        )
        (§ elseif (ß coll instanceof Matcher)
            (ß ((Matcher) coll).group(n))
        )
        (§ elseif (ß coll instanceof Map.Entry)
            (§ let Map.Entry e = (Map.Entry) coll)
            (§ if (ß n == 0)
                (§ return (ß e.getKey()))
            )
            (§ elseif (ß n == 1)
                (§ return (ß e.getValue()))
            )
            (§ throw new IndexOutOfBoundsException())
        )
        (§ elseif (ß coll instanceof Sequential)
            (§ let ISeq seq = RT.seq(coll))
            (ß coll = nil)
            (§ loop-when-recur [(ß int i = 0)] (ß i <= n && seq != nil) [(ß ++i, seq = seq.next())]
                (§ if (ß i == n)
                    (§ return (ß seq.first()))
                )
            )
            (§ throw new IndexOutOfBoundsException())
        )
        (§ else 
            (§ throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName()))
        )
    )

    (§ defn Object nth(Object coll, int n, Object notFound)
        (§ if (ß coll instanceof Indexed)
            (§ let Indexed v = (Indexed) coll)
            (§ return (ß v.nth(n, notFound)))
        )
        (ß nthFrom(coll, n, notFound))
    )

    (§ defn Object nthFrom(Object coll, int n, Object notFound)
        (§ if (ß coll == nil)
            notFound
        )
        (§ elseif (ß n < 0)
            notFound
        )
        (§ elseif (ß coll instanceof CharSequence)
            (§ let CharSequence s = (CharSequence) coll)
            (§ if (ß n < s.length())
                (§ return (ß Character.valueOf(s.charAt(n))))
            )
            notFound
        )
        (§ elseif (ß coll.getClass().isArray())
            (§ if (ß n < Array.getLength(coll))
                (§ return (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
            )
            notFound
        )
        (§ elseif (ß coll instanceof RandomAccess)
            (§ let List list = (List) coll)
            (§ if (ß n < list.size())
                (§ return (ß list.get(n)))
            )
            notFound
        )
        (§ elseif (ß coll instanceof Matcher)
            (§ let Matcher m = (Matcher) coll)
            (§ if (ß n < m.groupCount())
                (§ return (ß m.group(n)))
            )
            notFound
        )
        (§ elseif (ß coll instanceof Map.Entry)
            (§ let Map.Entry e = (Map.Entry) coll)
            (§ if (ß n == 0)
                (§ return (ß e.getKey()))
            )
            (§ elseif (ß n == 1)
                (§ return (ß e.getValue()))
            )
            notFound
        )
        (§ elseif (ß coll instanceof Sequential)
            (§ let ISeq seq = RT.seq(coll))
            (ß coll = nil)
            (§ loop-when-recur [(ß int i = 0)] (ß i <= n && seq != nil) [(ß ++i, seq = seq.next())]
                (§ if (ß i == n)
                    (§ return (ß seq.first()))
                )
            )
            notFound
        )
        (§ else 
            (§ throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName()))
        )
    )

    (§ defn Object assocN(int n, Object val, Object coll)
        (§ if (ß coll == nil)
            nil
        )
        (§ elseif (ß coll instanceof IPersistentVector)
            (ß ((IPersistentVector) coll).assocN(n, val))
        )
        (§ elseif (ß coll instanceof Object[])
            ;; hmm... this is not persistent
            (§ let Object[] array = ((Object[]) coll))
            (ß array[n] = val)
            array
        )
        (§ else 
            nil
        )
    )

    (§ defn boolean hasTag(Object o, Object tag)
        (ß Util.equals(tag, RT.get(RT.meta(o), TAG_KEY)))
    )

    (§ defn Object box(Object x)
        x
    )

    (§ defn Character box(char x)
        (ß Character.valueOf(x))
    )

    (§ defn Object box(boolean x)
        (ß x ? T :or F)
    )

    (§ defn Object box(Boolean x)
        x
    )

    (§ defn Number box(byte x)
        x
    )

    (§ defn Number box(short x)
        x
    )

    (§ defn Number box(int x)
        x
    )

    (§ defn Number box(long x)
        x
    )

    (§ defn Number box(float x)
        x
    )

    (§ defn Number box(double x)
        x
    )

    (§ defn char charCast(Object x)
        (§ if (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (§ let long n = ((Number) x).longValue())
        (§ if (ß n < Character.MIN_VALUE || n > Character.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        (ß (char) n)
    )

    (§ defn char charCast(byte x)
        (§ let char i = (char) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        i
    )

    (§ defn char charCast(short x)
        (§ let char i = (char) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        i
    )

    (§ defn char charCast(char x)
        x
    )

    (§ defn char charCast(int x)
        (§ let char i = (char) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        i
    )

    (§ defn char charCast(long x)
        (§ let char i = (char) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        i
    )

    (§ defn char charCast(float x)
        (§ if (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for char: " + x))
    )

    (§ defn char charCast(double x)
        (§ if (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for char: " + x))
    )

    (§ defn boolean booleanCast(Object x)
        (§ if (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x).booleanValue()))
        )
        (ß (x != nil))
    )

    (§ defn boolean booleanCast(boolean x)
        x
    )

    (§ defn byte byteCast(Object x)
        (§ if (ß x instanceof Byte)
            (§ return (ß ((Byte) x).byteValue()))
        )
        (§ let long n = longCast(x))
        (§ if (ß n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        (ß (byte) n)
    )

    (§ defn byte byteCast(byte x)
        x
    )

    (§ defn byte byteCast(short x)
        (§ let byte i = (byte) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        i
    )

    (§ defn byte byteCast(int x)
        (§ let byte i = (byte) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        i
    )

    (§ defn byte byteCast(long x)
        (§ let byte i = (byte) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        i
    )

    (§ defn byte byteCast(float x)
        (§ if (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
    )

    (§ defn byte byteCast(double x)
        (§ if (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
    )

    (§ defn short shortCast(Object x)
        (§ if (ß x instanceof Short)
            (§ return (ß ((Short) x).shortValue()))
        )
        (§ let long n = longCast(x))
        (§ if (ß n < Short.MIN_VALUE || n > Short.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for short: " + x))
        )
        (ß (short) n)
    )

    (§ defn short shortCast(byte x)
        x
    )

    (§ defn short shortCast(short x)
        x
    )

    (§ defn short shortCast(int x)
        (§ let short i = (short) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for short: " + x))
        )
        i
    )

    (§ defn short shortCast(long x)
        (§ let short i = (short) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for short: " + x))
        )
        i
    )

    (§ defn short shortCast(float x)
        (§ if (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for short: " + x))
    )

    (§ defn short shortCast(double x)
        (§ if (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for short: " + x))
    )

    (§ defn int intCast(Object x)
        (§ if (ß x instanceof Integer)
            (§ return (ß ((Integer)x).intValue()))
        )
        (§ if (ß x instanceof Number)
            (§ let long n = longCast(x))
            (§ return (ß intCast(n)))
        )
        (ß ((Character) x).charValue())
    )

    (§ defn int intCast(char x)
        x
    )

    (§ defn int intCast(byte x)
        x
    )

    (§ defn int intCast(short x)
        x
    )

    (§ defn int intCast(int x)
        x
    )

    (§ defn int intCast(float x)
        (§ if (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for int: " + x))
        )
        (ß (int) x)
    )

    (§ defn int intCast(long x)
        (§ let int i = (int) x)
        (§ if (ß i != x)
            (§ throw new IllegalArgumentException("Value out of range for int: " + x))
        )
        i
    )

    (§ defn int intCast(double x)
        (§ if (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for int: " + x))
        )
        (ß (int) x)
    )

    (§ defn long longCast(Object x)
        (§ if (ß x instanceof Integer || x instanceof Long)
            (ß ((Number) x).longValue())
        )
        (§ elseif (ß x instanceof BigInt)
            (§ let BigInt bi = (BigInt) x)
            (§ if (ß bi.bipart == nil)
                (ß bi.lpart)
            )
            (§ else 
                (§ throw new IllegalArgumentException("Value out of range for long: " + x))
            )
        )
        (§ elseif (ß x instanceof BigInteger)
            (§ let BigInteger bi = (BigInteger) x)
            (§ if (ß bi.bitLength() < 64)
                (ß bi.longValue())
            )
            (§ else 
                (§ throw new IllegalArgumentException("Value out of range for long: " + x))
            )
        )
        (§ elseif (ß x instanceof Byte || x instanceof Short)
            (ß ((Number) x).longValue())
        )
        (§ elseif (ß x instanceof Ratio)
            (ß longCast(((Ratio)x).bigIntegerValue()))
        )
        (§ elseif (ß x instanceof Character)
            (ß longCast(((Character) x).charValue()))
        )
        (§ else 
            (ß longCast(((Number)x).doubleValue()))
        )
    )

    (§ defn long longCast(byte x)
        x
    )

    (§ defn long longCast(short x)
        x
    )

    (§ defn long longCast(int x)
        x
    )

    (§ defn long longCast(float x)
        (§ if (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for long: " + x))
        )
        (ß (long) x)
    )

    (§ defn long longCast(long x)
        x
    )

    (§ defn long longCast(double x)
        (§ if (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for long: " + x))
        )
        (ß (long) x)
    )

    (§ defn float floatCast(Object x)
        (§ if (ß x instanceof Float)
            (§ return (ß ((Float) x).floatValue()))
        )
        (§ let double n = ((Number) x).doubleValue())
        (§ if (ß n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for float: " + x))
        )
        (ß (float) n)
    )

    (§ defn float floatCast(byte x)
        x
    )

    (§ defn float floatCast(short x)
        x
    )

    (§ defn float floatCast(int x)
        x
    )

    (§ defn float floatCast(float x)
        x
    )

    (§ defn float floatCast(long x)
        x
    )

    (§ defn float floatCast(double x)
        (§ if (ß x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
            (§ throw new IllegalArgumentException("Value out of range for float: " + x))
        )
        (ß (float) x)
    )

    (§ defn double doubleCast(Object x)
        (ß ((Number) x).doubleValue())
    )

    (§ defn double doubleCast(byte x)
        x
    )

    (§ defn double doubleCast(short x)
        x
    )

    (§ defn double doubleCast(int x)
        x
    )

    (§ defn double doubleCast(float x)
        x
    )

    (§ defn double doubleCast(long x)
        x
    )

    (§ defn double doubleCast(double x)
        x
    )

    (§ defn byte uncheckedByteCast(Object x)
        (ß ((Number) x).byteValue())
    )

    (§ defn byte uncheckedByteCast(byte x)
        x
    )

    (§ defn byte uncheckedByteCast(short x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(int x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(long x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(float x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(double x)
        (ß (byte) x)
    )

    (§ defn short uncheckedShortCast(Object x)
        (ß ((Number) x).shortValue())
    )

    (§ defn short uncheckedShortCast(byte x)
        x
    )

    (§ defn short uncheckedShortCast(short x)
        x
    )

    (§ defn short uncheckedShortCast(int x)
        (ß (short) x)
    )

    (§ defn short uncheckedShortCast(long x)
        (ß (short) x)
    )

    (§ defn short uncheckedShortCast(float x)
        (ß (short) x)
    )

    (§ defn short uncheckedShortCast(double x)
        (ß (short) x)
    )

    (§ defn char uncheckedCharCast(Object x)
        (§ if (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (ß (char) ((Number) x).longValue())
    )

    (§ defn char uncheckedCharCast(byte x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(short x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(char x)
        x
    )

    (§ defn char uncheckedCharCast(int x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(long x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(float x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(double x)
        (ß (char) x)
    )

    (§ defn int uncheckedIntCast(Object x)
        (§ if (ß x instanceof Number)
            (§ return (ß ((Number)x).intValue()))
        )
        (ß ((Character) x).charValue())
    )

    (§ defn int uncheckedIntCast(byte x)
        x
    )

    (§ defn int uncheckedIntCast(short x)
        x
    )

    (§ defn int uncheckedIntCast(char x)
        x
    )

    (§ defn int uncheckedIntCast(int x)
        x
    )

    (§ defn int uncheckedIntCast(long x)
        (ß (int) x)
    )

    (§ defn int uncheckedIntCast(float x)
        (ß (int) x)
    )

    (§ defn int uncheckedIntCast(double x)
        (ß (int) x)
    )

    (§ defn long uncheckedLongCast(Object x)
        (ß ((Number) x).longValue())
    )

    (§ defn long uncheckedLongCast(byte x)
        x
    )

    (§ defn long uncheckedLongCast(short x)
        x
    )

    (§ defn long uncheckedLongCast(int x)
        x
    )

    (§ defn long uncheckedLongCast(long x)
        x
    )

    (§ defn long uncheckedLongCast(float x)
        (ß (long) x)
    )

    (§ defn long uncheckedLongCast(double x)
        (ß (long) x)
    )

    (§ defn float uncheckedFloatCast(Object x)
        (ß ((Number) x).floatValue())
    )

    (§ defn float uncheckedFloatCast(byte x)
        x
    )

    (§ defn float uncheckedFloatCast(short x)
        x
    )

    (§ defn float uncheckedFloatCast(int x)
        x
    )

    (§ defn float uncheckedFloatCast(long x)
        x
    )

    (§ defn float uncheckedFloatCast(float x)
        x
    )

    (§ defn float uncheckedFloatCast(double x)
        (ß (float) x)
    )

    (§ defn double uncheckedDoubleCast(Object x)
        (ß ((Number) x).doubleValue())
    )

    (§ defn double uncheckedDoubleCast(byte x)
        x
    )

    (§ defn double uncheckedDoubleCast(short x)
        x
    )

    (§ defn double uncheckedDoubleCast(int x)
        x
    )

    (§ defn double uncheckedDoubleCast(long x)
        x
    )

    (§ defn double uncheckedDoubleCast(float x)
        x
    )

    (§ defn double uncheckedDoubleCast(double x)
        x
    )

    (§ defn IPersistentMap map(Object... init)
        (§ if (ß init == nil)
            (§ return (ß PersistentArrayMap.EMPTY))
        )
        (§ elseif (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (§ return (ß PersistentArrayMap.createWithCheck(init)))
        )
        (ß PersistentHashMap.createWithCheck(init))
    )

    (§ defn IPersistentMap mapUniqueKeys(Object... init)
        (§ if (ß init == nil)
            (§ return (ß PersistentArrayMap.EMPTY))
        )
        (§ elseif (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (§ return (ß new PersistentArrayMap(init)))
        )
        (ß PersistentHashMap.create(init))
    )

    (§ defn IPersistentSet set(Object... init)
        (ß PersistentHashSet.createWithCheck(init))
    )

    (§ defn IPersistentVector vector(Object... init)
        (ß LazilyPersistentVector.createOwning(init))
    )

    (§ defn IPersistentVector subvec(IPersistentVector v, int start, int end)
        (§ if (ß end < start || start < 0 || end > v.count())
            (§ throw new IndexOutOfBoundsException())
        )
        (§ if (ß start == end)
            (§ return (ß PersistentVector.EMPTY))
        )
        (ß new APersistentVector.SubVector(nil, v, start, end))
    )

    (§ defn ISeq list()
        nil
    )

    (§ defn ISeq list(Object arg1)
        (ß new PersistentList(arg1))
    )

    (§ defn ISeq list(Object arg1, Object arg2)
        (ß listStar(arg1, arg2, nil))
    )

    (§ defn ISeq list(Object arg1, Object arg2, Object arg3)
        (ß listStar(arg1, arg2, arg3, nil))
    )

    (§ defn ISeq list(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß listStar(arg1, arg2, arg3, arg4, nil))
    )

    (§ defn ISeq list(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß listStar(arg1, arg2, arg3, arg4, arg5, nil))
    )

    (§ defn ISeq listStar(Object arg1, ISeq rest)
        (ß (ISeq) cons(arg1, rest))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, rest)))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, Object arg3, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, rest))))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest)))))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest))))))
    )

    (§ defn ISeq arrayToList(Object[] a)
        (§ let ISeq ret = nil)
        (§ loop-when-recur [(ß int i = a.length - 1)] (ß i >= 0) [(ß --i)]
            (ß ret = (ISeq) cons(a[i], ret))
        )
        ret
    )

    (§ defn Object[] object_array(Object sizeOrSeq)
        (§ if (ß sizeOrSeq instanceof Number)
            (ß new Object[((Number) sizeOrSeq).intValue()])
        )
        (§ else 
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let Object[] ret = new Object[size])
            (§ loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                (ß ret[i] = s.first())
            )
            ret
        )
    )

    (§ defn Object[] toArray(Object coll)
        (§ if (ß coll == nil)
            (ß EMPTY_ARRAY)
        )
        (§ elseif (ß coll instanceof Object[])
            (ß (Object[]) coll)
        )
        (§ elseif (ß coll instanceof Collection)
            (ß ((Collection) coll).toArray())
        )
        (§ elseif (ß coll instanceof Iterable)
            (§ let ArrayList ret = new ArrayList())
            (§ doseq [#_"Object" o (ß (Iterable)coll)]
                (ß ret.add(o))
            )
            (ß ret.toArray())
        )
        (§ elseif (ß coll instanceof Map)
            (ß ((Map) coll).entrySet().toArray())
        )
        (§ elseif (ß coll instanceof String)
            (§ let char[] chars = ((String) coll).toCharArray())
            (§ let Object[] ret = new Object[chars.length])
            (§ loop-when-recur [(ß int i = 0)] (ß i < chars.length) [(ß i++)]
                (ß ret[i] = chars[i])
            )
            ret
        )
        (§ elseif (ß coll.getClass().isArray())
            (§ let ISeq s = (seq(coll)))
            (§ let Object[] ret = new Object[count(s)])
            (§ loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++, s = s.next())]
                (ß ret[i] = s.first())
            )
            ret
        )
        (§ else 
            (§ throw Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]"))
        )
    )

    (§ defn Object[] seqToArray(ISeq seq)
        (§ let int len = length(seq))
        (§ let Object[] ret = new Object[len])
        (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
            (ß ret[i] = seq.first())
        )
        ret
    )

    ;; supports java Collection.toArray(T[])
    (§ defn Object[] seqToPassedArray(ISeq seq, Object[] passed)
        (§ let Object[] dest = passed)
        (§ let int len = count(seq))
        (§ if (ß len > dest.length)
            (ß dest = (Object[]) Array.newInstance(passed.getClass().getComponentType(), len))
        )
        (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
            (ß dest[i] = seq.first())
        )
        (§ if (ß len < passed.length)
            (ß dest[len] = nil)
        )
        dest
    )

    (§ defn Object seqToTypedArray(ISeq seq)
        (§ let Class type = (seq != nil && seq.first() != nil) ? seq.first().getClass() :or Object.class)
        (ß seqToTypedArray(type, seq))
    )

    (§ defn Object seqToTypedArray(Class type, ISeq seq)
        (§ let Object ret = Array.newInstance(type, length(seq)))
        (§ if (ß type == Integer.TYPE)
            (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                (ß Array.set(ret, i, intCast(seq.first())))
            )
        )
        (§ elseif (ß type == Byte.TYPE)
            (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                (ß Array.set(ret, i, byteCast(seq.first())))
            )
        )
        (§ elseif (ß type == Float.TYPE)
            (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                (ß Array.set(ret, i, floatCast(seq.first())))
            )
        )
        (§ elseif (ß type == Short.TYPE)
            (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                (ß Array.set(ret, i, shortCast(seq.first())))
            )
        )
        (§ elseif (ß type == Character.TYPE)
            (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                (ß Array.set(ret, i, charCast(seq.first())))
            )
        )
        (§ else 
            (§ loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                (ß Array.set(ret, i, seq.first()))
            )
        )
        ret
    )

    (§ defn int length(ISeq list)
        (§ let int i = 0)
        (§ loop-when-recur [(ß ISeq c = list)] (ß c != nil) [(ß c = c.next())]
            (ß i++)
        )
        i
    )

    (§ defn int boundedLength(ISeq list, int limit)
        (§ let int i = 0)
        (§ loop-when-recur [(ß ISeq c = list)] (ß c != nil && i <= limit) [(ß c = c.next())]
            (ß i++)
        )
        i
    )

    (§ defn Character readRet(int ret)
        (§ if (ß ret == -1)
            (§ return nil)
        )
        (ß box((char) ret))
    )

    (§ defn Character readChar(Reader r) (§ throws IOException)
        (§ let int ret = r.read())
        (ß readRet(ret))
    )

    (§ defn Character peekChar(Reader r) (§ throws IOException)
        (§ let int ret)
        (§ if (ß r instanceof PushbackReader)
            (ß ret = r.read())
            (ß ((PushbackReader) r).unread(ret))
        )
        (§ else 
            (ß r.mark(1))
            (ß ret = r.read())
            (ß r.reset())
        )

        (ß readRet(ret))
    )

    (§ defn int getLineNumber(Reader r)
        (§ if (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getLineNumber()))
        )
        0
    )

    (§ defn int getColumnNumber(Reader r)
        (§ if (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getColumnNumber()))
        )
        0
    )

    (§ defn LineNumberingPushbackReader getLineNumberingReader(Reader r)
        (§ if (ß isLineNumberingReader(r))
            (§ return (ß (LineNumberingPushbackReader) r))
        )
        (ß new LineNumberingPushbackReader(r))
    )

    (§ defn boolean isLineNumberingReader(Reader r)
        (ß (r instanceof LineNumberingPushbackReader))
    )

    (§ defn boolean isReduced(Object r)
        (ß (r instanceof Reduced))
    )

    (§ defn String resolveClassNameInContext(String className)
        ;; todo - look up in context var
        className
    )

    (§ defn boolean suppressRead()
        (ß booleanCast(SUPPRESS_READ.deref()))
    )

    (§ defn String printString(Object x)
        (§ try 
            (§ let StringWriter sw = new StringWriter())
            (ß print(x, sw))
            (ß sw.toString())
        )
        (§ catch (ß Exception e)
            (§ throw Util.sneakyThrow(e))
        )
    )

    (§ defn Object readString(String s)
        (ß readString(s, nil))
    )

    (§ defn Object readString(String s, Object opts)
        (§ let PushbackReader r = new PushbackReader(new StringReader(s)))
        (ß LispReader.read(r, opts))
    )

    (§ defn void print(Object x, Writer w) (§ throws IOException)
        ;; call multimethod
        (§ if (ß PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref()))
            (ß PR_ON.invoke(x, w))
        )
        (§ else 
            (§ let boolean readably = booleanCast(PRINT_READABLY.deref()))
            (§ if (ß x instanceof Obj)
                (§ let Obj o = (Obj) x)
                (§ if (ß RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                    (§ let IPersistentMap meta = o.meta())
                    (ß w.write("#^"))
                    (§ if (ß meta.count() == 1 && meta.containsKey(TAG_KEY))
                        (ß print(meta.valAt(TAG_KEY), w))
                    )
                    (§ else 
                        (ß print(meta, w))
                    )
                    (ß w.write(\space))
                )
            )
            (§ if (ß x == nil)
                (ß w.write("nil"))
            )
            (§ elseif (ß x instanceof ISeq || x instanceof IPersistentList)
                (ß w.write(\())
                (ß printInnerSeq(seq(x), w))
                (ß w.write(\)))
            )
            (§ elseif (ß x instanceof String)
                (§ let String s = (String) x)
                (§ if (ß !readably)
                    (ß w.write(s))
                )
                (§ else 
                    (ß w.write(\")) ;; oops! "
                    (§ loop-when-recur [(ß int i = 0)] (ß i < s.length()) [(ß i++)]
                        (§ let char c = s.charAt(i))
                        (§ switch (ß c)
                            (§ case \newline)
                            (do
                                (ß w.write("\\n"))
                                (§ break )
                            )
                            (§ case \tab)
                            (do
                                (ß w.write("\\t"))
                                (§ break )
                            )
                            (§ case \return)
                            (do
                                (ß w.write("\\r"))
                                (§ break )
                            )
                            (§ case \")
                            (do
                                (ß w.write("\\\""))
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (ß w.write("\\\\"))
                                (§ break )
                            )
                            (§ case \formfeed)
                            (do
                                (ß w.write("\\f"))
                                (§ break )
                            )
                            (§ case \backspace)
                            (do
                                (ß w.write("\\b"))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (ß w.write(c))
                                (§ break )
                            )
                        )
                    )
                    (ß w.write(\")) ;; oops! "
                )
            )
            (§ elseif (ß x instanceof IPersistentMap)
                (ß w.write(\{))
                (§ loop-when-recur [(ß ISeq s = seq(x))] (ß s != nil) [(ß s = s.next())]
                    (§ let IMapEntry e = (IMapEntry) s.first())
                    (ß print(e.key(), w))
                    (ß w.write(\space))
                    (ß print(e.val(), w))
                    (§ if (ß s.next() != nil)
                        (ß w.write(", "))
                    )
                )
                (ß w.write(\}))
            )
            (§ elseif (ß x instanceof IPersistentVector)
                (§ let IPersistentVector a = (IPersistentVector) x)
                (ß w.write(\[))
                (§ loop-when-recur [(ß int i = 0)] (ß i < a.count()) [(ß i++)]
                    (ß print(a.nth(i), w))
                    (§ if (ß i < a.count() - 1)
                        (ß w.write(\space))
                    )
                )
                (ß w.write(\]))
            )
            (§ elseif (ß x instanceof IPersistentSet)
                (ß w.write("#{"))
                (§ loop-when-recur [(ß ISeq s = seq(x))] (ß s != nil) [(ß s = s.next())]
                    (ß print(s.first(), w))
                    (§ if (ß s.next() != nil)
                        (ß w.write(" "))
                    )
                )
                (ß w.write(\}))
            )
            (§ elseif (ß x instanceof Character)
                (§ let char c = ((Character) x).charValue())
                (§ if (ß !readably)
                    (ß w.write(c))
                )
                (§ else 
                    (ß w.write(\\))
                    (§ switch (ß c)
                        (§ case \newline)
                        (do
                            (ß w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (ß w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (ß w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (ß w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (ß w.write("formfeed"))
                            (§ break )
                        )
                        (§ case \return)
                        (do
                            (ß w.write("return"))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (ß w.write(c))
                            (§ break )
                        )
                    )
                )
            )
            (§ elseif (ß x instanceof Class)
                (ß w.write("#="))
                (ß w.write(((Class) x).getName()))
            )
            (§ elseif (ß x instanceof BigDecimal && readably)
                (ß w.write(x.toString()))
                (ß w.write(\M))
            )
            (§ elseif (ß x instanceof BigInt && readably)
                (ß w.write(x.toString()))
                (ß w.write(\N))
            )
            (§ elseif (ß x instanceof BigInteger && readably)
                (ß w.write(x.toString()))
                (ß w.write("BIGINT"))
            )
            (§ elseif (ß x instanceof Var)
                (§ let Var v = (Var) x)
                (ß w.write("#=(var " + v.ns.name + "/" + v.sym + ")"))
            )
            (§ elseif (ß x instanceof Pattern)
                (§ let Pattern p = (Pattern) x)
                (ß w.write("#\"" + p.pattern() + "\""))
            )
            (§ else 
                (ß w.write(x.toString()))
            )
        )
        nil
    )

    (§ defn- void printInnerSeq(ISeq x, Writer w) (§ throws IOException)
        (§ loop-when-recur [(ß ISeq s = x)] (ß s != nil) [(ß s = s.next())]
            (ß print(s.first(), w))
            (§ if (ß s.next() != nil)
                (ß w.write(\space))
            )
        )
        nil
    )

    (§ defn void formatAesthetic(Writer w, Object obj) (§ throws IOException)
        (§ if (ß obj == nil)
            (ß w.write("nil"))
        )
        (§ else 
            (ß w.write(obj.toString()))
        )
        nil
    )

    (§ defn void formatStandard(Writer w, Object obj) (§ throws IOException)
        (§ if (ß obj == nil)
            (ß w.write("nil"))
        )
        (§ elseif (ß obj instanceof String)
            (ß w.write(\")) ;; oops! "
            (ß w.write((String) obj))
            (ß w.write(\")) ;; oops! "
        )
        (§ elseif (ß obj instanceof Character)
            (ß w.write(\\))
            (§ let char c = ((Character) obj).charValue())
            (§ switch (ß c)
                (§ case \newline)
                (do
                    (ß w.write("newline"))
                    (§ break )
                )
                (§ case \tab)
                (do
                    (ß w.write("tab"))
                    (§ break )
                )
                (§ case \space)
                (do
                    (ß w.write("space"))
                    (§ break )
                )
                (§ case \backspace)
                (do
                    (ß w.write("backspace"))
                    (§ break )
                )
                (§ case \formfeed)
                (do
                    (ß w.write("formfeed"))
                    (§ break )
                )
                (§ default )
                (do
                    (ß w.write(c))
                    (§ break )
                )
            )
        )
        (§ else 
            (ß w.write(obj.toString()))
        )
        nil
    )

    (§ defn Object format(Object o, String s, Object... args) (§ throws IOException)
        (§ let Writer w)
        (§ if (ß o == nil)
            (ß w = new StringWriter())
        )
        (§ elseif (ß Util.equals(o, T))
            (ß w = (Writer) OUT.deref())
        )
        (§ else 
            (ß w = (Writer) o)
        )
        (ß doFormat(w, s, ArraySeq.create(args)))
        (§ if (ß o == nil)
            (§ return (ß w.toString()))
        )
        nil
    )

    (§ defn ISeq doFormat(Writer w, String s, ISeq args) (§ throws IOException)
        (§ loop-when-recur [(ß int i = 0)] (ß i < s.length()) [(ß )]
            (§ let char c = s.charAt(i++))
            (§ switch (ß Character.toLowerCase(c))
                (§ case \~)
                (do
                    (§ let char d = s.charAt(i++))
                    (§ switch (ß Character.toLowerCase(d))
                        (§ case \%)
                        (do
                            (ß w.write(\newline))
                            (§ break )
                        )
                        (§ case \t)
                        (do
                            (ß w.write(\tab))
                            (§ break )
                        )
                        (§ case \a)
                        (do
                            (§ if (ß args == nil)
                                (§ throw new IllegalArgumentException("Missing argument"))
                            )
                            (ß RT.formatAesthetic(w, RT.first(args)))
                            (ß args = RT.next(args))
                            (§ break )
                        )
                        (§ case \s)
                        (do
                            (§ if (ß args == nil)
                                (§ throw new IllegalArgumentException("Missing argument"))
                            )
                            (ß RT.formatStandard(w, RT.first(args)))
                            (ß args = RT.next(args))
                            (§ break )
                        )
                        (§ case \{)
                        (do
                            (§ let int j = s.indexOf("~}", i)) ;; note - does not nest
                            (§ if (ß j == -1)
                                (§ throw new IllegalArgumentException("Missing ~}"))
                            )
                            (§ let String subs = s.substring(i, j))
                            (§ loop-when-recur [(ß ISeq sargs = RT.seq(RT.first(args)))] (ß sargs != nil) [(ß )]
                                (ß sargs = doFormat(w, subs, sargs))
                            )
                            (ß args = RT.next(args))
                            (ß i = j + 2) ;; skip "~}"
                            (§ break )
                        )
                        (§ case \^)
                        (do
                            (§ if (ß args == nil)
                                (§ return nil)
                            )
                            (§ break )
                        )
                        (§ case \~)
                        (do
                            (ß w.write(\~))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (§ throw new IllegalArgumentException("Unsupported ~ directive: " + d))
                        )
                    )
                    (§ break )
                )
                (§ default )
                (do
                    (ß w.write(c))
                    (§ break )
                )
            )
        )
        args
    )

    (§ defn Object[] setValues(Object... vals)
        (§ if (ß vals.length > 0)
            (§ return vals)
        )
        nil
    )

    (§ defn ClassLoader makeClassLoader()
        (ß (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
            (§ reify
                (§ method Object run()
                    (§ try 
                        (ß Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T)))
                        (ß new DynamicClassLoader(baseLoader()))
                    )
                    (§ finally 
                        (ß Var.popThreadBindings())
                    )
                )
            ))
        )
    )

    (§ defn ClassLoader baseLoader()
        (§ if (ß Compiler.LOADER.isBound())
            (§ return (ß (ClassLoader) Compiler.LOADER.deref()))
        )
        (§ elseif (ß booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
            (§ return (ß Thread.currentThread().getContextClassLoader()))
        )
        (ß Compiler.class.getClassLoader())
    )

    (§ defn InputStream resourceAsStream(ClassLoader loader, String name)
        (§ if (ß loader == nil)
            (ß ClassLoader.getSystemResourceAsStream(name))
        )
        (§ else 
            (ß loader.getResourceAsStream(name))
        )
    )

    (§ defn URL getResource(ClassLoader loader, String name)
        (§ if (ß loader == nil)
            (ß ClassLoader.getSystemResource(name))
        )
        (§ else 
            (ß loader.getResource(name))
        )
    )

    (§ defn Class classForName(String name, boolean load, ClassLoader loader)
        (§ try 
            (§ let Class c = nil)
            (§ if (ß !(loader instanceof DynamicClassLoader))
                (ß c = DynamicClassLoader.findInMemoryClass(name))
            )
            (§ if (ß c != nil)
                (§ return c)
            )
            (ß Class.forName(name, load, loader))
        )
        (§ catch (ß ClassNotFoundException e)
            (§ throw Util.sneakyThrow(e))
        )
    )

    (§ defn Class classForName(String name)
        (ß classForName(name, true, baseLoader()))
    )

    (§ defn Class classForNameNonLoading(String name)
        (ß classForName(name, false, baseLoader()))
    )

    (§ defn Class loadClassForName(String name)
        (§ try 
            (ß classForNameNonLoading(name))
        )
        (§ catch (ß Exception e)
            (§ if (ß e instanceof ClassNotFoundException)
                (§ return nil)
            )
            (§ else 
                (§ throw Util.sneakyThrow(e))
            )
        )
        (ß classForName(name))
    )

    (§ defn float aget(float[] xs, int i)
        (ß xs[i])
    )

    (§ defn float aset(float[] xs, int i, float v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(float[] xs)
        (ß xs.length)
    )

    (§ defn float[] aclone(float[] xs)
        (ß xs.clone())
    )

    (§ defn double aget(double[] xs, int i)
        (ß xs[i])
    )

    (§ defn double aset(double[] xs, int i, double v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(double[] xs)
        (ß xs.length)
    )

    (§ defn double[] aclone(double[] xs)
        (ß xs.clone())
    )

    (§ defn int aget(int[] xs, int i)
        (ß xs[i])
    )

    (§ defn int aset(int[] xs, int i, int v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(int[] xs)
        (ß xs.length)
    )

    (§ defn int[] aclone(int[] xs)
        (ß xs.clone())
    )

    (§ defn long aget(long[] xs, int i)
        (ß xs[i])
    )

    (§ defn long aset(long[] xs, int i, long v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(long[] xs)
        (ß xs.length)
    )

    (§ defn long[] aclone(long[] xs)
        (ß xs.clone())
    )

    (§ defn char aget(char[] xs, int i)
        (ß xs[i])
    )

    (§ defn char aset(char[] xs, int i, char v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(char[] xs)
        (ß xs.length)
    )

    (§ defn char[] aclone(char[] xs)
        (ß xs.clone())
    )

    (§ defn byte aget(byte[] xs, int i)
        (ß xs[i])
    )

    (§ defn byte aset(byte[] xs, int i, byte v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(byte[] xs)
        (ß xs.length)
    )

    (§ defn byte[] aclone(byte[] xs)
        (ß xs.clone())
    )

    (§ defn short aget(short[] xs, int i)
        (ß xs[i])
    )

    (§ defn short aset(short[] xs, int i, short v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(short[] xs)
        (ß xs.length)
    )

    (§ defn short[] aclone(short[] xs)
        (ß xs.clone())
    )

    (§ defn boolean aget(boolean[] xs, int i)
        (ß xs[i])
    )

    (§ defn boolean aset(boolean[] xs, int i, boolean v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(boolean[] xs)
        (ß xs.length)
    )

    (§ defn boolean[] aclone(boolean[] xs)
        (ß xs.clone())
    )

    (§ defn Object aget(Object[] xs, int i)
        (ß xs[i])
    )

    (§ defn Object aset(Object[] xs, int i, Object v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(Object[] xs)
        (ß xs.length)
    )

    (§ defn Object[] aclone(Object[] xs)
        (ß xs.clone())
    )
)
)

(java-ns cloiure.lang.Seqable

(§ interface Seqable
    (§ abstract ISeq seq())
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (§ field ISeq seq)

    (§ constructor SeqEnumeration(ISeq seq)
        (ß this.seq = seq)
        this
    )

    (§ method boolean hasMoreElements()
        (ß (seq != nil))
    )

    (§ method Object nextElement()
        (§ let Object ret = RT.first(seq))
        (ß seq = RT.next(seq))
        ret
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (§ def Object START = new Object())

    (§ field Object seq)
    (§ field Object next)

    (§ constructor SeqIterator(Object o)
        (ß seq = START)
        (ß next = o)
        this
    )

    ;; preserved for binary compatibility
    (§ constructor SeqIterator(ISeq o)
        (ß seq = START)
        (ß next = o)
        this
    )

    (§ method boolean hasNext()
        (§ if (ß seq == START)
            (ß seq = nil)
            (ß next = RT.seq(next))
        )
        (§ elseif (ß seq == next)
            (ß next = RT.next(seq))
        )
        (ß (next != nil))
    )

    (§ method Object next() (§ throws NoSuchElementException)
        (§ if (ß !hasNext())
            (§ throw new NoSuchElementException())
        )
        (ß seq = next)
        (ß RT.first(next))
    )

    (§ method void remove()
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.Sequential

(§ interface Sequential
)
)

(java-ns cloiure.lang.Settable

(§ interface Settable
    (§ abstract Object doSet(Object val))
    (§ abstract Object doReset(Object val))
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ interface Sorted
    (§ abstract Comparator comparator())
    (§ abstract Object entryKey(Object entry))
    (§ abstract ISeq seq(boolean ascending))
    (§ abstract ISeq seqFrom(Object key, boolean ascending))
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (§ field CharSequence s)
    (§ field int i)

    (§ defn StringSeq create(CharSequence s)
        (§ if (ß s.length() == 0)
            (§ return nil)
        )
        (ß new StringSeq(nil, s, 0))
    )

    (§ constructor StringSeq(IPersistentMap meta, CharSequence s, int i)
        (§ super(meta))
        (ß this.s = s)
        (ß this.i = i)
        this
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (ß meta == meta())
            (§ return this)
        )
        (ß new StringSeq(meta, s, i))
    )

    (§ method Object first()
        (ß Character.valueOf(s.charAt(i)))
    )

    (§ method ISeq next()
        (§ if (ß i + 1 < s.length())
            (§ return (ß new StringSeq(_meta, s, i + 1)))
        )
        nil
    )

    (§ method int index()
        i
    )

    (§ method int count()
        (ß s.length() - i)
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    (§ field String ns)
    (§ field String name)
    (§ field- int _hasheq)
    (§ field IPersistentMap _meta)
    #_transient
    (§ field String _str)

    (§ method String toString()
        (§ if (ß _str == nil)
            (§ if (ß ns != nil)
                (ß _str = (ns + "/" + name))
            )
            (§ else 
                (ß _str = name)
            )
        )
        (ß _str)
    )

    (§ method String getNamespace()
        ns
    )

    (§ method String getName()
        name
    )

    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (§ defn Symbol create(String ns, String name)
        (ß Symbol.intern(ns, name))
    )

    (§ defn Symbol create(String nsname)
        (ß Symbol.intern(nsname))
    )

    (§ defn Symbol intern(String ns, String name)
        (ß new Symbol(ns, name))
    )

    (§ defn Symbol intern(String nsname)
        (§ let int i = nsname.indexOf(\/))
        (§ if (ß i == -1 || nsname.equals("/"))
            (ß new Symbol(nil, nsname))
        )
        (§ else 
            (ß new Symbol(nsname.substring(0, i), nsname.substring(i + 1)))
        )
    )

    (§ constructor- Symbol(String ns_interned, String name_interned)
        (ß this.name = name_interned)
        (ß this.ns = ns_interned)
        (ß this._meta = nil)
        this
    )

    (§ method boolean equals(Object o)
        (§ if (ß this == o)
            (§ return true)
        )
        (§ if (ß !(o instanceof Symbol))
            (§ return false)
        )

        (§ let Symbol symbol = (Symbol) o)

        (ß Util.equals(ns, symbol.ns) && name.equals(symbol.name))
    )

    (§ method int hashCode()
        (ß Util.hashCombine(name.hashCode(), Util.hash(ns)))
    )

    (§ method int hasheq()
        (§ if (ß _hasheq == 0)
            (ß _hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns)))
        )
        (ß _hasheq)
    )

    (§ method IObj withMeta(IPersistentMap meta)
        (ß new Symbol(meta, ns, name))
    )

    (§ constructor- Symbol(IPersistentMap meta, String ns, String name)
        (ß this.name = name)
        (ß this.ns = ns)
        (ß this._meta = meta)
        this
    )

    (§ method int compareTo(Object o)
        (§ let Symbol s = (Symbol) o)
        (§ if (ß this.equals(o))
            (§ return 0)
        )
        (§ if (ß this.ns == nil && s.ns != nil)
            (§ return -1)
        )
        (§ if (ß this.ns != nil)
            (§ if (ß s.ns == nil)
                (§ return 1)
            )
            (§ let int nsc = this.ns.compareTo(s.ns))
            (§ if (ß nsc != 0)
                (§ return nsc)
            )
        )
        (ß this.name.compareTo(s.name))
    )

    (§ method Object invoke(Object obj)
        (ß RT.get(obj, this))
    )

    (§ method Object invoke(Object obj, Object notFound)
        (ß RT.get(obj, this, notFound))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def Keyword TAG_KW = Keyword.intern("tag"))
    (§ def Keyword FORM_KW = Keyword.intern("form"))

    (§ field Symbol tag)
    (§ field Object form)

    (§ defn TaggedLiteral create(Symbol tag, Object form)
        (ß new TaggedLiteral(tag, form))
    )

    (§ constructor- TaggedLiteral(Symbol tag, Object form)
        (ß this.tag = tag)
        (ß this.form = form)
        this
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method Object valAt(Object key, Object notFound)
        (§ if (ß FORM_KW.equals(key))
            (ß this.form)
        )
        (§ elseif (ß TAG_KW.equals(key))
            (ß this.tag)
        )
        (§ else 
            notFound
        )
    )

    (§ anno @Override)
    (§ method boolean equals(Object o)
        (§ if (ß this == o)
            (§ return true)
        )
        (§ if (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (§ let TaggedLiteral that = (TaggedLiteral) o)

        (§ if (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
            (§ return false)
        )
        (§ if (ß (tag != nil) ? !tag.equals(that.tag) :or that.tag != nil)
            (§ return false)
        )

        true
    )

    (§ anno @Override)
    (§ method int hashCode()
        (§ let int result = Util.hash(tag))
        (ß result = 31 * result + Util.hash(form))
        result
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (§ field Ref[] bins)

    (§ method IPersistentMap mapAt(int bin)
        (ß (IPersistentMap) bins[bin].deref())
    )

    (§ method int binFor(Object k)
        ;; spread hashes, a la Cliff Click
        (§ let int h = k.hashCode())
        (ß h ^= (h >>> 20) :xor (h >>> 12))
        (ß h ^= (h >>> 7) :xor (h >>> 4))
        (ß h % bins.length)
    )

    (§ method Entry entryAt(Object k)
        (ß mapAt(binFor(k)).entryAt(k))
    )

    (§ constructor TransactionalHashMap()
        (§ this(421))
        this
    )

    (§ constructor TransactionalHashMap(int nBins)
        (ß bins = new Ref[nBins])
        (§ loop-when-recur [(ß int i = 0)] (ß i < nBins) [(ß i++)]
            (ß bins[i] = new Ref(PersistentHashMap.EMPTY))
        )
        this
    )

    (§ constructor TransactionalHashMap(Map<? extends K, ? extends V> m)
        (§ this(m.size()))
        (ß putAll(m))
        this
    )

    (§ method int size()
        (§ let int n = 0)
        (§ loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
            (ß n += mapAt(i).count())
        )
        n
    )

    (§ method boolean isEmpty()
        (ß (size() == 0))
    )

    (§ method boolean containsKey(Object k)
        (ß (entryAt(k) != nil))
    )

    (§ method V get(Object k)
        (§ let Entry e = entryAt(k))
        (§ if (ß e != nil)
            (§ return (ß (V) e.getValue()))
        )
        nil
    )

    (§ method V put(K k, V v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Object ret = map.valAt(k))
        (ß r.set(map.assoc(k, v)))
        (ß (V) ret)
    )

    (§ method V remove(Object k)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Object ret = map.valAt(k))
        (ß r.set(map.without(k)))
        (ß (V) ret)
    )

    (§ method void putAll(Map<? extends K, ? extends V> map)
        (§ loop-when-recur [(ß Iterator i = map.entrySet().iterator())] (ß i.hasNext()) [(ß )]
            (§ let Entry<K, V> e = (Entry) i.next())
            (ß put(e.getKey(), e.getValue()))
        )
        nil
    )

    (§ method void clear()
        (§ loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
            (§ let Ref r = bins[i])
            (§ let IPersistentMap map = (IPersistentMap) r.deref())
            (§ if (ß map.count() > 0)
                (ß r.set(PersistentHashMap.EMPTY))
            )
        )
        nil
    )

    (§ method Set<Entry<K, V>> entrySet()
        (§ let ArrayList<Map.Entry<K, V>> entries = new ArrayList(bins.length))
        (§ loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
            (§ let IPersistentMap map = mapAt(i))
            (§ if (ß map.count() > 0)
                (ß entries.addAll((Collection) RT.seq(map)))
            )
        )
        (ß new AbstractSet<Entry<K, V>>()
            (§ reify
                (§ method Iterator iterator()
                    (ß Collections.unmodifiableList(entries).iterator())
                )

                (§ method int size()
                    (ß entries.size())
                )
            )
        )
    )

    (§ method V putIfAbsent(K k, V v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (ß e == nil)
            (ß r.set(map.assoc(k, v)))
            nil
        )
        (§ else 
            (ß (V) e.getValue())
        )
    )

    (§ method boolean remove(Object k, Object v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (ß e != nil && e.getValue().equals(v))
            (ß r.set(map.without(k)))
            (§ return true)
        )
        false
    )

    (§ method boolean replace(K k, V oldv, V newv)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (ß e != nil && e.getValue().equals(oldv))
            (ß r.set(map.assoc(k, newv)))
            (§ return true)
        )
        false
    )

    (§ method V replace(K k, V v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (ß e != nil)
            (ß r.set(map.assoc(k, v)))
            (§ return (ß (V) e.getValue()))
        )
        nil
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

(class-ns TransformerIterator (§ implements Iterator)
    (§ def- Buffer EMPTY = new Empty())
    (§ def- Object NONE = new Object())

    ;; Source
    (§ field- Iterator sourceIter)
    (§ field- IFn xf)
    (§ field- boolean multi)

    ;; Iteration state
    #_volatile
    (§ field- Buffer buffer = EMPTY)
    #_volatile
    (§ field- Object next = NONE)
    #_volatile
    (§ field- boolean completed = false)

    (§ constructor- TransformerIterator(IFn xform, Iterator sourceIter, boolean multi)
        (ß this.sourceIter = sourceIter)
        (ß this.xf = (IFn) xform.invoke(new AFn()
            (§ reify
                (§ method Object invoke()
                    nil
                )

                (§ method Object invoke(Object acc)
                    acc
                )

                (§ method Object invoke(Object acc, Object o)
                    (ß buffer = buffer.add(o))
                    acc
                )
            ))
        )
        (ß this.multi = multi)
        this
    )

    (§ defn Iterator create(IFn xform, Iterator source)
        (ß new TransformerIterator(xform, source, false))
    )

    (§ defn Iterator createMulti(IFn xform, List sources)
        (§ let Iterator[] iters = new Iterator[sources.size()])
        (§ loop-when-recur [(ß int i = 0)] (ß i < sources.size()) [(ß i++)]
            (ß iters[i] = (Iterator)sources.get(i))
        )
        (ß new TransformerIterator(xform, new MultiIterator(iters), true))
    )

    (§ method- boolean step()
        (§ if (ß next != NONE)
            (§ return true)
        )

        (§ while (ß next == NONE)
            (§ if (ß buffer.isEmpty())
                (§ if (ß completed)
                    (§ return false)
                )
                (§ elseif (ß sourceIter.hasNext())
                    (§ let Object iter = nil)
                    (§ if (ß multi)
                        (ß iter = xf.applyTo(RT.cons(nil, sourceIter.next())))
                    )
                    (§ else 
                        (ß iter = xf.invoke(nil, sourceIter.next()))
                    )

                    (§ if (ß RT.isReduced(iter))
                        (ß xf.invoke(nil))
                        (ß completed = true)
                    )
                )
                (§ else 
                    (ß xf.invoke(nil))
                    (ß completed = true)
                )
            )
            (§ else 
                (ß next = buffer.remove())
            )
        )
        true
    )

    (§ method boolean hasNext()
        (ß step())
    )

    (§ method Object next()
        (§ if (ß hasNext())
            (§ let Object ret = next)
            (ß next = NONE)
            (§ return ret)
        )
        (§ throw new NoSuchElementException())
    )

    (§ method void remove()
        (§ throw new UnsupportedOperationException())
    )

    #_private
    (§ interface Buffer
        (§ abstract Buffer add(Object o))
        (§ abstract Object remove())
        (§ abstract boolean isEmpty())
    )

    #_private
    (class-ns Empty (§ implements Buffer)
        (§ method Buffer add(Object o)
            (ß new Single(o))
        )

        (§ method Object remove()
            (§ throw new IllegalStateException("Removing object from empty buffer"))
        )

        (§ method boolean isEmpty()
            true
        )

        (§ method String toString()
            (ß "Empty")
        )
    )

    #_private
    (class-ns Single (§ implements Buffer)
        #_volatile
        (§ field- Object val)

        (§ constructor Single(Object o)
            (ß this.val = o)
            this
        )

        (§ method Buffer add(Object o)
            (§ if (ß val == NONE)
                (ß val = o)
                this
            )
            (§ else 
                (ß new Many(val, o))
            )
        )

        (§ method Object remove()
            (§ if (ß val == NONE)
                (§ throw new IllegalStateException("Removing object from empty buffer"))
            )
            (§ let Object ret = val)
            (ß val = NONE)
            ret
        )

        (§ method boolean isEmpty()
            (ß (val == NONE))
        )

        (§ method String toString()
            (ß "Single: " + val)
        )
    )

    #_private
    (class-ns Many (§ implements Buffer)
        (§ field- Queue vals = new LinkedList())

        (§ constructor Many(Object o1, Object o2)
            (ß vals.add(o1))
            (ß vals.add(o2))
            this
        )

        (§ method Buffer add(Object o)
            (ß vals.add(o))
            this
        )

        (§ method Object remove()
            (ß vals.remove())
        )

        (§ method boolean isEmpty()
            (ß vals.isEmpty())
        )

        (§ method String toString()
            (ß "Many: " + vals.toString())
        )
    )

    #_private
    (class-ns MultiIterator (§ implements Iterator)
        (§ field- Iterator[] iters)

        (§ constructor MultiIterator(Iterator[] iters)
            (ß this.iters = iters)
            this
        )

        (§ method boolean hasNext()
            (§ doseq [#_"Iterator" iter iters]
                (§ if (ß !iter.hasNext())
                    (§ return false)
                )
            )
            true
        )

        (§ method Object next()
            (§ let Object[] nexts = new Object[iters.length])
            (§ loop-when-recur [(ß int i = 0)] (ß i < iters.length) [(ß i++)]
                (ß nexts[i] = iters[i].next())
            )
            (ß new ArraySeq(nexts, 0))
        )

        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(class-ns Tuple
    (§ def int MAX_SIZE = 6)

    (§ defn IPersistentVector create()
        (ß PersistentVector.EMPTY)
    )

    (§ defn IPersistentVector create(Object v0)
        (ß RT.vector(v0))
    )

    (§ defn IPersistentVector create(Object v0, Object v1)
        (ß RT.vector(v0, v1))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2)
        (ß RT.vector(v0, v1, v2))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2, Object v3)
        (ß RT.vector(v0, v1, v2, v3))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4)
        (ß RT.vector(v0, v1, v2, v3, v4))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4, Object v5)
        (ß RT.vector(v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(class-ns Util
    (§ defn boolean equiv(Object k1, Object k2)
        (§ if (ß k1 == k2)
            (§ return true)
        )
        (§ if (ß k1 != nil)
            (§ if (ß k1 instanceof Number && k2 instanceof Number)
                (§ return (ß Numbers.equal((Number)k1, (Number)k2)))
            )
            (§ elseif (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                (§ return (ß pcequiv(k1, k2)))
            )
            (§ return (ß k1.equals(k2)))
        )
        false
    )

    #_non-static
    (§ interface EquivPred
        (§ abstract boolean equiv(Object k1, Object k2))
    )

    (§ def EquivPred equivNull = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (ß (k2 == nil))
            )
        )
    )

    (§ def EquivPred equivEquals = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (ß k1.equals(k2))
            )
        )
    )

    (§ def EquivPred equivNumber = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (§ if (ß k2 instanceof Number)
                    (§ return (ß Numbers.equal((Number) k1, (Number) k2)))
                )
                false
            )
        )
    )

    (§ def EquivPred equivColl = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (§ if (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(k1, k2)))
                )
                (ß k1.equals(k2))
            )
        )
    )

    (§ defn EquivPred equivPred(Object k1)
        (§ if (ß k1 == nil)
            (§ return equivNull)
        )
        (§ elseif (ß k1 instanceof Number)
            (§ return equivNumber)
        )
        (§ elseif (ß k1 instanceof String || k1 instanceof Symbol)
            (§ return equivEquals)
        )
        (§ elseif (ß k1 instanceof Collection || k1 instanceof Map)
            (§ return equivColl)
        )
        equivEquals
    )

    (§ defn boolean equiv(long k1, long k2)
        (ß (k1 == k2))
    )

    (§ defn boolean equiv(Object k1, long k2)
        (ß equiv(k1, (Object)k2))
    )

    (§ defn boolean equiv(long k1, Object k2)
        (ß equiv((Object)k1, k2))
    )

    (§ defn boolean equiv(double k1, double k2)
        (ß (k1 == k2))
    )

    (§ defn boolean equiv(Object k1, double k2)
        (ß equiv(k1, (Object)k2))
    )

    (§ defn boolean equiv(double k1, Object k2)
        (ß equiv((Object)k1, k2))
    )

    (§ defn boolean equiv(boolean k1, boolean k2)
        (ß (k1 == k2))
    )

    (§ defn boolean equiv(Object k1, boolean k2)
        (ß equiv(k1, (Object)k2))
    )

    (§ defn boolean equiv(boolean k1, Object k2)
        (ß equiv((Object)k1, k2))
    )

    (§ defn boolean equiv(char c1, char c2)
        (ß (c1 == c2))
    )

    (§ defn boolean pcequiv(Object k1, Object k2)
        (§ if (ß k1 instanceof IPersistentCollection)
            (§ return (ß ((IPersistentCollection)k1).equiv(k2)))
        )
        (ß ((IPersistentCollection)k2).equiv(k1))
    )

    (§ defn boolean equals(Object k1, Object k2)
        (§ if (ß k1 == k2)
            (§ return true)
        )
        (ß (k1 != nil && k1.equals(k2)))
    )

    (§ defn boolean identical(Object k1, Object k2)
        (ß (k1 == k2))
    )

    (§ defn Class classOf(Object x)
        (§ if (ß x != nil)
            (§ return (ß x.getClass()))
        )
        nil
    )

    (§ defn int compare(Object k1, Object k2)
        (§ if (ß k1 == k2)
            (§ return 0)
        )
        (§ if (ß k1 != nil)
            (§ if (ß k2 == nil)
                (§ return 1)
            )
            (§ if (ß k1 instanceof Number)
                (§ return (ß Numbers.compare((Number) k1, (Number) k2)))
            )
            (§ return (ß ((Comparable) k1).compareTo(k2)))
        )
        -1
    )

    (§ defn int hash(Object o)
        (§ if (ß o == nil)
            (§ return 0)
        )
        (ß o.hashCode())
    )

    (§ defn int hasheq(Object o)
        (§ if (ß o == nil)
            (§ return 0)
        )
        (§ if (ß o instanceof IHashEq)
            (§ return (ß dohasheq((IHashEq) o)))
        )
        (§ if (ß o instanceof Number)
            (§ return (ß Numbers.hasheq((Number)o)))
        )
        (§ if (ß o instanceof String)
            (§ return (ß Murmur3.hashInt(o.hashCode())))
        )
        (ß o.hashCode())
    )

    (§ defn- int dohasheq(IHashEq o)
        (ß o.hasheq())
    )

    (§ defn int hashCombine(int seed, int hash)
        ;; a la boost
        (ß seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2))
        seed
    )

    (§ defn boolean isPrimitive(Class c)
        (ß (c != nil && c.isPrimitive() && !(c == Void.TYPE)))
    )

    (§ defn boolean isInteger(Object x)
        (ß (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger))
    )

    (§ defn Object ret1(Object ret, Object nil)
        ret
    )

    (§ defn ISeq ret1(ISeq ret, Object nil)
        ret
    )

    (§ defn <K, V> void clearCache(ReferenceQueue rq, ConcurrentHashMap<K, Reference<V>> cache)
        ;; cleanup any dead entries
        (§ if (ß rq.poll() != nil)
            (§ while (ß rq.poll() != nil)
            )
            (§ doseq [#_"Map.Entry<K, Reference<V>>" (ß e cache.entrySet())]
                (§ let Reference<V> val = e.getValue())
                (§ if (ß val != nil && val.get() == nil)
                    (ß cache.remove(e.getKey(), val))
                )
            )
        )
        nil
    )

    (§ defn RuntimeException runtimeException(String s)
        (ß new RuntimeException(s))
    )

    (§ defn RuntimeException runtimeException(String s, Throwable e)
        (ß new RuntimeException(s, e))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (§ defn RuntimeException sneakyThrow(Throwable t)
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (§ if (ß t == nil)
            (§ throw new NullPointerException())
        )
        (ß Util.<RuntimeException>sneakyThrow0(t))
        nil
    )

    (§ anno @SuppressWarnings("unchecked"))
    (§ defn- <T extends Throwable> void sneakyThrow0(Throwable t) (§ throws T)
        (§ throw (ß (T) t))
    )

    (§ defn Object loadWithClass(String scriptbase, Class<?> loadFrom) (§ throws IOException, ClassNotFoundException)
        (ß Var.pushThreadBindings(RT.map(new Object[] (§ Compiler.LOADER, loadFrom.getClassLoader() ))))
        (§ try 
            (ß RT.var("cloiure.core", "load").invoke(scriptbase))
        )
        (§ finally 
            (ß Var.popThreadBindings())
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (class-ns TBox
        #_volatile
        (§ field Object val)
        (§ field Thread thread)

        (§ constructor TBox(Thread t, Object val)
            (ß this.thread = t)
            (ß this.val = val)
            this
        )
    )

    (class-ns Unbound (§ extends AFn)
        (§ field Var v)

        (§ constructor Unbound(Var v)
            (ß this.v = v)
            this
        )

        (§ method String toString()
            (ß "Unbound: " + v)
        )

        (§ method Object throwArity(int n)
            (§ throw new IllegalStateException("Attempting to call unbound fn: " + v))
        )
    )

    (class-ns Frame
        (§ def Frame TOP = new Frame(PersistentHashMap.EMPTY, nil))
        ;; Var->TBox
        (§ field Associative bindings)
        ;; Var->val
        (§ field Frame prev)

        (§ constructor Frame(Associative bindings, Frame prev)
            (ß this.bindings = bindings)
            (ß this.prev = prev)
            this
        )

        #_protected
        (§ method Object clone()
            (ß new Frame(this.bindings, nil))
        )
    )

    (§ def ThreadLocal<Frame> dvals = new ThreadLocal<Frame>()
        (§ reify
            #_protected
            (§ method Frame initialValue()
                (ß Frame.TOP)
            )
        )
    )

    #_volatile
    (§ def int rev = 0)

    (§ def Keyword privateKey = Keyword.intern(nil, "private"))
    (§ def IPersistentMap privateMeta = new PersistentArrayMap(new Object[] (§ privateKey, Boolean.TRUE )))
    (§ def Keyword macroKey = Keyword.intern(nil, "macro"))
    (§ def Keyword nameKey = Keyword.intern(nil, "name"))
    (§ def Keyword nsKey = Keyword.intern(nil, "ns"))

    #_volatile
    (§ field Object root)

    #_volatile
    (§ field boolean dynamic = false)
    #_transient
    (§ field AtomicBoolean threadBound)
    (§ field Symbol sym)
    (§ field Namespace ns)

    (§ defn Object getThreadBindingFrame()
        (ß dvals.get())
    )

    (§ defn Object cloneThreadBindingFrame()
        (ß dvals.get().clone())
    )

    (§ defn void resetThreadBindingFrame(Object frame)
        (ß dvals.set((Frame) frame))
        nil
    )

    (§ method Var setDynamic()
        (ß this.dynamic = true)
        this
    )

    (§ method Var setDynamic(boolean b)
        (ß this.dynamic = b)
        this
    )

    (§ method boolean isDynamic()
        dynamic
    )

    (§ defn Var intern(Namespace ns, Symbol sym, Object root)
        (ß intern(ns, sym, root, true))
    )

    (§ defn Var intern(Namespace ns, Symbol sym, Object root, boolean replaceRoot)
        (§ let Var dvout = ns.intern(sym))
        (§ if (ß !dvout.hasRoot() || replaceRoot)
            (ß dvout.bindRoot(root))
        )
        dvout
    )

    (§ method String toString()
        (§ if (ß ns != nil)
            (§ return (ß "#'" + ns.name + "/" + sym))
        )
        (ß "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">")
    )

    (§ defn Var find(Symbol nsQualifiedSym)
        (§ if (ß nsQualifiedSym.ns == nil)
            (§ throw new IllegalArgumentException("Symbol must be namespace-qualified"))
        )
        (§ let Namespace ns = Namespace.find(Symbol.intern(nsQualifiedSym.ns)))
        (§ if (ß ns == nil)
            (§ throw new IllegalArgumentException("No such namespace: " + nsQualifiedSym.ns))
        )
        (ß ns.findInternedVar(Symbol.intern(nsQualifiedSym.name)))
    )

    (§ defn Var intern(Symbol nsName, Symbol sym)
        (§ let Namespace ns = Namespace.findOrCreate(nsName))
        (ß intern(ns, sym))
    )

    (§ defn Var internPrivate(String nsName, String sym)
        (§ let Namespace ns = Namespace.findOrCreate(Symbol.intern(nsName)))
        (§ let Var ret = intern(ns, Symbol.intern(sym)))
        (ß ret.setMeta(privateMeta))
        ret
    )

    (§ defn Var intern(Namespace ns, Symbol sym)
        (ß ns.intern(sym))
    )

    (§ defn Var create()
        (ß new Var(nil, nil))
    )

    (§ defn Var create(Object root)
        (ß new Var(nil, nil, root))
    )

    (§ constructor Var(Namespace ns, Symbol sym)
        (ß this.ns = ns)
        (ß this.sym = sym)
        (ß this.threadBound = new AtomicBoolean(false))
        (ß this.root = new Unbound(this))
        (ß setMeta(PersistentHashMap.EMPTY))
        this
    )

    (§ constructor Var(Namespace ns, Symbol sym, Object root)
        (§ this(ns, sym))
        (ß this.root = root)
        (ß ++rev)
        this
    )

    (§ method boolean isBound()
        (ß (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this))))
    )

    (§ method Object get()
        (§ if (ß !threadBound.get())
            (§ return root)
        )
        (ß deref())
    )

    (§ method Object deref()
        (§ let TBox b = getThreadBinding())
        (§ if (ß b != nil)
            (§ return (ß b.val))
        )
        root
    )

    (§ method void setValidator(IFn vf)
        (§ if (ß hasRoot())
            (ß validate(vf, root))
        )
        (ß validator = vf)
        nil
    )

    (§ method Object alter(IFn fn, ISeq args)
        (ß set(fn.applyTo(RT.cons(deref(), args))))
        this
    )

    (§ method Object set(Object val)
        (ß validate(getValidator(), val))
        (§ let TBox b = getThreadBinding())
        (§ if (ß b != nil)
            (§ if (ß Thread.currentThread() != b.thread)
                (§ throw new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym)))
            )
            (§ return (ß (b.val = val)))
        )
        (§ throw new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym)))
    )

    (§ method Object doSet(Object val)
        (ß set(val))
    )

    (§ method Object doReset(Object val)
        (ß bindRoot(val))
        val
    )

    (§ method void setMeta(IPersistentMap m)
        ;; ensure these basis keys
        (ß resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns)))
        nil
    )

    (§ method void setMacro()
        (ß alterMeta(assoc, RT.list(macroKey, RT.T)))
        nil
    )

    (§ method boolean isMacro()
        (ß RT.booleanCast(meta().valAt(macroKey)))
    )

    (§ method boolean isPublic()
        (ß !RT.booleanCast(meta().valAt(privateKey)))
    )

    (§ method Object getRawRoot()
        root
    )

    (§ method Object getTag()
        (ß meta().valAt(RT.TAG_KEY))
    )

    (§ method void setTag(Symbol tag)
        (ß alterMeta(assoc, RT.list(RT.TAG_KEY, tag)))
        nil
    )

    (§ method boolean hasRoot()
        (ß !(root instanceof Unbound))
    )

    ;; binding root always clears macro flag
    (§ method void bindRoot(Object root)
        (§ sync (ß this)
            (ß validate(getValidator(), root))
            (§ let Object oldroot = this.root)
            (ß this.root = root)
            (ß ++rev)
            (ß alterMeta(dissoc, RT.list(macroKey)))
            (ß notifyWatches(oldroot, this.root))
        )
        nil
    )

    (§ method void swapRoot(Object root)
        (§ sync (ß this)
            (ß validate(getValidator(), root))
            (§ let Object oldroot = this.root)
            (ß this.root = root)
            (ß ++rev)
            (ß notifyWatches(oldroot, root))
        )
        nil
    )

    (§ method void unbindRoot()
        (§ sync (ß this)
            (ß this.root = new Unbound(this))
            (ß ++rev)
        )
        nil
    )

    (§ method void commuteRoot(IFn fn)
        (§ sync (ß this)
            (§ let Object newRoot = fn.invoke(root))
            (ß validate(getValidator(), newRoot))
            (§ let Object oldroot = root)
            (ß this.root = newRoot)
            (ß ++rev)
            (ß notifyWatches(oldroot, newRoot))
        )
        nil
    )

    (§ method Object alterRoot(IFn fn, ISeq args)
        (§ sync (ß this)
            (§ let Object newRoot = fn.applyTo(RT.cons(root, args)))
            (ß validate(getValidator(), newRoot))
            (§ let Object oldroot = root)
            (ß this.root = newRoot)
            (ß ++rev)
            (ß notifyWatches(oldroot, newRoot))
            newRoot
        )
    )

    (§ defn void pushThreadBindings(Associative bindings)
        (§ let Frame f = dvals.get())
        (§ let Associative bmap = f.bindings)
        (§ loop-when-recur [(ß ISeq bs = bindings.seq())] (ß bs != nil) [(ß bs = bs.next())]
            (§ let IMapEntry e = (IMapEntry) bs.first())
            (§ let Var v = (Var) e.key())
            (§ if (ß !v.dynamic)
                (§ throw new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym)))
            )
            (ß v.validate(v.getValidator(), e.val()))
            (ß v.threadBound.set(true))
            (ß bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val())))
        )
        (ß dvals.set(new Frame(bmap, f)))
        nil
    )

    (§ defn void popThreadBindings()
        (§ let Frame f = dvals.get().prev)
        (§ if (ß f == nil)
            (§ throw new IllegalStateException("Pop without matching push"))
        )
        (§ elseif (ß f == Frame.TOP)
            (ß dvals.remove())
        )
        (§ else 
            (ß dvals.set(f))
        )
        nil
    )

    (§ defn Associative getThreadBindings()
        (§ let Frame f = dvals.get())
        (§ let IPersistentMap ret = PersistentHashMap.EMPTY)
        (§ loop-when-recur [(ß ISeq bs = f.bindings.seq())] (ß bs != nil) [(ß bs = bs.next())]
            (§ let IMapEntry e = (IMapEntry) bs.first())
            (§ let Var v = (Var) e.key())
            (§ let TBox b = (TBox) e.val())
            (ß ret = ret.assoc(v, b.val))
        )
        ret
    )

    (§ method TBox getThreadBinding()
        (§ if (ß threadBound.get())
            (§ let IMapEntry e = dvals.get().bindings.entryAt(this))
            (§ if (ß e != nil)
                (§ return (ß (TBox) e.val()))
            )
        )
        nil
    )

    (§ method IFn fn()
        (ß (IFn) deref())
    )

    (§ method Object call()
        (ß invoke())
    )

    (§ method void run()
        (ß invoke())
        nil
    )

    (§ method Object invoke()
        (ß fn().invoke())
    )

    (§ method Object invoke(Object arg1)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil),
                (Object[])Util.ret1(args, args = nil)))
    )

    (§ method Object applyTo(ISeq arglist)
        (ß fn().applyTo(arglist))
    )

    (§ def IFn assoc = new AFn()
        (§ reify
            (§ anno @Override)
            (§ method Object invoke(Object m, Object k, Object v)
                (ß RT.assoc(m, k, v))
            )
        )
    )

    (§ def IFn dissoc = new AFn()
        (§ reify
            (§ anno @Override)
            (§ method Object invoke(Object c, Object k)
                (ß RT.dissoc(c, k))
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    #_volatile
    (§ field Object val)

    (§ constructor Volatile(Object val)
        (ß this.val = val)
        this
    )

    (§ method Object deref()
        val
    )

    (§ method Object reset(Object newval)
        (ß this.val = newval)
    )
)
)

(java-ns cloiure.lang.WarnBoxedMath

(§ import java.lang.annotation.Retention)
(§ import java.lang.annotation.RetentionPolicy)
(§ import java.lang.annotation.ElementType)
(§ import java.lang.annotation.Target)

(§ anno @Retention(RetentionPolicy.RUNTIME))
(§ anno @Target(ElementType.METHOD))
(§ @interface WarnBoxedMath)
    (§ @abstract boolean value() default true)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

(class-ns main
    (§ def- Symbol CLOIURE_MAIN = Symbol.intern("cloiure.main"))
    (§ def- Var REQUIRE = RT.var("cloiure.core", "require"))
    (§ def- Var MAIN = RT.var("cloiure.main", "main"))

    (§ defn void main(String[] args)
        (ß REQUIRE.invoke(CLOIURE_MAIN))
        (ß MAIN.applyTo(RT.seq(args)))
        nil
    )
)
)
