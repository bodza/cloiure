(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def % rem)
(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro cast' [_ x] #_(ensure symbol? _) `(do ~x))

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(import
    [java.io File FileInputStream FileNotFoundException FileOutputStream InputStreamReader IOException LineNumberReader OutputStreamWriter PrintWriter PushbackReader Reader StringReader StringWriter Writer]
  #_[java.lang Character Class Exception IllegalArgumentException IllegalStateException Integer Number NumberFormatException Object RuntimeException String StringBuilder Throwable UnsupportedOperationException]
    [java.lang.ref Reference ReferenceQueue SoftReference WeakReference]
    [java.lang.reflect Array Constructor Field InvocationHandler #_Method Modifier]
    [java.math BigDecimal BigInteger MathContext]
    [java.net JarURLConnection MalformedURLException URL URLClassLoader URLConnection]
    [java.nio ByteBuffer]
    [java.nio.charset Charset]
    [java.security AccessController PrivilegedAction]
    [java.util ArrayList Arrays Collection Comparator Enumeration HashMap HashSet Iterator LinkedList List Map Map$Entry NoSuchElementException Queue RandomAccess Set Stack TreeMap]
    [java.util.concurrent Callable ConcurrentHashMap ConcurrentMap CountDownLatch Executor ExecutorService Executors ThreadFactory TimeUnit]
    [java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicLong AtomicReference]
    [java.util.concurrent.locks ReentrantReadWriteLock]
    [java.util.regex Matcher Pattern]
    [cloiure.asm Attribute ByteVector ClassVisitor ClassWriter FieldVisitor Label MethodVisitor Opcodes Type]
    [cloiure.asm.commons GeneratorAdapter Method]
)

(declare AFn'new AFunction'new AMapEntry'new APersistentMap'new APersistentVector'new AReference'new ASeq'new ATransientMap'new AbortException'new AbstractMap'new ArgReader'new AssignParser'new Attribute'new BigDecimalOps'new BigIntOps'new BodyParser'new CaseParser'new ConditionalReader'new ConstantParser'new CtorReader'new DefParser'new DefaultComparator'new DeftypeParser'new DoubleOps'new EdnCharacterReader'new EdnCommentReader'new EdnDiscardReader'new EdnDispatchReader'new EdnListReader'new EdnMapReader'new EdnMetaReader'new EdnNamespaceMapReader'new EdnSetReader'new EdnStringReader'new EdnSymbolicValueReader'new EdnUnmatchedDelimiterReader'new EdnUnreadableReader'new EdnVectorReader'new EmptyBuffer'new EnumerationSeqState'new Error'new EvalReader'new Exception'new FieldExpr'new FnReader'new HostExpr'new HostParser'new IfParser'new IllegalArgumentException'new ImportParser'new IteratorSeqState'new LetFnParser'new LetParser'new LispCharacterReader'new LispCommentReader'new LispDiscardReader'new LispDispatchReader'new LispListReader'new LispMapReader'new LispMetaReader'new LispNamespaceMapReader'new LispSetReader'new LispStringReader'new LispSymbolicValueReader'new LispUnmatchedDelimiterReader'new LispUnreadableReader'new LispVectorReader'new LiteralExpr'new LockingTransaction'new LongOps'new MethodExpr'new MonitorEnterParser'new MonitorExitParser'new NewParser'new NilExpr'new Number'new Obj'new OpsP'new Primordial'new PushbackReader'new RatioOps'new RecurParser'new RegexReader'new ReifyParser'new RestFn'new RetryEx'new RuntimeException'new SyntaxQuoteReader'new TaggedReader'new TheVarParser'new ThrowParser'new TryParser'new URLClassLoader'new UnquoteReader'new UntypedExpr'new VarReader'new)
(declare AFn'applyToHelper)
(declare ActionQueue'EMPTY ActionQueue'new)
(declare AgentAction'new AgentAction'doRun)
(declare Agent'CONTINUE Agent'FAIL Agent'sendThreadPoolCounter Agent'sendOffThreadPoolCounter Agent'createThreadFactory Agent'pooledExecutor Agent'soloExecutor Agent'nested Agent'shutdown Agent'new-1 Agent'new-2 Agent'dispatchAction Agent'releasePendingSends)
(declare KeySeq'create KeySeq'createFromMap KeySeq'new-2 KeySeq'new-3)
(declare ValSeq'create ValSeq'createFromMap ValSeq'new-2 ValSeq'new-3)
(declare APersistentMap'mapEquals APersistentMap'mapHash APersistentMap'mapHasheq APersistentMap'MAKE_ENTRY APersistentMap'MAKE_KEY APersistentMap'MAKE_VAL)
(declare APersistentSet'new APersistentSet'setEquals)
(declare VSeq'new-2 VSeq'new-3)
(declare RSeq'new-2 RSeq'new-3)
(declare SubVector'new)
(declare APersistentVector'doEquals APersistentVector'doEquiv)
(declare ARef'new-0 ARef'new-1)
(declare AReference'new-0 AReference'new-1)
(declare ArityException'new-2 ArityException'new-3)
(declare ArrayChunk'new-1 ArrayChunk'new-2 ArrayChunk'new-3)
(declare ArrayIter_int'new ArrayIter_float'new ArrayIter_double'new ArrayIter_long'new ArrayIter_byte'new ArrayIter_char'new ArrayIter_short'new ArrayIter_boolean'new ArrayIter'EMPTY_ITERATOR ArrayIter'create-0 ArrayIter'create-1 ArrayIter'createFromObject ArrayIter'new)
(declare ArraySeq_int'new ArraySeq_float'new ArraySeq_double'new ArraySeq_long'new ArraySeq_byte'new ArraySeq_char'new ArraySeq_short'new ArraySeq_boolean'new ArraySeq'create-0 ArraySeq'create-1 ArraySeq'createFromObject ArraySeq'new-2 ArraySeq'new-3)
(declare ASeq'new-1 ASeq'new-0)
(declare Atom'new-1 Atom'new-2)
(declare ATransientMap'NOT_FOUND)
(declare ATransientSet'new)
(declare BigInt'ZERO BigInt'ONE BigInt'new BigInt'fromBigInteger BigInt'fromLong BigInt'valueOf)
(declare Binding'new-1 Binding'new-2)
(declare Box'new)
(declare ChunkBuffer'new)
(declare ChunkedCons'new-3 ChunkedCons'new-2)
(declare Compile'PATH_PROP Compile'REFLECTION_WARNING_PROP Compile'UNCHECKED_MATH_PROP Compile'compile_path Compile'compile Compile'warn_on_reflection Compile'unchecked_math Compile'main)
(declare DefExpr'bindRootMethod DefExpr'setTagMethod DefExpr'setMetaMethod DefExpr'setDynamicMethod DefExpr'symintern DefExpr'internVar DefExpr'new)
(declare AssignExpr'new)
(declare VarExpr'getMethod VarExpr'setMethod VarExpr'new)
(declare TheVarExpr'new)
(declare KeywordExpr'new)
(declare ImportExpr'forNameMethod ImportExpr'importClassMethod ImportExpr'derefMethod ImportExpr'new)
(declare HostExpr'BOOLEAN_TYPE HostExpr'CHAR_TYPE HostExpr'INTEGER_TYPE HostExpr'LONG_TYPE HostExpr'FLOAT_TYPE HostExpr'DOUBLE_TYPE HostExpr'SHORT_TYPE HostExpr'BYTE_TYPE HostExpr'NUMBER_TYPE HostExpr'charValueMethod HostExpr'booleanValueMethod HostExpr'charValueOfMethod HostExpr'intValueOfMethod HostExpr'longValueOfMethod HostExpr'floatValueOfMethod HostExpr'doubleValueOfMethod HostExpr'shortValueOfMethod HostExpr'byteValueOfMethod HostExpr'intValueMethod HostExpr'longValueMethod HostExpr'floatValueMethod HostExpr'doubleValueMethod HostExpr'byteValueMethod HostExpr'shortValueMethod HostExpr'fromIntMethod HostExpr'fromLongMethod HostExpr'fromDoubleMethod HostExpr'emitBoxReturn HostExpr'emitUnboxArg HostExpr'maybeClass HostExpr'maybeSpecialTag HostExpr'tagToClass)
(declare InstanceFieldExpr'invokeNoArgInstanceMember InstanceFieldExpr'setInstanceFieldMethod InstanceFieldExpr'new)
(declare StaticFieldExpr'new)
(declare MethodExpr'emitArgsAsArray MethodExpr'emitTypedArgs)
(declare InstanceMethodExpr'invokeInstanceMethodMethod InstanceMethodExpr'new)
(declare StaticMethodExpr'forNameMethod StaticMethodExpr'invokeStaticMethodMethod StaticMethodExpr'warnOnBoxedKeyword StaticMethodExpr'new StaticMethodExpr'isBoxedMath)
(declare UnresolvedVarExpr'new)
(declare NumberExpr'new NumberExpr'parse)
(declare ConstantParser'formKey)
(declare ConstantExpr'new)
(declare BooleanExpr'new)
(declare StringExpr'new)
(declare MonitorEnterExpr'new)
(declare MonitorExitExpr'new)
(declare CatchClause'new)
(declare TryExpr'new)
(declare ThrowExpr'new)
(declare NewExpr'invokeConstructorMethod NewExpr'forNameMethod NewExpr'new)
(declare MetaExpr'IOBJ_TYPE MetaExpr'withMetaMethod MetaExpr'new)
(declare IfExpr'new)
(declare EmptyExpr'HASHMAP_TYPE EmptyExpr'HASHSET_TYPE EmptyExpr'VECTOR_TYPE EmptyExpr'IVECTOR_TYPE EmptyExpr'TUPLE_TYPE EmptyExpr'LIST_TYPE EmptyExpr'EMPTY_LIST_TYPE EmptyExpr'new)
(declare ListExpr'arrayToListMethod ListExpr'new)
(declare MapExpr'mapMethod MapExpr'mapUniqueKeysMethod MapExpr'new MapExpr'parse)
(declare SetExpr'setMethod SetExpr'new SetExpr'parse)
(declare VectorExpr'vectorMethod VectorExpr'new VectorExpr'parse)
(declare KeywordInvokeExpr'ILOOKUP_TYPE KeywordInvokeExpr'new)
(declare InstanceOfExpr'new)
(declare StaticInvokeExpr'new StaticInvokeExpr'parse)
(declare InvokeExpr'onKey InvokeExpr'methodMapKey InvokeExpr'sigTag InvokeExpr'new InvokeExpr'parse)
(declare SourceDebugExtensionAttribute'new)
(declare FnExpr'aFnType FnExpr'restFnType FnExpr'new FnExpr'parse)
(declare ObjExpr'CONST_PREFIX ObjExpr'voidctor ObjExpr'kwintern ObjExpr'symintern ObjExpr'varintern ObjExpr'DYNAMIC_CLASSLOADER_TYPE ObjExpr'getClassMethod ObjExpr'getClassLoaderMethod ObjExpr'getConstantsMethod ObjExpr'readStringMethod ObjExpr'ILOOKUP_SITE_TYPE ObjExpr'ILOOKUP_THUNK_TYPE ObjExpr'KEYWORD_LOOKUPSITE_TYPE ObjExpr'new ObjExpr'trimGenID ObjExpr'varGetMethod ObjExpr'varGetRawMethod)
(declare PathNode'new)
(declare FnMethod'new FnMethod'classChar FnMethod'primInterface FnMethod'parse)
(declare ObjMethod'new ObjMethod'emitBody)
(declare LocalBinding'new)
(declare LocalBindingExpr'new)
(declare BodyExpr'new)
(declare BindingInit'new)
(declare LetFnExpr'new)
(declare LetExpr'new)
(declare RecurExpr'new)
(declare CompilerException'new)
(declare NewInstanceExpr'new NewInstanceExpr'build NewInstanceExpr'compileStub NewInstanceExpr'interfaceNames NewInstanceExpr'slashname NewInstanceExpr'msig NewInstanceExpr'considerMethod NewInstanceExpr'gatherMethods-2m NewInstanceExpr'gatherMethods-2s)
(declare NewInstanceMethod'dummyThis NewInstanceMethod'new NewInstanceMethod'msig NewInstanceMethod'parse NewInstanceMethod'findMethodsWithNameAndArity NewInstanceMethod'findMethodsWithName)
(declare MethodParamExpr'new)
(declare CaseExpr'NUMBER_TYPE CaseExpr'intValueMethod CaseExpr'hashMethod CaseExpr'hashCodeMethod CaseExpr'equivMethod CaseExpr'compactKey CaseExpr'sparseKey CaseExpr'hashIdentityKey CaseExpr'hashEquivKey CaseExpr'intKey CaseExpr'new CaseExpr'emitExpr)
(declare Compiler'DEF Compiler'LOOP Compiler'RECUR Compiler'IF Compiler'LET Compiler'LETFN Compiler'DO Compiler'FN Compiler'FNONCE Compiler'QUOTE Compiler'THE_VAR Compiler'DOT Compiler'ASSIGN Compiler'TRY Compiler'CATCH Compiler'FINALLY Compiler'THROW Compiler'MONITOR_ENTER Compiler'MONITOR_EXIT Compiler'IMPORT Compiler'DEFTYPE Compiler'CASE Compiler'CLASS Compiler'NEW Compiler'THIS Compiler'REIFY Compiler'LIST Compiler'HASHMAP Compiler'VECTOR Compiler'IDENTITY Compiler'_AMP_ Compiler'ISEQ Compiler'loadNs Compiler'inlineKey Compiler'inlineAritiesKey Compiler'staticKey Compiler'arglistsKey Compiler'INVOKE_STATIC Compiler'volatileKey Compiler'implementsKey Compiler'COMPILE_STUB_PREFIX Compiler'protocolKey Compiler'onKey Compiler'dynamicKey Compiler'redefKey Compiler'NS Compiler'IN_NS Compiler'specials Compiler'MAX_POSITIONAL_ARITY Compiler'OBJECT_TYPE Compiler'KEYWORD_TYPE Compiler'VAR_TYPE Compiler'SYMBOL_TYPE Compiler'IFN_TYPE Compiler'AFUNCTION_TYPE Compiler'RT_TYPE Compiler'NUMBERS_TYPE Compiler'CLASS_TYPE Compiler'NS_TYPE Compiler'UTIL_TYPE Compiler'REFLECTOR_TYPE Compiler'THROWABLE_TYPE Compiler'BOOLEAN_OBJECT_TYPE Compiler'IPERSISTENTMAP_TYPE Compiler'IOBJ_TYPE Compiler'TUPLE_TYPE Compiler'createTupleMethods Compiler'ARG_TYPES Compiler'EXCEPTION_TYPES Compiler'LOCAL_ENV Compiler'LOOP_LOCALS Compiler'LOOP_LABEL Compiler'CONSTANTS Compiler'CONSTANT_IDS Compiler'KEYWORD_CALLSITES Compiler'PROTOCOL_CALLSITES Compiler'VAR_CALLSITES Compiler'KEYWORDS Compiler'VARS Compiler'METHOD Compiler'IN_CATCH_FINALLY Compiler'METHOD_RETURN_CONTEXT Compiler'NO_RECUR Compiler'LOADER Compiler'SOURCE Compiler'SOURCE_PATH Compiler'COMPILE_PATH Compiler'COMPILE_FILES Compiler'INSTANCE Compiler'ADD_ANNOTATIONS Compiler'disableLocalsClearingKey Compiler'directLinkingKey Compiler'elideMetaKey Compiler'COMPILER_OPTIONS Compiler'getCompilerOption Compiler'elideMeta Compiler'LINE Compiler'COLUMN Compiler'lineDeref Compiler'columnDeref Compiler'LINE_BEFORE Compiler'COLUMN_BEFORE Compiler'LINE_AFTER Compiler'COLUMN_AFTER Compiler'NEXT_LOCAL_NUM Compiler'RET_LOCAL_NUM Compiler'COMPILE_STUB_SYM Compiler'COMPILE_STUB_CLASS Compiler'CLEAR_PATH Compiler'CLEAR_ROOT Compiler'CLEAR_SITES Compiler'RECUR_CLASS Compiler'isSpecial Compiler'inTailCall Compiler'resolveSymbol Compiler'maybePrimitiveType Compiler'maybeJavaClass Compiler'NIL_EXPR Compiler'TRUE_EXPR Compiler'FALSE_EXPR Compiler'subsumes Compiler'getTypeStringForArgs Compiler'getMatchingParams Compiler'CHAR_MAP Compiler'DEMUNGE_MAP Compiler'DEMUNGE_PATTERN Compiler'munge Compiler'demunge Compiler'clearPathRoot Compiler'registerLocal Compiler'getAndIncLocalNum Compiler'analyze-2 Compiler'analyze-3 Compiler'isMacro Compiler'isInline Compiler'namesStaticMember Compiler'preserveTag Compiler'MACRO_CHECK Compiler'MACRO_CHECK_LOADING Compiler'MACRO_CHECK_LOCK Compiler'ensureMacroCheck Compiler'checkSpecs Compiler'macroexpand1 Compiler'macroexpand Compiler'analyzeSeq Compiler'errorMsg Compiler'eval-1 Compiler'eval-2 Compiler'registerConstant Compiler'registerKeyword Compiler'registerKeywordCallsite Compiler'registerProtocolCallsite Compiler'registerVarCallsite Compiler'fwdPath Compiler'commonPath Compiler'addAnnotation Compiler'addParameterAnnotation Compiler'analyzeSymbol Compiler'destubClassName Compiler'getType Compiler'resolve-2 Compiler'resolve-1 Compiler'namespaceFor-1 Compiler'namespaceFor-2 Compiler'resolveIn Compiler'maybeResolveIn Compiler'lookupVar-3 Compiler'lookupVar-2 Compiler'registerVar Compiler'currentNS Compiler'closeOver Compiler'referenceLocal Compiler'tagOf Compiler'loadFile Compiler'load-1 Compiler'consumeWhitespaces Compiler'OPTS_COND_ALLOWED Compiler'readerOpts Compiler'load-3 Compiler'writeClassFile Compiler'pushNS Compiler'pushNSandLoader Compiler'getLookupThunk Compiler'compile1 Compiler'compile Compiler'inty Compiler'retType Compiler'primClass-1s Compiler'tagClass Compiler'primClass-1c Compiler'boxClass Compiler'emptyVarCallSites)
(declare Cons'new-2 Cons'new-3)
(declare Cycle'new-3 Cycle'new-5 Cycle'create)
(declare Delay'new Delay'force)
(declare DynamicClassLoader'classCache DynamicClassLoader'EMPTY_URLS DynamicClassLoader'RQ DynamicClassLoader'new-0 DynamicClassLoader'new-1 DynamicClassLoader'findInMemoryClass)
(declare EdnReaderException'new)
(declare EdnSymbolicValueReader'specials)
(declare TaggedReader'READERS TaggedReader'DEFAULT)
(declare EdnReader'macros EdnReader'dispatchMacros EdnReader'symbolPat EdnReader'intPat EdnReader'ratioPat EdnReader'floatPat EdnReader'taggedReader EdnReader'nonConstituent EdnReader'readString EdnReader'isWhitespace EdnReader'unread EdnReader'read1 EdnReader'EOF EdnReader'read-2 EdnReader'read-5 EdnReader'readToken EdnReader'readNumber EdnReader'readUnicodeChar-4 EdnReader'readUnicodeChar-5 EdnReader'interpretToken EdnReader'matchSymbol EdnReader'matchNumber EdnReader'getMacro EdnReader'isMacro EdnReader'isTerminatingMacro EdnReader'readDelimitedList)
(declare EnumerationSeq'create EnumerationSeq'new-1 EnumerationSeq'new-3)
(declare ExceptionInfo'new-2 ExceptionInfo'new-3)
(declare FnLoaderThunk'new)
(declare Intrinsics'oa Intrinsics'ops Intrinsics'preds)
(declare Iterate'UNREALIZED_SEED Iterate'new-3 Iterate'new-5 Iterate'create)
(declare IteratorSeq'create IteratorSeq'new-1 IteratorSeq'new-3)
(declare Keyword'TABLE Keyword'RQ Keyword'intern Keyword'intern-2 Keyword'intern-1 Keyword'new Keyword'find Keyword'find-2 Keyword'find-1)
(declare KeywordLookupSite'new)
(declare LazilyPersistentVector'createOwning LazilyPersistentVector'fcount LazilyPersistentVector'create)
(declare LazySeq'new-1 LazySeq'new-2)
(declare LineNumberingPushbackReader'newline LineNumberingPushbackReader'new-1 LineNumberingPushbackReader'new-2)
(declare LispReaderException'new)
(declare RegexReader'stringrdr)
(declare LispSymbolicValueReader'specials)
(declare WrappingReader'new)
(declare DeprecatedWrappingReader'new)
(declare SyntaxQuoteReader'syntaxQuote SyntaxQuoteReader'sqExpandList SyntaxQuoteReader'flattenMap)
(declare ConditionalReader'READ_STARTED ConditionalReader'DEFAULT_FEATURE ConditionalReader'RESERVED_FEATURES ConditionalReader'hasFeature ConditionalReader'readCondDelimited ConditionalReader'checkConditionalAllowed)
(declare LispReader'QUOTE LispReader'THE_VAR LispReader'UNQUOTE LispReader'UNQUOTE_SPLICING LispReader'CONCAT LispReader'SEQ LispReader'LIST LispReader'APPLY LispReader'HASHMAP LispReader'HASHSET LispReader'VECTOR LispReader'WITH_META LispReader'META LispReader'DEREF LispReader'READ_COND LispReader'READ_COND_SPLICING LispReader'UNKNOWN LispReader'macros LispReader'dispatchMacros LispReader'symbolPat LispReader'intPat LispReader'ratioPat LispReader'floatPat LispReader'GENSYM_ENV LispReader'ARG_ENV LispReader'ctorReader LispReader'READ_COND_ENV LispReader'isWhitespace LispReader'unread LispReader'read1 LispReader'OPT_EOF LispReader'OPT_FEATURES LispReader'OPT_READ_COND LispReader'EOFTHROW LispReader'PLATFORM_KEY LispReader'PLATFORM_FEATURES LispReader'COND_ALLOW LispReader'COND_PRESERVE LispReader'read-2 LispReader'read-4 LispReader'read-5 LispReader'read-6 LispReader'ensurePending LispReader'installPlatformFeature LispReader'read-9 LispReader'readToken LispReader'readNumber LispReader'readUnicodeChar-4 LispReader'readUnicodeChar-5 LispReader'interpretToken LispReader'matchSymbol LispReader'matchNumber LispReader'getMacro LispReader'isMacro LispReader'isTerminatingMacro LispReader'garg LispReader'registerArg LispReader'isUnquoteSplicing LispReader'isUnquote LispReader'READ_EOF LispReader'READ_FINISHED LispReader'readDelimitedList LispReader'isPreserveReadCond)
(declare LockingTransactionInfo'new)
(declare CFn'new)
(declare Notify'new)
(declare LockingTransaction'RETRY_LIMIT LockingTransaction'LOCK_WAIT_MSECS LockingTransaction'BARGE_WAIT_NANOS LockingTransaction'RUNNING LockingTransaction'COMMITTING LockingTransaction'RETRY LockingTransaction'KILLED LockingTransaction'COMMITTED LockingTransaction'transaction LockingTransaction'lastPoint LockingTransaction'getEx LockingTransaction'isRunning LockingTransaction'getRunning LockingTransaction'runInTransaction)
(declare LongRangeIterator'new)
(declare LongChunk'new)
(declare LongRange'CHUNK_SIZE LongRange'positiveStep LongRange'negativeStep LongRange'new-4 LongRange'new-6 LongRange'new-7 LongRange'create-1 LongRange'create-2 LongRange'create-3)
(declare MapEntry'create MapEntry'new)
(declare Entry'new)
(declare MethodImplCache'new-2 MethodImplCache'new-5 MethodImplCache'new-3)
(declare MultiFn'assoc MultiFn'dissoc MultiFn'isa MultiFn'parents MultiFn'new)
(declare Murmur3'seed Murmur3'C1 Murmur3'C2 Murmur3'hashInt Murmur3'hashLong Murmur3'hashUnencodedChars Murmur3'mixCollHash Murmur3'hashOrdered Murmur3'hashUnordered Murmur3'mixK1 Murmur3'mixH1 Murmur3'fmix)
(declare Namespace'namespaces Namespace'new Namespace'all Namespace'areDifferentInstancesOfSameClassName Namespace'findOrCreate Namespace'remove Namespace'find)
(declare LongOps'gcd)
(declare RatioOps'normalizeRet)
(declare BigDecimalOps'MATH_CONTEXT)
(declare Numbers'isZero-1o Numbers'isPos-1o Numbers'isNeg-1o Numbers'minus-1o Numbers'minusP-1o Numbers'inc-1o Numbers'incP-1o Numbers'dec-1o Numbers'decP-1o Numbers'add-2oo Numbers'addP-2oo Numbers'minus-2oo Numbers'minusP-2oo Numbers'multiply-2oo Numbers'multiplyP-2oo Numbers'divide-2oo Numbers'quotient-2oo Numbers'remainder-2oo Numbers'quotient-2dd Numbers'remainder-2dd Numbers'equiv-2oo Numbers'equiv-2nn Numbers'equal Numbers'lt-2oo Numbers'lte-2oo Numbers'gt-2oo Numbers'gte-2oo Numbers'compare Numbers'toBigInt Numbers'toBigInteger Numbers'toBigDecimal Numbers'toRatio Numbers'rationalize Numbers'reduceBigInt Numbers'divide-2ii Numbers'shiftLeftInt Numbers'shiftLeft-2oo Numbers'shiftLeft-2ol Numbers'shiftLeft-2lo Numbers'shiftLeft-2ll Numbers'shiftRightInt Numbers'shiftRight-2oo Numbers'shiftRight-2ol Numbers'shiftRight-2lo Numbers'shiftRight-2ll Numbers'unsignedShiftRightInt Numbers'unsignedShiftRight-2oo Numbers'unsignedShiftRight-2ol Numbers'unsignedShiftRight-2lo Numbers'unsignedShiftRight-2ll Numbers'LONG_OPS Numbers'DOUBLE_OPS Numbers'RATIO_OPS Numbers'BIGINT_OPS Numbers'BIGDECIMAL_OPS Numbers'ops Numbers'hasheqFrom Numbers'hasheq Numbers'category Numbers'bitOpsCast Numbers'float_array-2 Numbers'float_array-1 Numbers'double_array-2 Numbers'double_array-1 Numbers'int_array-2 Numbers'int_array-1 Numbers'long_array-2 Numbers'long_array-1 Numbers'short_array-2 Numbers'short_array-1 Numbers'char_array-2 Numbers'char_array-1 Numbers'byte_array-2 Numbers'byte_array-1 Numbers'boolean_array-2 Numbers'boolean_array-1 Numbers'booleans Numbers'bytes Numbers'chars Numbers'shorts Numbers'floats Numbers'doubles Numbers'ints Numbers'longs Numbers'num-1o Numbers'num-1f Numbers'num-1d Numbers'add-2dd Numbers'addP-2dd Numbers'minus-2dd Numbers'minusP-2dd Numbers'minus-1d Numbers'minusP-1d Numbers'inc-1d Numbers'incP-1d Numbers'dec-1d Numbers'decP-1d Numbers'multiply-2dd Numbers'multiplyP-2dd Numbers'divide-2dd Numbers'equiv-2dd Numbers'lt-2dd Numbers'lte-2dd Numbers'gt-2dd Numbers'gte-2dd Numbers'isPos-1d Numbers'isNeg-1d Numbers'isZero-1d Numbers'throwIntOverflow Numbers'unchecked_int_add Numbers'unchecked_int_subtract Numbers'unchecked_int_negate Numbers'unchecked_int_inc Numbers'unchecked_int_dec Numbers'unchecked_int_multiply Numbers'not-1o Numbers'not-1l Numbers'and-2oo Numbers'and-2ol Numbers'and-2lo Numbers'and-2ll Numbers'or-2oo Numbers'or-2ol Numbers'or-2lo Numbers'or-2ll Numbers'xor-2oo Numbers'xor-2ol Numbers'xor-2lo Numbers'xor-2ll Numbers'andNot-2oo Numbers'andNot-2ol Numbers'andNot-2lo Numbers'andNot-2ll Numbers'clearBit-2oo Numbers'clearBit-2ol Numbers'clearBit-2lo Numbers'clearBit-2ll Numbers'setBit-2oo Numbers'setBit-2ol Numbers'setBit-2lo Numbers'setBit-2ll Numbers'flipBit-2oo Numbers'flipBit-2ol Numbers'flipBit-2lo Numbers'flipBit-2ll Numbers'testBit-2oo Numbers'testBit-2ol Numbers'testBit-2lo Numbers'testBit-2ll Numbers'unchecked_int_divide Numbers'unchecked_int_remainder Numbers'num-1l Numbers'unchecked_add-2ll Numbers'unchecked_minus-2ll Numbers'unchecked_multiply-2ll Numbers'unchecked_minus-1l Numbers'unchecked_inc-1l Numbers'unchecked_dec-1l Numbers'unchecked_add-2oo Numbers'unchecked_minus-2oo Numbers'unchecked_multiply-2oo Numbers'unchecked_minus-1o Numbers'unchecked_inc-1o Numbers'unchecked_dec-1o Numbers'unchecked_add-2dd Numbers'unchecked_minus-2dd Numbers'unchecked_multiply-2dd Numbers'unchecked_minus-1d Numbers'unchecked_inc-1d Numbers'unchecked_dec-1d Numbers'unchecked_add-2do Numbers'unchecked_minus-2do Numbers'unchecked_multiply-2do Numbers'unchecked_add-2od Numbers'unchecked_minus-2od Numbers'unchecked_multiply-2od Numbers'unchecked_add-2dl Numbers'unchecked_minus-2dl Numbers'unchecked_multiply-2dl Numbers'unchecked_add-2ld Numbers'unchecked_minus-2ld Numbers'unchecked_multiply-2ld Numbers'unchecked_add-2lo Numbers'unchecked_minus-2lo Numbers'unchecked_multiply-2lo Numbers'unchecked_add-2ol Numbers'unchecked_minus-2ol Numbers'unchecked_multiply-2ol Numbers'quotient-2do Numbers'quotient-2od Numbers'quotient-2lo Numbers'quotient-2ol Numbers'quotient-2dl Numbers'quotient-2ld Numbers'remainder-2do Numbers'remainder-2od Numbers'remainder-2lo Numbers'remainder-2ol Numbers'remainder-2dl Numbers'remainder-2ld Numbers'add-2ll Numbers'addP-2ll Numbers'minus-2ll Numbers'minusP-2ll Numbers'minus-1l Numbers'minusP-1l Numbers'inc-1l Numbers'incP-1l Numbers'dec-1l Numbers'decP-1l Numbers'multiply-2ll Numbers'multiplyP-2ll Numbers'quotient-2ll Numbers'remainder-2ll Numbers'equiv-2ll Numbers'lt-2ll Numbers'lte-2ll Numbers'gt-2ll Numbers'gte-2ll Numbers'isPos-1l Numbers'isNeg-1l Numbers'isZero-1l Numbers'add-2lo Numbers'add-2ol Numbers'addP-2lo Numbers'addP-2ol Numbers'add-2do Numbers'add-2od Numbers'add-2dl Numbers'add-2ld Numbers'addP-2do Numbers'addP-2od Numbers'addP-2dl Numbers'addP-2ld Numbers'minus-2lo Numbers'minus-2ol Numbers'minusP-2lo Numbers'minusP-2ol Numbers'minus-2do Numbers'minus-2od Numbers'minus-2dl Numbers'minus-2ld Numbers'minusP-2do Numbers'minusP-2od Numbers'minusP-2dl Numbers'minusP-2ld Numbers'multiply-2lo Numbers'multiply-2ol Numbers'multiplyP-2lo Numbers'multiplyP-2ol Numbers'multiply-2do Numbers'multiply-2od Numbers'multiply-2dl Numbers'multiply-2ld Numbers'multiplyP-2do Numbers'multiplyP-2od Numbers'multiplyP-2dl Numbers'multiplyP-2ld Numbers'divide-2lo Numbers'divide-2ol Numbers'divide-2do Numbers'divide-2od Numbers'divide-2dl Numbers'divide-2ld Numbers'divide-2ll Numbers'lt-2lo Numbers'lt-2ol Numbers'lt-2do Numbers'lt-2od Numbers'lt-2dl Numbers'lt-2ld Numbers'lte-2lo Numbers'lte-2ol Numbers'lte-2do Numbers'lte-2od Numbers'lte-2dl Numbers'lte-2ld Numbers'gt-2lo Numbers'gt-2ol Numbers'gt-2do Numbers'gt-2od Numbers'gt-2dl Numbers'gt-2ld Numbers'gte-2lo Numbers'gte-2ol Numbers'gte-2do Numbers'gte-2od Numbers'gte-2dl Numbers'gte-2ld Numbers'equiv-2lo Numbers'equiv-2ol Numbers'equiv-2do Numbers'equiv-2od Numbers'equiv-2dl Numbers'equiv-2ld Numbers'isNaN Numbers'max-2dd Numbers'max-2dl Numbers'max-2do Numbers'max-2ld Numbers'max-2ll Numbers'max-2lo Numbers'max-2ol Numbers'max-2od Numbers'max-2oo Numbers'min-2dd Numbers'min-2dl Numbers'min-2do Numbers'min-2ld Numbers'min-2ll Numbers'min-2lo Numbers'min-2ol Numbers'min-2od Numbers'min-2oo)
(declare Obj'new-1 Obj'new-0)
(declare MSeq'new-2 MSeq'new-3)
(declare MIter'new-2 MIter'new-3)
(declare TransientArrayMap'new)
(declare PersistentArrayMap'EMPTY PersistentArrayMap'HASHTABLE_THRESHOLD PersistentArrayMap'create PersistentArrayMap'new-0 PersistentArrayMap'createWithCheck PersistentArrayMap'createAsIfByAssoc PersistentArrayMap'new-1 PersistentArrayMap'new-2 PersistentArrayMap'equalKey)
(declare TransientHashMap'new-1 TransientHashMap'new-5)
(declare HSeq'create-1 HSeq'create-4 HSeq'new)
(declare HIter'new)
(declare ArrayNode'new ArrayNode'foldTasks)
(declare BitmapIndexedNode'EMPTY BitmapIndexedNode'new)
(declare HashCollisionNode'new)
(declare NodeIter'NULL NodeIter'new)
(declare NodeSeq'new-2 NodeSeq'create-1 NodeSeq'kvreduce NodeSeq'create-3 NodeSeq'new-4)
(declare PersistentHashMap'EMPTY PersistentHashMap'NOT_FOUND PersistentHashMap'create-1m PersistentHashMap'create-1a PersistentHashMap'createWithCheck-1a PersistentHashMap'create-1s PersistentHashMap'createWithCheck-1s PersistentHashMap'create-2 PersistentHashMap'new-4 PersistentHashMap'new-5 PersistentHashMap'hash PersistentHashMap'EMPTY_ITER PersistentHashMap'mask PersistentHashMap'cloneAndSet-3 PersistentHashMap'cloneAndSet-5 PersistentHashMap'removePair PersistentHashMap'createNode-6 PersistentHashMap'createNode-7 PersistentHashMap'bitpos)
(declare TransientHashSet'new)
(declare PersistentHashSet'EMPTY PersistentHashSet'create-1a PersistentHashSet'create-1l PersistentHashSet'create-1s PersistentHashSet'createWithCheck-1a PersistentHashSet'createWithCheck-1l PersistentHashSet'createWithCheck-1s PersistentHashSet'new)
(declare Primordial'invokeStatic)
(declare EmptyList'HASHEQ EmptyList'new EmptyList'hasheq)
(declare PersistentList'creator PersistentList'EMPTY PersistentList'new-1 PersistentList'new-4 PersistentList'create)
(declare QSeq'new-2 QSeq'new-3)
(declare PersistentQueue'EMPTY PersistentQueue'new)
(declare TNode'new)
(declare Black'new)
(declare BlackVal'new)
(declare BlackBranch'new)
(declare BlackBranchVal'new)
(declare Red'new)
(declare RedVal'new)
(declare RedBranch'new)
(declare RedBranchVal'new)
(declare TSeq'new-2 TSeq'new-3 TSeq'new-4 TSeq'create TSeq'push)
(declare NodeIterator'new)
(declare KeyIterator'new)
(declare ValIterator'new)
(declare PersistentTreeMap'EMPTY PersistentTreeMap'create-1m PersistentTreeMap'new-0 PersistentTreeMap'new-1 PersistentTreeMap'new-2 PersistentTreeMap'new-4m PersistentTreeMap'create-1s PersistentTreeMap'create-2 PersistentTreeMap'append PersistentTreeMap'balanceLeftDel PersistentTreeMap'balanceRightDel PersistentTreeMap'leftBalance PersistentTreeMap'rightBalance PersistentTreeMap'new-4c PersistentTreeMap'red PersistentTreeMap'black)
(declare PersistentTreeSet'EMPTY PersistentTreeSet'create-1 PersistentTreeSet'create-2 PersistentTreeSet'new)
(declare VNode'new-2 VNode'new-1)
(declare ChunkedSeq'new-3 ChunkedSeq'new-5 ChunkedSeq'new-4)
(declare TransientVector'new-4 TransientVector'new-1 TransientVector'editableRoot TransientVector'editableTail TransientVector'NOT_FOUND)
(declare PersistentVector'NOEDIT PersistentVector'EMPTY_NODE PersistentVector'EMPTY PersistentVector'TRANSIENT_VECTOR_CONJ PersistentVector'adopt PersistentVector'create-1r PersistentVector'create-1s PersistentVector'create-1l PersistentVector'create-1i PersistentVector'create-1a PersistentVector'new-4 PersistentVector'new-5 PersistentVector'doAssoc PersistentVector'newPath)
(declare ProxyHandler'new)
(declare RangeIterator'new)
(declare Range'CHUNK_SIZE Range'positiveStep Range'negativeStep Range'new-4 Range'new-6 Range'new-7 Range'create-1 Range'create-2 Range'create-3)
(declare Ratio'new)
(declare ReaderConditional'FORM_KW ReaderConditional'SPLICING_KW ReaderConditional'create ReaderConditional'new)
(declare RecordIterator'new)
(declare Reduced'new)
(declare RefTVal'new-3 RefTVal'new-2)
(declare Ref'ids Ref'new-1 Ref'new-2)
(declare Reflector'invokeInstanceMethod Reflector'getCauseOrElse Reflector'throwCauseOrElseException Reflector'noMethodReport Reflector'invokeMatchingMethod Reflector'getAsMethodOfPublicBase Reflector'isMatch Reflector'invokeConstructor Reflector'invokeStaticMethodVariadic Reflector'invokeStaticMethod-3s Reflector'invokeStaticMethod-3c Reflector'getStaticField-2s Reflector'getStaticField-2c Reflector'setStaticField-3s Reflector'setStaticField-3c Reflector'getInstanceField Reflector'setInstanceField Reflector'invokeNoArgInstanceMember-2 Reflector'invokeNoArgInstanceMember-3 Reflector'invokeInstanceMember-2 Reflector'invokeInstanceMember-3o Reflector'invokeInstanceMember-3a Reflector'getField Reflector'getMethods Reflector'boxArg Reflector'boxArgs Reflector'paramArgTypeMatch Reflector'isCongruent Reflector'prepRet)
(declare Repeat'INFINITE Repeat'new-2 Repeat'new-3 Repeat'create-1 Repeat'create-2)
(declare RestFn'ontoArrayPrepend RestFn'findKey)
(declare RT'T RT'F RT'LOADER_SUFFIX RT'DEFAULT_IMPORTS RT'UTF8 RT'readTrueFalseUnknown RT'CLOIURE_NS RT'OUT RT'IN RT'ERR RT'TAG_KEY RT'CONST_KEY RT'AGENT RT'readeval RT'READEVAL RT'DATA_READERS RT'DEFAULT_DATA_READER_FN RT'DEFAULT_DATA_READERS RT'SUPPRESS_READ RT'ASSERT RT'MATH_CONTEXT RT'LINE_KEY RT'COLUMN_KEY RT'FILE_KEY RT'DECLARED_KEY RT'DOC_KEY RT'USE_CONTEXT_CLASSLOADER RT'UNCHECKED_MATH RT'LOAD_FILE RT'IN_NAMESPACE RT'NAMESPACE RT'IDENTICAL RT'CMD_LINE_ARGS RT'CURRENT_NS RT'FLUSH_ON_NEWLINE RT'PRINT_META RT'PRINT_READABLY RT'PRINT_DUP RT'WARN_ON_REFLECTION RT'ALLOW_UNRESOLVED_VARS RT'READER_RESOLVER RT'IN_NS_VAR RT'NS_VAR RT'FN_LOADER_VAR RT'PRINT_INITIALIZED RT'PR_ON RT'inNamespace RT'bootNamespace RT'processCommandLine RT'errPrintWriter RT'EMPTY_ARRAY RT'DEFAULT_COMPARATOR RT'ID RT'addURL RT'CHECK_SPEC_ASSERTS RT'INSTRUMENT_MACROS RT'CHECK_SPECS RT'keyword RT'var-2 RT'var-3 RT'loadResourceScript-1 RT'maybeLoadResourceScript RT'loadResourceScript-2s RT'loadResourceScript-2c RT'loadResourceScript-3 RT'lastModified RT'compile RT'load-1 RT'load-2 RT'doInit RT'nextID RT'loadLibrary RT'CHUNK_SIZE RT'chunkIteratorSeq RT'seq RT'seqFrom RT'canSeq RT'iter RT'seqOrElse RT'keys RT'vals RT'meta RT'count RT'countFrom RT'conj RT'cons RT'first RT'second RT'third RT'fourth RT'next RT'more RT'peek RT'pop RT'get-2 RT'getFrom-2 RT'get-3 RT'getFrom-3 RT'assoc RT'contains RT'find RT'findKey RT'dissoc RT'nth-2 RT'nthFrom-2 RT'nth-3 RT'nthFrom-3 RT'assocN RT'hasTag RT'box-1o RT'box-1c RT'box-1z RT'box-1Z RT'box-1b RT'box-1s RT'box-1i RT'box-1l RT'box-1f RT'box-1d RT'charCast-1o RT'charCast-1b RT'charCast-1s RT'charCast-1c RT'charCast-1i RT'charCast-1l RT'charCast-1f RT'charCast-1d RT'booleanCast-1o RT'booleanCast-1b RT'byteCast-1o RT'byteCast-1b RT'byteCast-1s RT'byteCast-1i RT'byteCast-1l RT'byteCast-1f RT'byteCast-1d RT'shortCast-1o RT'shortCast-1b RT'shortCast-1s RT'shortCast-1i RT'shortCast-1l RT'shortCast-1f RT'shortCast-1d RT'intCast-1o RT'intCast-1c RT'intCast-1b RT'intCast-1s RT'intCast-1i RT'intCast-1f RT'intCast-1l RT'intCast-1d RT'longCast-1o RT'longCast-1b RT'longCast-1s RT'longCast-1i RT'longCast-1f RT'longCast-1l RT'longCast-1d RT'floatCast-1o RT'floatCast-1b RT'floatCast-1s RT'floatCast-1i RT'floatCast-1f RT'floatCast-1l RT'floatCast-1d RT'doubleCast-1o RT'doubleCast-1b RT'doubleCast-1s RT'doubleCast-1i RT'doubleCast-1f RT'doubleCast-1l RT'doubleCast-1d RT'uncheckedByteCast-1o RT'uncheckedByteCast-1b RT'uncheckedByteCast-1s RT'uncheckedByteCast-1i RT'uncheckedByteCast-1l RT'uncheckedByteCast-1f RT'uncheckedByteCast-1d RT'uncheckedShortCast-1o RT'uncheckedShortCast-1b RT'uncheckedShortCast-1s RT'uncheckedShortCast-1i RT'uncheckedShortCast-1l RT'uncheckedShortCast-1f RT'uncheckedShortCast-1d RT'uncheckedCharCast-1o RT'uncheckedCharCast-1b RT'uncheckedCharCast-1s RT'uncheckedCharCast-1c RT'uncheckedCharCast-1i RT'uncheckedCharCast-1l RT'uncheckedCharCast-1f RT'uncheckedCharCast-1d RT'uncheckedIntCast-1o RT'uncheckedIntCast-1b RT'uncheckedIntCast-1s RT'uncheckedIntCast-1c RT'uncheckedIntCast-1i RT'uncheckedIntCast-1l RT'uncheckedIntCast-1f RT'uncheckedIntCast-1d RT'uncheckedLongCast-1o RT'uncheckedLongCast-1b RT'uncheckedLongCast-1s RT'uncheckedLongCast-1i RT'uncheckedLongCast-1l RT'uncheckedLongCast-1f RT'uncheckedLongCast-1d RT'uncheckedFloatCast-1o RT'uncheckedFloatCast-1b RT'uncheckedFloatCast-1s RT'uncheckedFloatCast-1i RT'uncheckedFloatCast-1l RT'uncheckedFloatCast-1f RT'uncheckedFloatCast-1d RT'uncheckedDoubleCast-1o RT'uncheckedDoubleCast-1b RT'uncheckedDoubleCast-1s RT'uncheckedDoubleCast-1i RT'uncheckedDoubleCast-1l RT'uncheckedDoubleCast-1f RT'uncheckedDoubleCast-1d RT'map RT'mapUniqueKeys RT'set RT'vector RT'subvec RT'list-0 RT'list-1 RT'list-2 RT'list-3 RT'list-4 RT'list-5 RT'listStar-2 RT'listStar-3 RT'listStar-4 RT'listStar-5 RT'listStar-6 RT'arrayToList RT'object_array RT'toArray RT'seqToArray RT'seqToPassedArray RT'seqToTypedArray-1 RT'seqToTypedArray-2 RT'length RT'boundedLength RT'readRet RT'readChar RT'peekChar RT'getLineNumber RT'getColumnNumber RT'getLineNumberingReader RT'isLineNumberingReader RT'isReduced RT'resolveClassNameInContext RT'suppressRead RT'printString RT'readString-1 RT'readString-2 RT'print RT'printInnerSeq RT'formatAesthetic RT'formatStandard RT'format RT'doFormat RT'setValues RT'makeClassLoader RT'baseLoader RT'resourceAsStream RT'getResource RT'classForName-3 RT'classForName-1 RT'classForNameNonLoading RT'loadClassForName RT'aget-2f RT'aset-3f RT'alength-1f RT'aclone-1f RT'aget-2d RT'aset-3d RT'alength-1d RT'aclone-1d RT'aget-2i RT'aset-3i RT'alength-1i RT'aclone-1i RT'aget-2l RT'aset-3l RT'alength-1l RT'aclone-1l RT'aget-2c RT'aset-3c RT'alength-1c RT'aclone-1c RT'aget-2b RT'aset-3b RT'alength-1b RT'aclone-1b RT'aget-2s RT'aset-3s RT'alength-1s RT'aclone-1s RT'aget-2z RT'aset-3z RT'alength-1z RT'aclone-1z RT'aget-2o RT'aset-3o RT'alength-1o RT'aclone-1o)
(declare SeqEnumeration'new)
(declare SeqIterator'START SeqIterator'new)
(declare StringSeq'create StringSeq'new)
(declare Symbol'create-2 Symbol'create-1 Symbol'intern-2 Symbol'intern-1 Symbol'new-2 Symbol'new-3)
(declare TaggedLiteral'TAG_KW TaggedLiteral'FORM_KW TaggedLiteral'create TaggedLiteral'new)
(declare TransactionalHashMap'new-0 TransactionalHashMap'new-1i TransactionalHashMap'new-1m)
(declare SingleBuffer'new)
(declare ManyBuffer'new)
(declare MultiIterator'new)
(declare TransformerIterator'EMPTY TransformerIterator'NONE TransformerIterator'new TransformerIterator'create TransformerIterator'createMulti)
(declare Tuple'MAX_SIZE Tuple'create-0 Tuple'create-1 Tuple'create-2 Tuple'create-3 Tuple'create-4 Tuple'create-5 Tuple'create-6)
(declare Util'equiv-2oo Util'equivNull Util'equivEquals Util'equivNumber Util'equivColl Util'equivPred Util'equiv-2ll Util'equiv-2ol Util'equiv-2lo Util'equiv-2dd Util'equiv-2od Util'equiv-2do Util'equiv-2bb Util'equiv-2ob Util'equiv-2bo Util'equiv-2cc Util'pcequiv Util'equals Util'identical Util'classOf Util'compare Util'hash Util'hasheq Util'dohasheq Util'hashCombine Util'isPrimitive Util'isInteger Util'ret1 Util'clearCache Util'runtimeException-1 Util'runtimeException-2 Util'sneakyThrow Util'sneakyThrow0 Util'loadWithClass)
(declare TBox'new)
(declare Unbound'new)
(declare Frame'TOP Frame'new)
(declare Var'dvals Var'rev Var'privateKey Var'privateMeta Var'macroKey Var'nameKey Var'nsKey Var'getThreadBindingFrame Var'cloneThreadBindingFrame Var'resetThreadBindingFrame Var'intern-3 Var'intern-4 Var'find Var'intern-2s Var'internPrivate Var'intern-2n Var'create-0 Var'create-1 Var'new-2 Var'new-3 Var'pushThreadBindings Var'popThreadBindings Var'getThreadBindings Var'assoc Var'dissoc)
(declare Volatile'new)
(declare main'CLOIURE_MAIN main'REQUIRE main'MAIN)

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_protected
    (defn #_"AFn" AFn'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"AFn" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"AFn" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
        (.throwArity this, 0)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1]
        (.throwArity this, 1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (.throwArity this, 2)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (.throwArity this, 3)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (.throwArity this, 4)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (.throwArity this, 5)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (.throwArity this, 6)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (.throwArity this, 7)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (.throwArity this, 8)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (.throwArity this, 9)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (.throwArity this, 10)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (.throwArity this, 11)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (.throwArity this, 12)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (.throwArity this, 13)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (.throwArity this, 14)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (.throwArity this, 15)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (.throwArity this, 16)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (.throwArity this, 17)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (.throwArity this, 18)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (.throwArity this, 19)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (.throwArity this, 20)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (.throwArity this, 21)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"AFn" this, #_"ISeq" ___arglist]
        (ß AFn'applyToHelper(this, Util'ret1(___arglist, (§ ass ___arglist nil))))
    )

    (defn #_"Object" AFn'applyToHelper [#_"IFn" ___ifn, #_"ISeq" ___arglist]
        (§ switch (RT'boundedLength ___arglist, 20)
            (§ case 0)
            (do
                (§ ass ___arglist nil)
                (.invoke ___ifn)
            )
            (§ case 1)
            (do
                (ß ___ifn.invoke(Util'ret1((first ___arglist), (§ ass ___arglist nil))))
            )
            (§ case 2)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 3)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 4)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 5)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 6)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 7)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 8)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 9)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 10)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 11)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 12)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 13)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 14)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 15)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 16)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 17)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 18)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 19)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 20)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ default )
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        RT'seqToArray(Util'ret1((next ___arglist), (§ ass ___arglist nil)))))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"AFn" this, #_"int" ___n]
        (let [#_"String" ___name (ß getClass().getSimpleName())]
            (throw (ß ArityException'new-2(___n, Compiler'demunge(___name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (defn- #_"AFunction" AFunction'init []
        (hash-map
            #_volatile
            #_"MethodImplCache" :__methodImplCache nil
        )
    )

    #_protected
    (defn #_"AFunction" AFunction'new []
        (merge (AFn'new) (AFunction'init))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"AFunction" this]
        nil
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"AFunction" this, #_"IPersistentMap" ___meta]
        (§ reify RestFn()
            #_protected
            #_method
            (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___args]
                (.applyTo (§ this AFunction), (cast' ISeq ___args))
            )

            #_method
            (§ defn #_"IPersistentMap" (§ method meta) [#_"RestFn" this]
                ___meta
            )

            #_method
            (§ defn #_"IObj" (§ method withMeta) [#_"RestFn" this, #_"IPersistentMap" ___meta]
                (.withMeta (§ this AFunction), ___meta)
            )

            #_method
            (§ defn #_"int" (§ method getRequiredArity) [#_"RestFn" this]
                0
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method compare) [#_"AFunction" this, #_"Object" ___o1, #_"Object" ___o2]
        (let [#_"Object" ___o (.invoke this, ___o1, ___o2)]
            (when (instance? Boolean ___o)
                (when (RT'booleanCast-1o ___o)
                    (§ return -1)
                )
                (§ return (if (RT'booleanCast-1o (.invoke this, ___o2, ___o1)) 1 0))
            )

            (let [#_"Number" ___n (cast Number ___o)]
                (.intValue ___n)
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns ActionQueue
    (§ def #_"ActionQueue" ActionQueue'EMPTY (ActionQueue'new PersistentQueue'EMPTY, nil))

    (defn- #_"ActionQueue" ActionQueue'init []
        (hash-map
            #_"IPersistentStack" :q nil
            #_"Throwable" :error nil ;; non-null indicates fail state
        )
    )

    (defn #_"ActionQueue" ActionQueue'new [#_"IPersistentStack" ___q, #_"Throwable" ___error]
        (let [this (ActionQueue'init)]
            (§ ass (:q this) ___q)
            (§ ass (:error this) ___error)
            this
        )
    )
)

(class-ns AgentAction (§ implements Runnable)
    (defn- #_"AgentAction" AgentAction'init []
        (hash-map
            #_"Agent" :agent nil
            #_"IFn" :fn nil
            #_"ISeq" :args nil
            #_"Executor" :exec nil
        )
    )

    (defn #_"AgentAction" AgentAction'new [#_"Agent" ___agent, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [this (AgentAction'init)]
            (§ ass (:agent this) ___agent)
            (§ ass (:args this) ___args)
            (§ ass (:fn this) ___fn)
            (§ ass (:exec this) ___exec)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method execute) [#_"AgentAction" this]
        (try
            (.execute (:exec this), this)
            (catch Throwable ___error
                (when (some? (:errorHandler (:agent this)))
                    (try
                        (ß (:errorHandler (:agent this)).invoke((:agent this), ___error))
                        (catch Throwable ___e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AgentAction'doRun [#_"AgentAction" ___action]
        (try
            (.set Agent'nested, PersistentVector'EMPTY)

            (let [#_"Throwable" ___error nil]
                (try
                    (let [#_"Object" ___oldval (:state (:agent ___action))]
                        (let [#_"Object" ___newval (ß (:fn ___action).applyTo(RT'cons((:state (:agent ___action)), (:args ___action))))]
                            (.setState (:agent ___action), ___newval)
                            (.notifyWatches (:agent ___action), ___oldval, ___newval)
                        )
                    )
                    (catch Throwable ___e
                        (§ ass ___error ___e)
                    )
                )

                (if (nil? ___error)
                    (do
                        (Agent'releasePendingSends)
                    )
                    (do
                        (.set Agent'nested, nil) ;; allow errorHandler to send
                        (when (some? (:errorHandler (:agent ___action)))
                            (try
                                (ß (:errorHandler (:agent ___action)).invoke((:agent ___action), ___error))
                                (catch Throwable ___e
                                    ;; ignore errorHandler errors
                                )
                            )
                        )
                        (when (ß (:errorMode (:agent ___action)) == Agent'CONTINUE)
                            (§ ass ___error nil)
                        )
                    )
                )

                (let [#_"boolean" ___popped false]
                    (let [#_"ActionQueue" ___next nil]
                        (while (not ___popped)
                            (let [#_"ActionQueue" ___prior (.get (:aq (:agent ___action)))]
                                (§ ass ___next (ß ActionQueue'new((:q ___prior).pop(), ___error)))
                                (§ ass ___popped (ß (:aq (:agent ___action)).compareAndSet(___prior, ___next)))
                            )
                        )

                        (when (and (nil? ___error) (pos? (.count (:q ___next))))
                            (.execute (cast' AgentAction (.peek (:q ___next))))
                        )
                    )
                )
            )
            (finally
                (.set Agent'nested, nil)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"AgentAction" this]
        (AgentAction'doRun this)
        nil
    )
)

(class-ns Agent (§ extends ARef)
    (§ def #_"Keyword" Agent'CONTINUE (Keyword'intern-2 nil, "continue"))
    (§ def #_"Keyword" Agent'FAIL (Keyword'intern-2 nil, "fail"))

    (def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" ___format, #_"AtomicLong" ___threadPoolCounter]
        (§ reify ThreadFactory()
            #_method
            (§ defn #_"Thread" (§ method newThread) [#_"ThreadFactory" this, #_"Runnable" ___runnable]
                (let [#_"Thread" ___thread (Thread. ___runnable)]
                    (ß ___thread.setName(String/format(___format, (object-array [ (.getAndIncrement ___threadPoolCounter) ]))))
                    ___thread
                )
            )
        )
    )

    #_volatile
    (def #_"ExecutorService" Agent'pooledExecutor (ß Executors/newFixedThreadPool(2 + Runtime/getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))))

    #_volatile
    (def #_"ExecutorService" Agent'soloExecutor (ß Executors/newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))))

    (def #_"ThreadLocal<IPersistentVector>" Agent'nested (ThreadLocal.))

    (defn #_"void" Agent'shutdown []
        (.shutdown Agent'soloExecutor)
        (.shutdown Agent'pooledExecutor)
        nil
    )

    (defn- #_"Agent" Agent'init []
        (hash-map
            #_volatile
            #_"Object" :state nil
            #_"AtomicReference<ActionQueue>" :aq (AtomicReference. ActionQueue'EMPTY)

            #_volatile
            #_"Keyword" :errorMode Agent'CONTINUE
            #_volatile
            #_"IFn" :errorHandler nil
        )
    )

    (defn #_"Agent" Agent'new-1 [#_"Object" ___state]
        (Agent'new-2 ___state, nil)
    )

    (defn #_"Agent" Agent'new-2 [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Agent'init))]
            (.setState this, ___state)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method setState) [#_"Agent" this, #_"Object" ___newState]
        (.validate this, ___newState)
        (let [#_"boolean" ___ret (ß (:state this) != ___newState)]
            (§ ass (:state this) ___newState)
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Agent" this]
        (:state this)
    )

    #_method
    (§ defn #_"Throwable" (§ method getError) [#_"Agent" this]
        (:error (.get (:aq this)))
    )

    #_method
    (§ defn #_"void" (§ method setErrorMode) [#_"Agent" this, #_"Keyword" ___k]
        (§ ass (:errorMode this) ___k)
        nil
    )

    #_method
    (§ defn #_"Keyword" (§ method getErrorMode) [#_"Agent" this]
        (:errorMode this)
    )

    #_method
    (§ defn #_"void" (§ method setErrorHandler) [#_"Agent" this, #_"IFn" ___f]
        (§ ass (:errorHandler this) ___f)
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method getErrorHandler) [#_"Agent" this]
        (:errorHandler this)
    )

    #_method
    (§ defn #_"Object" (§ method restart) [#_"Agent" this, #_"Object" ___newState, #_"boolean" ___clearActions]
        (§ sync this
            (when (nil? (.getError this))
                (throw (Util'runtimeException-1 "Agent does not need a restart"))
            )
            (.validate this, ___newState)
            (§ ass (:state this) ___newState)

            (if ___clearActions
                (do
                    (.set (:aq this), ActionQueue'EMPTY)
                )
                (do
                    (let [#_"boolean" ___restarted false]
                        (let [#_"ActionQueue" ___prior nil]
                            (while (not ___restarted)
                                (§ ass ___prior (.get (:aq this)))
                                (§ ass ___restarted (ß (:aq this).compareAndSet(___prior, ActionQueue'new((:q ___prior), nil))))
                            )

                            (when (pos? (.count (:q ___prior)))
                                (.execute (cast' AgentAction (.peek (:q ___prior))))
                            )
                        )
                    )
                )
            )

            ___newState
        )
    )

    #_method
    (§ defn #_"Object" (§ method dispatch) [#_"Agent" this, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [#_"Throwable" ___error (.getError this)]
            (when (some? ___error)
                (throw (Util'runtimeException-2 "Agent is failed, needs restart", ___error))
            )
            (let [#_"AgentAction" ___action (AgentAction'new this, ___fn, ___args, ___exec)]
                (dispatchAction ___action)

                this
            )
        )
    )

    (defn #_"void" Agent'dispatchAction [#_"AgentAction" ___action]
        (let [#_"LockingTransaction" ___trans (LockingTransaction'getRunning)]
            (cond (some? ___trans)
                (do
                    (.enqueue ___trans, ___action)
                )
                (some? (.get Agent'nested))
                (do
                    (ß Agent'nested.set((.get Agent'nested).cons(___action)))
                )
                :else
                (do
                    (.enqueue (:agent ___action), ___action)
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method enqueue) [#_"Agent" this, #_"AgentAction" ___action]
        (let [#_"boolean" ___queued false]
            (let [#_"ActionQueue" ___prior nil]
                (while (not ___queued)
                    (§ ass ___prior (.get (:aq this)))
                    (§ ass ___queued (ß (:aq this).compareAndSet(___prior, ActionQueue'new((cast' IPersistentStack (.cons (:q ___prior), ___action)), (:error ___prior)))))
                )

                (when (and (zero? (.count (:q ___prior))) (nil? (:error ___prior)))
                    (.execute ___action)
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method getQueueCount) [#_"Agent" this]
        (.count (:q (.get (:aq this))))
    )

    (defn #_"int" Agent'releasePendingSends []
        (let [#_"IPersistentVector" ___sends (.get Agent'nested)]
            (when (nil? ___sends)
                (§ return 0)
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___sends)) [(inc ___i)]
                (let [#_"AgentAction" ___a (cast' AgentAction (.valAt ___sends, ___i))]
                    (.enqueue (:agent ___a), ___a)
                )
            )
            (.set Agent'nested, PersistentVector'EMPTY)
            (count ___sends)
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_protected
    (defn #_"AMapEntry" AMapEntry'new []
        (APersistentVector'new)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"AMapEntry" this, #_"int" ___i]
        (cond (zero? ___i)
            (do
                (.key this)
            )
            (= ___i 1)
            (do
                (.val this)
            )
            :else
            (do
                (throw (IndexOutOfBoundsException.))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" (§ method asVector) [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (.key this), (.val this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assocN) [#_"AMapEntry" this, #_"int" ___i, #_"Object" ___val]
        (ß (.asVector this).assocN(___i, ___val))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"AMapEntry" this]
        2
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"AMapEntry" this]
        (.seq (.asVector this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method cons) [#_"AMapEntry" this, #_"Object" ___o]
        (ß (.asVector this).cons(___o))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"AMapEntry" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" (§ method pop) [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (.key this))
    )

    #_method
    (§ defn #_"Object" (§ method setValue) [#_"AMapEntry" this, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

(class-ns KeySeq (§ extends ASeq)
    (defn #_"KeySeq" KeySeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (KeySeq'new-2 ___seq, nil)
    )

    (defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (.seq ___map)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (KeySeq'new-2 ___seq, ___map)
        )
    )

    (defn- #_"KeySeq" KeySeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"KeySeq" KeySeq'new-2 [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new) (KeySeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    (defn- #_"KeySeq" KeySeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new ___meta) (KeySeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"KeySeq" this]
        (.getKey (cast Map$Entry (.first (:seq this))))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"KeySeq" this]
        (ß this.create((:seq this).next()))
    )

    #_method
    (§ defn #_"KeySeq" (§ method withMeta) [#_"KeySeq" this, #_"IPersistentMap" ___meta]
        (KeySeq'new-3 ___meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"KeySeq" this]
        (when (nil? (:iterable this))
            (§ return (.iterator super))
        )

        (when (§ instance? IMapIterable (:iterable this))
            (§ return (.keyIterator (cast' IMapIterable (:iterable this))))
        )

        (let [#_"Iterator" ___mapIter (.iterator (:iterable this))]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (.hasNext ___mapIter)
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (.getKey (cast Map$Entry (.next ___mapIter)))
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

(class-ns ValSeq (§ extends ASeq)
    (defn #_"ValSeq" ValSeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (ValSeq'new-2 ___seq, nil)
    )

    (defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (.seq ___map)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ValSeq'new-2 ___seq, ___map)
        )
    )

    (defn- #_"ValSeq" ValSeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"ValSeq" ValSeq'new-2 [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new) (ValSeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    (defn- #_"ValSeq" ValSeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new ___meta) (ValSeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ValSeq" this]
        (.getValue (cast Map$Entry (.first (:seq this))))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ValSeq" this]
        (ß this.create((:seq this).next()))
    )

    #_method
    (§ defn #_"ValSeq" (§ method withMeta) [#_"ValSeq" this, #_"IPersistentMap" ___meta]
        (ValSeq'new-3 ___meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ValSeq" this]
        (when (nil? (:iterable this))
            (§ return (.iterator super))
        )

        (when (§ instance? IMapIterable (:iterable this))
            (§ return (.valIterator (cast' IMapIterable (:iterable this))))
        )

        (let [#_"Iterator" ___mapIter (.iterator (:iterable this))]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (.hasNext ___mapIter)
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (.getValue (cast Map$Entry (.next ___mapIter)))
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (defn- #_"APersistentMap" APersistentMap'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentMap" APersistentMap'new []
        (merge (AFn'new) (APersistentMap'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentMap" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method cons) [#_"APersistentMap" this, #_"Object" ___o]
        (cond (instance? Map$Entry ___o)
            (do
                (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                    (§ return (ß this.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (§ instance? IPersistentVector ___o)
            (do
                (let [#_"IPersistentVector" ___v (cast' IPersistentVector ___o)]
                    (when (ß (count ___v) != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß this.assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ___ret this]
            (loop-when-recur [#_"ISeq" ___es (RT'seq ___o)] (some? ___es) [(next ___es)]
                (let [#_"Map$Entry" ___e (cast Map$Entry (first ___es))]
                    (§ ass ___ret (.assoc ___ret, (.getKey ___e), (.getValue ___e)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentMap" this, #_"Object" ___obj]
        (mapEquals this, ___obj)
    )

    (defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" ___m1, #_"Object" ___obj]
        (when (= ___m1 ___obj)
            (§ return true)
        )
        (when (not (instance? Map ___obj))
            (§ return false)
        )
        (let [#_"Map" ___m (cast Map ___obj)]
            (when (ß (.size ___m) != (count ___m1))
                (§ return false)
            )

            (loop-when-recur [#_"ISeq" ___s (.seq ___m1)] (some? ___s) [(next ___s)]
                (let [#_"Map$Entry" ___e (cast Map$Entry (first ___s))]
                    (let [#_"boolean" ___found (.containsKey ___m, (.getKey ___e))]
                        (when (or (not ___found) (not (Util'equals (.getValue ___e), (.get ___m, (.getKey ___e)))))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentMap" this, #_"Object" ___obj]
        (when (not (instance? Map ___obj))
            (§ return false)
        )
        (when (and (§ instance? IPersistentMap ___obj) (not (§ instance? MapEquivalence ___obj)))
            (§ return false)
        )

        (let [#_"Map" ___m (cast Map ___obj)]
            (when (ß (.size ___m) != (.size this))
                (§ return false)
            )

            (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                (let [#_"Map$Entry" ___e (cast Map$Entry (first ___s))]
                    (let [#_"boolean" ___found (.containsKey ___m, (.getKey ___e))]
                        (when (or (not ___found) (not (Util'equiv-2oo (.getValue ___e), (.get ___m, (.getKey ___e)))))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentMap" this]
        (let [#_"int" ___cached (:_hash this)]
            (when (zero? ___cached)
                (§ ass (:_hash this) (§ ass ___cached (mapHash this)))
            )
            ___cached
        )
    )

    (defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" ___m]
        (let [#_"int" ___hash 0]
            (loop-when-recur [#_"ISeq" ___s (.seq ___m)] (some? ___s) [(next ___s)]
                (let [#_"Map$Entry" ___e (cast Map$Entry (first ___s))]
                    (§ ass ___hash (+ ___hash (ß (if (nil? (.getKey ___e)) 0 (.hashCode (.getKey ___e))) :xor (if (nil? (.getValue ___e)) 0 (.hashCode (.getValue ___e))))))
                )
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentMap" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (zero? ___cached)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashUnordered this)))
            )
            ___cached
        )
    )

    (defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" ___m]
        (Murmur3'hashUnordered ___m)
    )

    (def #_"IFn" APersistentMap'MAKE_ENTRY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                (MapEntry'create ___key, ___val)
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_KEY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                ___key
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_VAL
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                ___val
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentMap" this, #_"Object" ___arg1]
        (.valAt this, ___arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (.valAt this, ___arg1, ___notFound)
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsValue) [#_"APersistentMap" this, #_"Object" ___value]
        (ß (.values this).contains(___value))
    )

    #_method
    (§ defn #_"Set" (§ method entrySet) [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet" this]
                (.iterator (§ this APersistentMap))
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractSet" this]
                (count this)
            )

            #_method
            (§ defn #_"int" (§ method hashCode) [#_"AbstractSet" this]
                (.hashCode (§ this APersistentMap))
            )

            #_method
            (§ defn #_"boolean" (§ method contains) [#_"AbstractSet" this, #_"Object" ___o]
                (when (§ instance? Entry ___o)
                    (let [#_"Entry" ___e (cast' Entry ___o)]
                        (let [#_"Entry" ___found (.entryAt this, (.getKey ___e))]
                            (when (and (some? ___found) (Util'equals (.getValue ___found), (.getValue ___e)))
                                (§ return true)
                            )
                        )
                    )
                )
                false
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentMap" this, #_"Object" ___key]
        (.valAt this, ___key)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentMap" this]
        (zero? (count this))
    )

    #_method
    (§ defn #_"Set" (§ method keySet) [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet" this]
                (let [#_"Iterator" ___mi (.iterator (§ this APersistentMap))]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext ___mi)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [#_"Entry" ___e (cast' Entry (next ___mi))]
                                (.getKey ___e)
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractSet" this]
                (count this)
            )

            #_method
            (§ defn #_"boolean" (§ method contains) [#_"AbstractSet" this, #_"Object" ___o]
                (.containsKey (§ this APersistentMap), ___o)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method put) [#_"APersistentMap" this, #_"Object" ___key, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method putAll) [#_"APersistentMap" this, #_"Map" ___t]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"APersistentMap" this, #_"Object" ___key]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentMap" this]
        (count this)
    )

    #_method
    (§ defn #_"Collection" (§ method values) [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractCollection" this]
                (let [#_"Iterator" ___mi (.iterator (§ this APersistentMap))]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext ___mi)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [#_"Entry" ___e (cast' Entry (next ___mi))]
                                (.getValue ___e)
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractCollection" this]
                (count this)
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (defn- #_"APersistentSet" APersistentSet'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
            #_"IPersistentMap" :impl nil
        )
    )

    #_protected
    (defn #_"APersistentSet" APersistentSet'new [#_"IPersistentMap" ___impl]
        (let [this (merge (AFn'new) (APersistentSet'init))]
            (§ ass (:impl this) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentSet" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"APersistentSet" this, #_"Object" ___key]
        (.containsKey (:impl this), ___key)
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentSet" this, #_"Object" ___key]
        (.valAt (:impl this), ___key)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"APersistentSet" this]
        (count (:impl this))
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"APersistentSet" this]
        (RT'keys (:impl this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentSet" this, #_"Object" ___arg1]
        (.get this, ___arg1)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentSet" this, #_"Object" ___obj]
        (APersistentSet'setEquals this, ___obj)
    )

    (defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" ___s1, #_"Object" ___obj]
        (when (= ___s1 ___obj)
            (§ return true)
        )
        (when (not (instance? Set ___obj))
            (§ return false)
        )
        (let [#_"Set" ___m (cast Set ___obj)]
            (when (ß (.size ___m) != (count ___s1))
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (not (.contains ___s1, ___aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentSet" this, #_"Object" ___obj]
        (when (not (instance? Set ___obj))
            (§ return false)
        )

        (let [#_"Set" ___m (cast Set ___obj)]
            (when (ß (.size ___m) != (.size this))
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (not (.contains this, ___aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentSet" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (zero? ___hash)
                (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                    (let [#_"Object" ___e (first ___s)]
                        (§ ass ___hash (ß ___hash + Util'hash(___e)))
                    )
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentSet" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (zero? ___cached)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashUnordered this)))
            )
            ___cached
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentSet" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (.contains this, ___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentSet" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentSet" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentSet" this]
        (zero? (count this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"APersistentSet" this]
        (if (§ instance? IMapIterable (:impl this))
            (do
                (.keyIterator (cast' IMapIterable (:impl this)))
            )
            (do
                (§ reify Iterator()
                    (§ init
                        (hash-map
                            #_"Iterator" :iter (.iterator (:impl this))
                        )
                    )

                    #_method
                    (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                        (.hasNext (:iter this))
                    )

                    #_method
                    (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                        (.key (cast' IMapEntry (.next (:iter this))))
                    )

                    #_method
                    (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

(class-ns VSeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"VSeq" VSeq'init []
        (hash-map
            ;; todo - something more efficient
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"VSeq" VSeq'new-2 [#_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new) (VSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"VSeq" VSeq'new-3 [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (VSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"VSeq" this]
        (.nth (:v this), (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"VSeq" this]
        (when (ß (:i this) + 1 < (:v this).count())
            (§ return (ß VSeq'new-2((:v this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"VSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"VSeq" this]
        (ß (:v this).count() - (:i this))
    )

    #_method
    (§ defn #_"VSeq" (§ method withMeta) [#_"VSeq" this, #_"IPersistentMap" ___meta]
        (VSeq'new-3 ___meta, (:v this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"VSeq" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (.nth (:v this), (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:v this).count()) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:v this).nth(___x))))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"VSeq" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:v this).nth((:i this))))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:v this).count()) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:v this).nth(___x))))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )
)

(class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
    (defn- #_"RSeq" RSeq'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"RSeq" RSeq'new-2 [#_"IPersistentVector" ___vector, #_"int" ___i]
        (let [this (merge (ASeq'new) (RSeq'init))]
            (§ ass (:v this) ___vector)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"RSeq" RSeq'new-3 [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (RSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"RSeq" this]
        (.nth (:v this), (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"RSeq" this]
        (when (> (:i this) 0)
            (§ return (ß RSeq'new-2((:v this), (:i this) - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"RSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"RSeq" this]
        (+ (:i this) 1)
    )

    #_method
    (§ defn #_"RSeq" (§ method withMeta) [#_"RSeq" this, #_"IPersistentMap" ___meta]
        (RSeq'new-3 ___meta, (:v this), (:i this))
    )
)

(class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
    (defn- #_"SubVector" SubVector'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :start 0
            #_"int" :end 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"SubVector" SubVector'new [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (let [this (merge (APersistentVector'new) (SubVector'init))]
            (§ ass (:_meta this) ___meta)

            (when (§ instance? SubVector ___v)
                (let [#_"SubVector" ___sv (cast' SubVector ___v)]
                    (§ ass ___start (ß ___start + (:start ___sv)))
                    (§ ass ___end (ß ___end + (:start ___sv)))
                    (§ ass ___v (:v ___sv))
                )
            )
            (§ ass (:v this) ___v)
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"SubVector" this]
        (when (§ instance? APersistentVector (:v this))
            (§ return (ß (cast' APersistentVector (:v this)).rangedIterator((:start this), (:end this))))
        )
        (.iterator super)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"SubVector" this, #_"int" ___i]
        (when (or (neg? ___i) (<= (:end this) (+ (:start this) ___i)))
            (throw (IndexOutOfBoundsException.))
        )
        (ß (:v this).nth((:start this) + ___i))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assocN) [#_"SubVector" this, #_"int" ___i, #_"Object" ___val]
        (cond (ß (:start this) + ___i > (:end this))
            (do
                (throw (IndexOutOfBoundsException.))
            )
            (ß (:start this) + ___i == (:end this))
            (do
                (§ return (.cons this, ___val))
            )
        )
        (ß SubVector'new((:_meta this), (:v this).assocN((:start this) + ___i, ___val), (:start this), (:end this)))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"SubVector" this]
        (- (:end this) (:start this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method cons) [#_"SubVector" this, #_"Object" ___o]
        (ß SubVector'new((:_meta this), (:v this).assocN((:end this), ___o), (:start this), (:end this) + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"SubVector" this]
        (.withMeta PersistentVector'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"IPersistentStack" (§ method pop) [#_"SubVector" this]
        (when (ß (:end this) - 1 == (:start this))
            (§ return PersistentVector'EMPTY)
        )
        (ß SubVector'new((:_meta this), (:v this), (:start this), (:end this) - 1))
    )

    #_method
    (§ defn #_"SubVector" (§ method withMeta) [#_"SubVector" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (SubVector'new ___meta, (:v this), (:start this), (:end this))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"SubVector" this]
        (:_meta this)
    )
)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (defn- #_"APersistentVector" APersistentVector'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentVector" APersistentVector'new []
        (merge (AFn'new) (APersistentVector'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentVector" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"APersistentVector" this]
        (when (pos? (count this))
            (§ return (VSeq'new-2 this, 0))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"APersistentVector" this]
        (when (pos? (count this))
            (§ return (ß RSeq'new-2(this, (count this) - 1)))
        )
        nil
    )

    (defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (§ instance? IPersistentVector ___obj)
            (do
                (let [#_"IPersistentVector" ___ov (cast' IPersistentVector ___obj)]
                    (when (ß (count ___ov) != (count ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___v)) [(inc ___i)]
                        (when (not (ß Util'equals(___v.nth(___i), ___ov.nth(___i))))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (instance? List ___obj)
            (do
                (let [#_"Collection" ___ma (cast Collection ___obj)]
                    (when (or (ß (.size ___ma) != (count ___v)) (ß (.hashCode ___ma) != (.hashCode ___v)))
                        (§ return false)
                    )
                    (loop-when-recur [#_"Iterator" ___i1 (.iterator (cast List ___v)) #_"Iterator" ___i2 (.iterator ___ma)] (.hasNext ___i1) [___i1 ___i2]
                        (when (not (Util'equals (next ___i1), (next ___i2)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (not (§ instance? Sequential ___obj))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (RT'seq ___obj)]
                    (loop-when-recur [#_"int" ___i 0 ___ms ___ms] (ß ___i < (count ___v)) [(inc ___i) (next ___ms)]
                        (when (or (nil? ___ms) (not (ß Util'equals(___v.nth(___i), (first ___ms)))))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (§ instance? IPersistentVector ___obj)
            (do
                (let [#_"IPersistentVector" ___ov (cast' IPersistentVector ___obj)]
                    (when (ß (count ___ov) != (count ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___v)) [(inc ___i)]
                        (when (not (ß Util'equiv-2oo(___v.nth(___i), ___ov.nth(___i))))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (instance? List ___obj)
            (do
                (let [#_"Collection" ___ma (cast Collection ___obj)]
                    (when (ß (.size ___ma) != (count ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"Iterator" ___i1 (.iterator (cast List ___v)) #_"Iterator" ___i2 (.iterator ___ma)] (.hasNext ___i1) [___i1 ___i2]
                        (when (not (Util'equiv-2oo (next ___i1), (next ___i2)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (not (§ instance? Sequential ___obj))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (RT'seq ___obj)]
                    (loop-when-recur [#_"int" ___i 0 ___ms ___ms] (ß ___i < (count ___v)) [(inc ___i) (next ___ms)]
                        (when (or (nil? ___ms) (not (ß Util'equiv-2oo(___v.nth(___i), (first ___ms)))))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentVector" this, #_"Object" ___obj]
        (when (= ___obj this)
            (§ return true)
        )
        (doEquals this, ___obj)
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentVector" this, #_"Object" ___obj]
        (when (= ___obj this)
            (§ return true)
        )
        (APersistentVector'doEquiv this, ___obj)
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentVector" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (zero? ___hash)
                (§ ass ___hash 1)
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
                    (let [#_"Object" ___obj (.nth this, ___i)]
                        (§ ass ___hash (+ (* 31 ___hash) (if (nil? ___obj) 0 (.hashCode ___obj))))
                    )
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentVector" this]
        (let [#_"int" ___hash (:_hasheq this)]
            (when (zero? ___hash)
                (§ let [#_"int" ___n]
                    (§ ass ___hash 1)

                    (loop-when-recur [___n 0] (ß ___n < (count this)) [(inc ___n)]
                        (§ ass ___hash (ß 31 * ___hash + Util'hasheq(this.nth(___n))))
                    )

                    (§ ass (:_hasheq this) (§ ass ___hash (Murmur3'mixCollHash ___hash, ___n)))
                )
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentVector" this, #_"int" ___index]
        (.nth this, ___index)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (and (<= 0 ___i) (< ___i (count this)))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"APersistentVector" this, #_"int" ___i]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
            (when (ß Util'equiv-2oo(this.nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"int" ___i (ß (count this) - 1)] (>= ___i 0) [(dec ___i)]
            (when (ß Util'equiv-2oo(this.nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"APersistentVector" this]
        (.listIterator this, 0)
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"APersistentVector" this, #_"int" ___index]
        (§ reify ListIterator()
            (let [#_"int" ___nexti ___index]
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"ListIterator" this]
                    (ß (___nexti < (count this)))
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"ListIterator" this]
                    (if (ß ___nexti < (count this))
                        (let [_ (.nth this, ___nexti)]
                            (§ ass ___nexti (inc ___nexti))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"boolean" (§ method hasPrevious) [#_"ListIterator" this]
                    (> ___nexti 0)
                )

                #_method
                (§ defn #_"Object" (§ method previous) [#_"ListIterator" this]
                    (if (> ___nexti 0)
                        (do
                            (§ ass ___nexti (dec ___nexti))
                            (.nth this, ___nexti)
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"int" (§ method nextIndex) [#_"ListIterator" this]
                    ___nexti
                )

                #_method
                (§ defn #_"int" (§ method previousIndex) [#_"ListIterator" this]
                    (dec ___nexti)
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"ListIterator" this]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" (§ method set) [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" (§ method add) [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method rangedIterator) [#_"APersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (let [#_"int" ___i ___start]
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (< ___i ___end)
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (if (< ___i ___end)
                        (let [_ (.nth this, ___i)]
                            (§ ass ___i (inc ___i))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"APersistentVector" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (cast List (RT'subvec this, ___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentVector" this, #_"int" ___i, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentVector" this, #_"Object" ___arg1]
        (when (Util'isInteger ___arg1)
            (§ return (ß this.nth((cast Number ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (let [#_"int" ___i 0]
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (ß (___i < (count this)))
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (if (ß ___i < (count this))
                        (let [_ (.nth this, ___i)]
                            (§ ass ___i (inc ___i))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"APersistentVector" this]
        (when (pos? (count this))
            (§ return (ß this.nth((count this) - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"APersistentVector" this, #_"Object" ___key]
        (when (not (Util'isInteger ___key))
            (§ return false)
        )
        (let [#_"int" ___i (.intValue (cast Number ___key))]
            (and (<= 0 ___i) (< ___i (count this)))
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"APersistentVector" this, #_"Object" ___key]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (.intValue (cast Number ___key))]
                (when (and (<= 0 ___i) (< ___i (count this)))
                    (§ return (cast' IMapEntry (ß MapEntry'create(___key, this.nth(___i)))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assoc) [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___val]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (.intValue (cast Number ___key))]
                (§ return (.assocN this, ___i, ___val))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (.intValue (cast Number ___key))]
                (when (and (<= 0 ___i) (< ___i (count this)))
                    (§ return (.nth this, ___i))
                )
            )
        )
        ___notFound
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"APersistentVector" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentVector" this]
        (let [#_"Object[]" ___ret (make-array Object (count this))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
                (§ ass (§ aget ___ret ___i) (.nth this, ___i))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (.contains this, ___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentVector" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentVector" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentVector" this]
        (zero? (count this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"int" (§ method length) [#_"APersistentVector" this]
        (count this)
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"APersistentVector" this, #_"Object" ___o]
        (let [#_"IPersistentVector" ___v (cast' IPersistentVector ___o)]
            (cond (ß (count this) < (count ___v))
                (do
                    (§ return -1)
                )
                (ß (count this) > (count ___v))
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
                (let [#_"int" ___c (ß Util'compare(this.nth(___i), ___v.nth(___i)))]
                    (when (not= ___c 0)
                        (§ return ___c)
                    )
                )
            )
            0
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (defn- #_"ARef" ARef'init []
        (hash-map
            #_protected
            #_volatile
            #_"IFn" :validator nil
            #_volatile
            #_"IPersistentMap" :watches PersistentHashMap'EMPTY
        )
    )

    (defn #_"ARef" ARef'new-0 []
        (merge (AReference'new) (ARef'init))
    )

    (defn #_"ARef" ARef'new-1 [#_"IPersistentMap" ___meta]
        (merge (AReference'new ___meta) (ARef'init))
    )

    #_method
    (§ defn #_"void" (§ method validate) [#_"ARef" this, #_"IFn" ___vf, #_"Object" ___val]
        (try
            (when (and (some? ___vf) (not (RT'booleanCast-1o (.invoke ___vf, ___val))))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException ___re
                (throw ___re)
            )
            (catch Exception ___e
                (throw (IllegalStateException. "Invalid reference state", ___e))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method validate) [#_"ARef" this, #_"Object" ___val]
        (.validate this, (:validator this), ___val)
        nil
    )

    #_method
    (§ defn #_"void" (§ method setValidator) [#_"ARef" this, #_"IFn" ___vf]
        (ß this.validate(___vf, (.deref this)))
        (§ ass (:validator this) ___vf)
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method getValidator) [#_"ARef" this]
        (:validator this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getWatches) [#_"ARef" this]
        (:watches this)
    )

    #_method
    (§ defn #_"IRef" (§ method addWatch) [#_"ARef" this, #_"Object" ___key, #_"IFn" ___callback]
        (§ sync this
            (§ ass (:watches this) (.assoc (:watches this), ___key, ___callback))
            this
        )
    )

    #_method
    (§ defn #_"IRef" (§ method removeWatch) [#_"ARef" this, #_"Object" ___key]
        (§ sync this
            (§ ass (:watches this) (.without (:watches this), ___key))
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method notifyWatches) [#_"ARef" this, #_"Object" ___oldval, #_"Object" ___newval]
        (let [#_"IPersistentMap" ___ws (:watches this)]
            (when (pos? (count ___ws))
                (loop-when-recur [#_"ISeq" ___s (.seq ___ws)] (some? ___s) [(next ___s)]
                    (let [#_"Map$Entry" ___e (cast Map$Entry (first ___s))]
                        (let [#_"IFn" ___fn (cast' IFn (.getValue ___e))]
                            (when (some? ___fn)
                                (ß ___fn.invoke((.getKey ___e), this, ___oldval, ___newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (defn- #_"AReference" AReference'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"AReference" AReference'new-0 []
        (AReference'new-1 nil)
    )

    (defn #_"AReference" AReference'new-1 [#_"IPersistentMap" ___meta]
        (let [this (AReference'init)]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"AReference" this]
        (§ sync this
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method alterMeta) [#_"AReference" this, #_"IFn" ___alter, #_"ISeq" ___args]
        (§ sync this
            (§ ass (:_meta this) (cast' IPersistentMap (ß ___alter.applyTo(Cons'new-2((:_meta this), ___args)))))
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method resetMeta) [#_"AReference" this, #_"IPersistentMap" ___m]
        (§ sync this
            (§ ass (:_meta this) ___m)
            ___m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (defn- #_"ArityException" ArityException'init []
        (hash-map
            #_"int" :actual 0
            #_"String" :name nil
        )
    )

    (defn #_"ArityException" ArityException'new-2 [#_"int" ___actual, #_"String" ___name]
        (ArityException'new-3 ___actual, ___name, nil)
    )

    (defn #_"ArityException" ArityException'new-3 [#_"int" ___actual, #_"String" ___name, #_"Throwable" ___cause]
        (let [this (merge (§ foreign IllegalArgumentException'new (str "Wrong number of args (" ___actual ") passed to: " ___name), ___cause) (ArityException'init))]
            (§ ass (:actual this) ___actual)
            (§ ass (:name this) ___name)
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (defn- #_"ArrayChunk" ArrayChunk'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :off 0
            #_"int" :end 0
        )
    )

    (defn #_"ArrayChunk" ArrayChunk'new-1 [#_"Object[]" ___array]
        (ArrayChunk'new-3 ___array, 0, (§ alength ___array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-2 [#_"Object[]" ___array, #_"int" ___off]
        (ArrayChunk'new-3 ___array, ___off, (§ alength ___array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-3 [#_"Object[]" ___array, #_"int" ___off, #_"int" ___end]
        (let [this (ArrayChunk'init)]
            (§ ass (:array this) ___array)
            (§ ass (:off this) ___off)
            (§ ass (:end this) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"ArrayChunk" this, #_"int" ___i]
        (§ aget (:array this) (ß (:off this) + ___i))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"ArrayChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (and (<= 0 ___i) (< ___i (count this)))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArrayChunk" this]
        (- (:end this) (:off this))
    )

    #_method
    (§ defn #_"IChunk" (§ method dropFirst) [#_"ArrayChunk" this]
        (when (ß (:off this) == (:end this))
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß ArrayChunk'new-3((:array this), (:off this) + 1, (:end this)))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArrayChunk" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:off this)]))]
            (when (RT'isReduced ___ret)
                (§ return ___ret)
            )
            (loop-when-recur [#_"int" ___x (+ (:off this) 1)] (< ___x (:end this)) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return ___ret)
                )
            )
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter_int (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_int" ArrayIter_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_int" ArrayIter_int'new [#_"int[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_int'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_int" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_int" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_int" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_float (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_float" ArrayIter_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_float" ArrayIter_float'new [#_"float[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_float'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_float" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Double" (§ method next) [#_"ArrayIter_float" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (ß Double/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_float" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_double (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_double" ArrayIter_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_double" ArrayIter_double'new [#_"double[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_double'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_double" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Double" (§ method next) [#_"ArrayIter_double" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (§ aget (:array this) (:i this))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_double" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_long (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_long" ArrayIter_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_long" ArrayIter_long'new [#_"long[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_long'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_long" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_long" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_long" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_byte (§ implements Iterator<Byte>)
    (defn- #_"ArrayIter_byte" ArrayIter_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_byte" ArrayIter_byte'new [#_"byte[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_byte'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_byte" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Byte" (§ method next) [#_"ArrayIter_byte" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (§ aget (:array this) (:i this))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_byte" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_char (§ implements Iterator<Character>)
    (defn- #_"ArrayIter_char" ArrayIter_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_char" ArrayIter_char'new [#_"char[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_char'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_char" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Character" (§ method next) [#_"ArrayIter_char" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (§ aget (:array this) (:i this))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_char" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_short (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_short" ArrayIter_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_short" ArrayIter_short'new [#_"short[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_short'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_short" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_short" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_short" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
    (defn- #_"ArrayIter_boolean" ArrayIter_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_boolean" ArrayIter_boolean'new [#_"boolean[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_boolean'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_boolean" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Boolean" (§ method next) [#_"ArrayIter_boolean" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (ß Boolean/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_boolean" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter (§ implements Iterator)
    (def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (java.util.NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException. "remove() not supported"))
            )
        )
    )

    (defn #_"Iterator" ArrayIter'create-0 []
        ArrayIter'EMPTY_ITERATOR
    )

    (defn #_"Iterator" ArrayIter'create-1 [#_"Object..." ___array]
        (when (or (nil? ___array) (zero? (§ alength ___array)))
            (§ return ArrayIter'EMPTY_ITERATOR)
        )
        (ArrayIter'new ___array, 0)
    )

    (defn #_"Iterator" ArrayIter'createFromObject [#_"Object" ___array]
        (when (or (nil? ___array) (zero? (Array/getLength ___array)))
            (§ return ArrayIter'EMPTY_ITERATOR)
        )
        (let [#_"Class" ___aclass (.getClass ___array)]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß ArrayIter_int'new((int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß ArrayIter_float'new((float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß ArrayIter_double'new((double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß ArrayIter_long'new((long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß ArrayIter_byte'new((byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß ArrayIter_char'new((char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß ArrayIter_short'new((short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß ArrayIter_boolean'new((boolean[]) ___array, 0)))
            )
            (ArrayIter'new ___array, 0)
        )
    )

    (defn- #_"ArrayIter" ArrayIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter" ArrayIter'new [#_"Object" ___array, #_"int" ___i]
        (let [this (ArrayIter'init)]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter" this]
        (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"ArrayIter" this]
        (when (and (some? (:array this)) (< (:i this) (§ alength (:array this))))
            (let [_ (§ aget (:array this) (:i this))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_int" ArraySeq_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_int" ArraySeq_int'new [#_"IPersistentMap" ___meta, #_"int[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_int'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_int" this]
        (§ aget (:array this) (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_int" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_int'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_int" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_int" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_int" (§ method withMeta) [#_"ArraySeq_int" this, #_"IPersistentMap" ___meta]
        (ArraySeq_int'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_int" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_int" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"int" ___k (.intValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___k == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"int" ___k (.intValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___k == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_float" ArraySeq_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_float" ArraySeq_float'new [#_"IPersistentMap" ___meta, #_"float[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_float'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_float" this]
        (ß Numbers'num-1f((:array this)[(:i this)]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_float" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_float'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_float" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_float" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_float" (§ method withMeta) [#_"ArraySeq_float" this, #_"IPersistentMap" ___meta]
        (ArraySeq_float'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_float" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num-1f((:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1f((:array this)[___x]))))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_float" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num-1f((:array this)[(:i this)])))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1f((:array this)[___x]))))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"float" ___f (.floatValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___f == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"float" ___f (.floatValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___f == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        -1
    )
)

(class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_double" ArraySeq_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_double" ArraySeq_double'new [#_"IPersistentMap" ___meta, #_"double[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_double'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_double" this]
        (§ aget (:array this) (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_double" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_double'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_double" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_double" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_double" (§ method withMeta) [#_"ArraySeq_double" this, #_"IPersistentMap" ___meta]
        (ArraySeq_double'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_double" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_double" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"double" ___d (.doubleValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___d == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"double" ___d (.doubleValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___d == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_long" ArraySeq_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_long" ArraySeq_long'new [#_"IPersistentMap" ___meta, #_"long[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_long'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_long" this]
        (ß Numbers'num-1l((:array this)[(:i this)]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_long" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_long'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_long" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_long" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_long" (§ method withMeta) [#_"ArraySeq_long" this, #_"IPersistentMap" ___meta]
        (ArraySeq_long'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_long" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num-1l((:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1l((:array this)[___x]))))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_long" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num-1l((:array this)[(:i this)])))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1l((:array this)[___x]))))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"long" ___l (.longValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___l == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (instance? Number ___o)
            (let [#_"long" ___l (.longValue (cast Number ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___l == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_byte" ArraySeq_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_byte" ArraySeq_byte'new [#_"IPersistentMap" ___meta, #_"byte[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_byte'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_byte" this]
        (§ aget (:array this) (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_byte" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_byte'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_byte" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_byte" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_byte" (§ method withMeta) [#_"ArraySeq_byte" this, #_"IPersistentMap" ___meta]
        (ArraySeq_byte'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_byte" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_byte" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (instance? Byte ___o)
            (let [#_"byte" ___b (.byteValue (cast Byte ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (instance? Byte ___o)
            (let [#_"byte" ___b (.byteValue (cast Byte ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_char" ArraySeq_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_char" ArraySeq_char'new [#_"IPersistentMap" ___meta, #_"char[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_char'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_char" this]
        (§ aget (:array this) (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_char" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_char'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_char" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_char" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_char" (§ method withMeta) [#_"ArraySeq_char" this, #_"IPersistentMap" ___meta]
        (ArraySeq_char'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_char" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_char" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (instance? Character ___o)
            (let [#_"char" ___c (.charValue (cast Character ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___c == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (instance? Character ___o)
            (let [#_"char" ___c (.charValue (cast Character ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___c == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_short" ArraySeq_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_short" ArraySeq_short'new [#_"IPersistentMap" ___meta, #_"short[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_short'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_short" this]
        (§ aget (:array this) (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_short" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_short'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_short" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_short" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_short" (§ method withMeta) [#_"ArraySeq_short" this, #_"IPersistentMap" ___meta]
        (ArraySeq_short'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_short" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_short" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (instance? Short ___o)
            (let [#_"short" ___s (.shortValue (cast Short ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___s == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (instance? Short ___o)
            (let [#_"short" ___s (.shortValue (cast Short ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___s == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_boolean" ArraySeq_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_boolean" ArraySeq_boolean'new [#_"IPersistentMap" ___meta, #_"boolean[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_boolean'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_boolean" this]
        (§ aget (:array this) (:i this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_boolean" this]
        (when (ß (:i this) + 1 < (§ alength (:array this)))
            (§ return (ß ArraySeq_boolean'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_boolean" this]
        (ß (§ alength (:array this)) - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_boolean" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_boolean" (§ method withMeta) [#_"ArraySeq_boolean" this, #_"IPersistentMap" ___meta]
        (ArraySeq_boolean'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_boolean" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_boolean" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (instance? Boolean ___o)
            (let [#_"boolean" ___b (.booleanValue (cast Boolean ___o))]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (instance? Boolean ___o)
            (let [#_"boolean" ___b (.booleanValue (cast Boolean ___o))]
                (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn #_"ArraySeq" ArraySeq'create-0 []
        nil
    )

    (defn #_"ArraySeq" ArraySeq'create-1 [#_"Object..." ___array]
        (when (or (nil? ___array) (zero? (§ alength ___array)))
            (§ return nil)
        )
        (ArraySeq'new-2 ___array, 0)
    )

    (defn #_"ISeq" ArraySeq'createFromObject [#_"Object" ___array]
        (when (or (nil? ___array) (zero? (Array/getLength ___array)))
            (§ return nil)
        )
        (let [#_"Class" ___aclass (.getClass ___array)]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß ArraySeq_int'new(nil, (int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß ArraySeq_float'new(nil, (float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß ArraySeq_double'new(nil, (double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß ArraySeq_long'new(nil, (long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß ArraySeq_byte'new(nil, (byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß ArraySeq_char'new(nil, (char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß ArraySeq_short'new(nil, (short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß ArraySeq_boolean'new(nil, (boolean[]) ___array, 0)))
            )
            (ArraySeq'new-2 ___array, 0)
        )
    )

    (defn- #_"ArraySeq" ArraySeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-2 [#_"Object" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new) (ArraySeq'init))]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-3 [#_"IPersistentMap" ___meta, #_"Object" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq'init))]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq" this]
        (when (some? (:array this))
            (§ return (§ aget (:array this) (:i this)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq" this]
        (when (and (some? (:array this)) (< (inc (:i this)) (§ alength (:array this))))
            (§ return (ArraySeq'new-2 (:array this), (inc (:i this))))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq" this]
        (when (some? (:array this))
            (§ return (- (§ alength (:array this)) (:i this)))
        )
        0
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq" (§ method withMeta) [#_"ArraySeq" this, #_"IPersistentMap" ___meta]
        (ArraySeq'new-3 ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq" this, #_"IFn" ___f]
        (when (some? (:array this))
            (let [#_"Object" ___ret (§ aget (:array this) (:i this))]
                (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                    (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                    (when (RT'isReduced ___ret)
                        (§ return (.deref (cast' IDeref ___ret)))
                    )
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq" this, #_"IFn" ___f, #_"Object" ___start]
        (when (some? (:array this))
            (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
                (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (§ alength (:array this))) [(inc ___x)]
                    (when (RT'isReduced ___ret)
                        (§ return (.deref (cast' IDeref ___ret)))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                )
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? (:array this))
            (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (§ alength (:array this))) [(inc ___j)]
                (when (ß Util'equals(___o, (:array this)[___j]))
                    (§ return (- ___j (:i this)))
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? (:array this))
            (if (nil? ___o)
                (do
                    (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                        (when (nil? (§ aget (:array this) ___j))
                            (§ return (- ___j (:i this)))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"int" ___j (ß (§ alength (:array this)) - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                        (when (ß ___o.equals((:array this)[___j]))
                            (§ return (- ___j (:i this)))
                        )
                    )
                )
            )
        )
        -1
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (defn- #_"ASeq" ASeq'init []
        (hash-map
            #_transient
            #_"int" :_hash 0
            #_transient
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"ASeq" ASeq'new-1 [#_"IPersistentMap" ___meta]
        (merge (Obj'new ___meta) (ASeq'init))
    )

    #_protected
    (defn #_"ASeq" ASeq'new-0 []
        (merge (Obj'new) (ASeq'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ASeq" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"ASeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"ASeq" this, #_"Object" ___obj]
        (when (not (or (§ instance? Sequential ___obj) (instance? List ___obj)))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (or (nil? ___ms) (not (Util'equiv-2oo (first ___s), (first ___ms))))
                    (§ return false)
                )
            )
            (nil? ___ms)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"ASeq" this, #_"Object" ___obj]
        (when (= this ___obj)
            (§ return true)
        )
        (when (not (or (§ instance? Sequential ___obj) (instance? List ___obj)))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (or (nil? ___ms) (not (Util'equals (first ___s), (first ___ms))))
                    (§ return false)
                )
            )
            (nil? ___ms)
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"ASeq" this]
        (when (zero? (:_hash this))
            (let [#_"int" ___hash 1]
                (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                    (§ ass ___hash (+ (* 31 ___hash) (if (nil? (first ___s)) 0 (.hashCode (first ___s)))))
                )
                (§ ass (:_hash this) ___hash)
            )
        )
        (:_hash this)
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"ASeq" this]
        (when (zero? (:_hasheq this))
            (§ ass (:_hasheq this) (Murmur3'hashOrdered this))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ASeq" this]
        (let [#_"int" ___i 1]
            (loop-when-recur [#_"ISeq" ___s (next this) ___i ___i] (some? ___s) [(next ___s) (inc ___i)]
                (when (§ instance? Counted ___s)
                    (§ return (ß ___i + (count ___s)))
                )
            )
            ___i
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"ASeq" this]
        this
    )

    #_method
    (§ defn #_"ISeq" (§ method cons) [#_"ASeq" this, #_"Object" ___o]
        (Cons'new-2 ___o, this)
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"ASeq" this]
        (let [#_"ISeq" ___s (next this)]
            (when (nil? ___s)
                (§ return PersistentList'EMPTY)
            )
            ___s
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"ASeq" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"ASeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (.contains this, ___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"ASeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"ASeq" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"ASeq" this]
        (nil? (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ASeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"ASeq" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"ASeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (.reify this).subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"ASeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this) #_"int" ___i 0] (some? ___s) [(next ___s) (inc ___i)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ASeq" this, #_"Object" ___o]
        (ß (.reify this).lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"ASeq" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"ASeq" this, #_"int" ___index]
        (ß (.reify this).listIterator(___index))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"ASeq" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"ASeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Associative

(§ defprotocol Associative #_(§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" Associative'''(§ method containsKey) [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" Associative'''(§ method entryAt) [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"Associative" Associative'''(§ method assoc) [#_"Associative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (defn- #_"Atom" Atom'init []
        (hash-map
            #_"AtomicReference" :state nil
        )
    )

    (defn #_"Atom" Atom'new-1 [#_"Object" ___state]
        (let [this (merge (ARef'new-0) (Atom'init))]
            (§ ass (:state this) (AtomicReference. ___state))
            this
        )
    )

    (defn #_"Atom" Atom'new-2 [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Atom'init))]
            (§ ass (:state this) (AtomicReference. ___state))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Atom" this]
        (.get (:state this))
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___v (.deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___v)]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___v, ___newv)
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___v (.deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___v, ___arg)]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___v, ___newv)
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___v (.deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___v, ___arg1, ___arg2)]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___v, ___newv)
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___v (.deref this)]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar-4(___v, ___x, ___y, ___args)))]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___v, ___newv)
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___oldv (.deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___oldv)]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___oldv, ___newv)
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___oldv (.deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___oldv, ___arg)]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___oldv, ___newv)
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___oldv (.deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___oldv, ___arg1, ___arg2)]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___oldv, ___newv)
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___oldv (.deref this)]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar-4(___oldv, ___x, ___y, ___args)))]
                    (.validate this, ___newv)
                    (when (.compareAndSet (:state this), ___oldv, ___newv)
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method compareAndSet) [#_"Atom" this, #_"Object" ___oldv, #_"Object" ___newv]
        (.validate this, ___newv)
        (let [#_"boolean" ___ret (.compareAndSet (:state this), ___oldv, ___newv)]
            (when ___ret
                (.notifyWatches this, ___oldv, ___newv)
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reset) [#_"Atom" this, #_"Object" ___newval]
        (let [#_"Object" ___oldval (.get (:state this))]
            (.validate this, ___newval)
            (.set (:state this), ___newval)
            (.notifyWatches this, ___oldval, ___newval)
            ___newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method resetVals) [#_"Atom" this, #_"Object" ___newv]
        (.validate this, ___newv)
        (while true
            (let [#_"Object" ___oldv (.deref this)]
                (when (.compareAndSet (:state this), ___oldv, ___newv)
                    (.notifyWatches this, ___oldv, ___newv)
                    (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_protected
    (defn #_"ATransientMap" ATransientMap'new []
        (AFn'new)
    )

    #_abstract
    (§ defn #_"void" (§ method ensureEditable) [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"ATransientMap" this, #_"Object" ___key])
    #_abstract
    (§ defn #_"Object" (§ method doValAt) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (§ defn #_"int" (§ method doCount) [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"ATransientMap" this])

    #_method
    (§ defn #_"ITransientMap" (§ method conj) [#_"ATransientMap" this, #_"Object" ___o]
        (.ensureEditable this)
        (cond (instance? Map$Entry ___o)
            (do
                (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                    (§ return (ß this.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (§ instance? IPersistentVector ___o)
            (do
                (let [#_"IPersistentVector" ___v (cast' IPersistentVector ___o)]
                    (when (ß (count ___v) != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß this.assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ___ret this]
            (loop-when-recur [#_"ISeq" ___es (RT'seq ___o)] (some? ___es) [(next ___es)]
                (let [#_"Map$Entry" ___e (cast Map$Entry (first ___es))]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientMap" this, #_"Object" ___arg1]
        (.valAt this, ___arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (.valAt this, ___arg1, ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ATransientMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"ITransientMap" (§ method assoc) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val]
        (.ensureEditable this)
        (.doAssoc this, ___key, ___val)
    )

    #_method
    (§ defn #_"ITransientMap" (§ method without) [#_"ATransientMap" this, #_"Object" ___key]
        (.ensureEditable this)
        (.doWithout this, ___key)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method persistent) [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doPersistent this)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (.ensureEditable this)
        (.doValAt this, ___key, ___notFound)
    )

    (def- #_"Object" ATransientMap'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"ATransientMap" this, #_"Object" ___key]
        (ß this.valAt(___key, ATransientMap'NOT_FOUND) != ATransientMap'NOT_FOUND)
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"ATransientMap" this, #_"Object" ___key]
        (let [#_"Object" ___v (.valAt this, ___key, ATransientMap'NOT_FOUND)]
            (when (not= ___v ATransientMap'NOT_FOUND)
                (§ return (MapEntry'create ___key, ___v))
            )
            nil
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doCount this)
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (defn- #_"ATransientSet" ATransientSet'init []
        (hash-map
            #_volatile
            #_"ITransientMap" :impl nil
        )
    )

    (defn #_"ATransientSet" ATransientSet'new [#_"ITransientMap" ___impl]
        (let [this (merge (AFn'new) (ATransientSet'init))]
            (§ ass (:impl this) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ATransientSet" this]
        (count (:impl this))
    )

    #_method
    (§ defn #_"ITransientSet" (§ method conj) [#_"ATransientSet" this, #_"Object" ___val]
        (let [#_"ITransientMap" ___m (.assoc (:impl this), ___val, ___val)]
            (when (ß ___m != (:impl this))
                (§ ass (:impl this) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"ATransientSet" this, #_"Object" ___key]
        (ß (.this != (:impl this).valAt(___key, this)))
    )

    #_method
    (§ defn #_"ITransientSet" (§ method disjoin) [#_"ATransientSet" this, #_"Object" ___key]
        (let [#_"ITransientMap" ___m (.without (:impl this), ___key)]
            (when (ß ___m != (:impl this))
                (§ ass (:impl this) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"ATransientSet" this, #_"Object" ___key]
        (.valAt (:impl this), ___key)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientSet" this, #_"Object" ___key, #_"Object" ___notFound]
        (.valAt (:impl this), ___key, ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientSet" this, #_"Object" ___key]
        (.valAt (:impl this), ___key)
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" BigInt'ZERO (BigInt'new 0, nil))
    (§ def #_"BigInt" BigInt'ONE (BigInt'new 1, nil))

    (defn- #_"BigInt" BigInt'init []
        (hash-map
            #_"long" :lpart 0
            #_"BigInteger" :bipart nil
        )
    )

    (defn- #_"BigInt" BigInt'new [#_"long" ___lpart, #_"BigInteger" ___bipart]
        (let [this (merge (Number'new) (BigInt'init))]
            (§ ass (:lpart this) ___lpart)
            (§ ass (:bipart this) ___bipart)
            this
        )
    )

    ;; must follow Long
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (ß (int) ((:lpart this) :xor ((:lpart this) >>> 32))))
        )
        (.hashCode (:bipart this))
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (Murmur3'hashLong (:lpart this)))
        )
        (.hashCode (:bipart this))
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"BigInt" this, #_"Object" ___obj]
        (when (= this ___obj)
            (§ return true)
        )
        (when (§ instance? BigInt ___obj)
            (let [#_"BigInt" ___o (cast' BigInt ___obj)]
                (when (nil? (:bipart this))
                    (§ return (and (nil? (:bipart ___o)) (ß (:lpart this) == (:lpart ___o))))
                )
                (§ return (and (some? (:bipart ___o)) (.equals (:bipart this), (:bipart ___o))))
            )
        )
        false
    )

    (defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" ___val]
        (if (ß (.bitLength ___val) < 64)
            (do
                (ß BigInt'new((.longValue ___val), nil))
            )
            (do
                (BigInt'new 0, ___val)
            )
        )
    )

    (defn #_"BigInt" BigInt'fromLong [#_"long" ___val]
        (BigInt'new ___val, nil)
    )

    #_method
    (§ defn #_"BigInteger" (§ method toBigInteger) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (BigInteger/valueOf (:lpart this))
            )
            (do
                (:bipart this)
            )
        )
    )

    #_method
    (§ defn #_"BigDecimal" (§ method toBigDecimal) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (BigDecimal/valueOf (:lpart this))
            )
            (do
                (BigDecimal. (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method intValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (int) (:lpart this))
            )
            (do
                (.intValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"long" (§ method longValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (.longValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"float" (§ method floatValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (.floatValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"double" (§ method doubleValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (.doubleValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"byte" (§ method byteValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (byte) (:lpart this))
            )
            (do
                (.byteValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"short" (§ method shortValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (short) (:lpart this))
            )
            (do
                (.shortValue (:bipart this))
            )
        )
    )

    (defn #_"BigInt" BigInt'valueOf [#_"long" ___val]
        (BigInt'new ___val, nil)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (String/valueOf (:lpart this)))
        )
        (.toString (:bipart this))
    )

    #_method
    (§ defn #_"int" (§ method bitLength) [#_"BigInt" this]
        (.bitLength (.toBigInteger this))
    )

    #_method
    (§ defn #_"BigInt" (§ method add) [#_"BigInt" this, #_"BigInt" ___y]
        (when (and (nil? (:bipart this)) (nil? (:bipart ___y)))
            (let [#_"long" ___ret (ß (:lpart this) + (:lpart ___y))]
                (when (or (ß (___ret :xor (:lpart this)) >= 0) (ß (___ret :xor (:lpart ___y)) >= 0))
                    (§ return (BigInt'valueOf ___ret))
                )
            )
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).add((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"BigInt" (§ method multiply) [#_"BigInt" this, #_"BigInt" ___y]
        (when (and (nil? (:bipart this)) (nil? (:bipart ___y)))
            (let [#_"long" ___ret (ß (:lpart this) * (:lpart ___y))]
                (when (or (zero? (:lpart ___y)) (and (ß (ß ___ret / (:lpart ___y)) == (:lpart this)) (ß (:lpart this) != Long/MIN_VALUE)))
                    (§ return (BigInt'valueOf ___ret))
                )
            )
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).multiply((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"BigInt" (§ method quotient) [#_"BigInt" this, #_"BigInt" ___y]
        (when (and (nil? (:bipart this)) (nil? (:bipart ___y)))
            (when (and (ß (:lpart this) == Long/MIN_VALUE) (ß (:lpart ___y) == -1))
                (§ return (ß BigInt'fromBigInteger((.toBigInteger this).negate())))
            )
            (§ return (ß BigInt'valueOf((:lpart this) / (:lpart ___y))))
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).divide((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"BigInt" (§ method remainder) [#_"BigInt" this, #_"BigInt" ___y]
        (when (and (nil? (:bipart this)) (nil? (:bipart ___y)))
            (§ return (ß BigInt'valueOf((:lpart this) % (:lpart ___y))))
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).remainder((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigInt" this, #_"BigInt" ___y]
        (when (and (nil? (:bipart this)) (nil? (:bipart ___y)))
            (§ return (ß ((:lpart this) < (:lpart ___y))))
        )
        (neg? (.compareTo (.toBigInteger this), (.toBigInteger ___y)))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (defn- #_"Binding" Binding'init []
        (hash-map
            #_"T" :val nil
            #_"Binding" :rest nil
        )
    )

    (defn #_"Binding" Binding'new-1 [#_"T" ___val]
        (let [this (Binding'init)]
            (§ ass (:val this) ___val)
            (§ ass (:rest this) nil)
            this
        )
    )

    (defn #_"Binding" Binding'new-2 [#_"T" ___val, #_"Binding" ___rest]
        (let [this (Binding'init)]
            (§ ass (:val this) ___val)
            (§ ass (:rest this) ___rest)
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (defn- #_"Box" Box'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Box" Box'new [#_"Object" ___val]
        (let [this (Box'init)]
            (§ ass (:val this) ___val)
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (defn- #_"ChunkBuffer" ChunkBuffer'init []
        (hash-map
            #_"Object[]" :buffer nil
            #_"int" :end 0
        )
    )

    (defn #_"ChunkBuffer" ChunkBuffer'new [#_"int" ___capacity]
        (let [this (ChunkBuffer'init)]
            (§ ass (:buffer this) (make-array Object ___capacity))
            (§ ass (:end this) 0)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"ChunkBuffer" this, #_"Object" ___o]
        (§ ass (§ aget (:buffer this) (:end this)) ___o)
        (§ ass (:end this) (+ (:end this) 1))
        nil
    )

    #_method
    (§ defn #_"IChunk" (§ method chunk) [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ___ret (ArrayChunk'new-3 (:buffer this), 0, (:end this))]
            (§ ass (:buffer this) nil)
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ChunkBuffer" this]
        (:end this)
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (defn- #_"ChunkedCons" ChunkedCons'init []
        (hash-map
            #_"IChunk" :chunk nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-3 [#_"IPersistentMap" ___meta, #_"IChunk" ___chunk, #_"ISeq" ___more]
        (let [this (merge (ASeq'new ___meta) (ChunkedCons'init))]
            (§ ass (:chunk this) ___chunk)
            (§ ass (:_more this) ___more)
            this
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-2 [#_"IChunk" ___chunk, #_"ISeq" ___more]
        (ChunkedCons'new-3 nil, ___chunk, ___more)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"ChunkedCons" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (:_meta this))
            (§ return (ChunkedCons'new-3 ___meta, (:chunk this), (:_more this)))
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ChunkedCons" this]
        (.nth (:chunk this), 0)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ChunkedCons" this]
        (when (ß (:chunk this).count() > 1)
            (§ return (ß ChunkedCons'new-2((:chunk this).dropFirst(), (:_more this))))
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"ChunkedCons" this]
        (when (ß (:chunk this).count() > 1)
            (§ return (ß ChunkedCons'new-2((:chunk this).dropFirst(), (:_more this))))
        )
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"ChunkedCons" this]
        (:chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"ChunkedCons" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"ChunkedCons" this]
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

#_stateless
(class-ns Compile
    (def- #_"String" Compile'PATH_PROP "cloiure.compile.path")
    (def- #_"String" Compile'REFLECTION_WARNING_PROP "cloiure.compile.warn-on-reflection")
    (def- #_"String" Compile'UNCHECKED_MATH_PROP "cloiure.compile.unchecked-math")

    (§ def- #_"Var" Compile'compile_path (RT'var-2 "cloiure.core", "*compile-path*"))
    (§ def- #_"Var" Compile'compile (RT'var-2 "cloiure.core", "compile"))
    (§ def- #_"Var" Compile'warn_on_reflection (RT'var-2 "cloiure.core", "*warn-on-reflection*"))
    (§ def- #_"Var" Compile'unchecked_math (RT'var-2 "cloiure.core", "*unchecked-math*"))

    (defn #_"void" Compile'main [#_"String[]" ___args] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" ___out (cast OutputStreamWriter (.deref RT'OUT))]
            (let [#_"PrintWriter" ___err (RT'errPrintWriter)]
                (let [#_"String" ___path (System/getProperty Compile'PATH_PROP)]
                    (let [#_"int" ___count (§ alength ___args)]
                        (when (nil? ___path)
                            (.println ___err, (str "ERROR: Must set system property " Compile'PATH_PROP "\nto the location for compiled .class files." "\nThis directory must also be on your CLASSPATH."))
                            (System/exit 1)
                        )

                        (let [#_"boolean" ___warnOnReflection (ß System/getProperty(Compile'REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" ___uncheckedMathProp (System/getProperty Compile'UNCHECKED_MATH_PROP)]
                                (let [#_"Object" ___uncheckedMath Boolean/FALSE]
                                    (cond (ß "true".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath Boolean/TRUE)
                                        )
                                        (ß "warn-on-boxed".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath (Keyword'intern-1 "warn-on-boxed"))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (RT'load-1 "cloiure/core/specs/alpha")

                                    (try
                                        (ß Var'pushThreadBindings(RT'map(
                                            (object-array [
                                                compile_path       ___path
                                                warn_on_reflection ___warnOnReflection
                                                unchecked_math     ___uncheckedMath
                                            ])
                                        )))

                                        (doseq [#_"String" ___lib ___args]
                                            (.write ___out, (str "Compiling " ___lib " to " ___path "\n"))
                                            (.flush ___out)
                                            (.invoke Compile'compile, (Symbol'intern-1 ___lib))
                                        )
                                        (finally
                                            (Var'popThreadBindings)
                                            (try
                                                (.flush ___out)
                                                (catch IOException ___e
                                                    (.printStackTrace ___e, ___err)
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

#_private
#_stateless
(class-ns Recur
)

(§ defprotocol Expr
    #_abstract
    (#_"Object" Expr'''(§ method eval) [#_"Expr" this])
    #_abstract
    (#_"void" Expr'''(§ method emit) [#_"Expr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
    #_abstract
    (#_"boolean" Expr'''(§ method hasJavaClass) [#_"Expr" this])
    #_abstract
    (#_"Class" Expr'''(§ method getJavaClass) [#_"Expr" this])
)

#_stateless
#_abstract
(class-ns UntypedExpr (§ implements Expr)
    #_protected
    (defn #_"UntypedExpr" UntypedExpr'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"UntypedExpr" this]
        false
    )
)

(§ defprotocol IParser
    #_abstract
    (#_"Expr" IParser'''(§ method parse) [#_"IParser" this, #_"Context" ___context, #_"Object" ___form])
)

#_closure
(class-ns DefParser (§ implements IParser)
    (defn #_"DefParser" DefParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"DefParser" this, #_"Context" ___context, #_"Object" ___form]
        ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
        (let [#_"String" ___docstring nil]
            (when (and (ß (RT'count ___form) == 4) (instance? String (RT'third ___form)))
                (§ ass ___docstring (cast String (RT'third ___form)))
                (§ ass ___form (ß RT'list-3(RT'first(___form), RT'second(___form), RT'fourth(___form))))
            )
            (cond (ß RT'count(___form) > 3)
                (do
                    (throw (Util'runtimeException-1 "Too many arguments to def"))
                )
                (ß RT'count(___form) < 2)
                (do
                    (throw (Util'runtimeException-1 "Too few arguments to def"))
                )
                (not (§ instance? Symbol (RT'second ___form)))
                (do
                    (throw (Util'runtimeException-1 "First argument to def must be a Symbol"))
                )
            )
            (let [#_"Symbol" ___sym (cast' Symbol (RT'second ___form))]
                (let [#_"Var" ___v (Compiler'lookupVar-2 ___sym, true)]
                    (when (nil? ___v)
                        (throw (Util'runtimeException-1 "Can't refer to qualified var that doesn't exist"))
                    )
                    (let [#_"boolean" ___shadowsCoreMapping false]
                        (when (not (.equals (:ns ___v), (.currentNS this)))
                            (if (ß (nil? (:ns ___sym)))
                                (do
                                    (§ ass ___v (.intern (.currentNS this), ___sym))
                                    (§ ass ___shadowsCoreMapping true)
                                    (Compiler'registerVar ___v)
                                )
                                (do
                                    (throw (Util'runtimeException-1 "Can't create defs outside of current ns"))
                                )
                            )
                        )
                        (let [#_"IPersistentMap" ___mm (.meta ___sym)]
                            (let [#_"boolean" ___isDynamic (ß RT'booleanCast-1o(RT'get-2(___mm, Compiler'dynamicKey)))]
                                (when ___isDynamic
                                    (.setDynamic ___v)
                                )
                                (when (and (not ___isDynamic) (.startsWith (:name ___sym), "*") (.endsWith (:name ___sym), "*") (< 2 (.length (:name ___sym))))
                                    (.format (RT'errPrintWriter), "Warning: %1$s not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", (object-array [ ___sym, (.get Compiler'SOURCE_PATH), (.get Compiler'LINE) ]))
                                )
                                (when (RT'booleanCast-1o (RT'get-2 ___mm, Compiler'arglistsKey))
                                    (let [#_"IPersistentMap" ___vm (.meta ___v)]
                                        ;; drop quote
                                        (§ ass ___vm (cast' IPersistentMap (ß RT'assoc(___vm, Compiler'arglistsKey, RT'second(___mm.valAt(Compiler'arglistsKey))))))
                                        (.setMeta ___v, ___vm)
                                    )
                                )
                                (let [#_"Object" ___source_path (or (.get Compiler'SOURCE_PATH) "NO_SOURCE_FILE")]
                                    (§ ass ___mm (cast' IPersistentMap (ß RT'assoc(___mm, RT'LINE_KEY, Compiler'LINE.get()).assoc(RT'COLUMN_KEY, Compiler'COLUMN.get()).assoc(RT'FILE_KEY, ___source_path))))
                                    (when (some? ___docstring)
                                        (§ ass ___mm (cast' IPersistentMap (RT'assoc ___mm, RT'DOC_KEY, ___docstring)))
                                    )
                                    (§ ass ___mm (cast' IPersistentMap (Compiler'elideMeta ___mm)))
                                    (let [#_"Expr" ___meta (if (zero? (count ___mm)) nil (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), ___mm))]
                                        (DefExpr'new (cast String (.deref Compiler'SOURCE)), (Compiler'lineDeref), (Compiler'columnDeref), ___v, (Compiler'analyze-3 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (RT'third ___form), (:name (:sym ___v))), ___meta, (ß RT'count(___form) == 3), ___isDynamic, ___shadowsCoreMapping)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr (§ implements Expr)
    (def #_"Method" DefExpr'bindRootMethod (Method/getMethod "void bindRoot(Object)"))
    (def #_"Method" DefExpr'setTagMethod (Method/getMethod "void setTag(cloiure.lang.Symbol)"))
    (def #_"Method" DefExpr'setMetaMethod (Method/getMethod "void setMeta(cloiure.lang.IPersistentMap)"))
    (def #_"Method" DefExpr'setDynamicMethod (Method/getMethod "cloiure.lang.Var setDynamic(boolean)"))
    (def #_"Method" DefExpr'symintern (Method/getMethod "cloiure.lang.Symbol intern(String, String)"))
    (def #_"Method" DefExpr'internVar (Method/getMethod "cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

    (defn- #_"DefExpr" DefExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Expr" :init nil
            #_"Expr" :meta nil
            #_"boolean" :initProvided false
            #_"boolean" :isDynamic false
            #_"boolean" :shadowsCoreMapping false
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"DefExpr" DefExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Var" ___var, #_"Expr" ___init, #_"Expr" ___meta, #_"boolean" ___initProvided, #_"boolean" ___isDynamic, #_"boolean" ___shadowsCoreMapping]
        (let [this (DefExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:var this) ___var)
            (§ ass (:init this) ___init)
            (§ ass (:meta this) ___meta)
            (§ ass (:isDynamic this) ___isDynamic)
            (§ ass (:shadowsCoreMapping this) ___shadowsCoreMapping)
            (§ ass (:initProvided this) ___initProvided)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method includesExplicitMetadata) [#_"DefExpr" this, #_"MapExpr" ___expr]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals ___expr).count()) [(+ ___i 2)]
            (let [#_"Keyword" ___k (:k (cast' KeywordExpr (.nth (:keyvals ___expr), ___i)))]
                (when (and (ß ___k != RT'FILE_KEY) (ß ___k != RT'DECLARED_KEY) (ß ___k != RT'LINE_KEY) (ß ___k != RT'COLUMN_KEY))
                    (§ return true)
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"DefExpr" this]
        (try
            (when (:initProvided this)
                (ß (:var this).bindRoot((:init this).eval()))
            )
            (when (some? (:meta this))
                (let [#_"IPersistentMap" ___metaMap (cast' IPersistentMap (.eval (:meta this)))]
                    (when (or (:initProvided this) true) ;; includesExplicitMetadata((MapExpr) meta)
                        (.setMeta (:var this), ___metaMap)
                    )
                )
            )
            (.setDynamic (:var this), (:isDynamic this))
            (catch Throwable ___e
                (if (not (§ instance? CompilerException ___e))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (cast' CompilerException ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"DefExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitVar ___objx, ___gen, (:var this))

        (when (:shadowsCoreMapping this)
            (.dup ___gen)
            (.getField ___gen, Compiler'VAR_TYPE, "ns", Compiler'NS_TYPE)
            (.swap ___gen)
            (.dup ___gen)
            (.getField ___gen, Compiler'VAR_TYPE, "sym", Compiler'SYMBOL_TYPE)
            (.swap ___gen)
            (.invokeVirtual ___gen, Compiler'NS_TYPE, DefExpr'internVar)
        )

        (when (:isDynamic this)
            (.push ___gen, (:isDynamic this))
            (.invokeVirtual ___gen, Compiler'VAR_TYPE, setDynamicMethod)
        )
        (when (some? (:meta this))
            (when (or (:initProvided this) true) ;; includesExplicitMetadata((MapExpr) meta)
                (.dup ___gen)
                (ß (:meta this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.checkCast ___gen, Compiler'IPERSISTENTMAP_TYPE)
                (.invokeVirtual ___gen, Compiler'VAR_TYPE, setMetaMethod)
            )
        )
        (when (:initProvided this)
            (.dup ___gen)
            (if (§ instance? FnExpr (:init this))
                (do
                    (ß (cast' FnExpr (:init this)).emitForDefn(___objx, ___gen))
                )
                (do
                    (ß (:init this).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
            )
            (.invokeVirtual ___gen, Compiler'VAR_TYPE, bindRootMethod)
        )

        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"DefExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"DefExpr" this]
        (§ class Var)
    )
)

#_closure
(class-ns AssignParser (§ implements IParser)
    (defn #_"AssignParser" AssignParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"AssignParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            (when (ß RT'length(___form) != 3)
                (throw (IllegalArgumentException. "Malformed assignment, expecting (set! target val)"))
            )
            (let [#_"Expr" ___target (ß Compiler'analyze-2(:Context'EXPRESSION, RT'second(___form)))]
                (when (not (§ instance? AssignableExpr ___target))
                    (throw (IllegalArgumentException. "Invalid assignment target"))
                )
                (ß AssignExpr'new((cast' AssignableExpr ___target), Compiler'analyze-2(:Context'EXPRESSION, RT'third(___form))))
            )
        )
    )
)

(class-ns AssignExpr (§ implements Expr)
    (defn- #_"AssignExpr" AssignExpr'init []
        (hash-map
            #_"AssignableExpr" :target nil
            #_"Expr" :val nil
        )
    )

    (defn #_"AssignExpr" AssignExpr'new [#_"AssignableExpr" ___target, #_"Expr" ___val]
        (let [this (AssignExpr'init)]
            (§ ass (:target this) ___target)
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"AssignExpr" this]
        (.evalAssign (:target this), (:val this))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"AssignExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emitAssign(___context, ___objx, ___gen, (:val this)))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"AssignExpr" this]
        (.hasJavaClass (:val this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"AssignExpr" this]
        (.getJavaClass (:val this))
    )
)

(class-ns VarExpr (§ implements Expr, AssignableExpr)
    (def #_"Method" VarExpr'getMethod (Method/getMethod "Object get()"))
    (def #_"Method" VarExpr'setMethod (Method/getMethod "Object set(Object)"))

    (defn- #_"VarExpr" VarExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"VarExpr" VarExpr'new [#_"Var" ___var, #_"Symbol" ___tag]
        (let [this (VarExpr'init)]
            (§ ass (:var this) ___var)
            (§ ass (:tag this) (or ___tag (.getTag ___var)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"VarExpr" this]
        (.deref (:var this))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitVarValue ___objx, ___gen, (:var this))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"VarExpr" this]
        (some? (:tag this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"VarExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"VarExpr" this, #_"Expr" ___val]
        (.set (:var this), (.eval ___val))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (.emitVar ___objx, ___gen, (:var this))
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (.invokeVirtual ___gen, Compiler'VAR_TYPE, VarExpr'setMethod)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )
)

#_closure
(class-ns TheVarParser (§ implements IParser)
    (defn #_"TheVarParser" TheVarParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"TheVarParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"Symbol" ___sym (cast' Symbol (RT'second ___form))]
            (let [#_"Var" ___v (Compiler'lookupVar-2 ___sym, false)]
                (when (some? ___v)
                    (§ return (TheVarExpr'new ___v))
                )
                (throw (Util'runtimeException-1 (str "Unable to resolve var: " ___sym " in this context")))
            )
        )
    )
)

(class-ns TheVarExpr (§ implements Expr)
    (defn- #_"TheVarExpr" TheVarExpr'init []
        (hash-map
            #_"Var" :var nil
        )
    )

    (defn #_"TheVarExpr" TheVarExpr'new [#_"Var" ___var]
        (let [this (TheVarExpr'init)]
            (§ ass (:var this) ___var)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"TheVarExpr" this]
        (:var this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"TheVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitVar ___objx, ___gen, (:var this))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"TheVarExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"TheVarExpr" this]
        (§ class Var)
    )
)

(class-ns KeywordExpr (§ extends LiteralExpr)
    (defn- #_"KeywordExpr" KeywordExpr'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordExpr" KeywordExpr'new [#_"Keyword" ___k]
        (let [this (merge (LiteralExpr'new) (KeywordExpr'init))]
            (§ ass (:k this) ___k)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"KeywordExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitKeyword ___objx, ___gen, (:k this))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"KeywordExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"KeywordExpr" this]
        (§ class Keyword)
    )
)

#_closure
(class-ns ImportParser (§ implements IParser)
    (defn #_"ImportParser" ImportParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ImportParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß ImportExpr'new((cast String (RT'second ___form))))
    )
)

(class-ns ImportExpr (§ implements Expr)
    (def #_"Method" ImportExpr'forNameMethod (Method/getMethod "Class classForNameNonLoading(String)"))
    (def #_"Method" ImportExpr'importClassMethod (Method/getMethod "Class importClass(Class)"))
    (def #_"Method" ImportExpr'derefMethod (Method/getMethod "Object deref()"))

    (defn- #_"ImportExpr" ImportExpr'init []
        (hash-map
            #_"String" :c nil
        )
    )

    (defn #_"ImportExpr" ImportExpr'new [#_"String" ___c]
        (let [this (ImportExpr'init)]
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ImportExpr" this]
        (let [#_"Namespace" ___ns (cast' Namespace (.deref RT'CURRENT_NS))]
            (ß ___ns.importClass(RT'classForNameNonLoading((:c this))))
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ImportExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.getStatic ___gen, Compiler'RT_TYPE, "CURRENT_NS", Compiler'VAR_TYPE)
        (.invokeVirtual ___gen, Compiler'VAR_TYPE, ImportExpr'derefMethod)
        (.checkCast ___gen, Compiler'NS_TYPE)
        (.push ___gen, (:c this))
        (.invokeStatic ___gen, Compiler'RT_TYPE, ImportExpr'forNameMethod)
        (.invokeVirtual ___gen, Compiler'NS_TYPE, importClassMethod)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ImportExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

#_stateless
#_abstract
(class-ns LiteralExpr (§ implements Expr)
    #_protected
    (defn #_"LiteralExpr" LiteralExpr'new []
        (hash-map)
    )

    #_abstract
    (§ defn #_"Object" (§ method val) [#_"LiteralExpr" this])

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LiteralExpr" this]
        (.val this)
    )
)

(§ defprotocol AssignableExpr
    #_abstract
    (#_"Object" AssignableExpr'''(§ method evalAssign) [#_"AssignableExpr" this, #_"Expr" ___val])
    #_abstract
    (#_"void" AssignableExpr'''(§ method emitAssign) [#_"AssignableExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val])
)

(§ defprotocol MaybePrimitiveExpr #_(§ extends Expr)
    #_abstract
    (#_"boolean" MaybePrimitiveExpr'''(§ method canEmitPrimitive) [#_"MaybePrimitiveExpr" this])
    #_abstract
    (#_"void" MaybePrimitiveExpr'''(§ method emitUnboxed) [#_"MaybePrimitiveExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
)

#_closure
(class-ns HostParser (§ implements IParser)
    (defn #_"HostParser" HostParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"HostParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            ;; (. x fieldname-sym) or
            ;; (. x 0-ary-method)
            ;; (. x methodname-sym args+)
            ;; (. x (methodname-sym args?))
            (when (ß RT'length(___form) < 3)
                (throw (IllegalArgumentException. "Malformed member expression, expecting (. target member ...)"))
            )
            ;; determine static or instance
            ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
            (let [#_"int" ___line (Compiler'lineDeref)]
                (let [#_"int" ___column (Compiler'columnDeref)]
                    (let [#_"String" ___source (cast String (.deref Compiler'SOURCE))]
                        (let [#_"Class" ___c (ß maybeClass(RT'second(___form), false))]
                            ;; at this point c will be non-null if static
                            (let [#_"Expr" ___instance nil]
                                (when (nil? ___c)
                                    (§ ass ___instance (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (RT'second ___form)))
                                )

                                (let [#_"boolean" ___maybeField (and (ß RT'length(___form) == 3) (§ instance? Symbol (RT'third ___form)))]
                                    (when (and ___maybeField (ß (:name (cast' Symbol (RT'third ___form))).charAt(0) != \-))
                                        (let [#_"Symbol" ___sym (cast' Symbol (RT'third ___form))]
                                            (cond (some? ___c)
                                                (do
                                                    (§ ass ___maybeField (zero? (ß Reflector'getMethods(___c, 0, Compiler'munge((:name ___sym)), true).size())))
                                                )
                                                (and (some? ___instance) (.hasJavaClass ___instance) (some? (.getJavaClass ___instance)))
                                                (do
                                                    (§ ass ___maybeField (zero? (ß Reflector'getMethods((.getJavaClass ___instance), 0, Compiler'munge((:name ___sym)), false).size())))
                                                )
                                            )
                                        )
                                    )

                                    (if ___maybeField ;; field
                                        (do
                                            (let [#_"Symbol" ___sym (if (ß (:name (cast' Symbol (RT'third ___form))).charAt(0) == \-) (ß Symbol'intern-1((:name (cast' Symbol (RT'third ___form))).substring(1))) (cast' Symbol (RT'third ___form)))]
                                                (let [#_"Symbol" ___tag (Compiler'tagOf ___form)]
                                                    (if (some? ___c)
                                                        (do
                                                            (ß StaticFieldExpr'new(___line, ___column, ___c, Compiler'munge((:name ___sym)), ___tag))
                                                        )
                                                        (do
                                                            (ß InstanceFieldExpr'new(___line, ___column, ___instance, Compiler'munge((:name ___sym)), ___tag, ((:name (cast' Symbol (RT'third ___form))).charAt(0) == \-)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (let [#_"ISeq" ___call (cast' ISeq (if (§ instance? ISeq (RT'third ___form)) (RT'third ___form) (ß RT'next(RT'next(___form)))))]
                                                (when (not (§ instance? Symbol (RT'first ___call)))
                                                    (throw (IllegalArgumentException. "Malformed member expression"))
                                                )
                                                (let [#_"Symbol" ___sym (cast' Symbol (RT'first ___call))]
                                                    (let [#_"Symbol" ___tag (Compiler'tagOf ___form)]
                                                        (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                                                            (let [#_"boolean" ___tailPosition (Compiler'inTailCall ___context)]
                                                                (loop-when-recur [#_"ISeq" ___s (RT'next ___call)] (some? ___s) [(next ___s)]
                                                                    (§ ass ___args (.cons ___args, (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (first ___s))))
                                                                )
                                                                (if (some? ___c)
                                                                    (do
                                                                        (ß StaticMethodExpr'new(___source, ___line, ___column, ___tag, ___c, Compiler'munge((:name ___sym)), ___args, ___tailPosition))
                                                                    )
                                                                    (do
                                                                        (ß InstanceMethodExpr'new(___source, ___line, ___column, ___tag, ___instance, Compiler'munge((:name ___sym)), ___args, ___tailPosition))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
#_abstract
(class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
    #_protected
    (defn #_"HostExpr" HostExpr'new []
        (hash-map)
    )

    (def #_"Type" HostExpr'BOOLEAN_TYPE (Type/getType Boolean))
    (def #_"Type" HostExpr'CHAR_TYPE (Type/getType Character))
    (def #_"Type" HostExpr'INTEGER_TYPE (Type/getType Integer))
    (def #_"Type" HostExpr'LONG_TYPE (Type/getType Long))
    (def #_"Type" HostExpr'FLOAT_TYPE (Type/getType Float))
    (def #_"Type" HostExpr'DOUBLE_TYPE (Type/getType Double))
    (def #_"Type" HostExpr'SHORT_TYPE (Type/getType Short))
    (def #_"Type" HostExpr'BYTE_TYPE (Type/getType Byte))
    (def #_"Type" HostExpr'NUMBER_TYPE (Type/getType Number))

    (def #_"Method" HostExpr'charValueMethod (Method/getMethod "char charValue()"))
    (def #_"Method" HostExpr'booleanValueMethod (Method/getMethod "boolean booleanValue()"))

    (def #_"Method" HostExpr'charValueOfMethod (Method/getMethod "Character valueOf(char)"))
    (def #_"Method" HostExpr'intValueOfMethod (Method/getMethod "Integer valueOf(int)"))
    (def #_"Method" HostExpr'longValueOfMethod (Method/getMethod "Long valueOf(long)"))
    (def #_"Method" HostExpr'floatValueOfMethod (Method/getMethod "Float valueOf(float)"))
    (def #_"Method" HostExpr'doubleValueOfMethod (Method/getMethod "Double valueOf(double)"))
    (def #_"Method" HostExpr'shortValueOfMethod (Method/getMethod "Short valueOf(short)"))
    (def #_"Method" HostExpr'byteValueOfMethod (Method/getMethod "Byte valueOf(byte)"))

    (def #_"Method" HostExpr'intValueMethod (Method/getMethod "int intValue()"))
    (def #_"Method" HostExpr'longValueMethod (Method/getMethod "long longValue()"))
    (def #_"Method" HostExpr'floatValueMethod (Method/getMethod "float floatValue()"))
    (def #_"Method" HostExpr'doubleValueMethod (Method/getMethod "double doubleValue()"))
    (def #_"Method" HostExpr'byteValueMethod (Method/getMethod "byte byteValue()"))
    (def #_"Method" HostExpr'shortValueMethod (Method/getMethod "short shortValue()"))

    (def #_"Method" HostExpr'fromIntMethod (Method/getMethod "cloiure.lang.Num from(int)"))
    (def #_"Method" HostExpr'fromLongMethod (Method/getMethod "cloiure.lang.Num from(long)"))
    (def #_"Method" HostExpr'fromDoubleMethod (Method/getMethod "cloiure.lang.Num from(double)"))

    (defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___returnType]
        (when (.isPrimitive ___returnType)
            (cond (= ___returnType Boolean/TYPE)
                (do
                    (let [#_"Label" ___falseLabel (.newLabel ___gen)]
                        (let [#_"Label" ___endLabel (.newLabel ___gen)]
                            (.ifZCmp ___gen, GeneratorAdapter/EQ, ___falseLabel)
                            (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE)
                            (.goTo ___gen, ___endLabel)
                            (.mark ___gen, ___falseLabel)
                            (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                            (.mark ___gen, ___endLabel)
                        )
                    )
                )
                (= ___returnType Void/TYPE)
                (do
                    (ß Compiler'NIL_EXPR.emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (= ___returnType Character/TYPE)
                (do
                    (.invokeStatic ___gen, HostExpr'CHAR_TYPE, HostExpr'charValueOfMethod)
                )
                :else
                (do
                    (cond (= ___returnType Integer/TYPE)
                        (do
                            (.invokeStatic ___gen, HostExpr'INTEGER_TYPE, HostExpr'intValueOfMethod)
                        )
                        (= ___returnType Float/TYPE)
                        (do
                            (.invokeStatic ___gen, HostExpr'FLOAT_TYPE, HostExpr'floatValueOfMethod)
                        )
                        (= ___returnType Double/TYPE)
                        (do
                            (.invokeStatic ___gen, HostExpr'DOUBLE_TYPE, HostExpr'doubleValueOfMethod)
                        )
                        (= ___returnType Long/TYPE)
                        (do
                            (ß ___gen.invokeStatic(Compiler'NUMBERS_TYPE, Method/getMethod("Number num(long)")))
                        )
                        (= ___returnType Byte/TYPE)
                        (do
                            (.invokeStatic ___gen, HostExpr'BYTE_TYPE, HostExpr'byteValueOfMethod)
                        )
                        (= ___returnType Short/TYPE)
                        (do
                            (.invokeStatic ___gen, HostExpr'SHORT_TYPE, HostExpr'shortValueOfMethod)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___paramType]
        (if (.isPrimitive ___paramType)
            (do
                (cond (= ___paramType Boolean/TYPE)
                    (do
                        (.checkCast ___gen, HostExpr'BOOLEAN_TYPE)
                        (.invokeVirtual ___gen, HostExpr'BOOLEAN_TYPE, HostExpr'booleanValueMethod)
                    )
                    (= ___paramType Character/TYPE)
                    (do
                        (.checkCast ___gen, HostExpr'CHAR_TYPE)
                        (.invokeVirtual ___gen, HostExpr'CHAR_TYPE, HostExpr'charValueMethod)
                    )
                    :else
                    (do
                        (let [#_"Method" ___m nil]
                            (.checkCast ___gen, HostExpr'NUMBER_TYPE)
                            (if (ß RT'booleanCast-1o(RT'UNCHECKED_MATH.deref()))
                                (do
                                    (cond (= ___paramType Integer/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "int uncheckedIntCast(Object)"))
                                        )
                                        (= ___paramType Float/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "float uncheckedFloatCast(Object)"))
                                        )
                                        (= ___paramType Double/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "double uncheckedDoubleCast(Object)"))
                                        )
                                        (= ___paramType Long/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "long uncheckedLongCast(Object)"))
                                        )
                                        (= ___paramType Byte/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "byte uncheckedByteCast(Object)"))
                                        )
                                        (= ___paramType Short/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "short uncheckedShortCast(Object)"))
                                        )
                                    )
                                )
                                (do
                                    (cond (= ___paramType Integer/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "int intCast(Object)"))
                                        )
                                        (= ___paramType Float/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "float floatCast(Object)"))
                                        )
                                        (= ___paramType Double/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "double doubleCast(Object)"))
                                        )
                                        (= ___paramType Long/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "long longCast(Object)"))
                                        )
                                        (= ___paramType Byte/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "byte byteCast(Object)"))
                                        )
                                        (= ___paramType Short/TYPE)
                                        (do
                                            (§ ass ___m (Method/getMethod "short shortCast(Object)"))
                                        )
                                    )
                                )
                            )
                            (.invokeStatic ___gen, Compiler'RT_TYPE, ___m)
                        )
                    )
                )
            )
            (do
                (ß ___gen.checkCast(Type/getType(___paramType)))
            )
        )
        nil
    )

    (defn #_"Class" HostExpr'maybeClass [#_"Object" ___form, #_"boolean" ___stringOk]
        (when (instance? Class ___form)
            (§ return (cast Class ___form))
        )
        (let [#_"Class" ___c nil]
            (cond (§ instance? Symbol ___form)
                (do
                    (let [#_"Symbol" ___sym (cast' Symbol ___form)]
                        (when (ß (nil? (:ns ___sym))) ;; if ns-qualified can't be classname
                            (when (ß Util'equals(___sym, Compiler'COMPILE_STUB_SYM.get()))
                                (§ return (cast Class (.get Compiler'COMPILE_STUB_CLASS)))
                            )
                            (if (or (pos? (.indexOf (:name ___sym), \.)) (ß (:name ___sym).charAt(0) == \[))
                                (do
                                    (§ ass ___c (RT'classForNameNonLoading (:name ___sym)))
                                )
                                (do
                                    (let [#_"Object" ___o (ß (.currentNS this).getMapping(___sym))]
                                        (cond (instance? Class ___o)
                                            (do
                                                (§ ass ___c (cast Class ___o))
                                            )
                                            (and (some? (.deref Compiler'LOCAL_ENV)) (.containsKey (cast java.util.Map (.deref Compiler'LOCAL_ENV)), ___form))
                                            (do
                                                (§ return nil)
                                            )
                                            :else
                                            (do
                                                (try
                                                    (§ ass ___c (RT'classForNameNonLoading (:name ___sym)))
                                                    (catch Exception ___e
                                                        ;; aargh
                                                        ;; leave c set to nil -> return nil
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (and ___stringOk (instance? String ___form))
                (do
                    (§ ass ___c (RT'classForNameNonLoading (cast String ___form)))
                )
            )
            ___c
        )
    )

    (defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" ___sym]
        (let [#_"Class" ___c (Compiler'primClass-1s ___sym)]
            (cond (some? ___c)
                (do
                    (§ return ___c)
                )
                (.equals (:name ___sym), "objects")
                (do
                    (§ ass ___c (§ class Object[]))
                )
                (.equals (:name ___sym), "ints")
                (do
                    (§ ass ___c (§ class int[]))
                )
                (.equals (:name ___sym), "longs")
                (do
                    (§ ass ___c (§ class long[]))
                )
                (.equals (:name ___sym), "floats")
                (do
                    (§ ass ___c (§ class float[]))
                )
                (.equals (:name ___sym), "doubles")
                (do
                    (§ ass ___c (§ class double[]))
                )
                (.equals (:name ___sym), "chars")
                (do
                    (§ ass ___c (§ class char[]))
                )
                (.equals (:name ___sym), "shorts")
                (do
                    (§ ass ___c (§ class short[]))
                )
                (.equals (:name ___sym), "bytes")
                (do
                    (§ ass ___c (§ class byte[]))
                )
                (.equals (:name ___sym), "booleans")
                (do
                    (§ ass ___c (§ class boolean[]))
                )
            )
            ___c
        )
    )

    (defn #_"Class" HostExpr'tagToClass [#_"Object" ___tag]
        (let [#_"Class" ___c nil]
            (when (§ instance? Symbol ___tag)
                (let [#_"Symbol" ___sym (cast' Symbol ___tag)]
                    (when (ß (nil? (:ns ___sym))) ;; if ns-qualified can't be classname
                        (§ ass ___c (maybeSpecialTag ___sym))
                    )
                )
            )
            (when (nil? ___c)
                (§ ass ___c (maybeClass ___tag, true))
            )
            (when (some? ___c)
                (§ return ___c)
            )
            (throw (IllegalArgumentException. (str "Unable to resolve classname: " ___tag)))
        )
    )
)

#_stateless
#_abstract
(class-ns FieldExpr (§ extends HostExpr)
    #_protected
    (defn #_"FieldExpr" FieldExpr'new []
        (HostExpr'new)
    )

)

(class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (Method/getMethod "Object invokeNoArgInstanceMember(Object, String, boolean)"))
    (def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (Method/getMethod "Object setInstanceField(Object, String, Object)"))

    (defn- #_"InstanceFieldExpr" InstanceFieldExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"Class" :targetClass nil
            #_"java.lang.reflect.Field" :field nil
            #_"String" :fieldName nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :requireField false

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceFieldExpr" InstanceFieldExpr'new [#_"int" ___line, #_"int" ___column, #_"Expr" ___target, #_"String" ___fieldName, #_"Symbol" ___tag, #_"boolean" ___requireField]
        (let [this (merge (FieldExpr'new) (InstanceFieldExpr'init))]
            (§ ass (:target this) ___target)
            (§ ass (:targetClass this) (when (.hasJavaClass ___target) (.getJavaClass ___target)))
            (§ ass (:field this) (when (some? (:targetClass this)) (Reflector'getField (:targetClass this), ___fieldName, false)))
            (§ ass (:fieldName this) ___fieldName)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:requireField this) ___requireField)

            (when (and (nil? (:field this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                (if (nil? (:targetClass this))
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, ___fieldName ])))
                    )
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, ___fieldName, (.getName (:targetClass this)) ])))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceFieldExpr" this]
        (ß Reflector'invokeNoArgInstanceMember-3((:target this).eval(), (:fieldName this), (:requireField this)))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceFieldExpr" this]
        (and (some? (:targetClass this)) (some? (:field this)) (Util'isPrimitive (.getType (:field this))))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.checkCast(Compiler'getType((:targetClass this))))
                (ß ___gen.getField(Compiler'getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.checkCast(Compiler'getType((:targetClass this))))
                (ß ___gen.getField(Compiler'getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
                (ß HostExpr'emitBoxReturn(___objx, ___gen, (:field this).getType()))
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.push ___gen, (:fieldName this))
                (.push ___gen, (:requireField this))
                (.invokeStatic ___gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'invokeNoArgInstanceMember)
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceFieldExpr" this]
        (or (some? (:field this)) (some? (:tag this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"InstanceFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setInstanceField((:target this).eval(), (:fieldName this), (.eval ___val)))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(Compiler'getType((:targetClass this))))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.dupX1 ___gen)
                (ß HostExpr'emitUnboxArg(___objx, ___gen, (:field this).getType()))
                (ß ___gen.putField(Compiler'getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.push ___gen, (:fieldName this))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.invokeStatic ___gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod)
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )
)

(class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (defn- #_"StaticFieldExpr" StaticFieldExpr'init []
        (hash-map
            #_"String" :fieldName nil
            #_"Class" :c nil
            #_"java.lang.reflect.Field" :field nil
            #_"Symbol" :tag nil

            #_"int" :line 0
            #_"int" :column 0

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticFieldExpr" StaticFieldExpr'new [#_"int" ___line, #_"int" ___column, #_"Class" ___c, #_"String" ___fieldName, #_"Symbol" ___tag]
        (let [this (merge (FieldExpr'new) (StaticFieldExpr'init))]
            (§ ass (:fieldName this) ___fieldName)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:c this) ___c)
            (try
                (§ ass (:field this) (.getField ___c, ___fieldName))
                (catch NoSuchFieldException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticFieldExpr" this]
        (Reflector'getStaticField-2c (:c this), (:fieldName this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticFieldExpr" this]
        (ß Util'isPrimitive((:field this).getType()))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
        (ß ___gen.getStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

        (ß ___gen.getStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        (ß HostExpr'emitBoxReturn(___objx, ___gen, (:field this).getType()))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticFieldExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"StaticFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setStaticField-3c((:c this), (:fieldName this), (.eval ___val)))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
        (.dup ___gen)
        (ß HostExpr'emitUnboxArg(___objx, ___gen, (:field this).getType()))
        (ß ___gen.putStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )
)

#_stateless
#_abstract
(class-ns MethodExpr (§ extends HostExpr)
    #_protected
    (defn #_"MethodExpr" MethodExpr'new []
        (HostExpr'new)
    )

    (defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" ___args, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.push ___gen, (count ___args))
        (.newArray ___gen, Compiler'OBJECT_TYPE)
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
            (.dup ___gen)
            (.push ___gen, ___i)
            (ß (cast' Expr (.nth ___args, ___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
            (.arrayStore ___gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    (defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class[]" ___parameterTypes, #_"IPersistentVector" ___args]
        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___parameterTypes)) [(inc ___i)]
            (let [#_"Expr" ___e (cast' Expr (.nth ___args, ___i))]
                (try
                    (let [#_"Class" ___primc (Compiler'maybePrimitiveType ___e)]
                        (cond (ß ___primc == ___parameterTypes[___i])
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (cast' MaybePrimitiveExpr ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                            )
                            (and (ß ___primc == Integer/TYPE) (ß ___parameterTypes[___i] == Long/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (cast' MaybePrimitiveExpr ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (.visitInsn ___gen, Opcodes/I2L)
                                )
                            )
                            (and (ß ___primc == Long/TYPE) (ß ___parameterTypes[___i] == Integer/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (cast' MaybePrimitiveExpr ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (if (ß RT'booleanCast-1o(RT'UNCHECKED_MATH.deref()))
                                        (do
                                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int uncheckedIntCast(long)")))
                                        )
                                        (do
                                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                                        )
                                    )
                                )
                            )
                            (and (ß ___primc == Float/TYPE) (ß ___parameterTypes[___i] == Double/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (cast' MaybePrimitiveExpr ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (.visitInsn ___gen, Opcodes/F2D)
                                )
                            )
                            (and (ß ___primc == Double/TYPE) (ß ___parameterTypes[___i] == Float/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (cast' MaybePrimitiveExpr ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (.visitInsn ___gen, Opcodes/D2F)
                                )
                            )
                            :else
                            (do
                                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (ß HostExpr'emitUnboxArg(___objx, ___gen, ___parameterTypes[___i]))
                            )
                        )
                    )
                    (catch Exception ___e1
                        (throw (Util'sneakyThrow ___e1))
                    )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr (§ extends MethodExpr)
    (def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (Method/getMethod "Object invokeInstanceMethod(Object, String, Object[])"))

    (defn- #_"InstanceMethodExpr" InstanceMethodExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
            #_"java.lang.reflect.Method" :method nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceMethodExpr" InstanceMethodExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___target, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (merge (MethodExpr'new) (InstanceMethodExpr'init))]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:args this) ___args)
            (§ ass (:methodName this) ___methodName)
            (§ ass (:target this) ___target)
            (§ ass (:tag this) ___tag)
            (§ ass (:tailPosition this) ___tailPosition)
            (if (and (.hasJavaClass ___target) (some? (.getJavaClass ___target)))
                (do
                    (let [#_"List" ___methods (ß Reflector'getMethods((.getJavaClass ___target), (count ___args), ___methodName, false))]
                        (if (.isEmpty ___methods)
                            (do
                                (§ ass (:method this) nil)
                                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName, (.getName (.getJavaClass ___target)) ])))
                                )
                            )
                            (do
                                (let [#_"int" ___methodidx 0]
                                    (when (ß (.size ___methods) > 1)
                                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___methods)) [(inc ___i)]
                                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                                        (.add ___params, (.getParameterTypes ___m))
                                                        (.add ___rets, (.getReturnType ___m))
                                                    )
                                                )
                                                (§ ass ___methodidx (Compiler'getMatchingParams ___methodName, ___params, ___args, ___rets))
                                            )
                                        )
                                    )
                                    (let [#_"java.lang.reflect.Method" ___m (cast java.lang.reflect.Method (when (>= ___methodidx 0) (.get ___methods, ___methodidx)))]
                                        (when (and (some? ___m) (not (Modifier/isPublic (.getModifiers (.getDeclaringClass ___m)))))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (§ ass ___m (ß Reflector'getAsMethodOfPublicBase((.getDeclaringClass ___m), ___m)))
                                        )
                                        (§ ass (:method this) ___m)
                                        (when (and (nil? (:method this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                            (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName, (.getName (.getJavaClass ___target)), (Compiler'getTypeStringForArgs ___args) ])))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (§ ass (:method this) nil)
                    (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName ])))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" ___targetval (.eval (:target this))]
                (let [#_"Object[]" ___argvals (make-array Object (count (:args this)))]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                        (§ ass (§ aget ___argvals ___i) (.eval (cast' Expr (.nth (:args this), ___i))))
                    )
                    (when (some? (:method this))
                        (let [#_"LinkedList" ___ms (LinkedList.)]
                            (.add ___ms, (:method this))
                            (§ return (Reflector'invokeMatchingMethod (:methodName this), ___ms, ___targetval, ___argvals))
                        )
                    )
                    (Reflector'invokeInstanceMethod ___targetval, (:methodName this), ___argvals)
                )
            )
            (catch Throwable ___e
                (if (not (§ instance? CompilerException ___e))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (cast' CompilerException ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (let [#_"Type" ___type (Type/getType (.getDeclaringClass (:method this)))]
                    (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (.checkCast ___gen, ___type)
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                    (when (and (:tailPosition this) (not (:canBeDirect ___objx)))
                        (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                            (.emitClearThis ___method, ___gen)
                        )
                    )
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (if (ß (:method this).getDeclaringClass().isInterface())
                            (do
                                (.invokeInterface ___gen, ___type, ___m)
                            )
                            (do
                                (.invokeVirtual ___gen, ___type, ___m)
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (let [#_"Type" ___type (Type/getType (.getDeclaringClass (:method this)))]
                    (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (.checkCast ___gen, ___type)
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                    (when (ß ___context == :Context'RETURN)
                        (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                            (.emitClearLocals ___method, ___gen)
                        )
                    )
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (if (ß (:method this).getDeclaringClass().isInterface())
                            (do
                                (.invokeInterface ___gen, ___type, ___m)
                            )
                            (do
                                (.invokeVirtual ___gen, ___type, ___m)
                            )
                        )
                        (ß HostExpr'emitBoxReturn(___objx, ___gen, (:method this).getReturnType()))
                    )
                )
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.push ___gen, (:methodName this))
                (ß emitArgsAsArray((:args this), ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (.invokeStatic ___gen, Compiler'REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod)
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this)))))
        )
        (:jc this)
    )
)

(class-ns StaticMethodExpr (§ extends MethodExpr)
    (def #_"Method" StaticMethodExpr'forNameMethod (Method/getMethod "Class classForName(String)"))
    (def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (Method/getMethod "Object invokeStaticMethod(Class, String, Object[])"))
    (§ def #_"Keyword" StaticMethodExpr'warnOnBoxedKeyword (Keyword'intern-1 "warn-on-boxed"))

    (defn- #_"StaticMethodExpr" StaticMethodExpr'init []
        (hash-map
            #_"Class" :c nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
            #_"java.lang.reflect.Method" :method nil
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticMethodExpr" StaticMethodExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Class" ___c, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (merge (MethodExpr'new) (StaticMethodExpr'init))]
            (§ ass (:c this) ___c)
            (§ ass (:methodName this) ___methodName)
            (§ ass (:args this) ___args)
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:tailPosition this) ___tailPosition)

            (let [#_"List" ___methods (ß Reflector'getMethods(___c, (count ___args), ___methodName, true))]
                (when (.isEmpty ___methods)
                    (throw (IllegalArgumentException. (str "No matching method: " ___methodName)))
                )

                (let [#_"int" ___methodidx 0]
                    (when (ß (.size ___methods) > 1)
                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___methods)) [(inc ___i)]
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                        (.add ___params, (.getParameterTypes ___m))
                                        (.add ___rets, (.getReturnType ___m))
                                    )
                                )
                                (§ ass ___methodidx (Compiler'getMatchingParams ___methodName, ___params, ___args, ___rets))
                            )
                        )
                    )
                    (§ ass (:method this) (cast java.lang.reflect.Method (when (>= ___methodidx 0) (.get ___methods, ___methodidx))))
                    (when (and (nil? (:method this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName, (.getName ___c), (Compiler'getTypeStringForArgs ___args) ])))
                    )
                    (when (and (some? (:method this)) (ß warnOnBoxedKeyword.equals(RT'UNCHECKED_MATH.deref())) (StaticMethodExpr'isBoxedMath (:method this)))
                        (ß RT'errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, (.toString (:method this)) ])))
                    )
                    this
                )
            )
        )
    )

    (defn #_"boolean" StaticMethodExpr'isBoxedMath [#_"java.lang.reflect.Method" ___m]
        (let [#_"Class" ___c (.getDeclaringClass ___m)]
            (when (.equals ___c, (§ class Numbers))
                (let [#_"Class[]" ___argTypes (.getParameterTypes ___m)]
                    (doseq [#_"Class" ___argType ___argTypes]
                        (when (or (.equals ___argType, Object) (.equals ___argType, Number))
                            (§ return true)
                        )
                    )
                )
            )
            false
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" ___argvals (make-array Object (count (:args this)))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                    (§ ass (§ aget ___argvals ___i) (.eval (cast' Expr (.nth (:args this), ___i))))
                )
                (when (some? (:method this))
                    (let [#_"LinkedList" ___ms (LinkedList.)]
                        (.add ___ms, (:method this))
                        (§ return (Reflector'invokeMatchingMethod (:methodName this), ___ms, nil, ___argvals))
                    )
                )
                (Reflector'invokeStaticMethod-3c (:c this), (:methodName this), ___argvals)
            )
            (catch Throwable ___e
                (if (not (§ instance? CompilerException ___e))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (cast' CompilerException ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitIntrinsicPredicate) [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (some? (RT'get-2 Intrinsics'preds, (.toString (:method this)))))
    )

    #_method
    (§ defn #_"void" (§ method emitIntrinsicPredicate) [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Label" ___falseLabel]
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (let [#_"Object[]" ___predOps (ß (Object[]) RT'get-2(Intrinsics'preds, (:method this).toString()))]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength ___predOps) - 1) [(inc ___i)]
                        (ß ___gen.visitInsn((cast Integer (§ aget ___predOps ___i))))
                    )
                    (ß ___gen.visitJumpInsn((cast Integer (§ aget ___predOps (ß (§ alength ___predOps) - 1))), ___falseLabel))
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (let [#_"Object" ___ops (ß RT'get-2(Intrinsics'ops, (:method this).toString()))]
                    (if (some? ___ops)
                        (do
                            (if (§ instance? Object[] ___ops)
                                (do
                                    (doseq [#_"Object" ___op (ß (Object[])___ops)]
                                        (.visitInsn ___gen, (cast Integer ___op))
                                    )
                                )
                                (do
                                    (.visitInsn ___gen, (cast Integer ___ops))
                                )
                            )
                        )
                        (do
                            (let [#_"Type" ___type (Type/getType (:c this))]
                                (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                                    (.invokeStatic ___gen, ___type, ___m)
                                )
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (and (:tailPosition this) (not (:canBeDirect ___objx)))
                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearThis ___method, ___gen)
                    )
                )
                (let [#_"Type" ___type (Type/getType (:c this))]
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (.invokeStatic ___gen, ___type, ___m)
                        (let [#_"Class" ___retClass (.getReturnType (:method this))]
                            (if (ß ___context == :Context'STATEMENT)
                                (do
                                    (cond (or (ß ___retClass == Long/TYPE) (ß ___retClass == Double/TYPE))
                                        (do
                                            (.pop2 ___gen)
                                        )
                                        (not= ___retClass Void/TYPE)
                                        (do
                                            (.pop ___gen)
                                        )
                                    )
                                )
                                (do
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, (:method this).getReturnType()))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.push((:c this).getName()))
                (.invokeStatic ___gen, Compiler'RT_TYPE, StaticMethodExpr'forNameMethod)
                (.push ___gen, (:methodName this))
                (ß emitArgsAsArray((:args this), ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (.invokeStatic ___gen, Compiler'REFLECTOR_TYPE, StaticMethodExpr'invokeStaticMethodMethod)
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this)))))
        )
        (:jc this)
    )
)

(class-ns UnresolvedVarExpr (§ implements Expr)
    (defn- #_"UnresolvedVarExpr" UnresolvedVarExpr'init []
        (hash-map
            #_"Symbol" :symbol nil
        )
    )

    (defn #_"UnresolvedVarExpr" UnresolvedVarExpr'new [#_"Symbol" ___symbol]
        (let [this (UnresolvedVarExpr'init)]
            (§ ass (:symbol this) ___symbol)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"UnresolvedVarExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"UnresolvedVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
    (defn- #_"NumberExpr" NumberExpr'init []
        (hash-map
            #_"Number" :n nil
            #_"int" :id 0
        )
    )

    (defn #_"NumberExpr" NumberExpr'new [#_"Number" ___n]
        (let [this (merge (LiteralExpr'new) (NumberExpr'init))]
            (§ ass (:n this) ___n)
            (§ ass (:id this) (Compiler'registerConstant ___n))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"NumberExpr" this]
        (:n this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (.emitConstant ___objx, ___gen, (:id this))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NumberExpr" this]
        (cond (instance? Integer (:n this))
            (do
                Long/TYPE
            )
            (instance? Double (:n this))
            (do
                Double/TYPE
            )
            (instance? Long (:n this))
            (do
                Long/TYPE
            )
            :else
            (do
                (throw (IllegalStateException. (str "Unsupported Number type: " (ß (:n this).getClass().getName()))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (instance? Integer (:n this))
            (do
                (ß ___gen.push((:n this).longValue()))
            )
            (instance? Double (:n this))
            (do
                (ß ___gen.push((:n this).doubleValue()))
            )
            (instance? Long (:n this))
            (do
                (ß ___gen.push((:n this).longValue()))
            )
        )
        nil
    )

    (defn #_"Expr" NumberExpr'parse [#_"Number" ___form]
        (if (or (instance? Integer ___form) (instance? Double ___form) (instance? Long ___form))
            (do
                (NumberExpr'new ___form)
            )
            (do
                (ConstantExpr'new ___form)
            )
        )
    )
)

#_closure
(class-ns ConstantParser (§ implements IParser)
    (§ def #_"Keyword" ConstantParser'formKey (Keyword'intern-1 "form"))

    (defn #_"ConstantParser" ConstantParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ConstantParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"int" ___argCount (ß RT'count(___form) - 1)]
            (when (not= ___argCount 1)
                (let [#_"IPersistentMap" ___exData (PersistentArrayMap'new-1 (object-array [ ConstantParser'formKey, ___form ]))]
                    (throw (ExceptionInfo'new-2 (str "Wrong number of args (" ___argCount ") passed to quote"), ___exData))
                )
            )
            (let [#_"Object" ___v (RT'second ___form)]
                (cond (nil? ___v)
                    (do
                        (§ return Compiler'NIL_EXPR)
                    )
                    (= ___v Boolean/TRUE)
                    (do
                        (§ return Compiler'TRUE_EXPR)
                    )
                    (= ___v Boolean/FALSE)
                    (do
                        (§ return Compiler'FALSE_EXPR)
                    )
                )
                (cond (instance? Number ___v)
                    (do
                        (NumberExpr'parse (cast Number ___v))
                    )
                    (instance? String ___v)
                    (do
                        (StringExpr'new (cast String ___v))
                    )
                    (and (§ instance? IPersistentCollection ___v) (zero? (.count (cast' IPersistentCollection ___v))))
                    (do
                        (EmptyExpr'new ___v)
                    )
                    :else
                    (do
                        (ConstantExpr'new ___v)
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr (§ extends LiteralExpr)
    (defn- #_"ConstantExpr" ConstantExpr'init []
        (hash-map
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            #_"Object" :v nil
            #_"int" :id 0
        )
    )

    (defn #_"ConstantExpr" ConstantExpr'new [#_"Object" ___v]
        (let [this (merge (LiteralExpr'new) (ConstantExpr'init))]
            (§ ass (:v this) ___v)
            (§ ass (:id this) (Compiler'registerConstant ___v))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"ConstantExpr" this]
        (:v this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ConstantExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitConstant ___objx, ___gen, (:id this))

        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ConstantExpr" this]
        (ß Modifier/isPublic((:v this).getClass().getModifiers()))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ConstantExpr" this]
        (cond (§ instance? APersistentMap (:v this))
            (do
                (§ class APersistentMap)
            )
            (§ instance? APersistentSet (:v this))
            (do
                (§ class APersistentSet)
            )
            (§ instance? APersistentVector (:v this))
            (do
                (§ class APersistentVector)
            )
            :else
            (do
                (.getClass (:v this))
            )
        )
    )
)

(class-ns NilExpr (§ extends LiteralExpr)
    (defn #_"NilExpr" NilExpr'new []
        (LiteralExpr'new)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"NilExpr" this]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NilExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.visitInsn ___gen, Opcodes/ACONST_NULL)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NilExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr (§ extends LiteralExpr)
    (defn- #_"BooleanExpr" BooleanExpr'init []
        (hash-map
            #_"boolean" :val false
        )
    )

    (defn #_"BooleanExpr" BooleanExpr'new [#_"boolean" ___val]
        (let [this (merge (LiteralExpr'new) (BooleanExpr'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BooleanExpr" this]
        (if (:val this) RT'T RT'F)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"BooleanExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (:val this)
            (do
                (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE)
            )
            (do
                (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"BooleanExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"BooleanExpr" this]
        Boolean
    )
)

(class-ns StringExpr (§ extends LiteralExpr)
    (defn- #_"StringExpr" StringExpr'init []
        (hash-map
            #_"String" :str nil
        )
    )

    (defn #_"StringExpr" StringExpr'new [#_"String" ___str]
        (let [this (merge (LiteralExpr'new) (StringExpr'init))]
            (§ ass (:str this) ___str)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"StringExpr" this]
        (:str this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StringExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (.push ___gen, (:str this))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StringExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StringExpr" this]
        String
    )
)

#_closure
(class-ns MonitorEnterParser (§ implements IParser)
    (defn #_"MonitorEnterParser" MonitorEnterParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"MonitorEnterParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß MonitorEnterExpr'new(Compiler'analyze-2(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorEnterExpr (§ extends UntypedExpr)
    (defn- #_"MonitorEnterExpr" MonitorEnterExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorEnterExpr" MonitorEnterExpr'new [#_"Expr" ___target]
        (let [this (merge (UntypedExpr'new) (MonitorEnterExpr'init))]
            (§ ass (:target this) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MonitorEnterExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.monitorEnter ___gen)
        (.emit Compiler'NIL_EXPR, ___context, ___objx, ___gen)
        nil
    )
)

#_closure
(class-ns MonitorExitParser (§ implements IParser)
    (defn #_"MonitorExitParser" MonitorExitParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"MonitorExitParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß MonitorExitExpr'new(Compiler'analyze-2(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorExitExpr (§ extends UntypedExpr)
    (defn- #_"MonitorExitExpr" MonitorExitExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorExitExpr" MonitorExitExpr'new [#_"Expr" ___target]
        (let [this (merge (UntypedExpr'new) (MonitorExitExpr'init))]
            (§ ass (:target this) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MonitorExitExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.monitorExit ___gen)
        (.emit Compiler'NIL_EXPR, ___context, ___objx, ___gen)
        nil
    )
)

(class-ns CatchClause
    (defn- #_"CatchClause" CatchClause'init []
        (hash-map
            #_"Class" :c nil
            #_"LocalBinding" :lb nil
            #_"Expr" :handler nil
            #_"Label" :label nil
            #_"Label" :endLabel nil
        )
    )

    (defn #_"CatchClause" CatchClause'new [#_"Class" ___c, #_"LocalBinding" ___lb, #_"Expr" ___handler]
        (let [this (CatchClause'init)]
            (§ ass (:c this) ___c)
            (§ ass (:lb this) ___lb)
            (§ ass (:handler this) ___handler)
            this
        )
    )
)

#_closure
(class-ns TryParser (§ implements IParser)
    (defn #_"TryParser" TryParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"TryParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            (when (ß ___context != :Context'RETURN)
                (§ return (ß Compiler'analyze-2(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )

            ;; (try try-expr* catch-expr* finally-expr?)
            ;; catch-expr: (catch class sym expr*)
            ;; finally-expr: (finally expr*)

            (let [#_"PersistentVector" ___body PersistentVector'EMPTY]
                (let [#_"PersistentVector" ___catches PersistentVector'EMPTY]
                    (let [#_"Expr" ___bodyExpr nil]
                        (let [#_"Expr" ___finallyExpr nil]
                            (let [#_"boolean" ___caught false]
                                (let [#_"int" ___retLocal (Compiler'getAndIncLocalNum)]
                                    (let [#_"int" ___finallyLocal (Compiler'getAndIncLocalNum)]
                                        (loop-when-recur [#_"ISeq" ___fs (next ___form)] (some? ___fs) [(next ___fs)]
                                            (let [#_"Object" ___f (first ___fs)]
                                                (let [#_"Object" ___op (when (§ instance? ISeq ___f) (.first (cast' ISeq ___f)))]
                                                    (if (and (not (Util'equals ___op, Compiler'CATCH)) (not (Util'equals ___op, Compiler'FINALLY)))
                                                        (do
                                                            (when ___caught
                                                                (throw (Util'runtimeException-1 "Only catch or finally clause can follow catch in try expression"))
                                                            )
                                                            (§ ass ___body (.cons ___body, ___f))
                                                        )
                                                        (do
                                                            (when (nil? ___bodyExpr)
                                                                (try
                                                                    (ß Var'pushThreadBindings(RT'map(
                                                                        (object-array [
                                                                            Compiler'NO_RECUR              true
                                                                            Compiler'METHOD_RETURN_CONTEXT nil
                                                                        ])
                                                                    )))
                                                                    (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___context, RT'seq(___body))))
                                                                    (finally
                                                                        (Var'popThreadBindings)
                                                                    )
                                                                )
                                                            )

                                                            (cond (Util'equals ___op, Compiler'CATCH)
                                                                (do
                                                                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___f), false))]
                                                                        (when (nil? ___c)
                                                                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second ___f))))
                                                                        )
                                                                        (when (not (§ instance? Symbol (RT'third ___f)))
                                                                            (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (RT'third ___f))))
                                                                        )
                                                                        (let [#_"Symbol" ___sym (cast' Symbol (RT'third ___f))]
                                                                            (when (some? (.getNamespace ___sym))
                                                                                (throw (Util'runtimeException-1 (str "Can't bind qualified name:" ___sym)))
                                                                            )

                                                                            (let [#_"IPersistentMap" ___dynamicBindings
                                                                                    (ß RT'map(
                                                                                        (object-array [
                                                                                            Compiler'LOCAL_ENV        Compiler'LOCAL_ENV.deref()
                                                                                            Compiler'NEXT_LOCAL_NUM   Compiler'NEXT_LOCAL_NUM.deref()
                                                                                            Compiler'IN_CATCH_FINALLY RT'T
                                                                                        ])
                                                                                    ))]
                                                                                (try
                                                                                    (Var'pushThreadBindings ___dynamicBindings)
                                                                                    (let [#_"LocalBinding" ___lb (Compiler'registerLocal ___sym, (cast' Symbol (when (§ instance? Symbol (RT'second ___f)) (RT'second ___f))), nil, false)]
                                                                                        (let [#_"Expr" ___handler (ß (BodyParser'new()).parse(:Context'EXPRESSION, RT'next(RT'next(RT'next(___f)))))]
                                                                                            (§ ass ___catches (ß ___catches.cons(CatchClause'new(___c, ___lb, ___handler))))
                                                                                        )
                                                                                    )
                                                                                    (finally
                                                                                        (Var'popThreadBindings)
                                                                                    )
                                                                                )
                                                                                (§ ass ___caught true)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                :else ;; finally
                                                                (do
                                                                    (when (some? (next ___fs))
                                                                        (throw (Util'runtimeException-1 "finally clause must be last in try expression"))
                                                                    )
                                                                    (try
                                                                        (ß Var'pushThreadBindings(RT'map(
                                                                            (object-array [
                                                                                Compiler'IN_CATCH_FINALLY RT'T
                                                                            ])
                                                                        )))
                                                                        (§ ass ___finallyExpr (ß (BodyParser'new()).parse(:Context'STATEMENT, RT'next(___f))))
                                                                        (finally
                                                                            (Var'popThreadBindings)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (when (nil? ___bodyExpr)
                                            ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                            ;; return a body expr directly
                                            (try
                                                (ß Var'pushThreadBindings(RT'map(
                                                    (object-array [
                                                        Compiler'NO_RECUR true
                                                    ])
                                                )))
                                                (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___context, RT'seq(___body))))
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                            (§ return ___bodyExpr)
                                        )

                                        (TryExpr'new ___bodyExpr, ___catches, ___finallyExpr, ___retLocal, ___finallyLocal)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr (§ implements Expr)
    (defn- #_"TryExpr" TryExpr'init []
        (hash-map
            #_"Expr" :tryExpr nil
            #_"Expr" :finallyExpr nil
            #_"PersistentVector" :catchExprs nil
            #_"int" :retLocal 0
            #_"int" :finallyLocal 0
        )
    )

    (defn #_"TryExpr" TryExpr'new [#_"Expr" ___tryExpr, #_"PersistentVector" ___catchExprs, #_"Expr" ___finallyExpr, #_"int" ___retLocal, #_"int" ___finallyLocal]
        (let [this (TryExpr'init)]
            (§ ass (:tryExpr this) ___tryExpr)
            (§ ass (:catchExprs this) ___catchExprs)
            (§ ass (:finallyExpr this) ___finallyExpr)
            (§ ass (:retLocal this) ___retLocal)
            (§ ass (:finallyLocal this) ___finallyLocal)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"TryExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___startTry (.newLabel ___gen)]
            (let [#_"Label" ___endTry (.newLabel ___gen)]
                (let [#_"Label" ___end (.newLabel ___gen)]
                    (let [#_"Label" ___ret (.newLabel ___gen)]
                        (let [#_"Label" ___finallyLabel (.newLabel ___gen)]
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (cast' CatchClause (.nth (:catchExprs this), ___i))]
                                    (§ ass (:label ___clause) (.newLabel ___gen))
                                    (§ ass (:endLabel ___clause) (.newLabel ___gen))
                                )
                            )

                            (.mark ___gen, ___startTry)
                            (.emit (:tryExpr this), ___context, ___objx, ___gen)
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:retLocal this)))
                            )
                            (.mark ___gen, ___endTry)
                            (when (some? (:finallyExpr this))
                                (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                            )
                            (.goTo ___gen, ___ret)

                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (cast' CatchClause (.nth (:catchExprs this), ___i))]
                                    (.mark ___gen, (:label ___clause))
                                    ;; exception should be on stack
                                    ;; put in clause local
                                    (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:lb ___clause))))
                                    (.emit (:handler ___clause), ___context, ___objx, ___gen)
                                    (when (ß ___context != :Context'STATEMENT)
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:retLocal this)))
                                    )
                                    (.mark ___gen, (:endLabel ___clause))

                                    (when (some? (:finallyExpr this))
                                        (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                                    )
                                    (.goTo ___gen, ___ret)
                                )
                            )
                            (when (some? (:finallyExpr this))
                                (.mark ___gen, ___finallyLabel)
                                ;; exception should be on stack
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:finallyLocal this)))
                                (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:finallyLocal this)))
                                (.throwException ___gen)
                            )
                            (.mark ___gen, ___ret)
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:retLocal this)))
                            )
                            (.mark ___gen, ___end)
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (cast' CatchClause (.nth (:catchExprs this), ___i))]
                                    (ß ___gen.visitTryCatchBlock(___startTry, ___endTry, (:label ___clause), (:c ___clause).getName().replace(\., \/)))
                                )
                            )
                            (when (some? (:finallyExpr this))
                                (.visitTryCatchBlock ___gen, ___startTry, ___endTry, ___finallyLabel, nil)
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                    (let [#_"CatchClause" ___clause (cast' CatchClause (.nth (:catchExprs this), ___i))]
                                        (.visitTryCatchBlock ___gen, (:label ___clause), (:endLabel ___clause), ___finallyLabel, nil)
                                    )
                                )
                            )
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (cast' CatchClause (.nth (:catchExprs this), ___i))]
                                    (ß ___gen.visitLocalVariable((:name (:lb ___clause)), "Ljava/lang/Object;", nil, (:label ___clause), (:endLabel ___clause), (:idx (:lb ___clause))))
                                )
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"TryExpr" this]
        (.hasJavaClass (:tryExpr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"TryExpr" this]
        (.getJavaClass (:tryExpr this))
    )
)

#_closure
(class-ns ThrowParser (§ implements IParser)
    (defn #_"ThrowParser" ThrowParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ThrowParser" this, #_"Context" ___context, #_"Object" ___form]
        (cond (ß ___context == :Context'EVAL)
            (do
                (§ return (ß Compiler'analyze-2(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (ß RT'count(___form) == 1)
            (do
                (throw (Util'runtimeException-1 "Too few arguments to throw, throw expects a single Throwable instance"))
            )
            (ß RT'count(___form) > 2)
            (do
                (throw (Util'runtimeException-1 "Too many arguments to throw, throw expects a single Throwable instance"))
            )
        )
        (ß ThrowExpr'new(Compiler'analyze-2(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns ThrowExpr (§ extends UntypedExpr)
    (defn- #_"ThrowExpr" ThrowExpr'init []
        (hash-map
            #_"Expr" :excExpr nil
        )
    )

    (defn #_"ThrowExpr" ThrowExpr'new [#_"Expr" ___excExpr]
        (let [this (merge (UntypedExpr'new) (ThrowExpr'init))]
            (§ ass (:excExpr this) ___excExpr)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ThrowExpr" this]
        (throw (Util'runtimeException-1 "Can't eval throw"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ThrowExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:excExpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.checkCast ___gen, Compiler'THROWABLE_TYPE)
        (.throwException ___gen)
        nil
    )
)

#_closure
(class-ns NewParser (§ implements IParser)
    (defn #_"NewParser" NewParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"NewParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (Compiler'lineDeref)]
            (let [#_"int" ___column (Compiler'columnDeref)]
                (let [#_"ISeq" ___form (cast' ISeq ___frm)]
                    ;; (new Classname args...)
                    (when (ß (count ___form) < 2)
                        (throw (Util'runtimeException-1 "wrong number of arguments, expecting: (new Classname args...)"))
                    )
                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___form), false))]
                        (when (nil? ___c)
                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second ___form))))
                        )
                        (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                            (loop-when-recur [#_"ISeq" ___s (ß RT'next(RT'next(___form)))] (some? ___s) [(next ___s)]
                                (§ ass ___args (.cons ___args, (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (first ___s))))
                            )
                            (NewExpr'new ___c, ___args, ___line, ___column)
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr (§ implements Expr)
    (def #_"Method" NewExpr'invokeConstructorMethod (Method/getMethod "Object invokeConstructor(Class, Object[])"))
    (def #_"Method" NewExpr'forNameMethod (Method/getMethod "Class classForName(String)"))

    (defn- #_"NewExpr" NewExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"Constructor" :ctor nil
            #_"Class" :c nil
        )
    )

    (defn #_"NewExpr" NewExpr'new [#_"Class" ___c, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column]
        (let [this (NewExpr'init)]
            (§ ass (:args this) ___args)
            (§ ass (:c this) ___c)
            (let [#_"Constructor[]" ___allctors (.getConstructors ___c)]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                        (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___allctors)) [(inc ___i)]
                                (let [#_"Constructor" ___ctor (§ aget ___allctors ___i)]
                                    (when (ß (§ alength (.getParameterTypes ___ctor)) == (count ___args))
                                        (.add ___ctors, ___ctor)
                                        (.add ___params, (.getParameterTypes ___ctor))
                                        (.add ___rets, ___c)
                                    )
                                )
                            )
                            (when (.isEmpty ___ctors)
                                (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                            )

                            (let [#_"int" ___ctoridx 0]
                                (when (ß (.size ___ctors) > 1)
                                    (§ ass ___ctoridx (ß Compiler'getMatchingParams((.getName ___c), ___params, ___args, ___rets)))
                                )

                                (§ ass (:ctor this) (when (>= ___ctoridx 0) (cast Constructor (.get ___ctors, ___ctoridx))))
                                (when (and (nil? (:ctor this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column, (.getName ___c) ])))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"NewExpr" this]
        (let [#_"Object[]" ___argvals (make-array Object (count (:args this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass (§ aget ___argvals ___i) (.eval (cast' Expr (.nth (:args this), ___i))))
            )
            (when (ß (some? (:ctor this)))
                (try
                    (§ return (ß (:ctor this).newInstance(Reflector'boxArgs((:ctor this).getParameterTypes(), ___argvals))))
                    (catch Exception ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
            (Reflector'invokeConstructor (:c this), ___argvals)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NewExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (some? (:ctor this)))
            (do
                (let [#_"Type" ___type (Compiler'getType (:c this))]
                    (.newInstance ___gen, ___type)
                    (.dup ___gen)
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:ctor this).getParameterTypes(), (:args this)))
                    (ß ___gen.invokeConstructor(___type, (Method. "<init>", (Type/getConstructorDescriptor (:ctor this)))))
                )
            )
            (do
                (ß ___gen.push(Compiler'destubClassName((:c this).getName())))
                (.invokeStatic ___gen, Compiler'RT_TYPE, NewExpr'forNameMethod)
                (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
                (.invokeStatic ___gen, Compiler'REFLECTOR_TYPE, invokeConstructorMethod)
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NewExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NewExpr" this]
        (:c this)
    )
)

(class-ns MetaExpr (§ implements Expr)
    (§ def #_"Type" MetaExpr'IOBJ_TYPE (Type/getType (§ class IObj)))
    (def #_"Method" MetaExpr'withMetaMethod (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

    (defn- #_"MetaExpr" MetaExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Expr" :meta nil
        )
    )

    (defn #_"MetaExpr" MetaExpr'new [#_"Expr" ___expr, #_"Expr" ___meta]
        (let [this (MetaExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MetaExpr" this]
        (ß (cast' IObj (.eval (:expr this))).withMeta((cast' IPersistentMap (.eval (:meta this)))))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MetaExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.checkCast ___gen, MetaExpr'IOBJ_TYPE)
        (ß (:meta this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.checkCast ___gen, Compiler'IPERSISTENTMAP_TYPE)
        (.invokeInterface ___gen, MetaExpr'IOBJ_TYPE, MetaExpr'withMetaMethod)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MetaExpr" this]
        (.hasJavaClass (:expr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MetaExpr" this]
        (.getJavaClass (:expr this))
    )
)

#_closure
(class-ns IfParser (§ implements IParser)
    (defn #_"IfParser" IfParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"IfParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            ;; (if test then) or (if test then else)
            (cond (ß (count ___form) > 4)
                (do
                    (throw (Util'runtimeException-1 "Too many arguments to if"))
                )
                (ß (count ___form) < 3)
                (do
                    (throw (Util'runtimeException-1 "Too few arguments to if"))
                )
            )
            (let [#_"PathNode" ___branch (ß PathNode'new(:PathType'BRANCH, (cast' PathNode (.get Compiler'CLEAR_PATH))))]
                (let [#_"Expr" ___testexpr (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (RT'second ___form))]
                    (let [(ß Expr thenexpr, elseexpr)]
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'CLEAR_PATH PathNode'new(:PathType'PATH, ___branch)
                                ])
                            )))
                            (§ ass thenexpr (ß Compiler'analyze-2(___context, RT'third(___form))))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'CLEAR_PATH PathNode'new(:PathType'PATH, ___branch)
                                ])
                            )))
                            (§ ass elseexpr (ß Compiler'analyze-2(___context, RT'fourth(___form))))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                        (ß IfExpr'new(Compiler'lineDeref(), Compiler'columnDeref(), ___testexpr, thenexpr, elseexpr))
                    )
                )
            )
        )
    )
)

(class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"IfExpr" IfExpr'init []
        (hash-map
            #_"Expr" :testExpr nil
            #_"Expr" :thenExpr nil
            #_"Expr" :elseExpr nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"IfExpr" IfExpr'new [#_"int" ___line, #_"int" ___column, #_"Expr" ___testExpr, #_"Expr" ___thenExpr, #_"Expr" ___elseExpr]
        (let [this (IfExpr'init)]
            (§ ass (:testExpr this) ___testExpr)
            (§ ass (:thenExpr this) ___thenExpr)
            (§ ass (:elseExpr this) ___elseExpr)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"IfExpr" this]
        (let [#_"Object" ___t (.eval (:testExpr this))]
            (when (and (some? ___t) (ß ___t != Boolean/FALSE))
                (§ return (.eval (:thenExpr this)))
            )
            (.eval (:elseExpr this))
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___nullLabel (.newLabel ___gen)]
            (let [#_"Label" ___falseLabel (.newLabel ___gen)]
                (let [#_"Label" ___endLabel (.newLabel ___gen)]
                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

                    (cond (and (§ instance? StaticMethodExpr (:testExpr this)) (.canEmitIntrinsicPredicate (cast' StaticMethodExpr (:testExpr this))))
                        (do
                            (ß (cast' StaticMethodExpr (:testExpr this)).emitIntrinsicPredicate(:Context'EXPRESSION, ___objx, ___gen, ___falseLabel))
                        )
                        (ß Compiler'maybePrimitiveType((:testExpr this)) == Boolean/TYPE)
                        (do
                            (ß (cast' MaybePrimitiveExpr (:testExpr this)).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.ifZCmp(___gen.EQ, ___falseLabel))
                        )
                        :else
                        (do
                            (ß (:testExpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                            (.dup ___gen)
                            (.ifNull ___gen, ___nullLabel)
                            (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                            (.visitJumpInsn ___gen, Opcodes/IF_ACMPEQ, ___falseLabel)
                        )
                    )
                    (if ___emitUnboxed
                        (do
                            (ß (cast' MaybePrimitiveExpr (:thenExpr this)).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (.emit (:thenExpr this), ___context, ___objx, ___gen)
                        )
                    )
                    (.goTo ___gen, ___endLabel)
                    (.mark ___gen, ___nullLabel)
                    (.pop ___gen)
                    (.mark ___gen, ___falseLabel)
                    (if ___emitUnboxed
                        (do
                            (ß (cast' MaybePrimitiveExpr (:elseExpr this)).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (.emit (:elseExpr this), ___context, ___objx, ___gen)
                        )
                    )
                    (.mark ___gen, ___endLabel)
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"IfExpr" this]
        (and (.hasJavaClass (:thenExpr this))
             (.hasJavaClass (:elseExpr this))
            (or (ß (.getJavaClass (:thenExpr this)) == (.getJavaClass (:elseExpr this)))
                (ß (.getJavaClass (:thenExpr this)) == Compiler'RECUR_CLASS)
                (ß (.getJavaClass (:elseExpr this)) == Compiler'RECUR_CLASS)
                (and (nil? (.getJavaClass (:thenExpr this))) (not (ß (:elseExpr this).getJavaClass().isPrimitive())))
                (and (nil? (.getJavaClass (:elseExpr this))) (not (ß (:thenExpr this).getJavaClass().isPrimitive())))))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"IfExpr" this]
        (try
            (and (§ instance? MaybePrimitiveExpr (:thenExpr this))
                 (§ instance? MaybePrimitiveExpr (:elseExpr this))
                (or (ß (.getJavaClass (:thenExpr this)) == (.getJavaClass (:elseExpr this)))
                    (ß (.getJavaClass (:thenExpr this)) == Compiler'RECUR_CLASS)
                    (ß (.getJavaClass (:elseExpr this)) == Compiler'RECUR_CLASS))
                 (.canEmitPrimitive (cast' MaybePrimitiveExpr (:thenExpr this)))
                 (.canEmitPrimitive (cast' MaybePrimitiveExpr (:elseExpr this))))
            (catch Exception ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"IfExpr" this]
        (let [#_"Class" ___thenClass (.getJavaClass (:thenExpr this))]
            (when (and (some? ___thenClass) (ß ___thenClass != Compiler'RECUR_CLASS))
                (§ return ___thenClass)
            )
            (.getJavaClass (:elseExpr this))
        )
    )
)

(class-ns EmptyExpr (§ implements Expr)
    (§ def #_"Type" EmptyExpr'HASHMAP_TYPE (Type/getType (§ class PersistentArrayMap)))
    (§ def #_"Type" EmptyExpr'HASHSET_TYPE (Type/getType (§ class PersistentHashSet)))
    (§ def #_"Type" EmptyExpr'VECTOR_TYPE (Type/getType (§ class PersistentVector)))
    (§ def #_"Type" EmptyExpr'IVECTOR_TYPE (Type/getType (§ class IPersistentVector)))
    (§ def #_"Type" EmptyExpr'TUPLE_TYPE (Type/getType (§ class Tuple)))
    (§ def #_"Type" EmptyExpr'LIST_TYPE (Type/getType (§ class PersistentList)))
    (§ def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (Type/getType (§ class EmptyList)))

    (defn- #_"EmptyExpr" EmptyExpr'init []
        (hash-map
            #_"Object" :coll nil
        )
    )

    (defn #_"EmptyExpr" EmptyExpr'new [#_"Object" ___coll]
        (let [this (EmptyExpr'init)]
            (§ ass (:coll this) ___coll)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"EmptyExpr" this]
        (:coll this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"EmptyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (§ instance? IPersistentList (:coll this))
            (do
                (.getStatic ___gen, EmptyExpr'LIST_TYPE, "EMPTY", EmptyExpr'EMPTY_LIST_TYPE)
            )
            (§ instance? IPersistentVector (:coll this))
            (do
                (.getStatic ___gen, EmptyExpr'VECTOR_TYPE, "EMPTY", EmptyExpr'VECTOR_TYPE)
            )
            (§ instance? IPersistentMap (:coll this))
            (do
                (.getStatic ___gen, EmptyExpr'HASHMAP_TYPE, "EMPTY", EmptyExpr'HASHMAP_TYPE)
            )
            (§ instance? IPersistentSet (:coll this))
            (do
                (.getStatic ___gen, EmptyExpr'HASHSET_TYPE, "EMPTY", EmptyExpr'HASHSET_TYPE)
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"EmptyExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"EmptyExpr" this]
        (cond (§ instance? IPersistentList (:coll this))
            (do
                (§ class IPersistentList)
            )
            (§ instance? IPersistentVector (:coll this))
            (do
                (§ class IPersistentVector)
            )
            (§ instance? IPersistentMap (:coll this))
            (do
                (§ class IPersistentMap)
            )
            (§ instance? IPersistentSet (:coll this))
            (do
                (§ class IPersistentSet)
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
    )
)

(class-ns ListExpr (§ implements Expr)
    (def #_"Method" ListExpr'arrayToListMethod (Method/getMethod "cloiure.lang.ISeq arrayToList(Object[])"))

    (defn- #_"ListExpr" ListExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"ListExpr" ListExpr'new [#_"IPersistentVector" ___args]
        (let [this (ListExpr'init)]
            (§ ass (:args this) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ListExpr" this]
        (let [#_"IPersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass ___ret (cast' IPersistentVector (ß ___ret.cons((cast' Expr (.nth (:args this), ___i)).eval()))))
            )
            (.seq ___ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ListExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
        (.invokeStatic ___gen, Compiler'RT_TYPE, ListExpr'arrayToListMethod)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ListExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ListExpr" this]
        (§ class IPersistentList)
    )
)

(class-ns MapExpr (§ implements Expr)
    (def #_"Method" MapExpr'mapMethod (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
    (def #_"Method" MapExpr'mapUniqueKeysMethod (Method/getMethod "cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

    (defn- #_"MapExpr" MapExpr'init []
        (hash-map
            #_"IPersistentVector" :keyvals nil
        )
    )

    (defn #_"MapExpr" MapExpr'new [#_"IPersistentVector" ___keyvals]
        (let [this (MapExpr'init)]
            (§ ass (:keyvals this) ___keyvals)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MapExpr" this]
        (let [#_"Object[]" ___ret (make-array Object (count (:keyvals this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals this).count()) [(inc ___i)]
                (§ ass (§ aget ___ret ___i) (.eval (cast' Expr (.nth (:keyvals this), ___i))))
            )
            (RT'map ___ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MapExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___allKeysConstant true]
            (let [#_"boolean" ___allConstantKeysUnique true]
                (let [#_"IPersistentSet" ___constantKeys PersistentHashSet'EMPTY]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals this).count()) [(+ ___i 2)]
                        (let [#_"Expr" ___k (cast' Expr (.nth (:keyvals this), ___i))]
                            (if (§ instance? LiteralExpr ___k)
                                (do
                                    (let [#_"Object" ___kval (.eval ___k)]
                                        (if (.contains ___constantKeys, ___kval)
                                            (do
                                                (§ ass ___allConstantKeysUnique false)
                                            )
                                            (do
                                                (§ ass ___constantKeys (cast' IPersistentSet (.cons ___constantKeys, ___kval)))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (§ ass ___allKeysConstant false)
                                )
                            )
                        )
                    )
                    (MethodExpr'emitArgsAsArray (:keyvals this), ___objx, ___gen)
                    (if (or (and ___allKeysConstant ___allConstantKeysUnique) (ß (:keyvals this).count() <= 2))
                        (do
                            (.invokeStatic ___gen, Compiler'RT_TYPE, mapUniqueKeysMethod)
                        )
                        (do
                            (.invokeStatic ___gen, Compiler'RT_TYPE, mapMethod)
                        )
                    )
                    (when (ß ___context == :Context'STATEMENT)
                        (.pop ___gen)
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MapExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MapExpr" this]
        (§ class IPersistentMap)
    )

    (defn #_"Expr" MapExpr'parse [#_"Context" ___context, #_"IPersistentMap" ___form]
        (let [#_"IPersistentVector" ___keyvals PersistentVector'EMPTY]
            (let [#_"boolean" ___keysConstant true]
                (let [#_"boolean" ___valsConstant true]
                    (let [#_"boolean" ___allConstantKeysUnique true]
                        (let [#_"IPersistentSet" ___constantKeys PersistentHashSet'EMPTY]
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(next ___s)]
                                (let [#_"IMapEntry" ___e (cast' IMapEntry (first ___s))]
                                    (let [#_"Expr" ___k (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.key ___e))]
                                        (let [#_"Expr" ___v (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.val ___e))]
                                            (§ ass ___keyvals (cast' IPersistentVector (.cons ___keyvals, ___k)))
                                            (§ ass ___keyvals (cast' IPersistentVector (.cons ___keyvals, ___v)))
                                            (if (§ instance? LiteralExpr ___k)
                                                (do
                                                    (let [#_"Object" ___kval (.eval ___k)]
                                                        (if (.contains ___constantKeys, ___kval)
                                                            (do
                                                                (§ ass ___allConstantKeysUnique false)
                                                            )
                                                            (do
                                                                (§ ass ___constantKeys (cast' IPersistentSet (.cons ___constantKeys, ___kval)))
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (§ ass ___keysConstant false)
                                                )
                                            )
                                            (when (not (§ instance? LiteralExpr ___v))
                                                (§ ass ___valsConstant false)
                                            )
                                        )
                                    )
                                )
                            )

                            (let [#_"Expr" ___ret (MapExpr'new ___keyvals)]
                                (cond (and (§ instance? IObj ___form) (some? (.meta (cast' IObj ___form))))
                                    (do
                                        (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.meta (cast' IObj ___form))))
                                    )
                                    ___keysConstant
                                    (do
                                        ;; TBD: Add more detail to exception thrown below.
                                        (when (not ___allConstantKeysUnique)
                                            (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                                        )
                                        (if ___valsConstant
                                            (do
                                                (let [#_"IPersistentMap" ___m PersistentArrayMap'EMPTY]
                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (.length ___keyvals)) [(+ ___i 2)]
                                                        (§ ass ___m (ß ___m.assoc((cast' LiteralExpr (.nth ___keyvals, ___i)).val(), (cast' LiteralExpr (ß ___keyvals.nth(___i + 1))).val())))
                                                    )
                                                    (ConstantExpr'new ___m)
                                                )
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                    :else
                                    (do
                                        ___ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns SetExpr (§ implements Expr)
    (def #_"Method" SetExpr'setMethod (Method/getMethod "cloiure.lang.IPersistentSet set(Object[])"))

    (defn- #_"SetExpr" SetExpr'init []
        (hash-map
            #_"IPersistentVector" :keys nil
        )
    )

    (defn #_"SetExpr" SetExpr'new [#_"IPersistentVector" ___keys]
        (let [this (SetExpr'init)]
            (§ ass (:keys this) ___keys)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"SetExpr" this]
        (let [#_"Object[]" ___ret (make-array Object (count (:keys this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keys this).count()) [(inc ___i)]
                (§ ass (§ aget ___ret ___i) (.eval (cast' Expr (.nth (:keys this), ___i))))
            )
            (RT'set ___ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"SetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (MethodExpr'emitArgsAsArray (:keys this), ___objx, ___gen)
        (.invokeStatic ___gen, Compiler'RT_TYPE, setMethod)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"SetExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"SetExpr" this]
        (§ class IPersistentSet)
    )

    (defn #_"Expr" SetExpr'parse [#_"Context" ___context, #_"IPersistentSet" ___form]
        (let [#_"IPersistentVector" ___keys PersistentVector'EMPTY]
            (let [#_"boolean" ___constant true]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(next ___s)]
                    (let [#_"Object" ___e (first ___s)]
                        (let [#_"Expr" ___expr (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), ___e)]
                            (§ ass ___keys (cast' IPersistentVector (.cons ___keys, ___expr)))
                            (when (not (§ instance? LiteralExpr ___expr))
                                (§ ass ___constant false)
                            )
                        )
                    )
                )
                (let [#_"Expr" ___ret (SetExpr'new ___keys)]
                    (cond (and (§ instance? IObj ___form) (some? (.meta (cast' IObj ___form))))
                        (do
                            (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.meta (cast' IObj ___form))))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentSet" ___set PersistentHashSet'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___keys)) [(inc ___i)]
                                    (let [#_"LiteralExpr" ___ve (cast' LiteralExpr (.nth ___keys, ___i))]
                                        (§ ass ___set (cast' IPersistentSet (.cons ___set, (.val ___ve))))
                                    )
                                )
                                (ConstantExpr'new ___set)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns VectorExpr (§ implements Expr)
    (def #_"Method" VectorExpr'vectorMethod (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))

    (defn- #_"VectorExpr" VectorExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"VectorExpr" VectorExpr'new [#_"IPersistentVector" ___args]
        (let [this (VectorExpr'init)]
            (§ ass (:args this) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"VectorExpr" this]
        (let [#_"IPersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass ___ret (cast' IPersistentVector (ß ___ret.cons((cast' Expr (.nth (:args this), ___i)).eval()))))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"VectorExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:args this).count() <= Tuple'MAX_SIZE)
            (do
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                    (ß (cast' Expr (.nth (:args this), ___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___gen.invokeStatic(Compiler'TUPLE_TYPE, Compiler'createTupleMethods[(:args this).count()]))
            )
            (do
                (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
                (.invokeStatic ___gen, Compiler'RT_TYPE, vectorMethod)
            )
        )

        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"VectorExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"VectorExpr" this]
        (§ class IPersistentVector)
    )

    (defn #_"Expr" VectorExpr'parse [#_"Context" ___context, #_"IPersistentVector" ___form]
        (let [#_"boolean" ___constant true]
            (let [#_"IPersistentVector" ___args PersistentVector'EMPTY]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___form)) [(inc ___i)]
                    (let [#_"Expr" ___v (Compiler'analyze-2 (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.nth ___form, ___i))]
                        (§ ass ___args (cast' IPersistentVector (.cons ___args, ___v)))
                        (when (not (§ instance? LiteralExpr ___v))
                            (§ ass ___constant false)
                        )
                    )
                )
                (let [#_"Expr" ___ret (VectorExpr'new ___args)]
                    (cond (and (§ instance? IObj ___form) (some? (.meta (cast' IObj ___form))))
                        (do
                            (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.meta (cast' IObj ___form))))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentVector" ___rv PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
                                    (let [#_"LiteralExpr" ___ve (cast' LiteralExpr (.nth ___args, ___i))]
                                        (§ ass ___rv (.cons ___rv, (.val ___ve)))
                                    )
                                )
                                (ConstantExpr'new ___rv)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns KeywordInvokeExpr (§ implements Expr)
    (§ def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (Type/getType (§ class ILookup)))

    (defn- #_"KeywordInvokeExpr" KeywordInvokeExpr'init []
        (hash-map
            #_"KeywordExpr" :kw nil
            #_"Object" :tag nil
            #_"Expr" :target nil
            #_"int" :line 0
            #_"int" :column 0
            #_"int" :siteIndex 0
            #_"String" :source nil

            #_"Class" :jc nil
        )
    )

    (defn #_"KeywordInvokeExpr" KeywordInvokeExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"KeywordExpr" ___kw, #_"Expr" ___target]
        (let [this (KeywordInvokeExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:kw this) ___kw)
            (§ ass (:target this) ___target)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:siteIndex this) (Compiler'registerKeywordCallsite (:k ___kw)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"KeywordInvokeExpr" this]
        (try
            (ß (:k (:kw this)).invoke((:target this).eval()))
            (catch Throwable ___e
                (if (not (§ instance? CompilerException ___e))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (cast' CompilerException ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"KeywordInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___endLabel (.newLabel ___gen)]
            (let [#_"Label" ___faultLabel (.newLabel ___gen)]
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.getStatic((:objtype ___objx), ___objx.thunkNameStatic((:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE))
                (.dup ___gen) ;; thunk, thunk
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen)) ;; thunk, thunk, target
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.dupX2 ___gen) ;; target, thunk, thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; target, thunk, result
                (.dupX2 ___gen) ;; result, target, thunk, result
                (.visitJumpInsn ___gen, Opcodes/IF_ACMPEQ, ___faultLabel) ;; result, target
                (.pop ___gen) ;; result
                (.goTo ___gen, ___endLabel)

                (.mark ___gen, ___faultLabel) ;; result, target
                (.swap ___gen) ;; target, result
                (.pop ___gen) ;; target
                (.dup ___gen) ;; target, target
                (ß ___gen.getStatic((:objtype ___objx), ___objx.siteNameStatic((:siteIndex this)), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                (.swap ___gen) ;; target, site, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_SITE_TYPE, Method/getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                (.dup ___gen) ;; target, new-thunk, new-thunk
                (ß ___gen.putStatic((:objtype ___objx), ___objx.thunkNameStatic((:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                (.swap ___gen) ;; new-thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; result

                (.mark ___gen, ___endLabel)
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"KeywordInvokeExpr" this]
        (some? (:tag this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"KeywordInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )
)

(class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"InstanceOfExpr" InstanceOfExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Class" :c nil
        )
    )

    (defn #_"InstanceOfExpr" InstanceOfExpr'new [#_"Class" ___c, #_"Expr" ___expr]
        (let [this (InstanceOfExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceOfExpr" this]
        (when (ß (:c this).isInstance((:expr this).eval()))
            (§ return RT'T)
        )
        RT'F
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.instanceOf(Compiler'getType((:c this))))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitUnboxed this, ___context, ___objx, ___gen)
        (HostExpr'emitBoxReturn ___objx, ___gen, Boolean/TYPE)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceOfExpr" this]
        Boolean/TYPE
    )
)

(class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"StaticInvokeExpr" StaticInvokeExpr'init []
        (hash-map
            #_"Type" :target nil
            #_"Class" :retClass nil
            #_"Class[]" :paramclasses nil
            #_"Type[]" :paramtypes nil
            #_"IPersistentVector" :args nil
            #_"boolean" :variadic false
            #_"boolean" :tailPosition false
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticInvokeExpr" StaticInvokeExpr'new [#_"Type" ___target, #_"Class" ___retClass, #_"Class[]" ___paramclasses, #_"Type[]" ___paramtypes, #_"boolean" ___variadic, #_"IPersistentVector" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (let [this (StaticInvokeExpr'init)]
            (§ ass (:target this) ___target)
            (§ ass (:retClass this) ___retClass)
            (§ ass (:paramclasses this) ___paramclasses)
            (§ ass (:paramtypes this) ___paramtypes)
            (§ ass (:args this) ___args)
            (§ ass (:variadic this) ___variadic)
            (§ ass (:tailPosition this) ___tailPosition)
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitUnboxed this, ___context, ___objx, ___gen)
        (when (ß ___context != :Context'STATEMENT)
            (HostExpr'emitBoxReturn ___objx, ___gen, (:retClass this))
        )
        (when (ß ___context == :Context'STATEMENT)
            (if (or (ß (:retClass this) == Long/TYPE) (ß (:retClass this) == Double/TYPE))
                (do
                    (.pop2 ___gen)
                )
                (do
                    (.pop ___gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticInvokeExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (:retClass this)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticInvokeExpr" this]
        (.isPrimitive (:retClass this))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Method" ___ms (Method. "invokeStatic", (.getReturnType this), (:paramtypes this))]
            (if (:variadic this)
                (do
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:paramclasses this)) - 1) [(inc ___i)]
                        (let [#_"Expr" ___e (cast' Expr (.nth (:args this), ___i))]
                            (if (ß Compiler'maybePrimitiveType(___e) == (:paramclasses this)[___i])
                                (do
                                    (ß (cast' MaybePrimitiveExpr ___e).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                                (do
                                    (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß HostExpr'emitUnboxArg(___objx, ___gen, (:paramclasses this)[___i]))
                                )
                            )
                        )
                    )
                    (let [#_"IPersistentVector" ___restArgs (ß RT'subvec((:args this), (§ alength (:paramclasses this)) - 1, (:args this).count()))]
                        (MethodExpr'emitArgsAsArray ___restArgs, ___objx, ___gen)
                        (ß ___gen.invokeStatic(Type/getType((§ class ArraySeq)), Method/getMethod("cloiure.lang.ArraySeq create(Object[])")))
                    )
                )
                (do
                    (MethodExpr'emitTypedArgs ___objx, ___gen, (:paramclasses this), (:args this))
                )
            )

            (when (and (:tailPosition this) (not (:canBeDirect ___objx)))
                (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                    (.emitClearThis ___method, ___gen)
                )
            )

            (.invokeStatic ___gen, (:target this), ___ms)
            nil
        )
    )

    #_method
    (§ defn- #_"Type" (§ method getReturnType) [#_"StaticInvokeExpr" this]
        (Type/getType (:retClass this))
    )

    (defn #_"Expr" StaticInvokeExpr'parse [#_"Var" ___v, #_"ISeq" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (when (or (not (.isBound ___v)) (nil? (.get ___v)))
            (§ return nil)
        )
        (let [#_"Class" ___c (.getClass (.get ___v))]
            (let [#_"String" ___cname (.getName ___c)]
                (let [#_"java.lang.reflect.Method[]" ___allmethods (.getMethods ___c)]
                    (let [#_"boolean" ___variadic false]
                        (let [#_"int" ___argcount (RT'count ___args)]
                            (let [#_"java.lang.reflect.Method" ___method nil]
                                (doseq [#_"java.lang.reflect.Method" ___m ___allmethods]
                                    (when (and (Modifier/isStatic (.getModifiers ___m)) (ß (.getName ___m).equals("invokeStatic")))
                                        (let [#_"Class[]" ___params (.getParameterTypes ___m)]
                                            (cond (= ___argcount (§ alength ___params))
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic (and (pos? ___argcount) (ß ___params[(§ alength ___params) - 1] == (§ class ISeq))))
                                                    (§ break )
                                                )
                                                (and (< 0 (§ alength ___params) ___argcount) (ß ___params[(§ alength ___params) - 1] == (§ class ISeq)))
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic true)
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                                (when (nil? ___method)
                                    (§ return nil)
                                )

                                (let [#_"Class" ___retClass (.getReturnType ___method)]
                                    (let [#_"Class[]" ___paramClasses (.getParameterTypes ___method)]
                                        (let [#_"Type[]" ___paramTypes (make-array Type (§ alength ___paramClasses))]
                                            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___paramClasses)) [(inc ___i)]
                                                (§ ass (§ aget ___paramTypes ___i) (Type/getType (§ aget ___paramClasses ___i)))
                                            )

                                            (let [#_"Type" ___target (§ unsure Type/getType ___c)]
                                                (let [#_"PersistentVector" ___argv PersistentVector'EMPTY]
                                                    (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(next ___s)]
                                                        (§ ass ___argv (ß ___argv.cons(Compiler'analyze-2(:Context'EXPRESSION, (first ___s)))))
                                                    )

                                                    (StaticInvokeExpr'new ___target, ___retClass, ___paramClasses, ___paramTypes, ___variadic, ___argv, ___tag, ___tailPosition)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr (§ implements Expr)
    (§ def #_"Keyword" InvokeExpr'onKey (Keyword'intern-1 "on"))
    (§ def #_"Keyword" InvokeExpr'methodMapKey (Keyword'intern-1 "method-map"))

    (defn #_"Object" InvokeExpr'sigTag [#_"int" ___argcount, #_"Var" ___v]
        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), Compiler'arglistsKey))]
            (let [#_"Object" ___sigTag nil]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___arglists)] (some? ___s) [(next ___s)]
                    (let [#_"APersistentVector" ___sig (cast' APersistentVector (first ___s))]
                        (let [#_"int" ___restOffset (.indexOf ___sig, Compiler'_AMP_)]
                            (when (or (= ___argcount (count ___sig)) (<= 0 ___restOffset ___argcount))
                                (§ return (Compiler'tagOf ___sig))
                            )
                        )
                    )
                )
                nil
            )
        )
    )

    (defn- #_"InvokeExpr" InvokeExpr'init []
        (hash-map
            #_"Expr" :fexpr nil
            #_"Object" :tag nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :tailPosition false
            #_"String" :source nil

            #_"boolean" :isProtocol false
            #_"boolean" :isDirect false
            #_"int" :siteIndex -1
            #_"Class" :protocolOn nil
            #_"java.lang.reflect.Method" :onMethod nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InvokeExpr" InvokeExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___fexpr, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (InvokeExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:fexpr this) ___fexpr)
            (§ ass (:args this) ___args)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tailPosition this) ___tailPosition)

            (when (§ instance? VarExpr ___fexpr)
                (let [#_"Var" ___fvar (:var (cast' VarExpr ___fexpr))]
                    (let [#_"Var" ___pvar (cast' Var (ß RT'get-2((.meta ___fvar), Compiler'protocolKey)))]
                        (when (and (some? ___pvar) (.isBound Compiler'PROTOCOL_CALLSITES))
                            (§ ass (:isProtocol this) true)
                            (§ ass (:siteIndex this) (ß Compiler'registerProtocolCallsite((:var (cast' VarExpr ___fexpr)))))
                            (let [#_"Object" ___pon (ß RT'get-2((.get ___pvar), Compiler'onKey))]
                                (§ ass (:protocolOn this) (HostExpr'maybeClass ___pon, false))
                                (when (ß (some? (:protocolOn this)))
                                    (let [#_"IPersistentMap" ___mmap (cast' IPersistentMap (ß RT'get-2((.get ___pvar), methodMapKey)))]
                                        (let [#_"Keyword" ___mmapVal (cast' Keyword (ß ___mmap.valAt(Keyword'intern((:sym ___fvar)))))]
                                            (when (nil? ___mmapVal)
                                                (throw (IllegalArgumentException. (str "No method of interface: " (.getName (:protocolOn this)) " found for function: " (:sym ___fvar) " of protocol: " (:sym ___pvar) " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" ___mname (ß Compiler'munge((:sym ___mmapVal).toString()))]
                                                (let [#_"List" ___methods (ß Reflector'getMethods((:protocolOn this), (count ___args) - 1, ___mname, false))]
                                                    (when (ß (.size ___methods) != 1)
                                                        (throw (IllegalArgumentException. (str "No single method: " ___mname " of interface: " (.getName (:protocolOn this)) " found for function: " (:sym ___fvar) " of protocol: " (:sym ___pvar))))
                                                    )
                                                    (§ ass (:onMethod this) (ß (java.lang.reflect.Method) ___methods.get(0)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (some? ___tag)
                (do
                    (§ ass (:tag this) ___tag)
                )
                (§ instance? VarExpr ___fexpr)
                (do
                    (let [#_"Var" ___v (:var (cast' VarExpr ___fexpr))]
                        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), Compiler'arglistsKey))]
                            (let [#_"Object" ___sigTag (ß InvokeExpr'sigTag((count ___args), ___v))]
                                (§ ass (:tag this) (or ___sigTag (:tag (cast' VarExpr ___fexpr))))
                            )
                        )
                    )
                )
                :else
                (do
                    (§ ass (:tag this) nil)
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" ___fn (cast' IFn (.eval (:fexpr this)))]
                (let [#_"PersistentVector" ___argvs PersistentVector'EMPTY]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                        (§ ass ___argvs (ß ___argvs.cons((cast' Expr (.nth (:args this), ___i)).eval())))
                    )
                    (ß ___fn.applyTo(RT'seq(Util'ret1(___argvs, (§ ass ___argvs nil)))))
                )
            )
            (catch Throwable ___e
                (if (not (§ instance? CompilerException ___e))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (cast' CompilerException ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (:isProtocol this)
            (do
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.emitProto this, ___context, ___objx, ___gen)
            )
            (do
                (ß (:fexpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.checkCast ___gen, Compiler'IFN_TYPE)
                (.emitArgsAndCall this, 0, ___context, ___objx, ___gen)
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitProto) [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___onLabel (.newLabel ___gen)]
            (let [#_"Label" ___callLabel (.newLabel ___gen)]
                (let [#_"Label" ___endLabel (.newLabel ___gen)]
                    (let [#_"Var" ___v (:var (cast' VarExpr (:fexpr this)))]
                        (let [#_"Expr" ___e (cast' Expr (.nth (:args this), 0))]
                            (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                            (.dup ___gen) ;; target, target
                            (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.getStatic((:objtype ___objx), ___objx.cachedClassName((:siteIndex this)), Compiler'CLASS_TYPE)) ;; target, class, cached-class
                            (.visitJumpInsn ___gen, Opcodes/IF_ACMPEQ, ___callLabel) ;; target
                            (when (some? (:protocolOn this))
                                (.dup ___gen) ;; target, target
                                (ß ___gen.instanceOf(Type/getType((:protocolOn this))))
                                (.ifZCmp ___gen, GeneratorAdapter/NE, ___onLabel)
                            )

                            (.dup ___gen) ;; target, target
                            (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.putStatic((:objtype ___objx), ___objx.cachedClassName((:siteIndex this)), Compiler'CLASS_TYPE)) ;; target

                            (.mark ___gen, ___callLabel) ;; target
                            (.emitVar ___objx, ___gen, ___v)
                            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, Method/getMethod("Object getRawRoot()"))) ;; target, proto-fn
                            (.swap ___gen)
                            (.emitArgsAndCall this, 1, ___context, ___objx, ___gen)
                            (.goTo ___gen, ___endLabel)

                            (.mark ___gen, ___onLabel) ;; target
                            (when (some? (:protocolOn this))
                                (ß ___gen.checkCast(Type/getType((:protocolOn this))))
                                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:onMethod this).getParameterTypes(), RT'subvec((:args this), 1, (:args this).count())))
                                (when (ß ___context == :Context'RETURN)
                                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                                        (.emitClearLocals ___method, ___gen)
                                    )
                                )
                                (let [#_"Method" ___m (Method. (.getName (:onMethod this)), (Type/getReturnType (:onMethod this)), (Type/getArgumentTypes (:onMethod this)))]
                                    (ß ___gen.invokeInterface(Type/getType((:protocolOn this)), ___m))
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, (:onMethod this).getReturnType()))
                                )
                            )
                            (.mark ___gen, ___endLabel)
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitArgsAndCall) [#_"InvokeExpr" this, #_"int" ___firstArgToEmit, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i ___firstArgToEmit] (ß ___i < Math/min(Compiler'MAX_POSITIONAL_ARITY, (:args this).count())) [(inc ___i)]
            (let [#_"Expr" ___e (cast' Expr (.nth (:args this), ___i))]
                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        (when (ß (:args this).count() > Compiler'MAX_POSITIONAL_ARITY)
            (let [#_"PersistentVector" ___restArgs PersistentVector'EMPTY]
                (loop-when-recur [#_"int" ___i Compiler'MAX_POSITIONAL_ARITY] (ß ___i < (:args this).count()) [(inc ___i)]
                    (§ ass ___restArgs (ß ___restArgs.cons((:args this).nth(___i))))
                )
                (MethodExpr'emitArgsAsArray ___restArgs, ___objx, ___gen)
            )
        )
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

        (when (and (:tailPosition this) (not (:canBeDirect ___objx)))
            (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                (.emitClearThis ___method, ___gen)
            )
        )

        (ß ___gen.invokeInterface(Compiler'IFN_TYPE, (Method. "invoke", Compiler'OBJECT_TYPE, (ß Compiler'ARG_TYPES[Math/min(Compiler'MAX_POSITIONAL_ARITY + 1, (:args this).count())]))))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InvokeExpr" this]
        (some? (:tag this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )

    (defn #_"Expr" InvokeExpr'parse [#_"Context" ___context, #_"ISeq" ___form]
        (let [#_"boolean" ___tailPosition (Compiler'inTailCall ___context)]
            (when (ß ___context != :Context'EVAL)
                (§ ass ___context (ß :Context'EXPRESSION))
            )
            (let [#_"Expr" ___fexpr (ß Compiler'analyze-2(___context, (first ___form)))]
                (when (and (§ instance? VarExpr ___fexpr) (.equals (:var (cast' VarExpr ___fexpr)), Compiler'INSTANCE) (ß (RT'count ___form) == 3))
                    (let [#_"Expr" ___sexpr (ß Compiler'analyze-2(:Context'EXPRESSION, RT'second(___form)))]
                        (when (§ instance? ConstantExpr ___sexpr)
                            (let [#_"Object" ___val (.val (cast' ConstantExpr ___sexpr))]
                                (when (instance? Class ___val)
                                    (§ return (ß InstanceOfExpr'new((cast Class ___val), Compiler'analyze-2(___context, RT'third(___form)))))
                                )
                            )
                        )
                    )
                )

                (when (and (RT'booleanCast-1o (Compiler'getCompilerOption Compiler'directLinkingKey)) (§ instance? VarExpr ___fexpr) (not= ___context :Context'EVAL))
                    (let [#_"Var" ___v (:var (cast' VarExpr ___fexpr))]
                        (when (and (not (.isDynamic ___v)) (not (RT'booleanCast-1o (RT'get-3 (.meta ___v), Compiler'redefKey, false))))
                            (let [#_"Symbol" ___formtag (Compiler'tagOf ___form)]
                                (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), Compiler'arglistsKey))]
                                    (let [#_"int" ___arity (RT'count (next ___form))]
                                        (let [#_"Object" ___sigtag (InvokeExpr'sigTag ___arity, ___v)]
                                            (let [#_"Object" ___vtag (ß RT'get-2(RT'meta(___v), RT'TAG_KEY))]
                                                (let [#_"Expr" ___ret (StaticInvokeExpr'parse ___v, (RT'next ___form), (or ___formtag ___sigtag ___vtag), ___tailPosition)]
                                                    (when (some? ___ret)
                                                        (§ return ___ret)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (and (§ instance? VarExpr ___fexpr) (ß ___context != :Context'EVAL))
                    (let [#_"Var" ___v (:var (cast' VarExpr ___fexpr))]
                        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), Compiler'arglistsKey))]
                            (let [#_"int" ___arity (RT'count (next ___form))]
                                (loop-when-recur [#_"ISeq" ___s (RT'seq ___arglists)] (some? ___s) [(next ___s)]
                                    (let [#_"IPersistentVector" ___args (cast' IPersistentVector (first ___s))]
                                        (when (ß (count ___args) == ___arity)
                                            (let [#_"String" ___primc (FnMethod'primInterface ___args)]
                                                (when (some? ___primc)
                                                    (§ return (ß Compiler'analyze-2(___context, (cast' IObj (ß RT'listStar-3(Symbol'intern-1(".invokePrim"), (cast' Symbol (first ___form)).withMeta(RT'map(RT'TAG_KEY, Symbol'intern-1(___primc))), (next ___form)))).withMeta((cast' IPersistentMap (ß RT'conj(RT'meta(___v), RT'meta(___form))))))))
                                                )
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (and (§ instance? KeywordExpr ___fexpr) (ß (RT'count ___form) == 2) (.isBound Compiler'KEYWORD_CALLSITES))
                    (let [#_"Expr" ___target (ß Compiler'analyze-2(___context, RT'second(___form)))]
                        (§ return (ß KeywordInvokeExpr'new((cast String (.deref Compiler'SOURCE)), Compiler'lineDeref(), Compiler'columnDeref(), Compiler'tagOf(___form), (cast' KeywordExpr ___fexpr), ___target)))
                    )
                )
                (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                    (loop-when-recur [#_"ISeq" ___s (RT'seq (next ___form))] (some? ___s) [(next ___s)]
                        (§ ass ___args (ß ___args.cons(Compiler'analyze-2(___context, (first ___s)))))
                    )

                    (ß InvokeExpr'new((cast String (.deref Compiler'SOURCE)), Compiler'lineDeref(), Compiler'columnDeref(), Compiler'tagOf(___form), ___fexpr, ___args, ___tailPosition))
                )
            )
        )
    )
)

#_stateless
(class-ns SourceDebugExtensionAttribute (§ extends Attribute)
    (defn #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute'new []
        (Attribute'new "SourceDebugExtension")
    )

    #_method
    (§ defn #_"void" (§ method writeSMAP) [#_"SourceDebugExtensionAttribute" this, #_"ClassWriter" ___cw, #_"String" ___smap]
        (let [#_"ByteVector" ___bv (write ___cw, nil, -1, -1, -1)]
            (.putUTF8 ___bv, ___smap)
            nil
        )
    )
)

(class-ns FnExpr (§ extends ObjExpr)
    (§ def #_"Type" FnExpr'aFnType (Type/getType (§ class AFunction)))
    (§ def #_"Type" FnExpr'restFnType (Type/getType (§ class RestFn)))

    (defn- #_"FnExpr" FnExpr'init []
        (hash-map
            ;; if there is a variadic overload (there can only be one) it is stored here
            #_"FnMethod" :variadicMethod nil
            #_"IPersistentCollection" :methods nil
            #_"boolean" :hasPrimSigs false
            #_"boolean" :hasMeta false
            #_"boolean" :hasEnclosingMethod false

            #_"Class" :jc nil
        )
    )

    (defn #_"FnExpr" FnExpr'new [#_"Object" ___tag]
        (merge (ObjExpr'new ___tag) (FnExpr'init))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"FnExpr" this]
        true
    )

    #_method
    (§ defn #_"boolean" (§ method supportsMeta) [#_"FnExpr" this]
        (:hasMeta this)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"FnExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (§ class AFunction)))
        )
        (:jc this)
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"FnExpr" this, #_"ClassVisitor" ___cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [#_"ISeq" ___s (RT'seq (:methods this))] (some? ___s) [(next ___s)]
            (let [#_"ObjMethod" ___method (cast' ObjMethod (first ___s))]
                (.emit ___method, this, ___cv)
            )
        )

        (when (.isVariadic this)
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, (Method/getMethod "int getRequiredArity()"), nil, nil, ___cv)]
                (.visitCode ___gen)
                (ß ___gen.push((:reqParms (:variadicMethod this)).count()))
                (.returnValue ___gen)
                (.endMethod ___gen)
            )
        )
        nil
    )

    (defn #_"Expr" FnExpr'parse [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"ISeq" ___origForm ___form]
            (let [#_"FnExpr" ___fn (ß FnExpr'new(Compiler'tagOf(___form)))]
                (let [#_"Keyword" ___retkey (Keyword'intern-2 nil, "rettag")]
                    (let [#_"Object" ___rettag (ß RT'get-2(RT'meta(___form), ___retkey))]
                        (§ ass (:src ___fn) ___form)
                        (let [#_"ObjMethod" ___enclosingMethod (cast' ObjMethod (.deref Compiler'METHOD))]
                            (§ ass (:hasEnclosingMethod ___fn) (some? ___enclosingMethod))
                            (when (some? (.meta (cast' IMeta (first ___form))))
                                (§ ass (:onceOnly ___fn) (ß RT'booleanCast-1o(RT'get-2(RT'meta((first ___form)), Keyword'intern-2(nil, "once")))))
                            )

                            (let [#_"String" ___basename (str (if (some? ___enclosingMethod) (:name (:objx ___enclosingMethod)) (ß Compiler'munge((:name (:name (.currentNS this)))))) "$")]
                                (let [#_"Symbol" ___nm nil]
                                    (if (§ instance? Symbol (RT'second ___form))
                                        (do
                                            (§ ass ___nm (cast' Symbol (RT'second ___form)))
                                            (§ ass ___name (str (:name ___nm) "__" (RT'nextID)))
                                        )
                                        (do
                                            (cond (nil? ___name)
                                                (do
                                                    (§ ass ___name (str "fn__" (RT'nextID)))
                                                )
                                                (some? ___enclosingMethod)
                                                (do
                                                    (§ ass ___name (str ___name "__"(RT'nextID)))
                                                )
                                            )
                                        )
                                    )

                                    (let [#_"String" ___simpleName (ß Compiler'munge(___name).replace(".", "_DOT_"))]
                                        (§ ass (:name ___fn) (+ ___basename ___simpleName))
                                        (§ ass (:internalName ___fn) (ß (:name ___fn).replace(\., \/)))
                                        (§ ass (:objtype ___fn) (Type/getObjectType (:internalName ___fn)))
                                        (let [#_"ArrayList<String>" ___prims (ArrayList.)]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (object-array [
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                                                        Compiler'NO_RECUR           nil
                                                    ])
                                                )))

                                                ;; arglist might be preceded by symbol naming this fn
                                                (when (some? ___nm)
                                                    (§ ass (:thisName ___fn) (:name ___nm))
                                                    (§ ass ___form (ß RT'cons(Compiler'FN, RT'next(RT'next(___form)))))
                                                )

                                                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                ;; turn former into latter
                                                (when (§ instance? IPersistentVector (RT'second ___form))
                                                    (§ ass ___form (ß RT'list-2(Compiler'FN, RT'next(___form))))
                                                )
                                                (§ ass (:line ___fn) (Compiler'lineDeref))
                                                (§ ass (:column ___fn) (Compiler'columnDeref))
                                                (let [#_"FnMethod[]" ___methodArray (ß FnMethod'new[Compiler'MAX_POSITIONAL_ARITY + 1])]
                                                    (let [#_"FnMethod" ___variadicMethod nil]
                                                        (let [#_"boolean" ___usesThis false]
                                                            (loop-when-recur [#_"ISeq" ___s (RT'next ___form)] (some? ___s) [(RT'next ___s)]
                                                                (let [#_"FnMethod" ___f (ß FnMethod'parse(___fn, (cast' ISeq (RT'first ___s)), ___rettag))]
                                                                    (when (:usesThis ___f)
                                                                        (§ ass ___usesThis true)
                                                                    )
                                                                    (cond (.isVariadic ___f)
                                                                        (do
                                                                            (if (nil? ___variadicMethod)
                                                                                (do
                                                                                    (§ ass ___variadicMethod ___f)
                                                                                )
                                                                                (do
                                                                                    (throw (Util'runtimeException-1 "Can't have more than 1 variadic overload"))
                                                                                )
                                                                            )
                                                                        )
                                                                        (nil? (§ aget ___methodArray (ß (:reqParms ___f).count())))
                                                                        (do
                                                                            (§ ass (§ aget ___methodArray (ß (:reqParms ___f).count())) ___f)
                                                                        )
                                                                        :else
                                                                        (do
                                                                            (throw (Util'runtimeException-1 "Can't have 2 overloads with same arity"))
                                                                        )
                                                                    )
                                                                    (when (ß (some? (:prim ___f)))
                                                                        (.add ___prims, (:prim ___f))
                                                                    )
                                                                )
                                                            )
                                                            (when (some? ___variadicMethod)
                                                                (loop-when-recur [#_"int" ___i (ß (:reqParms ___variadicMethod).count() + 1)] (<= ___i Compiler'MAX_POSITIONAL_ARITY) [(inc ___i)]
                                                                    (when (some? (§ aget ___methodArray ___i))
                                                                        (throw (Util'runtimeException-1 "Can't have fixed arity function with more params than variadic function"))
                                                                    )
                                                                )
                                                            )

                                                            (§ ass (:canBeDirect ___fn) (and (not (:hasEnclosingMethod ___fn)) (zero? (.count (:closes ___fn))) (not ___usesThis)))

                                                            (let [#_"IPersistentCollection" ___methods nil]
                                                                (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___methodArray)) [(inc ___i)]
                                                                    (when (some? (§ aget ___methodArray ___i))
                                                                        (§ ass ___methods (ß RT'conj(___methods, ___methodArray[___i])))
                                                                    )
                                                                )
                                                                (when (some? ___variadicMethod)
                                                                    (§ ass ___methods (RT'conj ___methods, ___variadicMethod))
                                                                )

                                                                (when (:canBeDirect ___fn)
                                                                    (doseq [#_"FnMethod" ___fm (ß (Collection<FnMethod>)___methods)]
                                                                        (when (ß (some? (:locals ___fm)))
                                                                            (doseq [#_"LocalBinding" ___lb (ß (Collection<LocalBinding>)RT'keys((:locals ___fm)))]
                                                                                (when (:isArg ___lb)
                                                                                    (§ ass (:idx ___lb) (ß (:idx ___lb) - 1))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )

                                                                (§ ass (:methods ___fn) ___methods)
                                                                (§ ass (:variadicMethod ___fn) ___variadicMethod)
                                                                (§ ass (:keywords ___fn) (cast' IPersistentMap (.deref Compiler'KEYWORDS)))
                                                                (§ ass (:vars ___fn) (cast' IPersistentMap (.deref Compiler'VARS)))
                                                                (§ ass (:constants ___fn) (cast' PersistentVector (.deref Compiler'CONSTANTS)))
                                                                (§ ass (:keywordCallsites ___fn) (cast' IPersistentVector (.deref Compiler'KEYWORD_CALLSITES)))
                                                                (§ ass (:protocolCallsites ___fn) (cast' IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES)))
                                                                (§ ass (:varCallsites ___fn) (cast' IPersistentSet (.deref Compiler'VAR_CALLSITES)))

                                                                (§ ass (:constantsID ___fn) (RT'nextID))
                                                            )
                                                        )
                                                    )
                                                )
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                            (§ ass (:hasPrimSigs ___fn) (pos? (.size ___prims)))
                                            (let [#_"IPersistentMap" ___fmeta (RT'meta ___origForm)]
                                                (when (some? ___fmeta)
                                                    (§ ass ___fmeta (ß ___fmeta.without(RT'LINE_KEY).without(RT'COLUMN_KEY).without(RT'FILE_KEY).without(___retkey)))
                                                )

                                                (§ ass (:hasMeta ___fn) (pos? (RT'count ___fmeta)))

                                                (try
                                                    (.compile ___fn, (if (.isVariadic ___fn) "cloiure/lang/RestFn" "cloiure/lang/AFunction"), (if (zero? (.size ___prims)) nil (.toArray ___prims, (make-array String (.size ___prims)))), (:onceOnly ___fn))
                                                    (catch IOException ___e
                                                        (throw (Util'sneakyThrow ___e))
                                                    )
                                                )
                                                (.getCompiledClass ___fn)

                                                (if (.supportsMeta ___fn)
                                                    (do
                                                        (MetaExpr'new ___fn, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), ___fmeta))
                                                    )
                                                    (do
                                                        ___fn
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ObjMethod" (§ method variadicMethod) [#_"FnExpr" this]
        (:variadicMethod this)
    )

    #_method
    (§ defn #_"boolean" (§ method isVariadic) [#_"FnExpr" this]
        (some? (:variadicMethod this))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method methods) [#_"FnExpr" this]
        (:methods this)
    )

    #_method
    (§ defn #_"void" (§ method emitForDefn) [#_"FnExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß this.emit(:Context'EXPRESSION, ___objx, ___gen))
        nil
    )
)

(class-ns ObjExpr (§ implements Expr)
    (def #_"String" ObjExpr'CONST_PREFIX "const__")

    (def #_"Method" ObjExpr'voidctor (Method/getMethod "void <init>()"))

    (def #_"Method" ObjExpr'kwintern (Method/getMethod "cloiure.lang.Keyword intern(String, String)"))
    (def #_"Method" ObjExpr'symintern (Method/getMethod "cloiure.lang.Symbol intern(String)"))
    (def #_"Method" ObjExpr'varintern (Method/getMethod "cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)"))

    (§ def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (Type/getType (§ class DynamicClassLoader)))
    (def #_"Method" ObjExpr'getClassMethod (Method/getMethod "Class getClass()"))
    (def #_"Method" ObjExpr'getClassLoaderMethod (Method/getMethod "ClassLoader getClassLoader()"))
    (def #_"Method" ObjExpr'getConstantsMethod (Method/getMethod "Object[] getConstants(int)"))
    (def #_"Method" ObjExpr'readStringMethod (Method/getMethod "Object readString(String)"))

    (§ def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (Type/getType (§ class ILookupSite)))
    (§ def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (Type/getType (§ class ILookupThunk)))
    (§ def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (Type/getType (§ class KeywordLookupSite)))

    (defn- #_"ObjExpr" ObjExpr'init []
        (hash-map
            #_"String" :name nil
            #_"String" :internalName nil
            #_"String" :thisName nil
            #_"Type" :objtype nil
            #_"Object" :tag nil
            ;; localbinding->itself
            #_"IPersistentMap" :closes PersistentHashMap'EMPTY
            ;; localbndingexprs
            #_"IPersistentVector" :closesExprs PersistentVector'EMPTY
            ;; symbols
            #_"IPersistentSet" :volatiles PersistentHashSet'EMPTY

            ;; symbol->lb
            #_"IPersistentMap" :fields nil

            ;; hinted fields
            #_"IPersistentVector" :hintedFields PersistentVector'EMPTY

            ;; Keyword->KeywordExpr
            #_"IPersistentMap" :keywords PersistentHashMap'EMPTY
            #_"IPersistentMap" :vars PersistentHashMap'EMPTY
            #_"Class" :compiledClass nil
            #_"int" :line 0
            #_"int" :column 0
            #_"PersistentVector" :constants nil
            #_"IPersistentSet" :usedConstants PersistentHashSet'EMPTY

            #_"int" :constantsID 0
            #_"int" :altCtorDrops 0

            #_"IPersistentVector" :keywordCallsites nil
            #_"IPersistentVector" :protocolCallsites nil
            #_"IPersistentSet" :varCallsites nil
            #_"boolean" :onceOnly false

            #_"Object" :src nil

            #_"IPersistentMap" :opts PersistentHashMap'EMPTY

            #_protected
            #_"IPersistentMap" :classMeta nil
            #_protected
            #_"boolean" :canBeDirect false

            #_"DynamicClassLoader" :loader nil
            #_"byte[]" :bytecode nil

            #_"Class" :jc nil
        )
    )

    (defn #_"ObjExpr" ObjExpr'new [#_"Object" ___tag]
        (let [this (ObjExpr'init)]
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method name) [#_"ObjExpr" this]
        (:name this)
    )

    #_method
    (§ defn #_"String" (§ method internalName) [#_"ObjExpr" this]
        (:internalName this)
    )

    #_method
    (§ defn #_"String" (§ method thisName) [#_"ObjExpr" this]
        (:thisName this)
    )

    #_method
    (§ defn #_"Type" (§ method objtype) [#_"ObjExpr" this]
        (:objtype this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method closes) [#_"ObjExpr" this]
        (:closes this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method keywords) [#_"ObjExpr" this]
        (:keywords this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method vars) [#_"ObjExpr" this]
        (:vars this)
    )

    #_method
    (§ defn #_"Class" (§ method compiledClass) [#_"ObjExpr" this]
        (:compiledClass this)
    )

    #_method
    (§ defn #_"int" (§ method line) [#_"ObjExpr" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" (§ method column) [#_"ObjExpr" this]
        (:column this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method constants) [#_"ObjExpr" this]
        (:constants this)
    )

    #_method
    (§ defn #_"int" (§ method constantsID) [#_"ObjExpr" this]
        (:constantsID this)
    )

    (defn #_"String" ObjExpr'trimGenID [#_"String" ___name]
        (let [#_"int" ___i (.lastIndexOf ___name, "__")]
            (if (= ___i -1) ___name (.substring ___name, 0, ___i))
        )
    )

    #_method
    (§ defn #_"Type[]" (§ method ctorTypes) [#_"ObjExpr" this]
        (let [#_"IPersistentVector" ___tv (if (not (.supportsMeta this)) PersistentVector'EMPTY (RT'vector Compiler'IPERSISTENTMAP_TYPE))]
            (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(next ___s)]
                (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___s))]
                    (if (some? (.getPrimitiveType ___lb))
                        (do
                            (§ ass ___tv (ß ___tv.cons(Type/getType((.getPrimitiveType ___lb)))))
                        )
                        (do
                            (§ ass ___tv (.cons ___tv, Compiler'OBJECT_TYPE))
                        )
                    )
                )
            )
            (let [#_"Type[]" ___ret (make-array Type (count ___tv))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___tv)) [(inc ___i)]
                    (§ ass (§ aget ___ret ___i) (cast Type (.nth ___tv, ___i)))
                )
                ___ret
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method compile) [#_"ObjExpr" this, #_"String" ___superName, #_"String[]" ___interfaceNames, #_"boolean" ___oneTimeUse] #_(§ throws IOException)
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" ___cv ___cw]
                (ß ___cv.visit(Opcodes/V1_5, Opcodes/ACC_PUBLIC + Opcodes/ACC_SUPER + Opcodes/ACC_FINAL, (:internalName this), nil, ___superName, ___interfaceNames))
                (let [#_"String" ___source (cast String (.deref Compiler'SOURCE))]
                    (let [#_"int" ___lineBefore (cast Integer (.deref Compiler'LINE_BEFORE))]
                        (let [#_"int" ___lineAfter (cast Integer (inc (.deref Compiler'LINE_AFTER)))]
                            (let [#_"int" ___columnBefore (cast Integer (.deref Compiler'COLUMN_BEFORE))]
                                (let [#_"int" ___columnAfter (cast Integer (inc (.deref Compiler'COLUMN_AFTER)))]
                                    (when (and (some? ___source) (some? (.deref Compiler'SOURCE_PATH)))
                                        (let [#_"String" ___smap
                                                (str "SMAP\n"
                                                    (if (pos? (.lastIndexOf ___source, \.)) (ß ___source.substring(0, ___source.lastIndexOf(\.))) ___source)
                                                    ".java\n"
                                                    "Cloiure\n"
                                                    "*S Cloiure\n"
                                                    "*F\n"
                                                    "+ 1 " ___source "\n"
                                                    (cast String (.deref Compiler'SOURCE_PATH)) "\n"
                                                    "*L\n"
                                                    (ß String/format("%d#1,%d:%d\n", (object-array [ ___lineBefore, (- ___lineAfter ___lineBefore), ___lineBefore ])))
                                                    "*E"
                                                )]
                                            (.visitSource ___cv, ___source, ___smap)
                                        )
                                    )
                                    (ß Compiler'addAnnotation(___cv, (:classMeta this)))

                                    (when (.supportsMeta this)
                                        (ß ___cv.visitField(Opcodes/ACC_FINAL, "__meta", Compiler'IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                    )
                                    ;; instance fields for closed-overs
                                    (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(next ___s)]
                                        (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___s))]
                                            (if (.isDeftype this)
                                                (do
                                                    (let [#_"int" ___access (if (.isVolatile this, ___lb) Opcodes/ACC_VOLATILE (if (.isMutable this, ___lb) 0 (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL)))]
                                                        (§ let [#_"FieldVisitor" ___fv]
                                                            (if (some? (.getPrimitiveType ___lb))
                                                                (do
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, (:name ___lb), Type/getType((.getPrimitiveType ___lb)).getDescriptor(), nil, nil)))
                                                                )
                                                                (do
                                                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil)))
                                                                )
                                                            )
                                                            (ß Compiler'addAnnotation(___fv, RT'meta((:sym ___lb))))
                                                        )
                                                    )
                                                )
                                                (do
                                                    ;; todo - only enable this non-private+writability for letfns where we need it
                                                    (if (some? (.getPrimitiveType ___lb))
                                                        (do
                                                            (ß ___cv.visitField((if (.isVolatile this, ___lb) Opcodes/ACC_VOLATILE 0), (:name ___lb), (ß Type/getType((.getPrimitiveType ___lb)).getDescriptor()), nil, nil))
                                                        )
                                                        (do
                                                            (ß ___cv.visitField(0, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )

                                    ;; static fields for callsites and thunks
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:protocolCallsites this).count()) [(inc ___i)]
                                        (ß ___cv.visitField(Opcodes/ACC_PRIVATE + Opcodes/ACC_STATIC, this.cachedClassName(___i), Compiler'CLASS_TYPE.getDescriptor(), nil, nil))
                                    )

                                    ;; ctor that takes closed-overs and inits base + fields
                                    (let [#_"Method" ___m (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))]
                                        (let [#_"GeneratorAdapter" ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, nil, ___cv)]
                                            (let [#_"Label" ___start (.newLabel ___ctorgen)]
                                                (let [#_"Label" ___end (.newLabel ___ctorgen)]
                                                    (.visitCode ___ctorgen)
                                                    (ß ___ctorgen.visitLineNumber((:line this), (.mark ___ctorgen)))
                                                    (.visitLabel ___ctorgen, ___start)
                                                    (.loadThis ___ctorgen)
                                                    (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))

                                                    (when (.supportsMeta this)
                                                        (.loadThis ___ctorgen)
                                                        (ß ___ctorgen.visitVarInsn(Compiler'IPERSISTENTMAP_TYPE.getOpcode(Opcodes/ILOAD), 1))
                                                        (ß ___ctorgen.putField((:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE))
                                                    )

                                                    (let [#_"int" ___a (if (.supportsMeta this) 2 1)]
                                                        (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this)) ___a ___a] (some? ___s) [(next ___s) (inc ___a)]
                                                            (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___s))]
                                                                (.loadThis ___ctorgen)
                                                                (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                                                    (if (some? ___primc)
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                                                                            (when (or (ß ___primc == Long/TYPE) (ß ___primc == Double/TYPE))
                                                                                (§ ass ___a (inc ___a))
                                                                            )
                                                                        )
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                                                                        )
                                                                    )
                                                                    (§ ass (:closesExprs this) (ß (:closesExprs this).cons(LocalBindingExpr'new(___lb, nil))))
                                                                )
                                                            )
                                                        )

                                                        (.visitLabel ___ctorgen, ___end)

                                                        (.returnValue ___ctorgen)

                                                        (.endMethod ___ctorgen)

                                                        (when (> (:altCtorDrops this) 0)
                                                            ;; ctor that takes closed-overs and inits base + fields
                                                            (let [#_"Type[]" ___ctorTypes (.ctorTypes this)]
                                                                (let [#_"Type[]" ___altCtorTypes (make-array Type (- (§ alength ___ctorTypes) (:altCtorDrops this)))]
                                                                    (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___altCtorTypes)) [(inc ___i)]
                                                                        (§ ass (§ aget ___altCtorTypes ___i) (§ aget ___ctorTypes ___i))
                                                                    )
                                                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes)]
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (.visitCode ___ctorgen)
                                                                        (.loadThis ___ctorgen)
                                                                        (.loadArgs ___ctorgen)

                                                                        (.visitInsn ___ctorgen, Opcodes/ACONST_NULL) ;; __meta
                                                                        (.visitInsn ___ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                                                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hash
                                                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (.returnValue ___ctorgen)
                                                                        (.endMethod ___ctorgen)

                                                                        ;; alt ctor no __hash, __hasheq
                                                                        (§ ass ___altCtorTypes (make-array Type (- (§ alength ___ctorTypes) 2)))
                                                                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___altCtorTypes)) [(inc ___i)]
                                                                            (§ ass (§ aget ___altCtorTypes ___i) (§ aget ___ctorTypes ___i))
                                                                        )

                                                                        (§ ass ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes))
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (.visitCode ___ctorgen)
                                                                        (.loadThis ___ctorgen)
                                                                        (.loadArgs ___ctorgen)

                                                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hash
                                                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (.returnValue ___ctorgen)
                                                                        (.endMethod ___ctorgen)
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (when (.supportsMeta this)
                                                            ;; ctor that takes closed-overs but not meta
                                                            (let [#_"Type[]" ___ctorTypes (.ctorTypes this)]
                                                                (let [#_"Type[]" ___noMetaCtorTypes (make-array Type (- (§ alength ___ctorTypes) 1))]
                                                                    (loop-when-recur [#_"int" ___i 1] (< ___i (§ alength ___ctorTypes)) [(inc ___i)]
                                                                        (§ ass (§ aget ___noMetaCtorTypes (ß ___i - 1)) (§ aget ___ctorTypes ___i))
                                                                    )
                                                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___noMetaCtorTypes)]
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (.visitCode ___ctorgen)
                                                                        (.loadThis ___ctorgen)
                                                                        (.visitInsn ___ctorgen, Opcodes/ACONST_NULL) ;; nil meta
                                                                        (.loadArgs ___ctorgen)
                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (.returnValue ___ctorgen)
                                                                        (.endMethod ___ctorgen)

                                                                        ;; meta()
                                                                        (let [#_"Method" ___meth (Method/getMethod "cloiure.lang.IPersistentMap meta()")]
                                                                            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___meth, nil, nil, ___cv)]
                                                                                (.visitCode ___gen)
                                                                                (.loadThis ___gen)
                                                                                (ß ___gen.getField((:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE))

                                                                                (.returnValue ___gen)
                                                                                (.endMethod ___gen)

                                                                                ;; withMeta()
                                                                                (§ ass ___meth (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                                                                                (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___meth, nil, nil, ___cv))
                                                                                (.visitCode ___gen)
                                                                                (.newInstance ___gen, (:objtype this))
                                                                                (.dup ___gen)
                                                                                (.loadArg ___gen, 0)

                                                                                (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this)) ___a ___a] (some? ___s) [(next ___s) (inc ___a)]
                                                                                    (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___s))]
                                                                                        (.loadThis ___gen)
                                                                                        (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                                                                            (if (some? ___primc)
                                                                                                (do
                                                                                                    (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                                                                                                )
                                                                                                (do
                                                                                                    (ß ___gen.getField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )

                                                                                (ß ___gen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))
                                                                                (.returnValue ___gen)
                                                                                (.endMethod ___gen)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (.emitStatics this, ___cv)
                                                        (.emitMethods this, ___cv)

                                                        ;; static fields for constants
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants this).count()) [(inc ___i)]
                                                            (when (.contains (:usedConstants this), ___i)
                                                                (ß ___cv.visitField(Opcodes/ACC_PUBLIC + Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, this.constantName(___i), this.constantType(___i).getDescriptor(), nil, nil))
                                                            )
                                                        )

                                                        ;; static fields for lookup sites
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keywordCallsites this).count()) [(inc ___i)]
                                                            (ß ___cv.visitField(Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, this.siteNameStatic(___i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                            (ß ___cv.visitField(Opcodes/ACC_STATIC, this.thunkNameStatic(___i), ObjExpr'ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                        )

                                                        ;; static init for constants, keywords and vars
                                                        (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, ___cv)]
                                                            (.visitCode ___clinitgen)
                                                            (ß ___clinitgen.visitLineNumber((:line this), (.mark ___clinitgen)))

                                                            (when (pos? (.count (:constants this)))
                                                                (.emitConstants this, ___clinitgen)
                                                            )

                                                            (when (pos? (.count (:keywordCallsites this)))
                                                                (.emitKeywordCallsites this, ___clinitgen)
                                                            )

                                                            (when (and (.isDeftype this) (RT'booleanCast-1o (RT'get-2 (:opts this), Compiler'loadNs)))
                                                                (let [#_"String" ___nsname (ß (cast' Symbol (RT'second (:src this))).getNamespace())]
                                                                    (when (not (.equals ___nsname, "cloiure.core"))
                                                                        (.push ___clinitgen, "cloiure.core")
                                                                        (.push ___clinitgen, "require")
                                                                        (ß ___clinitgen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Var var(String, String)")))
                                                                        (ß ___clinitgen.invokeVirtual(Compiler'VAR_TYPE, Method/getMethod("Object getRawRoot()")))
                                                                        (.checkCast ___clinitgen, Compiler'IFN_TYPE)
                                                                        (.push ___clinitgen, ___nsname)
                                                                        (ß ___clinitgen.invokeStatic(Compiler'SYMBOL_TYPE, Method/getMethod("cloiure.lang.Symbol create(String)")))
                                                                        (ß ___clinitgen.invokeInterface(Compiler'IFN_TYPE, Method/getMethod("Object invoke(Object)")))
                                                                        (.pop ___clinitgen)
                                                                    )
                                                                )
                                                            )

                                                            (.returnValue ___clinitgen)

                                                            (.endMethod ___clinitgen)

                                                            ;; end of class
                                                            (.visitEnd ___cv)

                                                            (§ ass (:bytecode this) (.toByteArray ___cw))
                                                            (when (ß RT'booleanCast-1o(Compiler'COMPILE_FILES.deref()))
                                                                (ß Compiler'writeClassFile((:internalName this), (:bytecode this)))
                                                            )
                                                            nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" (§ method emitKeywordCallsites) [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keywordCallsites this).count()) [(inc ___i)]
            (let [#_"Keyword" ___k (cast' Keyword (.nth (:keywordCallsites this), ___i))]
                (.newInstance ___clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.dup ___clinitgen)
                (.emitValue this, ___k, ___clinitgen)
                (ß ___clinitgen.invokeConstructor(ObjExpr'KEYWORD_LOOKUPSITE_TYPE, Method/getMethod("void <init>(cloiure.lang.Keyword)")))
                (.dup ___clinitgen)
                (ß ___clinitgen.putStatic((:objtype this), this.siteNameStatic(___i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE))
                (ß ___clinitgen.putStatic((:objtype this), this.thunkNameStatic(___i), ObjExpr'ILOOKUP_THUNK_TYPE))
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitStatics) [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitListAsObjectArray) [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push((cast List ___value).size()))
        (.newArray ___gen, Compiler'OBJECT_TYPE)
        (loop-when-recur [#_"Iterator" ___it (.iterator (cast List ___value)) #_"int" ___i 0] (.hasNext ___it) [___it (inc ___i)]
            (.dup ___gen)
            (.push ___gen, ___i)
            (ß this.emitValue((next ___it), ___gen))
            (.arrayStore ___gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitValue) [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___partial true]
            (cond (nil? ___value)
                (do
                    (.visitInsn ___gen, Opcodes/ACONST_NULL)
                )
                (instance? String ___value)
                (do
                    (.push ___gen, (cast String ___value))
                )
                (instance? Boolean ___value)
                (do
                    (if (.booleanValue (cast Boolean ___value))
                        (do
                            (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE)
                        )
                        (do
                            (.getStatic ___gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                        )
                    )
                )
                (instance? Integer ___value)
                (do
                    (ß ___gen.push((cast Integer ___value).intValue()))
                    (ß ___gen.invokeStatic(Type/getType(Integer), Method/getMethod("Integer valueOf(int)")))
                )
                (instance? Long ___value)
                (do
                    (ß ___gen.push((cast Long ___value).longValue()))
                    (ß ___gen.invokeStatic(Type/getType(Long), Method/getMethod("Long valueOf(long)")))
                )
                (instance? Double ___value)
                (do
                    (ß ___gen.push((cast Double ___value).doubleValue()))
                    (ß ___gen.invokeStatic(Type/getType(Double), Method/getMethod("Double valueOf(double)")))
                )
                (instance? Character ___value)
                (do
                    (ß ___gen.push((cast Character ___value).charValue()))
                    (ß ___gen.invokeStatic(Type/getType(Character), Method/getMethod("Character valueOf(char)")))
                )
                (instance? Class ___value)
                (do
                    (let [#_"Class" ___cc (cast Class ___value)]
                        (if (.isPrimitive ___cc)
                            (do
                                (§ let [#_"Type" ___bt]
                                    (cond (= ___cc Boolean/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Boolean))
                                        )
                                        (= ___cc Byte/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Byte))
                                        )
                                        (= ___cc Character/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Character))
                                        )
                                        (= ___cc Double/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Double))
                                        )
                                        (= ___cc Float/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Float))
                                        )
                                        (= ___cc Integer/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Integer))
                                        )
                                        (= ___cc Long/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Long))
                                        )
                                        (= ___cc Short/TYPE)
                                        (do
                                            (§ ass ___bt (Type/getType Short))
                                        )
                                        :else
                                        (do
                                            (throw (Util'runtimeException-1 (str "Can't embed unknown primitive in code: " ___value)))
                                        )
                                    )
                                    (ß ___gen.getStatic(___bt, "TYPE", Type/getType(Class)))
                                )
                            )
                            (do
                                (ß ___gen.push(Compiler'destubClassName((.getName ___cc))))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("Class classForName(String)")))
                            )
                        )
                    )
                )
                (§ instance? Symbol ___value)
                (do
                    (ß ___gen.push((:ns (cast' Symbol ___value))))
                    (ß ___gen.push((:name (cast' Symbol ___value))))
                    (ß ___gen.invokeStatic(Type/getType((§ class Symbol)), Method/getMethod("cloiure.lang.Symbol intern(String, String)")))
                )
                (§ instance? Keyword ___value)
                (do
                    (ß ___gen.push((:ns (:sym (cast' Keyword ___value)))))
                    (ß ___gen.push((:name (:sym (cast' Keyword ___value)))))
                    (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Keyword keyword(String, String)")))
                )
                (§ instance? Var ___value)
                (do
                    (let [#_"Var" ___var (cast' Var ___value)]
                        (ß ___gen.push((:name (:ns ___var)).toString()))
                        (ß ___gen.push((:sym ___var).toString()))
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Var var(String, String)")))
                    )
                )
                (§ instance? IType ___value)
                (do
                    (let [#_"Method" ___ctor (Method. "<init>", (Type/getConstructorDescriptor (ß (.getClass ___value).getConstructors()[0])))]
                        (ß ___gen.newInstance(Type/getType((.getClass ___value))))
                        (.dup ___gen)
                        (let [#_"IPersistentVector" ___fields (cast' IPersistentVector (ß Reflector'invokeStaticMethod-3c((.getClass ___value), "getBasis", (object-array 0))))]
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___fields)] (some? ___s) [(next ___s)]
                                (let [#_"Symbol" ___field (cast' Symbol (first ___s))]
                                    (let [#_"Class" ___k (ß Compiler'tagClass(Compiler'tagOf(___field)))]
                                        (let [#_"Object" ___val (ß Reflector'getInstanceField(___value, Compiler'munge((:name ___field))))]
                                            (.emitValue this, ___val, ___gen)

                                            (when (.isPrimitive ___k)
                                                (let [#_"Type" ___b (Type/getType (Compiler'boxClass ___k))]
                                                    (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                        (let [#_"String" ___n (.getName ___k)]
                                                            (ß ___gen.invokeVirtual(___b, (Method. (str ___n "Value"), (str "()" ___p))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeConstructor(Type/getType((.getClass ___value)), ___ctor))
                        )
                    )
                )
                (§ instance? IRecord ___value)
                (do
                    (let [#_"Method" ___createMethod (Method/getMethod (str (.getName (.getClass ___value)) " create(cloiure.lang.IPersistentMap)"))]
                        (ß this.emitValue(PersistentArrayMap'create((java.util.Map) ___value), ___gen))
                        (ß ___gen.invokeStatic(Compiler'getType((.getClass ___value)), ___createMethod))
                    )
                )
                (§ instance? IPersistentMap ___value)
                (do
                    (let [#_"List" ___entries (ArrayList.)]
                        (doseq [#_"Map$Entry" ___entry (ß (Set<Map$Entry>) (cast Map ___value).entrySet())]
                            (.add ___entries, (.getKey ___entry))
                            (.add ___entries, (.getValue ___entry))
                        )
                        (.emitListAsObjectArray this, ___entries, ___gen)
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                    )
                )
                (§ instance? IPersistentVector ___value)
                (do
                    (let [#_"IPersistentVector" ___args (cast' IPersistentVector ___value)]
                        (if (ß (count ___args) <= Tuple'MAX_SIZE)
                            (do
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
                                    (ß this.emitValue(___args.nth(___i), ___gen))
                                )
                                (ß ___gen.invokeStatic(Compiler'TUPLE_TYPE, Compiler'createTupleMethods[(count ___args)]))
                            )
                            (do
                                (.emitListAsObjectArray this, ___value, ___gen)
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                            )
                        )
                    )
                )
                (§ instance? PersistentHashSet ___value)
                (do
                    (let [#_"ISeq" ___vs (RT'seq ___value)]
                        (if (nil? ___vs)
                            (do
                                (ß ___gen.getStatic(Type/getType((§ class PersistentHashSet)), "EMPTY", Type/getType((§ class PersistentHashSet))))
                            )
                            (do
                                (.emitListAsObjectArray this, ___vs, ___gen)
                                (ß ___gen.invokeStatic(Type/getType((§ class PersistentHashSet)), Method/getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                            )
                        )
                    )
                )
                (or (§ instance? ISeq ___value) (§ instance? IPersistentList ___value))
                (do
                    (.emitListAsObjectArray this, ___value, ___gen)
                    (ß ___gen.invokeStatic(Type/getType(java.util.Arrays), Method/getMethod("java.util.List asList(Object[])")))
                    (ß ___gen.invokeStatic(Type/getType((§ class PersistentList)), Method/getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                )
                (instance? Pattern ___value)
                (do
                    (ß this.emitValue((.toString ___value), ___gen))
                    (ß ___gen.invokeStatic(Type/getType(Pattern), Method/getMethod("java.util.regex.Pattern compile(String)")))
                )
                :else
                (do
                    (let [#_"String" ___cs nil]
                        (try
                            (§ ass ___cs (RT'printString ___value))
                            (catch Exception ___e
                                (throw (Util'runtimeException-1 (str "Can't embed object in code, maybe print-dup not defined: " ___value)))
                            )
                        )
                        (when (zero? (.length ___cs))
                            (throw (Util'runtimeException-1 (str "Can't embed unreadable object in code: " ___value)))
                        )

                        (when (.startsWith ___cs, "#<")
                            (throw (Util'runtimeException-1 (str "Can't embed unreadable object in code: " ___cs)))
                        )

                        (.push ___gen, ___cs)
                        (.invokeStatic ___gen, Compiler'RT_TYPE, readStringMethod)
                        (§ ass ___partial false)
                    )
                )
            )

            (when ___partial
                (when (and (§ instance? IObj ___value) (pos? (RT'count (.meta (cast' IObj ___value)))))
                    (.checkCast ___gen, Compiler'IOBJ_TYPE)
                    (let [#_"Object" ___m (.meta (cast' IObj ___value))]
                        (ß this.emitValue(Compiler'elideMeta(___m), ___gen))
                        (.checkCast ___gen, Compiler'IPERSISTENTMAP_TYPE)
                        (ß ___gen.invokeInterface(Compiler'IOBJ_TYPE, Method/getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                    )
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emitConstants) [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (try
            (ß Var'pushThreadBindings(RT'map(
                (object-array [
                    RT'PRINT_DUP RT'T
                ])
            )))

            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants this).count()) [(inc ___i)]
                (when (.contains (:usedConstants this), ___i)
                    (ß this.emitValue((:constants this).nth(___i), ___clinitgen))
                    (ß ___clinitgen.checkCast(this.constantType(___i)))
                    (ß ___clinitgen.putStatic((:objtype this), this.constantName(___i), this.constantType(___i)))
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isMutable) [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (or (.isVolatile this, ___lb) (and (ß RT'booleanCast-1o(RT'contains((:fields this), (:sym ___lb)))) (ß RT'booleanCast-1o(RT'get-2((:sym ___lb).meta(), Keyword'intern-1("unsynchronized-mutable"))))))
    )

    #_method
    (§ defn #_"boolean" (§ method isVolatile) [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (and (ß RT'booleanCast-1o(RT'contains((:fields this), (:sym ___lb)))) (ß RT'booleanCast-1o(RT'get-2((:sym ___lb).meta(), Keyword'intern-1("volatile-mutable")))))
    )

    #_method
    (§ defn #_"boolean" (§ method isDeftype) [#_"ObjExpr" this]
        (some? (:fields this))
    )

    #_method
    (§ defn #_"boolean" (§ method supportsMeta) [#_"ObjExpr" this]
        (not (.isDeftype this))
    )

    #_method
    (§ defn #_"void" (§ method emitClearCloses) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Class" (§ method getCompiledClass) [#_"ObjExpr" this]
        (§ sync this
            (when (nil? (:compiledClass this))
                (§ ass (:loader this) (cast' DynamicClassLoader (.deref Compiler'LOADER)))
                (§ ass (:compiledClass this) (ß (:loader this).defineClass((:name this), (:bytecode this), (:src this))))
            )
            (:compiledClass this)
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ObjExpr" this]
        (when (.isDeftype this)
            (§ return nil)
        )
        (try
            (.newInstance (.getCompiledClass this))
            (catch Exception ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitLetFnInits) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"IPersistentSet" ___letFnLocals]
        ;; objx arg is enclosing objx, not this
        (.checkCast ___gen, (:objtype this))

        (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(next ___s)]
            (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___s))]
                (when (.contains ___letFnLocals, ___lb)
                    (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                        (.dup ___gen)
                        (if (some? ___primc)
                            (do
                                (.emitUnboxedLocal ___objx, ___gen, ___lb)
                                (ß ___gen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                            )
                            (do
                                (.emitLocal ___objx, ___gen, ___lb, false)
                                (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
        )
        (.pop ___gen)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ObjExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (if (.isDeftype this)
            (do
                (.visitInsn ___gen, Opcodes/ACONST_NULL)
            )
            (do
                (.newInstance ___gen, (:objtype this))
                (.dup ___gen)
                (when (.supportsMeta this)
                    (.visitInsn ___gen, Opcodes/ACONST_NULL)
                )
                (loop-when-recur [#_"ISeq" ___s (RT'seq (:closesExprs this))] (some? ___s) [(next ___s)]
                    (let [#_"LocalBindingExpr" ___lbe (cast' LocalBindingExpr (first ___s))]
                        (let [#_"LocalBinding" ___lb (:b ___lbe)]
                            (if (some? (.getPrimitiveType ___lb))
                                (do
                                    (.emitUnboxedLocal ___objx, ___gen, ___lb)
                                )
                                (do
                                    (.emitLocal ___objx, ___gen, ___lb, (:shouldClear ___lbe))
                                )
                            )
                        )
                    )
                )
                (ß ___gen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ObjExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ObjExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (cond (some? (:compiledClass this)) (:compiledClass this) (some? (:tag this)) (HostExpr'tagToClass (:tag this)) :else (§ class IFn)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"void" (§ method emitAssignLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"Expr" ___val]
        (when (not (.isMutable this, ___lb))
            (throw (IllegalArgumentException. (str "Cannot assign to non-mutable: " (:name ___lb))))
        )
        (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
            (.loadThis ___gen)
            (if (some? ___primc)
                (do
                    (when (not (and (§ instance? MaybePrimitiveExpr ___val) (.canEmitPrimitive (cast' MaybePrimitiveExpr ___val))))
                        (throw (IllegalArgumentException. (str "Must assign primitive to primitive mutable: " (:name ___lb))))
                    )
                    (let [#_"MaybePrimitiveExpr" ___me (cast' MaybePrimitiveExpr ___val)]
                        (ß ___me.emitUnboxed(:Context'EXPRESSION, this, ___gen))
                        (ß ___gen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                    )
                )
                (do
                    (ß ___val.emit(:Context'EXPRESSION, this, ___gen))
                    (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                )
            )
            nil
        )
    )

    #_method
    (§ defn- #_"void" (§ method emitLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"boolean" ___clear]
        (if (.containsKey (:closes this), ___lb)
            (do
                (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                    (.loadThis ___gen)
                    (if (some? ___primc)
                        (do
                            (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                            (HostExpr'emitBoxReturn this, ___gen, ___primc)
                        )
                        (do
                            (ß ___gen.getField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            (when (and (:onceOnly this) ___clear (:canBeCleared ___lb))
                                (.loadThis ___gen)
                                (.visitInsn ___gen, Opcodes/ACONST_NULL)
                                (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
            (do
                (let [#_"int" ___argoff (if (:canBeDirect this) 0 1)]
                    (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                        (if (:isArg ___lb)
                            (do
                                (ß ___gen.loadArg(___lb.idx-argoff))
                                (cond (some? ___primc)
                                    (do
                                        (HostExpr'emitBoxReturn this, ___gen, ___primc)
                                    )
                                    (and ___clear (:canBeCleared ___lb))
                                    (do
                                        (.visitInsn ___gen, Opcodes/ACONST_NULL)
                                        (ß ___gen.storeArg((:idx ___lb) - ___argoff))
                                    )
                                )
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                                        (HostExpr'emitBoxReturn this, ___gen, ___primc)
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                                        (when (and ___clear (:canBeCleared ___lb))
                                            (.visitInsn ___gen, Opcodes/ACONST_NULL)
                                            (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitUnboxedLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb]
        (let [#_"int" ___argoff (if (:canBeDirect this) 0 1)]
            (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                (cond (.containsKey (:closes this), ___lb)
                    (do
                        (.loadThis ___gen)
                        (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                    )
                    (:isArg ___lb)
                    (do
                        (ß ___gen.loadArg(___lb.idx-argoff))
                    )
                    :else
                    (do
                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                    )
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitVar) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___var]
        (let [#_"Integer" ___i (cast Integer (.valAt (:vars this), ___var))]
            (.emitConstant this, ___gen, ___i)
            nil
        )
    )

    (def #_"Method" ObjExpr'varGetMethod (Method/getMethod "Object get()"))
    (def #_"Method" ObjExpr'varGetRawMethod (Method/getMethod "Object getRawRoot()"))

    #_method
    (§ defn #_"void" (§ method emitVarValue) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___v]
        (let [#_"Integer" ___i (cast Integer (.valAt (:vars this), ___v))]
            (if (not (.isDynamic ___v))
                (do
                    (.emitConstant this, ___gen, ___i)
                    (.invokeVirtual ___gen, Compiler'VAR_TYPE, ObjExpr'varGetRawMethod)
                )
                (do
                    (.emitConstant this, ___gen, ___i)
                    (.invokeVirtual ___gen, Compiler'VAR_TYPE, varGetMethod)
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emitKeyword) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Keyword" ___k]
        (let [#_"Integer" ___i (cast Integer (.valAt (:keywords this), ___k))]
            (.emitConstant this, ___gen, ___i)
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emitConstant) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"int" ___id]
        (§ ass (:usedConstants this) (cast' IPersistentSet (.cons (:usedConstants this), ___id)))
        (ß ___gen.getStatic((:objtype this), this.constantName(___id), this.constantType(___id)))
        nil
    )

    #_method
    (§ defn #_"String" (§ method constantName) [#_"ObjExpr" this, #_"int" ___id]
        (str ObjExpr'CONST_PREFIX ___id)
    )

    #_method
    (§ defn #_"String" (§ method siteName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__site__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method siteNameStatic) [#_"ObjExpr" this, #_"int" ___n]
        (str (.siteName this, ___n) "__")
    )

    #_method
    (§ defn #_"String" (§ method thunkName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__thunk__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method cachedClassName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__cached_class__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method cachedVarName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__cached_var__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method varCallsiteName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__var__callsite__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method thunkNameStatic) [#_"ObjExpr" this, #_"int" ___n]
        (str (.thunkName this, ___n) "__")
    )

    #_method
    (§ defn #_"Type" (§ method constantType) [#_"ObjExpr" this, #_"int" ___id]
        (let [#_"Object" ___o (.nth (:constants this), ___id)]
            (let [#_"Class" ___c (ß cloiure.lang.Util'classOf(___o))]
                (when (and (some? ___c) (Modifier/isPublic (.getModifiers ___c)))
                    ;; can't emit derived fn types due to visibility
                    (cond (.isAssignableFrom (§ class LazySeq), ___c)
                        (do
                            (§ return (Type/getType (§ class ISeq)))
                        )
                        (ß ___c == (§ class Keyword))
                        (do
                            (§ return (Type/getType (§ class Keyword)))
                        )
                        (.isAssignableFrom (§ class RestFn), ___c)
                        (do
                            (§ return (Type/getType (§ class RestFn)))
                        )
                        (.isAssignableFrom (§ class AFn), ___c)
                        (do
                            (§ return (Type/getType (§ class AFn)))
                        )
                        (ß ___c == (§ class Var))
                        (do
                            (§ return (Type/getType (§ class Var)))
                        )
                        (= ___c String)
                        (do
                            (§ return (Type/getType String))
                        )
                    )
                )
                Compiler'OBJECT_TYPE
            )
        )
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (defn- #_"PathNode" PathNode'init []
        (hash-map
            #_"PathType" :type nil
            #_"PathNode" :parent nil
        )
    )

    (defn #_"PathNode" PathNode'new [#_"PathType" ___type, #_"PathNode" ___parent]
        (let [this (PathNode'init)]
            (§ ass (:type this) ___type)
            (§ ass (:parent this) ___parent)
            this
        )
    )
)

(def PState'enum-set
    (hash-set
        :PState'REQ
        :PState'REST
        :PState'DONE
    )
)

(class-ns FnMethod (§ extends ObjMethod)
    (defn- #_"FnMethod" FnMethod'init []
        (hash-map
            ;; localbinding->localbinding
            #_"PersistentVector" :reqParms PersistentVector'EMPTY
            #_"LocalBinding" :restParm nil
            #_"Type[]" :argtypes nil
            #_"Class[]" :argclasses nil
            #_"Class" :retClass nil
            #_"String" :prim nil
        )
    )

    (defn #_"FnMethod" FnMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (merge (ObjMethod'new ___objx, ___parent) (FnMethod'init))
    )

    (defn #_"char" FnMethod'classChar [#_"Object" ___x]
        (let [#_"Class" ___c nil]
            (cond (instance? Class ___x)
                (do
                    (§ ass ___c (cast Class ___x))
                )
                (§ instance? Symbol ___x)
                (do
                    (§ ass ___c (ß Compiler'primClass-1s((cast' Symbol ___x))))
                )
            )
            (when (or (nil? ___c) (not (.isPrimitive ___c)))
                (§ return \O)
            )
            (when (= ___c Long/TYPE)
                (§ return \L)
            )
            (when (= ___c Double/TYPE)
                (§ return \D)
            )
            (throw (IllegalArgumentException. "Only long and double primitives are supported"))
        )
    )

    (defn #_"String" FnMethod'primInterface [#_"IPersistentVector" ___arglist]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___arglist)) [(inc ___i)]
                (ß ___sb.append(classChar(Compiler'tagOf(___arglist.nth(___i)))))
            )
            (ß ___sb.append(classChar(Compiler'tagOf(___arglist))))
            (let [#_"String" ___ret (.toString ___sb)]
                (let [#_"boolean" ___prim (or (.contains ___ret, "L") (.contains ___ret, "D"))]
                    (when (and ___prim (ß (count ___arglist) > 4))
                        (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    )
                    (when ___prim
                        (§ return (str "cloiure.lang.IFn$" ___ret))
                    )
                    nil
                )
            )
        )
    )

    (defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Object" ___rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" ___parms (cast' IPersistentVector (RT'first ___form))]
            (let [#_"ISeq" ___body (RT'next ___form)]
                (try
                    (let [#_"FnMethod" ___method (ß FnMethod'new(___objx, (cast' ObjMethod (.deref Compiler'METHOD))))]
                        (§ ass (:line ___method) (Compiler'lineDeref))
                        (§ ass (:column ___method) (Compiler'columnDeref))
                        ;; register as the current method and set up a new env frame
                        (let [#_"PathNode" ___pnode (cast' PathNode (.get Compiler'CLEAR_PATH))]
                            (when (nil? ___pnode)
                                (§ ass ___pnode (ß PathNode'new(:PathType'PATH, nil)))
                            )
                            (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                (object-array [
                                    Compiler'METHOD                ___method
                                    Compiler'LOCAL_ENV             (.deref Compiler'LOCAL_ENV)
                                    Compiler'LOOP_LOCALS           nil
                                    Compiler'NEXT_LOCAL_NUM        0
                                    Compiler'CLEAR_PATH            ___pnode
                                    Compiler'CLEAR_ROOT            ___pnode
                                    Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                    Compiler'METHOD_RETURN_CONTEXT RT'T
                                ])
                            )))

                            (§ ass (:prim ___method) (primInterface ___parms))
                            (when (ß (some? (:prim ___method)))
                                (§ ass (:prim ___method) (ß (:prim ___method).replace(\., \/)))
                            )

                            (when (instance? String ___rettag)
                                (§ ass ___rettag (ß Symbol'intern-2(nil, (cast String ___rettag))))
                            )
                            (when (not (§ instance? Symbol ___rettag))
                                (§ ass ___rettag nil)
                            )
                            (when (some? ___rettag)
                                (let [#_"String" ___retstr (.getName (cast' Symbol ___rettag))]
                                    (when (not (or (.equals ___retstr, "long") (.equals ___retstr, "double")))
                                        (§ ass ___rettag nil)
                                    )
                                )
                            )
                            (§ ass (:retClass ___method) (Compiler'tagClass (or (Compiler'tagOf ___parms) ___rettag)))
                            (if (.isPrimitive (:retClass ___method))
                                (do
                                    (when (not (or (ß (:retClass ___method) == Double/TYPE) (ß (:retClass ___method) == Long/TYPE)))
                                        (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                    )
                                )
                                (do
                                    (§ ass (:retClass ___method) Object)
                                )
                            )
                            ;; register 'this' as local 0
                            (if (ß (some? (:thisName ___objx)))
                                (do
                                    (ß Compiler'registerLocal(Symbol'intern-1((:thisName ___objx)), nil, nil, false))
                                )
                                (do
                                    (Compiler'getAndIncLocalNum)
                                )
                            )
                            (let [#_"PState" ___state (ß :PState'REQ)]
                                (let [#_"PersistentVector" ___argLocals PersistentVector'EMPTY]
                                    (let [#_"ArrayList<Type>" ___argtypes (ArrayList.)]
                                        (let [#_"ArrayList<Class>" ___argclasses (ArrayList.)]
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                (when (not (§ instance? Symbol (.nth ___parms, ___i)))
                                                    (throw (IllegalArgumentException. "fn params must be Symbols"))
                                                )
                                                (let [#_"Symbol" ___p (cast' Symbol (.nth ___parms, ___i))]
                                                    (when (some? (.getNamespace ___p))
                                                        (throw (Util'runtimeException-1 (str "Can't use qualified name as parameter: " ___p)))
                                                    )
                                                    (if (.equals ___p, Compiler'_AMP_)
                                                        (do
                                                            (if (ß ___state == :PState'REQ)
                                                                (do
                                                                    (§ ass ___state (ß :PState'REST))
                                                                )
                                                                (do
                                                                    (throw (Util'runtimeException-1 "Invalid parameter list"))
                                                                )
                                                            )
                                                        )
                                                        (do
                                                            (let [#_"Class" ___pc (ß Compiler'primClass-1c(Compiler'tagClass(Compiler'tagOf(___p))))]
                                                                (when (and (.isPrimitive ___pc) (not (or (ß ___pc == Double/TYPE) (ß ___pc == Long/TYPE))))
                                                                    (throw (IllegalArgumentException. (str "Only long and double primitives are supported: " ___p)))
                                                                )

                                                                (when (and (= ___state :PState'REST) (some? (Compiler'tagOf ___p)))
                                                                    (throw (Util'runtimeException-1 "& arg cannot have type hint"))
                                                                )
                                                                (when (and (= ___state :PState'REST) (some? (:prim ___method)))
                                                                    (throw (Util'runtimeException-1 "fns taking primitives cannot be variadic"))
                                                                )

                                                                (when (ß ___state == :PState'REST)
                                                                    (§ ass ___pc (§ class ISeq))
                                                                )
                                                                (ß ___argtypes.add(Type/getType(___pc)))
                                                                (.add ___argclasses, ___pc)
                                                                (let [#_"LocalBinding" ___lb (if (.isPrimitive ___pc) (Compiler'registerLocal ___p, nil, (MethodParamExpr'new ___pc), true) (Compiler'registerLocal ___p, (if (= ___state :PState'REST) Compiler'ISEQ (Compiler'tagOf ___p)), nil, true))]
                                                                    (§ ass ___argLocals (.cons ___argLocals, ___lb))
                                                                    (§ switch ___state
                                                                        (§ case :PState'REQ)
                                                                        (do
                                                                            (§ ass (:reqParms ___method) (.cons (:reqParms ___method), ___lb))
                                                                            (§ break )
                                                                        )
                                                                        (§ case :PState'REST)
                                                                        (do
                                                                            (§ ass (:restParm ___method) ___lb)
                                                                            (§ ass ___state (ß :PState'DONE))
                                                                            (§ break )
                                                                        )
                                                                        (§ default )
                                                                        (do
                                                                            (throw (Util'runtimeException-1 "Unexpected parameter"))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (when (ß (:reqParms ___method).count() > Compiler'MAX_POSITIONAL_ARITY)
                                                (throw (Util'runtimeException-1 (str "Can't specify more than " Compiler'MAX_POSITIONAL_ARITY " params")))
                                            )
                                            (.set Compiler'LOOP_LOCALS, ___argLocals)
                                            (§ ass (:argLocals ___method) ___argLocals)
                                            (§ ass (:argtypes ___method) (.toArray ___argtypes, (make-array Type (.size ___argtypes))))
                                            (§ ass (:argclasses ___method) (.toArray ___argclasses, (make-array Class (.size ___argtypes))))
                                            (when (ß (some? (:prim ___method)))
                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:argclasses ___method))) [(inc ___i)]
                                                    (when (or (ß (:argclasses ___method)[___i] == Long/TYPE) (ß (:argclasses ___method)[___i] == Double/TYPE))
                                                        (Compiler'getAndIncLocalNum)
                                                    )
                                                )
                                            )
                                            (§ ass (:body ___method) (ß (BodyParser'new()).parse(:Context'RETURN, ___body)))
                                            ___method
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (cond (:canBeDirect ___fn)
            (do
                (.doEmitStatic this, ___fn, ___cv)
            )
            (some? (:prim this))
            (do
                (.doEmitPrim this, ___fn, ___cv)
            )
            :else
            (do
                (.doEmit this, ___fn, ___cv)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmitStatic) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Type" ___returnType (Type/getType (:retClass this))]
            (let [#_"Method" ___ms (Method. "invokeStatic", ___returnType, (:argtypes this))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ___ms, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                    (.visitCode ___gen)
                    (let [#_"Label" ___loopLabel (.mark ___gen)]
                        (.visitLineNumber ___gen, (:line this), ___loopLabel)
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'LOOP_LABEL ___loopLabel
                                    Compiler'METHOD     this
                                ])
                            )))
                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))

                            (let [#_"Label" ___end (.mark ___gen)]
                                (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                    (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___lbs))]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argtypes this)[(:idx ___lb)].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue ___gen)
                        (.endMethod ___gen)

                        ;; generate the regular invoke, calling the static method
                        (let [#_"Method" ___m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv))
                            (.visitCode ___gen)
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:argtypes this))) [(inc ___i)]
                                (.loadArg ___gen, ___i)
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, (:argclasses this)[___i]))
                                (when (not (ß (:argclasses this)[___i].isPrimitive()))
                                    (.visitInsn ___gen, Opcodes/ACONST_NULL)
                                    (.storeArg ___gen, ___i)
                                )
                            )
                            (let [#_"Label" ___callLabel (.mark ___gen)]
                                (.visitLineNumber ___gen, (:line this), ___callLabel)
                                (ß ___gen.invokeStatic((:objtype (:objx this)), ___ms))
                                (.box ___gen, ___returnType)

                                (.returnValue ___gen)
                                (.endMethod ___gen)

                                ;; generate primInvoke if prim
                                (when (some? (:prim this))
                                    (when (or (ß (:retClass this) == Double/TYPE) (ß (:retClass this) == Long/TYPE))
                                        (§ ass ___returnType (.getReturnType this))
                                    )
                                    (let [#_"else" ___returnType Compiler'OBJECT_TYPE]
                                        (let [#_"Method" ___pm (Method. "invokePrim", ___returnType, (:argtypes this))]
                                            ;; todo don't hardwire EXCEPTION_TYPES
                                            (§ ass ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ___pm, nil, Compiler'EXCEPTION_TYPES, ___cv))
                                            (.visitCode ___gen)
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:argtypes this))) [(inc ___i)]
                                                (.loadArg ___gen, ___i)
                                                (when (not (ß (:argclasses this)[___i].isPrimitive()))
                                                    (.visitInsn ___gen, Opcodes/ACONST_NULL)
                                                    (.storeArg ___gen, ___i)
                                                )
                                            )
                                            (ß ___gen.invokeStatic((:objtype (:objx this)), ___ms))

                                            (.returnValue ___gen)
                                            (.endMethod ___gen)
                                        )
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method doEmitPrim) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (§ let [#_"Type" ___returnType]
            (if (or (ß (:retClass this) == Double/TYPE) (ß (:retClass this) == Long/TYPE))
                (do
                    (§ ass ___returnType (.getReturnType this))
                )
                (do
                    (§ ass ___returnType Compiler'OBJECT_TYPE)
                )
            )
            (let [#_"Method" ___ms (Method. "invokePrim", ___returnType, (:argtypes this))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ___ms, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                    (.visitCode ___gen)

                    (let [#_"Label" ___loopLabel (.mark ___gen)]
                        (.visitLineNumber ___gen, (:line this), ___loopLabel)
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'LOOP_LABEL ___loopLabel
                                    Compiler'METHOD     this
                                ])
                            )))
                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))

                            (let [#_"Label" ___end (.mark ___gen)]
                                (.visitLocalVariable ___gen, "this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0)
                                (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                    (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___lbs))]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argtypes this)[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue ___gen)
                        (.endMethod ___gen)

                        ;; generate the regular invoke, calling the prim method
                        (let [#_"Method" ___m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv))
                            (.visitCode ___gen)
                            (.loadThis ___gen)
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:argtypes this))) [(inc ___i)]
                                (.loadArg ___gen, ___i)
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, (:argclasses this)[___i]))
                            )
                            (.invokeInterface ___gen, (Type/getType (str "L" (:prim this) ";")), ___ms)
                            (.box ___gen, (.getReturnType this))

                            (.returnValue ___gen)
                            (.endMethod ___gen)
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                (.visitCode ___gen)

                (let [#_"Label" ___loopLabel (.mark ___gen)]
                    (.visitLineNumber ___gen, (:line this), ___loopLabel)
                    (try
                        (ß Var'pushThreadBindings(RT'map(
                            (object-array [
                                Compiler'LOOP_LABEL ___loopLabel
                                Compiler'METHOD     this
                            ])
                        )))

                        (ß (:body this).emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (.mark ___gen)]
                            (.visitLocalVariable ___gen, "this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0)
                            (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___lbs))]
                                    (.visitLocalVariable ___gen, (:name ___lb), "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx ___lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue ___gen)
                    (.endMethod ___gen)
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"PersistentVector" (§ method reqParms) [#_"FnMethod" this]
        (:reqParms this)
    )

    #_method
    (§ defn #_"LocalBinding" (§ method restParm) [#_"FnMethod" this]
        (:restParm this)
    )

    #_method
    (§ defn #_"boolean" (§ method isVariadic) [#_"FnMethod" this]
        (some? (:restParm this))
    )

    #_method
    (§ defn #_"int" (§ method numParams) [#_"FnMethod" this]
        (+ (.count (:reqParms this)) (if (.isVariadic this) 1 0))
    )

    #_method
    (§ defn #_"String" (§ method getMethodName) [#_"FnMethod" this]
        (if (.isVariadic this) "doInvoke" "invoke")
    )

    #_method
    (§ defn #_"Type" (§ method getReturnType) [#_"FnMethod" this]
        (when (some? (:prim this)) ;; objx.isStatic
            (§ return (Type/getType (:retClass this)))
        )
        Compiler'OBJECT_TYPE
    )

    #_method
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"FnMethod" this]
        (when (and (.isVariadic this) (ß (.count (:reqParms this)) == Compiler'MAX_POSITIONAL_ARITY))
            (let [#_"Type[]" ___ret (make-array Type (ß Compiler'MAX_POSITIONAL_ARITY + 1))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < Compiler'MAX_POSITIONAL_ARITY + 1) [(inc ___i)]
                    (§ ass (§ aget ___ret ___i) Compiler'OBJECT_TYPE)
                )
                (§ return ___ret)
            )
        )
        (ß Compiler'ARG_TYPES[(.numParams this)])
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocals) [#_"FnMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )
)

#_abstract
(class-ns ObjMethod
    (defn- #_"ObjMethod" ObjMethod'init []
        (hash-map
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            #_"ObjMethod" :parent nil
            ;; localbinding->localbinding
            #_"IPersistentMap" :locals nil
            ;; num->localbinding
            #_"IPersistentMap" :indexlocals nil
            #_"Expr" :body nil
            #_"ObjExpr" :objx nil
            #_"PersistentVector" :argLocals nil
            #_"int" :maxLocal 0
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :usesThis false
            #_"PersistentHashSet" :localsUsedInCatchFinally PersistentHashSet'EMPTY
            #_protected
            #_"IPersistentMap" :methodMeta nil
        )
    )

    (defn #_"ObjMethod" ObjMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (let [this (ObjMethod'init)]
            (§ ass (:parent this) ___parent)
            (§ ass (:objx this) ___objx)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method locals) [#_"ObjMethod" this]
        (:locals this)
    )

    #_method
    (§ defn #_"Expr" (§ method body) [#_"ObjMethod" this]
        (:body this)
    )

    #_method
    (§ defn #_"ObjExpr" (§ method objx) [#_"ObjMethod" this]
        (:objx this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method argLocals) [#_"ObjMethod" this]
        (:argLocals this)
    )

    #_method
    (§ defn #_"int" (§ method maxLocal) [#_"ObjMethod" this]
        (:maxLocal this)
    )

    #_method
    (§ defn #_"int" (§ method line) [#_"ObjMethod" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" (§ method column) [#_"ObjMethod" this]
        (:column this)
    )

    (defn #_"void" ObjMethod'emitBody [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___retClass, #_"Expr" ___body]
        (let [#_"MaybePrimitiveExpr" ___be (cast' MaybePrimitiveExpr ___body)]
            (if (and (Util'isPrimitive ___retClass) (.canEmitPrimitive ___be))
                (do
                    (let [#_"Class" ___bc (Compiler'maybePrimitiveType ___be)]
                        (cond (= ___bc ___retClass)
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                            )
                            (and (ß ___retClass == Long/TYPE) (ß ___bc == Integer/TYPE))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (.visitInsn ___gen, Opcodes/I2L)
                            )
                            (and (ß ___retClass == Double/TYPE) (ß ___bc == Float/TYPE))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (.visitInsn ___gen, Opcodes/F2D)
                            )
                            (and (ß ___retClass == Integer/TYPE) (ß ___bc == Long/TYPE))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                            )
                            (and (ß ___retClass == Float/TYPE) (ß ___bc == Double/TYPE))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (.visitInsn ___gen, Opcodes/D2F)
                            )
                            :else
                            (do
                                (throw (IllegalArgumentException. (str "Mismatched primitive return, expected: " ___retClass ", had: " (.getJavaClass ___be))))
                            )
                        )
                    )
                )
                (do
                    (ß ___body.emit(:Context'RETURN, ___objx, ___gen))
                    (if (= ___retClass Void/TYPE)
                        (do
                            (.pop ___gen)
                        )
                        (do
                            (ß ___gen.unbox(Type/getType(___retClass)))
                        )
                    )
                )
            )
            nil
        )
    )

    #_abstract
    (§ defn #_"int" (§ method numParams) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"String" (§ method getMethodName) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type" (§ method getReturnType) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"ObjMethod" this])

    #_method
    (§ defn #_"void" (§ method emit) [#_"ObjMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                (.visitCode ___gen)

                (let [#_"Label" ___loopLabel (.mark ___gen)]
                    (.visitLineNumber ___gen, (:line this), ___loopLabel)
                    (try
                        (ß Var'pushThreadBindings(RT'map(
                            (object-array [
                                Compiler'LOOP_LABEL ___loopLabel
                                Compiler'METHOD     this
                            ])
                        )))

                        (ß (:body this).emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (.mark ___gen)]
                            (.visitLocalVariable ___gen, "this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0)
                            (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___lbs))]
                                    (.visitLocalVariable ___gen, (:name ___lb), "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx ___lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue ___gen)
                    (.endMethod ___gen)
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocals) [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocalsOld) [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argLocals this).count()) [(inc ___i)]
            (let [#_"LocalBinding" ___lb (cast' LocalBinding (.nth (:argLocals this), ___i))]
                (when (and (not (.contains (:localsUsedInCatchFinally this), (:idx ___lb))) (nil? (.getPrimitiveType ___lb)))
                    (.visitInsn ___gen, Opcodes/ACONST_NULL)
                    (ß ___gen.storeArg((:idx ___lb) - 1))
                )
            )
        )
        (loop-when-recur [#_"int" ___i (ß (.numParams this) + 1)] (ß ___i < (:maxLocal this) + 1) [(inc ___i)]
            (when (not (.contains (:localsUsedInCatchFinally this), ___i))
                (let [#_"LocalBinding" ___b (cast' LocalBinding (RT'get-2 (:indexlocals this), ___i))]
                    (when (or (nil? ___b) (nil? (Compiler'maybePrimitiveType (:init ___b))))
                        (.visitInsn ___gen, Opcodes/ACONST_NULL)
                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___i))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearThis) [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (.visitInsn ___gen, Opcodes/ACONST_NULL)
        (.visitVarInsn ___gen, Opcodes/ASTORE, 0)
        nil
    )
)

(class-ns LocalBinding
    (defn- #_"LocalBinding" LocalBinding'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"Symbol" :tag nil
            #_"Expr" :init nil
            #_"int" :idx 0
            #_"String" :name nil
            #_"boolean" :isArg false
            #_"PathNode" :clearPathRoot nil
            #_"boolean" :canBeCleared (.not (RT'booleanCast-1o (Compiler'getCompilerOption Compiler'disableLocalsClearingKey)))
            #_"boolean" :recurMistmatch false
            #_"boolean" :used false

            #_"Boolean" :hjc nil

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBinding" LocalBinding'new [#_"int" ___num, #_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg, #_"PathNode" ___clearPathRoot]
        (let [this (LocalBinding'init)]
            (when (and (some? (Compiler'maybePrimitiveType ___init)) (some? ___tag))
                (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
            )
            (§ ass (:idx this) ___num)
            (§ ass (:sym this) ___sym)
            (§ ass (:tag this) ___tag)
            (§ ass (:init this) ___init)
            (§ ass (:isArg this) ___isArg)
            (§ ass (:clearPathRoot this) ___clearPathRoot)
            (§ ass (:name this) (Compiler'munge (:name ___sym)))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LocalBinding" this]
        (when (nil? (:hjc this))
            (if (and (some? (:init this)) (.hasJavaClass (:init this)) (Util'isPrimitive (.getJavaClass (:init this))) (not (§ instance? MaybePrimitiveExpr (:init this))))
                (do
                    (§ ass (:hjc this) false)
                )
                (do
                    (§ ass (:hjc this) (or (some? (:tag this)) (and (some? (:init this)) (.hasJavaClass (:init this)))))
                )
            )
        )
        (:hjc this)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LocalBinding" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getJavaClass (:init this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Class" (§ method getPrimitiveType) [#_"LocalBinding" this]
        (Compiler'maybePrimitiveType (:init this))
    )
)

(class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
    (defn- #_"LocalBindingExpr" LocalBindingExpr'init []
        (hash-map
            #_"LocalBinding" :b nil
            #_"Symbol" :tag nil

            #_"PathNode" :clearPath nil
            #_"PathNode" :clearRoot nil
            #_"boolean" :shouldClear false

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBindingExpr" LocalBindingExpr'new [#_"LocalBinding" ___b, #_"Symbol" ___tag]
        (let [this (LocalBindingExpr'init)]
            (when (and (some? (.getPrimitiveType ___b)) (some? ___tag))
                (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            )
            (§ ass (:b this) ___b)
            (§ ass (:tag this) ___tag)

            (§ ass (:clearPath this) (cast' PathNode (.get Compiler'CLEAR_PATH)))
            (§ ass (:clearRoot this) (cast' PathNode (.get Compiler'CLEAR_ROOT)))
            (let [#_"IPersistentCollection" ___sites (cast' IPersistentCollection (ß RT'get-2(Compiler'CLEAR_SITES.get(), ___b)))]
                (§ ass (:used ___b) true)

                (when (pos? (:idx ___b))
                    (when (some? ___sites)
                        (loop-when-recur [#_"ISeq" ___s (.seq ___sites)] (some? ___s) [(next ___s)]
                            (let [#_"LocalBindingExpr" ___o (cast' LocalBindingExpr (first ___s))]
                                (let [#_"PathNode" ___common (ß Compiler'commonPath((:clearPath this), (:clearPath ___o)))]
                                    (when (and (some? ___common) (= (:type ___common) :PathType'PATH))
                                        (§ ass (:shouldClear ___o) false)
                                    )
                                )
                            )
                        )
                    )

                    (when (ß (:clearRoot this) == (:clearPathRoot ___b))
                        (§ ass (:shouldClear this) true)
                        (§ ass ___sites (RT'conj ___sites, this))
                        (ß Compiler'CLEAR_SITES.set(RT'assoc(Compiler'CLEAR_SITES.get(), ___b, ___sites)))
                    )
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"LocalBindingExpr" this]
        (some? (.getPrimitiveType (:b this)))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitUnboxedLocal ___objx, ___gen, (:b this))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (.emitLocal ___objx, ___gen, (:b this), (:shouldClear this))
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"LocalBindingExpr" this, #_"Expr" ___val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (.emitAssignLocal ___objx, ___gen, (:b this), ___val)
        (when (ß ___context != :Context'STATEMENT)
            (.emitLocal ___objx, ___gen, (:b this), false)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LocalBindingExpr" this]
        (or (some? (:tag this)) (.hasJavaClass (:b this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LocalBindingExpr" this]
        (when (nil? (:jc this))
            (if (some? (:tag this))
                (do
                    (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
                )
                (do
                    (§ ass (:jc this) (.getJavaClass (:b this)))
                )
            )
        )
        (:jc this)
    )
)

#_closure
(class-ns BodyParser (§ implements IParser)
    (defn #_"BodyParser" BodyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"BodyParser" this, #_"Context" ___context, #_"Object" ___frms]
        (let [#_"ISeq" ___forms (cast' ISeq ___frms)]
            (when (ß Util'equals(RT'first(___forms), Compiler'DO))
                (§ ass ___forms (RT'next ___forms))
            )
            (let [#_"PersistentVector" ___exprs PersistentVector'EMPTY]
                (loop-when-recur [___forms ___forms] (some? ___forms) [(next ___forms)]
                    (let [#_"Expr" ___e (if (and (not= ___context :Context'EVAL) (or (= ___context :Context'STATEMENT) (some? (next ___forms)))) (Compiler'analyze-2 :Context'STATEMENT, (first ___forms)) (Compiler'analyze-2 ___context, (first ___forms)))]
                        (§ ass ___exprs (.cons ___exprs, ___e))
                    )
                )
                (when (zero? (count ___exprs))
                    (§ ass ___exprs (.cons ___exprs, Compiler'NIL_EXPR))
                )
                (BodyExpr'new ___exprs)
            )
        )
    )
)

(class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"BodyExpr" BodyExpr'init []
        (hash-map
            #_"PersistentVector" :exprs nil
        )
    )

    (defn #_"BodyExpr" BodyExpr'new [#_"PersistentVector" ___exprs]
        (let [this (BodyExpr'init)]
            (§ ass (:exprs this) ___exprs)
            this
        )
    )

    #_method
    (§ defn #_"PersistentVector" (§ method exprs) [#_"BodyExpr" this]
        (:exprs this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"BodyExpr" this]
        (let [#_"Object" ___ret nil]
            (doseq [#_"Object" ___o (:exprs this)]
                (let [#_"Expr" ___e (cast' Expr ___o)]
                    (§ ass ___ret (.eval ___e))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"BodyExpr" this]
        (and (§ instance? MaybePrimitiveExpr (.lastExpr this)) (.canEmitPrimitive (cast' MaybePrimitiveExpr (.lastExpr this))))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exprs this).count() - 1) [(inc ___i)]
            (let [#_"Expr" ___e (cast' Expr (.nth (:exprs this), ___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"MaybePrimitiveExpr" ___last (cast' MaybePrimitiveExpr (ß (:exprs this).nth((:exprs this).count() - 1)))]
            (.emitUnboxed ___last, ___context, ___objx, ___gen)
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exprs this).count() - 1) [(inc ___i)]
            (let [#_"Expr" ___e (cast' Expr (.nth (:exprs this), ___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"Expr" ___last (cast' Expr (ß (:exprs this).nth((:exprs this).count() - 1)))]
            (.emit ___last, ___context, ___objx, ___gen)
            nil
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"BodyExpr" this]
        (.hasJavaClass (.lastExpr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"BodyExpr" this]
        (.getJavaClass (.lastExpr this))
    )

    #_method
    (§ defn- #_"Expr" (§ method lastExpr) [#_"BodyExpr" this]
        (cast' Expr (ß (:exprs this).nth((:exprs this).count() - 1)))
    )
)

(class-ns BindingInit
    (defn- #_"BindingInit" BindingInit'init []
        (hash-map
            #_"LocalBinding" :binding nil
            #_"Expr" :init nil
        )
    )

    (defn #_"BindingInit" BindingInit'new [#_"LocalBinding" ___binding, #_"Expr" ___init]
        (let [this (BindingInit'init)]
            (§ ass (:binding this) ___binding)
            (§ ass (:init this) ___init)
            this
        )
    )

    #_method
    (§ defn #_"LocalBinding" (§ method binding) [#_"BindingInit" this]
        (:binding this)
    )

    #_method
    (§ defn #_"Expr" (§ method init) [#_"BindingInit" this]
        (:init this)
    )
)

#_closure
(class-ns LetFnParser (§ implements IParser)
    (defn #_"LetFnParser" LetFnParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"LetFnParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            ;; (letfns* [var (fn [args] body) ...] body...)
            (when (not (§ instance? IPersistentVector (RT'second ___form)))
                (throw (IllegalArgumentException. "Bad binding form, expected vector"))
            )

            (let [#_"IPersistentVector" ___bindings (cast' IPersistentVector (RT'second ___form))]
                (when (ß ((count ___bindings) % 2) != 0)
                    (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                )

                (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                    (when (ß ___context == :Context'EVAL)
                        (§ return (ß Compiler'analyze-2(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
                    )

                    (let [#_"IPersistentMap" ___dynamicBindings
                            (ß RT'map(
                                (object-array [
                                    Compiler'LOCAL_ENV      Compiler'LOCAL_ENV.deref()
                                    Compiler'NEXT_LOCAL_NUM Compiler'NEXT_LOCAL_NUM.deref()
                                ])
                            ))]
                        (try
                            (Var'pushThreadBindings ___dynamicBindings)

                            ;; pre-seed env (like Lisp labels)
                            (let [#_"PersistentVector" ___lbs PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings)) [(+ ___i 2)]
                                    (when (not (§ instance? Symbol (.nth ___bindings, ___i)))
                                        (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth ___bindings, ___i))))
                                    )
                                    (let [#_"Symbol" ___sym (cast' Symbol (.nth ___bindings, ___i))]
                                        (when (some? (.getNamespace ___sym))
                                            (throw (Util'runtimeException-1 (str "Can't let qualified name: " ___sym)))
                                        )
                                        (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___sym, Compiler'tagOf(___sym), nil, false))]
                                            (§ ass (:canBeCleared ___lb) false)
                                            (§ ass ___lbs (.cons ___lbs, ___lb))
                                        )
                                    )
                                )
                                (let [#_"PersistentVector" ___bindingInits PersistentVector'EMPTY]
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings)) [(+ ___i 2)]
                                        (let [#_"Symbol" ___sym (cast' Symbol (.nth ___bindings, ___i))]
                                            (let [#_"Expr" ___init (ß Compiler'analyze-3(:Context'EXPRESSION, ___bindings.nth(___i + 1), (:name ___sym)))]
                                                (let [#_"LocalBinding" ___lb (cast' LocalBinding (ß ___lbs.nth(___i / 2)))]
                                                    (§ ass (:init ___lb) ___init)
                                                    (let [#_"BindingInit" ___bi (BindingInit'new ___lb, ___init)]
                                                        (§ ass ___bindingInits (.cons ___bindingInits, ___bi))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß LetFnExpr'new(___bindingInits, (BodyParser'new()).parse(___context, ___body)))
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr (§ implements Expr)
    (defn- #_"LetFnExpr" LetFnExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
        )
    )

    (defn #_"LetFnExpr" LetFnExpr'new [#_"PersistentVector" ___bindingInits, #_"Expr" ___body]
        (let [this (LetFnExpr'init)]
            (§ ass (:bindingInits this) ___bindingInits)
            (§ ass (:body this) ___body)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LetFnExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
            (let [#_"BindingInit" ___bi (cast' BindingInit (.nth (:bindingInits this), ___i))]
                (.visitInsn ___gen, Opcodes/ACONST_NULL)
                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
            )
        )

        (let [#_"IPersistentSet" ___lbset PersistentHashSet'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (cast' BindingInit (.nth (:bindingInits this), ___i))]
                    (§ ass ___lbset (cast' IPersistentSet (.cons ___lbset, (:binding ___bi))))
                    (ß (:init ___bi).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
                )
            )

            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (cast' BindingInit (.nth (:bindingInits this), ___i))]
                    (let [#_"ObjExpr" ___fe (cast' ObjExpr (:init ___bi))]
                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:idx (:binding ___bi))))
                        (.emitLetFnInits ___fe, ___gen, ___objx, ___lbset)
                    )
                )
            )

            (let [#_"Label" ___loopLabel (.mark ___gen)]
                (.emit (:body this), ___context, ___objx, ___gen)

                (let [#_"Label" ___end (.mark ___gen)]
                    (loop-when-recur [#_"ISeq" ___bis (.seq (:bindingInits this))] (some? ___bis) [(next ___bis)]
                        (let [#_"BindingInit" ___bi (cast' BindingInit (first ___bis))]
                            (let [#_"String" ___lname (:name (:binding ___bi))]
                                (when (.endsWith ___lname, "__auto__")
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (Compiler'maybePrimitiveType (:init ___bi))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___loopLabel, ___end, (:idx (:binding ___bi))))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx (:binding ___bi))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LetFnExpr" this]
        (.hasJavaClass (:body this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LetFnExpr" this]
        (.getJavaClass (:body this))
    )
)

#_closure
(class-ns LetParser (§ implements IParser)
    (defn #_"LetParser" LetParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"LetParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            ;; (let [var val var2 val2 ...] body...)
            (let [#_"boolean" ___isLoop (ß RT'first(___form).equals(Compiler'LOOP))]
                (when (not (§ instance? IPersistentVector (RT'second ___form)))
                    (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                )

                (let [#_"IPersistentVector" ___bindings (cast' IPersistentVector (RT'second ___form))]
                    (when (ß ((count ___bindings) % 2) != 0)
                        (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                    )

                    (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                        (when (or (ß ___context == :Context'EVAL) (and (ß ___context == :Context'EXPRESSION) ___isLoop))
                            (§ return (ß Compiler'analyze-2(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
                        )

                        (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                            (let [#_"IPersistentMap" ___backupMethodLocals (:locals ___method)]
                                (let [#_"IPersistentMap" ___backupMethodIndexLocals (:indexlocals ___method)]
                                    (let [#_"IPersistentVector" ___recurMismatches PersistentVector'EMPTY]
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings) / 2) [(inc ___i)]
                                            (§ ass ___recurMismatches (.cons ___recurMismatches, RT'F))
                                        )

                                        ;; may repeat once for each binding with a mismatch, return breaks
                                        (while true
                                            (let [#_"IPersistentMap" ___dynamicBindings
                                                    (ß RT'map(
                                                        (object-array [
                                                            Compiler'LOCAL_ENV      Compiler'LOCAL_ENV.deref()
                                                            Compiler'NEXT_LOCAL_NUM Compiler'NEXT_LOCAL_NUM.deref()
                                                        ])
                                                    ))]
                                                (§ ass (:locals ___method) ___backupMethodLocals)
                                                (§ ass (:indexlocals ___method) ___backupMethodIndexLocals)

                                                (let [#_"PathNode" ___looproot (ß PathNode'new(:PathType'PATH, (cast' PathNode (.get Compiler'CLEAR_PATH))))]
                                                    (let [#_"PathNode" ___clearroot (ß PathNode'new(:PathType'PATH, ___looproot))]
                                                        (let [#_"PathNode" ___clearpath (ß PathNode'new(:PathType'PATH, ___looproot))]
                                                            (when ___isLoop
                                                                (§ ass ___dynamicBindings (.assoc ___dynamicBindings, Compiler'LOOP_LOCALS, nil))
                                                            )

                                                            (try
                                                                (Var'pushThreadBindings ___dynamicBindings)

                                                                (let [#_"PersistentVector" ___bindingInits PersistentVector'EMPTY]
                                                                    (let [#_"PersistentVector" ___loopLocals PersistentVector'EMPTY]
                                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings)) [(+ ___i 2)]
                                                                            (when (not (§ instance? Symbol (.nth ___bindings, ___i)))
                                                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth ___bindings, ___i))))
                                                                            )
                                                                            (let [#_"Symbol" ___sym (cast' Symbol (.nth ___bindings, ___i))]
                                                                                (when (some? (.getNamespace ___sym))
                                                                                    (throw (Util'runtimeException-1 (str "Can't let qualified name: " ___sym)))
                                                                                )
                                                                                (let [#_"Expr" ___init (ß Compiler'analyze-3(:Context'EXPRESSION, ___bindings.nth(___i + 1), (:name ___sym)))]
                                                                                    (when ___isLoop
                                                                                        (cond (and (some? ___recurMismatches) (RT'booleanCast-1o (ß ___recurMismatches.nth(___i / 2))))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "box", RT'vector(___init), false)))
                                                                                                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                                                                                    (.println (RT'errPrintWriter), (str "Auto-boxing loop arg: " ___sym))
                                                                                                )
                                                                                            )
                                                                                            (ß Compiler'maybePrimitiveType(___init) == Integer/TYPE)
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "longCast", RT'vector(___init), false)))
                                                                                            )
                                                                                            (ß Compiler'maybePrimitiveType(___init) == Float/TYPE)
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "doubleCast", RT'vector(___init), false)))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                    ;; sequential enhancement of env (like Lisp let*)
                                                                                    (try
                                                                                        (when ___isLoop
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (object-array [
                                                                                                    Compiler'CLEAR_PATH ___clearpath
                                                                                                    Compiler'CLEAR_ROOT ___clearroot
                                                                                                    Compiler'NO_RECUR   nil
                                                                                                ])
                                                                                            )))
                                                                                        )
                                                                                        (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___sym, Compiler'tagOf(___sym), ___init, false))]
                                                                                            (let [#_"BindingInit" ___bi (BindingInit'new ___lb, ___init)]
                                                                                                (§ ass ___bindingInits (.cons ___bindingInits, ___bi))
                                                                                                (when ___isLoop
                                                                                                    (§ ass ___loopLocals (.cons ___loopLocals, ___lb))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (finally
                                                                                            (when ___isLoop
                                                                                                (Var'popThreadBindings)
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (when ___isLoop
                                                                            (.set Compiler'LOOP_LOCALS, ___loopLocals)
                                                                        )
                                                                        (§ let [#_"Expr" ___bodyExpr]
                                                                            (let [#_"boolean" ___moreMismatches false]
                                                                                (try
                                                                                    (when ___isLoop
                                                                                        (let [#_"Object" ___methodReturnContext (when (= ___context :Context'RETURN) (.deref Compiler'METHOD_RETURN_CONTEXT))]
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (object-array [
                                                                                                    Compiler'CLEAR_PATH            ___clearpath
                                                                                                    Compiler'CLEAR_ROOT            ___clearroot
                                                                                                    Compiler'NO_RECUR              nil
                                                                                                    Compiler'METHOD_RETURN_CONTEXT ___methodReturnContext
                                                                                                ])
                                                                                            )))
                                                                                        )
                                                                                    )
                                                                                    (§ ass ___bodyExpr (.parse (BodyParser'new), (if ___isLoop :Context'RETURN ___context), ___body))
                                                                                    (finally
                                                                                        (when ___isLoop
                                                                                            (Var'popThreadBindings)
                                                                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___loopLocals)) [(inc ___i)]
                                                                                                (let [#_"LocalBinding" ___lb (cast' LocalBinding (.nth ___loopLocals, ___i))]
                                                                                                    (when (:recurMistmatch ___lb)
                                                                                                        (§ ass ___recurMismatches (cast' IPersistentVector (.assoc ___recurMismatches, ___i, RT'T)))
                                                                                                        (§ ass ___moreMismatches true)
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when (not ___moreMismatches)
                                                                                    (§ return (LetExpr'new ___bindingInits, ___bodyExpr, ___isLoop))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (finally
                                                                    (Var'popThreadBindings)
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"LetExpr" LetExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
            #_"boolean" :isLoop false
        )
    )

    (defn #_"LetExpr" LetExpr'new [#_"PersistentVector" ___bindingInits, #_"Expr" ___body, #_"boolean" ___isLoop]
        (let [this (LetExpr'init)]
            (§ ass (:bindingInits this) ___bindingInits)
            (§ ass (:body this) ___body)
            (§ ass (:isLoop this) ___isLoop)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" ___bindingLabels (HashMap.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (cast' BindingInit (.nth (:bindingInits this), ___i))]
                    (let [#_"Class" ___primc (Compiler'maybePrimitiveType (:init ___bi))]
                        (if (some? ___primc)
                            (do
                                (ß (cast' MaybePrimitiveExpr (:init ___bi)).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
                            )
                            (do
                                (ß (:init ___bi).emit(:Context'EXPRESSION, ___objx, ___gen))
                                (if (and (not (:used (:binding ___bi))) (:canBeCleared (:binding ___bi)))
                                    (do
                                        (.pop ___gen)
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
                                    )
                                )
                            )
                        )
                        (ß ___bindingLabels.put(___bi, (.mark ___gen)))
                    )
                )
            )
            (let [#_"Label" ___loopLabel (.mark ___gen)]
                (if (:isLoop this)
                    (do
                        (try
                            (ß Var'pushThreadBindings(RT'map(Compiler'LOOP_LABEL, ___loopLabel)))
                            (if ___emitUnboxed
                                (do
                                    (ß (cast' MaybePrimitiveExpr (:body this)).emitUnboxed(___context, ___objx, ___gen))
                                )
                                (do
                                    (.emit (:body this), ___context, ___objx, ___gen)
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                    (do
                        (if ___emitUnboxed
                            (do
                                (ß (cast' MaybePrimitiveExpr (:body this)).emitUnboxed(___context, ___objx, ___gen))
                            )
                            (do
                                (.emit (:body this), ___context, ___objx, ___gen)
                            )
                        )
                    )
                )
                (let [#_"Label" ___end (.mark ___gen)]
                    (loop-when-recur [#_"ISeq" ___bis (.seq (:bindingInits this))] (some? ___bis) [(next ___bis)]
                        (let [#_"BindingInit" ___bi (cast' BindingInit (first ___bis))]
                            (let [#_"String" ___lname (:name (:binding ___bi))]
                                (when (.endsWith ___lname, "__auto__")
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (Compiler'maybePrimitiveType (:init ___bi))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___bindingLabels.get(___bi), ___end, (:idx (:binding ___bi))))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___bindingLabels.get(___bi), ___end, (:idx (:binding ___bi))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LetExpr" this]
        (.hasJavaClass (:body this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LetExpr" this]
        (.getJavaClass (:body this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"LetExpr" this]
        (and (§ instance? MaybePrimitiveExpr (:body this)) (.canEmitPrimitive (cast' MaybePrimitiveExpr (:body this))))
    )
)

#_closure
(class-ns RecurParser (§ implements IParser)
    (defn #_"RecurParser" RecurParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"RecurParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (Compiler'lineDeref)]
            (let [#_"int" ___column (Compiler'columnDeref)]
                (let [#_"String" ___source (cast String (.deref Compiler'SOURCE))]
                    (let [#_"ISeq" ___form (cast' ISeq ___frm)]
                        (let [#_"IPersistentVector" ___loopLocals (cast' IPersistentVector (.deref Compiler'LOOP_LOCALS))]
                            (when (or (ß ___context != :Context'RETURN) (nil? ___loopLocals))
                                (throw (UnsupportedOperationException. "Can only recur from tail position"))
                            )
                            (when (some? (.deref Compiler'NO_RECUR))
                                (throw (UnsupportedOperationException. "Cannot recur across try"))
                            )
                            (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                                (loop-when-recur [#_"ISeq" ___s (RT'seq (next ___form))] (some? ___s) [(next ___s)]
                                    (§ ass ___args (ß ___args.cons(Compiler'analyze-2(:Context'EXPRESSION, (first ___s)))))
                                )
                                (when (ß (count ___args) != (count ___loopLocals))
                                    (throw (IllegalArgumentException. (String/format "Mismatched argument count to recur, expected: %d args, got: %d", (object-array [ (count ___loopLocals), (count ___args) ]))))
                                )
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___loopLocals)) [(inc ___i)]
                                    (let [#_"LocalBinding" ___lb (cast' LocalBinding (.nth ___loopLocals, ___i))]
                                        (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                            (when (some? ___primc)
                                                (let [#_"boolean" ___mismatch false]
                                                    (let [#_"Class" ___pc (ß Compiler'maybePrimitiveType((cast' Expr (.nth ___args, ___i))))]
                                                        (cond (= ___primc Long/TYPE)
                                                            (do
                                                                (when (not (or (ß ___pc == Long/TYPE) (ß ___pc == Integer/TYPE) (ß ___pc == Short/TYPE) (ß ___pc == Character/TYPE) (ß ___pc == Byte/TYPE)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                            (= ___primc Double/TYPE)
                                                            (do
                                                                (when (not (or (ß ___pc == Double/TYPE) (ß ___pc == Float/TYPE)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                        )
                                                        (when ___mismatch
                                                            (§ ass (:recurMistmatch ___lb) true)
                                                            (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                                                (.println (RT'errPrintWriter), (str ___source ":" ___line " recur arg for primitive local: " (:name ___lb) " is not matching primitive, had: " (if (some? ___pc) (.getName ___pc) "Object") ", needed: " (.getName ___primc)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (RecurExpr'new ___loopLocals, ___args, ___line, ___column, ___source)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"RecurExpr" RecurExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"IPersistentVector" :loopLocals nil

            #_"int" :line 0
            #_"int" :column 0
            #_"String" :source nil
        )
    )

    (defn #_"RecurExpr" RecurExpr'new [#_"IPersistentVector" ___loopLocals, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column, #_"String" ___source]
        (let [this (RecurExpr'init)]
            (§ ass (:loopLocals this) ___loopLocals)
            (§ ass (:args this) ___args)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:source this) ___source)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___loopLabel (cast Label (.deref Compiler'LOOP_LABEL))]
            (when (nil? ___loopLabel)
                (throw (IllegalStateException.))
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:loopLocals this).count()) [(inc ___i)]
                (let [#_"LocalBinding" ___lb (cast' LocalBinding (.nth (:loopLocals this), ___i))]
                    (let [#_"Expr" ___arg (cast' Expr (.nth (:args this), ___i))]
                        (if (some? (.getPrimitiveType ___lb))
                            (do
                                (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                    (let [#_"Class" ___pc (Compiler'maybePrimitiveType ___arg)]
                                        (cond (= ___pc ___primc)
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                            )
                                            (and (ß ___primc == Long/TYPE) (ß ___pc == Integer/TYPE))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (.visitInsn ___gen, Opcodes/I2L)
                                            )
                                            (and (ß ___primc == Double/TYPE) (ß ___pc == Float/TYPE))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (.visitInsn ___gen, Opcodes/F2D)
                                            )
                                            (and (ß ___primc == Integer/TYPE) (ß ___pc == Long/TYPE))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                                            )
                                            (and (ß ___primc == Float/TYPE) (ß ___pc == Double/TYPE))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (.visitInsn ___gen, Opcodes/D2F)
                                            )
                                            :else
                                            (do
                                                (throw (IllegalArgumentException. (str "recur arg for primitive local: " (:name ___lb) " is not matching primitive, had: " (if (.hasJavaClass ___arg) (.getName (.getJavaClass ___arg)) "Object") ", needed: " (.getName ___primc))))
                                            )
                                        )
                                    )
                                )
                            )
                            (do
                                (ß ___arg.emit(:Context'EXPRESSION, ___objx, ___gen))
                            )
                        )
                    )
                )
            )

            (loop-when-recur [#_"int" ___i (ß (:loopLocals this).count() - 1)] (>= ___i 0) [(dec ___i)]
                (let [#_"LocalBinding" ___lb (cast' LocalBinding (.nth (:loopLocals this), ___i))]
                    (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                        (if (:isArg ___lb)
                            (do
                                (.storeArg ___gen, (- (:idx ___lb) (if (:canBeDirect ___objx) 0 1)))
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (.goTo ___gen, ___loopLabel)
            nil
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"RecurExpr" this]
        Compiler'RECUR_CLASS
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emit this, ___context, ___objx, ___gen)
        nil
    )
)

(class-ns CompilerException (§ extends RuntimeException)
    (defn- #_"CompilerException" CompilerException'init []
        (hash-map
            #_"String" :source nil
            #_"int" :line 0
        )
    )

    (defn #_"CompilerException" CompilerException'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new (ß Compiler'errorMsg(___source, ___line, ___column, (.toString ___cause))), ___cause) (CompilerException'init))]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"CompilerException" this]
        (.getMessage this)
    )
)

#_closure
(class-ns DeftypeParser (§ implements IParser)
    (defn #_"DeftypeParser" DeftypeParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"DeftypeParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___rform (cast' ISeq ___frm)]
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            (§ ass ___rform (RT'next ___rform))
            (let [#_"String" ___tagname (.getName (cast' Symbol (first ___rform)))]
                (§ ass ___rform (next ___rform))
                (let [#_"Symbol" ___classname (cast' Symbol (first ___rform))]
                    (§ ass ___rform (next ___rform))
                    (let [#_"IPersistentVector" ___fields (cast' IPersistentVector (first ___rform))]
                        (§ ass ___rform (next ___rform))
                        (let [#_"IPersistentMap" ___opts PersistentHashMap'EMPTY]
                            (while (and (some? ___rform) (§ instance? Keyword (first ___rform)))
                                (§ ass ___opts (ß ___opts.assoc((first ___rform), RT'second(___rform))))
                                (§ ass ___rform (next (next ___rform)))
                            )

                            (let [#_"ObjExpr" ___ret (ß build((cast' IPersistentVector (RT'get-3 ___opts, Compiler'implementsKey, PersistentVector'EMPTY)), ___fields, nil, ___tagname, ___classname, (cast' Symbol (RT'get-2 ___opts, RT'TAG_KEY)), ___rform, ___frm, ___opts))]
                                ___ret
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ReifyParser (§ implements IParser)
    (defn #_"ReifyParser" ReifyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ReifyParser" this, #_"Context" ___context, #_"Object" ___frm]
        ;; (reify this-name? [interfaces] (method-name [args] body)*)
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            (let [#_"ObjMethod" ___enclosingMethod (cast' ObjMethod (.deref Compiler'METHOD))]
                (let [#_"String" ___basename (str (if (some? ___enclosingMethod) (ß trimGenID((:name (:objx ___enclosingMethod)))) (ß Compiler'munge((:name (:name (.currentNS this)))))) "$")]
                    (let [#_"String" ___simpleName (str "reify__" (RT'nextID))]
                        (let [#_"String" ___classname (+ ___basename ___simpleName)]
                            (let [#_"ISeq" ___rform (RT'next ___form)]
                                (let [#_"IPersistentVector" ___interfaces (ß (cast' IPersistentVector (RT'first ___rform)).cons(Symbol'intern-1("cloiure.lang.IObj")))]
                                    (§ ass ___rform (RT'next ___rform))

                                    (let [#_"ObjExpr" ___ret (ß build(___interfaces, nil, nil, ___classname, Symbol'intern-1(___classname), nil, ___rform, ___frm, nil))]
                                        (if (and (§ instance? IObj ___frm) (some? (.meta (cast' IObj ___frm))))
                                            (do
                                                (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.meta (cast' IObj ___frm))))
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewInstanceExpr (§ extends ObjExpr)
    (defn- #_"NewInstanceExpr" NewInstanceExpr'init []
        (hash-map
            #_"IPersistentCollection" :methods nil

            #_"Map<IPersistentVector, java.lang.reflect.Method>" :mmap nil
            #_"Map<IPersistentVector, Set<Class>>" :covariants nil
        )
    )

    (defn #_"NewInstanceExpr" NewInstanceExpr'new [#_"Object" ___tag]
        (merge (ObjExpr'new ___tag) (NewInstanceExpr'init))
    )

    (defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" ___interfaceSyms, #_"IPersistentVector" ___fieldSyms, #_"Symbol" ___thisSym, #_"String" ___tagName, #_"Symbol" ___className, #_"Symbol" ___typeTag, #_"ISeq" ___methodForms, #_"Object" ___frm, #_"IPersistentMap" ___opts]
        (let [#_"NewInstanceExpr" ___ret (NewInstanceExpr'new nil)]
            (§ ass (:src ___ret) ___frm)
            (§ ass (:name ___ret) (.toString ___className))
            (§ ass (:classMeta ___ret) (RT'meta ___className))
            (§ ass (:internalName ___ret) (ß (:name ___ret).replace(\., \/)))
            (§ ass (:objtype ___ret) (Type/getObjectType (:internalName ___ret)))
            (§ ass (:opts ___ret) ___opts)

            (when (some? ___thisSym)
                (§ ass (:thisName ___ret) (:name ___thisSym))
            )

            (when (some? ___fieldSyms)
                (let [#_"IPersistentMap" ___fmap PersistentHashMap'EMPTY]
                    (let [#_"Object[]" ___closesvec (make-array Object (ß 2 * (count ___fieldSyms)))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___fieldSyms)) [(inc ___i)]
                            (let [#_"Symbol" ___sym (cast' Symbol (.nth ___fieldSyms, ___i))]
                                (let [#_"LocalBinding" ___lb (ß LocalBinding'new(-1, ___sym, nil, MethodParamExpr'new(Compiler'tagClass(Compiler'tagOf(___sym))), false, nil))]
                                    (§ ass ___fmap (.assoc ___fmap, ___sym, ___lb))
                                    (§ ass (§ aget ___closesvec (ß ___i * 2)) ___lb)
                                    (§ ass (§ aget ___closesvec (ß ___i * 2 + 1)) ___lb)
                                )
                            )
                        )

                        ;; todo - inject __meta et al into closes - when?
                        ;; use array map to preserve ctor order
                        (§ ass (:closes ___ret) (PersistentArrayMap'new-1 ___closesvec))
                        (§ ass (:fields ___ret) ___fmap)
                        (loop-when-recur [#_"int" ___i (dec (count ___fieldSyms))] (and (<= 0 ___i) (or (.equals (:name (cast' Symbol (.nth ___fieldSyms, ___i))), "__meta") (.equals (:name (cast' Symbol (.nth ___fieldSyms, ___i))), "__extmap") (.equals (:name (cast' Symbol (.nth ___fieldSyms, ___i))), "__hash") (.equals (:name (cast' Symbol (.nth ___fieldSyms, ___i))), "__hasheq"))) [(dec ___i)]
                            (§ ass (:altCtorDrops ___ret) (inc (:altCtorDrops ___ret)))
                        )
                    )
                )
            )

            (let [#_"PersistentVector" ___interfaces PersistentVector'EMPTY]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___interfaceSyms)] (some? ___s) [(next ___s)]
                    (let [#_"Class" ___c (cast Class (ß resolve((cast' Symbol (first ___s)))))]
                        (when (not (.isInterface ___c))
                            (throw (IllegalArgumentException. (str "only interfaces are supported, had: " (.getName ___c))))
                        )
                        (§ ass ___interfaces (.cons ___interfaces, ___c))
                    )
                )
                (let [#_"Class" ___superClass Object]
                    (let [#_"Map[]" ___mc (ß NewInstanceExpr'gatherMethods-2s(___superClass, RT'seq(___interfaces)))]
                        (let [#_"Map" ___overrideables (§ aget ___mc (ß 0))]
                            (let [#_"Map" ___covariants (§ aget ___mc (ß 1))]
                                (§ ass (:mmap ___ret) ___overrideables)
                                (§ ass (:covariants ___ret) ___covariants)

                                (let [#_"String[]" ___inames (NewInstanceExpr'interfaceNames ___interfaces)]
                                    (let [#_"Class" ___stub (ß compileStub(slashname(___superClass), ___ret, ___inames, ___frm))]
                                        (let [#_"Symbol" ___thistag (ß Symbol'intern-2(nil, (.getName ___stub)))]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (object-array [
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                                                        Compiler'NO_RECUR           nil
                                                    ])
                                                )))
                                                (when (.isDeftype ___ret)
                                                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                        (object-array [
                                                            Compiler'METHOD             nil
                                                            Compiler'LOCAL_ENV          (:fields ___ret)
                                                            Compiler'COMPILE_STUB_SYM   (Symbol'intern-2 nil, ___tagName)
                                                            Compiler'COMPILE_STUB_CLASS ___stub
                                                        ])
                                                    )))

                                                    (§ ass (:hintedFields ___ret) (ß RT'subvec(___fieldSyms, 0, (count ___fieldSyms) - (:altCtorDrops ___ret))))
                                                )

                                                ;; now (methodname [args] body)*
                                                (§ ass (:line ___ret) (Compiler'lineDeref))
                                                (§ ass (:column ___ret) (Compiler'columnDeref))
                                                (let [#_"IPersistentCollection" ___methods nil]
                                                    (loop-when-recur [#_"ISeq" ___s ___methodForms] (some? ___s) [(RT'next ___s)]
                                                        (let [#_"NewInstanceMethod" ___m (ß NewInstanceMethod'parse(___ret, (cast' ISeq (RT'first ___s)), ___thistag, ___overrideables))]
                                                            (§ ass ___methods (RT'conj ___methods, ___m))
                                                        )
                                                    )

                                                    (§ ass (:methods ___ret) ___methods)
                                                    (§ ass (:keywords ___ret) (cast' IPersistentMap (.deref Compiler'KEYWORDS)))
                                                    (§ ass (:vars ___ret) (cast' IPersistentMap (.deref Compiler'VARS)))
                                                    (§ ass (:constants ___ret) (cast' PersistentVector (.deref Compiler'CONSTANTS)))
                                                    (§ ass (:constantsID ___ret) (RT'nextID))
                                                    (§ ass (:keywordCallsites ___ret) (cast' IPersistentVector (.deref Compiler'KEYWORD_CALLSITES)))
                                                    (§ ass (:protocolCallsites ___ret) (cast' IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES)))
                                                    (§ ass (:varCallsites ___ret) (cast' IPersistentSet (.deref Compiler'VAR_CALLSITES)))
                                                )
                                                (finally
                                                    (when (.isDeftype ___ret)
                                                        (Var'popThreadBindings)
                                                    )
                                                    (Var'popThreadBindings)
                                                )
                                            )

                                            (try
                                                (ß ___ret.compile(slashname(___superClass), ___inames, false))
                                                (catch IOException ___e
                                                    (throw (Util'sneakyThrow ___e))
                                                )
                                            )
                                            (.getCompiledClass ___ret)
                                            ___ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Current host interop uses reflection, which requires pre-existing classes
     ; Work around this by:
     ; Generate a stub class that has the same interfaces and fields as the class we are generating.
     ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
     ; Unmunge the name (using a magic prefix) on any code gen for classes
     ;;
    (defn #_"Class" NewInstanceExpr'compileStub [#_"String" ___superName, #_"NewInstanceExpr" ___ret, #_"String[]" ___interfaceNames, #_"Object" ___frm]
        (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" ___cv ___cw]
                (.visit ___cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER), (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ___ret)), nil, ___superName, ___interfaceNames)

                ;; instance fields for closed-overs
                (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes ___ret))] (some? ___s) [(next ___s)]
                    (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___s))]
                        (let [#_"int" ___access (+ Opcodes/ACC_PUBLIC (if (.isVolatile ___ret, ___lb) Opcodes/ACC_VOLATILE (if (.isMutable ___ret, ___lb) 0 Opcodes/ACC_FINAL)))]
                            (if (some? (.getPrimitiveType ___lb))
                                (do
                                    (ß ___cv.visitField(___access, (:name ___lb), Type/getType((.getPrimitiveType ___lb)).getDescriptor(), nil, nil))
                                )
                                (do
                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                    (ß ___cv.visitField(___access, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil))
                                )
                            )
                        )
                    )
                )

                ;; ctor that takes closed-overs and does nothing
                (let [#_"Method" ___m (Method. "<init>", Type/VOID_TYPE, (.ctorTypes ___ret))]
                    (let [#_"GeneratorAdapter" ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, nil, ___cv)]
                        (.visitCode ___ctorgen)
                        (.loadThis ___ctorgen)
                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))
                        (.returnValue ___ctorgen)
                        (.endMethod ___ctorgen)

                        (when (pos? (:altCtorDrops ___ret))
                            (let [#_"Type[]" ___ctorTypes (.ctorTypes ___ret)]
                                (let [#_"Type[]" ___altCtorTypes (make-array Type (- (§ alength ___ctorTypes) (:altCtorDrops ___ret)))]
                                    (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___altCtorTypes)) [(inc ___i)]
                                        (§ ass (§ aget ___altCtorTypes ___i) (§ aget ___ctorTypes ___i))
                                    )
                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes)]
                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                        (.visitCode ___ctorgen)
                                        (.loadThis ___ctorgen)
                                        (.loadArgs ___ctorgen)

                                        (.visitInsn ___ctorgen, Opcodes/ACONST_NULL) ;; __meta
                                        (.visitInsn ___ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hash
                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                        (.invokeConstructor ___ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ___ret))), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes))

                                        (.returnValue ___ctorgen)
                                        (.endMethod ___ctorgen)

                                        ;; alt ctor no __hash, __hasheq
                                        (§ ass ___altCtorTypes (make-array Type (- (§ alength ___ctorTypes) 2)))
                                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___altCtorTypes)) [(inc ___i)]
                                            (§ ass (§ aget ___altCtorTypes ___i) (§ aget ___ctorTypes ___i))
                                        )

                                        (§ ass ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes))
                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                        (.visitCode ___ctorgen)
                                        (.loadThis ___ctorgen)
                                        (.loadArgs ___ctorgen)

                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hash
                                        (.visitInsn ___ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                        (.invokeConstructor ___ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ___ret))), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes))

                                        (.returnValue ___ctorgen)
                                        (.endMethod ___ctorgen)
                                    )
                                )
                            )
                        )
                        ;; end of class
                        (.visitEnd ___cv)

                        (let [#_"byte[]" ___bytecode (.toByteArray ___cw)]
                            (let [#_"DynamicClassLoader" ___loader (cast' DynamicClassLoader (.deref Compiler'LOADER))]
                                (.defineClass ___loader, (str Compiler'COMPILE_STUB_PREFIX "." (:name ___ret)), ___bytecode, ___frm)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" ___interfaces]
        (let [#_"int" ___icnt (count ___interfaces)]
            (let [#_"String[]" ___inames (when (pos? ___icnt) (make-array String ___icnt))]
                (loop-when-recur [#_"int" ___i 0] (< ___i ___icnt) [(inc ___i)]
                    (§ ass (§ aget ___inames ___i) (ß slashname((cast Class (.nth ___interfaces, ___i)))))
                )
                ___inames
            )
        )
    )

    (defn #_"String" NewInstanceExpr'slashname [#_"Class" ___c]
        (ß (.getName ___c).replace(\., \/))
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitStatics) [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (when (.isDeftype this)
            ;; getBasis()
            (let [#_"Method" ___meth (Method/getMethod "cloiure.lang.IPersistentVector getBasis()")]
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ___meth, nil, nil, ___cv)]
                    (.emitValue this, (:hintedFields this), ___gen)
                    (.returnValue ___gen)
                    (.endMethod ___gen)

                    (when (and (.isDeftype this) (< (.count (:hintedFields this)) (.count (:fields this))))
                        ;; create(IPersistentMap)
                        (let [#_"String" ___className (ß (:name this).replace(\., \/))]
                            (let [#_"int" ___i 1]
                                (let [#_"int" ___fieldCount (count (:hintedFields this))]
                                    (let [#_"MethodVisitor" ___mv (.visitMethod ___cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), "create", (str "(Lcloiure/lang/IPersistentMap;)L" ___className ";"), nil, nil)]
                                        (.visitCode ___mv)

                                        (loop-when-recur [#_"ISeq" ___s (RT'seq (:hintedFields this)) ___i ___i] (some? ___s) [(next ___s) (inc ___i)]
                                            (let [#_"String" ___bName (:name (cast' Symbol (first ___s)))]
                                                (let [#_"Class" ___k (ß Compiler'tagClass(Compiler'tagOf((first ___s))))]
                                                    (.visitVarInsn ___mv, Opcodes/ALOAD, 0)
                                                    (.visitLdcInsn ___mv, ___bName)
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                                    (.visitInsn ___mv, Opcodes/ACONST_NULL)
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                                                    (when (.isPrimitive ___k)
                                                        (ß ___mv.visitTypeInsn(Opcodes/CHECKCAST, Type/getType(Compiler'boxClass(___k)).getInternalName()))
                                                    )
                                                    (.visitVarInsn ___mv, Opcodes/ASTORE, ___i)
                                                    (.visitVarInsn ___mv, Opcodes/ALOAD, 0)
                                                    (.visitLdcInsn ___mv, ___bName)
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                                                    (.visitVarInsn ___mv, Opcodes/ASTORE, 0)
                                                )
                                            )
                                        )

                                        (.visitTypeInsn ___mv, Opcodes/NEW, ___className)
                                        (.visitInsn ___mv, Opcodes/DUP)

                                        (let [#_"Method" ___ctor (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))]
                                            (when (pos? (.count (:hintedFields this)))
                                                (loop-when-recur [___i 1] (<= ___i ___fieldCount) [(inc ___i)]
                                                    (.visitVarInsn ___mv, Opcodes/ALOAD, ___i)
                                                    (let [#_"Class" ___k (ß Compiler'tagClass(Compiler'tagOf((:hintedFields this).nth(___i - 1))))]
                                                        (when (.isPrimitive ___k)
                                                            (let [#_"String" ___b (ß Type/getType(Compiler'boxClass(___k)).getInternalName())]
                                                                (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                                    (let [#_"String" ___n (.getName ___k)]
                                                                        (.visitMethodInsn ___mv, Opcodes/INVOKEVIRTUAL, ___b, (str ___n "Value"), (str "()" ___p))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )

                                            (.visitInsn ___mv, Opcodes/ACONST_NULL) ;; __meta
                                            (.visitVarInsn ___mv, Opcodes/ALOAD, 0) ;; __extmap
                                            (.visitMethodInsn ___mv, Opcodes/INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                                            (.visitInsn ___mv, Opcodes/ICONST_0) ;; __hash
                                            (.visitInsn ___mv, Opcodes/ICONST_0) ;; __hasheq
                                            (ß ___mv.visitMethodInsn(Opcodes/INVOKESPECIAL, ___className, "<init>", (.getDescriptor ___ctor)))
                                            (.visitInsn ___mv, Opcodes/ARETURN)
                                            (ß ___mv.visitMaxs(4 + ___fieldCount, 1 + ___fieldCount))
                                            (.visitEnd ___mv)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (loop-when-recur [#_"ISeq" ___s (RT'seq (:methods this))] (some? ___s) [(next ___s)]
            (let [#_"ObjMethod" ___method (cast' ObjMethod (first ___s))]
                (.emit ___method, this, ___cv)
            )
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" ___e (.entrySet (:covariants this))]
            (let [#_"java.lang.reflect.Method" ___m (.get (:mmap this), (.getKey ___e))]
                (let [#_"Class[]" ___params (.getParameterTypes ___m)]
                    (let [#_"Type[]" ___argTypes (make-array Type (§ alength ___params))]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___params)) [(inc ___i)]
                            (§ ass (§ aget ___argTypes ___i) (Type/getType (§ aget ___params ___i)))
                        )

                        (let [#_"Method" ___target (Method. (.getName ___m), (Type/getType (.getReturnType ___m)), ___argTypes)]
                            (doseq [#_"Class" ___retType (.getValue ___e)]
                                (let [#_"Method" ___meth (Method. (.getName ___m), (Type/getType ___retType), ___argTypes)]
                                    ;; todo don't hardwire EXCEPTION_TYPES
                                    (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_BRIDGE), ___meth, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                                        (.visitCode ___gen)
                                        (.loadThis ___gen)
                                        (.loadArgs ___gen)
                                        (ß ___gen.invokeInterface(Type/getType((.getDeclaringClass ___m)), ___target))
                                        (.returnValue ___gen)
                                        (.endMethod ___gen)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" ___m]
        (ß RT'vector((.getName ___m), RT'seq((.getParameterTypes ___m)), (.getReturnType ___m)))
    )

    (defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" ___m, #_"Map" ___mm]
        (let [#_"IPersistentVector" ___mk (NewInstanceExpr'msig ___m)]
            (let [#_"int" ___mods (.getModifiers ___m)]
                (when (not (or (.containsKey ___mm, ___mk) (not (or (Modifier/isPublic ___mods) (Modifier/isProtected ___mods))) (Modifier/isStatic ___mods) (Modifier/isFinal ___mods)))
                    (.put ___mm, ___mk, ___m)
                )
                nil
            )
        )
    )

    (defn #_"void" NewInstanceExpr'gatherMethods-2m [#_"Class" ___c, #_"Map" ___mm]
        (loop-when-recur [___c ___c] (some? ___c) [(.getSuperclass ___c)]
            (doseq [#_"java.lang.reflect.Method" ___m (.getDeclaredMethods ___c)]
                (NewInstanceExpr'considerMethod ___m, ___mm)
            )
            (doseq [#_"java.lang.reflect.Method" ___m (.getMethods ___c)]
                (NewInstanceExpr'considerMethod ___m, ___mm)
            )
        )
        nil
    )

    (defn #_"Map[]" NewInstanceExpr'gatherMethods-2s [#_"Class" ___sc, #_"ISeq" ___interfaces]
        (let [#_"Map" ___allm (HashMap.)]
            (NewInstanceExpr'gatherMethods-2m ___sc, ___allm)
            (loop-when-recur [___interfaces ___interfaces] (some? ___interfaces) [(next ___interfaces)]
                (ß NewInstanceExpr'gatherMethods-2m((cast Class (first ___interfaces)), ___allm))
            )

            (let [#_"Map<IPersistentVector, java.lang.reflect.Method>" ___mm (HashMap.)]
                (let [#_"Map<IPersistentVector, Set<Class>>" ___covariants (HashMap.)]
                    (doseq [#_"Object" ___o (.entrySet ___allm)]
                        (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                            (let [#_"IPersistentVector" ___mk (cast' IPersistentVector (.getKey ___e))]
                                (§ ass ___mk (cast' IPersistentVector (.pop ___mk)))
                                (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) (.getValue ___e))]
                                    (if (.containsKey ___mm, ___mk) ;; covariant return
                                        (do
                                            (let [#_"Set<Class>" ___cvs (.get ___covariants, ___mk)]
                                                (when (nil? ___cvs)
                                                    (§ ass ___cvs (HashSet.))
                                                    (.put ___covariants, ___mk, ___cvs)
                                                )
                                                (let [#_"java.lang.reflect.Method" ___om (.get ___mm, ___mk)]
                                                    (if (.isAssignableFrom (.getReturnType ___om), (.getReturnType ___m))
                                                        (do
                                                            (.add ___cvs, (.getReturnType ___om))
                                                            (.put ___mm, ___mk, ___m)
                                                        )
                                                        (do
                                                            (.add ___cvs, (.getReturnType ___m))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (.put ___mm, ___mk, ___m)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß new Map[] (object-array [ ___mm, ___covariants ]))
                )
            )
        )
    )
)

(class-ns NewInstanceMethod (§ extends ObjMethod)
    (§ def #_"Symbol" NewInstanceMethod'dummyThis (Symbol'intern-2 nil, "dummy_this_dlskjsdfower"))

    (defn- #_"NewInstanceMethod" NewInstanceMethod'init []
        (hash-map
            #_"String" :name nil
            #_"Type[]" :argTypes nil
            #_"Type" :retType nil
            #_"Class" :retClass nil
            #_"Class[]" :exclasses nil

            #_"IPersistentVector" :parms nil
        )
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (merge (ObjMethod'new ___objx, ___parent) (NewInstanceMethod'init))
    )

    #_method
    (§ defn #_"int" (§ method numParams) [#_"NewInstanceMethod" this]
        (count (:argLocals this))
    )

    #_method
    (§ defn #_"String" (§ method getMethodName) [#_"NewInstanceMethod" this]
        (:name this)
    )

    #_method
    (§ defn #_"Type" (§ method getReturnType) [#_"NewInstanceMethod" this]
        (:retType this)
    )

    #_method
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"NewInstanceMethod" this]
        (:argTypes this)
    )

    (defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" ___name, #_"Class[]" ___paramTypes]
        (ß RT'vector(___name, RT'seq(___paramTypes)))
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Symbol" ___thistag, #_"Map" ___overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" ___method (ß NewInstanceMethod'new(___objx, (cast' ObjMethod (.deref Compiler'METHOD))))]
            (let [#_"Symbol" ___dotname (cast' Symbol (RT'first ___form))]
                (let [#_"Symbol" ___name (cast' Symbol (ß Symbol'intern-2(nil, Compiler'munge((:name ___dotname))).withMeta(RT'meta(___dotname))))]
                    (let [#_"IPersistentVector" ___parms (cast' IPersistentVector (RT'second ___form))]
                        (when (zero? (count ___parms))
                            (throw (IllegalArgumentException. (str "Must supply at least one argument for 'this' in: " ___dotname)))
                        )
                        (let [#_"Symbol" ___thisName (cast' Symbol (.nth ___parms, 0))]
                            (§ ass ___parms (ß RT'subvec(___parms, 1, (count ___parms))))
                            (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                                (try
                                    (§ ass (:line ___method) (Compiler'lineDeref))
                                    (§ ass (:column ___method) (Compiler'columnDeref))
                                    ;; register as the current method and set up a new env frame
                                    (let [#_"PathNode" ___pnode (ß PathNode'new(:PathType'PATH, (cast' PathNode (.get Compiler'CLEAR_PATH))))]
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (object-array [
                                                Compiler'METHOD                ___method
                                                Compiler'LOCAL_ENV             (.deref Compiler'LOCAL_ENV)
                                                Compiler'LOOP_LOCALS           nil
                                                Compiler'NEXT_LOCAL_NUM        0
                                                Compiler'CLEAR_PATH            ___pnode
                                                Compiler'CLEAR_ROOT            ___pnode
                                                Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                                Compiler'METHOD_RETURN_CONTEXT RT'T
                                            ])
                                        )))

                                        ;; register 'this' as local 0
                                        (if (some? ___thisName)
                                            (do
                                                (Compiler'registerLocal (or ___thisName NewInstanceMethod'dummyThis), ___thistag, nil, false)
                                            )
                                            (do
                                                (Compiler'getAndIncLocalNum)
                                            )
                                        )

                                        (let [#_"PersistentVector" ___argLocals PersistentVector'EMPTY]
                                            (§ ass (:retClass ___method) (ß Compiler'tagClass(Compiler'tagOf(___name))))
                                            (§ ass (:argTypes ___method) (make-array Type (count ___parms)))
                                            (let [#_"boolean" ___hinted (some? (Compiler'tagOf ___name))]
                                                (let [#_"Class[]" ___pclasses (make-array Class (count ___parms))]
                                                    (let [#_"Symbol[]" ___psyms (§ typeless make-array Symbol (count ___parms))]
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                            (when (not (§ instance? Symbol (.nth ___parms, ___i)))
                                                                (throw (IllegalArgumentException. "params must be Symbols"))
                                                            )
                                                            (let [#_"Symbol" ___p (cast' Symbol (.nth ___parms, ___i))]
                                                                (let [#_"Object" ___tag (Compiler'tagOf ___p)]
                                                                    (when (some? ___tag)
                                                                        (§ ass ___hinted true)
                                                                    )
                                                                    (when (some? (.getNamespace ___p))
                                                                        (§ ass ___p (ß Symbol'intern-1((:name ___p))))
                                                                    )
                                                                    (let [#_"Class" ___pclass (Compiler'tagClass ___tag)]
                                                                        (§ ass (§ aget ___pclasses ___i) ___pclass)
                                                                        (§ ass (§ aget ___psyms ___i) ___p)
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (let [#_"Map" ___matches (ß findMethodsWithNameAndArity((:name ___name), (count ___parms), ___overrideables))]
                                                            (let [#_"Object" ___mk (ß NewInstanceMethod'msig((:name ___name), ___pclasses))]
                                                                (let [#_"java.lang.reflect.Method" ___m nil]
                                                                    (if (pos? (.size ___matches))
                                                                        (do
                                                                            ;; multiple methods
                                                                            (cond (ß (.size ___matches) > 1)
                                                                                (do
                                                                                    ;; must be hinted and match one method
                                                                                    (when (not ___hinted)
                                                                                        (throw (IllegalArgumentException. (str "Must hint overloaded method: " (:name ___name))))
                                                                                    )
                                                                                    (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                    (when (nil? ___m)
                                                                                        (throw (IllegalArgumentException. (str "Can't find matching overloaded method: " (:name ___name))))
                                                                                    )
                                                                                    (when (ß (.getReturnType ___m) != (:retClass ___method))
                                                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name ___name) ", expected: " (.getName (.getReturnType ___m)) ", had: " (.getName (:retClass ___method)))))
                                                                                    )
                                                                                )
                                                                                :else ;; one match
                                                                                (do
                                                                                    ;; if hinted, validate match
                                                                                    (cond ___hinted
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                            (when (nil? ___m)
                                                                                                (throw (IllegalArgumentException. (str "Can't find matching method: " (:name ___name) ", leave off hints for auto match.")))
                                                                                            )
                                                                                            (when (ß (.getReturnType ___m) != (:retClass ___method))
                                                                                                (throw (IllegalArgumentException. (str "Mismatched return type: " (:name ___name) ", expected: " (.getName (.getReturnType ___m)) ", had: " (.getName (:retClass ___method)))))
                                                                                            )
                                                                                        )
                                                                                        :else ;; adopt found method sig
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) (.values ___matches).iterator().next()))
                                                                                            (§ ass (:retClass ___method) (.getReturnType ___m))
                                                                                            (§ ass ___pclasses (.getParameterTypes ___m))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (do
                                                                            (throw (IllegalArgumentException. (str "Can't define method not in interfaces: " (:name ___name))))
                                                                        )
                                                                    )

                                                                    ;; validate unque name+arity among additional methods

                                                                    (§ ass (:retType ___method) (Type/getType (:retClass ___method)))
                                                                    (§ ass (:exclasses ___method) (.getExceptionTypes ___m))

                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                                        (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___psyms[___i], nil, MethodParamExpr'new(___pclasses[___i]), true))]
                                                                            (§ ass ___argLocals (.assocN ___argLocals, ___i, ___lb))
                                                                            (§ ass (§ aget (:argTypes ___method) ___i) (Type/getType (§ aget ___pclasses ___i)))
                                                                        )
                                                                    )
                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                                        (when (or (ß ___pclasses[___i] == Long/TYPE) (ß ___pclasses[___i] == Double/TYPE))
                                                                            (Compiler'getAndIncLocalNum)
                                                                        )
                                                                    )
                                                                    (.set Compiler'LOOP_LOCALS, ___argLocals)
                                                                    (§ ass (:name ___method) (:name ___name))
                                                                    (§ ass (:methodMeta ___method) (RT'meta ___name))
                                                                    (§ ass (:parms ___method) ___parms)
                                                                    (§ ass (:argLocals ___method) ___argLocals)
                                                                    (§ ass (:body ___method) (ß (BodyParser'new()).parse(:Context'RETURN, ___body)))
                                                                    ___method
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (finally
                                        (Var'popThreadBindings)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" ___name, #_"int" ___arity, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (.entrySet ___mm)]
                (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) (.getValue ___e))]
                        (when (and (.equals ___name, (.getName ___m)) (ß (§ alength (.getParameterTypes ___m)) == ___arity))
                            (ß ___ret.put((.getKey ___e), (.getValue ___e)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" ___name, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (.entrySet ___mm)]
                (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) (.getValue ___e))]
                        (when (.equals ___name, (.getName ___m))
                            (ß ___ret.put((.getKey ___e), (.getValue ___e)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NewInstanceMethod" this, #_"ObjExpr" ___obj, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            (let [#_"Type[]" ___extypes nil]
                (when (pos? (§ alength (:exclasses this)))
                    (§ ass ___extypes (make-array Type (§ alength (:exclasses this))))
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:exclasses this))) [(inc ___i)]
                        (§ ass (§ aget ___extypes ___i) (Type/getType (§ aget (:exclasses this) ___i)))
                    )
                )
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, ___extypes, ___cv)]
                    (ß Compiler'addAnnotation(___gen, (:methodMeta this)))
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:parms this).count()) [(inc ___i)]
                        (let [#_"IPersistentMap" ___meta (ß RT'meta((:parms this).nth(___i)))]
                            (Compiler'addParameterAnnotation ___gen, ___meta, ___i)
                        )
                    )
                    (.visitCode ___gen)

                    (let [#_"Label" ___loopLabel (.mark ___gen)]
                        (.visitLineNumber ___gen, (:line this), ___loopLabel)
                        (try
                            (ß Var'pushThreadBindings(RT'map(Compiler'LOOP_LABEL, ___loopLabel, Compiler'METHOD, this)))

                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))
                            (let [#_"Label" ___end (.mark ___gen)]
                                (ß ___gen.visitLocalVariable("this", (:objtype ___obj).getDescriptor(), nil, ___loopLabel, ___end, 0))
                                (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                    (let [#_"LocalBinding" ___lb (cast' LocalBinding (first ___lbs))]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argTypes this)[___lb.idx - 1].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue ___gen)
                        (.endMethod ___gen)
                        nil
                    )
                )
            )
        )
    )
)

(class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"MethodParamExpr" MethodParamExpr'init []
        (hash-map
            #_"Class" :c nil
        )
    )

    (defn #_"MethodParamExpr" MethodParamExpr'new [#_"Class" ___c]
        (let [this (MethodParamExpr'init)]
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MethodParamExpr" this]
        (throw (Util'runtimeException-1 "Can't eval"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (Util'runtimeException-1 "Can't emit"))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MethodParamExpr" this]
        (some? (:c this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MethodParamExpr" this]
        (:c this)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"MethodParamExpr" this]
        (Util'isPrimitive (:c this))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (Util'runtimeException-1 "Can't emit"))
    )
)

#_closure
(class-ns CaseParser (§ implements IParser)
    (defn #_"CaseParser" CaseParser'new []
        (hash-map)
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    ;; prepared by case macro and presumed correct
    ;; case macro binds actual expr in let so expr is always a local,
    ;; no need to worry about multiple evaluation
    #_method
    (§ defn #_"Expr" (§ method parse) [#_"CaseParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (cast' ISeq ___frm)]
            (when (ß ___context == :Context'EVAL)
                (§ return (ß Compiler'analyze-2(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (let [#_"IPersistentVector" ___args (LazilyPersistentVector'create (next ___form))]
                (let [#_"Object" ___exprForm (.nth ___args, 0)]
                    (let [#_"int" ___shift (.intValue (cast Number (.nth ___args, 1)))]
                        (let [#_"int" ___mask (.intValue (cast Number (.nth ___args, 2)))]
                            (let [#_"Object" ___defaultForm (.nth ___args, 3)]
                                (let [#_"Map" ___caseMap (cast Map (.nth ___args, 4))]
                                    (let [#_"Keyword" ___switchType (ß (cast' Keyword (.nth ___args, 5)))]
                                        (let [#_"Keyword" ___testType (ß (cast' Keyword (.nth ___args, 6)))]
                                            (let [#_"Set" ___skipCheck (if (< (RT'count ___args) 8) nil (cast Set (.nth ___args, 7)))]
                                                (let [#_"ISeq" ___keys (RT'keys ___caseMap)]
                                                    (let [#_"int" ___low (.intValue (cast Number (RT'first ___keys)))]
                                                        (let [#_"int" ___high (ß (cast Number (ß RT'nth-2(___keys, RT'count(___keys) - 1))).intValue())]
                                                            (let [#_"LocalBindingExpr" ___testexpr (cast' LocalBindingExpr (ß Compiler'analyze-2(:Context'EXPRESSION, ___exprForm)))]
                                                                (§ ass (:shouldClear ___testexpr) false)

                                                                (let [#_"SortedMap<Integer, Expr>" ___tests (TreeMap.)]
                                                                    (let [#_"HashMap<Integer, Expr>" ___thens (HashMap.)]
                                                                        (let [#_"PathNode" ___branch (ß PathNode'new(:PathType'BRANCH, (cast' PathNode (.get Compiler'CLEAR_PATH))))]
                                                                            (doseq [#_"Object" ___o (.entrySet ___caseMap)]
                                                                                (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                                                                                    (let [#_"Integer" ___minhash (.intValue (cast Number (.getKey ___e)))]
                                                                                        (let [#_"Object" ___pair (.getValue ___e)] ;; [test-val then-expr]
                                                                                            (let [#_"Expr" ___testExpr (if (= ___testType intKey) (NumberExpr'parse (.intValue (cast Number (RT'first ___pair)))) (ConstantExpr'new (RT'first ___pair)))]
                                                                                                (.put ___tests, ___minhash, ___testExpr)

                                                                                                (§ let [#_"Expr" ___thenExpr]
                                                                                                    (try
                                                                                                        (ß Var'pushThreadBindings(RT'map(Compiler'CLEAR_PATH, PathNode'new(:PathType'PATH, ___branch))))
                                                                                                        (§ ass ___thenExpr (ß Compiler'analyze-2(___context, RT'second(___pair))))
                                                                                                        (finally
                                                                                                            (Var'popThreadBindings)
                                                                                                        )
                                                                                                    )
                                                                                                    (.put ___thens, ___minhash, ___thenExpr)
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )

                                                                            (§ let [#_"Expr" ___defaultExpr]
                                                                                (try
                                                                                    (ß Var'pushThreadBindings(RT'map(Compiler'CLEAR_PATH, PathNode'new(:PathType'PATH, ___branch))))
                                                                                    (§ ass ___defaultExpr (ß Compiler'analyze-2(___context, ___args.nth(3))))
                                                                                    (finally
                                                                                        (Var'popThreadBindings)
                                                                                    )
                                                                                )

                                                                                (let [#_"int" ___line (.intValue (cast Number (.deref Compiler'LINE)))]
                                                                                    (let [#_"int" ___column (.intValue (cast Number (.deref Compiler'COLUMN)))]
                                                                                        (CaseExpr'new ___line, ___column, ___testexpr, ___shift, ___mask, ___low, ___high, ___defaultExpr, ___tests, ___thens, ___switchType, ___testType, ___skipCheck)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
    (def #_"Type" CaseExpr'NUMBER_TYPE (Type/getType Number))
    (def #_"Method" CaseExpr'intValueMethod (Method/getMethod "int intValue()"))

    (def #_"Method" CaseExpr'hashMethod (Method/getMethod "int hash(Object)"))
    (def #_"Method" CaseExpr'hashCodeMethod (Method/getMethod "int hashCode()"))
    (def #_"Method" CaseExpr'equivMethod (Method/getMethod "boolean equiv(Object, Object)"))
    (§ def #_"Keyword" CaseExpr'compactKey (Keyword'intern-2 nil, "compact"))
    (§ def #_"Keyword" CaseExpr'sparseKey (Keyword'intern-2 nil, "sparse"))
    (§ def #_"Keyword" CaseExpr'hashIdentityKey (Keyword'intern-2 nil, "hash-identity"))
    (§ def #_"Keyword" CaseExpr'hashEquivKey (Keyword'intern-2 nil, "hash-equiv"))
    (§ def #_"Keyword" CaseExpr'intKey (Keyword'intern-2 nil, "int"))

    (defn- #_"CaseExpr" CaseExpr'init []
        (hash-map
            #_"LocalBindingExpr" :expr nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"int" :low 0
            #_"int" :high 0
            #_"Expr" :defaultExpr nil
            #_"SortedMap<Integer, Expr>" :tests nil
            #_"HashMap<Integer, Expr>" :thens nil
            #_"Keyword" :switchType nil
            #_"Keyword" :testType nil
            #_"Set<Integer>" :skipCheck nil
            #_"Class" :returnType nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (defn #_"CaseExpr" CaseExpr'new [#_"int" ___line, #_"int" ___column, #_"LocalBindingExpr" ___expr, #_"int" ___shift, #_"int" ___mask, #_"int" ___low, #_"int" ___high, #_"Expr" ___defaultExpr, #_"SortedMap<Integer, Expr>" ___tests, #_"HashMap<Integer, Expr>" ___thens, #_"Keyword" ___switchType, #_"Keyword" ___testType, #_"Set<Integer>" ___skipCheck]
        (let [this (CaseExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:shift this) ___shift)
            (§ ass (:mask this) ___mask)
            (§ ass (:low this) ___low)
            (§ ass (:high this) ___high)
            (§ ass (:defaultExpr this) ___defaultExpr)
            (§ ass (:tests this) ___tests)
            (§ ass (:thens this) ___thens)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (when (and (ß ___switchType != compactKey) (ß ___switchType != sparseKey))
                (throw (IllegalArgumentException. (str "Unexpected switch type: " ___switchType)))
            )
            (§ ass (:switchType this) ___switchType)
            (when (and (ß ___testType != intKey) (ß ___testType != hashEquivKey) (ß ___testType != hashIdentityKey))
                (throw (IllegalArgumentException. (str "Unexpected test type: " ___switchType)))
            )
            (§ ass (:testType this) ___testType)
            (§ ass (:skipCheck this) ___skipCheck)
            (let [#_"Collection<Expr>" ___returns (ArrayList. (.values ___thens))]
                (.add ___returns, ___defaultExpr)
                (§ ass (:returnType this) (Compiler'maybeJavaClass ___returns))
                (when (and (pos? (RT'count ___skipCheck)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", (object-array [ (.deref Compiler'SOURCE_PATH), ___line, ___column ])))
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"CaseExpr" this]
        (some? (:returnType this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"CaseExpr" this]
        (Util'isPrimitive (:returnType this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"CaseExpr" this]
        (:returnType this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___defaultLabel (.newLabel ___gen)]
            (let [#_"Label" ___endLabel (.newLabel ___gen)]
                (let [#_"SortedMap<Integer, Label>" ___labels (TreeMap.)]
                    (doseq [#_"Integer" ___i (.keySet (:tests this))]
                        (ß ___labels.put(___i, (.newLabel ___gen)))
                    )

                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

                    (let [#_"Class" ___primExprClass (Compiler'maybePrimitiveType (:expr this))]
                        (let [#_"Type" ___primExprType (when (some? ___primExprClass) (Type/getType ___primExprClass))]
                            (if (ß (:testType this) == intKey)
                                (do
                                    (.emitExprForInts this, ___objx, ___gen, ___primExprType, ___defaultLabel)
                                )
                                (do
                                    (.emitExprForHashes this, ___objx, ___gen)
                                )
                            )

                            (if (ß (:switchType this) == sparseKey)
                                (do
                                    (let [#_"Label[]" ___la (make-array Label (.size ___labels))]
                                        (§ ass ___la (ß (.values ___labels).toArray(___la)))
                                        (let [#_"int[]" ___ints (ß Numbers'int_array-1((:tests this).keySet()))]
                                            (.visitLookupSwitchInsn ___gen, ___defaultLabel, ___ints, ___la)
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Label[]" ___la (make-array Label (ß ((:high this) - (:low this)) + 1))]
                                        (loop-when-recur [#_"int" ___i (:low this)] (ß ___i <= (:high this)) [(inc ___i)]
                                            (§ ass (§ aget ___la (ß ___i - (:low this))) (if (.containsKey ___labels, ___i) (.get ___labels, ___i) ___defaultLabel))
                                        )
                                        (.visitTableSwitchInsn ___gen, (:low this), (:high this), ___defaultLabel, ___la)
                                    )
                                )
                            )

                            (doseq [#_"Integer" ___i (.keySet ___labels)]
                                (ß ___gen.mark(___labels.get(___i)))
                                (cond (ß (:testType this) == intKey)
                                    (do
                                        (ß this.emitThenForInts(___objx, ___gen, ___primExprType, (:tests this).get(___i), (:thens this).get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                    (ß RT'contains((:skipCheck this), ___i) == RT'T)
                                    (do
                                        (ß CaseExpr'emitExpr(___objx, ___gen, (:thens this).get(___i), ___emitUnboxed))
                                    )
                                    :else
                                    (do
                                        (ß this.emitThenForHashes(___objx, ___gen, (:tests this).get(___i), (:thens this).get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                )
                                (.goTo ___gen, ___endLabel)
                            )

                            (.mark ___gen, ___defaultLabel)
                            (CaseExpr'emitExpr ___objx, ___gen, (:defaultExpr this), ___emitUnboxed)
                            (.mark ___gen, ___endLabel)
                            (when (ß ___context == :Context'STATEMENT)
                                (.pop ___gen)
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method isShiftMasked) [#_"CaseExpr" this]
        (ß ((:mask this) != 0))
    )

    #_method
    (§ defn- #_"void" (§ method emitShiftMask) [#_"CaseExpr" this, #_"GeneratorAdapter" ___gen]
        (when (.isShiftMasked this)
            (.push ___gen, (:shift this))
            (.visitInsn ___gen, Opcodes/ISHR)
            (.push ___gen, (:mask this))
            (.visitInsn ___gen, Opcodes/IAND)
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitExprForInts) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Label" ___defaultLabel]
        (cond (nil? ___exprType)
            (do
                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", (object-array [ (.deref Compiler'SOURCE_PATH), (:line this), (:column this) ])))
                )
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.instanceOf ___gen, CaseExpr'NUMBER_TYPE)
                (.ifZCmp ___gen, GeneratorAdapter/EQ, ___defaultLabel)
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.checkCast ___gen, CaseExpr'NUMBER_TYPE)
                (.invokeVirtual ___gen, CaseExpr'NUMBER_TYPE, HostExpr'intValueMethod)
                (.emitShiftMask this, ___gen)
            )
            (or (ß ___exprType == Type/LONG_TYPE) (ß ___exprType == Type/INT_TYPE) (ß ___exprType == Type/SHORT_TYPE) (ß ___exprType == Type/BYTE_TYPE))
            (do
                (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (.cast ___gen, ___exprType, Type/INT_TYPE)
                (.emitShiftMask this, ___gen)
            )
            :else
            (do
                (.goTo ___gen, ___defaultLabel)
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitThenForInts) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (cond (nil? ___exprType)
            (do
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
                (.invokeStatic ___gen, Compiler'UTIL_TYPE, equivMethod)
                (.ifZCmp ___gen, GeneratorAdapter/EQ, ___defaultLabel)
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            (= ___exprType Type/LONG_TYPE)
            (do
                (ß (cast' NumberExpr ___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (.ifCmp ___gen, Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel)
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            (or (ß ___exprType == Type/INT_TYPE) (ß ___exprType == Type/SHORT_TYPE) (ß ___exprType == Type/BYTE_TYPE))
            (do
                (when (.isShiftMasked this)
                    (ß (cast' NumberExpr ___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (.cast ___gen, ___exprType, Type/LONG_TYPE)
                    (.ifCmp ___gen, Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel)
                )
                ;; else direct match
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            :else
            (do
                (.goTo ___gen, ___defaultLabel)
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitExprForHashes) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.invokeStatic ___gen, Compiler'UTIL_TYPE, hashMethod)
        (.emitShiftMask this, ___gen)
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitThenForHashes) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
        (if (ß (:testType this) == hashIdentityKey)
            (do
                (.visitJumpInsn ___gen, Opcodes/IF_ACMPNE, ___defaultLabel)
            )
            (do
                (.invokeStatic ___gen, Compiler'UTIL_TYPE, equivMethod)
                (.ifZCmp ___gen, GeneratorAdapter/EQ, ___defaultLabel)
            )
        )
        (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
        nil
    )

    (defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___expr, #_"boolean" ___emitUnboxed]
        (if (and ___emitUnboxed (§ instance? MaybePrimitiveExpr ___expr))
            (do
                (ß (cast' MaybePrimitiveExpr ___expr).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
            )
            (do
                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        nil
    )
)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" Compiler'DEF (Symbol'intern-1 "def"))
    (§ def #_"Symbol" Compiler'LOOP (Symbol'intern-1 "loop*"))
    (§ def #_"Symbol" Compiler'RECUR (Symbol'intern-1 "recur"))
    (§ def #_"Symbol" Compiler'IF (Symbol'intern-1 "if"))
    (§ def #_"Symbol" Compiler'LET (Symbol'intern-1 "let*"))
    (§ def #_"Symbol" Compiler'LETFN (Symbol'intern-1 "letfn*"))
    (§ def #_"Symbol" Compiler'DO (Symbol'intern-1 "do"))
    (§ def #_"Symbol" Compiler'FN (Symbol'intern-1 "fn*"))
    (§ def #_"Symbol" Compiler'FNONCE (cast' Symbol (ß Symbol'intern-1("fn*").withMeta(RT'map(Keyword'intern-2(nil, "once"), RT'T)))))
    (§ def #_"Symbol" Compiler'QUOTE (Symbol'intern-1 "quote"))
    (§ def #_"Symbol" Compiler'THE_VAR (Symbol'intern-1 "var"))
    (§ def #_"Symbol" Compiler'DOT (Symbol'intern-1 "."))
    (§ def #_"Symbol" Compiler'ASSIGN (Symbol'intern-1 "set!"))
    (§ def #_"Symbol" Compiler'TRY (Symbol'intern-1 "try"))
    (§ def #_"Symbol" Compiler'CATCH (Symbol'intern-1 "catch"))
    (§ def #_"Symbol" Compiler'FINALLY (Symbol'intern-1 "finally"))
    (§ def #_"Symbol" Compiler'THROW (Symbol'intern-1 "throw"))
    (§ def #_"Symbol" Compiler'MONITOR_ENTER (Symbol'intern-1 "monitor-enter"))
    (§ def #_"Symbol" Compiler'MONITOR_EXIT (Symbol'intern-1 "monitor-exit"))
    (§ def #_"Symbol" Compiler'IMPORT (Symbol'intern-2 "cloiure.core", "import*"))
    (§ def #_"Symbol" Compiler'DEFTYPE (Symbol'intern-1 "deftype*"))
    (§ def #_"Symbol" Compiler'CASE (Symbol'intern-1 "case*"))

    (§ def #_"Symbol" Compiler'CLASS (Symbol'intern-1 "Class"))
    (§ def #_"Symbol" Compiler'NEW (Symbol'intern-1 "new"))
    (§ def #_"Symbol" Compiler'THIS (Symbol'intern-1 "this"))
    (§ def #_"Symbol" Compiler'REIFY (Symbol'intern-1 "reify*"))
    (§ def #_"Symbol" Compiler'LIST (Symbol'intern-2 "cloiure.core", "list"))
    (§ def #_"Symbol" Compiler'HASHMAP (Symbol'intern-2 "cloiure.core", "hash-map"))
    (§ def #_"Symbol" Compiler'VECTOR (Symbol'intern-2 "cloiure.core", "vector"))
    (§ def #_"Symbol" Compiler'IDENTITY (Symbol'intern-2 "cloiure.core", "identity"))

    (§ def #_"Symbol" Compiler'_AMP_ (Symbol'intern-1 "&"))
    (§ def #_"Symbol" Compiler'ISEQ (Symbol'intern-1 "cloiure.lang.ISeq"))

    (§ def #_"Keyword" Compiler'loadNs (Keyword'intern-2 nil, "load-ns"))
    (§ def #_"Keyword" Compiler'inlineKey (Keyword'intern-2 nil, "inline"))
    (§ def #_"Keyword" Compiler'inlineAritiesKey (Keyword'intern-2 nil, "inline-arities"))
    (§ def #_"Keyword" Compiler'staticKey (Keyword'intern-2 nil, "static"))
    (§ def #_"Keyword" Compiler'arglistsKey (Keyword'intern-2 nil, "arglists"))
    (§ def #_"Symbol" Compiler'INVOKE_STATIC (Symbol'intern-1 "invokeStatic"))

    (§ def #_"Keyword" Compiler'volatileKey (Keyword'intern-2 nil, "volatile"))
    (§ def #_"Keyword" Compiler'implementsKey (Keyword'intern-2 nil, "implements"))
    (def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" Compiler'protocolKey (Keyword'intern-2 nil, "protocol"))
    (§ def #_"Keyword" Compiler'onKey (Keyword'intern-2 nil, "on"))
    (§ def #_"Keyword" Compiler'dynamicKey (Keyword'intern-1 "dynamic"))
    (§ def #_"Keyword" Compiler'redefKey (Keyword'intern-2 nil, "redef"))

    (§ def #_"Symbol" Compiler'NS (Symbol'intern-1 "ns"))
    (§ def #_"Symbol" Compiler'IN_NS (Symbol'intern-1 "in-ns"))

    (def #_"IPersistentMap" Compiler'specials (ß PersistentHashMap'create-1a(
        (object-array [
            Compiler'DEF           (DefParser'new)
            Compiler'LOOP          (LetParser'new)
            Compiler'RECUR         (RecurParser'new)
            Compiler'IF            (IfParser'new)
            Compiler'CASE          (CaseParser'new)
            Compiler'LET           (LetParser'new)
            Compiler'LETFN         (LetFnParser'new)
            Compiler'DO            (BodyParser'new)
            Compiler'FN            nil
            Compiler'QUOTE         (ConstantParser'new)
            Compiler'THE_VAR       (TheVarParser'new)
            Compiler'IMPORT        (ImportParser'new)
            Compiler'DOT           (HostParser'new)
            Compiler'ASSIGN        (AssignParser'new)
            Compiler'DEFTYPE       (DeftypeParser'new)
            Compiler'REIFY         (ReifyParser'new)
            Compiler'TRY           (TryParser'new)
            Compiler'THROW         (ThrowParser'new)
            Compiler'MONITOR_ENTER (MonitorEnterParser'new)
            Compiler'MONITOR_EXIT  (MonitorExitParser'new)
            Compiler'CATCH         nil
            Compiler'FINALLY       nil
            Compiler'NEW           (NewParser'new)
            Compiler'_AMP_         nil
        ])
    )))

    (def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)

    (def #_"Type" Compiler'CLASS_TYPE (Type/getType Class))
    (def #_"Type" Compiler'OBJECT_TYPE (Type/getType Object))
    (def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (Type/getType Boolean))
    (def #_"Type" Compiler'THROWABLE_TYPE (Type/getType Throwable))

    (§ def- #_"Type" Compiler'KEYWORD_TYPE (Type/getType (§ class Keyword)))
    (§ def- #_"Type" Compiler'VAR_TYPE (Type/getType (§ class Var)))
    (§ def- #_"Type" Compiler'SYMBOL_TYPE (Type/getType (§ class Symbol)))
    (§ def- #_"Type" Compiler'IFN_TYPE (Type/getType (§ class IFn)))
    (§ def- #_"Type" Compiler'AFUNCTION_TYPE (Type/getType (§ class AFunction)))
    (§ def- #_"Type" Compiler'RT_TYPE (Type/getType (§ class RT)))
    (§ def- #_"Type" Compiler'NUMBERS_TYPE (Type/getType (§ class Numbers)))

    (§ def #_"Type" Compiler'NS_TYPE (Type/getType (§ class Namespace)))
    (§ def #_"Type" Compiler'UTIL_TYPE (Type/getType (§ class Util)))
    (§ def #_"Type" Compiler'REFLECTOR_TYPE (Type/getType (§ class Reflector)))
    (§ def #_"Type" Compiler'IPERSISTENTMAP_TYPE (Type/getType (§ class IPersistentMap)))
    (§ def #_"Type" Compiler'IOBJ_TYPE (Type/getType (§ class IObj)))
    (§ def #_"Type" Compiler'TUPLE_TYPE (Type/getType (§ class Tuple)))

    (def #_"Method[]" Compiler'createTupleMethods
        (object-array [
            (Method/getMethod "cloiure.lang.IPersistentVector create()")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object, Object)")
        ])
    )

    (def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (def- #_"Type[]" Compiler'EXCEPTION_TYPES (object-array 0))

    (§ static
        (§ ass Compiler'ARG_TYPES (ß new Type[Compiler'MAX_POSITIONAL_ARITY + 2][]))
        (loop-when-recur [#_"int" ___i 0] (<= ___i Compiler'MAX_POSITIONAL_ARITY) [(inc ___i)]
            (let [#_"Type[]" ___a (make-array Type ___i)]
                (loop-when-recur [#_"int" ___j 0] (< ___j ___i) [(inc ___j)]
                    (§ ass (§ aget ___a ___j) Compiler'OBJECT_TYPE)
                )
                (§ ass (ß Compiler'ARG_TYPES[___i]) ___a)
            )
        )
        (let [#_"Type[]" ___a (make-array Type (ß Compiler'MAX_POSITIONAL_ARITY + 1))]
            (loop-when-recur [#_"int" ___j 0] (< ___j Compiler'MAX_POSITIONAL_ARITY) [(inc ___j)]
                (§ ass (§ aget ___a ___j) Compiler'OBJECT_TYPE)
            )
            (§ ass (§ aget ___a Compiler'MAX_POSITIONAL_ARITY) (Type/getType "[Ljava/lang/Object;"))
            (§ ass (ß Compiler'ARG_TYPES[Compiler'MAX_POSITIONAL_ARITY + 1]) ___a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" Compiler'LOCAL_ENV (ß Var'create-1(nil).setDynamic()))

    ;; vector<localbinding>
    (§ def #_"Var" Compiler'LOOP_LOCALS (ß Var'create-0().setDynamic()))

    ;; Label
    (§ def #_"Var" Compiler'LOOP_LABEL (ß Var'create-0().setDynamic()))

    ;; vector<object>
    (§ def #_"Var" Compiler'CONSTANTS (ß Var'create-0().setDynamic()))

    ;; IdentityHashMap
    (§ def #_"Var" Compiler'CONSTANT_IDS (ß Var'create-0().setDynamic()))

    ;; vector<keyword>
    (§ def #_"Var" Compiler'KEYWORD_CALLSITES (ß Var'create-0().setDynamic()))

    ;; vector<var>
    (§ def #_"Var" Compiler'PROTOCOL_CALLSITES (ß Var'create-0().setDynamic()))

    ;; set<var>
    (§ def #_"Var" Compiler'VAR_CALLSITES (ß Var'create-0().setDynamic()))

    ;; keyword->constid
    (§ def #_"Var" Compiler'KEYWORDS (ß Var'create-0().setDynamic()))

    ;; var->constid
    (§ def #_"Var" Compiler'VARS (ß Var'create-0().setDynamic()))

    ;; FnFrame
    (§ def #_"Var" Compiler'METHOD (ß Var'create-1(nil).setDynamic()))

    ;; nil or not
    (§ def #_"Var" Compiler'IN_CATCH_FINALLY (ß Var'create-1(nil).setDynamic()))

    (§ def #_"Var" Compiler'METHOD_RETURN_CONTEXT (ß Var'create-1(nil).setDynamic()))

    (§ def #_"Var" Compiler'NO_RECUR (ß Var'create-1(nil).setDynamic()))

    ;; DynamicClassLoader
    (§ def #_"Var" Compiler'LOADER (ß Var'create-0().setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*source-path*"), "NO_SOURCE_FILE").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE_PATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*file*"), "NO_SOURCE_PATH").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'COMPILE_PATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compile-path*"), nil).setDynamic()))
    ;; boolean
    (§ def #_"Var" Compiler'COMPILE_FILES (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compile-files*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Var" Compiler'INSTANCE (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("instance?"))))

    (§ def #_"Var" Compiler'ADD_ANNOTATIONS (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("add-annotations"))))

    (§ def #_"Keyword" Compiler'disableLocalsClearingKey (Keyword'intern-1 "disable-locals-clearing"))
    (§ def #_"Keyword" Compiler'directLinkingKey (Keyword'intern-1 "direct-linking"))
    (§ def #_"Keyword" Compiler'elideMetaKey (Keyword'intern-1 "elide-meta"))

    (def #_"Var" Compiler'COMPILER_OPTIONS nil)

    (defn #_"Object" Compiler'getCompilerOption [#_"Keyword" ___k]
        (ß RT'get-2(Compiler'COMPILER_OPTIONS.deref(), ___k))
    )

    (§ static
        (let [#_"Object" ___compilerOptions nil]
            (doseq [#_"Map$Entry" ___e (ß System/getProperties().entrySet())]
                (let [#_"String" ___name (cast String (.getKey ___e))]
                    (let [#_"String" ___v (cast String (.getValue ___e))]
                        (when (.startsWith ___name, "cloiure.compiler.")
                            (§ ass ___compilerOptions (ß RT'assoc(___compilerOptions, RT'keyword(nil, ___name.substring(1 + ___name.lastIndexOf(\.))), RT'readString-1(___v))))
                        )
                    )
                )
            )

            (§ ass Compiler'COMPILER_OPTIONS (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compiler-options*"), ___compilerOptions).setDynamic()))
        )
    )

    (defn #_"Object" Compiler'elideMeta [#_"Object" ___m]
        (let [#_"Collection<Object>" ___elides (ß (Collection<Object>) Compiler'getCompilerOption(Compiler'elideMetaKey))]
            (when (some? ___elides)
                (doseq [#_"Object" ___k ___elides]
                    (§ ass ___m (RT'dissoc ___m, ___k))
                )
            )
            ___m
        )
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN (ß Var'create-1(0).setDynamic()))

    (defn #_"int" Compiler'lineDeref []
        (.intValue (cast Number (.deref Compiler'LINE)))
    )

    (defn #_"int" Compiler'columnDeref []
        (.intValue (cast Number (.deref Compiler'COLUMN)))
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE_BEFORE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_BEFORE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'LINE_AFTER (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_AFTER (ß Var'create-1(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'NEXT_LOCAL_NUM (ß Var'create-1(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'RET_LOCAL_NUM (ß Var'create-0().setDynamic()))

    (§ def #_"Var" Compiler'COMPILE_STUB_SYM (ß Var'create-1(nil).setDynamic()))
    (§ def #_"Var" Compiler'COMPILE_STUB_CLASS (ß Var'create-1(nil).setDynamic()))

    ;; PathNode chain
    (§ def #_"Var" Compiler'CLEAR_PATH (ß Var'create-1(nil).setDynamic()))

    ;; tail of PathNode chain
    (§ def #_"Var" Compiler'CLEAR_ROOT (ß Var'create-1(nil).setDynamic()))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" Compiler'CLEAR_SITES (ß Var'create-1(nil).setDynamic()))

    (def #_"Class" Compiler'RECUR_CLASS (§ class Recur))

    (defn #_"boolean" Compiler'isSpecial [#_"Object" ___sym]
        (.containsKey Compiler'specials, ___sym)
    )

    (defn #_"boolean" Compiler'inTailCall [#_"Context" ___context]
        (and (= ___context :Context'RETURN) (some? (.deref Compiler'METHOD_RETURN_CONTEXT)) (nil? (.deref Compiler'IN_CATCH_FINALLY)))
    )

    (defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" ___sym]
        ;; already qualified or classname?
        (when (pos? (.indexOf (:name ___sym), \.))
            (§ return ___sym)
        )
        (when (ß (some? (:ns ___sym)))
            (let [#_"Namespace" ___ns (Compiler'namespaceFor-1 ___sym)]
                (when (or (nil? ___ns) (if (nil? (:name (:name ___ns))) (nil? (:ns ___sym)) (.equals (:name (:name ___ns)), (:ns ___sym))))
                    (§ return ___sym)
                )
                (§ return (ß Symbol'intern-2((:name (:name ___ns)), (:name ___sym))))
            )
        )
        (let [#_"Object" ___o (ß (.currentNS this).getMapping(___sym))]
            (cond (nil? ___o)
                (do
                    (§ return (ß Symbol'intern-2((:name (:name (.currentNS this))), (:name ___sym))))
                )
                (instance? Class ___o)
                (do
                    (§ return (ß Symbol'intern-2(nil, (cast Class ___o).getName())))
                )
                (§ instance? Var ___o)
                (do
                    (let [#_"Var" ___v (cast' Var ___o)]
                        (§ return (ß Symbol'intern-2((:name (:name (:ns ___v))), (:name (:sym ___v)))))
                    )
                )
            )
            nil
        )
    )

    (defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" ___e]
        (when (and (§ instance? MaybePrimitiveExpr ___e) (.hasJavaClass ___e) (.canEmitPrimitive (cast' MaybePrimitiveExpr ___e)))
            (let [#_"Class" ___c (.getJavaClass ___e)]
                (when (Util'isPrimitive ___c)
                    (§ return ___c)
                )
            )
        )
        nil
    )

    (defn #_"Class" Compiler'maybeJavaClass [#_"Collection<Expr>" ___exprs]
        (let [#_"Class" ___match nil]
            (try
                (doseq [#_"Expr" ___e ___exprs]
                    (when (§ instance? ThrowExpr ___e)
                        (§ continue )
                    )
                    (when (not (.hasJavaClass ___e))
                        (§ return nil)
                    )
                    (let [#_"Class" ___c (.getJavaClass ___e)]
                        (cond (nil? ___match)
                            (do
                                (§ ass ___match ___c)
                            )
                            (not= ___match ___c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception ___e
                    (§ return nil)
                )
            )
            ___match
        )
    )

    (§ def #_"NilExpr" Compiler'NIL_EXPR (NilExpr'new))

    (§ def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr'new true))
    (§ def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr'new false))

    (defn #_"boolean" Compiler'subsumes [#_"Class[]" ___c1, #_"Class[]" ___c2]
        ;; presumes matching lengths
        (let [#_"Boolean" ___better false]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___c1)) [(inc ___i)]
                (when (ß ___c1[___i] != ___c2[___i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (or (and (not (ß ___c1[___i].isPrimitive())) (ß ___c2[___i].isPrimitive())) (ß ___c2[___i].isAssignableFrom(___c1[___i])))
                        (do
                            (§ ass ___better true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            ___better
        )
    )

    (defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" ___args]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
                (let [#_"Expr" ___arg (cast' Expr (.nth ___args, ___i))]
                    (when (> ___i 0)
                        (.append ___sb, ", ")
                    )
                    (.append ___sb, (if (and (.hasJavaClass ___arg) (some? (.getJavaClass ___arg))) (.getName (.getJavaClass ___arg)) "unknown"))
                )
            )
            (.toString ___sb)
        )
    )

    (defn #_"int" Compiler'getMatchingParams [#_"String" ___methodName, #_"ArrayList<Class[]>" ___paramlists, #_"IPersistentVector" ___argexprs, #_"List<Class>" ___rets]
        ;; presumes matching lengths
        (let [#_"int" ___matchIdx -1]
            (let [#_"boolean" ___tied false]
                (let [#_"boolean" ___foundExact false]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___paramlists)) [(inc ___i)]
                        (let [#_"boolean" ___match true]
                            (let [#_"ISeq" ___aseq (.seq ___argexprs)]
                                (let [#_"int" ___exact 0]
                                    (loop-when-recur [#_"int" ___p 0 ___aseq ___aseq] (and ___match (< ___p (count ___argexprs)) (some? ___aseq)) [(inc ___p) (next ___aseq)]
                                        (let [#_"Expr" ___arg (cast' Expr (first ___aseq))]
                                            (let [#_"Class" ___aclass (if (.hasJavaClass ___arg) (.getJavaClass ___arg) Object)]
                                                (let [#_"Class" ___pclass (ß ___paramlists.get(___i)[___p])]
                                                    (if (and (.hasJavaClass ___arg) (ß ___aclass == ___pclass))
                                                        (do
                                                            (§ ass ___exact (inc ___exact))
                                                        )
                                                        (do
                                                            (§ ass ___match (Reflector'paramArgTypeMatch ___pclass, ___aclass))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß ___exact == (count ___argexprs))
                                        (do
                                            (when (or (not ___foundExact) (ß ___matchIdx == -1) (ß ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i))))
                                                (§ ass ___matchIdx ___i)
                                            )
                                            (§ ass ___tied false)
                                            (§ ass ___foundExact true)
                                        )
                                        (and ___match (not ___foundExact))
                                        (do
                                            (if (= ___matchIdx -1)
                                                (do
                                                    (§ ass ___matchIdx ___i)
                                                )
                                                (do
                                                    (cond (ß Compiler'subsumes(___paramlists.get(___i), ___paramlists.get(___matchIdx)))
                                                        (do
                                                            (§ ass ___matchIdx ___i)
                                                            (§ ass ___tied false)
                                                        )
                                                        (ß Arrays/equals(___paramlists.get(___matchIdx), ___paramlists.get(___i)))
                                                        (do
                                                            (when (ß ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                                (§ ass ___matchIdx ___i)
                                                            )
                                                        )
                                                        (not (ß Compiler'subsumes(___paramlists.get(___matchIdx), ___paramlists.get(___i))))
                                                        (do
                                                            (§ ass ___tied true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when ___tied
                        (throw (IllegalArgumentException. (str "More than one matching method found: " ___methodName)))
                    )

                    ___matchIdx
                )
            )
        )
    )

    (def #_"IPersistentMap" Compiler'CHAR_MAP (ß PersistentHashMap'create-1a(
        (object-array [
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        ])
    )))

    (def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" ___m (ß RT'map("$", \/))]
            (loop-when-recur [#_"ISeq" ___s (RT'seq Compiler'CHAR_MAP)] (some? ___s) [(next ___s)]
                (let [#_"IMapEntry" ___e (cast' IMapEntry (first ___s))]
                    (let [#_"Character" ___origCh (cast Character (.key ___e))]
                        (let [#_"String" ___escapeStr (cast String (.val ___e))]
                            (§ ass ___m (.assoc ___m, ___escapeStr, ___origCh))
                        )
                    )
                )
            )
            (§ ass Compiler'DEMUNGE_MAP ___m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired. Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" ___mungeStrs (ß RT'toArray(RT'keys(___m)))]
                (ß Arrays/sort(___mungeStrs,
                        (§ reify Comparator()
                            #_method
                            (§ defn #_"int" (§ method compare) [#_"Comparator" this, #_"Object" ___s1, #_"Object" ___s2]
                                (ß (cast String ___s2).length() - (cast String ___s1).length())
                            )
                        )
                    )
                )
                (let [#_"StringBuilder" ___sb (StringBuilder.)]
                    (let [#_"boolean" ___first true]
                        (doseq [#_"Object" ___s ___mungeStrs]
                            (let [#_"String" ___escapeStr (cast String ___s)]
                                (when (not ___first)
                                    (.append ___sb, "|")
                                )
                                (§ ass ___first false)
                                (.append ___sb, "\\Q")
                                (.append ___sb, ___escapeStr)
                                (.append ___sb, "\\E")
                            )
                        )
                        (§ ass Compiler'DEMUNGE_PATTERN (Pattern/compile (.toString ___sb)))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'munge [#_"String" ___name]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (doseq [#_"char" ___c (.toCharArray ___name)]
                (let [#_"String" ___sub (cast String (.valAt Compiler'CHAR_MAP, ___c))]
                    (if (some? ___sub)
                        (do
                            (.append ___sb, ___sub)
                        )
                        (do
                            (.append ___sb, ___c)
                        )
                    )
                )
            )
            (.toString ___sb)
        )
    )

    (defn #_"String" Compiler'demunge [#_"String" ___mungedName]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Matcher" ___m (.matcher Compiler'DEMUNGE_PATTERN, ___mungedName)]
                (let [#_"int" ___lastMatchEnd 0]
                    (while (.find ___m)
                        (let [#_"int" ___start (.start ___m)]
                            (let [#_"int" ___end (.end ___m)]
                                ;; Keep everything before the match
                                (ß ___sb.append(___mungedName.substring(___lastMatchEnd, ___start)))
                                (§ ass ___lastMatchEnd ___end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" ___origCh (cast Character (.valAt Compiler'DEMUNGE_MAP, (.group ___m)))]
                                    (.append ___sb, ___origCh)
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß ___sb.append(___mungedName.substring(___lastMatchEnd)))
                    (.toString ___sb)
                )
            )
        )
    )

    (defn #_"PathNode" Compiler'clearPathRoot []
        (cast' PathNode (.get Compiler'CLEAR_ROOT))
    )

    (defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg]
        (let [#_"int" ___num (Compiler'getAndIncLocalNum)]
            (let [#_"LocalBinding" ___b (ß LocalBinding'new(___num, ___sym, ___tag, ___init, ___isArg, Compiler'clearPathRoot()))]
                (let [#_"IPersistentMap" ___localsMap (cast' IPersistentMap (.deref Compiler'LOCAL_ENV))]
                    (ß Compiler'LOCAL_ENV.set(RT'assoc(___localsMap, (:sym ___b), ___b)))
                    (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (§ ass (:locals ___method) (cast' IPersistentMap (ß RT'assoc((:locals ___method), ___b, ___b))))
                        (§ ass (:indexlocals ___method) (cast' IPersistentMap (ß RT'assoc((:indexlocals ___method), ___num, ___b))))
                        ___b
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" ___num (.intValue (cast Number (.deref Compiler'NEXT_LOCAL_NUM)))]
            (let [#_"ObjMethod" ___m (cast' ObjMethod (.deref Compiler'METHOD))]
                (when (ß ___num > (:maxLocal ___m))
                    (§ ass (:maxLocal ___m) ___num)
                )
                (ß Compiler'NEXT_LOCAL_NUM.set(___num + 1))
                ___num
            )
        )
    )

    (defn #_"Expr" Compiler'analyze-2 [#_"Context" ___context, #_"Object" ___form]
        (Compiler'analyze-3 ___context, ___form, nil)
    )

    (defn- #_"Expr" Compiler'analyze-3 [#_"Context" ___context, #_"Object" ___form, #_"String" ___name]
        ;; todo symbol macro expansion?
        (try
            (when (§ instance? LazySeq ___form)
                (let [#_"Object" ___mform ___form]
                    (§ ass ___form (RT'seq ___form))
                    (when (nil? ___form)
                        (§ ass ___form PersistentList'EMPTY)
                    )
                    (§ ass ___form (ß (cast' IObj ___form).withMeta(RT'meta(___mform))))
                )
            )
            (cond (nil? ___form)
                (do
                    (§ return Compiler'NIL_EXPR)
                )
                (= ___form Boolean/TRUE)
                (do
                    (§ return Compiler'TRUE_EXPR)
                )
                (= ___form Boolean/FALSE)
                (do
                    (§ return Compiler'FALSE_EXPR)
                )
            )
            (let [#_"Class" ___fclass (.getClass ___form)]
                (cond (ß ___fclass == (§ class Symbol))
                    (do
                        (§ return (Compiler'analyzeSymbol (cast' Symbol ___form)))
                    )
                    (ß ___fclass == (§ class Keyword))
                    (do
                        (§ return (Compiler'registerKeyword (cast' Keyword ___form)))
                    )
                    (instance? Number ___form)
                    (do
                        (§ return (NumberExpr'parse (cast Number ___form)))
                    )
                    (= ___fclass String)
                    (do
                        (§ return (StringExpr'new (.intern (cast String ___form))))
                    )
                    (and (§ instance? IPersistentCollection ___form) (not (§ instance? IRecord ___form)) (not (§ instance? IType ___form)) (zero? (.count (cast' IPersistentCollection ___form))))
                    (do
                        (let [#_"Expr" ___ret (EmptyExpr'new ___form)]
                            (when (some? (RT'meta ___form))
                                (§ ass ___ret (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (.meta (cast' IObj ___form)))))
                            )
                            (§ return ___ret)
                        )
                    )
                    (§ instance? ISeq ___form)
                    (do
                        (§ return (ß Compiler'analyzeSeq(___context, (cast' ISeq ___form), ___name)))
                    )
                    (§ instance? IPersistentVector ___form)
                    (do
                        (§ return (ß VectorExpr'parse(___context, (cast' IPersistentVector ___form))))
                    )
                    (§ instance? IRecord ___form)
                    (do
                        (§ return (ConstantExpr'new ___form))
                    )
                    (§ instance? IType ___form)
                    (do
                        (§ return (ConstantExpr'new ___form))
                    )
                    (§ instance? IPersistentMap ___form)
                    (do
                        (§ return (ß MapExpr'parse(___context, (cast' IPersistentMap ___form))))
                    )
                    (§ instance? IPersistentSet ___form)
                    (do
                        (§ return (ß SetExpr'parse(___context, (cast' IPersistentSet ___form))))
                    )
                )

                (ConstantExpr'new ___form)
            )
            (catch Throwable ___e
                (if (not (§ instance? CompilerException ___e))
                    (do
                        (throw (ß CompilerException'new((cast String (.deref Compiler'SOURCE_PATH)), Compiler'lineDeref(), Compiler'columnDeref(), ___e)))
                    )
                    (do
                        (throw (cast' CompilerException ___e))
                    )
                )
            )
        )
    )

    (defn #_"Var" Compiler'isMacro [#_"Object" ___op]
        ;; no local macros for now
        (when (and (§ instance? Symbol ___op) (some? (Compiler'referenceLocal (cast' Symbol ___op))))
            (§ return nil)
        )
        (when (or (§ instance? Symbol ___op) (§ instance? Var ___op))
            (let [#_"Var" ___v (if (§ instance? Var ___op) (cast' Var ___op) (Compiler'lookupVar-3 (cast' Symbol ___op), false, false))]
                (when (and (some? ___v) (.isMacro ___v))
                    (when (and (ß (:ns ___v) != (.currentNS this)) (not (.isPublic ___v)))
                        (throw (IllegalStateException. (str "var: " ___v " is not public")))
                    )
                    (§ return ___v)
                )
            )
        )
        nil
    )

    (defn #_"IFn" Compiler'isInline [#_"Object" ___op, #_"int" ___arity]
        ;; no local inlines for now
        (when (and (§ instance? Symbol ___op) (some? (Compiler'referenceLocal (cast' Symbol ___op))))
            (§ return nil)
        )
        (when (or (§ instance? Symbol ___op) (§ instance? Var ___op))
            (let [#_"Var" ___v (if (§ instance? Var ___op) (cast' Var ___op) (Compiler'lookupVar-2 (cast' Symbol ___op), false))]
                (when (some? ___v)
                    (when (and (ß (:ns ___v) != (.currentNS this)) (not (.isPublic ___v)))
                        (throw (IllegalStateException. (str "var: " ___v " is not public")))
                    )
                    (let [#_"IFn" ___ret (cast' IFn (ß RT'get-2((.meta ___v), Compiler'inlineKey)))]
                        (when (some? ___ret)
                            (let [#_"IFn" ___arityPred (cast' IFn (ß RT'get-2((.meta ___v), Compiler'inlineAritiesKey)))]
                                (when (or (nil? ___arityPred) (ß RT'booleanCast-1o(___arityPred.invoke(___arity))))
                                    (§ return ___ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" ___sym]
        (and (some? (:ns ___sym)) (nil? (Compiler'namespaceFor-1 ___sym)))
    )

    (defn #_"Object" Compiler'preserveTag [#_"ISeq" ___src, #_"Object" ___dst]
        (let [#_"Symbol" ___tag (Compiler'tagOf ___src)]
            (when (and (some? ___tag) (§ instance? IObj ___dst))
                (let [#_"IPersistentMap" ___meta (RT'meta ___dst)]
                    (§ return (ß (cast' IObj ___dst).withMeta((cast' IPersistentMap (RT'assoc ___meta, RT'TAG_KEY, ___tag)))))
                )
            )
            ___dst
        )
    )

    #_volatile
    (def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (defn- #_"Var" Compiler'ensureMacroCheck [] #_(§ throws ClassNotFoundException, IOException)
        (when (nil? Compiler'MACRO_CHECK)
            (§ sync Compiler'MACRO_CHECK_LOCK
                (when (nil? Compiler'MACRO_CHECK)
                    (§ ass Compiler'MACRO_CHECK_LOADING true)
                    (RT'load-1 "cloiure/spec/alpha")
                    (RT'load-1 "cloiure/core/specs/alpha")
                    (§ ass Compiler'MACRO_CHECK (ß Var'find(Symbol'intern-2("cloiure.spec.alpha", "macroexpand-check"))))
                    (§ ass Compiler'MACRO_CHECK_LOADING false)
                )
            )
        )
        Compiler'MACRO_CHECK
    )

    (defn #_"void" Compiler'checkSpecs [#_"Var" ___v, #_"ISeq" ___form]
        (when (and RT'CHECK_SPECS (not Compiler'MACRO_CHECK_LOADING))
            (try
                (ß Compiler'ensureMacroCheck().applyTo(RT'cons(___v, RT'list-1((next ___form)))))
                (catch Exception ___e
                    (throw (ß CompilerException'new((cast String (.deref Compiler'SOURCE_PATH)), Compiler'lineDeref(), Compiler'columnDeref(), ___e)))
                )
            )
        )
        nil
    )

    (defn #_"Object" Compiler'macroexpand1 [#_"Object" ___x]
        (when (§ instance? ISeq ___x)
            (let [#_"ISeq" ___form (cast' ISeq ___x)]
                (let [#_"Object" ___op (RT'first ___form)]
                    (when (Compiler'isSpecial ___op)
                        (§ return ___x)
                    )
                    ;; macro expansion
                    (let [#_"Var" ___v (Compiler'isMacro ___op)]
                        (if (some? ___v)
                            (do
                                (Compiler'checkSpecs ___v, ___form)

                                (try
                                    (let [#_"ISeq" ___args (ß RT'cons(___form, RT'cons(Compiler'LOCAL_ENV.get(), (next ___form))))]
                                        (§ return (.applyTo ___v, ___args))
                                    )
                                    (§ catch ArityException ___e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß ArityException'new-2((:actual ___e) - 2, (:name ___e))))
                                    )
                                )
                            )
                            (do
                                (when (§ instance? Symbol ___op)
                                    (let [#_"Symbol" ___sym (cast' Symbol ___op)]
                                        (let [#_"String" ___sname (:name ___sym)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß (:name ___sym).charAt(0) == \.)
                                                (do
                                                    (when (ß RT'length(___form) < 2)
                                                        (throw (IllegalArgumentException. "Malformed member expression, expecting (.member target ...)"))
                                                    )
                                                    (let [#_"Symbol" ___meth (ß Symbol'intern-1(___sname.substring(1)))]
                                                        (let [#_"Object" ___target (RT'second ___form)]
                                                            (when (some? (HostExpr'maybeClass ___target, false))
                                                                (§ ass ___target (ß (cast' IObj (RT'list-2 Compiler'IDENTITY, ___target)).withMeta(RT'map(RT'TAG_KEY, Compiler'CLASS))))
                                                            )
                                                            (§ return (ß Compiler'preserveTag(___form, RT'listStar-4(Compiler'DOT, ___target, ___meth, (next ___form).next()))))
                                                        )
                                                    )
                                                )
                                                (Compiler'namesStaticMember ___sym)
                                                (do
                                                    (let [#_"Symbol" ___target (ß Symbol'intern-1((:ns ___sym)))]
                                                        (let [#_"Class" ___c (HostExpr'maybeClass ___target, false)]
                                                            (when (some? ___c)
                                                                (let [#_"Symbol" ___meth (ß Symbol'intern-1((:name ___sym)))]
                                                                    (§ return (ß Compiler'preserveTag(___form, RT'listStar-4(Compiler'DOT, ___target, ___meth, (next ___form)))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" ___idx (.lastIndexOf ___sname, \.)]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß ___idx == (.length ___sname) - 1)
                                                            (§ return (ß RT'listStar-3(Compiler'NEW, Symbol'intern-1(___sname.substring(0, ___idx)), (next ___form))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        ___x
    )

    (defn #_"Object" Compiler'macroexpand [#_"Object" ___form]
        (let [#_"Object" ___exf (Compiler'macroexpand1 ___form)]
            (when (not= ___exf ___form)
                (§ return (Compiler'macroexpand ___exf))
            )
            ___form
        )
    )

    (defn- #_"Expr" Compiler'analyzeSeq [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"Object" ___line (Compiler'lineDeref)]
            (let [#_"Object" ___column (Compiler'columnDeref)]
                (when (and (some? (RT'meta ___form)) (ß RT'meta(___form).containsKey(RT'LINE_KEY)))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (and (some? (RT'meta ___form)) (ß RT'meta(___form).containsKey(RT'COLUMN_KEY)))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(Compiler'LINE, ___line, Compiler'COLUMN, ___column)))
                (try
                    (let [#_"Object" ___me (Compiler'macroexpand1 ___form)]
                        (when (not= ___me ___form)
                            (§ return (Compiler'analyze-3 ___context, ___me, ___name))
                        )

                        (let [#_"Object" ___op (RT'first ___form)]
                            (when (nil? ___op)
                                (throw (IllegalArgumentException. (str "Can't call nil, form: " ___form)))
                            )
                            (let [#_"IFn" ___inline (ß Compiler'isInline(___op, RT'count(RT'next(___form))))]
                                (when (some? ___inline)
                                    (§ return (ß Compiler'analyze-2(___context, Compiler'preserveTag(___form, ___inline.applyTo(RT'next(___form))))))
                                )
                                (§ let [#_"IParser" ___p]
                                    (cond (.equals ___op, Compiler'FN)
                                        (do
                                            (FnExpr'parse ___context, ___form, ___name)
                                        )
                                        (some? (§ ass ___p (cast' IParser (.valAt Compiler'specials, ___op))))
                                        (do
                                            (.parse ___p, ___context, ___form)
                                        )
                                        :else
                                        (do
                                            (InvokeExpr'parse ___context, ___form)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable ___e
                        (if (not (§ instance? CompilerException ___e))
                            (do
                                (throw (ß CompilerException'new((cast String (.deref Compiler'SOURCE_PATH)), Compiler'lineDeref(), Compiler'columnDeref(), ___e)))
                            )
                            (do
                                (throw (cast' CompilerException ___e))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'errorMsg [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"String" ___s]
        (String/format "%s, compiling:(%s:%d:%d)", (object-array [ ___s, ___source, ___line, ___column ]))
    )

    (defn #_"Object" Compiler'eval-1 [#_"Object" ___form]
        (Compiler'eval-2 ___form, true)
    )

    (defn #_"Object" Compiler'eval-2 [#_"Object" ___form, #_"boolean" ___freshLoader]
        (let [#_"boolean" ___createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var'pushThreadBindings(RT'map(Compiler'LOADER, RT'makeClassLoader())))
                (§ ass ___createdLoader true)
            )
            (try
                (let [#_"Object" ___line (Compiler'lineDeref)]
                    (let [#_"Object" ___column (Compiler'columnDeref)]
                        (when (and (some? (RT'meta ___form)) (.containsKey (RT'meta ___form), RT'LINE_KEY))
                            (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                        )
                        (when (and (some? (RT'meta ___form)) (.containsKey (RT'meta ___form), RT'COLUMN_KEY))
                            (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                        )
                        (ß Var'pushThreadBindings(RT'map(Compiler'LINE, ___line, Compiler'COLUMN, ___column)))
                        (try
                            (§ ass ___form (Compiler'macroexpand ___form))
                            (cond (and (§ instance? ISeq ___form) (Util'equals (RT'first ___form), Compiler'DO))
                                (do
                                    (let [#_"ISeq" ___s (RT'next ___form)]
                                        (loop-when-recur [___s ___s] (some? (RT'next ___s)) [(RT'next ___s)]
                                            (ß Compiler'eval-2(RT'first(___s), false))
                                        )
                                        (ß Compiler'eval-2(RT'first(___s), false))
                                    )
                                )
                                (or (§ instance? IType ___form) (and (§ instance? IPersistentCollection ___form) (not (and (§ instance? Symbol (RT'first ___form)) (.startsWith (:name (cast' Symbol (RT'first ___form))), "def")))))
                                (do
                                    (let [#_"ObjExpr" ___fexpr (cast' ObjExpr (ß Compiler'analyze-3(:Context'EXPRESSION, RT'list-3(Compiler'FN, PersistentVector'EMPTY, ___form), (str "eval" (RT'nextID)))))]
                                        (let [#_"IFn" ___fn (cast' IFn (.eval ___fexpr))]
                                            (.invoke ___fn)
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" ___expr (ß Compiler'analyze-2(:Context'EVAL, ___form))]
                                        (.eval ___expr)
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
                (finally
                    (when ___createdLoader
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'registerConstant [#_"Object" ___o]
        (when (not (.isBound Compiler'CONSTANTS))
            (§ return -1)
        )
        (let [#_"PersistentVector" ___v (cast' PersistentVector (.deref Compiler'CONSTANTS))]
            (let [#_"IdentityHashMap<Object, Integer>" ___ids (ß (IdentityHashMap<Object, Integer>) Compiler'CONSTANT_IDS.deref())]
                (let [#_"Integer" ___i (.get ___ids, ___o)]
                    (when (some? ___i)
                        (§ return ___i)
                    )
                    (ß Compiler'CONSTANTS.set(RT'conj(___v, ___o)))
                    (ß ___ids.put(___o, (count ___v)))
                    (count ___v)
                )
            )
        )
    )

    (defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" ___keyword]
        (when (not (.isBound Compiler'KEYWORDS))
            (§ return (KeywordExpr'new ___keyword))
        )

        (let [#_"IPersistentMap" ___keywordsMap (cast' IPersistentMap (.deref Compiler'KEYWORDS))]
            (let [#_"Object" ___id (RT'get-2 ___keywordsMap, ___keyword)]
                (when (nil? ___id)
                    (ß Compiler'KEYWORDS.set(RT'assoc(___keywordsMap, ___keyword, Compiler'registerConstant(___keyword))))
                )
                (KeywordExpr'new ___keyword)
            )
        )
    )

    (defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" ___keyword]
        (when (not (.isBound Compiler'KEYWORD_CALLSITES))
            (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___keywordCallsites (cast' IPersistentVector (.deref Compiler'KEYWORD_CALLSITES))]
            (§ ass ___keywordCallsites (.cons ___keywordCallsites, ___keyword))
            (.set Compiler'KEYWORD_CALLSITES, ___keywordCallsites)
            (ß (count ___keywordCallsites) - 1)
        )
    )

    (defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" ___v]
        (when (not (.isBound Compiler'PROTOCOL_CALLSITES))
            (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___protocolCallsites (cast' IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES))]
            (§ ass ___protocolCallsites (.cons ___protocolCallsites, ___v))
            (.set Compiler'PROTOCOL_CALLSITES, ___protocolCallsites)
            (ß (count ___protocolCallsites) - 1)
        )
    )

    (defn- #_"void" Compiler'registerVarCallsite [#_"Var" ___v]
        (when (not (.isBound Compiler'VAR_CALLSITES))
            (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
        )

        (let [#_"IPersistentCollection" ___varCallsites (cast' IPersistentCollection (.deref Compiler'VAR_CALLSITES))]
            (§ ass ___varCallsites (.cons ___varCallsites, ___v))
            (.set Compiler'VAR_CALLSITES, ___varCallsites)
            nil
        )
    )

    (defn #_"ISeq" Compiler'fwdPath [#_"PathNode" ___p1]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [___p1 ___p1] (some? ___p1) [(:parent ___p1)]
                (§ ass ___ret (RT'cons ___p1, ___ret))
            )
            ___ret
        )
    )

    (defn #_"PathNode" Compiler'commonPath [#_"PathNode" ___n1, #_"PathNode" ___n2]
        (let [#_"ISeq" ___xp (Compiler'fwdPath ___n1)]
            (let [#_"ISeq" ___yp (Compiler'fwdPath ___n2)]
                (when (ß RT'first(___xp) != RT'first(___yp))
                    (§ return nil)
                )
                (while (and (some? (RT'second ___xp)) (ß (RT'second ___xp) == (RT'second ___yp)))
                    (§ ass ___xp (next ___xp))
                    (§ ass ___yp (next ___yp))
                )
                (cast' PathNode (RT'first ___xp))
            )
        )
    )

    (defn #_"void" Compiler'addAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta]
        (when (and (some? ___meta) (.isBound Compiler'ADD_ANNOTATIONS))
            (.invoke Compiler'ADD_ANNOTATIONS, ___visitor, ___meta)
        )
        nil
    )

    (defn #_"void" Compiler'addParameterAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta, #_"int" ___i]
        (when (and (some? ___meta) (.isBound Compiler'ADD_ANNOTATIONS))
            (.invoke Compiler'ADD_ANNOTATIONS, ___visitor, ___meta, ___i)
        )
        nil
    )

    (defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" ___sym]
        (let [#_"Symbol" ___tag (Compiler'tagOf ___sym)]
            (cond (ß (nil? (:ns ___sym))) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" ___b (Compiler'referenceLocal ___sym)]
                        (when (some? ___b)
                            (§ return (LocalBindingExpr'new ___b, ___tag))
                        )
                    )
                )
                (nil? (ß Compiler'namespaceFor-1(___sym)))
                (do
                    (let [#_"Symbol" ___nsSym (ß Symbol'intern-1((:ns ___sym)))]
                        (let [#_"Class" ___c (HostExpr'maybeClass ___nsSym, false)]
                            (when (some? ___c)
                                (when (some? (Reflector'getField ___c, (:name ___sym), true))
                                    (§ return (ß StaticFieldExpr'new(Compiler'lineDeref(), Compiler'columnDeref(), ___c, (:name ___sym), ___tag)))
                                )
                                (throw (Util'runtimeException-1 (str "Unable to find static field: " (:name ___sym) " in " ___c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" ___o (resolve ___sym)]
                (cond (§ instance? Var ___o)
                    (do
                        (let [#_"Var" ___v (cast' Var ___o)]
                            (when (some? (Compiler'isMacro ___v))
                                (throw (Util'runtimeException-1 (str "Can't take value of a macro: " ___v)))
                            )
                            (when (ß RT'booleanCast-1o(RT'get-2((.meta ___v), RT'CONST_KEY)))
                                (§ return (ß Compiler'analyze-2(:Context'EXPRESSION, RT'list-2(Compiler'QUOTE, (.get ___v)))))
                            )
                            (Compiler'registerVar ___v)
                            (§ return (VarExpr'new ___v, ___tag))
                        )
                    )
                    (instance? Class ___o)
                    (do
                        (§ return (ConstantExpr'new ___o))
                    )
                    (§ instance? Symbol ___o)
                    (do
                        (§ return (UnresolvedVarExpr'new (cast' Symbol ___o)))
                    )
                )

                (throw (Util'runtimeException-1 (str "Unable to resolve symbol: " ___sym " in this context")))
            )
        )
    )

    (defn #_"String" Compiler'destubClassName [#_"String" ___className]
        ;; skip over prefix + '.' or '/'
        (when (.startsWith ___className, Compiler'COMPILE_STUB_PREFIX)
            (§ return (.substring ___className, (inc (.length Compiler'COMPILE_STUB_PREFIX))))
        )
        ___className
    )

    (defn #_"Type" Compiler'getType [#_"Class" ___c]
        (let [#_"String" ___descriptor (ß Type/getType(___c).getDescriptor())]
            (when (.startsWith ___descriptor, "L")
                (§ ass ___descriptor (str "L" (ß Compiler'destubClassName(___descriptor.substring(1)))))
            )
            (§ unsure Type/getType ___descriptor)
        )
    )

    (defn #_"Object" Compiler'resolve-2 [#_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        (ß Compiler'resolveIn((.currentNS this), ___sym, ___allowPrivate))
    )

    (defn #_"Object" Compiler'resolve-1 [#_"Symbol" ___sym]
        (ß Compiler'resolveIn((.currentNS this), ___sym, false))
    )

    (defn #_"Namespace" Compiler'namespaceFor-1 [#_"Symbol" ___sym]
        (ß Compiler'namespaceFor-2((.currentNS this), ___sym))
    )

    (defn #_"Namespace" Compiler'namespaceFor-2 [#_"Namespace" ___inns, #_"Symbol" ___sym]
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" ___nsSym (ß Symbol'intern-1((:ns ___sym)))]
            (let [#_"Namespace" ___ns (.lookupAlias ___inns, ___nsSym)]
                (when (nil? ___ns)
                    ;; ...otherwise check the Namespaces map.
                    (§ ass ___ns (Namespace'find ___nsSym))
                )
                ___ns
            )
        )
    )

    (defn #_"Object" Compiler'resolveIn [#_"Namespace" ___n, #_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond (ß (some? (:ns ___sym)))
            (do
                (let [#_"Namespace" ___ns (Compiler'namespaceFor-2 ___n, ___sym)]
                    (when (nil? ___ns)
                        (throw (Util'runtimeException-1 (str "No such namespace: " (:ns ___sym))))
                    )

                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern-1((:name ___sym))))]
                        (cond (nil? ___v)
                            (do
                                (throw (Util'runtimeException-1 (str "No such var: " ___sym)))
                            )
                            (and (ß (:ns ___v) != (.currentNS this)) (not (.isPublic ___v)) (not ___allowPrivate))
                            (do
                                (throw (IllegalStateException. (str "var: " ___sym " is not public")))
                            )
                        )
                        ___v
                    )
                )
            )
            (or (pos? (.indexOf (:name ___sym), \.)) (ß (:name ___sym).charAt(0) == \[))
            (do
                (ß RT'classForName-1((:name ___sym)))
            )
            (.equals ___sym, Compiler'NS)
            (do
                RT'NS_VAR
            )
            (.equals ___sym, Compiler'IN_NS)
            (do
                RT'IN_NS_VAR
            )
            :else
            (do
                (when (ß Util'equals(___sym, Compiler'COMPILE_STUB_SYM.get()))
                    (§ return (.get Compiler'COMPILE_STUB_CLASS))
                )
                (let [#_"Object" ___o (.getMapping ___n, ___sym)]
                    (when (nil? ___o)
                        (if (ß RT'booleanCast-1o(RT'ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return ___sym)
                            )
                            (do
                                (throw (Util'runtimeException-1 (str "Unable to resolve symbol: " ___sym " in this context")))
                            )
                        )
                    )
                    ___o
                )
            )
        )
    )

    (defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" ___n, #_"Symbol" ___sym]
        ;; note - ns-qualified vars must already exist
        (cond (ß (some? (:ns ___sym)))
            (do
                (let [#_"Namespace" ___ns (Compiler'namespaceFor-2 ___n, ___sym)]
                    (when (nil? ___ns)
                        (§ return nil)
                    )
                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern-1((:name ___sym))))]
                        (when (nil? ___v)
                            (§ return nil)
                        )
                        ___v
                    )
                )
            )
            (or (and (pos? (.indexOf (:name ___sym), \.)) (not (.endsWith (:name ___sym), "."))) (ß (:name ___sym).charAt(0) == \[))
            (do
                (ß RT'classForName-1((:name ___sym)))
            )
            (.equals ___sym, Compiler'NS)
            (do
                RT'NS_VAR
            )
            (.equals ___sym, Compiler'IN_NS)
            (do
                RT'IN_NS_VAR
            )
            :else
            (do
                (let [#_"Object" ___o (.getMapping ___n, ___sym)]
                    ___o
                )
            )
        )
    )

    (defn #_"Var" Compiler'lookupVar-3 [#_"Symbol" ___sym, #_"boolean" ___internNew, #_"boolean" ___registerMacro]
        (let [#_"Var" ___var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß (some? (:ns ___sym)))
                (do
                    (let [#_"Namespace" ___ns (Compiler'namespaceFor-1 ___sym)]
                        (when (nil? ___ns)
                            (§ return nil)
                        )
                        (let [#_"Symbol" ___name (ß Symbol'intern-1((:name ___sym)))]
                            (if (and ___internNew (ß ___ns == (.currentNS this)))
                                (do
                                    (§ ass ___var (.intern (.currentNS this), ___name))
                                )
                                (do
                                    (§ ass ___var (.findInternedVar ___ns, ___name))
                                )
                            )
                        )
                    )
                )
                (.equals ___sym, Compiler'NS)
                (do
                    (§ ass ___var RT'NS_VAR)
                )
                (.equals ___sym, Compiler'IN_NS)
                (do
                    (§ ass ___var RT'IN_NS_VAR)
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" ___o (ß (.currentNS this).getMapping(___sym))]
                        (cond (nil? ___o)
                            (do
                                ;; introduce a new var in the current ns
                                (when ___internNew
                                    (§ ass ___var (.intern (.currentNS this), (Symbol'intern-1 (:name ___sym))))
                                )
                            )
                            (§ instance? Var ___o)
                            (do
                                (§ ass ___var (cast' Var ___o))
                            )
                            :else
                            (do
                                (throw (Util'runtimeException-1 (str "Expecting var, but " ___sym " is mapped to " ___o)))
                            )
                        )
                    )
                )
            )
            (when (and (some? ___var) (or (not (.isMacro ___var)) ___registerMacro))
                (Compiler'registerVar ___var)
            )
            ___var
        )
    )

    (defn #_"Var" Compiler'lookupVar-2 [#_"Symbol" ___sym, #_"boolean" ___internNew]
        (Compiler'lookupVar-3 ___sym, ___internNew, true)
    )

    (defn- #_"void" Compiler'registerVar [#_"Var" ___var]
        (when (not (.isBound Compiler'VARS))
            (§ return nil)
        )
        (let [#_"IPersistentMap" ___varsMap (cast' IPersistentMap (.deref Compiler'VARS))]
            (let [#_"Object" ___id (RT'get-2 ___varsMap, ___var)]
                (when (nil? ___id)
                    (ß Compiler'VARS.set(RT'assoc(___varsMap, ___var, Compiler'registerConstant(___var))))
                )
                nil
            )
        )
    )

    (defn #_"Namespace" Compiler'currentNS []
        (cast' Namespace (.deref RT'CURRENT_NS))
    )

    (defn #_"void" Compiler'closeOver [#_"LocalBinding" ___b, #_"ObjMethod" ___method]
        (when (and (some? ___b) (some? ___method))
            (let [#_"LocalBinding" ___lb (cast' LocalBinding (ß RT'get-2((:locals ___method), ___b)))]
                (if (nil? ___lb)
                    (do
                        (§ ass (:closes (:objx ___method)) (cast' IPersistentMap (ß RT'assoc((:closes (:objx ___method)), ___b, ___b))))
                        (ß Compiler'closeOver(___b, (:parent ___method)))
                    )
                    (do
                        (when (zero? (:idx ___lb))
                            (§ ass (:usesThis ___method) true)
                        )
                        (when (some? (.deref Compiler'IN_CATCH_FINALLY))
                            (§ ass (:localsUsedInCatchFinally ___method) (cast' PersistentHashSet (.cons (:localsUsedInCatchFinally ___method), (:idx ___b))))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" ___sym]
        (when (not (.isBound Compiler'LOCAL_ENV))
            (§ return nil)
        )
        (let [#_"LocalBinding" ___b (cast' LocalBinding (ß RT'get-2(Compiler'LOCAL_ENV.deref(), ___sym)))]
            (when (some? ___b)
                (let [#_"ObjMethod" ___method (cast' ObjMethod (.deref Compiler'METHOD))]
                    (when (zero? (:idx ___b))
                        (§ ass (:usesThis ___method) true)
                    )
                    (Compiler'closeOver ___b, ___method)
                )
            )
            ___b
        )
    )

    (defn- #_"Symbol" Compiler'tagOf [#_"Object" ___o]
        (let [#_"Object" ___tag (ß RT'get-2(RT'meta(___o), RT'TAG_KEY))]
            (cond (§ instance? Symbol ___tag)
                (do
                    (§ return (cast' Symbol ___tag))
                )
                (instance? String ___tag)
                (do
                    (§ return (ß Symbol'intern-2(nil, (cast String ___tag))))
                )
            )
            nil
        )
    )

    (defn #_"Object" Compiler'loadFile [#_"String" ___file] #_(§ throws IOException)
        (let [#_"FileInputStream" ___f (FileInputStream. ___file)]
            (try
                (Compiler'load-3 (InputStreamReader. ___f, RT'UTF8), (.getAbsolutePath (File. ___file)), (.getName (File. ___file)))
                (finally
                    (.close ___f)
                )
            )
        )
    )

    (defn #_"Object" Compiler'load-1 [#_"Reader" ___rdr]
        (Compiler'load-3 ___rdr, nil, "NO_SOURCE_FILE")
    )

    (defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" ___pushbackReader]
        (let [#_"int" ___ch (LispReader'read1 ___pushbackReader)]
            (while (LispReader'isWhitespace ___ch)
                (§ ass ___ch (LispReader'read1 ___pushbackReader))
            )
            (LispReader'unread ___pushbackReader, ___ch)
            nil
        )
    )

    (§ def- #_"Object" Compiler'OPTS_COND_ALLOWED (RT'mapUniqueKeys LispReader'OPT_READ_COND, LispReader'COND_ALLOW))

    (defn- #_"Object" Compiler'readerOpts [#_"String" ___sourceName]
        (if (and (some? ___sourceName) (.endsWith ___sourceName, ".clic"))
            (do
                Compiler'OPTS_COND_ALLOWED
            )
            (do
                nil
            )
        )
    )

    (defn #_"Object" Compiler'load-3 [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName]
        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (if (§ instance? LineNumberingPushbackReader ___rdr) (cast' LineNumberingPushbackReader ___rdr) (LineNumberingPushbackReader'new-1 ___rdr))]
                    (Compiler'consumeWhitespaces ___pushbackReader)
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (object-array [
                            Compiler'LOADER         (RT'makeClassLoader)
                            Compiler'SOURCE_PATH    ___sourcePath
                            Compiler'SOURCE         ___sourceName
                            Compiler'METHOD         nil
                            Compiler'LOCAL_ENV      nil
                            Compiler'LOOP_LOCALS    nil
                            Compiler'NEXT_LOCAL_NUM 0
                            RT'READEVAL             RT'T
                            RT'CURRENT_NS           (.deref RT'CURRENT_NS)
                            Compiler'LINE_BEFORE    (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_BEFORE  (.getColumnNumber ___pushbackReader)
                            Compiler'LINE_AFTER     (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_AFTER   (.getColumnNumber ___pushbackReader)
                            RT'UNCHECKED_MATH       (.deref RT'UNCHECKED_MATH)
                            RT'WARN_ON_REFLECTION   (.deref RT'WARN_ON_REFLECTION)
                            RT'DATA_READERS         (.deref RT'DATA_READERS)
                        ])
                    )))

                    (let [#_"Object" ___readerOpts (Compiler'readerOpts ___sourceName)]
                        (try
                            (loop-when-recur [#_"Object" ___r (LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)] (not= ___r ___EOF) [(LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)]
                                (Compiler'consumeWhitespaces ___pushbackReader)
                                (.set Compiler'LINE_AFTER, (.getLineNumber ___pushbackReader))
                                (.set Compiler'COLUMN_AFTER, (.getColumnNumber ___pushbackReader))
                                (§ ass ___ret (Compiler'eval-2 ___r, false))
                                (.set Compiler'LINE_BEFORE, (.getLineNumber ___pushbackReader))
                                (.set Compiler'COLUMN_BEFORE, (.getColumnNumber ___pushbackReader))
                            )
                            (§ catch LispReaderException ___e
                                (throw (ß CompilerException'new(___sourcePath, (:line ___e), (:column ___e), (.getCause ___e))))
                            )
                            (catch Throwable ___e
                                (if (not (§ instance? CompilerException ___e))
                                    (do
                                        (throw (ß CompilerException'new(___sourcePath, (cast Integer (.deref Compiler'LINE_BEFORE)), (cast Integer (.deref Compiler'COLUMN_BEFORE)), ___e)))
                                    )
                                    (do
                                        (throw (cast' CompilerException ___e))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                        ___ret
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'writeClassFile [#_"String" ___internalName, #_"byte[]" ___bytecode] #_(§ throws IOException)
        (let [#_"String" ___genPath (cast String (.deref Compiler'COMPILE_PATH))]
            (when (nil? ___genPath)
                (throw (Util'runtimeException-1 "*compile-path* not set"))
            )
            (let [#_"String[]" ___dirs (.split ___internalName, "/")]
                (let [#_"String" ___p ___genPath]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength ___dirs) - 1) [(inc ___i)]
                        (§ ass ___p (ß ___p + File/separator + ___dirs[___i]))
                        (.mkdir (File. ___p))
                    )
                    (let [#_"String" ___path (str ___genPath File/separator ___internalName ".class")]
                        (let [#_"File" ___cf (§ unsure File. ___path)]
                            (.createNewFile ___cf)
                            (let [#_"FileOutputStream" ___cfs (§ unsure FileOutputStream. ___cf)]
                                (try
                                    (.write ___cfs, ___bytecode)
                                    (.flush ___cfs)
                                    (finally
                                        (.close ___cfs)
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'pushNS []
        (ß Var'pushThreadBindings(PersistentHashMap'create-1a(
            (object-array [
                Var'intern-2s(Symbol'intern-1("cloiure.core"), Symbol'intern-1("*ns*")).setDynamic() nil
            ])
        )))
        nil
    )

    (defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" ___loader]
        (ß Var'pushThreadBindings(RT'map(
            (object-array [
                Var'intern-2s(Symbol'intern-1("cloiure.core"), Symbol'intern-1("*ns*")).setDynamic() nil
                RT'FN_LOADER_VAR                                                                    ___loader
                RT'READEVAL                                                                         RT'T
            ])
        )))
        nil
    )

    (defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" ___target, #_"Keyword" ___k]
        nil
    )

    (defn #_"void" Compiler'compile1 [#_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"Object" ___form]
        (let [#_"Object" ___line (Compiler'lineDeref)]
            (let [#_"Object" ___column (Compiler'columnDeref)]
                (when (and (some? (RT'meta ___form)) (.containsKey (RT'meta ___form), RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (and (some? (RT'meta ___form)) (.containsKey (RT'meta ___form), RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(
                    (object-array [
                        Compiler'LINE   ___line
                        Compiler'COLUMN ___column
                        Compiler'LOADER (RT'makeClassLoader)
                    ])
                )))
                (try
                    (§ ass ___form (Compiler'macroexpand ___form))
                    (if (and (§ instance? ISeq ___form) (Util'equals (RT'first ___form), Compiler'DO))
                        (do
                            (loop-when-recur [#_"ISeq" ___s (RT'next ___form)] (some? ___s) [(RT'next ___s)]
                                (ß Compiler'compile1(___gen, ___objx, RT'first(___s)))
                            )
                        )
                        (do
                            (let [#_"Expr" ___expr (ß Compiler'analyze-2(:Context'EVAL, ___form))]
                                (§ ass (:keywords ___objx) (cast' IPersistentMap (.deref Compiler'KEYWORDS)))
                                (§ ass (:vars ___objx) (cast' IPersistentMap (.deref Compiler'VARS)))
                                (§ ass (:constants ___objx) (cast' PersistentVector (.deref Compiler'CONSTANTS)))
                                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (.eval ___expr)
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
                nil
            )
        )
    )

    (defn #_"Object" Compiler'compile [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName] #_(§ throws IOException)
        (when (nil? (.deref Compiler'COMPILE_PATH))
            (throw (Util'runtimeException-1 "*compile-path* not set"))
        )

        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (if (§ instance? LineNumberingPushbackReader ___rdr) (cast' LineNumberingPushbackReader ___rdr) (LineNumberingPushbackReader'new-1 ___rdr))]
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (object-array [
                            Compiler'SOURCE_PATH    ___sourcePath
                            Compiler'SOURCE         ___sourceName
                            Compiler'METHOD         nil
                            Compiler'LOCAL_ENV      nil
                            Compiler'LOOP_LOCALS    nil
                            Compiler'NEXT_LOCAL_NUM 0
                            RT'READEVAL             RT'T
                            RT'CURRENT_NS           (.deref RT'CURRENT_NS)
                            Compiler'LINE_BEFORE    (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_BEFORE  (.getColumnNumber ___pushbackReader)
                            Compiler'LINE_AFTER     (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_AFTER   (.getColumnNumber ___pushbackReader)
                            Compiler'CONSTANTS      PersistentVector'EMPTY
                            Compiler'CONSTANT_IDS   (IdentityHashMap.)
                            Compiler'KEYWORDS       PersistentHashMap'EMPTY
                            Compiler'VARS           PersistentHashMap'EMPTY
                            RT'UNCHECKED_MATH       (.deref RT'UNCHECKED_MATH)
                            RT'WARN_ON_REFLECTION   (.deref RT'WARN_ON_REFLECTION)
                            RT'DATA_READERS         (.deref RT'DATA_READERS)
                        ])
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" ___objx (ObjExpr'new nil)]
                            (§ ass (:internalName ___objx) (str (ß ___sourcePath.replace(File/separator, "/").substring(0, ___sourcePath.lastIndexOf(\.))) RT'LOADER_SUFFIX))

                            (§ ass (:objtype ___objx) (Type/getObjectType (:internalName ___objx)))
                            (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
                                (let [#_"ClassVisitor" ___cv ___cw]
                                    (ß ___cv.visit(Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER), (:internalName ___objx), nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void load ()"), nil, nil, ___cv)]
                                        (.visitCode ___gen)

                                        (let [#_"Object" ___readerOpts (Compiler'readerOpts ___sourceName)]
                                            (loop-when-recur [#_"Object" ___r (LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)] (not= ___r ___EOF) [(LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)]
                                                (.set Compiler'LINE_AFTER, (.getLineNumber ___pushbackReader))
                                                (.set Compiler'COLUMN_AFTER, (.getColumnNumber ___pushbackReader))
                                                (Compiler'compile1 ___gen, ___objx, ___r)
                                                (.set Compiler'LINE_BEFORE, (.getLineNumber ___pushbackReader))
                                                (.set Compiler'COLUMN_BEFORE, (.getColumnNumber ___pushbackReader))
                                            )
                                            ;; end of load
                                            (.returnValue ___gen)
                                            (.endMethod ___gen)

                                            ;; static fields for constants
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants ___objx).count()) [(inc ___i)]
                                                (when (.contains (:usedConstants ___objx), ___i)
                                                    (ß ___cv.visitField((+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL Opcodes/ACC_STATIC), ___objx.constantName(___i), ___objx.constantType(___i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [#_"int" ___INITS_PER 100]
                                                (let [#_"int" ___numInits (ß (:constants ___objx).count() / ___INITS_PER)]
                                                    (when (ß (:constants ___objx).count() % ___INITS_PER != 0)
                                                        (§ ass ___numInits (inc ___numInits))
                                                    )

                                                    (loop-when-recur [#_"int" ___n 0] (< ___n ___numInits) [(inc ___n)]
                                                        (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod (str "void __init" ___n"()")), nil, nil, ___cv)]
                                                            (.visitCode ___clinitgen)
                                                            (try
                                                                (ß Var'pushThreadBindings(RT'map(RT'PRINT_DUP, RT'T)))

                                                                (loop-when-recur [#_"int" ___i (* ___n ___INITS_PER)] (and (ß ___i < (:constants ___objx).count()) (ß ___i < (___n + 1) * ___INITS_PER)) [(inc ___i)]
                                                                    (when (.contains (:usedConstants ___objx), ___i)
                                                                        (ß ___objx.emitValue((:constants ___objx).nth(___i), ___clinitgen))
                                                                        (ß ___clinitgen.checkCast(___objx.constantType(___i)))
                                                                        (ß ___clinitgen.putStatic((:objtype ___objx), ___objx.constantName(___i), ___objx.constantType(___i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (Var'popThreadBindings)
                                                                )
                                                            )
                                                            (.returnValue ___clinitgen)
                                                            (.endMethod ___clinitgen)
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, ___cv)]
                                                        (.visitCode ___clinitgen)
                                                        (let [#_"Label" ___startTry (.newLabel ___clinitgen)]
                                                            (let [#_"Label" ___endTry (.newLabel ___clinitgen)]
                                                                (let [#_"Label" ___end (.newLabel ___clinitgen)]
                                                                    (let [#_"Label" ___finallyLabel (.newLabel ___clinitgen)]
                                                                        (loop-when-recur [#_"int" ___n 0] (< ___n ___numInits) [(inc ___n)]
                                                                            (.invokeStatic ___clinitgen, (:objtype ___objx), (Method/getMethod (str "void __init" ___n "()")))
                                                                        )

                                                                        (ß ___clinitgen.push((:internalName ___objx).replace(\/, \.)))
                                                                        (ß ___clinitgen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("Class classForName(String)")))
                                                                        (ß ___clinitgen.invokeVirtual(Compiler'CLASS_TYPE, Method/getMethod("ClassLoader getClassLoader()")))
                                                                        (ß ___clinitgen.invokeStatic(Type/getType((§ class Compiler)), Method/getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (.mark ___clinitgen, ___startTry)
                                                                        (ß ___clinitgen.invokeStatic((:objtype ___objx), Method/getMethod("void load()")))
                                                                        (.mark ___clinitgen, ___endTry)
                                                                        (ß ___clinitgen.invokeStatic(Compiler'VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (.goTo ___clinitgen, ___end)

                                                                        (.mark ___clinitgen, ___finallyLabel)
                                                                        ;; exception should be on stack
                                                                        (ß ___clinitgen.invokeStatic(Compiler'VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (.throwException ___clinitgen)
                                                                        (.mark ___clinitgen, ___end)
                                                                        (.visitTryCatchBlock ___clinitgen, ___startTry, ___endTry, ___finallyLabel, nil)

                                                                        ;; end of static init
                                                                        (.returnValue ___clinitgen)
                                                                        (.endMethod ___clinitgen)

                                                                        ;; end of class
                                                                        (.visitEnd ___cv)

                                                                        (ß Compiler'writeClassFile((:internalName ___objx), (.toByteArray ___cw)))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (§ catch LispReaderException ___e
                            (throw (ß CompilerException'new(___sourcePath, (:line ___e), (:column ___e), (.getCause ___e))))
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                    ___ret
                )
            )
        )
    )

    (defn #_"boolean" Compiler'inty [#_"Class" ___c]
        (or (ß ___c == Integer/TYPE) (ß ___c == Short/TYPE) (ß ___c == Byte/TYPE) (ß ___c == Character/TYPE))
    )

    (defn #_"Class" Compiler'retType [#_"Class" ___tc, #_"Class" ___ret]
        (when (nil? ___tc)
            (§ return ___ret)
        )
        (when (nil? ___ret)
            (§ return ___tc)
        )
        (when (and (.isPrimitive ___ret) (.isPrimitive ___tc))
            (when (or (and (Compiler'inty ___ret) (Compiler'inty ___tc)) (ß ___ret == ___tc))
                (§ return ___tc)
            )
            (throw (UnsupportedOperationException. (str "Cannot coerce " ___ret " to " ___tc ", use a cast instead")))
        )
        ___tc
    )

    (defn #_"Class" Compiler'primClass-1s [#_"Symbol" ___sym]
        (when (nil? ___sym)
            (§ return nil)
        )
        (let [#_"Class" ___c nil]
            (cond (.equals (:name ___sym), "int")
                (do
                    (§ ass ___c Integer/TYPE)
                )
                (.equals (:name ___sym), "long")
                (do
                    (§ ass ___c Long/TYPE)
                )
                (.equals (:name ___sym), "float")
                (do
                    (§ ass ___c Float/TYPE)
                )
                (.equals (:name ___sym), "double")
                (do
                    (§ ass ___c Double/TYPE)
                )
                (.equals (:name ___sym), "char")
                (do
                    (§ ass ___c Character/TYPE)
                )
                (.equals (:name ___sym), "short")
                (do
                    (§ ass ___c Short/TYPE)
                )
                (.equals (:name ___sym), "byte")
                (do
                    (§ ass ___c Byte/TYPE)
                )
                (.equals (:name ___sym), "boolean")
                (do
                    (§ ass ___c Boolean/TYPE)
                )
                (.equals (:name ___sym), "void")
                (do
                    (§ ass ___c Void/TYPE)
                )
            )
            ___c
        )
    )

    (defn #_"Class" Compiler'tagClass [#_"Object" ___tag]
        (when (nil? ___tag)
            (§ return Object)
        )
        (let [#_"Class" ___c nil]
            (when (§ instance? Symbol ___tag)
                (§ ass ___c (ß Compiler'primClass-1s((cast' Symbol ___tag))))
            )
            (when (nil? ___c)
                (§ ass ___c (HostExpr'tagToClass ___tag))
            )
            ___c
        )
    )

    (defn #_"Class" Compiler'primClass-1c [#_"Class" ___c]
        (if (.isPrimitive ___c) ___c Object)
    )

    (defn #_"Class" Compiler'boxClass [#_"Class" ___p]
        (when (not (.isPrimitive ___p))
            (§ return ___p)
        )

        (let [#_"Class" ___c nil]
            (cond (= ___p Integer/TYPE)
                (do
                    (§ ass ___c Integer)
                )
                (= ___p Long/TYPE)
                (do
                    (§ ass ___c Long)
                )
                (= ___p Float/TYPE)
                (do
                    (§ ass ___c Float)
                )
                (= ___p Double/TYPE)
                (do
                    (§ ass ___c Double)
                )
                (= ___p Character/TYPE)
                (do
                    (§ ass ___c Character)
                )
                (= ___p Short/TYPE)
                (do
                    (§ ass ___c Short)
                )
                (= ___p Byte/TYPE)
                (do
                    (§ ass ___c Byte)
                )
                (= ___p Boolean/TYPE)
                (do
                    (§ ass ___c Boolean)
                )
            )

            ___c
        )
    )

    (defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        PersistentHashSet'EMPTY
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (defn- #_"Cons" Cons'init []
        (hash-map
            #_"Object" :_first nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"Cons" Cons'new-2 [#_"Object" ___first, #_"ISeq" ____more]
        (let [this (merge (ASeq'new) (Cons'init))]
            (§ ass (:_first this) ___first)
            (§ ass (:_more this) ____more)
            this
        )
    )

    (defn #_"Cons" Cons'new-3 [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"ISeq" ____more]
        (let [this (merge (ASeq'new ___meta) (Cons'init))]
            (§ ass (:_first this) ____first)
            (§ ass (:_more this) ____more)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Cons" this]
        (:_first this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Cons" this]
        (.seq (.more this))
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"Cons" this]
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"Cons" this]
        (ß 1 + RT'count((:_more this)))
    )

    #_method
    (§ defn #_"Cons" (§ method withMeta) [#_"Cons" this, #_"IPersistentMap" ___meta]
        (Cons'new-3 ___meta, (:_first this), (:_more this))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ defprotocol Counted
    #_abstract
    (#_"int" Counted'''(§ method count) [#_"Counted" this])
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (defn- #_"Cycle" Cycle'init []
        (hash-map
            #_"ISeq" :all nil ;; never nil
            #_"ISeq" :prev nil
            #_volatile
            #_"ISeq" :_current nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Cycle" Cycle'new-3 [#_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current]
        (let [this (merge (ASeq'new) (Cycle'init))]
            (§ ass (:all this) ___all)
            (§ ass (:prev this) ___prev)
            (§ ass (:_current this) ___current)
            this
        )
    )

    (defn- #_"Cycle" Cycle'new-5 [#_"IPersistentMap" ___meta, #_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current, #_"ISeq" ___next]
        (let [this (merge (ASeq'new ___meta) (Cycle'init))]
            (§ ass (:all this) ___all)
            (§ ass (:prev this) ___prev)
            (§ ass (:_current this) ___current)
            (§ ass (:_next this) ___next)
            this
        )
    )

    (defn #_"ISeq" Cycle'create [#_"ISeq" ___vals]
        (when (nil? ___vals)
            (§ return PersistentList'EMPTY)
        )
        (Cycle'new-3 ___vals, nil, ___vals)
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" (§ method current) [#_"Cycle" this]
        (when (nil? (:_current this))
            (let [#_"ISeq" ___current (next (:prev this))]
                (§ ass (:_current this) (or ___current (:all this)))
            )
        )
        (:_current this)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Cycle" this]
        (some? (:_current this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Cycle" this]
        (first (.current this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Cycle" this]
        (when (nil? (:_next this))
            (§ ass (:_next this) (ß Cycle'new-3((:all this), (.current this), nil)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Cycle" (§ method withMeta) [#_"Cycle" this, #_"IPersistentMap" ___meta]
        (Cycle'new-5 ___meta, (:all this), (:prev this), (:_current this), (:_next this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Cycle" this, #_"IFn" ___f]
        (let [#_"ISeq" ___s (.current this)]
            (let [#_"Object" ___ret (first ___s)]
                (while true
                    (§ ass ___s (next ___s))
                    (when (nil? ___s)
                        (§ ass ___s (:all this))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
                    (when (RT'isReduced ___ret)
                        (§ return (.deref (cast' IDeref ___ret)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Cycle" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"ISeq" ___s (.current this)]
                (while true
                    (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
                    (when (RT'isReduced ___ret)
                        (§ return (.deref (cast' IDeref ___ret)))
                    )
                    (§ ass ___s (next ___s))
                    (when (nil? ___s)
                        (§ ass ___s (:all this))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (defn- #_"Delay" Delay'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Throwable" :exception nil
            #_volatile
            #_"IFn" :fn nil
        )
    )

    (defn #_"Delay" Delay'new [#_"IFn" ___fn]
        (let [this (Delay'init)]
            (§ ass (:fn this) ___fn)
            (§ ass (:val this) nil)
            (§ ass (:exception this) nil)
            this
        )
    )

    (defn #_"Object" Delay'force [#_"Object" ___x]
        (if (§ instance? Delay ___x) (.deref (cast' Delay ___x)) ___x)
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Delay" this]
        (when (some? (:fn this))
            (§ sync this
                ;; double check
                (when (some? (:fn this))
                    (try
                        (§ ass (:val this) (.invoke (:fn this)))
                        (catch Throwable ___t
                            (§ ass (:exception this) ___t)
                        )
                    )
                    (§ ass (:fn this) nil)
                )
            )
        )
        (when (some? (:exception this))
            (throw (Util'sneakyThrow (:exception this)))
        )
        (:val this)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Delay" this]
        (§ sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ConcurrentHashMap.))

    (def #_"URL[]" DynamicClassLoader'EMPTY_URLS (make-array URL 0))

    (def #_"ReferenceQueue" DynamicClassLoader'RQ (ReferenceQueue.))

    (defn- #_"DynamicClassLoader" DynamicClassLoader'init []
        (hash-map
            #_"HashMap<Integer, Object[]>" :constantVals (HashMap.)
        )
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new-0 []
        ;; pseudo test in lieu of hasContextClassLoader()
        (merge (URLClassLoader'new DynamicClassLoader'EMPTY_URLS, (if (or (nil? (ß Thread/currentThread().getContextClassLoader())) (ß Thread/currentThread().getContextClassLoader() == ClassLoader/getSystemClassLoader())) (.getClassLoader (§ class Compiler)) (ß Thread/currentThread().getContextClassLoader()))) (DynamicClassLoader'init))
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new-1 [#_"ClassLoader" ___parent]
        (merge (URLClassLoader'new DynamicClassLoader'EMPTY_URLS, ___parent) (DynamicClassLoader'init))
    )

    #_method
    (§ defn #_"Class" (§ method defineClass) [#_"DynamicClassLoader" this, #_"String" ___name, #_"byte[]" ___bytes, #_"Object" ___srcForm]
        (Util'clearCache DynamicClassLoader'RQ, DynamicClassLoader'classCache)
        (let [#_"Class" ___c (ß this.defineClass(___name, ___bytes, 0, (§ alength ___bytes)))]
            (ß DynamicClassLoader'classCache.put(___name, (SoftReference. ___c, DynamicClassLoader'RQ)))
            ___c
        )
    )

    (defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" ___name]
        (let [#_"Reference<Class>" ___cr (.get DynamicClassLoader'classCache, ___name)]
            (when (some? ___cr)
                (let [#_"Class" ___c (.get ___cr)]
                    (if (some? ___c)
                        (do
                            (§ return ___c)
                        )
                        (do
                            (.remove DynamicClassLoader'classCache, ___name, ___cr)
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" (§ method findClass) [#_"DynamicClassLoader" this, #_"String" ___name] #_(§ throws ClassNotFoundException)
        (let [#_"Class" ___c (DynamicClassLoader'findInMemoryClass ___name)]
            (if (some? ___c)
                (do
                    ___c
                )
                (do
                    (.findClass super, ___name)
                )
            )
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" (§ method loadClass) [#_"DynamicClassLoader" this, #_"String" ___name, #_"boolean" ___resolve] #_(§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" ___c (findLoadedClass ___name)]
                (when (nil? ___c)
                    (§ ass ___c (DynamicClassLoader'findInMemoryClass ___name))
                    (when (nil? ___c)
                        (§ ass ___c (.loadClass super, ___name, false))
                    )
                )
                (when ___resolve
                    (.resolveClass this, ___c)
                )
                ___c
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method registerConstants) [#_"DynamicClassLoader" this, #_"int" ___id, #_"Object[]" ___val]
        (.put (:constantVals this), ___id, ___val)
        nil
    )

    #_method
    (§ defn #_"Object[]" (§ method getConstants) [#_"DynamicClassLoader" this, #_"int" ___id]
        (.get (:constantVals this), ___id)
    )

    #_method
    (§ defn #_"void" (§ method addURL) [#_"DynamicClassLoader" this, #_"URL" ___url]
        (.addURL super, ___url)
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReaderException (§ extends RuntimeException)
    (defn- #_"EdnReaderException" EdnReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"EdnReaderException" EdnReaderException'new [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new ___cause) (EdnReaderException'init))]
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )
)

#_closure
(class-ns EdnStringReader (§ extends AFn)
    (defn #_"EdnStringReader" EdnStringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (cast Reader ___reader)]
                (loop-when-recur [#_"int" ___ch (EdnReader'read1 ___r)] (ß ___ch != \") [(EdnReader'read1 ___r)] ;; oops! "
                    (when (= ___ch -1)
                        (throw (Util'runtimeException-1 "EOF while reading string"))
                    )
                    (when (= ___ch \\) ;; escape
                        (§ ass ___ch (EdnReader'read1 ___r))
                        (when (= ___ch -1)
                            (throw (Util'runtimeException-1 "EOF while reading string"))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch \tab)
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch \return)
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch \newline)
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch \backspace)
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch \formfeed)
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (EdnReader'read1 ___r))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (Util'runtimeException-1 (str "Invalid unicode escape: \\u" (ß (char) ___ch))))
                                )
                                (§ ass ___ch (ß readUnicodeChar((cast PushbackReader ___r), ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (Character/isDigit ___ch)
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((cast PushbackReader ___r), ___ch, 8, 3, false)))
                                        (when (> ___ch 0377)
                                            (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (Util'runtimeException-1 (str "Unsupported escape character: \\" (ß (char) ___ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (.toString ___sb)
            )
        )
    )
)

#_closure
(class-ns EdnCommentReader (§ extends AFn)
    (defn #_"EdnCommentReader" EdnCommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts]
        (let [#_"Reader" ___r (cast Reader ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (EdnReader'read1 ___r))
                    (§ recur-if (and (ß ___ch != -1) (ß ___ch != \newline) (ß ___ch != \return)))
                )
                ___r
            )
        )
    )
)

#_closure
(class-ns EdnDiscardReader (§ extends AFn)
    (defn #_"EdnDiscardReader" EdnDiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (EdnReader'read-5 ___r, true, nil, true, ___opts)
            ___r
        )
    )
)

#_closure
(class-ns EdnNamespaceMapReader (§ extends AFn)
    (defn #_"EdnNamespaceMapReader" EdnNamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            ;; Read ns symbol
            (let [#_"Object" ___sym (EdnReader'read-5 ___r, true, nil, false, ___opts)]
                (when (or (not (§ instance? Symbol ___sym)) (some? (.getNamespace (cast' Symbol ___sym))))
                    (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " ___sym)))
                )
                (let [#_"String" ___ns (.getName (cast' Symbol ___sym))]
                    ;; Read map
                    (let [#_"int" ___nextChar (EdnReader'read1 ___r)]
                        (while (EdnReader'isWhitespace ___nextChar)
                            (§ ass ___nextChar (EdnReader'read1 ___r))
                        )
                        (when (ß \{ != ___nextChar)
                            (throw (RuntimeException. "Namespaced map must specify a map"))
                        )
                        (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts))]
                            (when (ß ((.size ___kvs) & 1) == 1)
                                (throw (Util'runtimeException-1 "Namespaced map literal must contain an even number of forms"))
                            )

                            ;; Construct output map
                            (let [#_"Object[]" ___a (make-array Object (.size ___kvs))]
                                (let [#_"Iterator" ___iter (.iterator ___kvs)]
                                    (loop-when-recur [#_"int" ___i 0] (.hasNext ___iter) [(+ ___i 2)]
                                        (let [#_"Object" ___key (next ___iter)]
                                            (let [#_"Object" ___val (next ___iter)]
                                                (cond (§ instance? Keyword ___key)
                                                    (do
                                                        (let [#_"Keyword" ___kw (cast' Keyword ___key)]
                                                            (cond (nil? (.getNamespace ___kw))
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern-2(___ns, (.getName ___kw))))
                                                                )
                                                                (ß (.getNamespace ___kw).equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern-2(nil, (.getName ___kw))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (§ instance? Symbol ___key)
                                                    (do
                                                        (let [#_"Symbol" ___s (cast' Symbol ___key)]
                                                            (cond (nil? (.getNamespace ___s))
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern-2(___ns, (.getName ___s))))
                                                                )
                                                                (ß (.getNamespace ___s).equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern-2(nil, (.getName ___s))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (§ ass (§ aget ___a ___i) ___key)
                                                (§ ass (§ aget ___a (ß ___i + 1)) ___val)
                                            )
                                        )
                                    )
                                    (RT'map ___a)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnDispatchReader (§ extends AFn)
    (defn #_"EdnDispatchReader" EdnDispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts]
        (let [#_"int" ___ch (EdnReader'read1 (cast Reader ___reader))]
            (when (= ___ch -1)
                (throw (Util'runtimeException-1 "EOF while reading character"))
            )
            (let [#_"IFn" ___fn (§ aget dispatchMacros ___ch)]
                (when (nil? ___fn)
                    ;; try tagged reader
                    (when (Character/isLetter ___ch)
                        (EdnReader'unread (cast PushbackReader ___reader), ___ch)
                        (§ return (.invoke taggedReader, ___reader, ___ch, ___opts))
                    )

                    (throw (ß Util'runtimeException-1(String/format("No dispatch macro for: %c", (object-array [ (ß (char) ___ch) ])))))
                )
                (.invoke ___fn, ___reader, ___ch, ___opts)
            )
        )
    )
)

#_closure
(class-ns EdnMetaReader (§ extends AFn)
    (defn #_"EdnMetaReader" EdnMetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (§ instance? LineNumberingPushbackReader ___r)
                        (§ ass ___line (.getLineNumber (cast' LineNumberingPushbackReader ___r)))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (let [#_"Object" ___meta (EdnReader'read-5 ___r, true, nil, true, ___opts)]
                        (cond (or (§ instance? Symbol ___meta) (instance? String ___meta))
                            (do
                                (§ ass ___meta (RT'map RT'TAG_KEY, ___meta))
                            )
                            (§ instance? Keyword ___meta)
                            (do
                                (§ ass ___meta (RT'map ___meta, RT'T))
                            )
                            (not (§ instance? IPersistentMap ___meta))
                            (do
                                (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                            )
                        )

                        (let [#_"Object" ___o (EdnReader'read-5 ___r, true, nil, true, ___opts)]
                            (if (§ instance? IMeta ___o)
                                (do
                                    (when (and (ß ___line != -1) (§ instance? ISeq ___o))
                                        (§ ass ___meta (ß (cast' IPersistentMap ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (§ instance? IReference ___o)
                                        (.resetMeta (cast' IReference ___o), (cast' IPersistentMap ___meta))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (RT'meta ___o)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'seq ___meta)] (some? ___s) [(next ___s)]
                                            (let [#_"IMapEntry" ___kv (cast' IMapEntry (first ___s))]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, (.getKey ___kv), (.getValue ___kv))))
                                            )
                                        )
                                        (.withMeta (cast' IObj ___o), (cast' IPersistentMap ___ometa))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnCharacterReader (§ extends AFn)
    (defn #_"EdnCharacterReader" EdnCharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___ch (EdnReader'read1 ___r)]
                (when (= ___ch -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch, false))]
                    (cond (ß (.length ___token) == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (.equals ___token, "newline")
                        (do
                            (§ return \newline)
                        )
                        (.equals ___token, "space")
                        (do
                            (§ return \space)
                        )
                        (.equals ___token, "tab")
                        (do
                            (§ return \tab)
                        )
                        (.equals ___token, "backspace")
                        (do
                            (§ return \backspace)
                        )
                        (.equals ___token, "formfeed")
                        (do
                            (§ return \formfeed)
                        )
                        (.equals ___token, "return")
                        (do
                            (§ return \return)
                        )
                        (.startsWith ___token, "u")
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (and (ß ___c >= (§ char "\ud800")) (ß ___c <= (§ char "\udfff"))) ;; surrogate code unit?
                                    (throw (Util'runtimeException-1 (str "Invalid character constant: \\u" (Integer/toString ___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (.startsWith ___token, "o")
                        (do
                            (let [#_"int" ___len (ß (.length ___token) - 1)]
                                (when (> ___len 3)
                                    (throw (Util'runtimeException-1 (str "Invalid octal escape sequence length: " ___len)))
                                )
                                (let [#_"int" ___uc (readUnicodeChar ___token, 1, ___len, 8)]
                                    (when (> ___uc 0377)
                                        (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (Util'runtimeException-1 (str "Unsupported character: \\" ___token)))
                )
            )
        )
    )
)

#_closure
(class-ns EdnListReader (§ extends AFn)
    (defn #_"EdnListReader" EdnListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (§ instance? LineNumberingPushbackReader ___r)
                        (§ ass ___line (.getLineNumber (cast' LineNumberingPushbackReader ___r)))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts))]
                        (when (.isEmpty ___list)
                            (§ return PersistentList'EMPTY)
                        )
                        (let [#_"IObj" ___s (cast' IObj (PersistentList'create ___list))]
                            ___s
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnVectorReader (§ extends AFn)
    (defn #_"EdnVectorReader" EdnVectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts)))
        )
    )
)

#_closure
(class-ns EdnMapReader (§ extends AFn)
    (defn #_"EdnMapReader" EdnMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts).toArray())]
                (when (ß ((§ alength ___a) & 1) == 1)
                    (throw (Util'runtimeException-1 "Map literal must contain an even number of forms"))
                )
                (RT'map ___a)
            )
        )
    )
)

#_closure
(class-ns EdnSetReader (§ extends AFn)
    (defn #_"EdnSetReader" EdnSetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (ß PersistentHashSet'createWithCheck-1l(readDelimitedList(\}, ___r, true, ___opts)))
        )
    )
)

#_closure
(class-ns EdnUnmatchedDelimiterReader (§ extends AFn)
    (defn #_"EdnUnmatchedDelimiterReader" EdnUnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts]
        (throw (Util'runtimeException-1 (str "Unmatched delimiter: " ___rightdelim)))
    )
)

#_closure
(class-ns EdnUnreadableReader (§ extends AFn)
    (defn #_"EdnUnreadableReader" EdnUnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts]
        (throw (Util'runtimeException-1 "Unreadable form"))
    )
)

#_closure
(class-ns EdnSymbolicValueReader (§ extends AFn)
    (defn #_"EdnSymbolicValueReader" EdnSymbolicValueReader'new []
        (AFn'new)
    )

    (def #_"IPersistentMap" EdnSymbolicValueReader'specials (ß PersistentHashMap'create-1a(
        (object-array [
            (Symbol'intern-1 "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern-1 "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern-1 "NaN")  Double/NaN
        ])
    )))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___o (EdnReader'read-5 ___r, true, nil, true, ___opts)]
                (when (not (§ instance? Symbol ___o))
                    (throw (Util'runtimeException-1 (str "Invalid token: ##" ___o)))
                )
                (when (not (.containsKey EdnSymbolicValueReader'specials, ___o))
                    (throw (Util'runtimeException-1 (str "Unknown symbolic value: ##" ___o)))
                )

                (.valAt EdnSymbolicValueReader'specials, ___o)
            )
        )
    )
)

#_closure
(class-ns TaggedReader (§ extends AFn)
    (defn #_"TaggedReader" TaggedReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"TaggedReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___name (EdnReader'read-5 ___r, true, nil, false, ___opts)]
                (when (not (§ instance? Symbol ___name))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (cast' Symbol ___name)]
                    (ß this.readTagged(___r, ___sym, (cast' IPersistentMap ___opts)))
                )
            )
        )
    )

    (§ def #_"Keyword" TaggedReader'READERS (Keyword'intern-2 nil, "readers"))
    (§ def #_"Keyword" TaggedReader'DEFAULT (Keyword'intern-2 nil, "default"))

    #_method
    (§ defn- #_"Object" (§ method readTagged) [#_"TaggedReader" this, #_"PushbackReader" ___reader, #_"Symbol" ___tag, #_"IPersistentMap" ___opts]
        (let [#_"Object" ___o (EdnReader'read-5 ___reader, true, nil, true, ___opts)]
            (let [#_"ILookup" ___readers (cast' ILookup (RT'get-2 ___opts, TaggedReader'READERS))]
                (let [#_"IFn" ___dataReader (cast' IFn (RT'get-2 ___readers, ___tag))]
                    (when (nil? ___dataReader)
                        (§ ass ___dataReader (cast' IFn (ß RT'get-2(RT'DEFAULT_DATA_READERS.deref(), ___tag))))
                    )
                    (if (nil? ___dataReader)
                        (do
                            (let [#_"IFn" ___defaultReader (cast' IFn (RT'get-2 ___opts, TaggedReader'DEFAULT))]
                                (if (some? ___defaultReader)
                                    (do
                                        (.invoke ___defaultReader, ___tag, ___o)
                                    )
                                    (do
                                        (throw (RuntimeException. (str "No reader function for tag " (.toString ___tag))))
                                    )
                                )
                            )
                        )
                        (do
                            (.invoke ___dataReader, ___o)
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnReader
    (def #_"IFn[]" EdnReader'macros (§ typeless make-array IFn 256))
    (def #_"IFn[]" EdnReader'dispatchMacros (§ typeless make-array IFn 256))
    (def #_"Pattern" EdnReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" EdnReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" EdnReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" EdnReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    (§ def #_"IFn" EdnReader'taggedReader (TaggedReader'new))

    (§ static
        (§ ass (ß macros[\"]) (EdnStringReader'new)) ;; oops! "
        (§ ass (ß macros[\;]) (EdnCommentReader'new))
        (§ ass (ß macros[\^]) (EdnMetaReader'new))
        (§ ass (ß macros[\(]) (EdnListReader'new))
        (§ ass (ß macros[\)]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\[]) (EdnVectorReader'new))
        (§ ass (ß macros[\]]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\{]) (EdnMapReader'new))
        (§ ass (ß macros[\}]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\\]) (EdnCharacterReader'new))
        (§ ass (ß macros[\#]) (EdnDispatchReader'new))

        (§ ass (ß dispatchMacros[\#]) (EdnSymbolicValueReader'new))
        (§ ass (ß dispatchMacros[\^]) (EdnMetaReader'new))
        (§ ass (ß dispatchMacros[\{]) (EdnSetReader'new))
        (§ ass (ß dispatchMacros[\<]) (EdnUnreadableReader'new))
        (§ ass (ß dispatchMacros[\_]) (EdnDiscardReader'new))
        (§ ass (ß dispatchMacros[\:]) (EdnNamespaceMapReader'new))
    )

    (defn #_"boolean" EdnReader'nonConstituent [#_"int" ___ch]
        (or (ß ___ch == \@) (ß ___ch == \`) (ß ___ch == \~))
    )

    (defn #_"Object" EdnReader'readString [#_"String" ___s, #_"IPersistentMap" ___opts]
        (let [#_"PushbackReader" ___r (PushbackReader. (java.io.StringReader. ___s))]
            (EdnReader'read-2 ___r, ___opts)
        )
    )

    (defn #_"boolean" EdnReader'isWhitespace [#_"int" ___ch]
        (or (Character/isWhitespace ___ch) (ß ___ch == \,))
    )

    (defn #_"void" EdnReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (not= ___ch -1)
            (try
                (.unread ___r, ___ch)
                (catch IOException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
        )
        nil
    )

    (defn #_"int" EdnReader'read1 [#_"Reader" ___r]
        (try
            (.read ___r)
            (catch IOException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (§ def #_"Keyword" EdnReader'EOF (Keyword'intern-2 nil, "eof"))

    (defn #_"Object" EdnReader'read-2 [#_"PushbackReader" ___r, #_"IPersistentMap" ___opts]
        (EdnReader'read-5 ___r, (not (.containsKey ___opts, EdnReader'EOF)), (.valAt ___opts, EdnReader'EOF), false, ___opts)
    )

    (defn #_"Object" EdnReader'read-5 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (try
            (while true
                (let [#_"int" ___ch (EdnReader'read1 ___r)]
                    (while (EdnReader'isWhitespace ___ch)
                        (§ ass ___ch (EdnReader'read1 ___r))
                    )

                    (when (= ___ch -1)
                        (when ___eofIsError
                            (throw (Util'runtimeException-1 "EOF while reading"))
                        )
                        (§ return ___eofValue)
                    )

                    (when (Character/isDigit ___ch)
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (when (RT'suppressRead)
                                (§ return nil)
                            )
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (EdnReader'getMacro ___ch)]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                (when (RT'suppressRead)
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (= ___ret ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (or (ß ___ch == \+) (ß ___ch == \-))
                            (let [#_"int" ___ch2 (EdnReader'read1 ___r)]
                                (when (Character/isDigit ___ch2)
                                    (EdnReader'unread ___r, ___ch2)
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (when (RT'suppressRead)
                                            (§ return nil)
                                        )
                                        (§ return ___n)
                                    )
                                )
                                (EdnReader'unread ___r, ___ch2)
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch, true))]
                            (when (RT'suppressRead)
                                (§ return nil)
                            )
                            (§ return (interpretToken ___token))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (or ___isRecursive (not (§ instance? LineNumberingPushbackReader ___r)))
                    (throw (Util'sneakyThrow ___e))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (cast' LineNumberingPushbackReader ___r)]
                    (throw (ß EdnReaderException'new((.getLineNumber ___rdr), (.getColumnNumber ___rdr), ___e)))
                )
            )
        )
    )

    (defn- #_"String" EdnReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch, #_"boolean" ___leadConstituent]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (when (and ___leadConstituent (EdnReader'nonConstituent ___initch))
                (throw (Util'runtimeException-1 (str "Invalid leading character: " (ß (char)___initch))))
            )

            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (EdnReader'read1 ___r)]
                    (cond (or (ß ___ch == -1) (EdnReader'isWhitespace ___ch) (EdnReader'isTerminatingMacro ___ch))
                        (do
                            (EdnReader'unread ___r, ___ch)
                            (§ return (.toString ___sb))
                        )
                        (EdnReader'nonConstituent ___ch)
                        (do
                            (throw (Util'runtimeException-1 (str "Invalid constituent character: " (ß (char)___ch))))
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (defn- #_"Object" EdnReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (EdnReader'read1 ___r)]
                    (when (or (ß ___ch == -1) (EdnReader'isWhitespace ___ch) (EdnReader'isMacro ___ch))
                        (EdnReader'unread ___r, ___ch)
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (.toString ___sb)]
                (let [#_"Object" ___n (EdnReader'matchNumber ___s)]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (str "Invalid number: " ___s)))
                    )
                    ___n
                )
            )
        )
    )

    (defn- #_"int" EdnReader'readUnicodeChar-4 [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß (.length ___token) != ___offset + ___length)
            (throw (IllegalArgumentException. (str "Invalid unicode character: \\" ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [#_"int" ___i ___offset] (ß ___i < ___offset + ___length) [(inc ___i)]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (= ___d -1)
                        (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt ___token, ___i))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (defn- #_"int" EdnReader'readUnicodeChar-5 [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (Character/digit ___initch, ___base)]
            (when (= ___uc -1)
                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___initch))))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [___i ___i] (< ___i ___length) [(inc ___i)]
                    (let [#_"int" ___ch (EdnReader'read1 ___r)]
                        (when (or (ß ___ch == -1) (EdnReader'isWhitespace ___ch) (EdnReader'isMacro ___ch))
                            (EdnReader'unread ___r, ___ch)
                            (§ break )
                        )
                        (let [#_"int" ___d (Character/digit ___ch, ___base)]
                            (when (= ___d -1)
                                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___ch))))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (and (ß ___i != ___length) ___exact)
                    (throw (IllegalArgumentException. (str "Invalid character length: " ___i ", should be: " ___length)))
                )
                ___uc
            )
        )
    )

    (defn- #_"Object" EdnReader'interpretToken [#_"String" ___s]
        (cond (.equals ___s, "nil")
            (do
                (§ return nil)
            )
            (.equals ___s, "true")
            (do
                (§ return RT'T)
            )
            (.equals ___s, "false")
            (do
                (§ return RT'F)
            )
        )

        (let [#_"Object" ___ret nil]
            (§ ass ___ret (matchSymbol ___s))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (Util'runtimeException-1 (str "Invalid token: " ___s)))
        )
    )

    (defn- #_"Object" EdnReader'matchSymbol [#_"String" ___s]
        (let [#_"Matcher" ___m (.matcher EdnReader'symbolPat, ___s)]
            (when (.matches ___m)
                (let [#_"int" ___gc (.groupCount ___m)]
                    (let [#_"String" ___ns (.group ___m, 1)]
                        (let [#_"String" ___name (.group ___m, 2)]
                            (when (or (and (some? ___ns) (.endsWith ___ns, ":/")) (.endsWith ___name, ":") (ß (.indexOf ___s, "::", 1) != -1))
                                (§ return nil)
                            )
                            (when (.startsWith ___s, "::")
                                (§ return nil)
                            )
                            (let [#_"boolean" ___isKeyword (ß ___s.charAt(0) == \:)]
                                (let [#_"Symbol" ___sym (Symbol'intern-1 (.substring ___s, (if ___isKeyword 1 0)))]
                                    (when ___isKeyword
                                        (§ return (Keyword'intern ___sym))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"Object" EdnReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (.matcher EdnReader'intPat, ___s)]
            (when (.matches ___m)
                (when (some? (.group ___m, 2))
                    (when (some? (.group ___m, 8))
                        (§ return BigInt'ZERO)
                    )
                    (§ return (Numbers'num-1l 0))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (.group ___m, 3)))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (.group ___m, 4)))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (.group ___m, 5)))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (.group ___m, 7)))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (BigInteger. ___n, ___radix)]
                                (when ___negate
                                    (§ ass ___bn (.negate ___bn))
                                )
                                (when (some? (.group ___m, 8))
                                    (§ return (BigInt'fromBigInteger ___bn))
                                )
                                (§ return (if (< (.bitLength ___bn) 64) (Numbers'num-1l (.longValue ___bn)) (BigInt'fromBigInteger ___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (.matcher EdnReader'floatPat, ___s))
            (when (.matches ___m)
                (when (some? (.group ___m, 4))
                    (§ return (§ unsure BigDecimal. (.group ___m, 1)))
                )
                (§ return (Double/parseDouble ___s))
            )
            (§ ass ___m (.matcher EdnReader'ratioPat, ___s))
            (when (.matches ___m)
                (let [#_"String" ___numerator (.group ___m, 1)]
                    (when (.startsWith ___numerator, "+")
                        (§ ass ___numerator (.substring ___numerator, 1))
                    )

                    (§ return (Numbers'divide-2oo (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. ___numerator))), (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. (.group ___m, 2))))))
                )
            )
            nil
        )
    )

    (defn- #_"IFn" EdnReader'getMacro [#_"int" ___ch]
        (when (< ___ch (§ alength macros))
            (§ return (§ aget macros ___ch))
        )
        nil
    )

    (defn- #_"boolean" EdnReader'isMacro [#_"int" ___ch]
        (and (< ___ch (§ alength macros)) (some? (§ aget macros ___ch)))
    )

    (defn- #_"boolean" EdnReader'isTerminatingMacro [#_"int" ___ch]
        (and (ß ___ch != \#) (ß ___ch != \') (EdnReader'isMacro ___ch))
    )

    (defn #_"List" EdnReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (let [#_"int" ___firstline (if (§ instance? LineNumberingPushbackReader ___r) (.getLineNumber (cast' LineNumberingPushbackReader ___r)) -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (while true
                    (let [#_"int" ___ch (EdnReader'read1 ___r)]
                        (while (EdnReader'isWhitespace ___ch)
                            (§ ass ___ch (EdnReader'read1 ___r))
                        )

                        (when (= ___ch -1)
                            (if (< ___firstline 0)
                                (do
                                    (throw (Util'runtimeException-1 "EOF while reading"))
                                )
                                (do
                                    (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                )
                            )
                        )

                        (when (= ___ch ___delim)
                            (§ break )
                        )

                        (let [#_"IFn" ___macroFn (EdnReader'getMacro ___ch)]
                            (if (some? ___macroFn)
                                (do
                                    (let [#_"Object" ___mret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                        ;; no op macros return the reader
                                        (when (not= ___mret ___r)
                                            (.add ___a, ___mret)
                                        )
                                    )
                                )
                                (do
                                    (EdnReader'unread ___r, ___ch)

                                    (let [#_"Object" ___o (EdnReader'read-5 ___r, true, nil, ___isRecursive, ___opts)]
                                        (when (not= ___o ___r)
                                            (.add ___a, ___o)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                ___a
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeqState
    (defn- #_"EnumerationSeqState" EnumerationSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"EnumerationSeqState" EnumerationSeqState'new []
        (EnumerationSeqState'init)
    )
)

(class-ns EnumerationSeq (§ extends ASeq)
    (defn #_"EnumerationSeq" EnumerationSeq'create [#_"Enumeration" ___iter]
        (when (.hasMoreElements ___iter)
            (§ return (EnumerationSeq'new-1 ___iter))
        )
        nil
    )

    (defn- #_"EnumerationSeq" EnumerationSeq'init []
        (hash-map
            #_"Enumeration" :iter nil
            #_"EnumerationSeqState" :state nil
        )
    )

    (defn #_"EnumerationSeq" EnumerationSeq'new-1 [#_"Enumeration" ___iter]
        (let [this (merge (ASeq'new) (EnumerationSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) (EnumerationSeqState'new))
            (§ ass (:val (:state this)) (:state this))
            (§ ass (:_rest (:state this)) (:state this))
            this
        )
    )

    (defn #_"EnumerationSeq" EnumerationSeq'new-3 [#_"IPersistentMap" ___meta, #_"Enumeration" ___iter, #_"EnumerationSeqState" ___state]
        (let [this (merge (ASeq'new ___meta) (EnumerationSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"EnumerationSeq" this]
        (when (ß (:val (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:val (:state this)) == (:state this))
                    (§ ass (:val (:state this)) (.nextElement (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"EnumerationSeq" this]
        (when (ß (:_rest (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:_rest (:state this)) == (:state this))
                    (first this)
                    (§ ass (:_rest (:state this)) (EnumerationSeq'create (:iter this)))
                )
            )
        )
        (cast' ISeq (:_rest (:state this)))
    )

    #_method
    (§ defn #_"EnumerationSeq" (§ method withMeta) [#_"EnumerationSeq" this, #_"IPersistentMap" ___meta]
        (EnumerationSeq'new-3 ___meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (defn- #_"ExceptionInfo" ExceptionInfo'init []
        (hash-map
            #_"IPersistentMap" :data nil
        )
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-2 [#_"String" ___s, #_"IPersistentMap" ___data]
        (ExceptionInfo'new-3 ___s, ___data, nil)
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-3 [#_"String" ___s, #_"IPersistentMap" ___data, #_"Throwable" ___throwable]
        (let [this (merge (§ foreign RuntimeException'new ___s, ___throwable) (ExceptionInfo'init))]
            ;; nil cause is equivalent to not passing a cause
            (if (some? ___data)
                (do
                    (§ ass (:data this) ___data)
                )
                (do
                    (throw (IllegalArgumentException. "Additional data must be non-nil."))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getData) [#_"ExceptionInfo" this]
        (:data this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ExceptionInfo" this]
        (str "cloiure.lang.ExceptionInfo: " (.getMessage this) " " (.toString (:data this)))
    )
)
)

(java-ns cloiure.lang.Fn

(§ defprotocol Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (defn- #_"FnLoaderThunk" FnLoaderThunk'init []
        (hash-map
            #_"Var" :v nil
            #_"ClassLoader" :loader nil
            #_"String" :fnClassName nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"FnLoaderThunk" FnLoaderThunk'new [#_"Var" ___v, #_"String" ___fnClassName]
        (let [this (merge (RestFn'new) (FnLoaderThunk'init))]
            (§ ass (:v this) ___v)
            (§ ass (:loader this) (cast ClassLoader (.get RT'FN_LOADER_VAR)))
            (§ ass (:fnClassName this) ___fnClassName)
            (§ ass (:fn this) nil)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" ___arg1]
        (.load this)
        (.invoke (:fn this), ___arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (.load this)
        (.invoke (:fn this), ___arg1, ___arg2)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (.load this)
        (.invoke (:fn this), ___arg1, ___arg2, ___arg3)
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"FnLoaderThunk" this, #_"Object" ___args]
        (.load this)
        (.applyTo (:fn this), (cast' ISeq ___args))
    )

    #_method
    (§ defn- #_"void" (§ method load) [#_"FnLoaderThunk" this]
        (when (nil? (:fn this))
            (try
                (§ ass (:fn this) (cast' IFn (ß Class/forName((:fnClassName this), true, (:loader this)).newInstance())))
                (catch Exception ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
            (§ ass (:root (:v this)) (:fn this))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getRequiredArity) [#_"FnLoaderThunk" this]
        0
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"FnLoaderThunk" this, #_"IPersistentMap" ___meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ defprotocol IAtom
    #_abstract
    (#_"Object" IAtom'''(§ method swap-2) [#_"IAtom" this, #_"IFn" ___f])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-3) [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-4) [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-5) [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"boolean" IAtom'''(§ method compareAndSet) [#_"IAtom" this, #_"Object" ___oldv, #_"Object" ___newv])
    #_abstract
    (#_"Object" IAtom'''(§ method reset) [#_"IAtom" this, #_"Object" ___newval])
)
)

(java-ns cloiure.lang.IAtom2

(§ defprotocol IAtom2 #_(§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-2) [#_"IAtom2" this, #_"IFn" ___f])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-3) [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-4) [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-5) [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method resetVals) [#_"IAtom2" this, #_"Object" ___newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ defprotocol IBlockingDeref
    #_abstract
    (#_"Object" IBlockingDeref'''(§ method deref) [#_"IBlockingDeref" this, #_"long" ___ms, #_"Object" ___timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(§ defprotocol IChunk #_(§ extends Indexed)
    #_abstract
    (#_"IChunk" IChunk'''(§ method dropFirst) [#_"IChunk" this])
    #_abstract
    (#_"Object" IChunk'''(§ method reduce) [#_"IChunk" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ defprotocol IChunkedSeq #_(§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" IChunkedSeq'''(§ method chunkedFirst) [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''(§ method chunkedNext) [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''(§ method chunkedMore) [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(§ defprotocol IDeref
    #_abstract
    (#_"Object" IDeref'''(§ method deref) [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(§ defprotocol IEditableCollection
    #_abstract
    (#_"ITransientCollection" IEditableCollection'''(§ method asTransient) [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ defprotocol IExceptionInfo
    #_abstract
    (#_"IPersistentMap" IExceptionInfo'''(§ method getData) [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

(§ defprotocol L
    #_abstract
    (#_"long" L'''(§ method invokePrim) [#_"L" this])
)

(§ defprotocol D
    #_abstract
    (#_"double" D'''(§ method invokePrim) [#_"D" this])
)

(§ defprotocol OL
    #_abstract
    (#_"long" OL'''(§ method invokePrim) [#_"OL" this, #_"Object" ___arg0])
)

(§ defprotocol OD
    #_abstract
    (#_"double" OD'''(§ method invokePrim) [#_"OD" this, #_"Object" ___arg0])
)

(§ defprotocol LO
    #_abstract
    (#_"Object" LO'''(§ method invokePrim) [#_"LO" this, #_"long" ___arg0])
)

(§ defprotocol LL
    #_abstract
    (#_"long" LL'''(§ method invokePrim) [#_"LL" this, #_"long" ___arg0])
)

(§ defprotocol LD
    #_abstract
    (#_"double" LD'''(§ method invokePrim) [#_"LD" this, #_"long" ___arg0])
)

(§ defprotocol DO
    #_abstract
    (#_"Object" DO'''(§ method invokePrim) [#_"DO" this, #_"double" ___arg0])
)

(§ defprotocol DL
    #_abstract
    (#_"long" DL'''(§ method invokePrim) [#_"DL" this, #_"double" ___arg0])
)

(§ defprotocol DD
    #_abstract
    (#_"double" DD'''(§ method invokePrim) [#_"DD" this, #_"double" ___arg0])
)

(§ defprotocol OOL
    #_abstract
    (#_"long" OOL'''(§ method invokePrim) [#_"OOL" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol OOD
    #_abstract
    (#_"double" OOD'''(§ method invokePrim) [#_"OOD" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol OLO
    #_abstract
    (#_"Object" OLO'''(§ method invokePrim) [#_"OLO" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(§ defprotocol OLL
    #_abstract
    (#_"long" OLL'''(§ method invokePrim) [#_"OLL" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(§ defprotocol OLD
    #_abstract
    (#_"double" OLD'''(§ method invokePrim) [#_"OLD" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(§ defprotocol ODO
    #_abstract
    (#_"Object" ODO'''(§ method invokePrim) [#_"ODO" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(§ defprotocol ODL
    #_abstract
    (#_"long" ODL'''(§ method invokePrim) [#_"ODL" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(§ defprotocol ODD
    #_abstract
    (#_"double" ODD'''(§ method invokePrim) [#_"ODD" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(§ defprotocol LOO
    #_abstract
    (#_"Object" LOO'''(§ method invokePrim) [#_"LOO" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol LOL
    #_abstract
    (#_"long" LOL'''(§ method invokePrim) [#_"LOL" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol LOD
    #_abstract
    (#_"double" LOD'''(§ method invokePrim) [#_"LOD" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol LLO
    #_abstract
    (#_"Object" LLO'''(§ method invokePrim) [#_"LLO" this, #_"long" ___arg0, #_"long" ___arg1])
)

(§ defprotocol LLL
    #_abstract
    (#_"long" LLL'''(§ method invokePrim) [#_"LLL" this, #_"long" ___arg0, #_"long" ___arg1])
)

(§ defprotocol LLD
    #_abstract
    (#_"double" LLD'''(§ method invokePrim) [#_"LLD" this, #_"long" ___arg0, #_"long" ___arg1])
)

(§ defprotocol LDO
    #_abstract
    (#_"Object" LDO'''(§ method invokePrim) [#_"LDO" this, #_"long" ___arg0, #_"double" ___arg1])
)

(§ defprotocol LDL
    #_abstract
    (#_"long" LDL'''(§ method invokePrim) [#_"LDL" this, #_"long" ___arg0, #_"double" ___arg1])
)

(§ defprotocol LDD
    #_abstract
    (#_"double" LDD'''(§ method invokePrim) [#_"LDD" this, #_"long" ___arg0, #_"double" ___arg1])
)

(§ defprotocol DOO
    #_abstract
    (#_"Object" DOO'''(§ method invokePrim) [#_"DOO" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol DOL
    #_abstract
    (#_"long" DOL'''(§ method invokePrim) [#_"DOL" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol DOD
    #_abstract
    (#_"double" DOD'''(§ method invokePrim) [#_"DOD" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol DLO
    #_abstract
    (#_"Object" DLO'''(§ method invokePrim) [#_"DLO" this, #_"double" ___arg0, #_"long" ___arg1])
)

(§ defprotocol DLL
    #_abstract
    (#_"long" DLL'''(§ method invokePrim) [#_"DLL" this, #_"double" ___arg0, #_"long" ___arg1])
)

(§ defprotocol DLD
    #_abstract
    (#_"double" DLD'''(§ method invokePrim) [#_"DLD" this, #_"double" ___arg0, #_"long" ___arg1])
)

(§ defprotocol DDO
    #_abstract
    (#_"Object" DDO'''(§ method invokePrim) [#_"DDO" this, #_"double" ___arg0, #_"double" ___arg1])
)

(§ defprotocol DDL
    #_abstract
    (#_"long" DDL'''(§ method invokePrim) [#_"DDL" this, #_"double" ___arg0, #_"double" ___arg1])
)

(§ defprotocol DDD
    #_abstract
    (#_"double" DDD'''(§ method invokePrim) [#_"DDD" this, #_"double" ___arg0, #_"double" ___arg1])
)

(§ defprotocol OOOL
    #_abstract
    (#_"long" OOOL'''(§ method invokePrim) [#_"OOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OOOD
    #_abstract
    (#_"double" OOOD'''(§ method invokePrim) [#_"OOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OOLO
    #_abstract
    (#_"Object" OOLO'''(§ method invokePrim) [#_"OOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OOLL
    #_abstract
    (#_"long" OOLL'''(§ method invokePrim) [#_"OOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OOLD
    #_abstract
    (#_"double" OOLD'''(§ method invokePrim) [#_"OOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OODO
    #_abstract
    (#_"Object" OODO'''(§ method invokePrim) [#_"OODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OODL
    #_abstract
    (#_"long" OODL'''(§ method invokePrim) [#_"OODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OODD
    #_abstract
    (#_"double" OODD'''(§ method invokePrim) [#_"OODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OLOO
    #_abstract
    (#_"Object" OLOO'''(§ method invokePrim) [#_"OLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OLOL
    #_abstract
    (#_"long" OLOL'''(§ method invokePrim) [#_"OLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OLOD
    #_abstract
    (#_"double" OLOD'''(§ method invokePrim) [#_"OLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OLLO
    #_abstract
    (#_"Object" OLLO'''(§ method invokePrim) [#_"OLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OLLL
    #_abstract
    (#_"long" OLLL'''(§ method invokePrim) [#_"OLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OLLD
    #_abstract
    (#_"double" OLLD'''(§ method invokePrim) [#_"OLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OLDO
    #_abstract
    (#_"Object" OLDO'''(§ method invokePrim) [#_"OLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OLDL
    #_abstract
    (#_"long" OLDL'''(§ method invokePrim) [#_"OLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OLDD
    #_abstract
    (#_"double" OLDD'''(§ method invokePrim) [#_"OLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol ODOO
    #_abstract
    (#_"Object" ODOO'''(§ method invokePrim) [#_"ODOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol ODOL
    #_abstract
    (#_"long" ODOL'''(§ method invokePrim) [#_"ODOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol ODOD
    #_abstract
    (#_"double" ODOD'''(§ method invokePrim) [#_"ODOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol ODLO
    #_abstract
    (#_"Object" ODLO'''(§ method invokePrim) [#_"ODLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol ODLL
    #_abstract
    (#_"long" ODLL'''(§ method invokePrim) [#_"ODLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol ODLD
    #_abstract
    (#_"double" ODLD'''(§ method invokePrim) [#_"ODLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol ODDO
    #_abstract
    (#_"Object" ODDO'''(§ method invokePrim) [#_"ODDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol ODDL
    #_abstract
    (#_"long" ODDL'''(§ method invokePrim) [#_"ODDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol ODDD
    #_abstract
    (#_"double" ODDD'''(§ method invokePrim) [#_"ODDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LOOO
    #_abstract
    (#_"Object" LOOO'''(§ method invokePrim) [#_"LOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LOOL
    #_abstract
    (#_"long" LOOL'''(§ method invokePrim) [#_"LOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LOOD
    #_abstract
    (#_"double" LOOD'''(§ method invokePrim) [#_"LOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LOLO
    #_abstract
    (#_"Object" LOLO'''(§ method invokePrim) [#_"LOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LOLL
    #_abstract
    (#_"long" LOLL'''(§ method invokePrim) [#_"LOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LOLD
    #_abstract
    (#_"double" LOLD'''(§ method invokePrim) [#_"LOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LODO
    #_abstract
    (#_"Object" LODO'''(§ method invokePrim) [#_"LODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LODL
    #_abstract
    (#_"long" LODL'''(§ method invokePrim) [#_"LODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LODD
    #_abstract
    (#_"double" LODD'''(§ method invokePrim) [#_"LODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LLOO
    #_abstract
    (#_"Object" LLOO'''(§ method invokePrim) [#_"LLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LLOL
    #_abstract
    (#_"long" LLOL'''(§ method invokePrim) [#_"LLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LLOD
    #_abstract
    (#_"double" LLOD'''(§ method invokePrim) [#_"LLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LLLO
    #_abstract
    (#_"Object" LLLO'''(§ method invokePrim) [#_"LLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LLLL
    #_abstract
    (#_"long" LLLL'''(§ method invokePrim) [#_"LLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LLLD
    #_abstract
    (#_"double" LLLD'''(§ method invokePrim) [#_"LLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LLDO
    #_abstract
    (#_"Object" LLDO'''(§ method invokePrim) [#_"LLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LLDL
    #_abstract
    (#_"long" LLDL'''(§ method invokePrim) [#_"LLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LLDD
    #_abstract
    (#_"double" LLDD'''(§ method invokePrim) [#_"LLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LDOO
    #_abstract
    (#_"Object" LDOO'''(§ method invokePrim) [#_"LDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LDOL
    #_abstract
    (#_"long" LDOL'''(§ method invokePrim) [#_"LDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LDOD
    #_abstract
    (#_"double" LDOD'''(§ method invokePrim) [#_"LDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LDLO
    #_abstract
    (#_"Object" LDLO'''(§ method invokePrim) [#_"LDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LDLL
    #_abstract
    (#_"long" LDLL'''(§ method invokePrim) [#_"LDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LDLD
    #_abstract
    (#_"double" LDLD'''(§ method invokePrim) [#_"LDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LDDO
    #_abstract
    (#_"Object" LDDO'''(§ method invokePrim) [#_"LDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LDDL
    #_abstract
    (#_"long" LDDL'''(§ method invokePrim) [#_"LDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LDDD
    #_abstract
    (#_"double" LDDD'''(§ method invokePrim) [#_"LDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DOOO
    #_abstract
    (#_"Object" DOOO'''(§ method invokePrim) [#_"DOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DOOL
    #_abstract
    (#_"long" DOOL'''(§ method invokePrim) [#_"DOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DOOD
    #_abstract
    (#_"double" DOOD'''(§ method invokePrim) [#_"DOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DOLO
    #_abstract
    (#_"Object" DOLO'''(§ method invokePrim) [#_"DOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DOLL
    #_abstract
    (#_"long" DOLL'''(§ method invokePrim) [#_"DOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DOLD
    #_abstract
    (#_"double" DOLD'''(§ method invokePrim) [#_"DOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DODO
    #_abstract
    (#_"Object" DODO'''(§ method invokePrim) [#_"DODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DODL
    #_abstract
    (#_"long" DODL'''(§ method invokePrim) [#_"DODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DODD
    #_abstract
    (#_"double" DODD'''(§ method invokePrim) [#_"DODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DLOO
    #_abstract
    (#_"Object" DLOO'''(§ method invokePrim) [#_"DLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DLOL
    #_abstract
    (#_"long" DLOL'''(§ method invokePrim) [#_"DLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DLOD
    #_abstract
    (#_"double" DLOD'''(§ method invokePrim) [#_"DLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DLLO
    #_abstract
    (#_"Object" DLLO'''(§ method invokePrim) [#_"DLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DLLL
    #_abstract
    (#_"long" DLLL'''(§ method invokePrim) [#_"DLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DLLD
    #_abstract
    (#_"double" DLLD'''(§ method invokePrim) [#_"DLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DLDO
    #_abstract
    (#_"Object" DLDO'''(§ method invokePrim) [#_"DLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DLDL
    #_abstract
    (#_"long" DLDL'''(§ method invokePrim) [#_"DLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DLDD
    #_abstract
    (#_"double" DLDD'''(§ method invokePrim) [#_"DLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DDOO
    #_abstract
    (#_"Object" DDOO'''(§ method invokePrim) [#_"DDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DDOL
    #_abstract
    (#_"long" DDOL'''(§ method invokePrim) [#_"DDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DDOD
    #_abstract
    (#_"double" DDOD'''(§ method invokePrim) [#_"DDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DDLO
    #_abstract
    (#_"Object" DDLO'''(§ method invokePrim) [#_"DDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DDLL
    #_abstract
    (#_"long" DDLL'''(§ method invokePrim) [#_"DDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DDLD
    #_abstract
    (#_"double" DDLD'''(§ method invokePrim) [#_"DDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DDDO
    #_abstract
    (#_"Object" DDDO'''(§ method invokePrim) [#_"DDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DDDL
    #_abstract
    (#_"long" DDDL'''(§ method invokePrim) [#_"DDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DDDD
    #_abstract
    (#_"double" DDDD'''(§ method invokePrim) [#_"DDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OOOOL
    #_abstract
    (#_"long" OOOOL'''(§ method invokePrim) [#_"OOOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOOOD
    #_abstract
    (#_"double" OOOOD'''(§ method invokePrim) [#_"OOOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOOLO
    #_abstract
    (#_"Object" OOOLO'''(§ method invokePrim) [#_"OOOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOOLL
    #_abstract
    (#_"long" OOOLL'''(§ method invokePrim) [#_"OOOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOOLD
    #_abstract
    (#_"double" OOOLD'''(§ method invokePrim) [#_"OOOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOODO
    #_abstract
    (#_"Object" OOODO'''(§ method invokePrim) [#_"OOODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOODL
    #_abstract
    (#_"long" OOODL'''(§ method invokePrim) [#_"OOODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOODD
    #_abstract
    (#_"double" OOODD'''(§ method invokePrim) [#_"OOODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOLOO
    #_abstract
    (#_"Object" OOLOO'''(§ method invokePrim) [#_"OOLOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOLOL
    #_abstract
    (#_"long" OOLOL'''(§ method invokePrim) [#_"OOLOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOLOD
    #_abstract
    (#_"double" OOLOD'''(§ method invokePrim) [#_"OOLOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOLLO
    #_abstract
    (#_"Object" OOLLO'''(§ method invokePrim) [#_"OOLLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOLLL
    #_abstract
    (#_"long" OOLLL'''(§ method invokePrim) [#_"OOLLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOLLD
    #_abstract
    (#_"double" OOLLD'''(§ method invokePrim) [#_"OOLLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOLDO
    #_abstract
    (#_"Object" OOLDO'''(§ method invokePrim) [#_"OOLDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOLDL
    #_abstract
    (#_"long" OOLDL'''(§ method invokePrim) [#_"OOLDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOLDD
    #_abstract
    (#_"double" OOLDD'''(§ method invokePrim) [#_"OOLDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OODOO
    #_abstract
    (#_"Object" OODOO'''(§ method invokePrim) [#_"OODOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OODOL
    #_abstract
    (#_"long" OODOL'''(§ method invokePrim) [#_"OODOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OODOD
    #_abstract
    (#_"double" OODOD'''(§ method invokePrim) [#_"OODOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OODLO
    #_abstract
    (#_"Object" OODLO'''(§ method invokePrim) [#_"OODLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OODLL
    #_abstract
    (#_"long" OODLL'''(§ method invokePrim) [#_"OODLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OODLD
    #_abstract
    (#_"double" OODLD'''(§ method invokePrim) [#_"OODLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OODDO
    #_abstract
    (#_"Object" OODDO'''(§ method invokePrim) [#_"OODDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OODDL
    #_abstract
    (#_"long" OODDL'''(§ method invokePrim) [#_"OODDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OODDD
    #_abstract
    (#_"double" OODDD'''(§ method invokePrim) [#_"OODDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLOOO
    #_abstract
    (#_"Object" OLOOO'''(§ method invokePrim) [#_"OLOOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLOOL
    #_abstract
    (#_"long" OLOOL'''(§ method invokePrim) [#_"OLOOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLOOD
    #_abstract
    (#_"double" OLOOD'''(§ method invokePrim) [#_"OLOOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLOLO
    #_abstract
    (#_"Object" OLOLO'''(§ method invokePrim) [#_"OLOLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLOLL
    #_abstract
    (#_"long" OLOLL'''(§ method invokePrim) [#_"OLOLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLOLD
    #_abstract
    (#_"double" OLOLD'''(§ method invokePrim) [#_"OLOLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLODO
    #_abstract
    (#_"Object" OLODO'''(§ method invokePrim) [#_"OLODO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLODL
    #_abstract
    (#_"long" OLODL'''(§ method invokePrim) [#_"OLODL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLODD
    #_abstract
    (#_"double" OLODD'''(§ method invokePrim) [#_"OLODD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLLOO
    #_abstract
    (#_"Object" OLLOO'''(§ method invokePrim) [#_"OLLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLLOL
    #_abstract
    (#_"long" OLLOL'''(§ method invokePrim) [#_"OLLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLLOD
    #_abstract
    (#_"double" OLLOD'''(§ method invokePrim) [#_"OLLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLLLO
    #_abstract
    (#_"Object" OLLLO'''(§ method invokePrim) [#_"OLLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLLLL
    #_abstract
    (#_"long" OLLLL'''(§ method invokePrim) [#_"OLLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLLLD
    #_abstract
    (#_"double" OLLLD'''(§ method invokePrim) [#_"OLLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLLDO
    #_abstract
    (#_"Object" OLLDO'''(§ method invokePrim) [#_"OLLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLLDL
    #_abstract
    (#_"long" OLLDL'''(§ method invokePrim) [#_"OLLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLLDD
    #_abstract
    (#_"double" OLLDD'''(§ method invokePrim) [#_"OLLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLDOO
    #_abstract
    (#_"Object" OLDOO'''(§ method invokePrim) [#_"OLDOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLDOL
    #_abstract
    (#_"long" OLDOL'''(§ method invokePrim) [#_"OLDOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLDOD
    #_abstract
    (#_"double" OLDOD'''(§ method invokePrim) [#_"OLDOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLDLO
    #_abstract
    (#_"Object" OLDLO'''(§ method invokePrim) [#_"OLDLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLDLL
    #_abstract
    (#_"long" OLDLL'''(§ method invokePrim) [#_"OLDLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLDLD
    #_abstract
    (#_"double" OLDLD'''(§ method invokePrim) [#_"OLDLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLDDO
    #_abstract
    (#_"Object" OLDDO'''(§ method invokePrim) [#_"OLDDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLDDL
    #_abstract
    (#_"long" OLDDL'''(§ method invokePrim) [#_"OLDDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLDDD
    #_abstract
    (#_"double" OLDDD'''(§ method invokePrim) [#_"OLDDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODOOO
    #_abstract
    (#_"Object" ODOOO'''(§ method invokePrim) [#_"ODOOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODOOL
    #_abstract
    (#_"long" ODOOL'''(§ method invokePrim) [#_"ODOOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODOOD
    #_abstract
    (#_"double" ODOOD'''(§ method invokePrim) [#_"ODOOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODOLO
    #_abstract
    (#_"Object" ODOLO'''(§ method invokePrim) [#_"ODOLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODOLL
    #_abstract
    (#_"long" ODOLL'''(§ method invokePrim) [#_"ODOLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODOLD
    #_abstract
    (#_"double" ODOLD'''(§ method invokePrim) [#_"ODOLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODODO
    #_abstract
    (#_"Object" ODODO'''(§ method invokePrim) [#_"ODODO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODODL
    #_abstract
    (#_"long" ODODL'''(§ method invokePrim) [#_"ODODL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODODD
    #_abstract
    (#_"double" ODODD'''(§ method invokePrim) [#_"ODODD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODLOO
    #_abstract
    (#_"Object" ODLOO'''(§ method invokePrim) [#_"ODLOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODLOL
    #_abstract
    (#_"long" ODLOL'''(§ method invokePrim) [#_"ODLOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODLOD
    #_abstract
    (#_"double" ODLOD'''(§ method invokePrim) [#_"ODLOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODLLO
    #_abstract
    (#_"Object" ODLLO'''(§ method invokePrim) [#_"ODLLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODLLL
    #_abstract
    (#_"long" ODLLL'''(§ method invokePrim) [#_"ODLLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODLLD
    #_abstract
    (#_"double" ODLLD'''(§ method invokePrim) [#_"ODLLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODLDO
    #_abstract
    (#_"Object" ODLDO'''(§ method invokePrim) [#_"ODLDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODLDL
    #_abstract
    (#_"long" ODLDL'''(§ method invokePrim) [#_"ODLDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODLDD
    #_abstract
    (#_"double" ODLDD'''(§ method invokePrim) [#_"ODLDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODDOO
    #_abstract
    (#_"Object" ODDOO'''(§ method invokePrim) [#_"ODDOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODDOL
    #_abstract
    (#_"long" ODDOL'''(§ method invokePrim) [#_"ODDOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODDOD
    #_abstract
    (#_"double" ODDOD'''(§ method invokePrim) [#_"ODDOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODDLO
    #_abstract
    (#_"Object" ODDLO'''(§ method invokePrim) [#_"ODDLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODDLL
    #_abstract
    (#_"long" ODDLL'''(§ method invokePrim) [#_"ODDLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODDLD
    #_abstract
    (#_"double" ODDLD'''(§ method invokePrim) [#_"ODDLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODDDO
    #_abstract
    (#_"Object" ODDDO'''(§ method invokePrim) [#_"ODDDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODDDL
    #_abstract
    (#_"long" ODDDL'''(§ method invokePrim) [#_"ODDDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODDDD
    #_abstract
    (#_"double" ODDDD'''(§ method invokePrim) [#_"ODDDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOOOO
    #_abstract
    (#_"Object" LOOOO'''(§ method invokePrim) [#_"LOOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOOOL
    #_abstract
    (#_"long" LOOOL'''(§ method invokePrim) [#_"LOOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOOOD
    #_abstract
    (#_"double" LOOOD'''(§ method invokePrim) [#_"LOOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOOLO
    #_abstract
    (#_"Object" LOOLO'''(§ method invokePrim) [#_"LOOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOOLL
    #_abstract
    (#_"long" LOOLL'''(§ method invokePrim) [#_"LOOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOOLD
    #_abstract
    (#_"double" LOOLD'''(§ method invokePrim) [#_"LOOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOODO
    #_abstract
    (#_"Object" LOODO'''(§ method invokePrim) [#_"LOODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOODL
    #_abstract
    (#_"long" LOODL'''(§ method invokePrim) [#_"LOODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOODD
    #_abstract
    (#_"double" LOODD'''(§ method invokePrim) [#_"LOODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOLOO
    #_abstract
    (#_"Object" LOLOO'''(§ method invokePrim) [#_"LOLOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOLOL
    #_abstract
    (#_"long" LOLOL'''(§ method invokePrim) [#_"LOLOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOLOD
    #_abstract
    (#_"double" LOLOD'''(§ method invokePrim) [#_"LOLOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOLLO
    #_abstract
    (#_"Object" LOLLO'''(§ method invokePrim) [#_"LOLLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOLLL
    #_abstract
    (#_"long" LOLLL'''(§ method invokePrim) [#_"LOLLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOLLD
    #_abstract
    (#_"double" LOLLD'''(§ method invokePrim) [#_"LOLLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOLDO
    #_abstract
    (#_"Object" LOLDO'''(§ method invokePrim) [#_"LOLDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOLDL
    #_abstract
    (#_"long" LOLDL'''(§ method invokePrim) [#_"LOLDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOLDD
    #_abstract
    (#_"double" LOLDD'''(§ method invokePrim) [#_"LOLDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LODOO
    #_abstract
    (#_"Object" LODOO'''(§ method invokePrim) [#_"LODOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LODOL
    #_abstract
    (#_"long" LODOL'''(§ method invokePrim) [#_"LODOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LODOD
    #_abstract
    (#_"double" LODOD'''(§ method invokePrim) [#_"LODOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LODLO
    #_abstract
    (#_"Object" LODLO'''(§ method invokePrim) [#_"LODLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LODLL
    #_abstract
    (#_"long" LODLL'''(§ method invokePrim) [#_"LODLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LODLD
    #_abstract
    (#_"double" LODLD'''(§ method invokePrim) [#_"LODLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LODDO
    #_abstract
    (#_"Object" LODDO'''(§ method invokePrim) [#_"LODDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LODDL
    #_abstract
    (#_"long" LODDL'''(§ method invokePrim) [#_"LODDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LODDD
    #_abstract
    (#_"double" LODDD'''(§ method invokePrim) [#_"LODDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLOOO
    #_abstract
    (#_"Object" LLOOO'''(§ method invokePrim) [#_"LLOOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLOOL
    #_abstract
    (#_"long" LLOOL'''(§ method invokePrim) [#_"LLOOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLOOD
    #_abstract
    (#_"double" LLOOD'''(§ method invokePrim) [#_"LLOOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLOLO
    #_abstract
    (#_"Object" LLOLO'''(§ method invokePrim) [#_"LLOLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLOLL
    #_abstract
    (#_"long" LLOLL'''(§ method invokePrim) [#_"LLOLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLOLD
    #_abstract
    (#_"double" LLOLD'''(§ method invokePrim) [#_"LLOLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLODO
    #_abstract
    (#_"Object" LLODO'''(§ method invokePrim) [#_"LLODO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLODL
    #_abstract
    (#_"long" LLODL'''(§ method invokePrim) [#_"LLODL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLODD
    #_abstract
    (#_"double" LLODD'''(§ method invokePrim) [#_"LLODD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLLOO
    #_abstract
    (#_"Object" LLLOO'''(§ method invokePrim) [#_"LLLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLLOL
    #_abstract
    (#_"long" LLLOL'''(§ method invokePrim) [#_"LLLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLLOD
    #_abstract
    (#_"double" LLLOD'''(§ method invokePrim) [#_"LLLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLLLO
    #_abstract
    (#_"Object" LLLLO'''(§ method invokePrim) [#_"LLLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLLLL
    #_abstract
    (#_"long" LLLLL'''(§ method invokePrim) [#_"LLLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLLLD
    #_abstract
    (#_"double" LLLLD'''(§ method invokePrim) [#_"LLLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLLDO
    #_abstract
    (#_"Object" LLLDO'''(§ method invokePrim) [#_"LLLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLLDL
    #_abstract
    (#_"long" LLLDL'''(§ method invokePrim) [#_"LLLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLLDD
    #_abstract
    (#_"double" LLLDD'''(§ method invokePrim) [#_"LLLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLDOO
    #_abstract
    (#_"Object" LLDOO'''(§ method invokePrim) [#_"LLDOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLDOL
    #_abstract
    (#_"long" LLDOL'''(§ method invokePrim) [#_"LLDOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLDOD
    #_abstract
    (#_"double" LLDOD'''(§ method invokePrim) [#_"LLDOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLDLO
    #_abstract
    (#_"Object" LLDLO'''(§ method invokePrim) [#_"LLDLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLDLL
    #_abstract
    (#_"long" LLDLL'''(§ method invokePrim) [#_"LLDLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLDLD
    #_abstract
    (#_"double" LLDLD'''(§ method invokePrim) [#_"LLDLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLDDO
    #_abstract
    (#_"Object" LLDDO'''(§ method invokePrim) [#_"LLDDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLDDL
    #_abstract
    (#_"long" LLDDL'''(§ method invokePrim) [#_"LLDDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLDDD
    #_abstract
    (#_"double" LLDDD'''(§ method invokePrim) [#_"LLDDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDOOO
    #_abstract
    (#_"Object" LDOOO'''(§ method invokePrim) [#_"LDOOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDOOL
    #_abstract
    (#_"long" LDOOL'''(§ method invokePrim) [#_"LDOOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDOOD
    #_abstract
    (#_"double" LDOOD'''(§ method invokePrim) [#_"LDOOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDOLO
    #_abstract
    (#_"Object" LDOLO'''(§ method invokePrim) [#_"LDOLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDOLL
    #_abstract
    (#_"long" LDOLL'''(§ method invokePrim) [#_"LDOLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDOLD
    #_abstract
    (#_"double" LDOLD'''(§ method invokePrim) [#_"LDOLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDODO
    #_abstract
    (#_"Object" LDODO'''(§ method invokePrim) [#_"LDODO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDODL
    #_abstract
    (#_"long" LDODL'''(§ method invokePrim) [#_"LDODL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDODD
    #_abstract
    (#_"double" LDODD'''(§ method invokePrim) [#_"LDODD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDLOO
    #_abstract
    (#_"Object" LDLOO'''(§ method invokePrim) [#_"LDLOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDLOL
    #_abstract
    (#_"long" LDLOL'''(§ method invokePrim) [#_"LDLOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDLOD
    #_abstract
    (#_"double" LDLOD'''(§ method invokePrim) [#_"LDLOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDLLO
    #_abstract
    (#_"Object" LDLLO'''(§ method invokePrim) [#_"LDLLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDLLL
    #_abstract
    (#_"long" LDLLL'''(§ method invokePrim) [#_"LDLLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDLLD
    #_abstract
    (#_"double" LDLLD'''(§ method invokePrim) [#_"LDLLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDLDO
    #_abstract
    (#_"Object" LDLDO'''(§ method invokePrim) [#_"LDLDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDLDL
    #_abstract
    (#_"long" LDLDL'''(§ method invokePrim) [#_"LDLDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDLDD
    #_abstract
    (#_"double" LDLDD'''(§ method invokePrim) [#_"LDLDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDDOO
    #_abstract
    (#_"Object" LDDOO'''(§ method invokePrim) [#_"LDDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDDOL
    #_abstract
    (#_"long" LDDOL'''(§ method invokePrim) [#_"LDDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDDOD
    #_abstract
    (#_"double" LDDOD'''(§ method invokePrim) [#_"LDDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDDLO
    #_abstract
    (#_"Object" LDDLO'''(§ method invokePrim) [#_"LDDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDDLL
    #_abstract
    (#_"long" LDDLL'''(§ method invokePrim) [#_"LDDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDDLD
    #_abstract
    (#_"double" LDDLD'''(§ method invokePrim) [#_"LDDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDDDO
    #_abstract
    (#_"Object" LDDDO'''(§ method invokePrim) [#_"LDDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDDDL
    #_abstract
    (#_"long" LDDDL'''(§ method invokePrim) [#_"LDDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDDDD
    #_abstract
    (#_"double" LDDDD'''(§ method invokePrim) [#_"LDDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOOOO
    #_abstract
    (#_"Object" DOOOO'''(§ method invokePrim) [#_"DOOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOOOL
    #_abstract
    (#_"long" DOOOL'''(§ method invokePrim) [#_"DOOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOOOD
    #_abstract
    (#_"double" DOOOD'''(§ method invokePrim) [#_"DOOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOOLO
    #_abstract
    (#_"Object" DOOLO'''(§ method invokePrim) [#_"DOOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOOLL
    #_abstract
    (#_"long" DOOLL'''(§ method invokePrim) [#_"DOOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOOLD
    #_abstract
    (#_"double" DOOLD'''(§ method invokePrim) [#_"DOOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOODO
    #_abstract
    (#_"Object" DOODO'''(§ method invokePrim) [#_"DOODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOODL
    #_abstract
    (#_"long" DOODL'''(§ method invokePrim) [#_"DOODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOODD
    #_abstract
    (#_"double" DOODD'''(§ method invokePrim) [#_"DOODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOLOO
    #_abstract
    (#_"Object" DOLOO'''(§ method invokePrim) [#_"DOLOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOLOL
    #_abstract
    (#_"long" DOLOL'''(§ method invokePrim) [#_"DOLOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOLOD
    #_abstract
    (#_"double" DOLOD'''(§ method invokePrim) [#_"DOLOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOLLO
    #_abstract
    (#_"Object" DOLLO'''(§ method invokePrim) [#_"DOLLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOLLL
    #_abstract
    (#_"long" DOLLL'''(§ method invokePrim) [#_"DOLLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOLLD
    #_abstract
    (#_"double" DOLLD'''(§ method invokePrim) [#_"DOLLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOLDO
    #_abstract
    (#_"Object" DOLDO'''(§ method invokePrim) [#_"DOLDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOLDL
    #_abstract
    (#_"long" DOLDL'''(§ method invokePrim) [#_"DOLDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOLDD
    #_abstract
    (#_"double" DOLDD'''(§ method invokePrim) [#_"DOLDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DODOO
    #_abstract
    (#_"Object" DODOO'''(§ method invokePrim) [#_"DODOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DODOL
    #_abstract
    (#_"long" DODOL'''(§ method invokePrim) [#_"DODOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DODOD
    #_abstract
    (#_"double" DODOD'''(§ method invokePrim) [#_"DODOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DODLO
    #_abstract
    (#_"Object" DODLO'''(§ method invokePrim) [#_"DODLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DODLL
    #_abstract
    (#_"long" DODLL'''(§ method invokePrim) [#_"DODLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DODLD
    #_abstract
    (#_"double" DODLD'''(§ method invokePrim) [#_"DODLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DODDO
    #_abstract
    (#_"Object" DODDO'''(§ method invokePrim) [#_"DODDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DODDL
    #_abstract
    (#_"long" DODDL'''(§ method invokePrim) [#_"DODDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DODDD
    #_abstract
    (#_"double" DODDD'''(§ method invokePrim) [#_"DODDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLOOO
    #_abstract
    (#_"Object" DLOOO'''(§ method invokePrim) [#_"DLOOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLOOL
    #_abstract
    (#_"long" DLOOL'''(§ method invokePrim) [#_"DLOOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLOOD
    #_abstract
    (#_"double" DLOOD'''(§ method invokePrim) [#_"DLOOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLOLO
    #_abstract
    (#_"Object" DLOLO'''(§ method invokePrim) [#_"DLOLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLOLL
    #_abstract
    (#_"long" DLOLL'''(§ method invokePrim) [#_"DLOLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLOLD
    #_abstract
    (#_"double" DLOLD'''(§ method invokePrim) [#_"DLOLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLODO
    #_abstract
    (#_"Object" DLODO'''(§ method invokePrim) [#_"DLODO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLODL
    #_abstract
    (#_"long" DLODL'''(§ method invokePrim) [#_"DLODL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLODD
    #_abstract
    (#_"double" DLODD'''(§ method invokePrim) [#_"DLODD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLLOO
    #_abstract
    (#_"Object" DLLOO'''(§ method invokePrim) [#_"DLLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLLOL
    #_abstract
    (#_"long" DLLOL'''(§ method invokePrim) [#_"DLLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLLOD
    #_abstract
    (#_"double" DLLOD'''(§ method invokePrim) [#_"DLLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLLLO
    #_abstract
    (#_"Object" DLLLO'''(§ method invokePrim) [#_"DLLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLLLL
    #_abstract
    (#_"long" DLLLL'''(§ method invokePrim) [#_"DLLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLLLD
    #_abstract
    (#_"double" DLLLD'''(§ method invokePrim) [#_"DLLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLLDO
    #_abstract
    (#_"Object" DLLDO'''(§ method invokePrim) [#_"DLLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLLDL
    #_abstract
    (#_"long" DLLDL'''(§ method invokePrim) [#_"DLLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLLDD
    #_abstract
    (#_"double" DLLDD'''(§ method invokePrim) [#_"DLLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLDOO
    #_abstract
    (#_"Object" DLDOO'''(§ method invokePrim) [#_"DLDOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLDOL
    #_abstract
    (#_"long" DLDOL'''(§ method invokePrim) [#_"DLDOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLDOD
    #_abstract
    (#_"double" DLDOD'''(§ method invokePrim) [#_"DLDOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLDLO
    #_abstract
    (#_"Object" DLDLO'''(§ method invokePrim) [#_"DLDLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLDLL
    #_abstract
    (#_"long" DLDLL'''(§ method invokePrim) [#_"DLDLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLDLD
    #_abstract
    (#_"double" DLDLD'''(§ method invokePrim) [#_"DLDLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLDDO
    #_abstract
    (#_"Object" DLDDO'''(§ method invokePrim) [#_"DLDDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLDDL
    #_abstract
    (#_"long" DLDDL'''(§ method invokePrim) [#_"DLDDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLDDD
    #_abstract
    (#_"double" DLDDD'''(§ method invokePrim) [#_"DLDDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDOOO
    #_abstract
    (#_"Object" DDOOO'''(§ method invokePrim) [#_"DDOOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDOOL
    #_abstract
    (#_"long" DDOOL'''(§ method invokePrim) [#_"DDOOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDOOD
    #_abstract
    (#_"double" DDOOD'''(§ method invokePrim) [#_"DDOOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDOLO
    #_abstract
    (#_"Object" DDOLO'''(§ method invokePrim) [#_"DDOLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDOLL
    #_abstract
    (#_"long" DDOLL'''(§ method invokePrim) [#_"DDOLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDOLD
    #_abstract
    (#_"double" DDOLD'''(§ method invokePrim) [#_"DDOLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDODO
    #_abstract
    (#_"Object" DDODO'''(§ method invokePrim) [#_"DDODO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDODL
    #_abstract
    (#_"long" DDODL'''(§ method invokePrim) [#_"DDODL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDODD
    #_abstract
    (#_"double" DDODD'''(§ method invokePrim) [#_"DDODD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDLOO
    #_abstract
    (#_"Object" DDLOO'''(§ method invokePrim) [#_"DDLOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDLOL
    #_abstract
    (#_"long" DDLOL'''(§ method invokePrim) [#_"DDLOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDLOD
    #_abstract
    (#_"double" DDLOD'''(§ method invokePrim) [#_"DDLOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDLLO
    #_abstract
    (#_"Object" DDLLO'''(§ method invokePrim) [#_"DDLLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDLLL
    #_abstract
    (#_"long" DDLLL'''(§ method invokePrim) [#_"DDLLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDLLD
    #_abstract
    (#_"double" DDLLD'''(§ method invokePrim) [#_"DDLLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDLDO
    #_abstract
    (#_"Object" DDLDO'''(§ method invokePrim) [#_"DDLDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDLDL
    #_abstract
    (#_"long" DDLDL'''(§ method invokePrim) [#_"DDLDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDLDD
    #_abstract
    (#_"double" DDLDD'''(§ method invokePrim) [#_"DDLDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDDOO
    #_abstract
    (#_"Object" DDDOO'''(§ method invokePrim) [#_"DDDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDDOL
    #_abstract
    (#_"long" DDDOL'''(§ method invokePrim) [#_"DDDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDDOD
    #_abstract
    (#_"double" DDDOD'''(§ method invokePrim) [#_"DDDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDDLO
    #_abstract
    (#_"Object" DDDLO'''(§ method invokePrim) [#_"DDDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDDLL
    #_abstract
    (#_"long" DDDLL'''(§ method invokePrim) [#_"DDDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDDLD
    #_abstract
    (#_"double" DDDLD'''(§ method invokePrim) [#_"DDDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDDDO
    #_abstract
    (#_"Object" DDDDO'''(§ method invokePrim) [#_"DDDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDDDL
    #_abstract
    (#_"long" DDDDL'''(§ method invokePrim) [#_"DDDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDDDD
    #_abstract
    (#_"double" DDDDD'''(§ method invokePrim) [#_"DDDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ defprotocol IFn #_(§ extends Callable, Runnable)
    #_abstract
    (#_"Object" IFn'''(§ method invoke-1) [#_"IFn" this])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-2) [#_"IFn" this, #_"Object" ___arg1])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-3) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-4) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-5) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-6) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-7) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-8) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-9) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-10) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-11) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-12) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-13) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-14) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-15) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-16) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-17) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-18) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-19) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18])

    #_abstract
  #_(#_"Object" IFn'''(§ method invoke-20) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
  #_(#_"Object" IFn'''(§ method invoke-21) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-22) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" #_arg19, #_"Object" #_arg20, #_"Object..." ___args])

    #_abstract
    (#_"Object" IFn'''(§ method applyTo) [#_"IFn" this, #_"ISeq" ___arglist])
)
)

(java-ns cloiure.lang.IHashEq

(§ defprotocol IHashEq
    #_abstract
    (#_"int" IHashEq'''(§ method hasheq) [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ defprotocol IKeywordLookup
    #_abstract
    (#_"ILookupThunk" IKeywordLookup'''(§ method getLookupThunk) [#_"IKeywordLookup" this, #_"Keyword" ___k])
)
)

(java-ns cloiure.lang.IKVReduce

(§ defprotocol IKVReduce
    #_abstract
    (#_"Object" IKVReduce'''(§ method kvreduce) [#_"IKVReduce" this, #_"IFn" ___f, #_"Object" ___init])
)
)

(java-ns cloiure.lang.ILookup

(§ defprotocol ILookup
    #_abstract
    (#_"Object" ILookup'''(§ method valAt-2) [#_"ILookup" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ILookup'''(§ method valAt-3) [#_"ILookup" this, #_"Object" ___key, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(§ defprotocol ILookupSite
    #_abstract
    (#_"ILookupThunk" ILookupSite'''(§ method fault) [#_"ILookupSite" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.ILookupThunk

(§ defprotocol ILookupThunk
    #_abstract
    (#_"Object" ILookupThunk'''(§ method get) [#_"ILookupThunk" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ defprotocol IMapEntry #_(§ extends Map$Entry)
    #_abstract
    (#_"Object" IMapEntry'''(§ method key) [#_"IMapEntry" this])
    #_abstract
    (#_"Object" IMapEntry'''(§ method val) [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ defprotocol IMapIterable
    #_abstract
    (#_"Iterator" IMapIterable'''(§ method keyIterator) [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" IMapIterable'''(§ method valIterator) [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(§ defprotocol IMeta
    #_abstract
    (#_"IPersistentMap" IMeta'''(§ method meta) [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(§ defprotocol Indexed #_(§ extends Counted)
    #_abstract
    (#_"Object" Indexed'''(§ method nth-2) [#_"Indexed" this, #_"int" ___i])
    #_abstract
    (#_"Object" Indexed'''(§ method nth-3) [#_"Indexed" this, #_"int" ___i, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(§ defprotocol IndexedSeq #_(§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" IndexedSeq'''(§ method index) [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (defn- #_"Object[]" Intrinsics'oa [#_"Object..." ___arr]
        ___arr
    )

    (def #_"IPersistentMap" Intrinsics'ops (ß RT'map(
        (object-array [
            "public static double cloiure.lang.Numbers.add(double,double)"                Opcodes/DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      Opcodes/LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       Opcodes/LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      Opcodes/LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           Opcodes/DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             Opcodes/DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                Opcodes/LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (oa Opcodes/L2I, Opcodes/LSHL)
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (oa Opcodes/L2I, Opcodes/LSHR)
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (oa Opcodes/L2I, Opcodes/LUSHR)
            "public static double cloiure.lang.Numbers.minus(double)"                     Opcodes/DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              Opcodes/DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static double cloiure.lang.Numbers.dec(double)"                       (oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 Opcodes/LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                Opcodes/ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               Opcodes/ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       Opcodes/IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           Opcodes/IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      Opcodes/ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            Opcodes/INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (oa Opcodes/ICONST_1, Opcodes/IADD)
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (oa Opcodes/ICONST_1, Opcodes/ISUB)
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      Opcodes/IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        Opcodes/IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     Opcodes/IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            Opcodes/LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      Opcodes/DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               Opcodes/LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           Opcodes/DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    Opcodes/DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          Opcodes/LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       Opcodes/LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" Opcodes/DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (oa Opcodes/LCONST_1, Opcodes/LADD)
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (oa Opcodes/LCONST_1, Opcodes/LSUB)

            "public static short cloiure.lang.RT.aget(short[],int)"                       Opcodes/SALOAD
            "public static float cloiure.lang.RT.aget(float[],int)"                       Opcodes/FALOAD
            "public static double cloiure.lang.RT.aget(double[],int)"                     Opcodes/DALOAD
            "public static int cloiure.lang.RT.aget(int[],int)"                           Opcodes/IALOAD
            "public static long cloiure.lang.RT.aget(long[],int)"                         Opcodes/LALOAD
            "public static char cloiure.lang.RT.aget(char[],int)"                         Opcodes/CALOAD
            "public static byte cloiure.lang.RT.aget(byte[],int)"                         Opcodes/BALOAD
            "public static boolean cloiure.lang.RT.aget(boolean[],int)"                   Opcodes/BALOAD
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)" Opcodes/AALOAD
            "public static int cloiure.lang.RT.alength(int[])"                            Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(long[])"                           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(char[])"                           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(java.lang.Object[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(byte[])"                           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(float[])"                          Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(short[])"                          Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(boolean[])"                        Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(double[])"                         Opcodes/ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            Opcodes/L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          Opcodes/NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           Opcodes/F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" Opcodes/NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  Opcodes/F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   Opcodes/L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   Opcodes/I2D
            "public static long cloiure.lang.RT.longCast(long)"                Opcodes/NOP
            "public static long cloiure.lang.RT.longCast(short)"               Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(byte)"                Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(int)"                 Opcodes/I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         Opcodes/L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       Opcodes/D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        Opcodes/F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      Opcodes/F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     D2
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       Opcodes/NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        Opcodes/I2L
        ])
    )))

    ;; map to instructions terminated with comparator for branch to false
    (def #_"IPersistentMap" Intrinsics'preds (ß RT'map(
        (object-array [
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (oa Opcodes/DCMPG, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (oa Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (oa Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (oa Opcodes/DCMPG, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (oa Opcodes/LCMP, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (oa Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (oa Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (oa Opcodes/LCMP, Opcodes/IFLT)
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (oa Opcodes/DCMPL, Opcodes/IFLT)
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (oa Opcodes/IF_ICMPNE)
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (oa Opcodes/DCMPL, Opcodes/IFNE)

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (oa Opcodes/DCONST_0, Opcodes/DCMPG, Opcodes/IFGE)
        ])
    )))
)
)

(java-ns cloiure.lang.IObj

(§ defprotocol IObj #_(§ extends IMeta)
    #_abstract
    (#_"IObj" IObj'''(§ method withMeta) [#_"IObj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.IPending

(§ defprotocol IPending
    #_abstract
    (#_"boolean" IPending'''(§ method isRealized) [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ defprotocol IPersistentCollection #_(§ extends Seqable)
    #_abstract
    (#_"int" IPersistentCollection'''(§ method count) [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''(§ method cons) [#_"IPersistentCollection" this, #_"Object" ___o])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''(§ method empty) [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" IPersistentCollection'''(§ method equiv) [#_"IPersistentCollection" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IPersistentList

(§ defprotocol IPersistentList #_(§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ defprotocol IPersistentMap #_(§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method assoc) [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method assocEx) [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method without) [#_"IPersistentMap" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentSet

(§ defprotocol IPersistentSet #_(§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" IPersistentSet'''(§ method disjoin) [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" IPersistentSet'''(§ method contains) [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" IPersistentSet'''(§ method get) [#_"IPersistentSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentStack

(§ defprotocol IPersistentStack #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" IPersistentStack'''(§ method peek) [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" IPersistentStack'''(§ method pop) [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(§ defprotocol IPersistentVector #_(§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" IPersistentVector'''(§ method length) [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''(§ method assocN) [#_"IPersistentVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''(§ method cons) [#_"IPersistentVector" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IProxy

(§ defprotocol IProxy
    #_abstract
    (#_"void" IProxy'''(§ method __initCloiureFnMappings) [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"void" IProxy'''(§ method __updateCloiureFnMappings) [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"IPersistentMap" IProxy'''(§ method __getCloiureFnMappings) [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(§ defprotocol IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ defprotocol IReduce #_(§ extends IReduceInit)
    #_abstract
    (#_"Object" IReduce'''(§ method reduce) [#_"IReduce" this, #_"IFn" ___f])
)
)

(java-ns cloiure.lang.IReduceInit

(§ defprotocol IReduceInit
    #_abstract
    (#_"Object" IReduceInit'''(§ method reduce) [#_"IReduceInit" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IRef

(§ defprotocol IRef #_(§ extends IDeref)
    #_abstract
    (#_"void" IRef'''(§ method setValidator) [#_"IRef" this, #_"IFn" ___vf])
    #_abstract
    (#_"IFn" IRef'''(§ method getValidator) [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" IRef'''(§ method getWatches) [#_"IRef" this])
    #_abstract
    (#_"IRef" IRef'''(§ method addWatch) [#_"IRef" this, #_"Object" ___key, #_"IFn" ___callback])
    #_abstract
    (#_"IRef" IRef'''(§ method removeWatch) [#_"IRef" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IReference

(§ defprotocol IReference #_(§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" IReference'''(§ method alterMeta) [#_"IReference" this, #_"IFn" ___alter, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentMap" IReference'''(§ method resetMeta) [#_"IReference" this, #_"IPersistentMap" ___m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ defprotocol ISeq #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" ISeq'''(§ method first) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method next) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method more) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method cons) [#_"ISeq" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (defn- #_"Iterate" Iterate'init []
        (hash-map
            #_"IFn" :f nil ;; never nil
            #_"Object" :prevSeed nil
            #_volatile
            #_"Object" :_seed nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Iterate" Iterate'new-3 [#_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed]
        (let [this (merge (ASeq'new) (Iterate'init))]
            (§ ass (:f this) ___f)
            (§ ass (:prevSeed this) ___prevSeed)
            (§ ass (:_seed this) ___seed)
            this
        )
    )

    (defn- #_"Iterate" Iterate'new-5 [#_"IPersistentMap" ___meta, #_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed, #_"ISeq" ___next]
        (let [this (merge (ASeq'new ___meta) (Iterate'init))]
            (§ ass (:f this) ___f)
            (§ ass (:prevSeed this) ___prevSeed)
            (§ ass (:_seed this) ___seed)
            (§ ass (:_next this) ___next)
            this
        )
    )

    (defn #_"ISeq" Iterate'create [#_"IFn" ___f, #_"Object" ___seed]
        (Iterate'new-3 ___f, nil, ___seed)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Iterate" this]
        (ß ((:_seed this) != Iterate'UNREALIZED_SEED))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Iterate" this]
        (when (ß (:_seed this) == Iterate'UNREALIZED_SEED)
            (§ ass (:_seed this) (.invoke (:f this), (:prevSeed this)))
        )
        (:_seed this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Iterate" this]
        (when (nil? (:_next this))
            (§ ass (:_next this) (ß Iterate'new-3((:f this), (first this), Iterate'UNREALIZED_SEED)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Iterate" (§ method withMeta) [#_"Iterate" this, #_"IPersistentMap" ___meta]
        (Iterate'new-5 ___meta, (:f this), (:prevSeed this), (:_seed this), (:_next this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Iterate" this, #_"IFn" ___rf]
        (let [#_"Object" ___first (first this)]
            (let [#_"Object" ___ret ___first]
                (let [#_"Object" ___v (.invoke (:f this), ___first)]
                    (while true
                        (§ ass ___ret (.invoke ___rf, ___ret, ___v))
                        (when (RT'isReduced ___ret)
                            (§ return (.deref (cast' IDeref ___ret)))
                        )
                        (§ ass ___v (.invoke (:f this), ___v))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Iterate" this, #_"IFn" ___rf, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"Object" ___v (first this)]
                (while true
                    (§ ass ___ret (.invoke ___rf, ___ret, ___v))
                    (when (RT'isReduced ___ret)
                        (§ return (.deref (cast' IDeref ___ret)))
                    )
                    (§ ass ___v (.invoke (:f this), ___v))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeqState
    (defn- #_"IteratorSeqState" IteratorSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"IteratorSeqState" IteratorSeqState'new []
        (IteratorSeqState'init)
    )
)

(class-ns IteratorSeq (§ extends ASeq)
    (defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" ___iter]
        (when (.hasNext ___iter)
            (§ return (IteratorSeq'new-1 ___iter))
        )
        nil
    )

    (defn- #_"IteratorSeq" IteratorSeq'init []
        (hash-map
            #_"Iterator" :iter nil
            #_"IteratorSeqState" :state nil
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-1 [#_"Iterator" ___iter]
        (let [this (merge (ASeq'new) (IteratorSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) (IteratorSeqState'new))
            (§ ass (:val (:state this)) (:state this))
            (§ ass (:_rest (:state this)) (:state this))
            this
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-3 [#_"IPersistentMap" ___meta, #_"Iterator" ___iter, #_"IteratorSeqState" ___state]
        (let [this (merge (ASeq'new ___meta) (IteratorSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"IteratorSeq" this]
        (when (ß (:val (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:val (:state this)) == (:state this))
                    (§ ass (:val (:state this)) (next (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"IteratorSeq" this]
        (when (ß (:_rest (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:_rest (:state this)) == (:state this))
                    (first this)
                    (§ ass (:_rest (:state this)) (IteratorSeq'create (:iter this)))
                )
            )
        )
        (cast' ISeq (:_rest (:state this)))
    )

    #_method
    (§ defn #_"IteratorSeq" (§ method withMeta) [#_"IteratorSeq" this, #_"IPersistentMap" ___meta]
        (IteratorSeq'new-3 ___meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ defprotocol ITransientAssociative #_(§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" ITransientAssociative'''(§ method assoc) [#_"ITransientAssociative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ defprotocol ITransientAssociative2 #_(§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" ITransientAssociative2'''(§ method containsKey) [#_"ITransientAssociative2" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" ITransientAssociative2'''(§ method entryAt) [#_"ITransientAssociative2" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientCollection

(§ defprotocol ITransientCollection
    #_abstract
    (#_"ITransientCollection" ITransientCollection'''(§ method conj) [#_"ITransientCollection" this, #_"Object" ___val])
    #_abstract
    (#_"IPersistentCollection" ITransientCollection'''(§ method persistent) [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(§ defprotocol ITransientMap #_(§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" ITransientMap'''(§ method assoc) [#_"ITransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"ITransientMap" ITransientMap'''(§ method without) [#_"ITransientMap" this, #_"Object" ___key])
    #_abstract
    (#_"IPersistentMap" ITransientMap'''(§ method persistent) [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(§ defprotocol ITransientSet #_(§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" ITransientSet'''(§ method disjoin) [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" ITransientSet'''(§ method contains) [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ITransientSet'''(§ method get) [#_"ITransientSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientVector

(§ defprotocol ITransientVector #_(§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" ITransientVector'''(§ method assocN) [#_"ITransientVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"ITransientVector" ITransientVector'''(§ method pop) [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(§ defprotocol IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'TABLE (ConcurrentHashMap.))

    (def #_"ReferenceQueue" Keyword'RQ (ReferenceQueue.))

    (defn #_"Keyword" Keyword'intern [#_"Symbol" ___sym]
        (let [#_"Keyword" ___k nil]
            (let [#_"Reference<Keyword>" ___existingRef (.get Keyword'TABLE, ___sym)]
                (when (nil? ___existingRef)
                    (Util'clearCache Keyword'RQ, Keyword'TABLE)
                    (when (some? (.meta ___sym))
                        (§ ass ___sym (cast' Symbol (.withMeta ___sym, nil)))
                    )
                    (§ ass ___k (Keyword'new ___sym))
                    (§ ass ___existingRef (ß Keyword'TABLE.putIfAbsent(___sym, new WeakReference<Keyword>(___k, Keyword'RQ))))
                )
                (when (nil? ___existingRef)
                    (§ return ___k)
                )
                (let [#_"Keyword" ___existingk (.get ___existingRef)]
                    (when (some? ___existingk)
                        (§ return ___existingk)
                    )
                    ;; entry died in the interim, do over
                    (.remove Keyword'TABLE, ___sym, ___existingRef)
                    (Keyword'intern ___sym)
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'intern-2 [#_"String" ___ns, #_"String" ___name]
        (Keyword'intern (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Keyword" Keyword'intern-1 [#_"String" ___nsname]
        (Keyword'intern (Symbol'intern-1 ___nsname))
    )

    (defn- #_"Keyword" Keyword'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"int" :hasheq 0
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Keyword" Keyword'new [#_"Symbol" ___sym]
        (let [this (Keyword'init)]
            (§ ass (:sym this) ___sym)
            (§ ass (:hasheq this) (ß (.hasheq ___sym) + 0x9e3779b9))
            this
        )
    )

    (defn #_"Keyword" Keyword'find [#_"Symbol" ___sym]
        (let [#_"Reference<Keyword>" ___ref (.get Keyword'TABLE, ___sym)]
            (if (some? ___ref)
                (do
                    (.get ___ref)
                )
                (do
                    nil
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'find-2 [#_"String" ___ns, #_"String" ___name]
        (Keyword'find (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Keyword" Keyword'find-1 [#_"String" ___nsname]
        (Keyword'find (Symbol'intern-1 ___nsname))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Keyword" this]
        (ß (:sym this).hashCode() + 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"Keyword" this]
        (:hasheq this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Keyword" this]
        (when (nil? (:_str this))
            (§ ass (:_str this) (str ":" (:sym this)))
        )
        (:_str this)
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"Keyword" this]
        (throw (IllegalArgumentException. (str "Wrong number of args passed to keyword: " (.toString this))))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Keyword" this]
        (.throwArity this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this]
        (.throwArity this)
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Keyword" this, #_"Object" ___o]
        (ß (:sym this).compareTo((:sym (cast' Keyword ___o))))
    )

    #_method
    (§ defn #_"String" (§ method getNamespace) [#_"Keyword" this]
        (.getNamespace (:sym this))
    )

    #_method
    (§ defn #_"String" (§ method getName) [#_"Keyword" this]
        (.getName (:sym this))
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___obj]
        (when (§ instance? ILookup ___obj)
            (§ return (.valAt (cast' ILookup ___obj), this))
        )
        (RT'get-2 ___obj, this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___obj, #_"Object" ___notFound]
        (when (§ instance? ILookup ___obj)
            (§ return (.valAt (cast' ILookup ___obj), this, ___notFound))
        )
        (RT'get-3 ___obj, this, ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Keyword" this, #_"ISeq" ___arglist]
        (AFn'applyToHelper this, ___arglist)
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (defn- #_"KeywordLookupSite" KeywordLookupSite'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordLookupSite" KeywordLookupSite'new [#_"Keyword" ___k]
        (let [this (KeywordLookupSite'init)]
            (§ ass (:k this) ___k)
            this
        )
    )

    #_method
    (§ defn #_"ILookupThunk" (§ method fault) [#_"KeywordLookupSite" this, #_"Object" ___target]
        (cond (§ instance? IKeywordLookup ___target)
            (do
                (§ return (.install this, ___target))
            )
            (§ instance? ILookup ___target)
            (do
                (§ return (.ilookupThunk this, (.getClass ___target)))
            )
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"KeywordLookupSite" this, #_"Object" ___target]
        (when (or (§ instance? IKeywordLookup ___target) (§ instance? ILookup ___target))
            (§ return this)
        )
        (RT'get-2 ___target, (:k this))
    )

    #_method
    (§ defn- #_"ILookupThunk" (§ method ilookupThunk) [#_"KeywordLookupSite" this, #_"Class" ___c]
        (§ reify ILookupThunk()
            #_method
            (§ defn #_"Object" (§ method get) [#_"ILookupThunk" this, #_"Object" ___target]
                (when (and (some? ___target) (ß (.getClass ___target) == ___c))
                    (§ return (.valAt (cast' ILookup ___target), (:k this)))
                )
                this
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" (§ method install) [#_"KeywordLookupSite" this, #_"Object" ___target]
        (let [#_"ILookupThunk" ___t (.getLookupThunk (cast' IKeywordLookup ___target), (:k this))]
            (when (some? ___t)
                (§ return ___t)
            )
            (.ilookupThunk this, (.getClass ___target))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (defn #_"IPersistentVector" LazilyPersistentVector'createOwning [#_"Object..." ___items]
        (when (<= (§ alength ___items) 32)
            (§ return (ß PersistentVector'new-4((§ alength ___items), 5, PersistentVector'EMPTY_NODE, ___items)))
        )
        (PersistentVector'create-1a ___items)
    )

    (defn #_"int" LazilyPersistentVector'fcount [#_"Object" ___c]
        (when (§ instance? Counted ___c)
            (§ return (.count (cast' Counted ___c)))
        )
        (.size (cast Collection ___c))
    )

    (defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" ___obj]
        (cond (§ instance? IReduceInit ___obj)
            (do
                (ß PersistentVector'create-1r((cast' IReduceInit ___obj)))
            )
            (§ instance? ISeq ___obj)
            (do
                (ß PersistentVector'create-1s(RT'seq(___obj)))
            )
            (instance? Iterable ___obj)
            (do
                (ß PersistentVector'create-1i((cast Iterable ___obj)))
            )
            :else
            (do
                (ß createOwning(RT'toArray(___obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (defn- #_"LazySeq" LazySeq'init []
        (hash-map
            #_"IFn" :fn nil
            #_"Object" :sv nil
            #_"ISeq" :s nil
        )
    )

    (defn #_"LazySeq" LazySeq'new-1 [#_"IFn" ___fn]
        (let [this (merge (Obj'new) (LazySeq'init))]
            (§ ass (:fn this) ___fn)
            this
        )
    )

    (defn- #_"LazySeq" LazySeq'new-2 [#_"IPersistentMap" ___meta, #_"ISeq" ___s]
        (let [this (merge (Obj'new ___meta) (LazySeq'init))]
            (§ ass (:fn this) nil)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"LazySeq" this, #_"IPersistentMap" ___meta]
        (ß LazySeq'new-2(___meta, (.seq this)))
    )

    #_method
    (§ defn #_"Object" (§ method sval) [#_"LazySeq" this]
        (§ sync this
            (when (some? (:fn this))
                (§ ass (:sv this) (.invoke (:fn this)))
                (§ ass (:fn this) nil)
            )
            (when (some? (:sv this))
                (§ return (:sv this))
            )
            (:s this)
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"LazySeq" this]
        (§ sync this
            (.sval this)
            (when (some? (:sv this))
                (let [#_"Object" ___ls (:sv this)]
                    (§ ass (:sv this) nil)
                    (while (§ instance? LazySeq ___ls)
                        (§ ass ___ls (.sval (cast' LazySeq ___ls)))
                    )
                    (§ ass (:s this) (RT'seq ___ls))
                )
            )
            (:s this)
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"LazySeq" this]
        (let [#_"int" ___c 0]
            (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                (§ ass ___c (inc ___c))
            )
            ___c
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"LazySeq" this]
        (.seq this)
        (when (nil? (:s this))
            (§ return nil)
        )
        (first (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"LazySeq" this]
        (.seq this)
        (when (nil? (:s this))
            (§ return nil)
        )
        (next (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"LazySeq" this]
        (.seq this)
        (when (nil? (:s this))
            (§ return PersistentList'EMPTY)
        )
        (.more (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method cons) [#_"LazySeq" this, #_"Object" ___o]
        (ß RT'cons(___o, (.seq this)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"LazySeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (.seq this)]
            (if (some? ___s)
                (do
                    (.equiv ___s, ___o)
                )
                (do
                    (and (or (§ instance? Sequential ___o) (instance? List ___o)) (nil? (RT'seq ___o)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"LazySeq" this]
        (let [#_"ISeq" ___s (.seq this)]
            (when (nil? ___s)
                (§ return 1)
            )
            (Util'hash ___s)
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"LazySeq" this]
        (Murmur3'hashOrdered this)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (.seq this)]
            (if (some? ___s)
                (do
                    (.equals ___s, ___o)
                )
                (do
                    (and (or (§ instance? Sequential ___o) (instance? List ___o)) (nil? (RT'seq ___o)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"LazySeq" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"LazySeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (.contains this, ___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"LazySeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"LazySeq" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"LazySeq" this]
        (nil? (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"LazySeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"LazySeq" this]
        (ArrayList. this)
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"LazySeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (.reify this).subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"LazySeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this) #_"int" ___i 0] (some? ___s) [(next ___s) (inc ___i)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"LazySeq" this, #_"Object" ___o]
        (ß (.reify this).lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"LazySeq" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"LazySeq" this, #_"int" ___index]
        (ß (.reify this).listIterator(___index))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"LazySeq" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"LazySeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"LazySeq" this]
        (§ sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (def- #_"int" LineNumberingPushbackReader'newline (ß (int) \newline))

    (defn- #_"LineNumberingPushbackReader" LineNumberingPushbackReader'init []
        (hash-map
            #_"boolean" :_atLineStart true
            #_"boolean" :_prev false
            #_"int" :_columnNumber 1
        )
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-1 [#_"Reader" ___r]
        (merge (PushbackReader'new (LineNumberReader. ___r)) (LineNumberingPushbackReader'init))
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-2 [#_"Reader" ___r, #_"int" ___size]
        (merge (PushbackReader'new (LineNumberReader. ___r, ___size)) (LineNumberingPushbackReader'init))
    )

    #_method
    (§ defn #_"int" (§ method getLineNumber) [#_"LineNumberingPushbackReader" this]
        (ß (cast LineNumberReader in).getLineNumber() + 1)
    )

    #_method
    (§ defn #_"void" (§ method setLineNumber) [#_"LineNumberingPushbackReader" this, #_"int" ___line]
        (ß (cast LineNumberReader in).setLineNumber(___line - 1))
        nil
    )

    #_method
    (§ defn #_"int" (§ method getColumnNumber) [#_"LineNumberingPushbackReader" this]
        (:_columnNumber this)
    )

    #_method
    (§ defn #_"int" (§ method read) [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (.read super)]
            (§ ass (:_prev this) (:_atLineStart this))
            (if (or (ß ___c == LineNumberingPushbackReader'newline) (ß ___c == -1))
                (do
                    (§ ass (:_atLineStart this) true)
                    (§ ass (:_columnNumber this) 1)
                )
                (do
                    (§ ass (:_atLineStart this) false)
                    (§ ass (:_columnNumber this) (inc (:_columnNumber this)))
                )
            )
            ___c
        )
    )

    #_method
    (§ defn #_"void" (§ method unread) [#_"LineNumberingPushbackReader" this, #_"int" ___c] #_(§ throws IOException)
        (.unread super, ___c)
        (§ ass (:_atLineStart this) (:_prev this))
        (§ ass (:_columnNumber this) (dec (:_columnNumber this)))
        nil
    )

    #_method
    (§ defn #_"String" (§ method readLine) [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (.read this)]
            (§ let [#_"String" ___line]
                (§ switch ___c
                    (§ case -1)
                    (do
                        (§ ass ___line nil)
                        (§ break )
                    )
                    (§ case LineNumberingPushbackReader'newline)
                    (do
                        (§ ass ___line "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" ___first (ß String/valueOf((char) ___c))]
                            (let [#_"String" ___rest (.readLine (cast LineNumberReader in))]
                                (§ ass ___line (if (nil? ___rest) ___first (str ___first ___rest)))
                                (§ ass (:_prev this) false)
                                (§ ass (:_atLineStart this) true)
                                (§ ass (:_columnNumber this) 1)
                                (§ break )
                            )
                        )
                    )
                )
                ___line
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method atLineStart) [#_"LineNumberingPushbackReader" this]
        (:_atLineStart this)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(§ defprotocol Resolver
    #_abstract
    (#_"Symbol" Resolver'''(§ method currentNS) [#_"Resolver" this])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveClass) [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveAlias) [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveVar) [#_"Resolver" this, #_"Symbol" ___sym])
)

(class-ns LispReaderException (§ extends RuntimeException)
    (defn- #_"LispReaderException" LispReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"LispReaderException" LispReaderException'new [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new ___cause) (LispReaderException'init))]
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )
)

#_closure
(class-ns RegexReader (§ extends AFn)
    (defn #_"RegexReader" RegexReader'new []
        (AFn'new)
    )

    (§ def #_"LispStringReader" RegexReader'stringrdr (LispStringReader'new))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RegexReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (cast Reader ___reader)]
                (loop-when-recur [#_"int" ___ch (LispReader'read1 ___r)] (ß ___ch != \") [(LispReader'read1 ___r)] ;; oops! "
                    (when (= ___ch -1)
                        (throw (Util'runtimeException-1 "EOF while reading regex"))
                    )
                    (ß ___sb.append((char) ___ch))
                    (when (= ___ch \\) ;; escape
                        (§ ass ___ch (LispReader'read1 ___r))
                        (when (= ___ch -1)
                            (throw (Util'runtimeException-1 "EOF while reading regex"))
                        )
                        (ß ___sb.append((char) ___ch))
                    )
                )
                (Pattern/compile (.toString ___sb))
            )
        )
    )
)

#_closure
(class-ns LispStringReader (§ extends AFn)
    (defn #_"LispStringReader" LispStringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (cast Reader ___reader)]
                (loop-when-recur [#_"int" ___ch (LispReader'read1 ___r)] (ß ___ch != \") [(LispReader'read1 ___r)] ;; oops! "
                    (when (= ___ch -1)
                        (throw (Util'runtimeException-1 "EOF while reading string"))
                    )
                    (when (= ___ch \\) ;; escape
                        (§ ass ___ch (LispReader'read1 ___r))
                        (when (= ___ch -1)
                            (throw (Util'runtimeException-1 "EOF while reading string"))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch \tab)
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch \return)
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch \newline)
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch \backspace)
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch \formfeed)
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (LispReader'read1 ___r))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (Util'runtimeException-1 (str "Invalid unicode escape: \\u" (ß (char) ___ch))))
                                )
                                (§ ass ___ch (ß readUnicodeChar((cast PushbackReader ___r), ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (Character/isDigit ___ch)
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((cast PushbackReader ___r), ___ch, 8, 3, false)))
                                        (when (> ___ch 0377)
                                            (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (Util'runtimeException-1 (str "Unsupported escape character: \\" (ß (char) ___ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (.toString ___sb)
            )
        )
    )
)

#_closure
(class-ns LispCommentReader (§ extends AFn)
    (defn #_"LispCommentReader" LispCommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Reader" ___r (cast Reader ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (LispReader'read1 ___r))
                    (§ recur-if (and (ß ___ch != -1) (ß ___ch != \newline) (ß ___ch != \return)))
                )
                ___r
            )
        )
    )
)

#_closure
(class-ns LispDiscardReader (§ extends AFn)
    (defn #_"LispDiscardReader" LispDiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))
            ___r
        )
    )
)

;; :a.b{:c 1} => {:a.b/c 1}
;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
#_closure
(class-ns LispNamespaceMapReader (§ extends AFn)
    (defn #_"LispNamespaceMapReader" LispNamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"boolean" ___auto false]
                (let [#_"int" ___autoChar (LispReader'read1 ___r)]
                    (if (ß ___autoChar == \:)
                        (do
                            (§ ass ___auto true)
                        )
                        (do
                            (LispReader'unread ___r, ___autoChar)
                        )
                    )

                    (let [#_"Object" ___sym nil]
                        (let [#_"int" ___nextChar (LispReader'read1 ___r)]
                            (cond (LispReader'isWhitespace ___nextChar) ;; the #:: { } case or an error
                                (do
                                    (if ___auto
                                        (do
                                            (while (LispReader'isWhitespace ___nextChar)
                                                (§ ass ___nextChar (LispReader'read1 ___r))
                                            )
                                            (when (ß ___nextChar != \{)
                                                (LispReader'unread ___r, ___nextChar)
                                                (throw (Util'runtimeException-1 "Namespaced map must specify a namespace"))
                                            )
                                        )
                                        (do
                                            (LispReader'unread ___r, ___nextChar)
                                            (throw (Util'runtimeException-1 "Namespaced map must specify a namespace"))
                                        )
                                    )
                                )
                                (ß ___nextChar != \{) ;; #:foo { } or #::foo { }
                                (do
                                    (LispReader'unread ___r, ___nextChar)
                                    (§ ass ___sym (LispReader'read-6 ___r, true, nil, false, ___opts, ___pendingForms))
                                    (§ ass ___nextChar (LispReader'read1 ___r))
                                    (while (LispReader'isWhitespace ___nextChar)
                                        (§ ass ___nextChar (LispReader'read1 ___r))
                                    )
                                )
                            )
                            (when (ß ___nextChar != \{)
                                (throw (Util'runtimeException-1 "Namespaced map must specify a map"))
                            )

                            ;; Resolve autoresolved ns
                            (§ let [#_"String" ___ns]
                                (cond ___auto
                                    (do
                                        (let [#_"Resolver" ___resolver (cast' Resolver (.deref RT'READER_RESOLVER))]
                                            (cond (nil? ___sym)
                                                (do
                                                    (if (some? ___resolver)
                                                        (do
                                                            (§ ass ___ns (:name (.currentNS ___resolver)))
                                                        )
                                                        (do
                                                            (§ ass ___ns (ß Compiler'currentNS().getName().getName()))
                                                        )
                                                    )
                                                )
                                                (or (not (§ instance? Symbol ___sym)) (some? (.getNamespace (cast' Symbol ___sym))))
                                                (do
                                                    (throw (Util'runtimeException-1 (str "Namespaced map must specify a valid namespace: " ___sym)))
                                                )
                                                :else
                                                (do
                                                    (§ let [#_"Symbol" ___resolvedNS]
                                                        (if (some? ___resolver)
                                                            (do
                                                                (§ ass ___resolvedNS (.resolveAlias ___resolver, (cast' Symbol ___sym)))
                                                            )
                                                            (do
                                                                (let [#_"Namespace" ___rns (ß Compiler'currentNS().lookupAlias((cast' Symbol ___sym)))]
                                                                    (§ ass ___resolvedNS (when (some? ___rns) (.getName ___rns)))
                                                                )
                                                            )
                                                        )

                                                        (if (nil? ___resolvedNS)
                                                            (do
                                                                (throw (Util'runtimeException-1 (str "Unknown auto-resolved namespace alias: " ___sym)))
                                                            )
                                                            (do
                                                                (§ ass ___ns (.getName ___resolvedNS))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (or (not (§ instance? Symbol ___sym)) (some? (.getNamespace (cast' Symbol ___sym))))
                                    (do
                                        (throw (Util'runtimeException-1 (str "Namespaced map must specify a valid namespace: " ___sym)))
                                    )
                                    :else
                                    (do
                                        (§ ass ___ns (.getName (cast' Symbol ___sym)))
                                    )
                                )

                                ;; Read map
                                (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts, LispReader'ensurePending(___pendingForms)))]
                                    (when (ß ((.size ___kvs) & 1) == 1)
                                        (throw (Util'runtimeException-1 "Namespaced map literal must contain an even number of forms"))
                                    )

                                    ;; Construct output map
                                    (let [#_"Object[]" ___a (make-array Object (.size ___kvs))]
                                        (let [#_"Iterator" ___iter (.iterator ___kvs)]
                                            (loop-when-recur [#_"int" ___i 0] (.hasNext ___iter) [(+ ___i 2)]
                                                (let [#_"Object" ___key (next ___iter)]
                                                    (let [#_"Object" ___val (next ___iter)]
                                                        (cond (§ instance? Keyword ___key)
                                                            (do
                                                                (let [#_"Keyword" ___kw (cast' Keyword ___key)]
                                                                    (cond (nil? (.getNamespace ___kw))
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern-2(___ns, (.getName ___kw))))
                                                                        )
                                                                        (ß (.getNamespace ___kw).equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern-2(nil, (.getName ___kw))))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (§ instance? Symbol ___key)
                                                            (do
                                                                (let [#_"Symbol" ___s (cast' Symbol ___key)]
                                                                    (cond (nil? (.getNamespace ___s))
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern-2(___ns, (.getName ___s))))
                                                                        )
                                                                        (ß (.getNamespace ___s).equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern-2(nil, (.getName ___s))))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (§ ass (§ aget ___a ___i) ___key)
                                                        (§ ass (§ aget ___a (ß ___i + 1)) ___val)
                                                    )
                                                )
                                            )
                                            (RT'map ___a)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispSymbolicValueReader (§ extends AFn)
    (defn #_"LispSymbolicValueReader" LispSymbolicValueReader'new []
        (AFn'new)
    )

    (def #_"IPersistentMap" LispSymbolicValueReader'specials (ß PersistentHashMap'create-1a(
        (object-array [
            (Symbol'intern-1 "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern-1 "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern-1 "NaN")  Double/NaN
        ])
    )))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                (when (not (§ instance? Symbol ___o))
                    (throw (Util'runtimeException-1 (str "Invalid token: ##" ___o)))
                )
                (when (not (.containsKey LispSymbolicValueReader'specials, ___o))
                    (throw (Util'runtimeException-1 (str "Unknown symbolic value: ##" ___o)))
                )

                (.valAt LispSymbolicValueReader'specials, ___o)
            )
        )
    )
)

(class-ns WrappingReader (§ extends AFn)
    (defn- #_"WrappingReader" WrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
        )
    )

    (defn #_"WrappingReader" WrappingReader'new [#_"Symbol" ___sym]
        (let [this (merge (AFn'new) (WrappingReader'init))]
            (§ ass (:sym this) ___sym)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"WrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                (RT'list-2 (:sym this), ___o)
            )
        )
    )
)

(class-ns DeprecatedWrappingReader (§ extends AFn)
    (defn- #_"DeprecatedWrappingReader" DeprecatedWrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"String" :macro nil
        )
    )

    (defn #_"DeprecatedWrappingReader" DeprecatedWrappingReader'new [#_"Symbol" ___sym, #_"String" ___macro]
        (let [this (merge (AFn'new) (DeprecatedWrappingReader'init))]
            (§ ass (:sym this) ___sym)
            (§ ass (:macro this) ___macro)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"DeprecatedWrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (System/out.println (str "WARNING: reader macro " (:macro this) " is deprecated; use " (.getName (:sym this)) " instead"))
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                (RT'list-2 (:sym this), ___o)
            )
        )
    )
)

#_closure
(class-ns VarReader (§ extends AFn)
    (defn #_"VarReader" VarReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"VarReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                (RT'list-2 LispReader'THE_VAR, ___o)
            )
        )
    )
)

#_closure
(class-ns LispDispatchReader (§ extends AFn)
    (defn #_"LispDispatchReader" LispDispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___ch (LispReader'read1 (cast Reader ___reader))]
            (when (= ___ch -1)
                (throw (Util'runtimeException-1 "EOF while reading character"))
            )
            (let [#_"IFn" ___fn (§ aget dispatchMacros ___ch)]
                ;; Try the ctor reader first
                (when (nil? ___fn)
                    (LispReader'unread (cast PushbackReader ___reader), ___ch)
                    (§ ass ___pendingForms (LispReader'ensurePending ___pendingForms))
                    (let [#_"Object" ___result (.invoke ctorReader, ___reader, ___ch, ___opts, ___pendingForms)]
                        (if (some? ___result)
                            (do
                                (§ return ___result)
                            )
                            (do
                                (throw (Util'runtimeException-1 (String/format "No dispatch macro for: %c", (object-array [ (ß (char) ___ch) ]))))
                            )
                        )
                    )
                )
                (.invoke ___fn, ___reader, ___ch, ___opts, ___pendingForms)
            )
        )
    )
)

#_closure
(class-ns FnReader (§ extends AFn)
    (defn #_"FnReader" FnReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnReader" this, #_"Object" ___reader, #_"Object" ___lparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (when (some? (.deref LispReader'ARG_ENV))
                (throw (IllegalStateException. "Nested #()s are not allowed"))
            )
            (try
                (ß Var'pushThreadBindings(RT'map(LispReader'ARG_ENV, PersistentTreeMap'EMPTY)))
                (LispReader'unread ___r, \()
                (let [#_"Object" ___form (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                    (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                        (let [#_"PersistentTreeMap" ___argsyms (cast' PersistentTreeMap (.deref LispReader'ARG_ENV))]
                            (let [#_"ISeq" ___rargs (.rseq ___argsyms)]
                                (when (some? ___rargs)
                                    (let [#_"int" ___higharg (cast Integer (.getKey (cast Map$Entry (first ___rargs))))]
                                        (when (> ___higharg 0)
                                            (loop-when-recur [#_"int" ___i 1] (<= ___i ___higharg) [(inc ___i)]
                                                (let [#_"Object" ___sym (.valAt ___argsyms, ___i)]
                                                    (when (nil? ___sym)
                                                        (§ ass ___sym (garg ___i))
                                                    )
                                                    (§ ass ___args (.cons ___args, ___sym))
                                                )
                                            )
                                        )
                                        (let [#_"Object" ___restsym (.valAt ___argsyms, -1)]
                                            (when (some? ___restsym)
                                                (§ ass ___args (.cons ___args, Compiler'_AMP_))
                                                (§ ass ___args (.cons ___args, ___restsym))
                                            )
                                        )
                                    )
                                )
                                (RT'list-3 Compiler'FN, ___args, ___form)
                            )
                        )
                    )
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )
)

#_closure
(class-ns ArgReader (§ extends AFn)
    (defn #_"ArgReader" ArgReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ArgReader" this, #_"Object" ___reader, #_"Object" ___pct, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (when (nil? (.deref LispReader'ARG_ENV))
                (§ return (ß interpretToken(readToken(___r, \%), nil)))
            )
            (let [#_"int" ___ch (LispReader'read1 ___r)]
                (LispReader'unread ___r, ___ch)
                ;; % alone is first arg
                (when (or (ß ___ch == -1) (LispReader'isWhitespace ___ch) (LispReader'isTerminatingMacro ___ch))
                    (§ return (registerArg 1))
                )
                (let [#_"Object" ___n (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                    (when (.equals ___n, Compiler'_AMP_)
                        (§ return (registerArg -1))
                    )
                    (when (not (instance? Number ___n))
                        (throw (IllegalStateException. "arg literal must be %, %& or %integer"))
                    )
                    (ß registerArg((cast Number ___n).intValue()))
                )
            )
        )
    )
)

#_closure
(class-ns LispMetaReader (§ extends AFn)
    (defn #_"LispMetaReader" LispMetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (§ instance? LineNumberingPushbackReader ___r)
                        (§ ass ___line (.getLineNumber (cast' LineNumberingPushbackReader ___r)))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (§ ass ___pendingForms (LispReader'ensurePending ___pendingForms))
                    (let [#_"Object" ___meta (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                        (cond (or (§ instance? Symbol ___meta) (instance? String ___meta))
                            (do
                                (§ ass ___meta (RT'map RT'TAG_KEY, ___meta))
                            )
                            (§ instance? Keyword ___meta)
                            (do
                                (§ ass ___meta (RT'map ___meta, RT'T))
                            )
                            (not (§ instance? IPersistentMap ___meta))
                            (do
                                (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                            )
                        )

                        (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                            (if (§ instance? IMeta ___o)
                                (do
                                    (when (and (ß ___line != -1) (§ instance? ISeq ___o))
                                        (§ ass ___meta (ß (cast' IPersistentMap ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (§ instance? IReference ___o)
                                        (.resetMeta (cast' IReference ___o), (cast' IPersistentMap ___meta))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (RT'meta ___o)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'seq ___meta)] (some? ___s) [(next ___s)]
                                            (let [#_"IMapEntry" ___kv (cast' IMapEntry (first ___s))]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, (.getKey ___kv), (.getValue ___kv))))
                                            )
                                        )
                                        (.withMeta (cast' IObj ___o), (cast' IPersistentMap ___ometa))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SyntaxQuoteReader (§ extends AFn)
    (defn #_"SyntaxQuoteReader" SyntaxQuoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"SyntaxQuoteReader" this, #_"Object" ___reader, #_"Object" ___backquote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (try
                (ß Var'pushThreadBindings(RT'map(LispReader'GENSYM_ENV, PersistentHashMap'EMPTY)))

                (let [#_"Object" ___form (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                    (syntaxQuote ___form)
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" ___form]
        (§ let [#_"Object" ___ret]
            (cond (Compiler'isSpecial ___form)
                (do
                    (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___form))
                )
                (§ instance? Symbol ___form)
                (do
                    (let [#_"Resolver" ___resolver (cast' Resolver (.deref RT'READER_RESOLVER))]
                        (let [#_"Symbol" ___sym (cast' Symbol ___form)]
                            (cond (and (nil? (:ns ___sym)) (.endsWith (:name ___sym), "#"))
                                (do
                                    (let [#_"IPersistentMap" ___gmap (cast' IPersistentMap (.deref LispReader'GENSYM_ENV))]
                                        (when (nil? ___gmap)
                                            (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                        )
                                        (let [#_"Symbol" ___gs (cast' Symbol (.valAt ___gmap, ___sym))]
                                            (when (nil? ___gs)
                                                (§ ass ___gs (Symbol'intern-2 nil, (str (ß (:name ___sym).substring(0, (:name ___sym).length() - 1)) "__" (RT'nextID) "__auto__")))
                                                (ß LispReader'GENSYM_ENV.set(___gmap.assoc(___sym, ___gs)))
                                            )
                                            (§ ass ___sym ___gs)
                                        )
                                    )
                                )
                                (and (nil? (:ns ___sym)) (.endsWith (:name ___sym), "."))
                                (do
                                    (let [#_"Symbol" ___csym (ß Symbol'intern-2(nil, (:name ___sym).substring(0, (:name ___sym).length() - 1)))]
                                        (if (some? ___resolver)
                                            (do
                                                (let [#_"Symbol" ___rc (.resolveClass ___resolver, ___csym)]
                                                    (when (some? ___rc)
                                                        (§ ass ___csym ___rc)
                                                    )
                                                )
                                            )
                                            (do
                                                (§ ass ___csym (Compiler'resolveSymbol ___csym))
                                            )
                                        )
                                        (§ ass ___sym (ß Symbol'intern-2(nil, (:name ___csym).concat("."))))
                                    )
                                )
                                (and (nil? (:ns ___sym)) (.startsWith (:name ___sym), "."))
                                (do
                                    ;; Simply quote method names.
                                )
                                (some? ___resolver)
                                (do
                                    (let [#_"Symbol" ___nsym nil]
                                        (when (ß (some? (:ns ___sym)))
                                            (let [#_"Symbol" ___alias (ß Symbol'intern-2(nil, (:ns ___sym)))]
                                                (§ ass ___nsym (.resolveClass ___resolver, ___alias))
                                                (when (nil? ___nsym)
                                                    (§ ass ___nsym (.resolveAlias ___resolver, ___alias))
                                                )
                                            )
                                        )
                                        (cond (some? ___nsym)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern-2((:name ___nsym), (:name ___sym))))
                                            )
                                            (ß (nil? (:ns ___sym)))
                                            (do
                                                (let [#_"Symbol" ___rsym (.resolveClass ___resolver, ___sym)]
                                                    (when (nil? ___rsym)
                                                        (§ ass ___rsym (.resolveVar ___resolver, ___sym))
                                                    )
                                                    (if (some? ___rsym)
                                                        (do
                                                            (§ ass ___sym ___rsym)
                                                        )
                                                        (do
                                                            (§ ass ___sym (ß Symbol'intern-2((:name (.currentNS ___resolver)), (:name ___sym))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        ;; leave alone if qualified
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Object" ___maybeClass nil]
                                        (when (ß (some? (:ns ___sym)))
                                            (§ ass ___maybeClass (ß Compiler'currentNS().getMapping(Symbol'intern-2(nil, (:ns ___sym)))))
                                        )
                                        (if (instance? Class ___maybeClass)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern-2((cast Class ___maybeClass).getName(), (:name ___sym))))
                                            )
                                            (do
                                                (§ ass ___sym (Compiler'resolveSymbol ___sym))
                                            )
                                        )
                                    )
                                )
                            )
                            (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___sym))
                        )
                    )
                )
                (LispReader'isUnquote ___form)
                (do
                    (§ return (RT'second ___form))
                )
                (LispReader'isUnquoteSplicing ___form)
                (do
                    (throw (IllegalStateException. "splice not in list"))
                )
                (§ instance? IPersistentCollection ___form)
                (do
                    (cond (§ instance? IRecord ___form)
                        (do
                            (§ ass ___ret ___form)
                        )
                        (§ instance? IPersistentMap ___form)
                        (do
                            (let [#_"IPersistentVector" ___keyvals (SyntaxQuoteReader'flattenMap ___form)]
                                (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'HASHMAP, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList((.seq ___keyvals)))))))
                            )
                        )
                        (§ instance? IPersistentVector ___form)
                        (do
                            (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'VECTOR, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList((cast' IPersistentVector ___form).seq()))))))
                        )
                        (§ instance? IPersistentSet ___form)
                        (do
                            (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'HASHSET, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList((cast' IPersistentSet ___form).seq()))))))
                        )
                        (or (§ instance? ISeq ___form) (§ instance? IPersistentList ___form))
                        (do
                            (let [#_"ISeq" ___seq (RT'seq ___form)]
                                (if (nil? ___seq)
                                    (do
                                        (§ ass ___ret (RT'cons LispReader'LIST, nil))
                                    )
                                    (do
                                        (§ ass ___ret (ß RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList(___seq)))))
                                    )
                                )
                            )
                        )
                        :else
                        (do
                            (throw (UnsupportedOperationException. "Unknown Collection type"))
                        )
                    )
                )
                (or (§ instance? Keyword ___form) (instance? Number ___form) (instance? Character ___form) (instance? String ___form))
                (do
                    (§ ass ___ret ___form)
                )
                :else
                (do
                    (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___form))
                )
            )

            (when (and (§ instance? IObj ___form) (some? (RT'meta ___form)))
                ;; filter line and column numbers
                (let [#_"IPersistentMap" ___newMeta (ß (cast' IObj ___form).meta().without(RT'LINE_KEY).without(RT'COLUMN_KEY))]
                    (when (pos? (count ___newMeta))
                        (§ return (ß RT'list-3(LispReader'WITH_META, ___ret, syntaxQuote((cast' IObj ___form).meta()))))
                    )
                )
            )
            ___ret
        )
    )

    (defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" ___seq]
        (let [#_"PersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [___seq ___seq] (some? ___seq) [(next ___seq)]
                (let [#_"Object" ___item (first ___seq)]
                    (cond (LispReader'isUnquote ___item)
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list-2(LispReader'LIST, RT'second(___item)))))
                        )
                        (LispReader'isUnquoteSplicing ___item)
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'second(___item))))
                        )
                        :else
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list-2(LispReader'LIST, syntaxQuote(___item)))))
                        )
                    )
                )
            )
            (.seq ___ret)
        )
    )

    (defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" ___form]
        (let [#_"IPersistentVector" ___keyvals PersistentVector'EMPTY]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(next ___s)]
                (let [#_"IMapEntry" ___e (cast' IMapEntry (first ___s))]
                    (§ ass ___keyvals (cast' IPersistentVector (.cons ___keyvals, (.key ___e))))
                    (§ ass ___keyvals (cast' IPersistentVector (.cons ___keyvals, (.val ___e))))
                )
            )
            ___keyvals
        )
    )
)

#_closure
(class-ns UnquoteReader (§ extends AFn)
    (defn #_"UnquoteReader" UnquoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"UnquoteReader" this, #_"Object" ___reader, #_"Object" ___comma, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___ch (LispReader'read1 ___r)]
                (when (= ___ch -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (§ ass ___pendingForms (LispReader'ensurePending ___pendingForms))
                (if (ß ___ch == \@)
                    (do
                        (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE_SPLICING, ___o)
                        )
                    )
                    (do
                        (LispReader'unread ___r, ___ch)
                        (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE, ___o)
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispCharacterReader (§ extends AFn)
    (defn #_"LispCharacterReader" LispCharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___ch (LispReader'read1 ___r)]
                (when (= ___ch -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                    (cond (ß (.length ___token) == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (.equals ___token, "newline")
                        (do
                            (§ return \newline)
                        )
                        (.equals ___token, "space")
                        (do
                            (§ return \space)
                        )
                        (.equals ___token, "tab")
                        (do
                            (§ return \tab)
                        )
                        (.equals ___token, "backspace")
                        (do
                            (§ return \backspace)
                        )
                        (.equals ___token, "formfeed")
                        (do
                            (§ return \formfeed)
                        )
                        (.equals ___token, "return")
                        (do
                            (§ return \return)
                        )
                        (.startsWith ___token, "u")
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (and (ß ___c >= (§ char "\ud800")) (ß ___c <= (§ char "\udfff"))) ;; surrogate code unit?
                                    (throw (Util'runtimeException-1 (str "Invalid character constant: \\u" (Integer/toString ___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (.startsWith ___token, "o")
                        (do
                            (let [#_"int" ___len (ß (.length ___token) - 1)]
                                (when (> ___len 3)
                                    (throw (Util'runtimeException-1 (str "Invalid octal escape sequence length: " ___len)))
                                )
                                (let [#_"int" ___uc (readUnicodeChar ___token, 1, ___len, 8)]
                                    (when (> ___uc 0377)
                                        (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (Util'runtimeException-1 (str "Unsupported character: \\" ___token)))
                )
            )
        )
    )
)

#_closure
(class-ns LispListReader (§ extends AFn)
    (defn #_"LispListReader" LispListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (§ instance? LineNumberingPushbackReader ___r)
                        (§ ass ___line (.getLineNumber (cast' LineNumberingPushbackReader ___r)))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts, LispReader'ensurePending(___pendingForms)))]
                        (when (.isEmpty ___list)
                            (§ return PersistentList'EMPTY)
                        )
                        (let [#_"IObj" ___s (cast' IObj (PersistentList'create ___list))]
                            (if (not= ___line -1)
                                (do
                                    (ß ___s.withMeta(RT'map(
                                        (object-array [
                                            RT'LINE_KEY   ___line
                                            RT'COLUMN_KEY ___column
                                        ])
                                    )))
                                )
                                (do
                                    ___s
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EvalReader (§ extends AFn)
    (defn #_"EvalReader" EvalReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EvalReader" this, #_"Object" ___reader, #_"Object" ___eq, #_"Object" ___opts, #_"Object" ___pendingForms]
        (when (not (ß RT'booleanCast-1o(RT'READEVAL.deref())))
            (throw (Util'runtimeException-1 "EvalReader not allowed when *read-eval* is false."))
        )

        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (LispReader'ensurePending ___pendingForms))]
                (cond (§ instance? Symbol ___o)
                    (do
                        (ß RT'classForName-1((.toString ___o)))
                    )
                    (§ instance? IPersistentList ___o)
                    (do
                        (let [#_"Symbol" ___fs (cast' Symbol (RT'first ___o))]
                            (when (.equals ___fs, LispReader'THE_VAR)
                                (let [#_"Symbol" ___vs (cast' Symbol (RT'second ___o))]
                                    (§ return (ß RT'var-2((:ns ___vs), (:name ___vs))))
                                )
                            )
                            (when (.endsWith (:name ___fs), ".")
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeConstructor(RT'classForName-1((:name ___fs).substring(0, (:name ___fs).length() - 1)), ___args)))
                                )
                            )
                            (when (Compiler'namesStaticMember ___fs)
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeStaticMethod-3s((:ns ___fs), (:name ___fs), ___args)))
                                )
                            )
                            (let [#_"Object" ___v (ß Compiler'maybeResolveIn(Compiler'currentNS(), ___fs))]
                                (when (§ instance? Var ___v)
                                    (§ return (ß (cast' IFn ___v).applyTo(RT'next(___o))))
                                )
                                (throw (Util'runtimeException-1 (str "Can't resolve " ___fs)))
                            )
                        )
                    )
                    :else
                    (do
                        (throw (IllegalArgumentException. "Unsupported #= form"))
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispVectorReader (§ extends AFn)
    (defn #_"LispVectorReader" LispVectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts, LispReader'ensurePending(___pendingForms))))
        )
    )
)

#_closure
(class-ns LispMapReader (§ extends AFn)
    (defn #_"LispMapReader" LispMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts, LispReader'ensurePending(___pendingForms)).toArray())]
                (when (ß ((§ alength ___a) & 1) == 1)
                    (throw (Util'runtimeException-1 "Map literal must contain an even number of forms"))
                )
                (RT'map ___a)
            )
        )
    )
)

#_closure
(class-ns LispSetReader (§ extends AFn)
    (defn #_"LispSetReader" LispSetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (ß PersistentHashSet'createWithCheck-1l(readDelimitedList(\}, ___r, true, ___opts, LispReader'ensurePending(___pendingForms))))
        )
    )
)

#_closure
(class-ns LispUnmatchedDelimiterReader (§ extends AFn)
    (defn #_"LispUnmatchedDelimiterReader" LispUnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (Util'runtimeException-1 (str "Unmatched delimiter: " ___rightdelim)))
    )
)

#_closure
(class-ns LispUnreadableReader (§ extends AFn)
    (defn #_"LispUnreadableReader" LispUnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (Util'runtimeException-1 "Unreadable form"))
    )
)

#_closure
(class-ns CtorReader (§ extends AFn)
    (defn #_"CtorReader" CtorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"CtorReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (§ ass ___pendingForms (LispReader'ensurePending ___pendingForms))
            (let [#_"Object" ___name (LispReader'read-6 ___r, true, nil, false, ___opts, ___pendingForms)]
                (when (not (§ instance? Symbol ___name))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (cast' Symbol ___name)]
                    (let [#_"Object" ___form (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                        (if (or (isPreserveReadCond ___opts) (RT'suppressRead))
                            (do
                                (TaggedLiteral'create ___sym, ___form)
                            )
                            (do
                                (if (ß (.getName ___sym).contains(".")) (.readRecord this, ___form, ___sym, ___opts, ___pendingForms) (.readTagged this, ___form, ___sym, ___opts, ___pendingForms))
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method readTagged) [#_"CtorReader" this, #_"Object" ___o, #_"Symbol" ___tag, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"ILookup" ___data_readers (cast' ILookup (.deref RT'DATA_READERS))]
            (let [#_"IFn" ___data_reader (cast' IFn (RT'get-2 ___data_readers, ___tag))]
                (when (nil? ___data_reader)
                    (§ ass ___data_readers (cast' ILookup (.deref RT'DEFAULT_DATA_READERS)))
                    (§ ass ___data_reader (cast' IFn (RT'get-2 ___data_readers, ___tag)))
                    (when (nil? ___data_reader)
                        (let [#_"IFn" ___default_reader (cast' IFn (.deref RT'DEFAULT_DATA_READER_FN))]
                            (if (some? ___default_reader)
                                (do
                                    (§ return (.invoke ___default_reader, ___tag, ___o))
                                )
                                (do
                                    (throw (RuntimeException. (str "No reader function for tag " (.toString ___tag))))
                                )
                            )
                        )
                    )
                )

                (.invoke ___data_reader, ___o)
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method readRecord) [#_"CtorReader" this, #_"Object" ___form, #_"Symbol" ___recordName, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"boolean" ___readeval (ß RT'booleanCast-1o(RT'READEVAL.deref()))]
            (when (not ___readeval)
                (throw (Util'runtimeException-1 "Record construction syntax can only be used when *read-eval* == true"))
            )

            (let [#_"Class" ___recordClass (RT'classForNameNonLoading (.toString ___recordName))]
                (let [#_"boolean" ___shortForm true]
                    (cond (§ instance? IPersistentMap ___form)
                        (do
                            (§ ass ___shortForm false)
                        )
                        (§ instance? IPersistentVector ___form)
                        (do
                            (§ ass ___shortForm true)
                        )
                        :else
                        (do
                            (throw (Util'runtimeException-1 (str "Unreadable constructor form starting with \"#" ___recordName "\"")))
                        )
                    )

                    (let [#_"Object" ___ret nil]
                        (let [#_"Constructor[]" ___allctors (.getConstructors (cast Class ___recordClass))]
                            (if ___shortForm
                                (do
                                    (let [#_"IPersistentVector" ___recordEntries (cast' IPersistentVector ___form)]
                                        (let [#_"boolean" ___ctorFound false]
                                            (doseq [#_"Constructor" ___ctor ___allctors]
                                                (when (ß (§ alength (.getParameterTypes ___ctor)) == (count ___recordEntries))
                                                    (§ ass ___ctorFound true)
                                                )
                                            )

                                            (when (not ___ctorFound)
                                                (throw (Util'runtimeException-1 (str "Unexpected number of constructor arguments to " (.toString ___recordClass) ": got " (count ___recordEntries))))
                                            )

                                            (§ ass ___ret (ß Reflector'invokeConstructor(___recordClass, RT'toArray(___recordEntries))))
                                        )
                                    )
                                )
                                (do
                                    (let [#_"IPersistentMap" ___vals (cast' IPersistentMap ___form)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'keys ___vals)] (some? ___s) [(next ___s)]
                                            (when (not (§ instance? Keyword (first ___s)))
                                                (throw (Util'runtimeException-1 (str "Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " (.toString (first ___s)))))
                                            )
                                        )
                                        (§ ass ___ret (ß Reflector'invokeStaticMethod-3c(___recordClass, "create", (object-array [ ___vals ]))))
                                    )
                                )
                            )

                            ___ret
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ConditionalReader (§ extends AFn)
    (defn #_"ConditionalReader" ConditionalReader'new []
        (AFn'new)
    )

    (def- #_"Object" ConditionalReader'READ_STARTED (Object.))
    (§ def #_"Keyword" ConditionalReader'DEFAULT_FEATURE (Keyword'intern-2 nil, "default"))
    (def #_"IPersistentSet" ConditionalReader'RESERVED_FEATURES (ß RT'set(Keyword'intern-2(nil, "else"), Keyword'intern-2(nil, "none"))))

    (defn #_"boolean" ConditionalReader'hasFeature [#_"Object" ___feature, #_"Object" ___opts]
        (when (not (§ instance? Keyword ___feature))
            (throw (Util'runtimeException-1 (str "Feature should be a keyword: " ___feature)))
        )

        (when (.equals ConditionalReader'DEFAULT_FEATURE, ___feature)
            (§ return true)
        )

        (let [#_"IPersistentSet" ___custom (cast' IPersistentSet (.valAt (cast' IPersistentMap ___opts), LispReader'OPT_FEATURES))]
            (and (some? ___custom) (.contains ___custom, ___feature))
        )
    )

    (defn #_"Object" ConditionalReader'readCondDelimited [#_"PushbackReader" ___r, #_"boolean" ___splicing, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Object" ___result ConditionalReader'READ_STARTED]
            (§ let [#_"Object" ___form] ;; The most recently ready form
                (let [#_"boolean" ___toplevel (nil? ___pendingForms)]
                    (§ ass ___pendingForms (LispReader'ensurePending ___pendingForms))

                    (let [#_"int" ___firstline (if (§ instance? LineNumberingPushbackReader ___r) (.getLineNumber (cast' LineNumberingPushbackReader ___r)) -1)]
                        (while true
                            (when (= ___result ConditionalReader'READ_STARTED)
                                ;; Read the next feature
                                (§ ass ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, nil))

                                (cond (= ___form LispReader'READ_EOF)
                                    (do
                                        (if (< ___firstline 0)
                                            (do
                                                (throw (Util'runtimeException-1 "EOF while reading"))
                                            )
                                            (do
                                                (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                            )
                                        )
                                    )
                                    (= ___form LispReader'READ_FINISHED)
                                    (do
                                        (§ break ) ;; read-cond form is done
                                    )
                                )

                                (when (.contains ConditionalReader'RESERVED_FEATURES, ___form)
                                    (throw (Util'runtimeException-1 (str "Feature name " ___form " is reserved.")))
                                )

                                (when (hasFeature ___form, ___opts)
                                    ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                    (§ ass ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, (cast' Resolver (.deref RT'READER_RESOLVER))))

                                    (cond (= ___form LispReader'READ_EOF)
                                        (do
                                            (if (< ___firstline 0)
                                                (do
                                                    (throw (Util'runtimeException-1 "EOF while reading"))
                                                )
                                                (do
                                                    (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                                )
                                            )
                                        )
                                        (= ___form LispReader'READ_FINISHED)
                                        (do
                                            (if (< ___firstline 0)
                                                (do
                                                    (throw (Util'runtimeException-1 "read-cond requires an even number of forms."))
                                                )
                                                (do
                                                    (throw (Util'runtimeException-1 (str "read-cond starting on line " ___firstline " requires an even number of forms")))
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            (§ ass ___result ___form)
                                        )
                                    )
                                )
                            )

                            ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                            (try
                                (ß Var'pushThreadBindings(RT'map(RT'SUPPRESS_READ, RT'T)))
                                (§ ass ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, (cast' Resolver (.deref RT'READER_RESOLVER))))

                                (cond (= ___form LispReader'READ_EOF)
                                    (do
                                        (if (< ___firstline 0)
                                            (do
                                                (throw (Util'runtimeException-1 "EOF while reading"))
                                            )
                                            (do
                                                (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                            )
                                        )
                                    )
                                    (= ___form LispReader'READ_FINISHED)
                                    (do
                                        (§ break )
                                    )
                                )
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                        )

                        (when (= ___result ConditionalReader'READ_STARTED) ;; no features matched
                            (§ return ___r)
                        )

                        (if ___splicing
                            (do
                                (when (not (instance? List ___result))
                                    (throw (Util'runtimeException-1 "Spliced form list in read-cond-splicing must implement java.util.List"))
                                )

                                (when ___toplevel
                                    (throw (Util'runtimeException-1 "Reader conditional splicing not allowed at the top level."))
                                )

                                (ß (cast List ___pendingForms).addAll(0, (cast List ___result)))

                                ___r
                            )
                            (do
                                ___result
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" ConditionalReader'checkConditionalAllowed [#_"Object" ___opts]
        (let [#_"IPersistentMap" ___mopts (cast' IPersistentMap ___opts)]
            (when (not (and (some? ___opts) (or (ß LispReader'COND_ALLOW.equals(___mopts.valAt(LispReader'OPT_READ_COND))) (ß LispReader'COND_PRESERVE.equals(___mopts.valAt(LispReader'OPT_READ_COND))))))
                (throw (Util'runtimeException-1 "Conditional read not allowed"))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ConditionalReader" this, #_"Object" ___reader, #_"Object" ___mode, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ConditionalReader'checkConditionalAllowed ___opts)

        (let [#_"PushbackReader" ___r (cast PushbackReader ___reader)]
            (let [#_"int" ___ch (LispReader'read1 ___r)]
                (when (= ___ch -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )

                (let [#_"boolean" ___splicing false]
                    (when (ß ___ch == \@)
                        (§ ass ___splicing true)
                        (§ ass ___ch (LispReader'read1 ___r))
                    )

                    (while (LispReader'isWhitespace ___ch)
                        (§ ass ___ch (LispReader'read1 ___r))
                    )

                    (when (= ___ch -1)
                        (throw (Util'runtimeException-1 "EOF while reading character"))
                    )

                    (when (ß ___ch != \()
                        (throw (Util'runtimeException-1 "read-cond body must be a list"))
                    )

                    (try
                        (ß Var'pushThreadBindings(RT'map(LispReader'READ_COND_ENV, RT'T)))

                        (if (isPreserveReadCond ___opts)
                            (do
                                (let [#_"IFn" ___listReader (EdnReader'getMacro ___ch)] ;; should always be a list
                                    (let [#_"Object" ___form (ß ___listReader.invoke(___r, ___ch, ___opts, LispReader'ensurePending(___pendingForms)))]
                                        (ReaderConditional'create ___form, ___splicing)
                                    )
                                )
                            )
                            (do
                                (readCondDelimited ___r, ___splicing, ___opts, ___pendingForms)
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" LispReader'QUOTE (Symbol'intern-1 "quote"))
    (§ def #_"Symbol" LispReader'THE_VAR (Symbol'intern-1 "var"))

    (§ def #_"Symbol" LispReader'UNQUOTE (Symbol'intern-2 "cloiure.core", "unquote"))
    (§ def #_"Symbol" LispReader'UNQUOTE_SPLICING (Symbol'intern-2 "cloiure.core", "unquote-splicing"))
    (§ def #_"Symbol" LispReader'CONCAT (Symbol'intern-2 "cloiure.core", "concat"))
    (§ def #_"Symbol" LispReader'SEQ (Symbol'intern-2 "cloiure.core", "seq"))
    (§ def #_"Symbol" LispReader'LIST (Symbol'intern-2 "cloiure.core", "list"))
    (§ def #_"Symbol" LispReader'APPLY (Symbol'intern-2 "cloiure.core", "apply"))
    (§ def #_"Symbol" LispReader'HASHMAP (Symbol'intern-2 "cloiure.core", "hash-map"))
    (§ def #_"Symbol" LispReader'HASHSET (Symbol'intern-2 "cloiure.core", "hash-set"))
    (§ def #_"Symbol" LispReader'VECTOR (Symbol'intern-2 "cloiure.core", "vector"))
    (§ def #_"Symbol" LispReader'WITH_META (Symbol'intern-2 "cloiure.core", "with-meta"))
    (§ def #_"Symbol" LispReader'META (Symbol'intern-2 "cloiure.core", "meta"))
    (§ def #_"Symbol" LispReader'DEREF (Symbol'intern-2 "cloiure.core", "deref"))
    (§ def #_"Symbol" LispReader'READ_COND (Symbol'intern-2 "cloiure.core", "read-cond"))
    (§ def #_"Symbol" LispReader'READ_COND_SPLICING (Symbol'intern-2 "cloiure.core", "read-cond-splicing"))
    (§ def #_"Keyword" LispReader'UNKNOWN (Keyword'intern-2 nil, "unknown"))

    (def #_"IFn[]" LispReader'macros (§ typeless make-array IFn 256))
    (def #_"IFn[]" LispReader'dispatchMacros (§ typeless make-array IFn 256))

    (def #_"Pattern" LispReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" LispReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" LispReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" LispReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def #_"Var" LispReader'GENSYM_ENV (ß Var'create-1(nil).setDynamic()))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" LispReader'ARG_ENV (ß Var'create-1(nil).setDynamic()))
    (§ def #_"IFn" LispReader'ctorReader (CtorReader'new))

    ;; Dynamic var set to true in a read-cond context
    (§ def #_"Var" LispReader'READ_COND_ENV (ß Var'create-1(nil).setDynamic()))

    (§ static
        (§ ass (ß macros[\"]) (LispStringReader'new)) ;; oops! "
        (§ ass (ß macros[\;]) (LispCommentReader'new))
        (§ ass (ß macros[\']) (WrappingReader'new LispReader'QUOTE))
        (§ ass (ß macros[\@]) (WrappingReader'new LispReader'DEREF))
        (§ ass (ß macros[\^]) (LispMetaReader'new))
        (§ ass (ß macros[\`]) (SyntaxQuoteReader'new))
        (§ ass (ß macros[\~]) (UnquoteReader'new))
        (§ ass (ß macros[\(]) (LispListReader'new))
        (§ ass (ß macros[\)]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\[]) (LispVectorReader'new))
        (§ ass (ß macros[\]]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\{]) (LispMapReader'new))
        (§ ass (ß macros[\}]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\\]) (LispCharacterReader'new))
        (§ ass (ß macros[\%]) (ArgReader'new))
        (§ ass (ß macros[\#]) (LispDispatchReader'new))

        (§ ass (ß dispatchMacros[\^]) (LispMetaReader'new))
        (§ ass (ß dispatchMacros[\#]) (LispSymbolicValueReader'new))
        (§ ass (ß dispatchMacros[\']) (VarReader'new))
        (§ ass (ß dispatchMacros[\"]) (RegexReader'new)) ;; oops! "
        (§ ass (ß dispatchMacros[\(]) (FnReader'new))
        (§ ass (ß dispatchMacros[\{]) (LispSetReader'new))
        (§ ass (ß dispatchMacros[\=]) (EvalReader'new))
        (§ ass (ß dispatchMacros[\!]) (LispCommentReader'new))
        (§ ass (ß dispatchMacros[\<]) (LispUnreadableReader'new))
        (§ ass (ß dispatchMacros[\_]) (LispDiscardReader'new))
        (§ ass (ß dispatchMacros[\?]) (ConditionalReader'new))
        (§ ass (ß dispatchMacros[\:]) (LispNamespaceMapReader'new))
    )

    (defn #_"boolean" LispReader'isWhitespace [#_"int" ___ch]
        (or (Character/isWhitespace ___ch) (ß ___ch == \,))
    )

    (defn #_"void" LispReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (not= ___ch -1)
            (try
                (.unread ___r, ___ch)
                (catch IOException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
        )
        nil
    )

    (defn #_"int" LispReader'read1 [#_"Reader" ___r]
        (try
            (.read ___r)
            (catch IOException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" LispReader'OPT_EOF (Keyword'intern-2 nil, "eof"))
    (§ def #_"Keyword" LispReader'OPT_FEATURES (Keyword'intern-2 nil, "features"))
    (§ def #_"Keyword" LispReader'OPT_READ_COND (Keyword'intern-2 nil, "read-cond"))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" LispReader'EOFTHROW (Keyword'intern-2 nil, "eofthrow"))

    ;; Platform features - always installed
    (§ def- #_"Keyword" LispReader'PLATFORM_KEY (Keyword'intern-2 nil, "cli"))
    (§ def- #_"Object" LispReader'PLATFORM_FEATURES (PersistentHashSet'create-1a LispReader'PLATFORM_KEY))

    ;; Reader conditional options - use with :read-cond
    (§ def #_"Keyword" LispReader'COND_ALLOW (Keyword'intern-2 nil, "allow"))
    (§ def #_"Keyword" LispReader'COND_PRESERVE (Keyword'intern-2 nil, "preserve"))

    (defn #_"Object" LispReader'read-2 [#_"PushbackReader" ___r, #_"Object" ___opts]
        (let [#_"boolean" ___eofIsError true]
            (let [#_"Object" ___eofValue nil]
                (when (and (some? ___opts) (§ instance? IPersistentMap ___opts))
                    (let [#_"Object" ___eof (.valAt (cast' IPersistentMap ___opts), LispReader'OPT_EOF, LispReader'EOFTHROW)]
                        (when (not (.equals LispReader'EOFTHROW, ___eof))
                            (§ ass ___eofIsError false)
                            (§ ass ___eofValue ___eof)
                        )
                    )
                )
                (LispReader'read-5 ___r, ___eofIsError, ___eofValue, false, ___opts)
            )
        )
    )

    (defn #_"Object" LispReader'read-4 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive]
        (LispReader'read-5 ___r, ___eofIsError, ___eofValue, ___isRecursive, PersistentHashMap'EMPTY)
    )

    (defn #_"Object" LispReader'read-5 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (LispReader'read-9 ___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, nil, (cast' Resolver (.deref RT'READER_RESOLVER)))
    )

    (defn- #_"Object" LispReader'read-6 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (LispReader'read-9 ___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, (LispReader'ensurePending ___pendingForms), (cast' Resolver (.deref RT'READER_RESOLVER)))
    )

    (defn- #_"Object" LispReader'ensurePending [#_"Object" ___pendingForms]
        (if (nil? ___pendingForms)
            (do
                (LinkedList.)
            )
            (do
                ___pendingForms
            )
        )
    )

    (defn- #_"Object" LispReader'installPlatformFeature [#_"Object" ___opts]
        (if (nil? ___opts)
            (do
                (RT'mapUniqueKeys LispReader'OPT_FEATURES, LispReader'PLATFORM_FEATURES)
            )
            (do
                (let [#_"IPersistentMap" ___mopts (cast' IPersistentMap ___opts)]
                    (let [#_"Object" ___features (.valAt ___mopts, LispReader'OPT_FEATURES)]
                        (if (nil? ___features)
                            (do
                                (.assoc ___mopts, LispReader'OPT_FEATURES, LispReader'PLATFORM_FEATURES)
                            )
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, RT'conj((cast' IPersistentSet ___features), LispReader'PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'read-9 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"Character" ___returnOn, #_"Object" ___returnOnValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms, #_"Resolver" ___resolver]
        (when (ß RT'READEVAL.deref() == LispReader'UNKNOWN)
            (throw (Util'runtimeException-1 "Reading disallowed - *read-eval* bound to :unknown"))
        )

        (§ ass ___opts (installPlatformFeature ___opts))

        (try
            (while true
                (when (and (instance? List ___pendingForms) (not (.isEmpty (cast List ___pendingForms))))
                    (§ return (.remove (cast List ___pendingForms), 0))
                )

                (let [#_"int" ___ch (LispReader'read1 ___r)]
                    (while (LispReader'isWhitespace ___ch)
                        (§ ass ___ch (LispReader'read1 ___r))
                    )

                    (when (= ___ch -1)
                        (when ___eofIsError
                            (throw (Util'runtimeException-1 "EOF while reading"))
                        )
                        (§ return ___eofValue)
                    )

                    (when (and (some? ___returnOn) (ß (.charValue ___returnOn) == ___ch))
                        (§ return ___returnOnValue)
                    )

                    (when (Character/isDigit ___ch)
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (EdnReader'getMacro ___ch)]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts, ___pendingForms))]
                                ;; no op macros return the reader
                                (when (= ___ret ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (or (ß ___ch == \+) (ß ___ch == \-))
                            (let [#_"int" ___ch2 (LispReader'read1 ___r)]
                                (when (Character/isDigit ___ch2)
                                    (LispReader'unread ___r, ___ch2)
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (§ return ___n)
                                    )
                                )
                                (LispReader'unread ___r, ___ch2)
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                            (§ return (interpretToken ___token, ___resolver))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (or ___isRecursive (not (§ instance? LineNumberingPushbackReader ___r)))
                    (throw (Util'sneakyThrow ___e))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (cast' LineNumberingPushbackReader ___r)]
                    (throw (ß LispReaderException'new((.getLineNumber ___rdr), (.getColumnNumber ___rdr), ___e)))
                )
            )
        )
    )

    (defn- #_"String" LispReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (LispReader'read1 ___r)]
                    (when (or (ß ___ch == -1) (LispReader'isWhitespace ___ch) (LispReader'isTerminatingMacro ___ch))
                        (LispReader'unread ___r, ___ch)
                        (§ return (.toString ___sb))
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (defn- #_"Object" LispReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (LispReader'read1 ___r)]
                    (when (or (ß ___ch == -1) (LispReader'isWhitespace ___ch) (LispReader'isMacro ___ch))
                        (LispReader'unread ___r, ___ch)
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (.toString ___sb)]
                (let [#_"Object" ___n (LispReader'matchNumber ___s)]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (str "Invalid number: " ___s)))
                    )
                    ___n
                )
            )
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-4 [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß (.length ___token) != ___offset + ___length)
            (throw (IllegalArgumentException. (str "Invalid unicode character: \\" ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [#_"int" ___i ___offset] (ß ___i < ___offset + ___length) [(inc ___i)]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (= ___d -1)
                        (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt ___token, ___i))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-5 [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (Character/digit ___initch, ___base)]
            (when (= ___uc -1)
                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___initch))))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [___i ___i] (< ___i ___length) [(inc ___i)]
                    (let [#_"int" ___ch (LispReader'read1 ___r)]
                        (when (or (ß ___ch == -1) (LispReader'isWhitespace ___ch) (LispReader'isMacro ___ch))
                            (LispReader'unread ___r, ___ch)
                            (§ break )
                        )
                        (let [#_"int" ___d (Character/digit ___ch, ___base)]
                            (when (= ___d -1)
                                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___ch))))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (and (ß ___i != ___length) ___exact)
                    (throw (IllegalArgumentException. (str "Invalid character length: " ___i ", should be: " ___length)))
                )
                ___uc
            )
        )
    )

    (defn- #_"Object" LispReader'interpretToken [#_"String" ___s, #_"Resolver" ___resolver]
        (cond (.equals ___s, "nil")
            (do
                (§ return nil)
            )
            (.equals ___s, "true")
            (do
                (§ return RT'T)
            )
            (.equals ___s, "false")
            (do
                (§ return RT'F)
            )
        )
        (let [#_"Object" ___ret nil]
            (§ ass ___ret (matchSymbol ___s, ___resolver))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (Util'runtimeException-1 (str "Invalid token: " ___s)))
        )
    )

    (defn- #_"Object" LispReader'matchSymbol [#_"String" ___s, #_"Resolver" ___resolver]
        (let [#_"Matcher" ___m (.matcher LispReader'symbolPat, ___s)]
            (when (.matches ___m)
                (let [#_"int" ___gc (.groupCount ___m)]
                    (let [#_"String" ___ns (.group ___m, 1)]
                        (let [#_"String" ___name (.group ___m, 2)]
                            (when (or (and (some? ___ns) (.endsWith ___ns, ":/")) (.endsWith ___name, ":") (ß (.indexOf ___s, "::", 1) != -1))
                                (§ return nil)
                            )
                            (when (.startsWith ___s, "::")
                                (let [#_"Symbol" ___ks (ß Symbol'intern-1(___s.substring(2)))]
                                    (if (some? ___resolver)
                                        (do
                                            (§ let [#_"Symbol" ___nsym]
                                                (if (ß (some? (:ns ___ks)))
                                                    (do
                                                        (§ ass ___nsym (ß ___resolver.resolveAlias(Symbol'intern-1((:ns ___ks)))))
                                                    )
                                                    (do
                                                        (§ ass ___nsym (.currentNS ___resolver))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___nsym)
                                                    (do
                                                        (§ return (ß Keyword'intern-2((:name ___nsym), (:name ___ks))))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" ___kns]
                                                (if (ß (some? (:ns ___ks)))
                                                    (do
                                                        (§ ass ___kns (ß Compiler'currentNS().lookupAlias(Symbol'intern-1((:ns ___ks)))))
                                                    )
                                                    (do
                                                        (§ ass ___kns (Compiler'currentNS))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___kns)
                                                    (do
                                                        (§ return (ß Keyword'intern-2((:name (:name ___kns)), (:name ___ks))))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" ___isKeyword (ß (___s.charAt(0) == \:))]
                                (let [#_"Symbol" ___sym (Symbol'intern-1 (.substring ___s, (if ___isKeyword 1 0)))]
                                    (when ___isKeyword
                                        (§ return (Keyword'intern ___sym))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"Object" LispReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (.matcher LispReader'intPat, ___s)]
            (when (.matches ___m)
                (when (some? (.group ___m, 2))
                    (when (some? (.group ___m, 8))
                        (§ return BigInt'ZERO)
                    )
                    (§ return (Numbers'num-1l 0))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (.group ___m, 3)))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (.group ___m, 4)))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (.group ___m, 5)))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (.group ___m, 7)))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (BigInteger. ___n, ___radix)]
                                (when ___negate
                                    (§ ass ___bn (.negate ___bn))
                                )
                                (when (some? (.group ___m, 8))
                                    (§ return (BigInt'fromBigInteger ___bn))
                                )
                                (§ return (if (< (.bitLength ___bn) 64) (Numbers'num-1l (.longValue ___bn)) (BigInt'fromBigInteger ___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (.matcher LispReader'floatPat, ___s))
            (when (.matches ___m)
                (when (some? (.group ___m, 4))
                    (§ return (§ unsure BigDecimal. (.group ___m, 1)))
                )
                (§ return (Double/parseDouble ___s))
            )
            (§ ass ___m (.matcher LispReader'ratioPat, ___s))
            (when (.matches ___m)
                (let [#_"String" ___numerator (.group ___m, 1)]
                    (when (.startsWith ___numerator, "+")
                        (§ ass ___numerator (.substring ___numerator, 1))
                    )
                    (§ return (ß Numbers'divide-2oo(Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. ___numerator))), Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. (.group ___m, 2)))))))
                )
            )
            nil
        )
    )

    (defn- #_"IFn" LispReader'getMacro [#_"int" ___ch]
        (when (< ___ch (§ alength macros))
            (§ return (§ aget macros ___ch))
        )
        nil
    )

    (defn- #_"boolean" LispReader'isMacro [#_"int" ___ch]
        (and (< ___ch (§ alength macros)) (some? (§ aget macros ___ch)))
    )

    (defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ___ch]
        (and (ß ___ch != \#) (ß ___ch != \') (ß ___ch != \%) (LispReader'isMacro ___ch))
    )

    (defn #_"Symbol" LispReader'garg [#_"int" ___n]
        (Symbol'intern-2 nil, (str (if (= ___n -1) "rest" (str "p" ___n)) "__" (RT'nextID) "#"))
    )

    (defn #_"Symbol" LispReader'registerArg [#_"int" ___n]
        (let [#_"PersistentTreeMap" ___argsyms (cast' PersistentTreeMap (.deref LispReader'ARG_ENV))]
            (when (nil? ___argsyms)
                (throw (IllegalStateException. "arg literal not in #()"))
            )
            (let [#_"Symbol" ___ret (cast' Symbol (.valAt ___argsyms, ___n))]
                (when (nil? ___ret)
                    (§ ass ___ret (garg ___n))
                    (ß LispReader'ARG_ENV.set(___argsyms.assoc(___n, ___ret)))
                )
                ___ret
            )
        )
    )

    (defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" ___form]
        (and (§ instance? ISeq ___form) (Util'equals (RT'first ___form), LispReader'UNQUOTE_SPLICING))
    )

    (defn #_"boolean" LispReader'isUnquote [#_"Object" ___form]
        (and (§ instance? ISeq ___form) (Util'equals (RT'first ___form), LispReader'UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (def- #_"Object" LispReader'READ_EOF (Object.))
    (def- #_"Object" LispReader'READ_FINISHED (Object.))

    (defn #_"List" LispReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___firstline (if (§ instance? LineNumberingPushbackReader ___r) (.getLineNumber (cast' LineNumberingPushbackReader ___r)) -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (let [#_"Resolver" ___resolver (cast' Resolver (.deref RT'READER_RESOLVER))]
                    (while true
                        (let [#_"Object" ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, ___delim, LispReader'READ_FINISHED, ___isRecursive, ___opts, ___pendingForms, ___resolver)]
                            (cond (= ___form LispReader'READ_EOF)
                                (do
                                    (if (< ___firstline 0)
                                        (do
                                            (throw (Util'runtimeException-1 "EOF while reading"))
                                        )
                                        (do
                                            (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                        )
                                    )
                                )
                                (= ___form LispReader'READ_FINISHED)
                                (do
                                    (§ return ___a)
                                )
                            )

                            (.add ___a, ___form)
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" LispReader'isPreserveReadCond [#_"Object" ___opts]
        (if (and (RT'booleanCast-1o (.deref LispReader'READ_COND_ENV)) (§ instance? IPersistentMap ___opts))
            (do
                (let [#_"Object" ___readCond (.valAt (cast' IPersistentMap ___opts), LispReader'OPT_READ_COND)]
                    (.equals LispReader'COND_PRESERVE, ___readCond)
                )
            )
            (do
                false
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(class-ns RetryEx (§ extends Error)
    (defn #_"RetryEx" RetryEx'new []
        (§ foreign Error'new)
    )
)

(class-ns AbortException (§ extends Exception)
    (defn #_"AbortException" AbortException'new []
        (§ foreign Exception'new)
    )
)

(class-ns LockingTransactionInfo
    (defn- #_"LockingTransactionInfo" LockingTransactionInfo'init []
        (hash-map
            #_"AtomicInteger" :status nil
            #_"long" :startPoint 0
            #_"CountDownLatch" :latch nil
        )
    )

    (defn #_"LockingTransactionInfo" LockingTransactionInfo'new [#_"int" ___status, #_"long" ___startPoint]
        (let [this (LockingTransactionInfo'init)]
            (§ ass (:status this) (AtomicInteger. ___status))
            (§ ass (:startPoint this) ___startPoint)
            (§ ass (:latch this) (CountDownLatch. 1))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method running) [#_"LockingTransactionInfo" this]
        (let [#_"int" ___s (.get (:status this))]
            (or (ß ___s == LockingTransaction'RUNNING) (ß ___s == LockingTransaction'COMMITTING))
        )
    )
)

(class-ns CFn
    (defn- #_"CFn" CFn'init []
        (hash-map
            #_"IFn" :fn nil
            #_"ISeq" :args nil
        )
    )

    (defn #_"CFn" CFn'new [#_"IFn" ___fn, #_"ISeq" ___args]
        (let [this (CFn'init)]
            (§ ass (:fn this) ___fn)
            (§ ass (:args this) ___args)
            this
        )
    )
)

(class-ns Notify
    (defn- #_"Notify" Notify'init []
        (hash-map
            #_"Ref" :ref nil
            #_"Object" :oldval nil
            #_"Object" :newval nil
        )
    )

    (defn #_"Notify" Notify'new [#_"Ref" ___ref, #_"Object" ___oldval, #_"Object" ___newval]
        (let [this (Notify'init)]
            (§ ass (:ref this) ___ref)
            (§ ass (:oldval this) ___oldval)
            (§ ass (:newval this) ___newval)
            this
        )
    )
)

(class-ns LockingTransaction
    (def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (def #_"long" LockingTransaction'BARGE_WAIT_NANOS (* 10 1000000))

    (def #_"int" LockingTransaction'RUNNING 0)
    (def #_"int" LockingTransaction'COMMITTING 1)
    (def #_"int" LockingTransaction'RETRY 2)
    (def #_"int" LockingTransaction'KILLED 3)
    (def #_"int" LockingTransaction'COMMITTED 4)

    (def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ThreadLocal.))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (defn- #_"LockingTransaction" LockingTransaction'init []
        (hash-map
            #_"LockingTransactionInfo" :info nil
            #_"long" :readPoint 0
            #_"long" :startPoint 0
            #_"long" :startTime 0

            #_"RetryEx" :retryex (RetryEx'new)
            #_"ArrayList<AgentAction>" :actions (ArrayList.)
            #_"HashMap<Ref, Object>" :vals (HashMap.)
            #_"HashSet<Ref>" :sets (HashSet.)
            #_"TreeMap<Ref, ArrayList<CFn>>" :commutes (TreeMap.)

            #_"HashSet<Ref>" :ensures (HashSet.) ;; all hold readLock
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'new []
        (LockingTransaction'init)
    )

    #_method
    (§ defn #_"void" (§ method getReadPoint) [#_"LockingTransaction" this]
        (§ ass (:readPoint this) (.incrementAndGet lastPoint))
        nil
    )

    #_method
    (§ defn #_"long" (§ method getCommitPoint) [#_"LockingTransaction" this]
        (.incrementAndGet lastPoint)
    )

    #_method
    (§ defn #_"void" (§ method stop) [#_"LockingTransaction" this, #_"int" ___status]
        (when (some? (:info this))
            (§ sync (:info this)
                (.set (:status (:info this)), ___status)
                (.countDown (:latch (:info this)))
            )
            (§ ass (:info this) nil)
            (.clear (:vals this))
            (.clear (:sets this))
            (.clear (:commutes this))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method tryWriteLock) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (try
            (when (not (ß (:lock ___ref).writeLock().tryLock(LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS)))
                (throw (:retryex this))
            )
            (catch InterruptedException ___e
                (throw (:retryex this))
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" (§ method lock) [#_"LockingTransaction" this, #_"Ref" ___ref]
        ;; can't upgrade readLock, so release it
        (.releaseIfEnsured this, ___ref)

        (let [#_"boolean" ___unlocked true]
            (try
                (.tryWriteLock this, ___ref)
                (§ ass ___unlocked false)

                (when (and (some? (:tvals ___ref)) (< (:readPoint this) (:point (:tvals ___ref))))
                    (throw (:retryex this))
                )
                (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
                    ;; write lock conflict
                    (when (and (some? ___refinfo) (ß ___refinfo != (:info this)) (.running ___refinfo))
                        (when (not (.barge this, ___refinfo))
                            (ß (:lock ___ref).writeLock().unlock())
                            (§ ass ___unlocked true)
                            (§ return (.blockAndBail this, ___refinfo))
                        )
                    )
                    (§ ass (:tinfo ___ref) (:info this))
                    (when (some? (:tvals ___ref)) (:val (:tvals ___ref)))
                )
                (finally
                    (when (not ___unlocked)
                        (ß (:lock ___ref).writeLock().unlock())
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method blockAndBail) [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        ;; stop prior to blocking
        (.stop this, LockingTransaction'RETRY)
        (try
            (.await (:latch ___refinfo), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS)
            (catch InterruptedException ___e
                ;; ignore
            )
        )
        (throw (:retryex this))
    )

    #_method
    (§ defn- #_"void" (§ method releaseIfEnsured) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (.contains (:ensures this), ___ref)
            (.remove (:ensures this), ___ref)
            (ß (:lock ___ref).readLock().unlock())
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method abort) [#_"LockingTransaction" this] #_(§ throws AbortException)
        (.stop this, LockingTransaction'KILLED)
        (throw (AbortException'new))
    )

    #_method
    (§ defn- #_"boolean" (§ method bargeTimeElapsed) [#_"LockingTransaction" this]
        (ß (System/nanoTime() - (:startTime this) > LockingTransaction'BARGE_WAIT_NANOS))
    )

    #_method
    (§ defn- #_"boolean" (§ method barge) [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        (let [#_"boolean" ___barged false]
            ;; if this transaction is older, try to abort the other
            (when (and (.bargeTimeElapsed this) (< (:startPoint this) (:startPoint ___refinfo)))
                (§ ass ___barged (.compareAndSet (:status ___refinfo), LockingTransaction'RUNNING, LockingTransaction'KILLED))
                (when ___barged
                    (.countDown (:latch ___refinfo))
                )
            )
            ___barged
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" ___t (.get LockingTransaction'transaction)]
            (when (or (nil? ___t) (nil? (:info ___t)))
                (throw (IllegalStateException. "No transaction running"))
            )
            ___t
        )
    )

    (defn #_"boolean" LockingTransaction'isRunning []
        (some? (LockingTransaction'getRunning))
    )

    (defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" ___t (.get LockingTransaction'transaction)]
            (when (or (nil? ___t) (nil? (:info ___t)))
                (§ return nil)
            )
            ___t
        )
    )

    (defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"LockingTransaction" ___t (.get LockingTransaction'transaction)]
            (§ let [#_"Object" ___ret]
                (if (nil? ___t)
                    (do
                        (ß LockingTransaction'transaction.set(§ ass ___t (LockingTransaction'new)))
                        (try
                            (§ ass ___ret (.run ___t, ___fn))
                            (finally
                                (.remove LockingTransaction'transaction)
                            )
                        )
                    )
                    (do
                        (if (ß (some? (:info ___t)))
                            (do
                                (§ ass ___ret (.call ___fn))
                            )
                            (do
                                (§ ass ___ret (.run ___t, ___fn))
                            )
                        )
                    )
                )

                ___ret
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method run) [#_"LockingTransaction" this, #_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"boolean" ___done false]
            (let [#_"Object" ___ret nil]
                (let [#_"ArrayList<Ref>" ___locked (ArrayList.)]
                    (let [#_"ArrayList<Notify>" ___notify (ArrayList.)]
                        (loop-when-recur [#_"int" ___i 0] (and (not ___done) (< ___i LockingTransaction'RETRY_LIMIT)) [(inc ___i)]
                            (try
                                (.getReadPoint this)
                                (when (zero? ___i)
                                    (§ ass (:startPoint this) (:readPoint this))
                                    (§ ass (:startTime this) (System/nanoTime))
                                )
                                (§ ass (:info this) (LockingTransactionInfo'new LockingTransaction'RUNNING, (:startPoint this)))
                                (§ ass ___ret (.call ___fn))
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß (:status (:info this)).compareAndSet(LockingTransaction'RUNNING, LockingTransaction'COMMITTING))
                                    (doseq [#_"Map$Entry<Ref, ArrayList<CFn>>" ___e (.entrySet (:commutes this))]
                                        (let [#_"Ref" ___ref (.getKey ___e)]
                                            (when (.contains (:sets this), ___ref)
                                                (§ continue )
                                            )

                                            (let [#_"boolean" ___wasEnsured (.contains (:ensures this), ___ref)]
                                                ;; can't upgrade readLock, so release it
                                                (.releaseIfEnsured this, ___ref)
                                                (.tryWriteLock this, ___ref)
                                                (.add ___locked, ___ref)
                                                (when (and ___wasEnsured (some? (:tvals ___ref)) (< (:readPoint this) (:point (:tvals ___ref))))
                                                    (throw (:retryex this))
                                                )

                                                (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
                                                    (when (and (some? ___refinfo) (ß ___refinfo != (:info this)) (.running ___refinfo))
                                                        (when (not (.barge this, ___refinfo))
                                                            (throw (:retryex this))
                                                        )
                                                    )
                                                    (let [#_"Object" ___val (when (some? (:tvals ___ref)) (:val (:tvals ___ref)))]
                                                        (.put (:vals this), ___ref, ___val)
                                                        (doseq [#_"CFn" ___f (.getValue ___e)]
                                                            (ß (:vals this).put(___ref, (:fn ___f).applyTo(RT'cons((:vals this).get(___ref), (:args ___f)))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ___ref (:sets this)]
                                        (.tryWriteLock this, ___ref)
                                        (.add ___locked, ___ref)
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map$Entry<Ref, Object>" ___e (.entrySet (:vals this))]
                                        (let [#_"Ref" ___ref (.getKey ___e)]
                                            (ß ___ref.validate((.getValidator ___ref), (.getValue ___e)))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" ___commitPoint (.getCommitPoint this)]
                                        (doseq [#_"Map$Entry<Ref, Object>" ___e (.entrySet (:vals this))]
                                            (let [#_"Ref" ___ref (.getKey ___e)]
                                                (let [#_"Object" ___oldval (when (some? (:tvals ___ref)) (:val (:tvals ___ref)))]
                                                    (let [#_"Object" ___newval (.getValue ___e)]
                                                        (let [#_"int" ___hcount (.histCount ___ref)]
                                                            (cond (ß (nil? (:tvals ___ref)))
                                                                (do
                                                                    (§ ass (:tvals ___ref) (RefTVal'new-2 ___newval, ___commitPoint))
                                                                )
                                                                (or (and (pos? (.get (:faults ___ref))) (< ___hcount (:maxHistory ___ref))) (< ___hcount (:minHistory ___ref)))
                                                                (do
                                                                    (§ ass (:tvals ___ref) (ß RefTVal'new-3(___newval, ___commitPoint, (:tvals ___ref))))
                                                                    (.set (:faults ___ref), 0)
                                                                )
                                                                :else
                                                                (do
                                                                    (§ ass (:tvals ___ref) (:next (:tvals ___ref)))
                                                                    (§ ass (:val (:tvals ___ref)) ___newval)
                                                                    (§ ass (:point (:tvals ___ref)) ___commitPoint)
                                                                )
                                                            )
                                                            (when (pos? (.count (.getWatches ___ref)))
                                                                (ß ___notify.add(Notify'new(___ref, ___oldval, ___newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (§ ass ___done true)
                                        (.set (:status (:info this)), LockingTransaction'COMMITTED)
                                    )
                                )
                                (§ catch RetryEx ___retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [#_"int" ___k (ß (.size ___locked) - 1)] (>= ___k 0) [(dec ___k)]
                                        (ß (:lock (.get ___locked, ___k)).writeLock().unlock())
                                    )
                                    (.clear ___locked)
                                    (doseq [#_"Ref" ___r (:ensures this)]
                                        (ß (:lock ___r).readLock().unlock())
                                    )
                                    (.clear (:ensures this))
                                    (.stop this, (if ___done LockingTransaction'COMMITTED LockingTransaction'RETRY))
                                    (try
                                        (when ___done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" ___n ___notify]
                                                (ß (:ref ___n).notifyWatches((:oldval ___n), (:newval ___n)))
                                            )
                                            (doseq [#_"AgentAction" ___action (:actions this)]
                                                (Agent'dispatchAction ___action)
                                            )
                                        )
                                        (finally
                                            (.clear ___notify)
                                            (.clear (:actions this))
                                        )
                                    )
                                )
                            )
                        )
                        (when (not ___done)
                            (throw (Util'runtimeException-1 "Transaction failed after reaching retry limit"))
                        )
                        ___ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method enqueue) [#_"LockingTransaction" this, #_"AgentAction" ___action]
        (.add (:actions this), ___action)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method doGet) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (not (.running (:info this)))
            (throw (:retryex this))
        )
        (when (.containsKey (:vals this), ___ref)
            (§ return (.get (:vals this), ___ref))
        )
        (try
            (ß (:lock ___ref).readLock().lock())
            (when (ß (nil? (:tvals ___ref)))
                (throw (IllegalStateException. (str (.toString ___ref) " is unbound.")))
            )
            (let [#_"RefTVal" ___ver (:tvals ___ref)]
                (§ loop
                    (when (ß (:point ___ver) <= (:readPoint this))
                        (§ return (:val ___ver))
                    )
                    (§ recur-if ((§ ass ___ver (:prior ___ver)) != (:tvals ___ref)))
                )
            )
            (finally
                (ß (:lock ___ref).readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (.incrementAndGet (:faults ___ref))
        (throw (:retryex this))
    )

    #_method
    (§ defn #_"Object" (§ method doSet) [#_"LockingTransaction" this, #_"Ref" ___ref, #_"Object" ___val]
        (when (not (.running (:info this)))
            (throw (:retryex this))
        )
        (when (.containsKey (:commutes this), ___ref)
            (throw (IllegalStateException. "Can't set after commute"))
        )
        (when (not (.contains (:sets this), ___ref))
            (.add (:sets this), ___ref)
            (.lock this, ___ref)
        )
        (.put (:vals this), ___ref, ___val)
        ___val
    )

    #_method
    (§ defn #_"void" (§ method doEnsure) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (not (.running (:info this)))
            (throw (:retryex this))
        )
        (when (.contains (:ensures this), ___ref)
            (§ return nil)
        )
        (ß (:lock ___ref).readLock().lock())

        ;; someone completed a write after our snapshot
        (when (and (some? (:tvals ___ref)) (< (:readPoint this) (:point (:tvals ___ref))))
            (ß (:lock ___ref).readLock().unlock())
            (throw (:retryex this))
        )

        (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
            ;; writer exists
            (if (and (some? ___refinfo) (.running ___refinfo))
                (do
                    (ß (:lock ___ref).readLock().unlock())

                    (when (ß ___refinfo != (:info this)) ;; not us, ensure is doomed
                        (.blockAndBail this, ___refinfo)
                    )
                )
                (do
                    (.add (:ensures this), ___ref)
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method doCommute) [#_"LockingTransaction" this, #_"Ref" ___ref, #_"IFn" ___fn, #_"ISeq" ___args]
        (when (not (.running (:info this)))
            (throw (:retryex this))
        )
        (when (not (.containsKey (:vals this), ___ref))
            (let [#_"Object" ___val nil]
                (try
                    (ß (:lock ___ref).readLock().lock())
                    (§ ass ___val (when (some? (:tvals ___ref)) (:val (:tvals ___ref))))
                    (finally
                        (ß (:lock ___ref).readLock().unlock())
                    )
                )
                (.put (:vals this), ___ref, ___val)
            )
        )
        (let [#_"ArrayList<CFn>" ___fns (.get (:commutes this), ___ref)]
            (when (nil? ___fns)
                (ß (:commutes this).put(___ref, (§ ass ___fns (ArrayList.))))
            )
            (ß ___fns.add(CFn'new(___fn, ___args)))
            (let [#_"Object" ___ret (ß ___fn.applyTo(RT'cons((:vals this).get(___ref), ___args)))]
                (.put (:vals this), ___ref, ___ret)
                ___ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_private
(§ defprotocol LongRangeBoundsCheck
    #_abstract
    (#_"boolean" LongRangeBoundsCheck'''(§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" ___val])
)

#_non-static
(class-ns LongRangeIterator (§ implements Iterator)
    (defn- #_"LongRangeIterator" LongRangeIterator'init []
        (hash-map
            #_"long" :next 0
            #_"boolean" :hasNext false
        )
    )

    (defn #_"LongRangeIterator" LongRangeIterator'new []
        (let [this (LongRangeIterator'init)]
            (§ ass (:next this) (:start this))
            (§ ass (:hasNext this) true)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"LongRangeIterator" this]
        (:hasNext this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"LongRangeIterator" this]
        (if (:hasNext this)
            (do
                (let [#_"long" ___ret (:next this)]
                    (try
                        (§ ass (:next this) (Numbers'add-2ll (:next this), (:step this)))
                        (§ ass (:hasNext this) (not (.exceededBounds (:boundsCheck this), (:next this))))
                        (catch ArithmeticException ___e
                            (§ ass (:hasNext this) false)
                        )
                    )
                    ___ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"LongRangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

#_private
(class-ns LongChunk (§ implements IChunk)
    (defn- #_"LongChunk" LongChunk'init []
        (hash-map
            #_"long" :start 0
            #_"long" :step 0
            #_"int" :count 0
        )
    )

    (defn #_"LongChunk" LongChunk'new [#_"long" ___start, #_"long" ___step, #_"int" ___count]
        (let [this (LongChunk'init)]
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:count this) ___count)
            this
        )
    )

    #_method
    (§ defn #_"long" (§ method first) [#_"LongChunk" this]
        (:start this)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"LongChunk" this, #_"int" ___i]
        (+ (:start this) (* ___i (:step this)))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"LongChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (and (<= 0 ___i) (< ___i (:count this)))
            (§ return (+ (:start this) (* ___i (:step this))))
        )
        ___notFound
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"LongChunk" this]
        (:count this)
    )

    #_method
    (§ defn #_"LongChunk" (§ method dropFirst) [#_"LongChunk" this]
        (when (ß (:count this) <= 1)
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß LongChunk'new((:start this) + (:step this), (:step this), (:count this) - 1))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongChunk" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"long" ___x (:start this)]
            (let [#_"Object" ___ret ___init]
                (loop-when-recur [#_"int" ___i 0] (< ___i (:count this)) [(inc ___i)]
                    (§ ass ___ret (.invoke ___f, ___ret, ___x))
                    (when (RT'isReduced ___ret)
                        (§ return ___ret)
                    )
                    (§ ass ___x (+ ___x (:step this)))
                )
                ___ret
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (def- #_"int" LongRange'CHUNK_SIZE 32)

    (defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (>= ___val ___end)
            )
        )
    )

    (defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (<= ___val ___end)
            )
        )
    )

    (defn- #_"LongRange" LongRange'init []
        (hash-map
            ;; Invariants guarantee this is never an empty or infinite seq
            #_"long" :start 0
            #_"long" :end 0
            #_"long" :step 0
            #_"LongRangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"LongChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"LongRange" LongRange'new-4 [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-6 [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-7 [#_"IPersistentMap" ___meta, #_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new ___meta) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn #_"ISeq" LongRange'create-1 [#_"long" ___end]
        (when (> ___end 0)
            (§ return (ß LongRange'new-4(0, ___end, 1, LongRange'positiveStep(___end))))
        )
        PersistentList'EMPTY
    )

    (defn #_"ISeq" LongRange'create-2 [#_"long" ___start, #_"long" ___end]
        (when (>= ___start ___end)
            (§ return PersistentList'EMPTY)
        )
        (ß LongRange'new-4(___start, ___end, 1, LongRange'positiveStep(___end)))
    )

    (defn #_"ISeq" LongRange'create-3 [#_"long" ___start, #_"long" ___end, #_"long" ___step]
        (cond (> ___step 0)
            (do
                (when (<= ___end ___start)
                    (§ return PersistentList'EMPTY)
                )
                (ß LongRange'new-4(___start, ___end, ___step, LongRange'positiveStep(___end)))
            )
            (< ___step 0)
            (do
                (when (>= ___end ___start)
                    (§ return PersistentList'EMPTY)
                )
                (ß LongRange'new-4(___start, ___end, ___step, LongRange'negativeStep(___end)))
            )
            :else
            (do
                (when (= ___end ___start)
                    (§ return PersistentList'EMPTY)
                )
                (Repeat'create-1 ___start)
            )
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"LongRange" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (LongRange'new-7 ___meta, (:start this), (:end this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"LongRange" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" (§ method forceChunk) [#_"LongRange" this]
        (when (some? (:_chunk this))
            (§ return nil)
        )

        (§ let [#_"long" ___count]
            (try
                (§ ass ___count (.rangeCount this, (:start this), (:end this), (:step this)))
                (catch ArithmeticException ___e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (§ ass ___count (.steppingCount this, (:start this), (:end this), (:step this)))
                )
            )

            (cond (> ___count LongRange'CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" ___nextStart (ß (:start this) + ((:step this) * LongRange'CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass (:_chunkNext this) (LongRange'new-4 ___nextStart, (:end this), (:step this), (:boundsCheck this)))
                        (§ ass (:_chunk this) (LongChunk'new (:start this), (:step this), LongRange'CHUNK_SIZE))
                    )
                )
                :else ;; last chunk
                (do
                    (§ ass (:_chunk this) (ß LongChunk'new((:start this), (:step this), (int) ___count))) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"LongRange" this]
        (when (some? (:_next this))
            (§ return (:_next this))
        )

        (.forceChunk this)
        (when (ß (:_chunk this).count() > 1)
            (let [#_"LongChunk" ___smallerChunk (.dropFirst (:_chunk this))]
                (§ ass (:_next this) (ß LongRange'new-6((first ___smallerChunk), (:end this), (:step this), (:boundsCheck this), ___smallerChunk, (:_chunkNext this))))
                (§ return (:_next this))
            )
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"LongRange" this]
        (.forceChunk this)
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"LongRange" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"LongRange" this]
        (.forceChunk this)
        (when (nil? (:_chunkNext this))
            (§ return PersistentList'EMPTY)
        )
        (:_chunkNext this)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" (§ method steppingCount) [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        (let [#_"long" ___count 1]
            (let [#_"long" ___s ___start]
                (while (<= ___count LongRange'CHUNK_SIZE)
                    (try
                        (§ ass ___s (Numbers'add-2ll ___s, ___step))
                        (if (.exceededBounds (:boundsCheck this), ___s)
                            (do
                                (§ break )
                            )
                            (do
                                (§ ass ___count (inc ___count))
                            )
                        )
                        (catch ArithmeticException ___e
                            (§ break )
                        )
                    )
                )
                ___count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" (§ method rangeCount) [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (/ (Numbers'add-2ll (Numbers'add-2ll (Numbers'minus-2ll ___end, ___start), ___step), (if (pos? (:step this)) -1 1)) ___step)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"LongRange" this]
        (try
            (let [#_"long" ___c (.rangeCount this, (:start this), (:end this), (:step this))]
                (if (> ___c Integer/MAX_VALUE)
                    (do
                        (Numbers'throwIntOverflow)
                    )
                    (do
                        (ß (int) ___c)
                    )
                )
            )
            (catch ArithmeticException ___e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" ___iter (.iterator this)]
                    (let [#_"long" ___count 0]
                        (while (.hasNext ___iter)
                            (next ___iter)
                            (§ ass ___count (inc ___count))
                        )

                        (if (> ___count Integer/MAX_VALUE)
                            (do
                                (Numbers'throwIntOverflow)
                            )
                            (do
                                (ß (int)___count)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongRange" this, #_"IFn" ___f]
        (let [#_"Object" ___acc (:start this)]
            (let [#_"long" ___i (+ (:start this) (:step this))]
                (while (not (.exceededBounds (:boundsCheck this), ___i))
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (§ instance? Reduced ___acc)
                        (§ return (.deref (cast' Reduced ___acc)))
                    )
                    (§ ass ___i (+ ___i (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongRange" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"long" ___i (:start this)]
                (§ loop
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (RT'isReduced ___acc)
                        (§ return (.deref (cast' Reduced ___acc)))
                    )
                    (§ ass ___i (+ ___i (:step this)))
                    (§ recur-if (not (.exceededBounds (:boundsCheck this), ___i)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"LongRange" this]
        (LongRangeIterator'new)
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (defn #_"MapEntry" MapEntry'create [#_"Object" ___key, #_"Object" ___val]
        (MapEntry'new ___key, ___val)
    )

    (defn- #_"MapEntry" MapEntry'init []
        (hash-map
            #_"Object" :_key nil
            #_"Object" :_val nil
        )
    )

    (defn #_"MapEntry" MapEntry'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (AMapEntry'new) (MapEntry'init))]
            (§ ass (:_key this) ___key)
            (§ ass (:_val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method key) [#_"MapEntry" this]
        (:_key this)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"MapEntry" this]
        (:_val this)
    )

    #_method
    (§ defn #_"Object" (§ method getKey) [#_"MapEntry" this]
        (.key this)
    )

    #_method
    (§ defn #_"Object" (§ method getValue) [#_"MapEntry" this]
        (.val this)
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ defprotocol MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns Entry
    (defn- #_"Entry" Entry'init []
        (hash-map
            #_"Class" :c nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"Entry" Entry'new [#_"Class" ___c, #_"IFn" ___fn]
        (let [this (Entry'init)]
            (§ ass (:c this) ___c)
            (§ ass (:fn this) ___fn)
            this
        )
    )
)

(class-ns MethodImplCache
    (defn- #_"MethodImplCache" MethodImplCache'init []
        (hash-map
            #_"IPersistentMap" :protocol nil
            #_"Keyword" :methodk nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"Object[]" :table nil ;; [class, entry. class, entry ...]
            #_"Map" :map nil

            #_"Entry" :mre nil
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-2 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk]
        (MethodImplCache'new-5 ___protocol, ___methodk, 0, 0, RT'EMPTY_ARRAY)
    )

    (defn #_"MethodImplCache" MethodImplCache'new-5 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"int" ___shift, #_"int" ___mask, #_"Object[]" ___table]
        (let [this (MethodImplCache'init)]
            (§ ass (:protocol this) ___protocol)
            (§ ass (:methodk this) ___methodk)
            (§ ass (:shift this) ___shift)
            (§ ass (:mask this) ___mask)
            (§ ass (:table this) ___table)
            (§ ass (:map this) nil)
            this
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-3 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"Map" ___map]
        (let [this (MethodImplCache'init)]
            (§ ass (:protocol this) ___protocol)
            (§ ass (:methodk this) ___methodk)
            (§ ass (:shift this) 0)
            (§ ass (:mask this) 0)
            (§ ass (:table this) nil)
            (§ ass (:map this) ___map)
            this
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fnFor) [#_"MethodImplCache" this, #_"Class" ___c]
        (let [#_"Entry" ___last (:mre this)]
            (when (and (some? ___last) (ß (:c ___last) == ___c))
                (§ return (:fn ___last))
            )
            (.findFnFor this, ___c)
        )
    )

    #_method
    (§ defn #_"IFn" (§ method findFnFor) [#_"MethodImplCache" this, #_"Class" ___c]
        (if (some? (:map this))
            (do
                (let [#_"Entry" ___e (cast' Entry (.get (:map this), ___c))]
                    (§ ass (:mre this) ___e)
                    (when (some? ___e) (:fn ___e))
                )
            )
            (do
                (let [#_"int" ___idx (ß ((Util'hash(___c) >> (:shift this)) & (:mask this)) << 1)]
                    (when (and (< ___idx (§ alength (:table this))) (ß (§ aget (:table this) ___idx) == ___c))
                        (let [#_"Entry" ___e (ß (cast' Entry (§ aget (:table this) (ß ___idx + 1))))]
                            (§ ass (:mre this) ___e)
                            (§ return (when (some? ___e) (:fn ___e)))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" MultiFn'assoc (RT'var-2 "cloiure.core", "assoc"))
    (§ def #_"Var" MultiFn'dissoc (RT'var-2 "cloiure.core", "dissoc"))
    (§ def #_"Var" MultiFn'isa (RT'var-2 "cloiure.core", "isa?"))
    (§ def #_"Var" MultiFn'parents (RT'var-2 "cloiure.core", "parents"))

    (defn- #_"MultiFn" MultiFn'init []
        (hash-map
            #_"IFn" :dispatchFn nil
            #_"Object" :defaultDispatchVal nil
            #_"IRef" :hierarchy nil
            #_"String" :name nil
            #_"ReentrantReadWriteLock" :rw nil

            #_volatile
            #_"IPersistentMap" :methodTable nil
            #_volatile
            #_"IPersistentMap" :preferTable nil
            #_volatile
            #_"IPersistentMap" :methodCache nil
            #_volatile
            #_"Object" :cachedHierarchy nil
        )
    )

    (defn #_"MultiFn" MultiFn'new [#_"String" ___name, #_"IFn" ___dispatchFn, #_"Object" ___defaultDispatchVal, #_"IRef" ___hierarchy]
        (let [this (merge (AFn'new) (MultiFn'init))]
            (§ ass (:rw this) (ReentrantReadWriteLock.))
            (§ ass (:name this) ___name)
            (§ ass (:dispatchFn this) ___dispatchFn)
            (§ ass (:defaultDispatchVal this) ___defaultDispatchVal)
            (§ ass (:methodTable this) PersistentHashMap'EMPTY)
            (§ ass (:methodCache this) (.getMethodTable this))
            (§ ass (:preferTable this) PersistentHashMap'EMPTY)
            (§ ass (:hierarchy this) ___hierarchy)
            (§ ass (:cachedHierarchy this) nil)
            this
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method reset) [#_"MultiFn" this]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (§ ass (:methodCache this) (§ ass (:preferTable this) PersistentHashMap'EMPTY)))
            (§ ass (:cachedHierarchy this) nil)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method addMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal, #_"IFn" ___method]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (ß (.getMethodTable this).assoc(___dispatchVal, ___method)))
            (.resetCache this)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method removeMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (ß (.getMethodTable this).without(___dispatchVal)))
            (.resetCache this)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method preferMethod) [#_"MultiFn" this, #_"Object" ___dispatchValX, #_"Object" ___dispatchValY]
        (ß (:rw this).writeLock().lock())
        (try
            (when (.prefers this, ___dispatchValY, ___dispatchValX)
                (throw (IllegalStateException. (String/format "Preference conflict in multimethod '%s': %s is already preferred to %s", (object-array [ (:name this), ___dispatchValY, ___dispatchValX ]))))
            )
            (§ ass (:preferTable this) (ß (.getPreferTable this).assoc(___dispatchValX, RT'conj((cast' IPersistentCollection (ß RT'get-3((.getPreferTable this), ___dispatchValX, PersistentHashSet'EMPTY))), ___dispatchValY))))
            (.resetCache this)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method prefers) [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (let [#_"IPersistentSet" ___xprefs (cast' IPersistentSet (ß (.getPreferTable this).valAt(___x)))]
            (when (and (some? ___xprefs) (.contains ___xprefs, ___y))
                (§ return true)
            )
            (loop-when-recur [#_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___y)))] (some? ___ps) [(next ___ps)]
                (when (ß this.prefers(___x, (first ___ps)))
                    (§ return true)
                )
            )
            (loop-when-recur [#_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___x)))] (some? ___ps) [(next ___ps)]
                (when (ß this.prefers((first ___ps), ___y))
                    (§ return true)
                )
            )
            false
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method isA) [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß RT'booleanCast-1o(isa.invoke((:hierarchy this).deref(), ___x, ___y)))
    )

    #_method
    (§ defn- #_"boolean" (§ method dominates) [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (or (.prefers this, ___x, ___y) (.isA this, ___x, ___y))
    )

    #_method
    (§ defn- #_"IPersistentMap" (§ method resetCache) [#_"MultiFn" this]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodCache this) (.getMethodTable this))
            (§ ass (:cachedHierarchy this) (.deref (:hierarchy this)))
            (:methodCache this)
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method getMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (when (ß (:cachedHierarchy this) != (:hierarchy this).deref())
            (.resetCache this)
        )
        (let [#_"IFn" ___targetFn (cast' IFn (.valAt (:methodCache this), ___dispatchVal))]
            (when (some? ___targetFn)
                (§ return ___targetFn)
            )
            (.findAndCacheBestMethod this, ___dispatchVal)
        )
    )

    #_method
    (§ defn- #_"IFn" (§ method getFn) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (let [#_"IFn" ___targetFn (.getMethod this, ___dispatchVal)]
            (when (nil? ___targetFn)
                (throw (IllegalArgumentException. (String/format "No method in multimethod '%s' for dispatch value: %s", (object-array [ (:name this), ___dispatchVal ]))))
            )
            ___targetFn
        )
    )

    #_method
    (§ defn- #_"IFn" (§ method findAndCacheBestMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß (:rw this).readLock().lock())
        (§ let [#_"Object" ___bestValue]
            (let [#_"IPersistentMap" ___mt (:methodTable this)]
                (let [#_"IPersistentMap" ___pt (:preferTable this)]
                    (let [#_"Object" ___ch (:cachedHierarchy this)]
                        (try
                            (let [#_"Map$Entry" ___bestEntry nil]
                                (doseq [#_"Object" ___o (.getMethodTable this)]
                                    (let [#_"Map$Entry" ___e (cast Map$Entry ___o)]
                                        (when (ß this.isA(___dispatchVal, (.getKey ___e)))
                                            (when (or (nil? ___bestEntry) (.dominates this, (.getKey ___e), (.getKey ___bestEntry)))
                                                (§ ass ___bestEntry ___e)
                                            )
                                            (when (not (.dominates this, (.getKey ___bestEntry), (.getKey ___e)))
                                                (throw (IllegalArgumentException. (String/format "Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", (object-array [ (:name this), ___dispatchVal, (.getKey ___e), (.getKey ___bestEntry) ]))))
                                            )
                                        )
                                    )
                                )
                                (if (nil? ___bestEntry)
                                    (do
                                        (§ ass ___bestValue (.valAt (:methodTable this), (:defaultDispatchVal this)))
                                        (when (nil? ___bestValue)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (§ ass ___bestValue (.getValue ___bestEntry))
                                    )
                                )
                            )
                            (finally
                                (ß (:rw this).readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß (:rw this).writeLock().lock())
                        (try
                            (if (and (ß ___mt == (:methodTable this)) (ß ___pt == (:preferTable this)) (ß ___ch == (:cachedHierarchy this)) (ß (:cachedHierarchy this) == (.deref (:hierarchy this))))
                                (do
                                    ;; place in cache
                                    (§ ass (:methodCache this) (.assoc (:methodCache this), ___dispatchVal, ___bestValue))
                                    (cast' IFn ___bestValue)
                                )
                                (do
                                    (.resetCache this)
                                    (.findAndCacheBestMethod this, ___dispatchVal)
                                )
                            )
                            (finally
                                (ß (:rw this).writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this]
        (ß this.getFn((:dispatchFn this).invoke()).invoke())
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1]
        (ß this.getFn((:dispatchFn this).invoke(___arg1)).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil)), Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                    ___args))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getMethodTable) [#_"MultiFn" this]
        (:methodTable this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getPreferTable) [#_"MultiFn" this]
        (:preferTable this)
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (def- #_"int" Murmur3'seed 0)
    (def- #_"int" Murmur3'C1 0xcc9e2d51)
    (def- #_"int" Murmur3'C2 0x1b873593)

    (defn #_"int" Murmur3'hashInt [#_"int" ___input]
        (when (zero? ___input)
            (§ return 0)
        )
        (let [#_"int" ___k1 (Murmur3'mixK1 ___input)]
            (let [#_"int" ___h1 (Murmur3'mixH1 Murmur3'seed, ___k1)]
                (Murmur3'fmix ___h1, 4)
            )
        )
    )

    (defn #_"int" Murmur3'hashLong [#_"long" ___input]
        (when (zero? ___input)
            (§ return 0)
        )
        (let [#_"int" ___low (ß (int) ___input)]
            (let [#_"int" ___high (ß (int) (___input >>> 32))]
                (let [#_"int" ___k1 (Murmur3'mixK1 ___low)]
                    (let [#_"int" ___h1 (Murmur3'mixH1 Murmur3'seed, ___k1)]
                        (§ ass ___k1 (Murmur3'mixK1 ___high))
                        (§ ass ___h1 (Murmur3'mixH1 ___h1, ___k1))

                        (Murmur3'fmix ___h1, 8)
                    )
                )
            )
        )
    )

    (defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" ___input]
        (let [#_"int" ___h1 Murmur3'seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [#_"int" ___i 1] (ß ___i < (.length ___input)) [(+ ___i 2)]
                (let [#_"int" ___k1 (ß ___input.charAt(___i - 1) | (___input.charAt(___i) << 16))]
                    (§ ass ___k1 (Murmur3'mixK1 ___k1))
                    (§ ass ___h1 (Murmur3'mixH1 ___h1, ___k1))
                )
            )

            ;; deal with any remaining characters
            (when (ß ((.length ___input) & 1) == 1)
                (let [#_"int" ___k1 (ß ___input.charAt((.length ___input) - 1))]
                    (§ ass ___k1 (Murmur3'mixK1 ___k1))
                    (§ ass ___h1 (ß ___h1 :xor ___k1))
                )
            )

            (ß Murmur3'fmix(___h1, 2 * (.length ___input)))
        )
    )

    (defn #_"int" Murmur3'mixCollHash [#_"int" ___hash, #_"int" ___count]
        (let [#_"int" ___h1 Murmur3'seed]
            (let [#_"int" ___k1 (Murmur3'mixK1 ___hash)]
                (§ ass ___h1 (Murmur3'mixH1 ___h1, ___k1))
                (Murmur3'fmix ___h1, ___count)
            )
        )
    )

    (defn #_"int" Murmur3'hashOrdered [#_"Iterable" ___xs]
        (let [#_"int" ___n 0]
            (let [#_"int" ___hash 1]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß 31 * ___hash + Util'hasheq(___x)))
                    (§ ass ___n (inc ___n))
                )

                (Murmur3'mixCollHash ___hash, ___n)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnordered [#_"Iterable" ___xs]
        (let [#_"int" ___hash 0]
            (let [#_"int" ___n 0]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß ___hash + Util'hasheq(___x)))
                    (§ ass ___n (inc ___n))
                )

                (Murmur3'mixCollHash ___hash, ___n)
            )
        )
    )

    (defn- #_"int" Murmur3'mixK1 [#_"int" ___k1]
        (§ ass ___k1 (ß ___k1 * Murmur3'C1))
        (§ ass ___k1 (Integer/rotateLeft ___k1, 15))
        (§ ass ___k1 (ß ___k1 * Murmur3'C2))
        ___k1
    )

    (defn- #_"int" Murmur3'mixH1 [#_"int" ___h1, #_"int" ___k1]
        (§ ass ___h1 (ß ___h1 :xor ___k1))
        (§ ass ___h1 (Integer/rotateLeft ___h1, 13))
        (§ ass ___h1 (ß ___h1 * 5 + 0xe6546b64))
        ___h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (defn- #_"int" Murmur3'fmix [#_"int" ___h1, #_"int" ___length]
        (§ ass ___h1 (ß ___h1 :xor ___length))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        (§ ass ___h1 (* ___h1 0x85ebca6b))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 13)))
        (§ ass ___h1 (* ___h1 0xc2b2ae35))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        ___h1
    )
)
)

(java-ns cloiure.lang.Named

(§ defprotocol Named
    #_abstract
    (#_"String" Named'''(§ method getNamespace) [#_"Named" this])
    #_abstract
    (#_"String" Named'''(§ method getName) [#_"Named" this])
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ConcurrentHashMap.))

    (defn- #_"Namespace" Namespace'init []
        (hash-map
            #_"Symbol" :name nil

            #_transient
            #_"AtomicReference<IPersistentMap>" :mappings (AtomicReference.)
            #_transient
            #_"AtomicReference<IPersistentMap>" :aliases (AtomicReference.)
        )
    )

    (defn #_"Namespace" Namespace'new [#_"Symbol" ___name]
        (let [this (merge (AReference'new (.meta ___name)) (Namespace'init))]
            (§ ass (:name this) ___name)
            (.set (:mappings this), RT'DEFAULT_IMPORTS)
            (ß (:aliases this).set(RT'map()))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Namespace" this]
        (.toString (:name this))
    )

    (defn #_"ISeq" Namespace'all []
        (RT'seq (.values Namespace'namespaces))
    )

    #_method
    (§ defn #_"Symbol" (§ method getName) [#_"Namespace" this]
        (:name this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getMappings) [#_"Namespace" this]
        (.get (:mappings this))
    )

    #_method
    (§ defn #_"Var" (§ method intern) [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß (some? (:ns ___sym)))
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (§ let [#_"Object" ___o]
                (let [#_"Var" ___v nil]
                    (while (nil? (§ ass ___o (.valAt ___map, ___sym)))
                        (when (nil? ___v)
                            (§ ass ___v (Var'new-2 this, ___sym))
                        )
                        (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___sym, ___v)]
                            (.compareAndSet (:mappings this), ___map, ___newMap)
                            (§ ass ___map (.getMappings this))
                        )
                    )
                    (when (and (§ instance? Var ___o) (ß (:ns (cast' Var ___o)) == this))
                        (§ return (cast' Var ___o))
                    )

                    (when (nil? ___v)
                        (§ ass ___v (Var'new-2 this, ___sym))
                    )

                    (.warnOrFailOnReplace this, ___sym, ___o, ___v)

                    (while (not (ß (:mappings this).compareAndSet(___map, ___map.assoc(___sym, ___v))))
                        (§ ass ___map (.getMappings this))
                    )

                    ___v
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" (§ method warnOrFailOnReplace) [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___o, #_"Object" ___v]
        (when (§ instance? Var ___o)
            (let [#_"Namespace" ___ns (:ns (cast' Var ___o))]
                (when (or (ß ___ns == this) (and (§ instance? Var ___v) (ß (:ns (cast' Var ___v)) == RT'CLOIURE_NS)))
                    (§ return nil)
                )
                (when (not= ___ns RT'CLOIURE_NS)
                    (throw (IllegalStateException. (str ___sym " already refers to: " ___o " in namespace: " (:name this))))
                )
            )
        )
        (.println (RT'errPrintWriter), (str "WARNING: " ___sym " already refers to: " ___o " in namespace: " (:name this) ", being replaced by: " ___v))
        nil
    )

    #_method
    (§ defn #_"Object" (§ method reference) [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___val]
        (when (ß (some? (:ns ___sym)))
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (§ let [#_"Object" ___o]
                (while (nil? (§ ass ___o (.valAt ___map, ___sym)))
                    (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___sym, ___val)]
                        (.compareAndSet (:mappings this), ___map, ___newMap)
                        (§ ass ___map (.getMappings this))
                    )
                )
                (when (= ___o ___val)
                    (§ return ___o)
                )

                (.warnOrFailOnReplace this, ___sym, ___o, ___val)

                (while (not (ß (:mappings this).compareAndSet(___map, ___map.assoc(___sym, ___val))))
                    (§ ass ___map (.getMappings this))
                )

                ___val
            )
        )
    )

    (defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" ___cls1, #_"Class" ___cls2]
        (and (ß ___cls1 != ___cls2) (.equals (.getName ___cls1), (.getName ___cls2)))
    )

    #_method
    (§ defn #_"Class" (§ method referenceClass) [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___val]
        (when (ß (some? (:ns ___sym)))
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (let [#_"Class" ___c (cast Class (.valAt ___map, ___sym))]
                (while (or (nil? ___c) (Namespace'areDifferentInstancesOfSameClassName ___c, ___val))
                    (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___sym, ___val)]
                        (.compareAndSet (:mappings this), ___map, ___newMap)
                        (§ ass ___map (.getMappings this))
                        (§ ass ___c (cast Class (.valAt ___map, ___sym)))
                    )
                )
                (when (= ___c ___val)
                    (§ return ___c)
                )

                (throw (IllegalStateException. (str ___sym " already refers to: " ___c " in namespace: " (:name this))))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method unmap) [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß (some? (:ns ___sym)))
            (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (while (.containsKey ___map, ___sym)
                (let [#_"IPersistentMap" ___newMap (.without ___map, ___sym)]
                    (.compareAndSet (:mappings this), ___map, ___newMap)
                    (§ ass ___map (.getMappings this))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Class" (§ method importClass) [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___c]
        (.referenceClass this, ___sym, ___c)
    )

    #_method
    (§ defn #_"Class" (§ method importClass) [#_"Namespace" this, #_"Class" ___c]
        (let [#_"String" ___n (.getName ___c)]
            (ß this.importClass(Symbol'intern-1(___n.substring(___n.lastIndexOf(\.) + 1)), ___c))
        )
    )

    #_method
    (§ defn #_"Var" (§ method refer) [#_"Namespace" this, #_"Symbol" ___sym, #_"Var" ___var]
        (cast' Var (.reference this, ___sym, ___var))
    )

    (defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" ___name]
        (let [#_"Namespace" ___ns (.get Namespace'namespaces, ___name)]
            (when (some? ___ns)
                (§ return ___ns)
            )
            (let [#_"Namespace" ___newns (Namespace'new ___name)]
                (§ ass ___ns (.putIfAbsent Namespace'namespaces, ___name, ___newns))
                (or ___ns ___newns)
            )
        )
    )

    (defn #_"Namespace" Namespace'remove [#_"Symbol" ___name]
        (when (.equals ___name, (:name RT'CLOIURE_NS))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (.remove Namespace'namespaces, ___name)
    )

    (defn #_"Namespace" Namespace'find [#_"Symbol" ___name]
        (.get Namespace'namespaces, ___name)
    )

    #_method
    (§ defn #_"Object" (§ method getMapping) [#_"Namespace" this, #_"Symbol" ___name]
        (ß (:mappings this).get().valAt(___name))
    )

    #_method
    (§ defn #_"Var" (§ method findInternedVar) [#_"Namespace" this, #_"Symbol" ___symbol]
        (let [#_"Object" ___o (ß (:mappings this).get().valAt(___symbol))]
            (when (and (some? ___o) (§ instance? Var ___o) (ß (:ns (cast' Var ___o)) == this))
                (§ return (cast' Var ___o))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getAliases) [#_"Namespace" this]
        (.get (:aliases this))
    )

    #_method
    (§ defn #_"Namespace" (§ method lookupAlias) [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (.getAliases this)]
            (cast' Namespace (.valAt ___map, ___alias))
        )
    )

    #_method
    (§ defn #_"void" (§ method addAlias) [#_"Namespace" this, #_"Symbol" ___alias, #_"Namespace" ___ns]
        (when (or (nil? ___alias) (nil? ___ns))
            (throw (NullPointerException. "Expecting Symbol + Namespace"))
        )
        (let [#_"IPersistentMap" ___map (.getAliases this)]
            (while (not (.containsKey ___map, ___alias))
                (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___alias, ___ns)]
                    (.compareAndSet (:aliases this), ___map, ___newMap)
                    (§ ass ___map (.getAliases this))
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (not (ß ___map.valAt(___alias).equals(___ns)))
                (throw (IllegalStateException. (str "Alias " ___alias " already exists in namespace " (:name this) ", aliasing " (.valAt ___map, ___alias))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method removeAlias) [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (.getAliases this)]
            (while (.containsKey ___map, ___alias)
                (let [#_"IPersistentMap" ___newMap (.without ___map, ___alias)]
                    (.compareAndSet (:aliases this), ___map, ___newMap)
                    (§ ass ___map (.getAliases this))
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(§ defprotocol Ops
    #_abstract
    (#_"Ops" Ops'''(§ method combine) [#_"Ops" this, #_"Ops" ___y])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithLong) [#_"Ops" this, #_"LongOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithDouble) [#_"Ops" this, #_"DoubleOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithRatio) [#_"Ops" this, #_"RatioOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithBigInt) [#_"Ops" this, #_"BigIntOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithBigDecimal) [#_"Ops" this, #_"BigDecimalOps" ___x])
    #_abstract
    (#_"boolean" Ops'''(§ method isZero) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''(§ method isPos) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''(§ method isNeg) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method add) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method addP) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method multiply) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method multiplyP) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method divide) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method quotient) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method remainder) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method equiv) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method lt) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method lte) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method gte) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method negate) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method negateP) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method inc) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method incP) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method dec) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method decP) [#_"Ops" this, #_"Number" ___x])
)

#_stateless
#_abstract
(class-ns OpsP (§ implements Ops)
    #_protected
    (defn #_"OpsP" OpsP'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Number" (§ method addP) [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (.add this, ___x, ___y)
    )

    #_method
    (§ defn #_"Number" (§ method multiplyP) [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (.multiply this, ___x, ___y)
    )

    #_method
    (§ defn #_"Number" (§ method negateP) [#_"OpsP" this, #_"Number" ___x]
        (.negate this, ___x)
    )

    #_method
    (§ defn #_"Number" (§ method incP) [#_"OpsP" this, #_"Number" ___x]
        (.inc this, ___x)
    )

    #_method
    (§ defn #_"Number" (§ method decP) [#_"OpsP" this, #_"Number" ___x]
        (.dec this, ___x)
    )
)

(class-ns LongOps (§ implements Ops)
    (defn #_"LongOps" LongOps'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"LongOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"RatioOps" ___x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"BigIntOps" ___x]
        Numbers'BIGINT_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"LongOps" this, #_"Number" ___x]
        (zero? (.longValue ___x))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"LongOps" this, #_"Number" ___x]
        (pos? (.longValue ___x))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"LongOps" this, #_"Number" ___x]
        (neg? (.longValue ___x))
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'add-2ll((.longValue ___x), (.longValue ___y))))
    )

    #_method
    (§ defn #_"Number" (§ method addP) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (.longValue ___x) #_"long" ___ly (.longValue ___y)]
            (let [#_"long" ___ret (+ ___lx ___ly)]
                (when (and (neg? (___ret :xor ___lx)) (neg? (___ret :xor ___ly)))
                    (§ return (.add Numbers'BIGINT_OPS, ___x, ___y))
                )
                (num ___ret)
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'multiply-2ll((.longValue ___x), (.longValue ___y))))
    )

    #_method
    (§ defn #_"Number" (§ method multiplyP) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (.longValue ___x) #_"long" ___ly (.longValue ___y)]
            (when (and (ß ___lx == Long/MIN_VALUE) (neg? ___ly))
                (§ return (.multiply Numbers'BIGINT_OPS, ___x, ___y))
            )
            (let [#_"long" ___ret (* ___lx ___ly)]
                (when (and (ß ___ly != 0) (ß ___ret / ___ly != ___lx))
                    (§ return (.multiply Numbers'BIGINT_OPS, ___x, ___y))
                )
                (num ___ret)
            )
        )
    )

    (defn #_"long" LongOps'gcd [#_"long" ___u, #_"long" ___v]
        (while (not= ___v 0)
            (let [#_"long" ___r (ß ___u % ___v)]
                (§ ass ___u ___v)
                (§ ass ___v ___r)
            )
        )
        ___u
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___n (.longValue ___x)]
            (let [#_"long" ___val (.longValue ___y)]
                (let [#_"long" ___gcd (LongOps'gcd ___n, ___val)]
                    (when (zero? ___gcd)
                        (§ return (num 0))
                    )

                    (§ ass ___n (/ ___n ___gcd))
                    (let [#_"long" ___d (/ ___val ___gcd)]
                        (when (= ___d 1)
                            (§ return (num ___n))
                        )
                        (when (< ___d 0)
                            (§ ass ___n (- ___n))
                            (§ ass ___d (- ___d))
                        )
                        (ß Ratio'new(BigInteger/valueOf(___n), BigInteger/valueOf(___d)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num((.longValue ___x) / (.longValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num((.longValue ___x) % (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) == (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) < (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) <= (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) >= (.longValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (ß num(Numbers'minus-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method negateP) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (when (> ___val Long/MIN_VALUE)
                (§ return (num (- val)))
            )
            (ß BigInt'fromBigInteger(BigInteger/valueOf(___val).negate()))
        )
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (ß num(Numbers'inc-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method incP) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (when (< ___val Long/MAX_VALUE)
                (§ return (ß num(___val + 1)))
            )
            (.inc Numbers'BIGINT_OPS, ___x)
        )
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (ß num(Numbers'dec-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method decP) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (when (> ___val Long/MIN_VALUE)
                (§ return (ß num(___val - 1)))
            )
            (.dec Numbers'BIGINT_OPS, ___x)
        )
    )
)

(class-ns DoubleOps (§ extends OpsP)
    (defn #_"DoubleOps" DoubleOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"DoubleOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"DoubleOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"DoubleOps" this, #_"Number" ___x]
        (zero? (.doubleValue ___x))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"DoubleOps" this, #_"Number" ___x]
        (pos? (.doubleValue ___x))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"DoubleOps" this, #_"Number" ___x]
        (neg? (.doubleValue ___x))
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf((.doubleValue ___x) + (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf((.doubleValue ___x) * (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf((.doubleValue ___x) / (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'quotient-2dd((.doubleValue ___x), (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'remainder-2dd((.doubleValue ___x), (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) == (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) < (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) <= (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) >= (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(-x.doubleValue()))
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf((.doubleValue ___x) + 1))
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf((.doubleValue ___x) - 1))
    )
)

(class-ns RatioOps (§ extends OpsP)
    (defn #_"RatioOps" RatioOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"RatioOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (cast' Ratio ___x)]
            (zero? (.signum (:numerator ___r)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (cast' Ratio ___x)]
            (pos? (.signum (:numerator ___r)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (cast' Ratio ___x)]
            (neg? (.signum (:numerator ___r)))
        )
    )

    (defn #_"Number" RatioOps'normalizeRet [#_"Number" ___ret, #_"Number" ___x, #_"Number" ___y]
        ___ret
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (let [#_"Number" ___ret (ß this.divide((:numerator ___ry).multiply((:denominator ___rx)).add((:numerator ___rx).multiply((:denominator ___ry))), (:denominator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (let [#_"Number" ___ret (ß Numbers'divide-2ii((:numerator ___ry).multiply((:numerator ___rx)), (:denominator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (let [#_"Number" ___ret (ß Numbers'divide-2ii((:denominator ___ry).multiply((:numerator ___rx)), (:numerator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (let [#_"BigInteger" ___q (ß (:numerator ___rx).multiply((:denominator ___ry)).divide((:denominator ___rx).multiply((:numerator ___ry))))]
                    (ß RatioOps'normalizeRet(BigInt'fromBigInteger(___q), ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (let [#_"BigInteger" ___q (ß (:numerator ___rx).multiply((:denominator ___ry)).divide((:denominator ___rx).multiply((:numerator ___ry))))]
                    (let [#_"Number" ___ret (ß Numbers'minus-2oo(___x, Numbers'multiply-2oo(___q, ___y)))]
                        (RatioOps'normalizeRet ___ret, ___x, ___y)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (and (.equals (:numerator ___rx), (:numerator ___ry)) (.equals (:denominator ___rx), (:denominator ___ry)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (ß Numbers'lt-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (ß Numbers'lte-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (toRatio ___x)]
            (let [#_"Ratio" ___ry (toRatio ___y)]
                (ß Numbers'gte-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (cast' Ratio ___x)]
            (ß Ratio'new((:numerator ___r).negate(), (:denominator ___r)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"RatioOps" this, #_"Number" ___x]
        (Numbers'add-2ol ___x, 1)
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"RatioOps" this, #_"Number" ___x]
        (Numbers'add-2ol ___x, -1)
    )
)

(class-ns BigIntOps (§ extends OpsP)
    (defn #_"BigIntOps" BigIntOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"BigIntOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"RatioOps" ___x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (toBigInt ___x)]
            (when (ß (nil? (:bipart ___bx)))
                (§ return (zero? (:lpart ___bx)))
            )
            (zero? (.signum (:bipart ___bx)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (toBigInt ___x)]
            (when (ß (nil? (:bipart ___bx)))
                (§ return (pos? (:lpart ___bx)))
            )
            (pos? (.signum (:bipart ___bx)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (toBigInt ___x)]
            (when (ß (nil? (:bipart ___bx)))
                (§ return (neg? (:lpart ___bx)))
            )
            (neg? (.signum (:bipart ___bx)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).add(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).multiply(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'divide-2ii(this.toBigInteger(___x), this.toBigInteger(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).quotient(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).remainder(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).equals(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).lt(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigInteger(___x).compareTo(this.toBigInteger(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigInteger(___x).compareTo(this.toBigInteger(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"BigIntOps" this, #_"Number" ___x]
        (ß BigInt'fromBigInteger(this.toBigInteger(___x).negate()))
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (.toBigInteger this, ___x)]
            (ß BigInt'fromBigInteger(___bx.add(BigInteger/ONE)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (.toBigInteger this, ___x)]
            (ß BigInt'fromBigInteger(___bx.subtract(BigInteger/ONE)))
        )
    )
)

(class-ns BigDecimalOps (§ extends OpsP)
    (§ def #_"Var" BigDecimalOps'MATH_CONTEXT RT'MATH_CONTEXT)

    (defn #_"BigDecimalOps" BigDecimalOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"BigDecimalOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
            (zero? (.signum ___bx))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
            (pos? (.signum ___bx))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
            (neg? (.signum ___bx))
        )
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).add(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).add(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).multiply(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).multiply(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).divide(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).divide(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).divideToIntegralValue(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).divideToIntegralValue(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).remainder(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).remainder(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (zero? (ß this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y))))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (neg? (ß this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y))))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (ß this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y))) <= 0)
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (ß this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y))) >= 0)
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? ___mc) (.negate (cast BigDecimal ___x)) (.negate (cast BigDecimal ___x), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
                (if (nil? ___mc) (.add ___bx, BigDecimal/ONE) (.add ___bx, BigDecimal/ONE, ___mc))
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
                (if (nil? ___mc) (.subtract ___bx, BigDecimal/ONE) (.subtract ___bx, BigDecimal/ONE, ___mc))
            )
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

#_stateless
(class-ns Numbers
    (defn #_"boolean" Numbers'isZero-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).isZero((cast Number ___x)))
    )

    (defn #_"boolean" Numbers'isPos-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).isPos((cast Number ___x)))
    )

    (defn #_"boolean" Numbers'isNeg-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).isNeg((cast Number ___x)))
    )

    (defn #_"Number" Numbers'minus-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).negate((cast Number ___x)))
    )

    (defn #_"Number" Numbers'minusP-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).negateP((cast Number ___x)))
    )

    (defn #_"Number" Numbers'inc-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).inc((cast Number ___x)))
    )

    (defn #_"Number" Numbers'incP-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).incP((cast Number ___x)))
    )

    (defn #_"Number" Numbers'dec-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).dec((cast Number ___x)))
    )

    (defn #_"Number" Numbers'decP-1o [#_"Object" ___x]
        (ß Numbers'ops(___x).decP((cast Number ___x)))
    )

    (defn #_"Number" Numbers'add-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).add((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"Number" Numbers'addP-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).addP((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"Number" Numbers'minus-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (Numbers'ops ___y)]
            (ß Numbers'ops(___x).combine(___yops).add((cast Number ___x), ___yops.negate((cast Number ___y))))
        )
    )

    (defn #_"Number" Numbers'minusP-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (Numbers'ops ___y)]
            (let [#_"Number" ___negativeY (.negateP ___yops, (cast Number ___y))]
                (let [#_"Ops" ___negativeYOps (Numbers'ops ___negativeY)]
                    (ß Numbers'ops(___x).combine(___negativeYOps).addP((cast Number ___x), ___negativeY))
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiply-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).multiply((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"Number" Numbers'multiplyP-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).multiplyP((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"Number" Numbers'divide-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (Numbers'isNaN ___x)
            (do
                (§ return (cast Number ___x))
            )
            (Numbers'isNaN ___y)
            (do
                (§ return (cast Number ___y))
            )
        )
        (let [#_"Ops" ___yops (Numbers'ops ___y)]
            (when (.isZero ___yops, (cast Number ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß Numbers'ops(___x).combine(___yops).divide((cast Number ___x), (cast Number ___y)))
        )
    )

    (defn #_"Number" Numbers'quotient-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (Numbers'ops ___y)]
            (when (.isZero ___yops, (cast Number ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß Numbers'ops(___x).combine(___yops).quotient((cast Number ___x), (cast Number ___y)))
        )
    )

    (defn #_"Number" Numbers'remainder-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (Numbers'ops ___y)]
            (when (.isZero ___yops, (cast Number ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß Numbers'ops(___x).combine(___yops).remainder((cast Number ___x), (cast Number ___y)))
        )
    )

    (defn #_"double" Numbers'quotient-2dd [#_"double" ___n, #_"double" ___d]
        (when (zero? ___d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (/ ___n ___d)]
            (cond (<= Long/MIN_VALUE ___q Long/MAX_VALUE)
                (do
                    (ß (double)(long) ___q)
                )
                :else ;; bigint quotient
                (do
                    (ß (BigDecimal. ___q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (defn #_"double" Numbers'remainder-2dd [#_"double" ___n, #_"double" ___d]
        (when (zero? ___d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (/ ___n ___d)]
            (cond (<= Long/MIN_VALUE ___q Long/MAX_VALUE)
                (do
                    (ß (___n - ((long) ___q) * ___d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" ___bq (.toBigInteger (BigDecimal. ___q))]
                        (ß (___n - (.doubleValue ___bq) * ___d))
                    )
                )
            )
        )
    )

    (defn #_"boolean" Numbers'equiv-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'equiv-2nn (cast Number ___x), (cast Number ___y))
    )

    (defn #_"boolean" Numbers'equiv-2nn [#_"Number" ___x, #_"Number" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).equiv(___x, ___y))
    )

    (defn #_"boolean" Numbers'equal [#_"Number" ___x, #_"Number" ___y]
        (and (ß category(___x) == category(___y)) (ß Numbers'ops(___x).combine(Numbers'ops(___y)).equiv(___x, ___y)))
    )

    (defn #_"boolean" Numbers'lt-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).lt((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"boolean" Numbers'lte-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).lte((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"boolean" Numbers'gt-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).lt((cast Number ___y), (cast Number ___x)))
    )

    (defn #_"boolean" Numbers'gte-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß Numbers'ops(___x).combine(Numbers'ops(___y)).gte((cast Number ___x), (cast Number ___y)))
    )

    (defn #_"int" Numbers'compare [#_"Number" ___x, #_"Number" ___y]
        (let [#_"Ops" ___ops (ß Numbers'ops(___x).combine(Numbers'ops(___y)))]
            (cond (.lt ___ops, ___x, ___y)
                (do
                    (§ return -1)
                )
                (.lt ___ops, ___y, ___x)
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (defn #_"BigInt" Numbers'toBigInt [#_"Object" ___x]
        (when (§ instance? BigInt ___x)
            (§ return (cast' BigInt ___x))
        )
        (if (instance? BigInteger ___x)
            (do
                (BigInt'fromBigInteger (cast BigInteger ___x))
            )
            (do
                (ß BigInt'fromLong((cast Number ___x).longValue()))
            )
        )
    )

    (defn #_"BigInteger" Numbers'toBigInteger [#_"Object" ___x]
        (cond (instance? BigInteger ___x)
            (do
                (cast BigInteger ___x)
            )
            (§ instance? BigInt ___x)
            (do
                (.toBigInteger (cast' BigInt ___x))
            )
            :else
            (do
                (ß BigInteger/valueOf((cast Number ___x).longValue()))
            )
        )
    )

    (defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" ___x]
        (cond (instance? BigDecimal ___x)
            (do
                (cast BigDecimal ___x)
            )
            (§ instance? BigInt ___x)
            (do
                (let [#_"BigInt" ___bi (cast' BigInt ___x)]
                    (if (ß (nil? (:bipart ___bi)))
                        (do
                            (BigDecimal/valueOf (:lpart ___bi))
                        )
                        (do
                            (§ unsure BigDecimal. (:bipart ___bi))
                        )
                    )
                )
            )
            (instance? BigInteger ___x)
            (do
                (§ unsure BigDecimal. (cast BigInteger ___x))
            )
            (instance? Double ___x)
            (do
                (§ unsure BigDecimal. (.doubleValue (cast Number ___x)))
            )
            (instance? Float ___x)
            (do
                (§ unsure BigDecimal. (.doubleValue (cast Number ___x)))
            )
            (§ instance? Ratio ___x)
            (do
                (let [#_"Ratio" ___r (cast' Ratio ___x)]
                    (cast BigDecimal (Numbers'divide-2oo (§ unsure BigDecimal. (:numerator ___r)), (:denominator ___r)))
                )
            )
            :else
            (do
                (BigDecimal/valueOf (.longValue (cast Number ___x)))
            )
        )
    )

    (defn #_"Ratio" Numbers'toRatio [#_"Object" ___x]
        (cond (§ instance? Ratio ___x)
            (do
                (§ return (cast' Ratio ___x))
            )
            (instance? BigDecimal ___x)
            (do
                (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
                    (let [#_"BigInteger" ___bv (.unscaledValue ___bx)]
                        (let [#_"int" ___scale (.scale ___bx)]
                            (if (< ___scale 0)
                                (do
                                    (§ return (ß Ratio'new(___bv.multiply(BigInteger/TEN.pow(-scale)), BigInteger/ONE)))
                                )
                                (do
                                    (§ return (ß Ratio'new(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (Ratio'new (Numbers'toBigInteger ___x), BigInteger/ONE)
    )

    (defn #_"Number" Numbers'rationalize [#_"Number" ___x]
        (cond (or (instance? Float ___x) (instance? Double ___x))
            (do
                (§ return (ß rationalize(BigDecimal/valueOf((.doubleValue ___x)))))
            )
            (instance? BigDecimal ___x)
            (do
                (let [#_"BigDecimal" ___bx (cast BigDecimal ___x)]
                    (let [#_"BigInteger" ___bv (.unscaledValue ___bx)]
                        (let [#_"int" ___scale (.scale ___bx)]
                            (if (< ___scale 0)
                                (do
                                    (§ return (ß BigInt'fromBigInteger(___bv.multiply(BigInteger/TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß Numbers'divide-ii(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        ___x
    )

    (defn #_"Number" Numbers'reduceBigInt [#_"BigInt" ___val]
        (if (ß (nil? (:bipart ___val)))
            (do
                (num (:lpart ___val))
            )
            (do
                (:bipart ___val)
            )
        )
    )

    (defn #_"Number" Numbers'divide-2ii [#_"BigInteger" ___n, #_"BigInteger" ___d]
        (when (.equals ___d, BigInteger/ZERO)
            (throw (ArithmeticException. "Divide by zero"))
        )
        (let [#_"BigInteger" ___gcd (.gcd ___n, ___d)]
            (when (.equals ___gcd, BigInteger/ZERO)
                (§ return BigInt'ZERO)
            )
            (§ ass ___n (.divide ___n, ___gcd))
            (§ ass ___d (.divide ___d, ___gcd))
            (cond (.equals ___d, BigInteger/ONE)
                (do
                    (§ return (BigInt'fromBigInteger ___n))
                )
                (ß ___d.equals(BigInteger/ONE.negate()))
                (do
                    (§ return (BigInt'fromBigInteger (.negate ___n)))
                )
            )
            (Ratio'new (if (neg? (.signum ___d)) (.negate ___n) ___n), (if (neg? (.signum ___d)) (.negate ___d) ___d))
        )
    )

    (defn #_"int" Numbers'shiftLeftInt [#_"int" ___x, #_"int" ___n]
        (<< ___x ___n)
    )

    (defn #_"long" Numbers'shiftLeft-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß shiftLeft(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftLeft-2ol [#_"Object" ___x, #_"long" ___y]
        (ß shiftLeft(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'shiftLeft-2lo [#_"long" ___x, #_"Object" ___y]
        (ß shiftLeft(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftLeft-2ll [#_"long" ___x, #_"long" ___n]
        (<< ___x ___n)
    )

    (defn #_"int" Numbers'shiftRightInt [#_"int" ___x, #_"int" ___n]
        (>> ___x ___n)
    )

    (defn #_"long" Numbers'shiftRight-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß shiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftRight-2ol [#_"Object" ___x, #_"long" ___y]
        (ß shiftRight(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'shiftRight-2lo [#_"long" ___x, #_"Object" ___y]
        (ß shiftRight(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftRight-2ll [#_"long" ___x, #_"long" ___n]
        (>> ___x ___n)
    )

    (defn #_"int" Numbers'unsignedShiftRightInt [#_"int" ___x, #_"int" ___n]
        (>>> ___x ___n)
    )

    (defn #_"long" Numbers'unsignedShiftRight-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ol [#_"Object" ___x, #_"long" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2lo [#_"long" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ll [#_"long" ___x, #_"long" ___n]
        (>>> ___x ___n)
    )

    (§ def #_"LongOps" Numbers'LONG_OPS (LongOps'new))
    (§ def #_"DoubleOps" Numbers'DOUBLE_OPS (DoubleOps'new))
    (§ def #_"RatioOps" Numbers'RATIO_OPS (RatioOps'new))
    (§ def #_"BigIntOps" Numbers'BIGINT_OPS (BigIntOps'new))
    (§ def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps'new))

    (defn #_"Ops" Numbers'ops [#_"Object" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (cond (= ___xc Long)
                (do
                    Numbers'LONG_OPS
                )
                (= ___xc Double)
                (do
                    Numbers'DOUBLE_OPS
                )
                (= ___xc Integer)
                (do
                    Numbers'LONG_OPS
                )
                (= ___xc Float)
                (do
                    Numbers'DOUBLE_OPS
                )
                (ß ___xc == (§ class BigInt))
                (do
                    Numbers'BIGINT_OPS
                )
                (= ___xc BigInteger)
                (do
                    Numbers'BIGINT_OPS
                )
                (ß ___xc == (§ class Ratio))
                (do
                    Numbers'RATIO_OPS
                )
                (= ___xc BigDecimal)
                (do
                    Numbers'BIGDECIMAL_OPS
                )
                :else
                (do
                    Numbers'LONG_OPS
                )
            )
        )
    )

    (defn #_"int" Numbers'hasheqFrom [#_"Number" ___x, #_"Class" ___xc]
        (when (or (ß ___xc == Integer) (ß ___xc == Short) (ß ___xc == Byte) (and (ß ___xc == BigInteger) (Numbers'lte-2ol ___x, Long/MAX_VALUE) (Numbers'gte-2ol ___x, Long/MIN_VALUE)))
            (let [#_"long" ___lpart (.longValue ___x)]
                (§ return (Murmur3'hashLong ___lpart))
            )
        )
        (when (= ___xc BigDecimal)
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode. Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (Numbers'isZero-1o ___x)
                (do
                    (§ return (.hashCode BigDecimal/ZERO))
                )
                (do
                    (§ return (ß (cast BigDecimal ___x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (and (= ___xc Float) (.equals ___x, (float -0.0)))
            (§ return 0) ;; match 0.0f
        )
        (.hashCode ___x)
    )

    (defn #_"int" Numbers'hasheq [#_"Number" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (when (= ___xc Long)
                (let [#_"long" ___lpart (.longValue ___x)]
                    (§ return (Murmur3'hashLong ___lpart))
                )
            )
            (when (= ___xc Double)
                (when (.equals ___x, -0.0)
                    (§ return 0) ;; match 0.0
                )
                (§ return (.hashCode ___x))
            )
            (Numbers'hasheqFrom ___x, ___xc)
        )
    )

    (defn #_"Category" Numbers'category [#_"Object" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (cond (= ___xc Integer)
                (do
                    (ß :Category'INTEGER)
                )
                (= ___xc Double)
                (do
                    (ß :Category'FLOATING)
                )
                (= ___xc Long)
                (do
                    (ß :Category'INTEGER)
                )
                (= ___xc Float)
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class BigInt))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Ratio))
                (do
                    (ß :Category'RATIO)
                )
                (= ___xc BigDecimal)
                (do
                    (ß :Category'DECIMAL)
                )
                :else
                (do
                    (ß :Category'INTEGER)
                )
            )
        )
    )

    (defn #_"long" Numbers'bitOpsCast [#_"Object" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (when (or (ß ___xc == Long) (ß ___xc == Integer) (ß ___xc == Short) (ß ___xc == Byte))
                (§ return (RT'longCast-1o ___x))
            )
            ;; no bignums, no decimals
            (throw (IllegalArgumentException. (str "bit operation not supported for: " ___xc)))
        )
    )

    (defn #_"float[]" Numbers'float_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"float[]" ___ret (.float-array ___size)]
            (if (instance? Number ___init)
                (do
                    (let [#_"float" ___f (.floatValue (cast Number ___init))]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (.floatValue (cast Number (first ___s))))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"float[]" Numbers'float_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.float-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"float[]" ___ret (.float-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (.floatValue (cast Number (first ___s))))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"double[]" Numbers'double_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"double[]" ___ret (.double-array ___size)]
            (if (instance? Number ___init)
                (do
                    (let [#_"double" ___f (.doubleValue (cast Number ___init))]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (.doubleValue (cast Number (first ___s))))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"double[]" Numbers'double_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.double-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"double[]" ___ret (.double-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (.doubleValue (cast Number (first ___s))))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"int[]" Numbers'int_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"int[]" ___ret (.int-array ___size)]
            (if (instance? Number ___init)
                (do
                    (let [#_"int" ___f (.intValue (cast Number ___init))]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (.intValue (cast Number (first ___s))))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"int[]" Numbers'int_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.int-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"int[]" ___ret (.int-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (.intValue (cast Number (first ___s))))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"long[]" Numbers'long_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"long[]" ___ret (.long-array ___size)]
            (if (instance? Number ___init)
                (do
                    (let [#_"long" ___f (.longValue (cast Number ___init))]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (.longValue (cast Number (first ___s))))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"long[]" Numbers'long_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.long-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"long[]" ___ret (.long-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (.longValue (cast Number (first ___s))))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"short[]" Numbers'short_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"short[]" ___ret (.short-array ___size)]
            (if (instance? Short ___init)
                (do
                    (let [#_"short" ___s (cast Short ___init)]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (.shortValue (cast Number (first ___s))))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"short[]" Numbers'short_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.short-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"short[]" ___ret (.short-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (.shortValue (cast Number (first ___s))))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"char[]" Numbers'char_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"char[]" ___ret (.char-array ___size)]
            (if (instance? Character ___init)
                (do
                    (let [#_"char" ___c (cast Character ___init)]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (cast Character (first ___s)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"char[]" Numbers'char_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.char-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"char[]" ___ret (.char-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (cast Character (first ___s)))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"byte[]" Numbers'byte_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"byte[]" ___ret (.byte-array ___size)]
            (if (instance? Byte ___init)
                (do
                    (let [#_"byte" ___b (cast Byte ___init)]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (.byteValue (cast Number (first ___s))))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"byte[]" Numbers'byte_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.byte-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"byte[]" ___ret (.byte-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (.byteValue (cast Number (first ___s))))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"boolean[]" ___ret (.boolean-array ___size)]
            (if (instance? Boolean ___init)
                (do
                    (let [#_"boolean" ___b (cast Boolean ___init)]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___ret)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (cast Boolean (.first ___s)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-1 [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (.boolean-array (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"boolean[]" ___ret (.boolean-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (ß ___i < ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (cast Boolean (.first ___s)))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'booleans [#_"Object" ___array]
        (.booleans ___array)
    )

    (defn #_"byte[]" Numbers'bytes [#_"Object" ___array]
        (.bytes ___array)
    )

    (defn #_"char[]" Numbers'chars [#_"Object" ___array]
        (.chars ___array)
    )

    (defn #_"short[]" Numbers'shorts [#_"Object" ___array]
        (.shorts ___array)
    )

    (defn #_"float[]" Numbers'floats [#_"Object" ___array]
        (.floats ___array)
    )

    (defn #_"double[]" Numbers'doubles [#_"Object" ___array]
        (.doubles ___array)
    )

    (defn #_"int[]" Numbers'ints [#_"Object" ___array]
        (.ints ___array)
    )

    (defn #_"long[]" Numbers'longs [#_"Object" ___array]
        (.longs ___array)
    )

    (defn #_"Number" Numbers'num-1o [#_"Object" ___x]
        (cast Number ___x)
    )

    (defn #_"Number" Numbers'num-1f [#_"float" ___x]
        (Float/valueOf ___x)
    )

    (defn #_"Number" Numbers'num-1d [#_"double" ___x]
        (Double/valueOf ___x)
    )

    (defn #_"double" Numbers'add-2dd [#_"double" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2dd [#_"double" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'minus-2dd [#_"double" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2dd [#_"double" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minus-1d [#_"double" ___x]
        (- ___x)
    )

    (defn #_"double" Numbers'minusP-1d [#_"double" ___x]
        (- ___x)
    )

    (defn #_"double" Numbers'inc-1d [#_"double" ___x]
        (+ ___x 1)
    )

    (defn #_"double" Numbers'incP-1d [#_"double" ___x]
        (+ ___x 1)
    )

    (defn #_"double" Numbers'dec-1d [#_"double" ___x]
        (- ___x 1)
    )

    (defn #_"double" Numbers'decP-1d [#_"double" ___x]
        (- ___x 1)
    )

    (defn #_"double" Numbers'multiply-2dd [#_"double" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2dd [#_"double" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'divide-2dd [#_"double" ___x, #_"double" ___y]
        (/ ___x ___y)
    )

    (defn #_"boolean" Numbers'equiv-2dd [#_"double" ___x, #_"double" ___y]
        (= ___x ___y)
    )

    (defn #_"boolean" Numbers'lt-2dd [#_"double" ___x, #_"double" ___y]
        (< ___x ___y)
    )

    (defn #_"boolean" Numbers'lte-2dd [#_"double" ___x, #_"double" ___y]
        (<= ___x ___y)
    )

    (defn #_"boolean" Numbers'gt-2dd [#_"double" ___x, #_"double" ___y]
        (> ___x ___y)
    )

    (defn #_"boolean" Numbers'gte-2dd [#_"double" ___x, #_"double" ___y]
        (>= ___x ___y)
    )

    (defn #_"boolean" Numbers'isPos-1d [#_"double" ___x]
        (> ___x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1d [#_"double" ___x]
        (< ___x 0)
    )

    (defn #_"boolean" Numbers'isZero-1d [#_"double" ___x]
        (zero? ___x)
    )

    (defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (defn #_"int" Numbers'unchecked_int_add [#_"int" ___x, #_"int" ___y]
        (+ ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_subtract [#_"int" ___x, #_"int" ___y]
        (- ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_negate [#_"int" ___x]
        (- ___x)
    )

    (defn #_"int" Numbers'unchecked_int_inc [#_"int" ___x]
        (+ ___x 1)
    )

    (defn #_"int" Numbers'unchecked_int_dec [#_"int" ___x]
        (- ___x 1)
    )

    (defn #_"int" Numbers'unchecked_int_multiply [#_"int" ___x, #_"int" ___y]
        (* ___x ___y)
    )

    (defn #_"long" Numbers'not-1o [#_"Object" ___x]
        (ß not(bitOpsCast(___x)))
    )

    (defn #_"long" Numbers'not-1l [#_"long" ___x]
        (ß ~___x)
    )

    (defn #_"long" Numbers'and-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß and(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'and-2ol [#_"Object" ___x, #_"long" ___y]
        (ß and(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'and-2lo [#_"long" ___x, #_"Object" ___y]
        (ß and(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'and-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x & ___y)
    )

    (defn #_"long" Numbers'or-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß or(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'or-2ol [#_"Object" ___x, #_"long" ___y]
        (ß or(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'or-2lo [#_"long" ___x, #_"Object" ___y]
        (ß or(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'or-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x | ___y)
    )

    (defn #_"long" Numbers'xor-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß xor(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'xor-2ol [#_"Object" ___x, #_"long" ___y]
        (ß xor(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'xor-2lo [#_"long" ___x, #_"Object" ___y]
        (ß xor(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'xor-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x :xor ___y)
    )

    (defn #_"long" Numbers'andNot-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß andNot(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'andNot-2ol [#_"Object" ___x, #_"long" ___y]
        (ß andNot(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'andNot-2lo [#_"long" ___x, #_"Object" ___y]
        (ß andNot(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'andNot-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x & ~___y)
    )

    (defn #_"long" Numbers'clearBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß clearBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'clearBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß clearBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'clearBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß clearBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'clearBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x & ~(1 << ___n))
    )

    (defn #_"long" Numbers'setBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß setBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'setBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß setBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'setBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß setBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'setBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x | (1 << ___n))
    )

    (defn #_"long" Numbers'flipBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß flipBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'flipBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß flipBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'flipBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß flipBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'flipBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x :xor (1 << ___n))
    )

    (defn #_"boolean" Numbers'testBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß testBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"boolean" Numbers'testBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß testBit(bitOpsCast(___x), ___y))
    )

    (defn #_"boolean" Numbers'testBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß testBit(___x, bitOpsCast(___y)))
    )

    (defn #_"boolean" Numbers'testBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ((___x & (1 << ___n)) != 0))
    )

    (defn #_"int" Numbers'unchecked_int_divide [#_"int" ___x, #_"int" ___y]
        (/ ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_remainder [#_"int" ___x, #_"int" ___y]
        (ß ___x % ___y)
    )

    (defn #_"Number" Numbers'num-1l [#_"long" ___x]
        (Long/valueOf ___x)
    )

    (defn #_"long" Numbers'unchecked_add-2ll [#_"long" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_minus-2ll [#_"long" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_multiply-2ll [#_"long" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_minus-1l [#_"long" ___x]
        (- ___x)
    )

    (defn #_"long" Numbers'unchecked_inc-1l [#_"long" ___x]
        (+ ___x 1)
    )

    (defn #_"long" Numbers'unchecked_dec-1l [#_"long" ___x]
        (- ___x 1)
    )

    (defn #_"Number" Numbers'unchecked_add-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'add-2oo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'minus-2oo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'multiply-2oo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-1o [#_"Object" ___x]
        (Numbers'minus-1o ___x)
    )

    (defn #_"Number" Numbers'unchecked_inc-1o [#_"Object" ___x]
        (Numbers'inc-1o ___x)
    )

    (defn #_"Number" Numbers'unchecked_dec-1o [#_"Object" ___x]
        (Numbers'dec-1o ___x)
    )

    (defn #_"double" Numbers'unchecked_add-2dd [#_"double" ___x, #_"double" ___y]
        (Numbers'add-2dd ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dd [#_"double" ___x, #_"double" ___y]
        (Numbers'minus-2dd ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dd [#_"double" ___x, #_"double" ___y]
        (Numbers'multiply-2dd ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-1d [#_"double" ___x]
        (Numbers'minus-1d ___x)
    )

    (defn #_"double" Numbers'unchecked_inc-1d [#_"double" ___x]
        (Numbers'inc-1d ___x)
    )

    (defn #_"double" Numbers'unchecked_dec-1d [#_"double" ___x]
        (Numbers'dec-1d ___x)
    )

    (defn #_"double" Numbers'unchecked_add-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'add-2do ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'minus-2do ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'multiply-2do ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_add-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'add-2od ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'minus-2od ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'multiply-2od ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_add-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'add-2dl ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'minus-2dl ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'multiply-2dl ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_add-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'add-2ld ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'minus-2ld ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'multiply-2ld ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_add-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'add-2lo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'minus-2lo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'multiply-2lo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_add-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'add-2ol ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'minus-2ol ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'multiply-2ol ___x, ___y)
    )

    (defn #_"Number" Numbers'quotient-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'quotient-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'quotient-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'quotient-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'quotient-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'quotient-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'quotient-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'quotient-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'quotient-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'quotient-2dd ___x, (double ___y))
    )

    (defn #_"double" Numbers'quotient-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'quotient-2dd (double ___x), ___y)
    )

    (defn #_"Number" Numbers'remainder-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'remainder-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'remainder-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'remainder-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'remainder-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'remainder-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'remainder-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'remainder-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'remainder-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'remainder-2dd ___x, (double ___y))
    )

    (defn #_"double" Numbers'remainder-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'remainder-2dd (double ___x), ___y)
    )

    (defn #_"long" Numbers'add-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (+ ___x ___y)]
            (when (and (neg? (ß ___ret :xor ___x)) (neg? (ß ___ret :xor ___y)))
                (§ return (throwIntOverflow))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'addP-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (+ ___x ___y)]
            (when (and (neg? (ß ___ret :xor ___x)) (neg? (ß ___ret :xor ___y)))
                (§ return (Numbers'addP-2oo (cast Number ___x), (cast Number ___y)))
            )
            (num ___ret)
        )
    )

    (defn #_"long" Numbers'minus-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (- ___x ___y)]
            (when (and (neg? (ß ___ret :xor ___x)) (neg? (ß ___ret :xor (ß ~ ___y))))
                (§ return (throwIntOverflow))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'minusP-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (- ___x ___y)]
            (when (and (neg? (ß ___ret :xor ___x)) (neg? (ß ___ret :xor (ß ~ ___y))))
                (§ return (ß minusP((cast Number ___x), (cast Number ___y))))
            )
            (num ___ret)
        )
    )

    (defn #_"long" Numbers'minus-1l [#_"long" ___x]
        (when (= ___x Long/MIN_VALUE)
            (§ return (throwIntOverflow))
        )
        (- ___x)
    )

    (defn #_"Number" Numbers'minusP-1l [#_"long" ___x]
        (when (= ___x Long/MIN_VALUE)
            (§ return (ß BigInt'fromBigInteger(BigInteger/valueOf(___x).negate())))
        )
        (num (- ___x))
    )

    (defn #_"long" Numbers'inc-1l [#_"long" ___x]
        (when (= ___x Long/MAX_VALUE)
            (§ return (throwIntOverflow))
        )
        (inc ___x)
    )

    (defn #_"Number" Numbers'incP-1l [#_"long" ___x]
        (when (= ___x Long/MAX_VALUE)
            (§ return (.inc Numbers'BIGINT_OPS, ___x))
        )
        (ß num(___x + 1))
    )

    (defn #_"long" Numbers'dec-1l [#_"long" ___x]
        (when (= ___x Long/MIN_VALUE)
            (§ return (throwIntOverflow))
        )
        (dec ___x)
    )

    (defn #_"Number" Numbers'decP-1l [#_"long" ___x]
        (when (= ___x Long/MIN_VALUE)
            (§ return (.dec Numbers'BIGINT_OPS, ___x))
        )
        (ß num(___x - 1))
    )

    (defn #_"long" Numbers'multiply-2ll [#_"long" ___x, #_"long" ___y]
        (when (and (ß ___x == Long/MIN_VALUE) (neg? ___y))
            (§ return (throwIntOverflow))
        )
        (let [#_"long" ___ret (* ___x ___y)]
            (when (and (ß ___y != 0) (ß ___ret / ___y != ___x))
                (§ return (throwIntOverflow))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'multiplyP-2ll [#_"long" ___x, #_"long" ___y]
        (when (and (ß ___x == Long/MIN_VALUE) (neg? ___y))
            (§ return (Numbers'multiplyP (cast Number ___x), (cast Number ___y)))
        )
        (let [#_"long" ___ret (* ___x ___y)]
            (when (and (ß ___y != 0) (ß ___ret / ___y != ___x))
                (§ return (Numbers'multiplyP (cast Number ___x), (cast Number ___y)))
            )
            (num ___ret)
        )
    )

    (defn #_"long" Numbers'quotient-2ll [#_"long" ___x, #_"long" ___y]
        (/ ___x ___y)
    )

    (defn #_"long" Numbers'remainder-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x % ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ll [#_"long" ___x, #_"long" ___y]
        (= ___x ___y)
    )

    (defn #_"boolean" Numbers'lt-2ll [#_"long" ___x, #_"long" ___y]
        (< ___x ___y)
    )

    (defn #_"boolean" Numbers'lte-2ll [#_"long" ___x, #_"long" ___y]
        (<= ___x ___y)
    )

    (defn #_"boolean" Numbers'gt-2ll [#_"long" ___x, #_"long" ___y]
        (> ___x ___y)
    )

    (defn #_"boolean" Numbers'gte-2ll [#_"long" ___x, #_"long" ___y]
        (>= ___x ___y)
    )

    (defn #_"boolean" Numbers'isPos-1l [#_"long" ___x]
        (> ___x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1l [#_"long" ___x]
        (< ___x 0)
    )

    (defn #_"boolean" Numbers'isZero-1l [#_"long" ___x]
        (zero? ___x)
    )

    ;; overload resolution

    (defn #_"Number" Numbers'add-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'add-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'add-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'add-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'addP-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'addP-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'addP-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'addP-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'add-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'add-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'add-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'add-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'add-2dl [#_"double" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'add-2ld [#_"long" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'addP-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'addP-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'addP-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'addP-2dl [#_"double" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2ld [#_"long" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"Number" Numbers'minus-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'minus-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'minus-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'minus-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'minusP-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'minusP-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'minusP-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'minusP-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'minus-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'minus-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'minus-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'minus-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'minus-2dl [#_"double" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minus-2ld [#_"long" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'minus-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'minusP-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'minus-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'minusP-2dl [#_"double" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2ld [#_"long" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"Number" Numbers'multiply-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'multiply-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'multiply-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'multiply-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'multiplyP-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'multiplyP-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'multiplyP-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'multiplyP-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'multiply-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'multiply-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'multiply-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'multiply-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'multiply-2dl [#_"double" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiply-2ld [#_"long" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'multiplyP-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'multiplyP-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'multiplyP-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'multiplyP-2dl [#_"double" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2ld [#_"long" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"Number" Numbers'divide-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'divide-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'divide-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'divide-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'divide-2do [#_"double" ___x, #_"Object" ___y]
        (ß ___x / (cast Number ___y).doubleValue())
    )

    (defn #_"double" Numbers'divide-2od [#_"Object" ___x, #_"double" ___y]
        (ß (cast Number ___x).doubleValue() / ___y)
    )

    (defn #_"double" Numbers'divide-2dl [#_"double" ___x, #_"long" ___y]
        (/ ___x ___y)
    )

    (defn #_"double" Numbers'divide-2ld [#_"long" ___x, #_"double" ___y]
        (/ ___x ___y)
    )

    (defn #_"Number" Numbers'divide-2ll [#_"long" ___x, #_"long" ___y]
        (Numbers'divide-2oo (cast Number ___x), (cast Number ___y))
    )

    (defn #_"boolean" Numbers'lt-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'lt-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'lt-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'lt-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'lt-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x < (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'lt-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() < ___y))
    )

    (defn #_"boolean" Numbers'lt-2dl [#_"double" ___x, #_"long" ___y]
        (< ___x ___y)
    )

    (defn #_"boolean" Numbers'lt-2ld [#_"long" ___x, #_"double" ___y]
        (< ___x ___y)
    )

    (defn #_"boolean" Numbers'lte-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'lte-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'lte-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'lte-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'lte-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x <= (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'lte-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() <= ___y))
    )

    (defn #_"boolean" Numbers'lte-2dl [#_"double" ___x, #_"long" ___y]
        (<= ___x ___y)
    )

    (defn #_"boolean" Numbers'lte-2ld [#_"long" ___x, #_"double" ___y]
        (<= ___x ___y)
    )

    (defn #_"boolean" Numbers'gt-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'gt-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'gt-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'gt-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'gt-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x > (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'gt-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() > ___y))
    )

    (defn #_"boolean" Numbers'gt-2dl [#_"double" ___x, #_"long" ___y]
        (> ___x ___y)
    )

    (defn #_"boolean" Numbers'gt-2ld [#_"long" ___x, #_"double" ___y]
        (> ___x ___y)
    )

    (defn #_"boolean" Numbers'gte-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'gte-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'gte-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'gte-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'gte-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x >= (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'gte-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() >= ___y))
    )

    (defn #_"boolean" Numbers'gte-2dl [#_"double" ___x, #_"long" ___y]
        (>= ___x ___y)
    )

    (defn #_"boolean" Numbers'gte-2ld [#_"long" ___x, #_"double" ___y]
        (>= ___x ___y)
    )

    (defn #_"boolean" Numbers'equiv-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'equiv-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'equiv-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'equiv-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x == (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'equiv-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() == ___y))
    )

    (defn #_"boolean" Numbers'equiv-2dl [#_"double" ___x, #_"long" ___y]
        (= ___x ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ld [#_"long" ___x, #_"double" ___y]
        (= ___x ___y)
    )

    (defn #_"boolean" Numbers'isNaN [#_"Object" ___x]
        (or (and (instance? Double ___x) (.isNaN (cast Double ___x))) (and (instance? Float ___x) (.isNaN (cast Float ___x))))
    )

    (defn #_"double" Numbers'max-2dd [#_"double" ___x, #_"double" ___y]
        (Math/max ___x, ___y)
    )

    (defn #_"Object" Numbers'max-2dl [#_"double" ___x, #_"long" ___y]
        (when (Double/isNaN ___x)
            (§ return ___x)
        )
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2do [#_"double" ___x, #_"Object" ___y]
        (cond (Double/isNaN ___x)
            (do
                (§ return ___x)
            )
            (Numbers'isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x > (cast Number ___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2ld [#_"long" ___x, #_"double" ___y]
        (when (Double/isNaN ___y)
            (§ return ___y)
        )
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"long" Numbers'max-2ll [#_"long" ___x, #_"long" ___y]
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2lo [#_"long" ___x, #_"Object" ___y]
        (when (Numbers'isNaN ___y)
            (§ return ___y)
        )
        (if (Numbers'gt-2lo ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2ol [#_"Object" ___x, #_"long" ___y]
        (when (Numbers'isNaN ___x)
            (§ return ___x)
        )
        (if (Numbers'gt-2ol ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2od [#_"Object" ___x, #_"double" ___y]
        (cond (Numbers'isNaN ___x)
            (do
                (§ return ___x)
            )
            (Double/isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß (cast Number ___x).doubleValue() > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (Numbers'isNaN ___x)
            (do
                (§ return ___x)
            )
            (Numbers'isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (Numbers'gt-2oo ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"double" Numbers'min-2dd [#_"double" ___x, #_"double" ___y]
        (Math/min ___x, ___y)
    )

    (defn #_"Object" Numbers'min-2dl [#_"double" ___x, #_"long" ___y]
        (when (Double/isNaN ___x)
            (§ return ___x)
        )
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2do [#_"double" ___x, #_"Object" ___y]
        (cond (Double/isNaN ___x)
            (do
                (§ return ___x)
            )
            (Numbers'isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x < (cast Number ___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2ld [#_"long" ___x, #_"double" ___y]
        (when (Double/isNaN ___y)
            (§ return ___y)
        )
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"long" Numbers'min-2ll [#_"long" ___x, #_"long" ___y]
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2lo [#_"long" ___x, #_"Object" ___y]
        (when (Numbers'isNaN ___y)
            (§ return ___y)
        )
        (if (Numbers'lt-2lo ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2ol [#_"Object" ___x, #_"long" ___y]
        (when (Numbers'isNaN ___x)
            (§ return ___x)
        )
        (if (Numbers'lt-2ol ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2od [#_"Object" ___x, #_"double" ___y]
        (cond (Numbers'isNaN ___x)
            (do
                (§ return ___x)
            )
            (Double/isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß (cast Number ___x).doubleValue() < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (Numbers'isNaN ___x)
            (do
                (§ return ___x)
            )
            (Numbers'isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (Numbers'lt-2oo ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (defn- #_"Obj" Obj'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"Obj" Obj'new-1 [#_"IPersistentMap" ___meta]
        (let [this (Obj'init)]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    (defn #_"Obj" Obj'new-0 []
        (let [this (Obj'init)]
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Obj" this]
        (:_meta this)
    )

    #_abstract
    (§ defn #_"Obj" (§ method withMeta) [#_"Obj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

(class-ns MSeq (§ extends ASeq) (§ implements Counted)
    (defn- #_"MSeq" MSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"MSeq" MSeq'new-2 [#_"Object[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new) (MSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"MSeq" MSeq'new-3 [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (MSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"MSeq" this]
        (ß MapEntry'create((:array this)[(:i this)], (:array this)[(:i this) + 1]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"MSeq" this]
        (when (ß (:i this) + 2 < (§ alength (:array this)))
            (§ return (ß MSeq'new-2((:array this), (:i this) + 2)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"MSeq" this]
        (/ (- (§ alength (:array this)) (:i this)) 2)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"MSeq" this, #_"IPersistentMap" ___meta]
        (MSeq'new-3 ___meta, (:array this), (:i this))
    )
)

(class-ns MIter (§ implements Iterator)
    (defn- #_"MIter" MIter'init []
        (hash-map
            #_"IFn" :f nil
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    ;; for iterator
    (defn #_"MIter" MIter'new-2 [#_"Object[]" ___array, #_"IFn" ___f]
        (MIter'new-3 ___array, -2, ___f)
    )

    ;; for entryAt
    (defn #_"MIter" MIter'new-3 [#_"Object[]" ___array, #_"int" ___i, #_"IFn" ___f]
        (let [this (MIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"MIter" this]
        (ß ((:i this) < (§ alength (:array this)) - 2))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"MIter" this]
        (try
            (§ ass (:i this) (+ (:i this) 2))
            (ß (:f this).invoke((:array this)[(:i this)], (:array this)[(:i this) + 1]))
            (catch IndexOutOfBoundsException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"MIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransientArrayMap (§ extends ATransientMap)
    (defn- #_"TransientArrayMap" TransientArrayMap'init []
        (hash-map
            #_volatile
            #_"int" :len 0
            #_"Object[]" :array nil
            #_volatile
            #_"Thread" :owner nil
        )
    )

    (defn #_"TransientArrayMap" TransientArrayMap'new [#_"Object[]" ___array]
        (let [this (merge (ATransientMap'new) (TransientArrayMap'init))]
            (§ ass (:owner this) (Thread/currentThread))
            (§ ass (:array this) (make-array Object (ß Math/max(PersistentArrayMap'HASHTABLE_THRESHOLD, (§ alength ___array)))))
            (ß System/arraycopy(___array, 0, (:array this), 0, (§ alength ___array)))
            (§ ass (:len this) (§ alength ___array))
            this
        )
    )

    #_method
    (§ defn- #_"int" (§ method indexOf) [#_"TransientArrayMap" this, #_"Object" ___key]
        (loop-when-recur [#_"int" ___i 0] (< ___i (:len this)) [(+ ___i 2)]
            (when (ß equalKey((:array this)[___i], ___key))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (cond (>= ___i 0) ;; already have key,
                (do
                    (when (ß (:array this)[___i + 1] != ___val) ;; no change, no op
                        (§ ass (§ aget (:array this) (ß ___i + 1)) ___val)
                    )
                )
                :else ;; didn't have key, grow
                (do
                    (when (ß (:len this) >= (§ alength (:array this)))
                        (§ return (ß PersistentHashMap'create-1a((:array this)).asTransient().assoc(___key, ___val)))
                    )
                    (§ ass (§ aget (:array this) (:len this)) ___key)
                    (§ ass (:len this) (+ (:len this) 1))
                    (§ ass (§ aget (:array this) (:len this)) ___val)
                    (§ ass (:len this) (+ (:len this) 1))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"TransientArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (>= ___i 0) ;; have key, will remove
                (when (ß (:len this) >= 2)
                    (§ ass (§ aget (:array this) ___i) (§ aget (:array this) (ß (:len this) - 2)))
                    (§ ass (§ aget (:array this) (ß ___i + 1)) (§ aget (:array this) (ß (:len this) - 1)))
                )
                (§ ass (:len this) (- (:len this) 2))
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method doValAt) [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (>= ___i 0)
                (§ return (§ aget (:array this) (ß ___i + 1)))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"int" (§ method doCount) [#_"TransientArrayMap" this]
        (/ (:len this) 2)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"TransientArrayMap" this]
        (.ensureEditable this)
        (§ ass (:owner this) nil)
        (let [#_"Object[]" ___a (make-array Object (:len this))]
            (System/arraycopy (:array this), 0, ___a, 0, (:len this))
            (PersistentArrayMap'new-1 ___a)
        )
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientArrayMap" this]
        (when (nil? (:owner this))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap'new-0))
    (def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentArrayMap'EMPTY)]
            (doseq [#_"Object" ___o (.entrySet ___other)]
                (let [#_"Map$Entry" ___e (cast' Entry ___o)]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (.persistent ___ret)
        )
    )

    (defn- #_"PersistentArrayMap" PersistentArrayMap'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IPersistentMap" :_meta nil
        )
    )

    #_protected
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-0 []
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:array this) (make-array Object 0))
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"PersistentArrayMap" (§ method withMeta) [#_"PersistentArrayMap" this, #_"IPersistentMap" ___meta]
        (PersistentArrayMap'new-2 ___meta, (:array this))
    )

    #_method
    (§ defn #_"PersistentArrayMap" (§ method create) [#_"PersistentArrayMap" this, #_"Object..." ___init]
        (ß PersistentArrayMap'new-2((.meta this), ___init))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method createHT) [#_"PersistentArrayMap" this, #_"Object[]" ___init]
        (ß PersistentHashMap'create-2((.meta this), ___init))
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" ___init]
        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(+ ___i 2)]
            (loop-when-recur [#_"int" ___j (+ ___i 2)] (< ___j (§ alength ___init)) [(+ ___j 2)]
                (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (§ aget ___init ___i))))
                )
            )
        )
        (PersistentArrayMap'new-1 ___init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" ___init]
        (when (ß ((§ alength ___init) & 1) == 1)
            (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (§ aget ___init (ß (§ alength ___init) - 1)) ]))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" ___n 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(+ ___i 2)]
                (let [#_"boolean" ___duplicateKey false]
                    (loop-when-recur [#_"int" ___j 0] (< ___j ___i) [(+ ___j 2)]
                        (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                            (§ ass ___duplicateKey true)
                            (§ break )
                        )
                    )
                    (when (not ___duplicateKey)
                        (§ ass ___n (+ ___n 2))
                    )
                )
            )
            (when (< ___n (§ alength ___init))
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key. To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" ___nodups (make-array Object ___n)]
                    (let [#_"int" ___m 0]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(+ ___i 2)]
                            (let [#_"boolean" ___duplicateKey false]
                                (loop-when-recur [#_"int" ___j 0] (< ___j ___m) [(+ ___j 2)]
                                    (when (ß PersistentArrayMap'equalKey(___init[___i], ___nodups[___j]))
                                        (§ ass ___duplicateKey true)
                                        (§ break )
                                    )
                                )
                                (when (not ___duplicateKey)
                                    (§ let [#_"int" ___j]
                                        (loop-when-recur [___j (- (§ alength ___init) 2)] (>= ___j ___i) [(- ___j 2)]
                                            (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                                                (§ break )
                                            )
                                        )
                                        (§ ass (§ aget ___nodups ___m) (§ aget ___init ___i))
                                        (§ ass (§ aget ___nodups (ß ___m + 1)) (§ aget ___init (ß ___j + 1)))
                                        (§ ass ___m (+ ___m 2))
                                    )
                                )
                            )
                        )
                        (when (not= ___m ___n)
                            (throw (IllegalArgumentException. (str "Internal error: m=" ___m)))
                        )
                        (§ ass ___init ___nodups)
                    )
                )
            )
            (PersistentArrayMap'new-1 ___init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-1 [#_"Object[]" ___init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:array this) ___init)
            (§ ass (:_meta this) nil)
            this
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-2 [#_"IPersistentMap" ___meta, #_"Object[]" ___init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:array this) ___init)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentArrayMap" this]
        (ß (§ alength (:array this)) / 2)
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (ß (this.indexOf(___key) >= 0))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (>= ___i 0)
                (§ return (cast' IMapEntry (ß MapEntry'create((:array this)[___i], (:array this)[___i + 1]))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assocEx) [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (§ let [#_"Object[]" ___newArray]
                (cond (>= ___i 0)
                    (do
                        (throw (Util'runtimeException-1 "Key already present"))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß (§ alength (:array this)) > PersistentArrayMap'HASHTABLE_THRESHOLD)
                            (§ return (ß this.createHT((:array this)).assocEx(___key, ___val)))
                        )
                        (§ ass ___newArray (make-array Object (ß (§ alength (:array this)) + 2)))
                        (when (pos? (§ alength (:array this)))
                            (ß System/arraycopy((:array this), 0, ___newArray, 2, (§ alength (:array this))))
                        )
                        (§ ass (§ aget ___newArray (ß 0)) ___key)
                        (§ ass (§ aget ___newArray (ß 1)) ___val)
                    )
                )
                (.create this, ___newArray)
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assoc) [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (§ let [#_"Object[]" ___newArray]
                (cond (>= ___i 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß (:array this)[___i + 1] == ___val) ;; no change, no op
                            (§ return this)
                        )
                        (§ ass ___newArray (.clone (:array this)))
                        (§ ass (§ aget ___newArray (ß ___i + 1)) ___val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß (§ alength (:array this)) > PersistentArrayMap'HASHTABLE_THRESHOLD)
                            (§ return (ß this.createHT((:array this)).assoc(___key, ___val)))
                        )
                        (§ ass ___newArray (make-array Object (ß (§ alength (:array this)) + 2)))
                        (when (pos? (§ alength (:array this)))
                            (ß System/arraycopy((:array this), 0, ___newArray, 0, (§ alength (:array this))))
                        )
                        (§ ass (§ aget ___newArray (ß (§ alength ___newArray) - 2)) ___key)
                        (§ ass (§ aget ___newArray (ß (§ alength ___newArray) - 1)) ___val)
                    )
                )
                (.create this, ___newArray)
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method without) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (>= ___i 0) ;; have key, will remove
                (let [#_"int" ___newlen (ß (§ alength (:array this)) - 2)]
                    (when (zero? ___newlen)
                        (§ return (.empty this))
                    )
                    (let [#_"Object[]" ___newArray (make-array Object ___newlen)]
                        (System/arraycopy (:array this), 0, ___newArray, 0, ___i)
                        (ß System/arraycopy((:array this), ___i + 2, ___newArray, ___i, ___newlen - ___i))
                        (§ return (.create this, ___newArray))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method empty) [#_"PersistentArrayMap" this]
        (cast' IPersistentMap (.withMeta PersistentArrayMap'EMPTY, (.meta this)))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (>= ___i 0)
                (§ return (§ aget (:array this) (ß ___i + 1)))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"int" (§ method capacity) [#_"PersistentArrayMap" this]
        (count this)
    )

    #_method
    (§ defn- #_"int" (§ method indexOfObject) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"EquivPred" ___ep (Util'equivPred ___key)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:array this))) [(+ ___i 2)]
                (when (ß ___ep.equiv(___key, (:array this)[___i]))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn- #_"int" (§ method indexOf) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (if (§ instance? Keyword ___key)
            (do
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:array this))) [(+ ___i 2)]
                    (when (ß ___key == (:array this)[___i])
                        (§ return ___i)
                    )
                )
                -1
            )
            (do
                (.indexOfObject this, ___key)
            )
        )
    )

    (defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" ___k1, #_"Object" ___k2]
        (when (§ instance? Keyword ___k1)
            (§ return (= ___k1 ___k2))
        )
        (Util'equiv-2oo ___k1, ___k2)
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_ENTRY)
    )

    #_method
    (§ defn #_"Iterator" (§ method keyIterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_KEY)
    )

    #_method
    (§ defn #_"Iterator" (§ method valIterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_VAL)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentArrayMap" this]
        (when (pos? (§ alength (:array this)))
            (§ return (MSeq'new-2 (:array this), 0))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentArrayMap" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentArrayMap" this, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:array this))) [(+ ___i 2)]
            (§ ass ___init (ß ___f.invoke(___init, (:array this)[___i], (:array this)[___i + 1])))
            (when (RT'isReduced ___init)
                (§ return (.deref (cast' IDeref ___init)))
            )
        )
        ___init
    )

    #_method
    (§ defn #_"ITransientMap" (§ method asTransient) [#_"PersistentArrayMap" this]
        (TransientArrayMap'new (:array this))
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns TransientHashMap (§ extends ATransientMap)
    (defn- #_"TransientHashMap" TransientHashMap'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_volatile
            #_"INode" :root nil
            #_volatile
            #_"int" :count 0
            #_volatile
            #_"boolean" :hasNull false
            #_volatile
            #_"Object" :nullValue nil
            #_"Box" :leafFlag (Box'new nil)
        )
    )

    (defn #_"TransientHashMap" TransientHashMap'new-1 [#_"PersistentHashMap" ___m]
        (TransientHashMap'new-5 (AtomicReference. (Thread/currentThread)), (:root ___m), (:count ___m), (:hasNull ___m), (:nullValue ___m))
    )

    (defn #_"TransientHashMap" TransientHashMap'new-5 [#_"AtomicReference<Thread>" ___edit, #_"INode" ___root, #_"int" ___count, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (ATransientMap'new) (TransientHashMap'init))]
            (§ ass (:edit this) ___edit)
            (§ ass (:root this) ___root)
            (§ ass (:count this) ___count)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß (:nullValue this) != ___val)
                (§ ass (:nullValue this) ___val)
            )
            (when (not (:hasNull this))
                (§ ass (:count this) (ß (:count this) + 1))
                (§ ass (:hasNull this) true)
            )
            (§ return this)
        )
        (§ ass (:val (:leafFlag this)) nil)
        (let [#_"INode" ___n (.assoc (or (:root this) BitmapIndexedNode'EMPTY), (:edit this), 0, (PersistentHashMap'hash ___key), ___key, ___val, (:leafFlag this))]
            (when (ß ___n != (:root this))
                (§ ass (:root this) ___n)
            )
            (when (some? (:val (:leafFlag this)))
                (§ ass (:count this) (ß (:count this) + 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"TransientHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (when (not (:hasNull this))
                (§ return this)
            )
            (§ ass (:hasNull this) false)
            (§ ass (:nullValue this) nil)
            (§ ass (:count this) (ß (:count this) - 1))
            (§ return this)
        )
        (when (nil? (:root this))
            (§ return this)
        )
        (§ ass (:val (:leafFlag this)) nil)
        (let [#_"INode" ___n (ß (:root this).without((:edit this), 0, PersistentHashMap'hash(___key), ___key, (:leafFlag this)))]
            (when (ß ___n != (:root this))
                (§ ass (:root this) ___n)
            )
            (when (some? (:val (:leafFlag this)))
                (§ ass (:count this) (ß (:count this) - 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"TransientHashMap" this]
        (.set (:edit this), nil)
        (PersistentHashMap'new-4 (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"Object" (§ method doValAt) [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (if (:hasNull this)
                (do
                    (§ return (:nullValue this))
                )
                (do
                    (§ return ___notFound)
                )
            )
        )
        (when (nil? (:root this))
            (§ return ___notFound)
        )
        (ß (:root this).find(0, PersistentHashMap'hash(___key), ___key, ___notFound))
    )

    #_method
    (§ defn #_"int" (§ method doCount) [#_"TransientHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientHashMap" this]
        (when (nil? (.get (:edit this)))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(§ defprotocol INode
    #_abstract
    (#_"INode" INode'''(§ method assoc-6) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''(§ method without-4) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" INode'''(§ method find-4) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"Object" INode'''(§ method find-5) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (#_"ISeq" INode'''(§ method nodeSeq) [#_"INode" this])
    #_abstract
    (#_"INode" INode'''(§ method assoc-7) [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''(§ method without-6) [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf])
    #_abstract
    (#_"Object" INode'''(§ method kvreduce) [#_"INode" this, #_"IFn" ___f, #_"Object" ___init])
    #_abstract
    (#_"Object" INode'''(§ method fold) [#_"INode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin])
    ;; returns the result of (f [k v]) for each iterated element
    #_abstract
    (#_"Iterator" INode'''(§ method iterator) [#_"INode" this, #_"IFn" ___f])
)

(class-ns HSeq (§ extends ASeq)
    (defn #_"ISeq" HSeq'create-1 [#_"INode[]" ___nodes]
        (HSeq'create-4 nil, ___nodes, 0, nil)
    )

    (defn- #_"ISeq" HSeq'create-4 [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (HSeq'new ___meta, ___nodes, ___i, ___s))
        )
        (loop-when-recur [#_"int" ___j ___i] (< ___j (§ alength ___nodes)) [(inc ___j)]
            (when (some? (§ aget ___nodes ___j))
                (let [#_"ISeq" ___ns (ß ___nodes[___j].nodeSeq())]
                    (when (some? ___ns)
                        (§ return (ß HSeq'new(___meta, ___nodes, ___j + 1, ___ns)))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"HSeq" HSeq'init []
        (hash-map
            #_"INode[]" :nodes nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn- #_"HSeq" HSeq'new [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (let [this (merge (ASeq'new ___meta) (HSeq'init))]
            (§ ass (:nodes this) ___nodes)
            (§ ass (:i this) ___i)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"HSeq" this, #_"IPersistentMap" ___meta]
        (HSeq'new ___meta, (:nodes this), (:i this), (:s this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"HSeq" this]
        (first (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"HSeq" this]
        (ß HSeq'create-4(nil, (:nodes this), (:i this), (:s this).next()))
    )
)

(class-ns HIter (§ implements Iterator)
    (defn- #_"HIter" HIter'init []
        (hash-map
            #_"INode[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Iterator" :nestedIter nil
        )
    )

    (defn- #_"HIter" HIter'new [#_"INode[]" ___array, #_"IFn" ___f]
        (let [this (HIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"HIter" this]
        (while true
            (when (some? (:nestedIter this))
                (if (.hasNext (:nestedIter this))
                    (do
                        (§ return true)
                    )
                    (do
                        (§ ass (:nestedIter this) nil)
                    )
                )
            )

            (if (ß (:i this) < (§ alength (:array this)))
                (do
                    (let [#_"INode" ___node (§ aget (:array this) (:i this))]
                        (§ ass (:i this) (+ (:i this) 1))
                        (when (some? ___node)
                            (§ ass (:nestedIter this) (.iterator ___node, (:f this)))
                        )
                    )
                )
                (do
                    (§ return false)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"HIter" this]
        (if (.hasNext this)
            (do
                (next (:nestedIter this))
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"HIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ArrayNode (§ implements INode)
    (defn- #_"ArrayNode" ArrayNode'init []
        (hash-map
            #_"int" :count 0
            #_"INode[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"ArrayNode" ArrayNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"INode[]" ___array]
        (let [this (ArrayNode'init)]
            (§ ass (:array this) ___array)
            (§ ass (:edit this) ___edit)
            (§ ass (:count this) ___count)
            this
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (mask ___hash, ___shift)]
            (let [#_"INode" ___node (§ aget (:array this) ___idx)]
                (when (nil? ___node)
                    (§ return (ß ArrayNode'new(nil, (:count this) + 1, cloneAndSet((:array this), ___idx, BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))))
                )
                (let [#_"INode" ___n (ß ___node.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (= ___n ___node)
                        (§ return this)
                    )
                    (ß ArrayNode'new(nil, (:count this), cloneAndSet((:array this), ___idx, ___n)))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (mask ___hash, ___shift)]
            (let [#_"INode" ___node (§ aget (:array this) ___idx)]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___shift + 5, ___hash, ___key))]
                    (when (= ___n ___node)
                        (§ return this)
                    )
                    (if (nil? ___n)
                        (do
                            (when (ß (:count this) <= 8) ;; shrink
                                (§ return (.pack this, nil, ___idx))
                            )
                            (ß ArrayNode'new(nil, (:count this) - 1, cloneAndSet((:array this), ___idx, ___n)))
                        )
                        (do
                            (ß ArrayNode'new(nil, (:count this), cloneAndSet((:array this), ___idx, ___n)))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (mask ___hash, ___shift)]
            (let [#_"INode" ___node (§ aget (:array this) ___idx)]
                (when (nil? ___node)
                    (§ return nil)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (mask ___hash, ___shift)]
            (let [#_"INode" ___node (§ aget (:array this) ___idx)]
                (when (nil? ___node)
                    (§ return ___notFound)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key, ___notFound))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"ArrayNode" this]
        (HSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ArrayNode" this, #_"IFn" ___f]
        (HIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"ArrayNode" this, #_"IFn" ___f, #_"Object" ___init]
        (doseq [#_"INode" ___node (:array this)]
            (when (some? ___node)
                (§ ass ___init (.kvreduce ___node, ___f, ___init))
                (when (RT'isReduced ___init)
                    (§ return ___init)
                )
            )
        )
        ___init
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"ArrayNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (let [#_"List<Callable>" ___tasks (ArrayList.)]
            (doseq [#_"INode" ___node (:array this)]
                (when (some? ___node)
                    (ß ___tasks.add(
                            (§ reify Callable()
                                #_method
                                (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                                    (.fold ___node, ___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin)
                                )
                            )
                        )
                    )
                )
            )

            (ArrayNode'foldTasks ___tasks, ___combinef, ___fjtask, ___fjfork, ___fjjoin)
        )
    )

    (defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" ___tasks, #_"IFn" ___combinef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (when (.isEmpty ___tasks)
            (§ return (.invoke ___combinef))
        )

        (when (ß (.size ___tasks) == 1)
            (let [#_"Object" ___ret nil]
                (try
                    (§ return (ß ___tasks.get(0).call()))
                    (catch Exception ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
        )

        (let [#_"List<Callable>" ___t1 (ß ___tasks.subList(0, (.size ___tasks) / 2))]
            (let [#_"List<Callable>" ___t2 (ß ___tasks.subList((.size ___tasks) / 2, (.size ___tasks)))]
                (let [#_"Object" ___forked
                        (ß ___fjfork.invoke(___fjtask.invoke(
                                (§ reify Callable()
                                    #_method
                                    (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                                        (ArrayNode'foldTasks ___t2, ___combinef, ___fjtask, ___fjfork, ___fjjoin)
                                    )
                                )
                            ))
                        )]
                    (ß ___combinef.invoke(ArrayNode'foldTasks(___t1, ___combinef, ___fjtask, ___fjfork, ___fjjoin), ___fjjoin.invoke(___forked)))
                )
            )
        )
    )

    #_method
    (§ defn- #_"ArrayNode" (§ method ensureEditable) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (ß ArrayNode'new(___edit, (:count this), (:array this).clone()))
    )

    #_method
    (§ defn- #_"ArrayNode" (§ method editAndSet) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"INode" ___n]
        (let [#_"ArrayNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (§ aget (:array ___editable) ___i) ___n)
            ___editable
        )
    )

    #_method
    (§ defn- #_"INode" (§ method pack) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___idx]
        (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) - 1)))]
            (let [#_"int" ___j 1]
                (let [#_"int" ___bitmap 0]
                    (loop-when-recur [#_"int" ___i 0] (< ___i ___idx) [(inc ___i)]
                        (when (some? (§ aget (:array this) ___i))
                            (§ ass (§ aget ___newArray ___j) (§ aget (:array this) ___i))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (+ ___j 2))
                        )
                    )
                    (loop-when-recur [#_"int" ___i (inc ___idx)] (ß ___i < (§ alength (:array this))) [(inc ___i)]
                        (when (some? (§ aget (:array this) ___i))
                            (§ ass (§ aget ___newArray ___j) (§ aget (:array this) ___i))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (+ ___j 2))
                        )
                    )
                    (BitmapIndexedNode'new ___edit, ___bitmap, ___newArray)
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (mask ___hash, ___shift)]
            (let [#_"INode" ___node (§ aget (:array this) ___idx)]
                (when (nil? ___node)
                    (let [#_"ArrayNode" ___editable (ß this.editAndSet(___edit, ___idx, BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))]
                        (§ ass (:count ___editable) (ß (:count ___editable) + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"INode" ___n (ß ___node.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (= ___n ___node)
                        (§ return this)
                    )
                    (.editAndSet this, ___edit, ___idx, ___n)
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (mask ___hash, ___shift)]
            (let [#_"INode" ___node (§ aget (:array this) ___idx)]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                    (when (= ___n ___node)
                        (§ return this)
                    )
                    (when (nil? ___n)
                        (when (ß (:count this) <= 8) ;; shrink
                            (§ return (.pack this, ___edit, ___idx))
                        )
                        (let [#_"ArrayNode" ___editable (.editAndSet this, ___edit, ___idx, ___n)]
                            (§ ass (:count ___editable) (ß (:count ___editable) - 1))
                            (§ return ___editable)
                        )
                    )
                    (.editAndSet this, ___edit, ___idx, ___n)
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode (§ implements INode)
    (def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (ß BitmapIndexedNode'new(nil, 0, new Object[0])))

    (defn- #_"BitmapIndexedNode" BitmapIndexedNode'init []
        (hash-map
            #_"int" :bitmap 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"BitmapIndexedNode" BitmapIndexedNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___bitmap, #_"Object[]" ___array]
        (let [this (BitmapIndexedNode'init)]
            (§ ass (:bitmap this) ___bitmap)
            (§ ass (:array this) ___array)
            (§ ass (:edit this) ___edit)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"BitmapIndexedNode" this, #_"int" ___bit]
        (ß Integer/bitCount((:bitmap this) & (___bit - 1)))
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (bitpos ___hash, ___shift)]
            (let [#_"int" ___idx (.index this, ___bit)]
                (if (ß ((:bitmap this) & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (§ aget (:array this) (ß 2 * ___idx))]
                            (let [#_"Object" ___valOrNode (§ aget (:array this) (ß 2 * ___idx + 1))]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß (cast' INode ___valOrNode).assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (= ___n ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___n))))
                                    )
                                )
                                (when (Util'equiv-2oo ___key, ___keyOrNull)
                                    (when (= ___val ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___val))))
                                )
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx, nil, 2 * ___idx + 1, createNode(___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val))))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
                            (if (>= ___n 16)
                                (do
                                    (let [#_"INode[]" ___nodes (§ typeless make-array INode 32)]
                                        (let [#_"int" ___jdx (mask ___hash, ___shift)]
                                            (§ ass (§ aget ___nodes ___jdx) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [#_"int" ___i 0] (< ___i 32) [(inc ___i)]
                                                    (when (ß (((:bitmap this) >>> ___i) & 1) != 0)
                                                        (if (nil? (§ aget (:array this) ___j))
                                                            (do
                                                                (§ ass (§ aget ___nodes ___i) (cast' INode (§ aget (:array this) (ß ___j + 1))))
                                                            )
                                                            (do
                                                                (§ ass (§ aget ___nodes ___i) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, PersistentHashMap'hash((:array this)[___j]), (:array this)[___j], (:array this)[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (+ ___j 2))
                                                    )
                                                )
                                                (ß ArrayNode'new(nil, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (make-array Object (ß 2 * (___n + 1)))]
                                        (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (§ aget ___newArray (ß 2 * ___idx)) ___key)
                                        (§ ass (:val ___addedLeaf) ___addedLeaf)
                                        (§ ass (§ aget ___newArray (ß 2 * ___idx + 1)) ___val)
                                        (ß System/arraycopy((:array this), 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (ß BitmapIndexedNode'new(nil, (:bitmap this) | ___bit, ___newArray))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (bitpos ___hash, ___shift)]
            (when (zero? (ß (:bitmap this) & ___bit))
                (§ return this)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (§ aget (:array this) (ß 2 * ___idx))]
                    (let [#_"Object" ___valOrNode (§ aget (:array this) (ß 2 * ___idx + 1))]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß (cast' INode ___valOrNode).without(___shift + 5, ___hash, ___key))]
                                (when (= ___n ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___n))))
                                )
                                (when (ß (:bitmap this) == ___bit)
                                    (§ return nil)
                                )
                                (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this) :xor ___bit, removePair((:array this), ___idx))))
                            )
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            ;; TODO: collapse
                            (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this) :xor ___bit, removePair((:array this), ___idx))))
                        )
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (bitpos ___hash, ___shift)]
            (when (zero? (ß (:bitmap this) & ___bit))
                (§ return nil)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (§ aget (:array this) (ß 2 * ___idx))]
                    (let [#_"Object" ___valOrNode (§ aget (:array this) (ß 2 * ___idx + 1))]
                        (when (nil? ___keyOrNull)
                            (§ return (ß (cast' INode ___valOrNode).find(___shift + 5, ___hash, ___key)))
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ return (cast' IMapEntry (MapEntry'create ___keyOrNull, ___valOrNode)))
                        )
                        nil
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___bit (bitpos ___hash, ___shift)]
            (when (zero? (ß (:bitmap this) & ___bit))
                (§ return ___notFound)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (§ aget (:array this) (ß 2 * ___idx))]
                    (let [#_"Object" ___valOrNode (§ aget (:array this) (ß 2 * ___idx + 1))]
                        (when (nil? ___keyOrNull)
                            (§ return (ß (cast' INode ___valOrNode).find(___shift + 5, ___hash, ___key, ___notFound)))
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ return ___valOrNode)
                        )
                        ___notFound
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"BitmapIndexedNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"BitmapIndexedNode" this, #_"IFn" ___f]
        (NodeIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"BitmapIndexedNode" this, #_"IFn" ___f, #_"Object" ___init]
        (NodeSeq'kvreduce (:array this), ___f, ___init)
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"BitmapIndexedNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce((:array this), ___reducef, (.invoke ___combinef)))
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method ensureEditable) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
            (let [#_"Object[]" ___newArray (make-array Object (if (<= 0 ___n) (* 2 (+ ___n 1)) 4))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, ___newArray, 0, (* 2 ___n))
                (BitmapIndexedNode'new ___edit, (:bitmap this), ___newArray)
            )
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndSet) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (§ aget (:array ___editable) ___i) ___a)
            ___editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndSet) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (§ aget (:array ___editable) ___i) ___a)
            (§ ass (§ aget (:array ___editable) ___j) ___b)
            ___editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndRemovePair) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___bit, #_"int" ___i]
        (when (ß (:bitmap this) == ___bit)
            (§ return nil)
        )
        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) :xor ___bit))
            (ß System/arraycopy((:array ___editable), 2 * (___i + 1), (:array ___editable), 2 * ___i, (§ alength (:array ___editable)) - 2 * (___i + 1)))
            (§ ass (§ aget (:array ___editable) (ß (§ alength (:array ___editable)) - 2)) nil)
            (§ ass (§ aget (:array ___editable) (ß (§ alength (:array ___editable)) - 1)) nil)
            ___editable
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (bitpos ___hash, ___shift)]
            (let [#_"int" ___idx (.index this, ___bit)]
                (if (ß ((:bitmap this) & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (§ aget (:array this) (ß 2 * ___idx))]
                            (let [#_"Object" ___valOrNode (§ aget (:array this) (ß 2 * ___idx + 1))]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß (cast' INode ___valOrNode).assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (= ___n ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß this.editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                    )
                                )
                                (when (Util'equiv-2oo ___key, ___keyOrNull)
                                    (when (= ___val ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß this.editAndSet(___edit, 2 * ___idx + 1, ___val)))
                                )
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (ß this.editAndSet(___edit, 2 * ___idx, nil, 2 * ___idx + 1, createNode(___edit, ___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val)))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
                            (when (ß ___n * 2 < (§ alength (:array this)))
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
                                    (ß System/arraycopy((:array ___editable), 2 * ___idx, (:array ___editable), 2 * (___idx + 1), 2 * (___n - ___idx)))
                                    (§ ass (§ aget (:array ___editable) (ß 2 * ___idx)) ___key)
                                    (§ ass (§ aget (:array ___editable) (ß 2 * ___idx + 1)) ___val)
                                    (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) | ___bit))
                                    (§ return ___editable)
                                )
                            )
                            (if (>= ___n 16)
                                (do
                                    (let [#_"INode[]" ___nodes (§ typeless make-array INode 32)]
                                        (let [#_"int" ___jdx (mask ___hash, ___shift)]
                                            (§ ass (§ aget ___nodes ___jdx) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [#_"int" ___i 0] (< ___i 32) [(inc ___i)]
                                                    (when (ß (((:bitmap this) >>> ___i) & 1) != 0)
                                                        (if (nil? (§ aget (:array this) ___j))
                                                            (do
                                                                (§ ass (§ aget ___nodes ___i) (cast' INode (§ aget (:array this) (ß ___j + 1))))
                                                            )
                                                            (do
                                                                (§ ass (§ aget ___nodes ___i) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, PersistentHashMap'hash((:array this)[___j]), (:array this)[___j], (:array this)[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (+ ___j 2))
                                                    )
                                                )
                                                (ß ArrayNode'new(___edit, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (make-array Object (ß 2 * (___n + 4)))]
                                        (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (§ aget ___newArray (ß 2 * ___idx)) ___key)
                                        (§ ass (:val ___addedLeaf) ___addedLeaf)
                                        (§ ass (§ aget ___newArray (ß 2 * ___idx + 1)) ___val)
                                        (ß System/arraycopy((:array this), 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
                                            (§ ass (:array ___editable) ___newArray)
                                            (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) | ___bit))
                                            ___editable
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___bit (bitpos ___hash, ___shift)]
            (when (zero? (ß (:bitmap this) & ___bit))
                (§ return this)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (§ aget (:array this) (ß 2 * ___idx))]
                    (let [#_"Object" ___valOrNode (§ aget (:array this) (ß 2 * ___idx + 1))]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß (cast' INode ___valOrNode).without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                                (when (= ___n ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß this.editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                )
                                (when (ß (:bitmap this) == ___bit)
                                    (§ return nil)
                                )
                                (§ return (.editAndRemovePair this, ___edit, ___bit, ___idx))
                            )
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ ass (:val ___removedLeaf) ___removedLeaf)
                            ;; TODO: collapse
                            (§ return (.editAndRemovePair this, ___edit, ___bit, ___idx))
                        )
                        this
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode (§ implements INode)
    (defn- #_"HashCollisionNode" HashCollisionNode'init []
        (hash-map
            #_"int" :hash 0
            #_"int" :count 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"HashCollisionNode" HashCollisionNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___hash, #_"int" ___count, #_"Object..." ___array]
        (let [this (HashCollisionNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:hash this) ___hash)
            (§ ass (:count this) ___count)
            (§ ass (:array this) ___array)
            this
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == (:hash this))
            (let [#_"int" ___idx (.findIndex this, ___key)]
                (when (not= ___idx -1)
                    (when (ß (:array this)[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß HashCollisionNode'new(nil, ___hash, (:count this), cloneAndSet((:array this), ___idx + 1, ___val))))
                )
                (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) + 1)))]
                    (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * (:count this)))
                    (§ ass (§ aget ___newArray (ß 2 * (:count this))) ___key)
                    (§ ass (§ aget ___newArray (ß 2 * (:count this) + 1)) ___val)
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (§ return (ß HashCollisionNode'new((:edit this), ___hash, (:count this) + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß BitmapIndexedNode'new(nil, bitpos((:hash this), ___shift), (object-array [ nil, this ])).assoc(___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (= ___idx -1)
                (§ return this)
            )
            (when (ß (:count this) == 1)
                (§ return nil)
            )
            (ß HashCollisionNode'new(nil, ___hash, (:count this) - 1, removePair((:array this), ___idx / 2)))
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (< ___idx 0)
                (§ return nil)
            )
            (when (ß Util'equiv-2oo(___key, (:array this)[___idx]))
                (§ return (cast' IMapEntry (ß MapEntry'create((:array this)[___idx], (:array this)[___idx + 1]))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (< ___idx 0)
                (§ return ___notFound)
            )
            (when (ß Util'equiv-2oo(___key, (:array this)[___idx]))
                (§ return (§ aget (:array this) (ß ___idx + 1)))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"HashCollisionNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"HashCollisionNode" this, #_"IFn" ___f]
        (NodeIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"HashCollisionNode" this, #_"IFn" ___f, #_"Object" ___init]
        (NodeSeq'kvreduce (:array this), ___f, ___init)
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"HashCollisionNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce((:array this), ___reducef, (.invoke ___combinef)))
    )

    #_method
    (§ defn #_"int" (§ method findIndex) [#_"HashCollisionNode" this, #_"Object" ___key]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < 2 * (:count this)) [(+ ___i 2)]
            (when (ß Util'equiv-2oo(___key, (:array this)[___i]))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method ensureEditable) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) + 1)))] ;; make room for next assoc
            (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * (:count this)))
            (HashCollisionNode'new ___edit, (:hash this), (:count this), ___newArray)
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method ensureEditable) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"Object[]" ___array]
        (when (ß (:edit this) == ___edit)
            (§ ass (:array this) ___array)
            (§ ass (:count this) ___count)
            (§ return this)
        )
        (HashCollisionNode'new ___edit, (:hash this), ___count, ___array)
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method editAndSet) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"HashCollisionNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (§ aget (:array ___editable) ___i) ___a)
            ___editable
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method editAndSet) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"HashCollisionNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (§ aget (:array ___editable) ___i) ___a)
            (§ ass (§ aget (:array ___editable) ___j) ___b)
            ___editable
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == (:hash this))
            (let [#_"int" ___idx (.findIndex this, ___key)]
                (when (not= ___idx -1)
                    (when (ß (:array this)[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß this.editAndSet(___edit, ___idx + 1, ___val)))
                )
                (when (ß (§ alength (:array this)) > 2 * (:count this))
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (let [#_"HashCollisionNode" ___editable (ß this.editAndSet(___edit, 2 * (:count this), ___key, 2 * (:count this) + 1, ___val))]
                        (§ ass (:count ___editable) (ß (:count ___editable) + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"Object[]" ___newArray (make-array Object (ß (§ alength (:array this)) + 2))]
                    (ß System/arraycopy((:array this), 0, ___newArray, 0, (§ alength (:array this))))
                    (§ ass (§ aget ___newArray (ß (§ alength (:array this)))) ___key)
                    (§ ass (§ aget ___newArray (ß (§ alength (:array this)) + 1)) ___val)
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (§ return (ß this.ensureEditable(___edit, (:count this) + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß BitmapIndexedNode'new(___edit, bitpos((:hash this), ___shift), (object-array [ nil, this, nil, nil ])).assoc(___edit, ___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (= ___idx -1)
                (§ return this)
            )
            (§ ass (:val ___removedLeaf) ___removedLeaf)
            (when (ß (:count this) == 1)
                (§ return nil)
            )
            (let [#_"HashCollisionNode" ___editable (.ensureEditable this, ___edit)]
                (§ ass (§ aget (:array ___editable) ___idx) (§ aget (:array ___editable) (ß 2 * (:count this) - 2)))
                (§ ass (§ aget (:array ___editable) (ß ___idx + 1)) (§ aget (:array ___editable) (ß 2 * (:count this) - 1)))
                (§ ass (§ aget (:array ___editable) (ß 2 * (:count this) - 2)) (§ ass (§ aget (:array ___editable) (ß 2 * (:count this) - 1)) nil))
                (§ ass (:count ___editable) (ß (:count ___editable) - 1))
                ___editable
            )
        )
    )
)

(class-ns NodeIter (§ implements Iterator)
    (def- #_"Object" NodeIter'NULL (Object.))

    (defn- #_"NodeIter" NodeIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Object" :nextEntry NodeIter'NULL
            #_"Iterator" :nextIter nil
        )
    )

    (defn #_"NodeIter" NodeIter'new [#_"Object[]" ___array, #_"IFn" ___f]
        (let [this (NodeIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method advance) [#_"NodeIter" this]
        (while (ß (:i this) < (§ alength (:array this)))
            (let [#_"Object" ___key (§ aget (:array this) (:i this))]
                (let [#_"Object" ___nodeOrVal (§ aget (:array this) (ß (:i this) + 1))]
                    (§ ass (:i this) (+ (:i this) 2))
                    (cond (some? ___key)
                        (do
                            (§ ass (:nextEntry this) (.invoke (:f this), ___key, ___nodeOrVal))
                            (§ return true)
                        )
                        (some? ___nodeOrVal)
                        (do
                            (let [#_"Iterator" ___iter (.iterator (cast' INode ___nodeOrVal), (:f this))]
                                (when (and (some? ___iter) (.hasNext ___iter))
                                    (§ ass (:nextIter this) ___iter)
                                    (§ return true)
                                )
                            )
                        )
                    )
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"NodeIter" this]
        (when (or (ß (:nextEntry this) != NodeIter'NULL) (some? (:nextIter this)))
            (§ return true)
        )
        (.advance this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"NodeIter" this]
        (let [#_"Object" ___ret (:nextEntry this)]
            (cond (not= ___ret NodeIter'NULL)
                (do
                    (§ ass (:nextEntry this) NodeIter'NULL)
                    (§ return ___ret)
                )
                (some? (:nextIter this))
                (do
                    (§ ass ___ret (next (:nextIter this)))
                    (when (not (.hasNext (:nextIter this)))
                        (§ ass (:nextIter this) nil)
                    )
                    (§ return ___ret)
                )
                (.advance this)
                (do
                    (§ return (next this))
                )
            )
            (throw (NoSuchElementException.))
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"NodeIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns NodeSeq (§ extends ASeq)
    (defn- #_"NodeSeq" NodeSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-2 [#_"Object[]" ___array, #_"int" ___i]
        (NodeSeq'new-4 nil, ___array, ___i, nil)
    )

    (defn #_"ISeq" NodeSeq'create-1 [#_"Object[]" ___array]
        (NodeSeq'create-3 ___array, 0, nil)
    )

    (defn #_"Object" NodeSeq'kvreduce [#_"Object[]" ___array, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___array)) [(+ ___i 2)]
            (if (some? (§ aget ___array ___i))
                (do
                    (§ ass ___init (ß ___f.invoke(___init, ___array[___i], ___array[___i + 1])))
                )
                (do
                    (let [#_"INode" ___node (cast' INode (§ aget ___array (ß ___i + 1)))]
                        (when (some? ___node)
                            (§ ass ___init (.kvreduce ___node, ___f, ___init))
                        )
                    )
                )
            )
            (when (RT'isReduced ___init)
                (§ return ___init)
            )
        )
        ___init
    )

    (defn- #_"ISeq" NodeSeq'create-3 [#_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (NodeSeq'new-4 nil, ___array, ___i, ___s))
        )
        (loop-when-recur [#_"int" ___j ___i] (< ___j (§ alength ___array)) [(+ ___j 2)]
            (when (some? (§ aget ___array ___j))
                (§ return (NodeSeq'new-4 nil, ___array, ___j, nil))
            )
            (let [#_"INode" ___node (cast' INode (§ aget ___array (ß ___j + 1)))]
                (when (some? ___node)
                    (let [#_"ISeq" ___nodeSeq (.nodeSeq ___node)]
                        (when (some? ___nodeSeq)
                            (§ return (ß NodeSeq'new-4(nil, ___array, ___j + 2, ___nodeSeq)))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"NodeSeq" NodeSeq'new-4 [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (let [this (merge (ASeq'new ___meta) (NodeSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"NodeSeq" this, #_"IPersistentMap" ___meta]
        (NodeSeq'new-4 ___meta, (:array this), (:i this), (:s this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"NodeSeq" this]
        (when (some? (:s this))
            (§ return (first (:s this)))
        )
        (ß MapEntry'create((:array this)[(:i this)], (:array this)[(:i this) + 1]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"NodeSeq" this]
        (when (some? (:s this))
            (§ return (ß NodeSeq'create-3((:array this), (:i this), (:s this).next())))
        )
        (ß NodeSeq'create-3((:array this), (:i this) + 2, nil))
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" PersistentHashMap'EMPTY (PersistentHashMap'new-4 0, nil, false, nil))
    (def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (defn #_"IPersistentMap" PersistentHashMap'create-1m [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (doseq [#_"Object" ___o (.entrySet ___other)]
                (let [#_"Map$Entry" ___e (cast' Entry ___o)]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (.persistent ___ret)
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-1a [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(+ ___i 2)]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
            )
            (cast' PersistentHashMap (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1a [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(+ ___i 2)]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
                (when (ß (count ___ret) != ___i / 2 + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (§ aget ___init ___i))))
                )
            )
            (cast' PersistentHashMap (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1s [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [___items ___items] (some? ___items) [(next (next ___items))]
                (when (nil? (next ___items))
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
            )
            (cast' PersistentHashMap (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1s [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [___items ___items #_"int" ___i 0] (some? ___items) [(next (next ___items)) (inc ___i)]
                (when (nil? (next ___items))
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
                (when (ß (count ___ret) != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (first ___items))))
                )
            )
            (cast' PersistentHashMap (.persistent ___ret))
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-2 [#_"IPersistentMap" ___meta, #_"Object..." ___init]
        (ß this.create(___init).withMeta(___meta))
    )

    (defn- #_"PersistentHashMap" PersistentHashMap'init []
        (hash-map
            #_"int" :count 0
            #_"INode" :root nil
            #_"boolean" :hasNull false
            #_"Object" :nullValue nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-4 [#_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass (:count this) ___count)
            (§ ass (:root this) ___root)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            (§ ass (:_meta this) nil)
            this
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-5 [#_"IPersistentMap" ___meta, #_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:count this) ___count)
            (§ ass (:root this) ___root)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            this
        )
    )

    (defn #_"int" PersistentHashMap'hash [#_"Object" ___k]
        (Util'hasheq ___k)
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (:hasNull this))
        )
        (and (some? (:root this)) (ß (ß (:root this).find(0, PersistentHashMap'hash(___key), ___key, PersistentHashMap'NOT_FOUND)) != PersistentHashMap'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (when (:hasNull this) (cast' IMapEntry (MapEntry'create nil, (:nullValue this)))))
        )
        (when (some? (:root this)) (ß (:root this).find(0, PersistentHashMap'hash(___key), ___key)))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assoc) [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (and (:hasNull this) (ß ___val == (:nullValue this)))
                (§ return this)
            )
            (§ return (PersistentHashMap'new-5 (.meta this), (if (:hasNull this) (:count this) (inc (:count this))), (:root this), true, ___val))
        )
        (let [#_"Box" ___addedLeaf (Box'new nil)]
            (let [#_"INode" ___newroot (.assoc (or (:root this) BitmapIndexedNode'EMPTY), 0, (PersistentHashMap'hash ___key), ___key, ___val, ___addedLeaf)]
                (when (ß ___newroot == (:root this))
                    (§ return this)
                )
                (PersistentHashMap'new-5 (.meta this), (if (nil? (:val ___addedLeaf)) (:count this) (inc (:count this))), ___newroot, (:hasNull this), (:nullValue this))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (§ return (if (:hasNull this) (:nullValue this) ___notFound))
        )
        (if (some? (:root this)) (ß (:root this).find(0, PersistentHashMap'hash(___key), ___key, ___notFound)) ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentHashMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assocEx) [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (.containsKey this, ___key)
            (throw (Util'runtimeException-1 "Key already present"))
        )
        (.assoc this, ___key, ___val)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method without) [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (if (:hasNull this) (PersistentHashMap'new-5 (.meta this), (dec (:count this)), (:root this), false, nil) this))
        )
        (when (nil? (:root this))
            (§ return this)
        )
        (let [#_"INode" ___newroot (ß (:root this).without(0, PersistentHashMap'hash(___key), ___key))]
            (when (ß ___newroot == (:root this))
                (§ return this)
            )
            (ß PersistentHashMap'new-5((.meta this), (:count this) - 1, ___newroot, (:hasNull this), (:nullValue this)))
        )
    )

    (def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn- #_"Iterator" (§ method iterator) [#_"PersistentHashMap" this, #_"IFn" ___f]
        (let [#_"Iterator" ___rootIter (if (nil? (:root this)) PersistentHashMap'EMPTY_ITER (.iterator (:root this), ___f))]
            (if (:hasNull this)
                (do
                    (§ reify Iterator()
                        (§ init
                            (hash-map
                                #_"boolean" :seen false
                            )
                        )

                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (if (not (:seen this))
                                (do
                                    true
                                )
                                (do
                                    (.hasNext ___rootIter)
                                )
                            )
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (if (not (:seen this))
                                (do
                                    (§ ass (:seen this) true)
                                    (.invoke ___f, nil, (:nullValue this))
                                )
                                (do
                                    (next ___rootIter)
                                )
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
                (do
                    ___rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentHashMap" this]
        (.iterator this, APersistentMap'MAKE_ENTRY)
    )

    #_method
    (§ defn #_"Iterator" (§ method keyIterator) [#_"PersistentHashMap" this]
        (.iterator this, APersistentMap'MAKE_KEY)
    )

    #_method
    (§ defn #_"Iterator" (§ method valIterator) [#_"PersistentHashMap" this]
        (.iterator this, APersistentMap'MAKE_VAL)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentHashMap" this, #_"IFn" ___f, #_"Object" ___init]
        (§ ass ___init (if (:hasNull this) (.invoke ___f, ___init, nil, (:nullValue this)) ___init))
        (when (RT'isReduced ___init)
            (§ return (.deref (cast' IDeref ___init)))
        )
        (when (some? (:root this))
            (§ ass ___init (.kvreduce (:root this), ___f, ___init))
            (if (RT'isReduced ___init)
                (do
                    (§ return (.deref (cast' IDeref ___init)))
                )
                (do
                    (§ return ___init)
                )
            )
        )
        ___init
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"PersistentHashMap" this, #_"long" ___n, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjinvoke, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" ___top
                (§ reify Callable()
                    #_method
                    (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                        (let [#_"Object" ___ret (.invoke ___combinef)]
                            (when (some? (:root this))
                                (§ ass ___ret (ß ___combinef.invoke(___ret, (:root this).fold(___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin))))
                            )
                            (if (:hasNull this) (ß ___combinef.invoke(___ret, ___reducef.invoke((.invoke ___combinef), nil, (:nullValue this)))) ___ret)
                        )
                    )
                )]
            (.invoke ___fjinvoke, ___top)
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentHashMap" this]
        (let [#_"ISeq" ___s (when (some? (:root this)) (.nodeSeq (:root this)))]
            (if (:hasNull this) (Cons'new-2 (MapEntry'create nil, (:nullValue this)), ___s) ___s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentHashMap" this]
        (.withMeta PersistentHashMap'EMPTY, (.meta this))
    )

    (defn #_"int" PersistentHashMap'mask [#_"int" ___hash, #_"int" ___shift]
        (ß (___hash >>> ___shift) & 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" (§ method withMeta) [#_"PersistentHashMap" this, #_"IPersistentMap" ___meta]
        (PersistentHashMap'new-5 ___meta, (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"TransientHashMap" (§ method asTransient) [#_"PersistentHashMap" this]
        (TransientHashMap'new-1 this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentHashMap" this]
        (:_meta this)
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-3 [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a]
        (let [#_"Object[]" ___clone (.clone ___array)]
            (§ ass (§ aget ___clone ___i) ___a)
            ___clone
        )
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-5 [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"Object[]" ___clone (.clone ___array)]
            (§ ass (§ aget ___clone ___i) ___a)
            (§ ass (§ aget ___clone ___j) ___b)
            ___clone
        )
    )

    (defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" ___array, #_"int" ___i]
        (let [#_"Object[]" ___newArray (make-array Object (- (§ alength ___array) 2))]
            (ß System/arraycopy(___array, 0, ___newArray, 0, 2 * ___i))
            (ß System/arraycopy(___array, 2 * (___i + 1), ___newArray, 2 * ___i, (§ alength ___newArray) - 2 * ___i))
            ___newArray
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-6 [#_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (PersistentHashMap'hash ___key1)]
            (when (= ___key1hash ___key2hash)
                (§ return (ß HashCollisionNode'new(nil, ___key1hash, 2, (object-array [ ___key1, ___val1, ___key2, ___val2 ]))))
            )
            (let [#_"Box" ___addedLeaf (Box'new nil)]
                (let [#_"AtomicReference<Thread>" ___edit (AtomicReference.)]
                    (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
                )
            )
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-7 [#_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (PersistentHashMap'hash ___key1)]
            (when (= ___key1hash ___key2hash)
                (§ return (ß HashCollisionNode'new(nil, ___key1hash, 2, (object-array [ ___key1, ___val1, ___key2, ___val2 ]))))
            )
            (let [#_"Box" ___addedLeaf (Box'new nil)]
                (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
            )
        )
    )

    (defn- #_"int" PersistentHashMap'bitpos [#_"int" ___hash, #_"int" ___shift]
        (ß 1 << mask(___hash, ___shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_stateless
(class-ns TransientHashSet (§ extends ATransientSet)
    (defn #_"TransientHashSet" TransientHashSet'new [#_"ITransientMap" ___impl]
        (ATransientSet'new ___impl)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method persistent) [#_"TransientHashSet" this]
        (ß PersistentHashSet'new(nil, (:impl this).persistent()))
    )
)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" PersistentHashSet'EMPTY (PersistentHashSet'new nil, PersistentHashMap'EMPTY))

    (defn #_"PersistentHashSet" PersistentHashSet'create-1a [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(inc ___i)]
                (§ ass ___ret (cast' ITransientSet (ß ___ret.conj(___init[___i]))))
            )
            (cast' PersistentHashSet (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1l [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (doseq [#_"Object" ___key ___init]
                (§ ass ___ret (cast' ITransientSet (.conj ___ret, ___key)))
            )
            (cast' PersistentHashSet (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1s [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                (§ ass ___ret (cast' ITransientSet (.conj ___ret, (first ___items))))
            )
            (cast' PersistentHashSet (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1a [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___init)) [(inc ___i)]
                (§ ass ___ret (cast' ITransientSet (ß ___ret.conj(___init[___i]))))
                (when (ß (count ___ret) != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (§ aget ___init ___i))))
                )
            )
            (cast' PersistentHashSet (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1l [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (let [#_"int" ___i 0]
                (doseq [#_"Object" ___key ___init]
                    (§ ass ___ret (cast' ITransientSet (.conj ___ret, ___key)))
                    (when (ß (count ___ret) != ___i + 1)
                        (throw (IllegalArgumentException. (str "Duplicate key: " ___key)))
                    )
                    (§ ass ___i (inc ___i))
                )
                (cast' PersistentHashSet (.persistent ___ret))
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1s [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [___items ___items #_"int" ___i 0] (some? ___items) [(next ___items) (inc ___i)]
                (§ ass ___ret (cast' ITransientSet (.conj ___ret, (first ___items))))
                (when (ß (count ___ret) != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (first ___items))))
                )
            )
            (cast' PersistentHashSet (.persistent ___ret))
        )
    )

    (defn- #_"PersistentHashSet" PersistentHashSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'new [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (merge (APersistentSet'new ___impl) (PersistentHashSet'init))]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method disjoin) [#_"PersistentHashSet" this, #_"Object" ___key]
        (when (.contains this, ___key)
            (§ return (ß PersistentHashSet'new((.meta this), (:impl this).without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method cons) [#_"PersistentHashSet" this, #_"Object" ___o]
        (when (.contains this, ___o)
            (§ return this)
        )
        (ß PersistentHashSet'new((.meta this), (:impl this).assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentHashSet" this]
        (.withMeta PersistentHashSet'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentHashSet" (§ method withMeta) [#_"PersistentHashSet" this, #_"IPersistentMap" ___meta]
        (PersistentHashSet'new ___meta, (:impl this))
    )

    #_method
    (§ defn #_"ITransientCollection" (§ method asTransient) [#_"PersistentHashSet" this]
        (ß TransientHashSet'new((cast' PersistentHashMap (:impl this)).asTransient()))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentHashSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns Primordial (§ extends RestFn)
    (defn #_"Primordial" Primordial'new []
        (RestFn'new)
    )

    #_method
    (§ defn #_"int" (§ method getRequiredArity) [#_"Primordial" this]
        0
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"Primordial" this, #_"Object" ___args]
        (when (§ instance? ArraySeq ___args)
            (let [#_"Object[]" ___argsarray (:array (cast' ArraySeq ___args))]
                (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
                    (loop-when-recur [#_"int" ___i (- (§ alength ___argsarray) 1)] (ß ___i >= (:i (cast' ArraySeq ___args))) [(dec ___i)]
                        (§ ass ___ret (cast' IPersistentList (ß ___ret.cons(___argsarray[___i]))))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(next ___s)]
                (.add ___list, (first ___s))
            )
            (PersistentList'create ___list)
        )
    )

    (defn #_"Object" Primordial'invokeStatic [#_"ISeq" ___args]
        (when (§ instance? ArraySeq ___args)
            (let [#_"Object[]" ___argsarray (:array (cast' ArraySeq ___args))]
                (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
                    (loop-when-recur [#_"int" ___i (- (§ alength ___argsarray) 1)] (>= ___i 0) [(dec ___i)]
                        (§ ass ___ret (cast' IPersistentList (ß ___ret.cons(___argsarray[___i]))))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(next ___s)]
                (.add ___list, (first ___s))
            )
            (PersistentList'create ___list)
        )
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"Primordial" this, #_"IPersistentMap" ___meta]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Primordial" this]
        nil
    )
)

#_stateless
(class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
    (§ def #_"int" EmptyList'HASHEQ (Murmur3'hashOrdered Collections/EMPTY_LIST))

    (defn #_"EmptyList" EmptyList'new [#_"IPersistentMap" ___meta]
        (Obj'new ___meta)
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"EmptyList" this]
        1
    )

    #_method
    (defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'HASHEQ
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"EmptyList" this]
        "()"
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"EmptyList" this, #_"Object" ___o]
        (and (or (§ instance? Sequential ___o) (instance? List ___o)) (nil? (RT'seq ___o)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"EmptyList" this, #_"Object" ___o]
        (.equals this, ___o)
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"PersistentList" (§ method cons) [#_"EmptyList" this, #_"Object" ___o]
        (ß PersistentList'new-4((.meta this), ___o, nil, 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"EmptyList" (§ method withMeta) [#_"EmptyList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (.meta this))
            (§ return (EmptyList'new ___meta))
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentList" (§ method pop) [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"EmptyList" this]
        true
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"EmptyList" this, #_"Object" ___o]
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"EmptyList" this]
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"EmptyList" this]
        RT'EMPTY_ARRAY
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (.isEmpty ___collection)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"EmptyList" this, #_"Object[]" ___objects]
        (when (> (§ alength ___objects) 0)
            (§ ass (§ aget ___objects (ß 0)) nil)
        )
        ___objects
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"EmptyList" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"EmptyList" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (.reify this).subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"EmptyList" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"EmptyList" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this) #_"int" ___i 0] (some? ___s) [(next ___s) (inc ___i)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"EmptyList" this, #_"Object" ___o]
        (ß (.reify this).lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"EmptyList" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"EmptyList" this, #_"int" ___index]
        (ß (.reify this).listIterator(___index))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"EmptyList" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"EmptyList" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ def #_"IFn" PersistentList'creator (Primordial'new))

    (§ def #_"EmptyList" PersistentList'EMPTY (EmptyList'new nil))

    (defn- #_"PersistentList" PersistentList'init []
        (hash-map
            #_"Object" :_first nil
            #_"IPersistentList" :_rest nil
            #_"int" :_count 0
        )
    )

    (defn #_"PersistentList" PersistentList'new-1 [#_"Object" ___first]
        (let [this (merge (ASeq'new) (PersistentList'init))]
            (§ ass (:_first this) ___first)
            (§ ass (:_rest this) nil)

            (§ ass (:_count this) 1)
            this
        )
    )

    (defn #_"PersistentList" PersistentList'new-4 [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"IPersistentList" ____rest, #_"int" ____count]
        (let [this (merge (ASeq'new ___meta) (PersistentList'init))]
            (§ ass (:_first this) ____first)
            (§ ass (:_rest this) ____rest)
            (§ ass (:_count this) ____count)
            this
        )
    )

    (defn #_"IPersistentList" PersistentList'create [#_"List" ___init]
        (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
            (loop-when-recur [#_"ListIterator" ___i (.listIterator ___init, (.size ___init))] (.hasPrevious ___i) [___i]
                (§ ass ___ret (cast' IPersistentList (.cons ___ret, (.previous ___i))))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"PersistentList" this]
        (:_first this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"PersistentList" this]
        (when (ß (:_count this) == 1)
            (§ return nil)
        )
        (cast' ISeq (:_rest this))
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"PersistentList" this]
        (first this)
    )

    #_method
    (§ defn #_"IPersistentList" (§ method pop) [#_"PersistentList" this]
        (when (nil? (:_rest this))
            (§ return (.withMeta PersistentList'EMPTY, (:_meta this)))
        )
        (:_rest this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentList" this]
        (:_count this)
    )

    #_method
    (§ defn #_"PersistentList" (§ method cons) [#_"PersistentList" this, #_"Object" ___o]
        (ß PersistentList'new-4((.meta this), ___o, this, (:_count this) + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentList" this]
        (.withMeta PersistentList'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentList" (§ method withMeta) [#_"PersistentList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (:_meta this))
            (§ return (PersistentList'new-4 ___meta, (:_first this), (:_rest this), (:_count this)))
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentList" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (first this)]
            (loop-when-recur [#_"ISeq" ___s (next this)] (some? ___s) [(next ___s)]
                (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentList" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (first this)))]
            (loop-when-recur [#_"ISeq" ___s (next this)] (some? ___s) [(next ___s)]
                (when (RT'isReduced ___ret)
                    (§ return (.deref (cast' IDeref ___ret)))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
            )
            (when (RT'isReduced ___ret)
                (§ return (.deref (cast' IDeref ___ret)))
            )
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns QSeq (§ extends ASeq)
    (defn- #_"QSeq" QSeq'init []
        (hash-map
            #_"ISeq" :f nil
            #_"ISeq" :rseq nil
        )
    )

    (defn #_"QSeq" QSeq'new-2 [#_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (merge (ASeq'new) (QSeq'init))]
            (§ ass (:f this) ___f)
            (§ ass (:rseq this) ___rseq)
            this
        )
    )

    (defn #_"QSeq" QSeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (merge (ASeq'new ___meta) (QSeq'init))]
            (§ ass (:f this) ___f)
            (§ ass (:rseq this) ___rseq)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"QSeq" this]
        (first (:f this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"QSeq" this]
        (let [#_"ISeq" ___f1 (next (:f this))]
            (let [#_"ISeq" ___r1 (:rseq this)]
                (when (nil? ___f1)
                    (when (nil? (:rseq this))
                        (§ return nil)
                    )
                    (§ ass ___f1 (:rseq this))
                    (§ ass ___r1 nil)
                )
                (QSeq'new-2 ___f1, ___r1)
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"QSeq" this]
        (ß RT'count((:f this)) + RT'count((:rseq this)))
    )

    #_method
    (§ defn #_"QSeq" (§ method withMeta) [#_"QSeq" this, #_"IPersistentMap" ___meta]
        (QSeq'new-3 ___meta, (:f this), (:rseq this))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" PersistentQueue'EMPTY (PersistentQueue'new nil, 0, nil, nil))

    (defn- #_"PersistentQueue" PersistentQueue'init []
        (hash-map
            #_"int" :cnt 0
            #_"ISeq" :f nil
            #_"PersistentVector" :r nil
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"PersistentQueue" PersistentQueue'new [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"ISeq" ___f, #_"PersistentVector" ___r]
        (let [this (merge (Obj'new ___meta) (PersistentQueue'init))]
            (§ ass (:cnt this) ___cnt)
            (§ ass (:f this) ___f)
            (§ ass (:r this) ___r)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (not (§ instance? Sequential ___obj))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (or (nil? ___ms) (not (Util'equiv-2oo (first ___s), (first ___ms))))
                    (§ return false)
                )
            )
            (nil? ___ms)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (not (§ instance? Sequential ___obj))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (or (nil? ___ms) (not (Util'equals (first ___s), (first ___ms))))
                    (§ return false)
                )
            )
            (nil? ___ms)
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"PersistentQueue" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (zero? ___hash)
                (§ ass ___hash 1)
                (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                    (§ ass ___hash (+ (* 31 ___hash) (if (nil? (first ___s)) 0 (.hashCode (first ___s)))))
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"PersistentQueue" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (zero? ___cached)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashOrdered this)))
            )
            ___cached
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"PersistentQueue" this]
        (RT'first (:f this))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method pop) [#_"PersistentQueue" this]
        (when (nil? (:f this)) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" ___f1 (next (:f this))]
            (let [#_"PersistentVector" ___r1 (:r this)]
                (when (nil? ___f1)
                    (§ ass ___f1 (RT'seq (:r this)))
                    (§ ass ___r1 nil)
                )
                (ß PersistentQueue'new((.meta this), (:cnt this) - 1, ___f1, ___r1))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentQueue" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentQueue" this]
        (when (nil? (:f this))
            (§ return nil)
        )
        (ß QSeq'new-2((:f this), RT'seq((:r this))))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method cons) [#_"PersistentQueue" this, #_"Object" ___o]
        (if (nil? (:f this)) ;; empty
            (do
                (PersistentQueue'new (.meta this), (inc (:cnt this)), (RT'list-1 ___o), nil)
            )
            (do
                (PersistentQueue'new (.meta this), (inc (:cnt this)), (:f this), (.cons (or (:r this) PersistentVector'EMPTY), ___o))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentQueue" this]
        (.withMeta PersistentQueue'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method withMeta) [#_"PersistentQueue" this, #_"IPersistentMap" ___meta]
        (PersistentQueue'new ___meta, (:cnt this), (:f this), (:r this))
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"PersistentQueue" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (.contains this, ___o)
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"PersistentQueue" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"PersistentQueue" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"PersistentQueue" this]
        (zero? (count this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"PersistentQueue" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"ISeq" :fseq (:f this)
                    #_"Iterator" :riter (when (some? (:r this)) (.iterator (:r this)))
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (or (and (some? (:fseq this)) (some? (.seq (:fseq this)))) (and (some? (:riter this)) (.hasNext (:riter this))))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (cond (some? (:fseq this))
                    (do
                        (let [#_"Object" ___ret (first (:fseq this))]
                            (§ ass (:fseq this) (next (:fseq this)))
                            ___ret
                        )
                    )
                    (and (some? (:riter this)) (.hasNext (:riter this)))
                    (do
                        (next (:riter this))
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

#_abstract
(class-ns TNode (§ extends AMapEntry)
    (defn- #_"TNode" TNode'init []
        (hash-map
            #_"Object" :key nil
        )
    )

    (defn #_"TNode" TNode'new [#_"Object" ___key]
        (let [this (merge (AMapEntry'new) (TNode'init))]
            (§ ass (:key this) ___key)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method key) [#_"TNode" this]
        (:key this)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method getKey) [#_"TNode" this]
        (.key this)
    )

    #_method
    (§ defn #_"Object" (§ method getValue) [#_"TNode" this]
        (.val this)
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"TNode" this]
        nil
    )

    #_abstract
    (§ defn #_"TNode" (§ method addLeft) [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" (§ method addRight) [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" (§ method removeLeft) [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" (§ method removeRight) [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" (§ method blacken) [#_"TNode" this])
    #_abstract
    (§ defn #_"TNode" (§ method redden) [#_"TNode" this])

    #_method
    (§ defn #_"TNode" (§ method balanceLeft) [#_"TNode" this, #_"TNode" ___parent]
        (ß black((:key ___parent), (.val ___parent), this, (.right ___parent)))
    )

    #_method
    (§ defn #_"TNode" (§ method balanceRight) [#_"TNode" this, #_"TNode" ___parent]
        (ß black((:key ___parent), (.val ___parent), (.left ___parent), this))
    )

    #_abstract
    (§ defn #_"TNode" (§ method replace) [#_"TNode" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right])

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"TNode" this, #_"IFn" ___f, #_"Object" ___init]
        (when (some? (.left this))
            (§ ass ___init (ß (.left this).kvreduce(___f, ___init)))
            (when (RT'isReduced ___init)
                (§ return ___init)
            )
        )
        (§ ass ___init (ß ___f.invoke(___init, (.key this), (.val this))))
        (when (RT'isReduced ___init)
            (§ return ___init)
        )

        (when (some? (.right this))
            (§ ass ___init (ß (.right this).kvreduce(___f, ___init)))
        )
        ___init
    )
)

#_stateless
(class-ns Black (§ extends TNode)
    (defn #_"Black" Black'new [#_"Object" ___key]
        (TNode'new ___key)
    )

    #_method
    (§ defn #_"TNode" (§ method addLeft) [#_"Black" this, #_"TNode" ___ins]
        (.balanceLeft ___ins, this)
    )

    #_method
    (§ defn #_"TNode" (§ method addRight) [#_"Black" this, #_"TNode" ___ins]
        (.balanceRight ___ins, this)
    )

    #_method
    (§ defn #_"TNode" (§ method removeLeft) [#_"Black" this, #_"TNode" ___del]
        (ß balanceLeftDel((:key this), (.val this), ___del, (.right this)))
    )

    #_method
    (§ defn #_"TNode" (§ method removeRight) [#_"Black" this, #_"TNode" ___del]
        (ß balanceRightDel((:key this), (.val this), (.left this), ___del))
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"Black" this]
        this
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"Black" this]
        (Red'new (:key this))
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"Black" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (black ___key, ___val, ___left, ___right)
    )
)

(class-ns BlackVal (§ extends Black)
    (defn- #_"BlackVal" BlackVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackVal" BlackVal'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (Black'new ___key) (BlackVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BlackVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackVal" this]
        (RedVal'new (:key this), (:val this))
    )
)

(class-ns BlackBranch (§ extends Black)
    (defn- #_"BlackBranch" BlackBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"BlackBranch" BlackBranch'new [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (Black'new ___key) (BlackBranch'init))]
            (§ ass (:left this) ___left)
            (§ ass (:right this) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"BlackBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"BlackBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackBranch" this]
        (RedBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns BlackBranchVal (§ extends BlackBranch)
    (defn- #_"BlackBranchVal" BlackBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackBranchVal" BlackBranchVal'new [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (BlackBranch'new ___key, ___left, ___right) (BlackBranchVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BlackBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackBranchVal" this]
        (RedBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

#_stateless
(class-ns Red (§ extends TNode)
    (defn #_"Red" Red'new [#_"Object" ___key]
        (TNode'new ___key)
    )

    #_method
    (§ defn #_"TNode" (§ method addLeft) [#_"Red" this, #_"TNode" ___ins]
        (ß red((:key this), (.val this), ___ins, (.right this)))
    )

    #_method
    (§ defn #_"TNode" (§ method addRight) [#_"Red" this, #_"TNode" ___ins]
        (ß red((:key this), (.val this), (.left this), ___ins))
    )

    #_method
    (§ defn #_"TNode" (§ method removeLeft) [#_"Red" this, #_"TNode" ___del]
        (ß red((:key this), (.val this), ___del, (.right this)))
    )

    #_method
    (§ defn #_"TNode" (§ method removeRight) [#_"Red" this, #_"TNode" ___del]
        (ß red((:key this), (.val this), (.left this), ___del))
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"Red" this]
        (Black'new (:key this))
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"Red" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (red ___key, ___val, ___left, ___right)
    )
)

(class-ns RedVal (§ extends Red)
    (defn- #_"RedVal" RedVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedVal" RedVal'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (Red'new ___key) (RedVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"RedVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedVal" this]
        (BlackVal'new (:key this), (:val this))
    )
)

(class-ns RedBranch (§ extends Red)
    (defn- #_"RedBranch" RedBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"RedBranch" RedBranch'new [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (Red'new ___key) (RedBranch'init))]
            (§ ass (:left this) ___left)
            (§ ass (:right this) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"RedBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"RedBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" (§ method balanceLeft) [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (§ instance? Red (:left this))
            (do
                (ß red((:key this), (.val this), (:left this).blacken(), black((:key ___parent), (.val ___parent), (:right this), (.right ___parent))))
            )
            (§ instance? Red (:right this))
            (do
                (ß red((:key (:right this)), (:right this).val(), black((:key this), (.val this), (:left this), (:right this).left()), black((:key ___parent), (.val ___parent), (:right this).right(), (.right ___parent))))
            )
            :else
            (do
                (.balanceLeft super, ___parent)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method balanceRight) [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (§ instance? Red (:right this))
            (do
                (ß red((:key this), (.val this), black((:key ___parent), (.val ___parent), (.left ___parent), (:left this)), (:right this).blacken()))
            )
            (§ instance? Red (:left this))
            (do
                (ß red((:key (:left this)), (:left this).val(), black((:key ___parent), (.val ___parent), (.left ___parent), (:left this).left()), black((:key this), (.val this), (:left this).right(), (:right this))))
            )
            :else
            (do
                (.balanceRight super, ___parent)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedBranch" this]
        (BlackBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns RedBranchVal (§ extends RedBranch)
    (defn- #_"RedBranchVal" RedBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedBranchVal" RedBranchVal'new [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (RedBranch'new ___key, ___left, ___right) (RedBranchVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"RedBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedBranchVal" this]
        (BlackBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns TSeq (§ extends ASeq)
    (defn- #_"TSeq" TSeq'init []
        (hash-map
            #_"ISeq" :stack nil
            #_"boolean" :asc false
            #_"int" :cnt 0
        )
    )

    (defn #_"TSeq" TSeq'new-2 [#_"ISeq" ___stack, #_"boolean" ___asc]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) -1)
            this
        )
    )

    (defn #_"TSeq" TSeq'new-3 [#_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) ___cnt)
            this
        )
    )

    (defn #_"TSeq" TSeq'new-4 [#_"IPersistentMap" ___meta, #_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (merge (ASeq'new ___meta) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) ___cnt)
            this
        )
    )

    (defn #_"TSeq" TSeq'create [#_"TNode" ___t, #_"boolean" ___asc, #_"int" ___cnt]
        (ß TSeq'new-3(TSeq'push(___t, nil, ___asc), ___asc, ___cnt))
    )

    (defn #_"ISeq" TSeq'push [#_"TNode" ___t, #_"ISeq" ___stack, #_"boolean" ___asc]
        (while (some? ___t)
            (§ ass ___stack (RT'cons ___t, ___stack))
            (§ ass ___t (if ___asc (.left ___t) (.right ___t)))
        )
        ___stack
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"TSeq" this]
        (first (:stack this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"TSeq" this]
        (let [#_"TNode" ___t (cast' TNode (.first (:stack this)))]
            (let [#_"ISeq" ___nextstack (TSeq'push (if (:asc this) (.right ___t) (.left ___t)), (.next (:stack this)), (:asc this))]
                (when (some? ___nextstack)
                    (§ return (ß TSeq'new-3(___nextstack, (:asc this), (:cnt this) - 1)))
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"TSeq" this]
        (when (< (:cnt this) 0)
            (§ return (count super))
        )
        (:cnt this)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"TSeq" this, #_"IPersistentMap" ___meta]
        (TSeq'new-4 ___meta, (:stack this), (:asc this), (:cnt this))
    )
)

(class-ns NodeIterator (§ implements Iterator)
    (defn- #_"NodeIterator" NodeIterator'init []
        (hash-map
            #_"Stack" :stack (Stack.)
            #_"boolean" :asc false
        )
    )

    (defn #_"NodeIterator" NodeIterator'new [#_"TNode" ___t, #_"boolean" ___asc]
        (let [this (NodeIterator'init)]
            (§ ass (:asc this) ___asc)
            (.push this, ___t)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method push) [#_"NodeIterator" this, #_"TNode" ___t]
        (while (some? ___t)
            (.push (:stack this), ___t)
            (§ ass ___t (if (:asc this) (.left ___t) (.right ___t)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"NodeIterator" this]
        (not (.isEmpty (:stack this)))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"NodeIterator" this]
        (try
            (let [#_"TNode" ___t (cast' TNode (.pop (:stack this)))]
                (.push this, (if (:asc this) (.right ___t) (.left ___t)))
                ___t
            )
            (catch EmptyStackException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"NodeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns KeyIterator (§ implements Iterator)
    (defn- #_"KeyIterator" KeyIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"KeyIterator" KeyIterator'new [#_"NodeIterator" ___it]
        (let [this (KeyIterator'init)]
            (§ ass (:it this) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"KeyIterator" this]
        (.hasNext (:it this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"KeyIterator" this]
        (:key (cast' TNode (next (:it this))))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"KeyIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ValIterator (§ implements Iterator)
    (defn- #_"ValIterator" ValIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"ValIterator" ValIterator'new [#_"NodeIterator" ___it]
        (let [this (ValIterator'init)]
            (§ ass (:it this) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ValIterator" this]
        (.hasNext (:it this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"ValIterator" this]
        (.val (cast' TNode (.next (:it this))))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ValIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap'new-0))

    (defn #_"IPersistentMap" PersistentTreeMap'create-1m [#_"Map" ___other]
        (let [#_"IPersistentMap" ___ret PersistentTreeMap'EMPTY]
            (doseq [#_"Object" ___o (.entrySet ___other)]
                (let [#_"Map$Entry" ___e (cast' Entry ___o)]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            ___ret
        )
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'init []
        (hash-map
            #_"Comparator" :comp nil
            #_"TNode" :tree nil
            #_"int" :_count 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-0 []
        (PersistentTreeMap'new-1 RT'DEFAULT_COMPARATOR)
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'new-1 [#_"Comparator" ___comp]
        (PersistentTreeMap'new-2 nil, ___comp)
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-2 [#_"IPersistentMap" ___meta, #_"Comparator" ___comp]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:comp this) ___comp)
            (§ ass (:_meta this) ___meta)
            (§ ass (:tree this) nil)
            (§ ass (:_count this) 0)
            this
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4m [#_"IPersistentMap" ___meta, #_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ____count]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:comp this) ___comp)
            (§ ass (:tree this) ___tree)
            (§ ass (:_count this) ____count)
            this
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method withMeta) [#_"PersistentTreeMap" this, #_"IPersistentMap" ___meta]
        (PersistentTreeMap'new-4m ___meta, (:comp this), (:tree this), (:_count this))
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-1s [#_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret PersistentTreeMap'EMPTY]
            (loop-when-recur [___items ___items] (some? ___items) [(next (next ___items))]
                (when (nil? (next ___items))
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
            )
            (cast' PersistentTreeMap ___ret)
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-2 [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret (PersistentTreeMap'new-1 ___comp)]
            (loop-when-recur [___items ___items] (some? ___items) [(next (next ___items))]
                (when (nil? (next ___items))
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
            )
            (cast' PersistentTreeMap ___ret)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (some? (.entryAt this, ___key))
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (.equals super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (.equiv super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method assocEx) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (.add this, (:tree this), ___key, ___val, ___found)]
                (when (nil? ___t) ;; nil == already contains key
                    (throw (Util'runtimeException-1 "Key already present"))
                )
                (ß PersistentTreeMap'new-4c((:comp this), (.blacken ___t), (:_count this) + 1, (.meta this)))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method assoc) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (.add this, (:tree this), ___key, ___val, ___found)]
                (when (nil? ___t) ;; nil == already contains key
                    (let [#_"TNode" ___foundNode (cast' TNode (:val ___found))]
                        (when (ß (.val ___foundNode) == ___val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß PersistentTreeMap'new-4c((:comp this), this.replace((:tree this), ___key, ___val), (:_count this), (.meta this))))
                    )
                )
                (ß PersistentTreeMap'new-4c((:comp this), (.blacken ___t), (:_count this) + 1, (.meta this)))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method without) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (.remove this, (:tree this), ___key, ___found)]
                (when (nil? ___t)
                    (when (ß (nil? (:val ___found))) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß PersistentTreeMap'new-2((.meta this), (:comp this))))
                )
                (ß PersistentTreeMap'new-4c((:comp this), (.blacken ___t), (:_count this) - 1, (.meta this)))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeMap" this]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), true, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentTreeMap" this]
        (ß PersistentTreeMap'new-2((.meta this), (:comp this)))
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"PersistentTreeMap" this]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), false, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"Comparator" (§ method comparator) [#_"PersistentTreeMap" this]
        (:comp this)
    )

    #_method
    (§ defn #_"Object" (§ method entryKey) [#_"PersistentTreeMap" this, #_"Object" ___entry]
        (.key (cast' IMapEntry ___entry))
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeMap" this, #_"boolean" ___ascending]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), ___ascending, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method seqFrom) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"boolean" ___ascending]
        (when (> (:_count this) 0)
            (let [#_"ISeq" ___stack nil]
                (let [#_"TNode" ___t (:tree this)]
                    (while (some? ___t)
                        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
                            (cond (zero? ___c)
                                (do
                                    (§ ass ___stack (RT'cons ___t, ___stack))
                                    (§ return (TSeq'new-2 ___stack, ___ascending))
                                )
                                ___ascending
                                (do
                                    (if (< ___c 0)
                                        (do
                                            (§ ass ___stack (RT'cons ___t, ___stack))
                                            (§ ass ___t (.left ___t))
                                        )
                                        (do
                                            (§ ass ___t (.right ___t))
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (> ___c 0)
                                        (do
                                            (§ ass ___stack (RT'cons ___t, ___stack))
                                            (§ ass ___t (.right ___t))
                                        )
                                        (do
                                            (§ ass ___t (.left ___t))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (some? ___stack)
                        (§ return (TSeq'new-2 ___stack, ___ascending))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"NodeIterator" (§ method iterator) [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), true)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentTreeMap" this, #_"IFn" ___f, #_"Object" ___init]
        (when (some? (:tree this))
            (§ ass ___init (.kvreduce (:tree this), ___f, ___init))
        )
        (when (RT'isReduced ___init)
            (§ ass ___init (.deref (cast' IDeref ___init)))
        )
        ___init
    )

    #_method
    (§ defn #_"NodeIterator" (§ method reverseIterator) [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), false)
    )

    #_method
    (§ defn #_"Iterator" (§ method keys) [#_"PersistentTreeMap" this]
        (.keys this, (.iterator this))
    )

    #_method
    (§ defn #_"Iterator" (§ method vals) [#_"PersistentTreeMap" this]
        (.vals this, (.iterator this))
    )

    #_method
    (§ defn #_"Iterator" (§ method keys) [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (KeyIterator'new ___it)
    )

    #_method
    (§ defn #_"Iterator" (§ method vals) [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (ValIterator'new ___it)
    )

    #_method
    (§ defn #_"Object" (§ method minKey) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (.min this)]
            (when (some? ___t) (:key ___t))
        )
    )

    #_method
    (§ defn #_"TNode" (§ method min) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (:tree this)]
            (when (some? ___t)
                (while (some? (.left ___t))
                    (§ ass ___t (.left ___t))
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"Object" (§ method maxKey) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (.max this)]
            (when (some? ___t) (:key ___t))
        )
    )

    #_method
    (§ defn #_"TNode" (§ method max) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (:tree this)]
            (when (some? ___t)
                (while (some? (.right ___t))
                    (§ ass ___t (.right ___t))
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"int" (§ method depth) [#_"PersistentTreeMap" this]
        (.depth this, (:tree this))
    )

    #_method
    (§ defn #_"int" (§ method depth) [#_"PersistentTreeMap" this, #_"TNode" ___t]
        (when (nil? ___t)
            (§ return 0)
        )
        (ß 1 + Math/max(this.depth((.left ___t)), this.depth((.right ___t))))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"TNode" ___n (.entryAt this, ___key)]
            (if (some? ___n) (.val ___n) ___notFound)
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"int" (§ method capacity) [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"TNode" (§ method entryAt) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"TNode" ___t (:tree this)]
            (while (some? ___t)
                (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
                    (cond (zero? ___c)
                        (do
                            (§ return ___t)
                        )
                        (< ___c 0)
                        (do
                            (§ ass ___t (.left ___t))
                        )
                        :else
                        (do
                            (§ ass ___t (.right ___t))
                        )
                    )
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"int" (§ method doCompare) [#_"PersistentTreeMap" this, #_"Object" ___k1, #_"Object" ___k2]
        (.compare (:comp this), ___k1, ___k2)
    )

    #_method
    (§ defn #_"TNode" (§ method add) [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val, #_"Box" ___found]
        (when (nil? ___t)
            (when (nil? ___val)
                (§ return (Red'new ___key))
            )
            (§ return (RedVal'new ___key, ___val))
        )
        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
            (when (zero? ___c)
                (§ ass (:val ___found) ___t)
                (§ return nil)
            )
            (let [#_"TNode" ___ins (if (neg? ___c) (.add this, (.left ___t), ___key, ___val, ___found) (.add this, (.right ___t), ___key, ___val, ___found))]
                (when (nil? ___ins) ;; found below
                    (§ return nil)
                )
                (when (< ___c 0)
                    (§ return (.addLeft ___t, ___ins))
                )
                (.addRight ___t, ___ins)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method remove) [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Box" ___found]
        (when (nil? ___t)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
            (when (zero? ___c)
                (§ ass (:val ___found) ___t)
                (§ return (ß append((.left ___t), (.right ___t))))
            )
            (let [#_"TNode" ___del (if (neg? ___c) (.remove this, (.left ___t), ___key, ___found) (.remove this, (.right ___t), ___key, ___found))]
                (when (and (nil? ___del) (nil? (:val ___found))) ;; not found below
                    (§ return nil)
                )
                (when (< ___c 0)
                    (if (§ instance? Black (.left ___t))
                        (do
                            (§ return (ß balanceLeftDel((:key ___t), (.val ___t), ___del, (.right ___t))))
                        )
                        (do
                            (§ return (ß red((:key ___t), (.val ___t), ___del, (.right ___t))))
                        )
                    )
                )
                (when (§ instance? Black (.right ___t))
                    (§ return (ß balanceRightDel((:key ___t), (.val ___t), (.left ___t), ___del)))
                )
                (ß red((:key ___t), (.val ___t), (.left ___t), ___del))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'append [#_"TNode" ___left, #_"TNode" ___right]
        (cond (nil? ___left)
            (do
                ___right
            )
            (nil? ___right)
            (do
                ___left
            )
            (§ instance? Red ___left)
            (do
                (if (§ instance? Red ___right)
                    (do
                        (let [#_"TNode" ___app (ß append((.right ___left), (.left ___right)))]
                            (if (§ instance? Red ___app)
                                (do
                                    (ß red((:key ___app), (.val ___app), red((:key ___left), (.val ___left), (.left ___left), (.left ___app)), red((:key ___right), (.val ___right), (.right ___app), (.right ___right))))
                                )
                                (do
                                    (ß red((:key ___left), (.val ___left), (.left ___left), red((:key ___right), (.val ___right), ___app, (.right ___right))))
                                )
                            )
                        )
                    )
                    (do
                        (ß red((:key ___left), (.val ___left), (.left ___left), append((.right ___left), ___right)))
                    )
                )
            )
            (§ instance? Red ___right)
            (do
                (ß red((:key ___right), (.val ___right), append(___left, (.left ___right)), (.right ___right)))
            )
            :else ;; black/black
            (do
                (let [#_"TNode" ___app (ß append((.right ___left), (.left ___right)))]
                    (if (§ instance? Red ___app)
                        (do
                            (ß red((:key ___app), (.val ___app), PersistentTreeMap'black((:key ___left), (.val ___left), (.left ___left), (.left ___app)), PersistentTreeMap'black((:key ___right), (.val ___right), (.right ___app), (.right ___right))))
                        )
                        (do
                            (ß balanceLeftDel((:key ___left), (.val ___left), (.left ___left), PersistentTreeMap'black((:key ___right), (.val ___right), ___app, (.right ___right))))
                        )
                    )
                )
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___del, #_"TNode" ___right]
        (cond (§ instance? Red ___del)
            (do
                (ß red(___key, ___val, (.blacken ___del), ___right))
            )
            (§ instance? Black ___right)
            (do
                (ß rightBalance(___key, ___val, ___del, (.redden ___right)))
            )
            (and (§ instance? Red ___right) (§ instance? Black (.left ___right)))
            (do
                (ß red((:key (.left ___right)), (.left ___right).val(), PersistentTreeMap'black(___key, ___val, ___del, (.left ___right).left()), rightBalance((:key ___right), (.val ___right), (.left ___right).right(), (.right ___right).redden())))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___del]
        (cond (§ instance? Red ___del)
            (do
                (ß red(___key, ___val, ___left, (.blacken ___del)))
            )
            (§ instance? Black ___left)
            (do
                (ß leftBalance(___key, ___val, (.redden ___left), ___del))
            )
            (and (§ instance? Red ___left) (§ instance? Black (.right ___left)))
            (do
                (ß red((:key (.right ___left)), (.right ___left).val(), leftBalance((:key ___left), (.val ___left), (.left ___left).redden(), (.right ___left).left()), PersistentTreeMap'black(___key, ___val, (.right ___left).right(), ___del)))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___ins, #_"TNode" ___right]
        (cond (and (§ instance? Red ___ins) (§ instance? Red (.left ___ins)))
            (do
                (ß red((:key ___ins), (.val ___ins), (.left ___ins).blacken(), PersistentTreeMap'black(___key, ___val, (.right ___ins), ___right)))
            )
            (and (§ instance? Red ___ins) (§ instance? Red (.right ___ins)))
            (do
                (ß red((:key (.right ___ins)), (.right ___ins).val(), PersistentTreeMap'black((:key ___ins), (.val ___ins), (.left ___ins), (.right ___ins).left()), PersistentTreeMap'black(___key, ___val, (.right ___ins).right(), ___right)))
            )
            :else
            (do
                (PersistentTreeMap'black ___key, ___val, ___ins, ___right)
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___ins]
        (cond (and (§ instance? Red ___ins) (§ instance? Red (.right ___ins)))
            (do
                (ß red((:key ___ins), (.val ___ins), PersistentTreeMap'black(___key, ___val, ___left, (.left ___ins)), (.right ___ins).blacken()))
            )
            (and (§ instance? Red ___ins) (§ instance? Red (.left ___ins)))
            (do
                (ß red((:key (.left ___ins)), (.left ___ins).val(), PersistentTreeMap'black(___key, ___val, ___left, (.left ___ins).left()), PersistentTreeMap'black((:key ___ins), (.val ___ins), (.left ___ins).right(), (.right ___ins))))
            )
            :else
            (do
                (PersistentTreeMap'black ___key, ___val, ___left, ___ins)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
            (.replace ___t, (:key ___t), (if (zero? ___c) ___val (.val ___t)), (if (neg? ___c) (.replace this, (.left ___t), ___key, ___val) (.left ___t)), (if (pos? ___c) (.replace this, (.right ___t), ___key, ___val) (.right ___t)))
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4c [#_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ___count, #_"IPersistentMap" ___meta]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:comp this) ___comp)
            (§ ass (:tree this) ___tree)
            (§ ass (:_count this) ___count)
            this
        )
    )

    (defn #_"Red" PersistentTreeMap'red [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (and (nil? ___left) (nil? ___right))
            (when (nil? ___val)
                (§ return (Red'new ___key))
            )
            (§ return (RedVal'new ___key, ___val))
        )
        (when (nil? ___val)
            (§ return (RedBranch'new ___key, ___left, ___right))
        )
        (RedBranchVal'new ___key, ___val, ___left, ___right)
    )

    (defn #_"Black" PersistentTreeMap'black [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (and (nil? ___left) (nil? ___right))
            (when (nil? ___val)
                (§ return (Black'new ___key))
            )
            (§ return (BlackVal'new ___key, ___val))
        )
        (when (nil? ___val)
            (§ return (BlackBranch'new ___key, ___left, ___right))
        )
        (BlackBranchVal'new ___key, ___val, ___left, ___right)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentTreeMap" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (PersistentTreeSet'new nil, PersistentTreeMap'EMPTY))

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-1 [#_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret PersistentTreeSet'EMPTY]
            (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                (§ ass ___ret (cast' PersistentTreeSet (.cons ___ret, (first ___items))))
            )
            ___ret
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-2 [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret (ß PersistentTreeSet'new(nil, PersistentTreeMap'new-2(nil, ___comp)))]
            (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                (§ ass ___ret (cast' PersistentTreeSet (.cons ___ret, (first ___items))))
            )
            ___ret
        )
    )

    (defn- #_"PersistentTreeSet" PersistentTreeSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'new [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (merge (APersistentSet'new ___impl) (PersistentTreeSet'init))]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (.equals super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (.equiv super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method disjoin) [#_"PersistentTreeSet" this, #_"Object" ___key]
        (when (.contains this, ___key)
            (§ return (ß PersistentTreeSet'new((.meta this), (:impl this).without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method cons) [#_"PersistentTreeSet" this, #_"Object" ___o]
        (when (.contains this, ___o)
            (§ return this)
        )
        (ß PersistentTreeSet'new((.meta this), (:impl this).assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentTreeSet" this]
        (ß PersistentTreeSet'new((.meta this), (cast' PersistentTreeMap (.empty (:impl this)))))
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"PersistentTreeSet" this]
        (ß KeySeq'create((cast' Reversible (:impl this)).rseq()))
    )

    #_method
    (§ defn #_"PersistentTreeSet" (§ method withMeta) [#_"PersistentTreeSet" this, #_"IPersistentMap" ___meta]
        (PersistentTreeSet'new ___meta, (:impl this))
    )

    #_method
    (§ defn #_"Comparator" (§ method comparator) [#_"PersistentTreeSet" this]
        (.comparator (cast' Sorted (:impl this)))
    )

    #_method
    (§ defn #_"Object" (§ method entryKey) [#_"PersistentTreeSet" this, #_"Object" ___entry]
        ___entry
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeSet" this, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (cast' PersistentTreeMap (:impl this))]
            (ß RT'keys(___m.seq(___ascending)))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seqFrom) [#_"PersistentTreeSet" this, #_"Object" ___key, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (cast' PersistentTreeMap (:impl this))]
            (ß RT'keys(___m.seqFrom(___key, ___ascending)))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentTreeSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns VNode
    (defn- #_"VNode" VNode'init []
        (hash-map
            #_transient
            #_"AtomicReference<Thread>" :edit nil
            #_"Object[]" :array nil
        )
    )

    (defn #_"VNode" VNode'new-2 [#_"AtomicReference<Thread>" ___edit, #_"Object[]" ___array]
        (let [this (VNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:array this) ___array)
            this
        )
    )

    (defn #_"VNode" VNode'new-1 [#_"AtomicReference<Thread>" ___edit]
        (let [this (VNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:array this) (make-array Object 32))
            this
        )
    )
)

(class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
    (defn- #_"ChunkedSeq" ChunkedSeq'init []
        (hash-map
            #_"PersistentVector" :vec nil
            #_"Object[]" :node nil
            #_"int" :i 0
            #_"int" :offset 0
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-3 [#_"PersistentVector" ___vec, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            (§ ass (:node this) (.arrayFor ___vec, ___i))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-5 [#_"IPersistentMap" ___meta, #_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new ___meta) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:node this) ___node)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-4 [#_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:node this) ___node)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            this
        )
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"ChunkedSeq" this]
        (ArrayChunk'new-2 (:node this), (:offset this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"ChunkedSeq" this]
        (when (ß (:i this) + (§ alength (:node this)) < (:cnt (:vec this)))
            (§ return (ß ChunkedSeq'new-3((:vec this), (:i this) + (§ alength (:node this)), 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"ChunkedSeq" this]
        (let [#_"ISeq" ___s (.chunkedNext this)]
            (when (nil? ___s)
                (§ return PersistentList'EMPTY)
            )
            ___s
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"ChunkedSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (ChunkedSeq'new-5 ___meta, (:vec this), (:node this), (:i this), (:offset this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ChunkedSeq" this]
        (§ aget (:node this) (:offset this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ChunkedSeq" this]
        (when (ß (:offset this) + 1 < (§ alength (:node this)))
            (§ return (ß ChunkedSeq'new-4((:vec this), (:node this), (:i this), (:offset this) + 1)))
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ChunkedSeq" this]
        (ß (:cnt (:vec this)) - ((:i this) + (:offset this)))
    )
)

(class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
    (defn- #_"TransientVector" TransientVector'init []
        (hash-map
            #_volatile
            #_"int" :cnt 0
            #_volatile
            #_"int" :shift 0
            #_volatile
            #_"VNode" :root nil
            #_volatile
            #_"Object[]" :tail nil
        )
    )

    (defn #_"TransientVector" TransientVector'new-4 [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (AFn'new) (TransientVector'init))]
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    (defn #_"TransientVector" TransientVector'new-1 [#_"PersistentVector" ___v]
        (TransientVector'new-4 (:cnt ___v), (:shift ___v), (.editableRoot (:root ___v)), (.editableTail (:tail ___v)))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"TransientVector" this]
        (.ensureEditable this)
        (:cnt this)
    )

    #_method
    (§ defn #_"VNode" (§ method ensureEditable) [#_"TransientVector" this, #_"VNode" ___node]
        (when (ß (:edit ___node) == (:edit (:root this)))
            (§ return ___node)
        )
        (ß VNode'new-2((:edit (:root this)), (:array ___node).clone()))
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientVector" this]
        (when (nil? (.get (:edit (:root this))))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (defn #_"VNode" TransientVector'editableRoot [#_"VNode" ___node]
        (VNode'new-2 (AtomicReference. (Thread/currentThread)), (.clone (:array ___node)))
    )

    #_method
    (§ defn #_"PersistentVector" (§ method persistent) [#_"TransientVector" this]
        (.ensureEditable this)
        (.set (:edit (:root this)), nil)
        (let [#_"Object[]" ___trimmedTail (make-array Object (ß (:cnt this) - (.tailoff this)))]
            (ß System/arraycopy((:tail this), 0, ___trimmedTail, 0, (§ alength ___trimmedTail)))
            (PersistentVector'new-4 (:cnt this), (:shift this), (:root this), ___trimmedTail)
        )
    )

    (defn #_"Object[]" TransientVector'editableTail [#_"Object[]" ___tl]
        (let [#_"Object[]" ___ret (make-array Object 32)]
            (ß System/arraycopy(___tl, 0, ___ret, 0, (§ alength ___tl)))
            ___ret
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method conj) [#_"TransientVector" this, #_"Object" ___val]
        (.ensureEditable this)
        (let [#_"int" ___i (:cnt this)]
            ;; room in tail?
            (when (ß ___i - (.tailoff this) < 32)
                (§ ass (§ aget (:tail this) (ß ___i & 0x01f)) ___val)
                (§ ass (:cnt this) (+ (:cnt this) 1))
                (§ return this)
            )
            ;; full tail, push into tree
            (§ let [#_"VNode" ___newroot]
                (let [#_"VNode" ___tailnode (ß VNode'new-2((:edit (:root this)), (:tail this)))]
                    (§ ass (:tail this) (make-array Object 32))
                    (§ ass (§ aget (:tail this) (ß 0)) ___val)
                    (let [#_"int" ___newshift (:shift this)]
                        ;; overflow root?
                        (if (ß ((:cnt this) >>> 5) > (1 << (:shift this)))
                            (do
                                (§ ass ___newroot (VNode'new-1 (:edit (:root this))))
                                (§ ass (§ aget (:array ___newroot) (ß 0)) (:root this))
                                (§ ass (§ aget (:array ___newroot) (ß 1)) (ß newPath((:edit (:root this)), (:shift this), ___tailnode)))
                                (§ ass ___newshift (+ ___newshift 5))
                            )
                            (do
                                (§ ass ___newroot (.pushTail this, (:shift this), (:root this), ___tailnode))
                            )
                        )
                        (§ ass (:root this) ___newroot)
                        (§ ass (:shift this) ___newshift)
                        (§ ass (:cnt this) (+ (:cnt this) 1))
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method pushTail) [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (§ ass ___parent (.ensureEditable this, ___parent))
        (let [#_"int" ___subidx (ß (((:cnt this) - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret ___parent]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (= ___level 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (cast' VNode (§ aget (:array ___parent) ___subidx))]
                                (§ ass ___nodeToInsert (if (some? ___child) (.pushTail this, (- ___level 5), ___child, ___tailnode) (newPath (:edit (:root this)), (- ___level 5), ___tailnode)))
                            )
                        )
                    )
                    (§ ass (§ aget (:array ___ret) ___subidx) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn- #_"int" (§ method tailoff) [#_"TransientVector" this]
        (when (< (:cnt this) 32)
            (§ return 0)
        )
        (ß (((:cnt this) - 1) >>> 5) << 5)
    )

    #_method
    (§ defn- #_"Object[]" (§ method arrayFor) [#_"TransientVector" this, #_"int" ___i]
        (when (and (<= 0 ___i) (< ___i (:cnt this)))
            (when (ß ___i >= (.tailoff this))
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (cast' VNode (§ aget (:array ___node) (ß (___i >>> ___level) & 0x01f))))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn- #_"Object[]" (§ method editableArrayFor) [#_"TransientVector" this, #_"int" ___i]
        (when (and (<= 0 ___i) (< ___i (:cnt this)))
            (when (ß ___i >= (.tailoff this))
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß this.ensureEditable((cast' VNode (§ aget (:array ___node) (ß (___i >>> ___level) & 0x01f))))))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TransientVector" this, #_"Object" ___key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (.ensureEditable this)
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (.intValue (cast Number ___key))]
                (when (and (<= 0 ___i) (< ___i (:cnt this)))
                    (§ return (.nth this, ___i))
                )
            )
        )
        ___notFound
    )

    (def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"TransientVector" this, #_"Object" ___key]
        (ß (this.valAt(___key, TransientVector'NOT_FOUND) != TransientVector'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"TransientVector" this, #_"Object" ___key]
        (let [#_"Object" ___v (.valAt this, ___key, TransientVector'NOT_FOUND)]
            (when (not= ___v TransientVector'NOT_FOUND)
                (§ return (MapEntry'create ___key, ___v))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"TransientVector" this, #_"Object" ___arg1]
        ;; note - relies on ensureEditable in nth
        (when (Util'isInteger ___arg1)
            (§ return (ß this.nth((cast Number ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"TransientVector" this, #_"int" ___i]
        (.ensureEditable this)
        (let [#_"Object[]" ___node (.arrayFor this, ___i)]
            (§ aget ___node (ß ___i & 0x01f))
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"TransientVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (and (<= 0 ___i) (< ___i (count this)))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"TransientVector" (§ method assocN) [#_"TransientVector" this, #_"int" ___i, #_"Object" ___val]
        (.ensureEditable this)
        (when (and (<= 0 ___i) (< ___i (:cnt this)))
            (when (ß ___i >= (.tailoff this))
                (§ ass (§ aget (:tail this) (ß ___i & 0x01f)) ___val)
                (§ return this)
            )

            (§ ass (:root this) (.doAssoc this, (:shift this), (:root this), ___i, ___val))
            (§ return this)
        )
        (when (ß ___i == (:cnt this))
            (§ return (.conj this, ___val))
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"TransientVector" (§ method assoc) [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___val]
        ;; note - relies on ensureEditable in assocN
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (.intValue (cast Number ___key))]
                (§ return (.assocN this, ___i, ___val))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn- #_"VNode" (§ method doAssoc) [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (§ ass ___node (.ensureEditable this, ___node))
        (let [#_"VNode" ___ret ___node]
            (if (zero? ___level)
                (do
                    (§ ass (§ aget (:array ___ret) (ß ___i & 0x01f)) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (§ aget (:array ___ret) ___subidx) (ß this.doAssoc((- ___level 5), (cast' VNode (§ aget (:array ___node) ___subidx)), ___i, ___val)))
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method pop) [#_"TransientVector" this]
        (.ensureEditable this)
        (when (zero? (:cnt this))
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß (:cnt this) == 1)
            (§ ass (:cnt this) 0)
            (§ return this)
        )
        (let [#_"int" ___i (- (:cnt this) 1)]
            ;; pop in tail?
            (when (pos? (___i & 0x01f))
                (§ ass (:cnt this) (- (:cnt this) 1))
                (§ return this)
            )

            (let [#_"Object[]" ___newtail (ß this.editableArrayFor((:cnt this) - 2))]
                (let [#_"VNode" ___newroot (.popTail this, (:shift this), (:root this))]
                    (let [#_"int" ___newshift (:shift this)]
                        (when (nil? ___newroot)
                            (§ ass ___newroot (VNode'new-1 (:edit (:root this))))
                        )
                        (when (and (< 5 (:shift this)) (nil? (§ aget (:array ___newroot) (ß 1))))
                            (§ ass ___newroot (ß this.ensureEditable((cast' VNode (§ aget (:array ___newroot) (ß 0))))))
                            (§ ass ___newshift (- ___newshift 5))
                        )
                        (§ ass (:root this) ___newroot)
                        (§ ass (:shift this) ___newshift)
                        (§ ass (:cnt this) (- (:cnt this) 1))
                        (§ ass (:tail this) ___newtail)
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method popTail) [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node]
        (§ ass ___node (.ensureEditable this, ___node))
        (let [#_"int" ___subidx (ß (((:cnt this) - 2) >>> ___level) & 0x01f)]
            (cond (> ___level 5)
                (do
                    (let [#_"VNode" ___newchild (ß this.popTail((- ___level 5), (cast' VNode (§ aget (:array ___node) ___subidx))))]
                        (if (and (nil? ___newchild) (zero? ___subidx))
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret ___node]
                                    (§ ass (§ aget (:array ___ret) ___subidx) ___newchild)
                                    ___ret
                                )
                            )
                        )
                    )
                )
                (zero? ___subidx)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret ___node]
                        (§ ass (§ aget (:array ___ret) ___subidx) nil)
                        ___ret
                    )
                )
            )
        )
    )
)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (AtomicReference. nil))
    (def #_"VNode" PersistentVector'EMPTY_NODE (ß VNode'new-2(PersistentVector'NOEDIT, new Object[32])))

    (def #_"PersistentVector" PersistentVector'EMPTY (ß PersistentVector'new-4(0, 5, PersistentVector'EMPTY_NODE, (object-array 0))))

    (def- #_"IFn" PersistentVector'TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___coll, #_"Object" ___val]
                (.conj (cast' ITransientVector ___coll), ___val)
            )
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___coll]
                ___coll
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" ___items]
        (ß PersistentVector'new-4((§ alength ___items), 5, PersistentVector'EMPTY_NODE, ___items))
    )

    (defn #_"PersistentVector" PersistentVector'create-1r [#_"IReduceInit" ___items]
        (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
            (.reduce ___items, PersistentVector'TRANSIENT_VECTOR_CONJ, ___ret)
            (.persistent ___ret)
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1s [#_"ISeq" ___items]
        (let [#_"Object[]" ___arr (make-array Object 32)]
            (let [#_"int" ___i 0]
                (loop-when-recur [___items ___items] (and (some? ___items) (< ___i 32)) [(next ___items)]
                    (§ ass (§ aget ___arr ___i) (first ___items))
                    (§ ass ___i (inc ___i))
                )

                (cond (some? ___items) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" ___start (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, ___arr)]
                            (let [#_"TransientVector" ___ret (.asTransient ___start)]
                                (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                                    (§ ass ___ret (.conj ___ret, (first ___items)))
                                )
                                (.persistent ___ret)
                            )
                        )
                    )
                    (= ___i 32) ;; exactly 32, skip copy
                    (do
                        (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, ___arr)
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" ___arr2 (make-array Object ___i)]
                            (System/arraycopy ___arr, 0, ___arr2, 0, ___i)
                            (PersistentVector'new-4 ___i, 5, PersistentVector'EMPTY_NODE, ___arr2)
                        )
                    )
                )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1l [#_"List" ___list]
        (let [#_"int" ___size (.size ___list)]
            (when (<= ___size 32)
                (§ return (ß PersistentVector'new-4(___size, 5, PersistentVector'EMPTY_NODE, (.toArray ___list))))
            )

            (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
                (loop-when-recur [#_"int" ___i 0] (< ___i ___size) [(inc ___i)]
                    (§ ass ___ret (ß ___ret.conj(___list.get(___i))))
                )
                (.persistent ___ret)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1i [#_"Iterable" ___items]
        ;; optimize common case
        (when (instance? ArrayList ___items)
            (§ return (.create this, (cast ArrayList ___items)))
        )

        (let [#_"Iterator" ___iter (.iterator ___items)]
            (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
                (while (.hasNext ___iter)
                    (§ ass ___ret (.conj ___ret, (next ___iter)))
                )
                (.persistent ___ret)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1a [#_"Object..." ___items]
        (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
            (doseq [#_"Object" ___item ___items]
                (§ ass ___ret (.conj ___ret, ___item))
            )
            (.persistent ___ret)
        )
    )

    (defn- #_"PersistentVector" PersistentVector'init []
        (hash-map
            #_"int" :cnt 0
            #_"int" :shift 0
            #_"VNode" :root nil
            #_"Object[]" :tail nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-4 [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass (:_meta this) nil)
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-5 [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method asTransient) [#_"PersistentVector" this]
        (TransientVector'new-1 this)
    )

    #_method
    (§ defn #_"int" (§ method tailoff) [#_"PersistentVector" this]
        (when (< (:cnt this) 32)
            (§ return 0)
        )
        (ß (((:cnt this) - 1) >>> 5) << 5)
    )

    #_method
    (§ defn #_"Object[]" (§ method arrayFor) [#_"PersistentVector" this, #_"int" ___i]
        (when (and (<= 0 ___i) (< ___i (:cnt this)))
            (when (ß ___i >= (.tailoff this))
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (cast' VNode (§ aget (:array ___node) (ß (___i >>> ___level) & 0x01f))))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"PersistentVector" this, #_"int" ___i]
        (let [#_"Object[]" ___node (.arrayFor this, ___i)]
            (§ aget ___node (ß ___i & 0x01f))
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (and (<= 0 ___i) (< ___i (:cnt this)))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"PersistentVector" (§ method assocN) [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___val]
        (when (and (<= 0 ___i) (< ___i (:cnt this)))
            (when (ß ___i >= (.tailoff this))
                (let [#_"Object[]" ___newTail (make-array Object (§ alength (:tail this)))]
                    (ß System/arraycopy((:tail this), 0, ___newTail, 0, (§ alength (:tail this))))
                    (§ ass (§ aget ___newTail (ß ___i & 0x01f)) ___val)

                    (§ return (ß PersistentVector'new-5((.meta this), (:cnt this), (:shift this), (:root this), ___newTail)))
                )
            )

            (§ return (ß PersistentVector'new-5((.meta this), (:cnt this), (:shift this), this.doAssoc((:shift this), (:root this), ___i, ___val), (:tail this))))
        )
        (when (ß ___i == (:cnt this))
            (§ return (.cons this, ___val))
        )
        (throw (IndexOutOfBoundsException.))
    )

    (defn- #_"VNode" PersistentVector'doAssoc [#_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (let [#_"VNode" ___ret (ß VNode'new-2((:edit ___node), (:array ___node).clone()))]
            (if (zero? ___level)
                (do
                    (§ ass (§ aget (:array ___ret) (ß ___i & 0x01f)) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (§ aget (:array ___ret) ___subidx) (ß this.doAssoc((- ___level 5), (cast' VNode (§ aget (:array ___node) ___subidx)), ___i, ___val)))
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentVector" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method withMeta) [#_"PersistentVector" this, #_"IPersistentMap" ___meta]
        (PersistentVector'new-5 ___meta, (:cnt this), (:shift this), (:root this), (:tail this))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentVector" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method cons) [#_"PersistentVector" this, #_"Object" ___val]
        ;; room in tail?
        (when (ß (:cnt this) - (.tailoff this) < 32)
            (let [#_"Object[]" ___newTail (make-array Object (inc (§ alength (:tail this))))]
                (ß System/arraycopy((:tail this), 0, ___newTail, 0, (§ alength (:tail this))))
                (§ ass (§ aget ___newTail (ß (§ alength (:tail this)))) ___val)
                (§ return (ß PersistentVector'new-5((.meta this), (:cnt this) + 1, (:shift this), (:root this), ___newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"VNode" ___newroot]
            (let [#_"VNode" ___tailnode (ß VNode'new-2((:edit (:root this)), (:tail this)))]
                (let [#_"int" ___newshift (:shift this)]
                    ;; overflow root?
                    (if (ß ((:cnt this) >>> 5) > (1 << (:shift this)))
                        (do
                            (§ ass ___newroot (VNode'new-1 (:edit (:root this))))
                            (§ ass (§ aget (:array ___newroot) (ß 0)) (:root this))
                            (§ ass (§ aget (:array ___newroot) (ß 1)) (ß PersistentVector'newPath((:edit (:root this)), (:shift this), ___tailnode)))
                            (§ ass ___newshift (+ ___newshift 5))
                        )
                        (do
                            (§ ass ___newroot (.pushTail this, (:shift this), (:root this), ___tailnode))
                        )
                    )
                    (ß PersistentVector'new-5((.meta this), (:cnt this) + 1, ___newshift, ___newroot, (object-array [ ___val ])))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method pushTail) [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" ___subidx (ß (((:cnt this) - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret (ß VNode'new-2((:edit ___parent), (:array ___parent).clone()))]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (= ___level 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (cast' VNode (§ aget (:array ___parent) ___subidx))]
                                (§ ass ___nodeToInsert (if (some? ___child) (.pushTail this, (- ___level 5), ___child, ___tailnode) (PersistentVector'newPath (:edit (:root this)), (- ___level 5), ___tailnode)))
                            )
                        )
                    )
                    (§ ass (§ aget (:array ___ret) ___subidx) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    (defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" ___edit, #_"int" ___level, #_"VNode" ___node]
        (when (zero? ___level)
            (§ return ___node)
        )
        (let [#_"VNode" ___ret (VNode'new-1 ___edit)]
            (§ ass (§ aget (:array ___ret) (ß 0)) (ß PersistentVector'newPath(___edit, ___level - 5, ___node)))
            ___ret
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" (§ method chunkedSeq) [#_"PersistentVector" this]
        (when (zero? (count this))
            (§ return nil)
        )
        (ChunkedSeq'new-3 this, 0, 0)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentVector" this]
        (.chunkedSeq this)
    )

    #_override
    #_method
    (§ defn #_"Iterator" (§ method rangedIterator) [#_"PersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i ___start
                    #_"int" :base (- (:i this) (% (:i this) 32))
                    #_"Object[]" :array (when (< ___start (count this)) (.arrayFor this, (:i this)))
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (ß ((:i this) < ___end))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (if (< (:i this) ___end)
                    (do
                        (when (ß (:i this) - (:base this) == 32)
                            (§ ass (:array this) (.arrayFor this, (:i this)))
                            (§ ass (:base this) (+ (:base this) 32))
                        )
                        (let [_ (§ aget (:array this) (ß (:i this) & 0x01f))]
                            (§ ass (:i this) (+ (:i this) 1))
                            _
                        )
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentVector" this]
        (ß this.rangedIterator(0, (count this)))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentVector" this, #_"IFn" ___f]
        (§ let [#_"Object" ___init]
            (if (> (:cnt this) 0)
                (do
                    (§ ass ___init (ß this.arrayFor(0)[0]))
                )
                (do
                    (§ return (.invoke ___f))
                )
            )
            (let [#_"int" ___step 0]
                (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                    (let [#_"Object[]" ___array (.arrayFor this, ___i)]
                        (loop-when-recur [#_"int" ___j (if (zero? ___i) 1 0)] (< ___j (§ alength ___array)) [(inc ___j)]
                            (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                            (when (RT'isReduced ___init)
                                (§ return (.deref (cast' IDeref ___init)))
                            )
                        )
                        (§ ass ___step (§ alength ___array))
                    )
                )
                ___init
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                (let [#_"Object[]" ___array (.arrayFor this, ___i)]
                    (loop-when-recur [#_"int" ___j 0] (< ___j (§ alength ___array)) [(inc ___j)]
                        (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                        (when (RT'isReduced ___init)
                            (§ return (.deref (cast' IDeref ___init)))
                        )
                    )
                    (§ ass ___step (§ alength ___array))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                (let [#_"Object[]" ___array (.arrayFor this, ___i)]
                    (loop-when-recur [#_"int" ___j 0] (< ___j (§ alength ___array)) [(inc ___j)]
                        (§ ass ___init (ß ___f.invoke(___init, ___j + ___i, ___array[___j])))
                        (when (RT'isReduced ___init)
                            (§ return (.deref (cast' IDeref ___init)))
                        )
                    )
                    (§ ass ___step (§ alength ___array))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentVector" this]
        (.withMeta PersistentVector'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentVector" (§ method pop) [#_"PersistentVector" this]
        (when (zero? (:cnt this))
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß (:cnt this) == 1)
            (§ return (.withMeta PersistentVector'EMPTY, (.meta this)))
        )
        (when (ß (:cnt this) - (.tailoff this) > 1)
            (let [#_"Object[]" ___newTail (make-array Object (dec (§ alength (:tail this))))]
                (ß System/arraycopy((:tail this), 0, ___newTail, 0, (§ alength ___newTail)))
                (§ return (ß PersistentVector'new-5((.meta this), (:cnt this) - 1, (:shift this), (:root this), ___newTail)))
            )
        )
        (let [#_"Object[]" ___newtail (ß this.arrayFor((:cnt this) - 2))]
            (let [#_"VNode" ___newroot (.popTail this, (:shift this), (:root this))]
                (let [#_"int" ___newshift (:shift this)]
                    (when (nil? ___newroot)
                        (§ ass ___newroot PersistentVector'EMPTY_NODE)
                    )
                    (when (and (< 5 (:shift this)) (nil? (§ aget (:array ___newroot) (ß 1))))
                        (§ ass ___newroot (cast' VNode (§ aget (:array ___newroot) (ß 0))))
                        (§ ass ___newshift (- ___newshift 5))
                    )
                    (ß PersistentVector'new-5((.meta this), (:cnt this) - 1, ___newshift, ___newroot, ___newtail))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method popTail) [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___node]
        (let [#_"int" ___subidx (ß (((:cnt this) - 2) >>> ___level) & 0x01f)]
            (cond (> ___level 5)
                (do
                    (let [#_"VNode" ___newchild (ß this.popTail((- ___level 5), (cast' VNode (§ aget (:array ___node) ___subidx))))]
                        (if (and (nil? ___newchild) (zero? ___subidx))
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret (ß VNode'new-2((:edit (:root this)), (:array ___node).clone()))]
                                    (§ ass (§ aget (:array ___ret) ___subidx) ___newchild)
                                    ___ret
                                )
                            )
                        )
                    )
                )
                (zero? ___subidx)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret (ß VNode'new-2((:edit (:root this)), (:array ___node).clone()))]
                        (§ ass (§ aget (:array ___ret) ___subidx) nil)
                        ___ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (defn- #_"ProxyHandler" ProxyHandler'init []
        (hash-map
            ;; method-name-string->fn
            #_"IPersistentMap" :fns nil
        )
    )

    (defn #_"ProxyHandler" ProxyHandler'new [#_"IPersistentMap" ___fns]
        (let [this (ProxyHandler'init)]
            (§ ass (:fns this) ___fns)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ProxyHandler" this, #_"Object" ___proxy, #_"java.lang.reflect.Method" ___method, #_"Object[]" ___args] #_(§ throws Throwable)
        (let [#_"Class" ___rt (.getReturnType ___method)]
            (let [#_"IFn" ___fn (cast' IFn (.valAt (:fns this), (.getName ___method)))]
                (when (nil? ___fn)
                    (cond (= ___rt Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß (.getName ___method).equals("equals"))
                        (do
                            (§ return (ß ___proxy == ___args[0]))
                        )
                        (ß (.getName ___method).equals("hashCode"))
                        (do
                            (§ return (System/identityHashCode ___proxy))
                        )
                        (ß (.getName ___method).equals("toString"))
                        (do
                            (§ return (str "Proxy: " (System/identityHashCode ___proxy)))
                        )
                    )
                    (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ___ret (ß ___fn.applyTo(ArraySeq'create-1(___args)))]
                    (cond (= ___rt Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (.isPrimitive ___rt)
                        (do
                            (cond (= ___rt Character/TYPE)
                                (do
                                    (§ return ___ret)
                                )
                                (= ___rt Integer/TYPE)
                                (do
                                    (§ return (.intValue (cast Number ___ret)))
                                )
                                (= ___rt Long/TYPE)
                                (do
                                    (§ return (.longValue (cast Number ___ret)))
                                )
                                (= ___rt Float/TYPE)
                                (do
                                    (§ return (.floatValue (cast Number ___ret)))
                                )
                                (= ___rt Double/TYPE)
                                (do
                                    (§ return (.doubleValue (cast Number ___ret)))
                                )
                                (and (= ___rt Boolean/TYPE) (not (instance? Boolean ___ret)))
                                (do
                                    (§ return (if (nil? ___ret) Boolean/FALSE Boolean/TRUE))
                                )
                                (= ___rt Byte/TYPE)
                                (do
                                    (§ return (ß (byte) (cast Number ___ret).intValue()))
                                )
                                (= ___rt Short/TYPE)
                                (do
                                    (§ return (ß (short) (cast Number ___ret).intValue()))
                                )
                            )
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

#_private
(§ defprotocol RangeBoundsCheck
    #_abstract
    (#_"boolean" RangeBoundsCheck'''(§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" ___val])
)

#_private
#_non-static
(class-ns RangeIterator (§ implements Iterator)
    (defn- #_"RangeIterator" RangeIterator'init []
        (hash-map
            #_"Object" :next nil
        )
    )

    (defn #_"RangeIterator" RangeIterator'new []
        (let [this (RangeIterator'init)]
            (§ ass (:next this) (:start this))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"RangeIterator" this]
        (not (.exceededBounds (:boundsCheck this), (:next this)))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"RangeIterator" this]
        (if (.hasNext this)
            (do
                (let [#_"Object" ___ret (:next this)]
                    (§ ass (:next this) (Numbers'addP-2oo (:next this), (:step this)))
                    ___ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"RangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (def- #_"int" Range'CHUNK_SIZE 32)

    (defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (Numbers'gte-2oo ___val, ___end)
            )
        )
    )

    (defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (Numbers'lte-2oo ___val, ___end)
            )
        )
    )

    (defn- #_"Range" Range'init []
        (hash-map
            ;; Invariants guarantee this is never an "empty" seq
            #_"Object" :end nil
            #_"Object" :start nil
            #_"Object" :step nil
            #_"RangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"IChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Range" Range'new-4 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            this
        )
    )

    (defn- #_"Range" Range'new-6 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn- #_"Range" Range'new-7 [#_"IPersistentMap" ___meta, #_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new ___meta) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn #_"ISeq" Range'create-1 [#_"Object" ___end]
        (when (Numbers'isPos-1o ___end)
            (§ return (ß Range'new-4(0, ___end, 1, Range'positiveStep(___end))))
        )
        PersistentList'EMPTY
    )

    (defn #_"ISeq" Range'create-2 [#_"Object" ___start, #_"Object" ___end]
        (Range'create-3 ___start, ___end, 1)
    )

    (defn #_"ISeq" Range'create-3 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step]
        (when (or (and (Numbers'isPos-1o ___step) (Numbers'gt-2oo ___start, ___end)) (and (Numbers'isNeg-1o ___step) (Numbers'gt-2oo ___end, ___start)) (Numbers'equiv-2oo ___start, ___end))
            (§ return PersistentList'EMPTY)
        )
        (when (Numbers'isZero-1o ___step)
            (§ return (Repeat'create-1 ___start))
        )
        (Range'new-4 ___start, ___end, ___step, (if (Numbers'isPos-1o ___step) (Range'positiveStep ___end) (Range'negativeStep ___end)))
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"Range" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (Range'new-7 ___meta, (:end this), (:start this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Range" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" (§ method forceChunk) [#_"Range" this]
        (when (some? (:_chunk this))
            (§ return nil)
        )

        (let [#_"Object[]" ___arr (make-array Object Range'CHUNK_SIZE)]
            (let [#_"int" ___n 0]
                (let [#_"Object" ___val (:start this)]
                    (while (< ___n Range'CHUNK_SIZE)
                        (§ ass (§ aget ___arr ___n) ___val)
                        (§ ass ___n (inc ___n))
                        (§ ass ___val (Numbers'addP-2oo ___val, (:step this)))
                        (when (.exceededBounds (:boundsCheck this), ___val)
                            ;; partial last chunk
                            (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, ___n))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (.exceededBounds (:boundsCheck this), ___val)
                        (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, Range'CHUNK_SIZE))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, Range'CHUNK_SIZE))
                    (§ ass (:_chunkNext this) (Range'new-4 ___val, (:end this), (:step this), (:boundsCheck this)))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Range" this]
        (when (some? (:_next this))
            (§ return (:_next this))
        )

        (.forceChunk this)
        (when (ß (:_chunk this).count() > 1)
            (let [#_"IChunk" ___smallerChunk (.dropFirst (:_chunk this))]
                (§ ass (:_next this) (ß Range'new-6(___smallerChunk.nth(0), (:end this), (:step this), (:boundsCheck this), ___smallerChunk, (:_chunkNext this))))
                (§ return (:_next this))
            )
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"Range" this]
        (.forceChunk this)
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"Range" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"Range" this]
        (.forceChunk this)
        (when (nil? (:_chunkNext this))
            (§ return PersistentList'EMPTY)
        )
        (:_chunkNext this)
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Range" this, #_"IFn" ___f]
        (let [#_"Object" ___acc (:start this)]
            (let [#_"Number" ___i (Numbers'addP-2oo (:start this), (:step this))]
                (while (not (.exceededBounds (:boundsCheck this), ___i))
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (RT'isReduced ___acc)
                        (§ return (.deref (cast' Reduced ___acc)))
                    )
                    (§ ass ___i (Numbers'addP-2oo ___i, (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Range" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"Object" ___i (:start this)]
                (while (not (.exceededBounds (:boundsCheck this), ___i))
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (RT'isReduced ___acc)
                        (§ return (.deref (cast' Reduced ___acc)))
                    )
                    (§ ass ___i (Numbers'addP-2oo ___i, (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"Range" this]
        (RangeIterator'new)
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (defn- #_"Ratio" Ratio'init []
        (hash-map
            #_"BigInteger" :numerator nil
            #_"BigInteger" :denominator nil
        )
    )

    (defn #_"Ratio" Ratio'new [#_"BigInteger" ___numerator, #_"BigInteger" ___denominator]
        (let [this (merge (Number'new) (Ratio'init))]
            (§ ass (:numerator this) ___numerator)
            (§ ass (:denominator this) ___denominator)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"Ratio" this, #_"Object" ___arg0]
        (and (some? ___arg0) (§ instance? Ratio ___arg0) (ß (:numerator (cast' Ratio ___arg0)).equals((:numerator this))) (ß (:denominator (cast' Ratio ___arg0)).equals((:denominator this))))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Ratio" this]
        (ß (:numerator this).hashCode() :xor (:denominator this).hashCode())
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Ratio" this]
        (str (.toString (:numerator this)) "/" (.toString (:denominator this)))
    )

    #_method
    (§ defn #_"int" (§ method intValue) [#_"Ratio" this]
        (ß (int) (.doubleValue this))
    )

    #_method
    (§ defn #_"long" (§ method longValue) [#_"Ratio" this]
        (.longValue (.bigIntegerValue this))
    )

    #_method
    (§ defn #_"float" (§ method floatValue) [#_"Ratio" this]
        (ß (float)this.doubleValue())
    )

    #_method
    (§ defn #_"double" (§ method doubleValue) [#_"Ratio" this]
        (ß this.decimalValue(MathContext/DECIMAL64).doubleValue())
    )

    #_method
    (§ defn #_"BigDecimal" (§ method decimalValue) [#_"Ratio" this]
        (.decimalValue this, MathContext/UNLIMITED)
    )

    #_method
    (§ defn #_"BigDecimal" (§ method decimalValue) [#_"Ratio" this, #_"MathContext" ___mc]
        (let [#_"BigDecimal" ___numerator (§ unsure BigDecimal. (:numerator this))]
            (let [#_"BigDecimal" ___denominator (§ unsure BigDecimal. (:denominator this))]
                (.divide ___numerator, ___denominator, ___mc)
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" (§ method bigIntegerValue) [#_"Ratio" this]
        (.divide (:numerator this), (:denominator this))
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Ratio" this, #_"Object" ___o]
        (let [#_"Number" ___other (cast Number ___o)]
            (Numbers'compare this, ___other)
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def #_"Keyword" ReaderConditional'FORM_KW (Keyword'intern-1 "form"))
    (§ def #_"Keyword" ReaderConditional'SPLICING_KW (Keyword'intern-1 "splicing?"))

    (defn #_"ReaderConditional" ReaderConditional'create [#_"Object" ___form, #_"boolean" ___splicing]
        (ReaderConditional'new ___form, ___splicing)
    )

    (defn- #_"ReaderConditional" ReaderConditional'init []
        (hash-map
            #_"Object" :form nil
            #_"Boolean" :splicing nil
        )
    )

    (defn- #_"ReaderConditional" ReaderConditional'new [#_"Object" ___form, #_"boolean" ___splicing]
        (let [this (ReaderConditional'init)]
            (§ ass (:form this) ___form)
            (§ ass (:splicing this) ___splicing)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ReaderConditional" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ReaderConditional" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (.equals ReaderConditional'FORM_KW, ___key)
            (do
                (:form this)
            )
            (.equals ReaderConditional'SPLICING_KW, ___key)
            (do
                (:splicing this)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" (§ method equals) [#_"ReaderConditional" this, #_"Object" ___o]
        (when (= this ___o)
            (§ return true)
        )
        (when (or (nil? ___o) (ß getClass() != (.getClass ___o)))
            (§ return false)
        )

        (let [#_"ReaderConditional" ___that (cast' ReaderConditional ___o)]
            (when (if (some? (:form this)) (not (.equals (:form this), (:form ___that))) (some? (:form ___that)))
                (§ return false)
            )
            (when (if (some? (:splicing this)) (not (.equals (:splicing this), (:splicing ___that))) (some? (:splicing ___that)))
                (§ return false)
            )
            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"ReaderConditional" this]
        (let [#_"int" ___result (Util'hash (:form this))]
            (§ ass ___result (ß 31 * ___result + Util'hash((:splicing this))))
            ___result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (defn- #_"RecordIterator" RecordIterator'init []
        (hash-map
            #_"int" :i 0
            #_"int" :basecnt 0
            #_"ILookup" :rec nil
            #_"IPersistentVector" :basefields nil
            #_"Iterator" :extmap nil
        )
    )

    (defn #_"RecordIterator" RecordIterator'new [#_"ILookup" ___rec, #_"IPersistentVector" ___basefields, #_"Iterator" ___extmap]
        (let [this (RecordIterator'init)]
            (§ ass (:rec this) ___rec)
            (§ ass (:basefields this) ___basefields)
            (§ ass (:basecnt this) (count ___basefields))
            (§ ass (:extmap this) ___extmap)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                true
            )
            (do
                (.hasNext (:extmap this))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                (let [#_"Object" ___k (.nth (:basefields this), (:i this))]
                    (§ ass (:i this) (+ (:i this) 1))
                    (ß MapEntry'create(___k, (:rec this).valAt(___k)))
                )
            )
            (do
                (next (:extmap this))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (defn- #_"Reduced" Reduced'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Reduced" Reduced'new [#_"Object" ___val]
        (let [this (Reduced'init)]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Reduced" this]
        (:val this)
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns RefTVal
    (defn- #_"RefTVal" RefTVal'init []
        (hash-map
            #_"Object" :val nil
            #_"long" :point 0
            #_"RefTVal" :prior nil
            #_"RefTVal" :next nil
        )
    )

    (defn #_"RefTVal" RefTVal'new-3 [#_"Object" ___val, #_"long" ___point, #_"RefTVal" ___prior]
        (let [this (RefTVal'init)]
            (§ ass (:val this) ___val)
            (§ ass (:point this) ___point)
            (§ ass (:prior this) ___prior)
            (§ ass (:next this) (:next ___prior))
            (§ ass (:next (:prior this)) this)
            (§ ass (:prior (:next this)) this)
            this
        )
    )

    (defn #_"RefTVal" RefTVal'new-2 [#_"Object" ___val, #_"long" ___point]
        (let [this (RefTVal'init)]
            (§ ass (:val this) ___val)
            (§ ass (:point this) ___point)
            (§ ass (:next this) this)
            (§ ass (:prior this) this)
            this
        )
    )
)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (def #_"AtomicLong" Ref'ids (AtomicLong.))

    (defn- #_"Ref" Ref'init []
        (hash-map
            #_"RefTVal" :tvals nil
            #_"AtomicInteger" :faults nil
            #_"ReentrantReadWriteLock" :lock nil
            #_"LockingTransactionInfo" :tinfo nil
            #_"long" :id 0

            #_volatile
            #_"int" :minHistory 0
            #_volatile
            #_"int" :maxHistory 10
        )
    )

    (defn #_"Ref" Ref'new-1 [#_"Object" ___initVal]
        (Ref'new-2 ___initVal, nil)
    )

    (defn #_"Ref" Ref'new-2 [#_"Object" ___initVal, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Ref'init))]
            (§ ass (:id this) (.getAndIncrement Ref'ids))
            (§ ass (:faults this) (AtomicInteger.))
            (§ ass (:lock this) (ReentrantReadWriteLock.))
            (§ ass (:tvals this) (RefTVal'new-2 ___initVal, 0))
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Ref" this, #_"Ref" ___ref]
        (cond (ß (:id this) == (:id ___ref))
            (do
                0
            )
            (ß (:id this) < (:id ___ref))
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method getMinHistory) [#_"Ref" this]
        (:minHistory this)
    )

    #_method
    (§ defn #_"Ref" (§ method setMinHistory) [#_"Ref" this, #_"int" ___minHistory]
        (§ ass (:minHistory this) ___minHistory)
        this
    )

    #_method
    (§ defn #_"int" (§ method getMaxHistory) [#_"Ref" this]
        (:maxHistory this)
    )

    #_method
    (§ defn #_"Ref" (§ method setMaxHistory) [#_"Ref" this, #_"int" ___maxHistory]
        (§ ass (:maxHistory this) ___maxHistory)
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" (§ method currentVal) [#_"Ref" this]
        (try
            (ß (:lock this).readLock().lock())
            (when (some? (:tvals this))
                (§ return (:val (:tvals this)))
            )
            (throw (IllegalStateException. (str (.toString this) " is unbound.")))
            (finally
                (ß (:lock this).readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Ref" this]
        (let [#_"LockingTransaction" ___t (LockingTransaction'getRunning)]
            (when (nil? ___t)
                (§ return (.currentVal this))
            )
            (.doGet ___t, this)
        )
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"Ref" this, #_"Object" ___val]
        (ß LockingTransaction'getEx().doSet(this, ___val))
    )

    #_method
    (§ defn #_"Object" (§ method commute) [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß LockingTransaction'getEx().doCommute(this, ___fn, ___args))
    )

    #_method
    (§ defn #_"Object" (§ method alter) [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (let [#_"LockingTransaction" ___t (LockingTransaction'getEx)]
            (ß ___t.doSet(this, ___fn.applyTo(RT'cons(___t.doGet(this), ___args))))
        )
    )

    #_method
    (§ defn #_"void" (§ method touch) [#_"Ref" this]
        (ß LockingTransaction'getEx().doEnsure(this))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isBound) [#_"Ref" this]
        (try
            (ß (:lock this).readLock().lock())
            (some? (:tvals this))
            (finally
                (ß (:lock this).readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method trimHistory) [#_"Ref" this]
        (try
            (ß (:lock this).writeLock().lock())
            (when (some? (:tvals this))
                (§ ass (:next (:tvals this)) (:tvals this))
                (§ ass (:prior (:tvals this)) (:tvals this))
            )
            (finally
                (ß (:lock this).writeLock().unlock())
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getHistoryCount) [#_"Ref" this]
        (try
            (ß (:lock this).writeLock().lock())
            (.histCount this)
            (finally
                (ß (:lock this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method histCount) [#_"Ref" this]
        (if (nil? (:tvals this))
            (do
                0
            )
            (do
                (let [#_"int" ___count 0]
                    (loop-when-recur [#_"RefTVal" ___tv (:next (:tvals this))] (ß ___tv != (:tvals this)) [(:next ___tv)]
                        (§ ass ___count (inc ___count))
                    )
                    ___count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fn) [#_"Ref" this]
        (cast' IFn (.deref this))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Ref" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Ref" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this]
        (.invoke (.fn this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1]
        (ß (.fn this).invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß (.fn this).invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args))
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Ref" this, #_"ISeq" ___arglist]
        (AFn'applyToHelper this, ___arglist)
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" ___target, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"List" ___methods (ß Reflector'getMethods(___c, (§ alength ___args), ___methodName, false))]
                (Reflector'invokeMatchingMethod ___methodName, ___methods, ___target, ___args)
            )
        )
    )

    (defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" ___e]
        (when (some? (.getCause ___e))
            (§ return (.getCause ___e))
        )
        ___e
    )

    (defn- #_"RuntimeException" Reflector'throwCauseOrElseException [#_"Exception" ___e]
        (when (some? (.getCause ___e))
            (throw (Util'sneakyThrow (.getCause ___e)))
        )
        (throw (Util'sneakyThrow ___e))
    )

    (defn- #_"String" Reflector'noMethodReport [#_"String" ___methodName, #_"Object" ___target]
        (str "No matching method found: " ___methodName (if (nil? ___target) "" (str " for " (.getClass ___target))))
    )

    (defn #_"Object" Reflector'invokeMatchingMethod [#_"String" ___methodName, #_"List" ___methods, #_"Object" ___target, #_"Object[]" ___args]
        (let [#_"java.lang.reflect.Method" ___m nil]
            (let [#_"Object[]" ___boxedArgs nil]
                (cond (.isEmpty ___methods)
                    (do
                        (throw (§ unsure IllegalArgumentException. (Reflector'noMethodReport ___methodName, ___target)))
                    )
                    (ß (.size ___methods) == 1)
                    (do
                        (§ ass ___m (ß (java.lang.reflect.Method) ___methods.get(0)))
                        (§ ass ___boxedArgs (ß Reflector'boxArgs((.getParameterTypes ___m), ___args)))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"java.lang.reflect.Method" ___foundm nil]
                            (loop-when-recur [#_"Iterator" ___i (.iterator ___methods)] (.hasNext ___i) [___i]
                                (§ ass ___m (ß (java.lang.reflect.Method) (next ___i)))

                                (let [#_"Class[]" ___params (.getParameterTypes ___m)]
                                    (when (Reflector'isCongruent ___params, ___args)
                                        (when (or (nil? ___foundm) (Compiler'subsumes ___params, (.getParameterTypes ___foundm)))
                                            (§ ass ___foundm ___m)
                                            (§ ass ___boxedArgs (Reflector'boxArgs ___params, ___args))
                                        )
                                    )
                                )
                            )
                            (§ ass ___m ___foundm)
                        )
                    )
                )
                (when (nil? ___m)
                    (throw (§ unsure IllegalArgumentException. (Reflector'noMethodReport ___methodName, ___target)))
                )

                (when (not (Modifier/isPublic (.getModifiers (.getDeclaringClass ___m))))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"java.lang.reflect.Method" ___oldm ___m]
                        (§ ass ___m (ß Reflector'getAsMethodOfPublicBase((.getClass ___target), ___m)))
                        (when (nil? ___m)
                            (throw (IllegalArgumentException. (str "Can't call public method of non-public class: " (.toString ___oldm))))
                        )
                    )
                )
                (try
                    (ß Reflector'prepRet((.getReturnType ___m), ___m.invoke(___target, ___boxedArgs)))
                    (catch Exception ___e
                        (throw (ß Util'sneakyThrow(Reflector'getCauseOrElse(___e))))
                    )
                )
            )
        )
    )

    (defn #_"java.lang.reflect.Method" Reflector'getAsMethodOfPublicBase [#_"Class" ___c, #_"java.lang.reflect.Method" ___m]
        (doseq [#_"Class" ___iface (.getInterfaces ___c)]
            (doseq [#_"java.lang.reflect.Method" ___im (.getMethods ___iface)]
                (when (Reflector'isMatch ___im, ___m)
                    (§ return ___im)
                )
            )
        )
        (let [#_"Class" ___sc (.getSuperclass ___c)]
            (when (nil? ___sc)
                (§ return nil)
            )
            (doseq [#_"java.lang.reflect.Method" ___scm (.getMethods ___sc)]
                (when (Reflector'isMatch ___scm, ___m)
                    (§ return ___scm)
                )
            )
            (Reflector'getAsMethodOfPublicBase ___sc, ___m)
        )
    )

    (defn #_"boolean" Reflector'isMatch [#_"java.lang.reflect.Method" ___lhs, #_"java.lang.reflect.Method" ___rhs]
        (when (or (not (ß ___lhs.getName().equals((.getName ___rhs)))) (not (Modifier/isPublic (.getModifiers (.getDeclaringClass ___lhs)))))
            (§ return false)
        )

        (let [#_"Class[]" ___types1 (.getParameterTypes ___lhs)]
            (let [#_"Class[]" ___types2 (.getParameterTypes ___rhs)]
                (when (not= (§ alength ___types1) (§ alength ___types2))
                    (§ return false)
                )

                (let [#_"boolean" ___match true]
                    (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___types1)) [(inc ___i)]
                        (when (not (ß ___types1[___i].isAssignableFrom(___types2[___i])))
                            (§ ass ___match false)
                            (§ break )
                        )
                    )
                    ___match
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeConstructor [#_"Class" ___c, #_"Object[]" ___args]
        (try
            (let [#_"Constructor[]" ___allctors (.getConstructors ___c)]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___allctors)) [(inc ___i)]
                        (let [#_"Constructor" ___ctor (§ aget ___allctors ___i)]
                            (when (ß (§ alength (.getParameterTypes ___ctor)) == (§ alength ___args))
                                (.add ___ctors, ___ctor)
                            )
                        )
                    )
                    (cond (.isEmpty ___ctors)
                        (do
                            (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                        )
                        (ß (.size ___ctors) == 1)
                        (do
                            (let [#_"Constructor" ___ctor (cast Constructor (.get ___ctors, 0))]
                                (ß ___ctor.newInstance(Reflector'boxArgs((.getParameterTypes ___ctor), ___args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [#_"Iterator" ___iterator (.iterator ___ctors)] (.hasNext ___iterator) [___iterator]
                                (let [#_"Constructor" ___ctor (cast Constructor (next ___iterator))]
                                    (let [#_"Class[]" ___params (.getParameterTypes ___ctor)]
                                        (when (Reflector'isCongruent ___params, ___args)
                                            (let [#_"Object[]" ___boxedArgs (Reflector'boxArgs ___params, ___args)]
                                                (§ return (.newInstance ___ctor, ___boxedArgs))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (throw (ß Util'sneakyThrow(Reflector'getCauseOrElse(___e))))
            )
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" ___className, #_"String" ___methodName, #_"Object..." ___args]
        (Reflector'invokeStaticMethod-3s ___className, ___methodName, ___args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3s [#_"String" ___className, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (Reflector'invokeStaticMethod-3c ___c, ___methodName, ___args)
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3c [#_"Class" ___c, #_"String" ___methodName, #_"Object[]" ___args]
        (when (.equals ___methodName, "new")
            (§ return (Reflector'invokeConstructor ___c, ___args))
        )
        (let [#_"List" ___methods (ß Reflector'getMethods(___c, (§ alength ___args), ___methodName, true))]
            (Reflector'invokeMatchingMethod ___methodName, ___methods, nil, ___args)
        )
    )

    (defn #_"Object" Reflector'getStaticField-2s [#_"String" ___className, #_"String" ___fieldName]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (Reflector'getStaticField-2c ___c, ___fieldName)
        )
    )

    (defn #_"Object" Reflector'getStaticField-2c [#_"Class" ___c, #_"String" ___fieldName]
        (let [#_"Field" ___f (Reflector'getField ___c, ___fieldName, true)]
            (when (some? ___f)
                (try
                    (§ return (ß Reflector'prepRet((.getType ___f), ___f.get(nil))))
                    (catch IllegalAccessException ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
            (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " ___c)))
        )
    )

    (defn #_"Object" Reflector'setStaticField-3s [#_"String" ___className, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (Reflector'setStaticField-3c ___c, ___fieldName, ___val)
        )
    )

    (defn #_"Object" Reflector'setStaticField-3c [#_"Class" ___c, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Field" ___f (Reflector'getField ___c, ___fieldName, true)]
            (when (some? ___f)
                (try
                    (ß ___f.set(nil, Reflector'boxArg((.getType ___f), ___val)))
                    (catch IllegalAccessException ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
                (§ return ___val)
            )
            (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " ___c)))
        )
    )

    (defn #_"Object" Reflector'getInstanceField [#_"Object" ___target, #_"String" ___fieldName]
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (Reflector'getField ___c, ___fieldName, false)]
                (when (some? ___f)
                    (try
                        (§ return (ß Reflector'prepRet((.getType ___f), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                )
                (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " (.getClass ___target))))
            )
        )
    )

    (defn #_"Object" Reflector'setInstanceField [#_"Object" ___target, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (Reflector'getField ___c, ___fieldName, false)]
                (when (some? ___f)
                    (try
                        (ß ___f.set(___target, Reflector'boxArg((.getType ___f), ___val)))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                    (§ return ___val)
                )
                (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " (.getClass ___target))))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (defn #_"Object" Reflector'invokeNoArgInstanceMember-2 [#_"Object" ___target, #_"String" ___name]
        (Reflector'invokeNoArgInstanceMember-3 ___target, ___name, false)
    )

    (defn #_"Object" Reflector'invokeNoArgInstanceMember-3 [#_"Object" ___target, #_"String" ___name, #_"boolean" ___requireField]
        (let [#_"Class" ___c (.getClass ___target)]
            (if ___requireField
                (do
                    (let [#_"Field" ___f (Reflector'getField ___c, ___name, false)]
                        (if (some? ___f)
                            (do
                                (Reflector'getInstanceField ___target, ___name)
                            )
                            (do
                                (throw (IllegalArgumentException. (str "No matching field found: " ___name " for " (.getClass ___target))))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" ___meths (Reflector'getMethods ___c, 0, ___name, false)]
                        (if (pos? (.size ___meths))
                            (do
                                (Reflector'invokeMatchingMethod ___name, ___meths, ___target, RT'EMPTY_ARRAY)
                            )
                            (do
                                (Reflector'getInstanceField ___target, ___name)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-2 [#_"Object" ___target, #_"String" ___name]
        ;; check for field first
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (Reflector'getField ___c, ___name, false)]
                (when (some? ___f) ;; field get
                    (try
                        (§ return (ß Reflector'prepRet((.getType ___f), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                )
                (Reflector'invokeInstanceMethod ___target, ___name, RT'EMPTY_ARRAY)
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3o [#_"String" ___name, #_"Object" ___target, #_"Object" ___arg1]
        ;; check for field first
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (Reflector'getField ___c, ___name, false)]
                (when (some? ___f) ;; field set
                    (try
                        (ß ___f.set(___target, Reflector'boxArg((.getType ___f), ___arg1)))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                    (§ return ___arg1)
                )
                (ß Reflector'invokeInstanceMethod(___target, ___name, (object-array [ ___arg1 ])))
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3a [#_"String" ___name, #_"Object" ___target, #_"Object..." ___args]
        (Reflector'invokeInstanceMethod ___target, ___name, ___args)
    )

    (defn #_"Field" Reflector'getField [#_"Class" ___c, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"Field[]" ___allfields (.getFields ___c)]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___allfields)) [(inc ___i)]
                (when (and (ß ___name.equals(___allfields[___i].getName())) (ß (ß Modifier/isStatic(___allfields[___i].getModifiers())) == ___getStatics))
                    (§ return (§ aget ___allfields ___i))
                )
            )
            nil
        )
    )

    (defn #_"List" Reflector'getMethods [#_"Class" ___c, #_"int" ___arity, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"java.lang.reflect.Method[]" ___allmethods (.getMethods ___c)]
            (let [#_"ArrayList" ___methods (ArrayList.)]
                (let [#_"ArrayList" ___bridgeMethods (ArrayList.)]
                    (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___allmethods)) [(inc ___i)]
                        (let [#_"java.lang.reflect.Method" ___method (§ aget ___allmethods ___i)]
                            (when (and (.equals ___name, (.getName ___method)) (ß (Modifier/isStatic (.getModifiers ___method)) == ___getStatics) (ß (§ alength (.getParameterTypes ___method)) == ___arity))
                                (try
                                    (if (and (.isBridge ___method) (.equals (ß ___c.getMethod((.getName ___method), (.getParameterTypes ___method))), ___method))
                                        (do
                                            (.add ___bridgeMethods, ___method)
                                        )
                                        (do
                                            (.add ___methods, ___method)
                                        )
                                    )
                                    (catch NoSuchMethodException ___e
                                    )
                                )
                            )
                        )
                    )

                    (when (.isEmpty ___methods)
                        (.addAll ___methods, ___bridgeMethods)
                    )
                    (when (and (not ___getStatics) (.isInterface ___c))
                        (§ ass ___allmethods (.getMethods Object))
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___allmethods)) [(inc ___i)]
                            (when (and (.equals ___name, (ß ___allmethods[___i].getName())) (= (ß Modifier/isStatic(___allmethods[___i].getModifiers())) ___getStatics) (= (§ alength (ß ___allmethods[___i].getParameterTypes())) ___arity))
                                (ß ___methods.add(___allmethods[___i]))
                            )
                        )
                    )
                    ___methods
                )
            )
        )
    )

    (defn #_"Object" Reflector'boxArg [#_"Class" ___paramType, #_"Object" ___arg]
        (cond (not (.isPrimitive ___paramType))
            (do
                (§ return (.cast ___paramType, ___arg))
            )
            (= ___paramType Boolean/TYPE)
            (do
                (§ return (.cast Boolean, ___arg))
            )
            (= ___paramType Character/TYPE)
            (do
                (§ return (.cast Character, ___arg))
            )
            (instance? Number ___arg)
            (do
                (let [#_"Number" ___n (cast Number ___arg)]
                    (cond (= ___paramType Integer/TYPE)
                        (do
                            (§ return (.intValue ___n))
                        )
                        (= ___paramType Float/TYPE)
                        (do
                            (§ return (.floatValue ___n))
                        )
                        (= ___paramType Double/TYPE)
                        (do
                            (§ return (.doubleValue ___n))
                        )
                        (= ___paramType Long/TYPE)
                        (do
                            (§ return (.longValue ___n))
                        )
                        (= ___paramType Short/TYPE)
                        (do
                            (§ return (.shortValue ___n))
                        )
                        (= ___paramType Byte/TYPE)
                        (do
                            (§ return (.byteValue ___n))
                        )
                    )
                )
            )
        )
        (throw (IllegalArgumentException. (str "Unexpected param type, expected: " ___paramType ", given: " (.getName (.getClass ___arg)))))
    )

    (defn #_"Object[]" Reflector'boxArgs [#_"Class[]" ___params, #_"Object[]" ___args]
        (when (zero? (§ alength ___params))
            (§ return nil)
        )
        (let [#_"Object[]" ___ret (make-array Object (§ alength ___params))]
            (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___params)) [(inc ___i)]
                (let [#_"Object" ___arg (§ aget ___args ___i)]
                    (let [#_"Class" ___paramType (§ aget ___params ___i)]
                        (§ ass (§ aget ___ret ___i) (Reflector'boxArg ___paramType, ___arg))
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" ___paramType, #_"Class" ___argType]
        (when (nil? ___argType)
            (§ return (not (.isPrimitive ___paramType)))
        )
        (when (or (ß ___paramType == ___argType) (.isAssignableFrom ___paramType, ___argType))
            (§ return true)
        )
        (cond (= ___paramType Integer/TYPE)
            (do
                (§ return (or (ß ___argType == Integer) (ß ___argType == Long/TYPE) (ß ___argType == Long) (ß ___argType == Short/TYPE) (ß ___argType == Byte/TYPE)))
            )
            (= ___paramType Float/TYPE)
            (do
                (§ return (or (ß ___argType == Float) (ß ___argType == Double/TYPE)))
            )
            (= ___paramType Double/TYPE)
            (do
                (§ return (or (ß ___argType == Double) (ß ___argType == Float/TYPE)))
            )
            (= ___paramType Long/TYPE)
            (do
                (§ return (or (ß ___argType == Long) (ß ___argType == Integer/TYPE) (ß ___argType == Short/TYPE) (ß ___argType == Byte/TYPE)))
            )
            (= ___paramType Character/TYPE)
            (do
                (§ return (= ___argType Character))
            )
            (= ___paramType Short/TYPE)
            (do
                (§ return (= ___argType Short))
            )
            (= ___paramType Byte/TYPE)
            (do
                (§ return (= ___argType Byte))
            )
            (= ___paramType Boolean/TYPE)
            (do
                (§ return (= ___argType Boolean))
            )
        )
        false
    )

    (defn #_"boolean" Reflector'isCongruent [#_"Class[]" ___params, #_"Object[]" ___args]
        (let [#_"boolean" ___ret false]
            (when (nil? ___args)
                (§ return (zero? (§ alength ___params)))
            )
            (when (= (§ alength ___params) (§ alength ___args))
                (§ ass ___ret true)
                (loop-when-recur [#_"int" ___i 0] (and ___ret (< ___i (§ alength ___params))) [(inc ___i)]
                    (let [#_"Object" ___arg (§ aget ___args ___i)]
                        (let [#_"Class" ___argType (when (some? ___arg) (.getClass ___arg))]
                            (let [#_"Class" ___paramType (§ aget ___params ___i)]
                                (§ ass ___ret (Reflector'paramArgTypeMatch ___paramType, ___argType))
                            )
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"Object" Reflector'prepRet [#_"Class" ___c, #_"Object" ___x]
        (when (not (or (.isPrimitive ___c) (ß ___c == Boolean)))
            (§ return ___x)
        )
        (when (instance? Boolean ___x)
            (§ return (if (cast Boolean ___x) Boolean/TRUE Boolean/FALSE))
        )
        ___x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (def- #_"long" Repeat'INFINITE -1)

    (defn- #_"Repeat" Repeat'init []
        (hash-map
            #_"long" :count 0 ;; always INFINITE or >0
            #_"Object" :val nil
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Repeat" Repeat'new-2 [#_"long" ___count, #_"Object" ___val]
        (let [this (merge (ASeq'new) (Repeat'init))]
            (§ ass (:count this) ___count)
            (§ ass (:val this) ___val)
            this
        )
    )

    (defn- #_"Repeat" Repeat'new-3 [#_"IPersistentMap" ___meta, #_"long" ___count, #_"Object" ___val]
        (let [this (merge (ASeq'new ___meta) (Repeat'init))]
            (§ ass (:count this) ___count)
            (§ ass (:val this) ___val)
            this
        )
    )

    (defn #_"Repeat" Repeat'create-1 [#_"Object" ___val]
        (Repeat'new-2 Repeat'INFINITE, ___val)
    )

    (defn #_"ISeq" Repeat'create-2 [#_"long" ___count, #_"Object" ___val]
        (when (<= ___count 0)
            (§ return PersistentList'EMPTY)
        )
        (Repeat'new-2 ___count, ___val)
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Repeat" this]
        (:val this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Repeat" this]
        (when (nil? (:_next this))
            (cond (> (:count this) 1)
                (do
                    (§ ass (:_next this) (ß Repeat'new-2((:count this) - 1, (:val this))))
                )
                (ß (:count this) == Repeat'INFINITE)
                (do
                    (§ ass (:_next this) this)
                )
            )
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Repeat" (§ method withMeta) [#_"Repeat" this, #_"IPersistentMap" ___meta]
        (Repeat'new-3 ___meta, (:count this), (:val this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Repeat" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (:val this)]
            (if (ß (:count this) == Repeat'INFINITE)
                (do
                    (while true
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (.deref (cast' IDeref ___ret)))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"long" ___i 1] (< ___i (:count this)) [(inc ___i)]
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (.deref (cast' IDeref ___ret)))
                        )
                    )
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Repeat" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (if (ß (:count this) == Repeat'INFINITE)
                (do
                    (while true
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (.deref (cast' IDeref ___ret)))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"long" ___i 0] (< ___i (:count this)) [(inc ___i)]
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (.deref (cast' IDeref ___ret)))
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_protected
    (defn #_"RestFn" RestFn'new []
        (AFunction'new)
    )

    #_abstract
    (§ defn #_"int" (§ method getRequiredArity) [#_"RestFn" this])

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object" ___args]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"RestFn" this, #_"ISeq" ___args]
        (when (ß RT'boundedLength(___args, (.getRequiredArity this)) <= (.getRequiredArity this))
            (§ return (ß AFn'applyToHelper(this, Util'ret1(___args, (§ ass ___args nil)))))
        )
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (§ return (ß this.doInvoke(Util'ret1(___args, (§ ass ___args nil)))))
            )
            (§ case 1)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 2)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 3)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 4)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 5)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 6)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 7)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 8)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 9)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 10)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 11)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 12)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 13)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 14)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 15)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 16)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 17)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 18)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 19)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 20)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
        )
        (.throwArity this, -1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (.doInvoke this, nil)
            )
            (§ default )
            (do
                (.throwArity this, 0)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(ArraySeq'create-1(Util'ret1(___arg1, (§ ass ___arg1 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 1)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 2)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 3)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 4)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 5)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 6)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 7)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 8)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 9)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 10)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 11)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 12)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 13)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 14)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 15)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 16)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 17)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 18)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 19)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 19)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 20)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ontoArrayPrepend(___args,
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                        ArraySeq'create-1(___args)))
            )
            (§ default )
            (do
                (.throwArity this, 21)
            )
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" ___array, #_"Object..." ___args]
        (let [#_"ISeq" ___ret (ArraySeq'create-1 ___array)]
            (loop-when-recur [#_"int" ___i (- (§ alength ___args) 1)] (>= ___i 0) [(dec ___i)]
                (§ ass ___ret (ß RT'cons(___args[___i], ___ret)))
            )
            ___ret
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'findKey [#_"Object" ___key, #_"ISeq" ___args]
        (while (some? ___args)
            (when (ß ___key == (first ___args))
                (§ return (next ___args))
            )
            (§ ass ___args (RT'next ___args))
            (§ ass ___args (RT'next ___args))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(§ defprotocol Reversible
    #_abstract
    (#_"ISeq" Reversible'''(§ method rseq) [#_"Reversible" this])
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_private
#_closure
(class-ns DefaultComparator (§ implements Comparator)
    (defn #_"DefaultComparator" DefaultComparator'new []
        (hash-map)
    )

    #_method
    (§ defn #_"int" (§ method compare) [#_"DefaultComparator" this, #_"Object" ___o1, #_"Object" ___o2]
        (Util'compare ___o1, ___o2)
    )
)

#_stateless
(class-ns RT
    (def #_"Boolean" RT'T Boolean/TRUE)
    (def #_"Boolean" RT'F Boolean/FALSE)
    (def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (def #_"IPersistentMap" RT'DEFAULT_IMPORTS (ß map(
        (object-array [
            (Symbol'intern-1 "Boolean")                         Boolean
            (Symbol'intern-1 "Byte")                            Byte
            (Symbol'intern-1 "Character")                       Character
            (Symbol'intern-1 "Class")                           Class
            (Symbol'intern-1 "ClassLoader")                     ClassLoader
            (Symbol'intern-1 "Compiler")                        Compiler
            (Symbol'intern-1 "Double")                          Double
            (Symbol'intern-1 "Enum")                            Enum
            (Symbol'intern-1 "Float")                           Float
            (Symbol'intern-1 "InheritableThreadLocal")          InheritableThreadLocal
            (Symbol'intern-1 "Integer")                         Integer
            (Symbol'intern-1 "Long")                            Long
            (Symbol'intern-1 "Math")                            Math
            (Symbol'intern-1 "Number")                          Number
            (Symbol'intern-1 "Object")                          Object
            (Symbol'intern-1 "Package")                         Package
            (Symbol'intern-1 "Process")                         Process
            (Symbol'intern-1 "ProcessBuilder")                  ProcessBuilder
            (Symbol'intern-1 "Runtime")                         Runtime
            (Symbol'intern-1 "RuntimePermission")               RuntimePermission
            (Symbol'intern-1 "SecurityManager")                 SecurityManager
            (Symbol'intern-1 "Short")                           Short
            (Symbol'intern-1 "StackTraceElement")               StackTraceElement
            (Symbol'intern-1 "StrictMath")                      StrictMath
            (Symbol'intern-1 "String")                          String
            (Symbol'intern-1 "StringBuffer")                    StringBuffer
            (Symbol'intern-1 "StringBuilder")                   StringBuilder
            (Symbol'intern-1 "System")                          System
            (Symbol'intern-1 "Thread")                          Thread
            (Symbol'intern-1 "ThreadGroup")                     ThreadGroup
            (Symbol'intern-1 "ThreadLocal")                     ThreadLocal
            (Symbol'intern-1 "Throwable")                       Throwable
            (Symbol'intern-1 "Void")                            Void
            (Symbol'intern-1 "Appendable")                      Appendable
            (Symbol'intern-1 "CharSequence")                    CharSequence
            (Symbol'intern-1 "Cloneable")                       Cloneable
            (Symbol'intern-1 "Comparable")                      Comparable
            (Symbol'intern-1 "Iterable")                        Iterable
            (Symbol'intern-1 "Readable")                        Readable
            (Symbol'intern-1 "Runnable")                        Runnable
            (Symbol'intern-1 "Callable")                        Callable
            (Symbol'intern-1 "BigInteger")                      BigInteger
            (Symbol'intern-1 "BigDecimal")                      BigDecimal
            (Symbol'intern-1 "ArithmeticException")             ArithmeticException
            (Symbol'intern-1 "ArrayIndexOutOfBoundsException")  ArrayIndexOutOfBoundsException
            (Symbol'intern-1 "ArrayStoreException")             ArrayStoreException
            (Symbol'intern-1 "ClassCastException")              ClassCastException
            (Symbol'intern-1 "ClassNotFoundException")          ClassNotFoundException
            (Symbol'intern-1 "CloneNotSupportedException")      CloneNotSupportedException
            (Symbol'intern-1 "EnumConstantNotPresentException") EnumConstantNotPresentException
            (Symbol'intern-1 "Exception")                       Exception
            (Symbol'intern-1 "IllegalAccessException")          IllegalAccessException
            (Symbol'intern-1 "IllegalArgumentException")        IllegalArgumentException
            (Symbol'intern-1 "IllegalMonitorStateException")    IllegalMonitorStateException
            (Symbol'intern-1 "IllegalStateException")           IllegalStateException
            (Symbol'intern-1 "IllegalThreadStateException")     IllegalThreadStateException
            (Symbol'intern-1 "IndexOutOfBoundsException")       IndexOutOfBoundsException
            (Symbol'intern-1 "InstantiationException")          InstantiationException
            (Symbol'intern-1 "InterruptedException")            InterruptedException
            (Symbol'intern-1 "NegativeArraySizeException")      NegativeArraySizeException
            (Symbol'intern-1 "NoSuchFieldException")            NoSuchFieldException
            (Symbol'intern-1 "NoSuchMethodException")           NoSuchMethodException
            (Symbol'intern-1 "NullPointerException")            NullPointerException
            (Symbol'intern-1 "NumberFormatException")           NumberFormatException
            (Symbol'intern-1 "RuntimeException")                RuntimeException
            (Symbol'intern-1 "SecurityException")               SecurityException
            (Symbol'intern-1 "StringIndexOutOfBoundsException") StringIndexOutOfBoundsException
            (Symbol'intern-1 "TypeNotPresentException")         TypeNotPresentException
            (Symbol'intern-1 "UnsupportedOperationException")   UnsupportedOperationException
            (Symbol'intern-1 "AbstractMethodError")             AbstractMethodError
            (Symbol'intern-1 "AssertionError")                  AssertionError
            (Symbol'intern-1 "ClassCircularityError")           ClassCircularityError
            (Symbol'intern-1 "ClassFormatError")                ClassFormatError
            (Symbol'intern-1 "Error")                           Error
            (Symbol'intern-1 "ExceptionInInitializerError")     ExceptionInInitializerError
            (Symbol'intern-1 "IllegalAccessError")              IllegalAccessError
            (Symbol'intern-1 "IncompatibleClassChangeError")    IncompatibleClassChangeError
            (Symbol'intern-1 "InstantiationError")              InstantiationError
            (Symbol'intern-1 "InternalError")                   InternalError
            (Symbol'intern-1 "LinkageError")                    LinkageError
            (Symbol'intern-1 "NoClassDefFoundError")            NoClassDefFoundError
            (Symbol'intern-1 "NoSuchFieldError")                NoSuchFieldError
            (Symbol'intern-1 "NoSuchMethodError")               NoSuchMethodError
            (Symbol'intern-1 "OutOfMemoryError")                OutOfMemoryError
            (Symbol'intern-1 "StackOverflowError")              StackOverflowError
            (Symbol'intern-1 "ThreadDeath")                     ThreadDeath
            (Symbol'intern-1 "UnknownError")                    UnknownError
            (Symbol'intern-1 "UnsatisfiedLinkError")            UnsatisfiedLinkError
            (Symbol'intern-1 "UnsupportedClassVersionError")    UnsupportedClassVersionError
            (Symbol'intern-1 "VerifyError")                     VerifyError
            (Symbol'intern-1 "VirtualMachineError")             VirtualMachineError
            (Symbol'intern-1 "Thread$UncaughtExceptionHandler") Thread$UncaughtExceptionHandler
            (Symbol'intern-1 "Thread$State")                    Thread$State
            (Symbol'intern-1 "Deprecated")                      Deprecated
            (Symbol'intern-1 "Override")                        Override
            (Symbol'intern-1 "SuppressWarnings")                SuppressWarnings
        ])
    )))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (def #_"Charset" RT'UTF8 (Charset/forName "UTF-8"))

    (defn #_"Object" RT'readTrueFalseUnknown [#_"String" ___s]
        (cond (.equals ___s, "true")
            (do
                (§ return Boolean/TRUE)
            )
            (.equals ___s, "false")
            (do
                (§ return Boolean/FALSE)
            )
        )
        (Keyword'intern-2 nil, "unknown")
    )

    (def #_"Namespace" RT'CLOIURE_NS (ß Namespace'findOrCreate(Symbol'intern-1("cloiure.core"))))
    (def #_"Var" RT'OUT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*out*"), (OutputStreamWriter. System/out)).setDynamic()))
    (def #_"Var" RT'IN (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*in*"), LineNumberingPushbackReader'new-1((InputStreamReader. System/in))).setDynamic()))
    (def #_"Var" RT'ERR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*err*"), (PrintWriter. (OutputStreamWriter. System/err), true)).setDynamic()))
    (§ def #_"Keyword" RT'TAG_KEY (Keyword'intern-2 nil, "tag"))
    (§ def #_"Keyword" RT'CONST_KEY (Keyword'intern-2 nil, "const"))
    (def #_"Var" RT'AGENT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*agent*"), nil).setDynamic()))
    (def #_"Object" RT'readeval (ß readTrueFalseUnknown(System/getProperty("cloiure.read.eval", "true"))))
    (def #_"Var" RT'READEVAL (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*read-eval*"), readeval).setDynamic()))
    (def #_"Var" RT'DATA_READERS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*data-readers*"), RT'map()).setDynamic()))
    (def #_"Var" RT'DEFAULT_DATA_READER_FN (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*default-data-reader-fn*"), RT'map()).setDynamic()))
    (def #_"Var" RT'DEFAULT_DATA_READERS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("default-data-readers"), RT'map())))
    (def #_"Var" RT'SUPPRESS_READ (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*suppress-read*"), nil).setDynamic()))
    (def #_"Var" RT'ASSERT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*assert*"), RT'T).setDynamic()))
    (def #_"Var" RT'MATH_CONTEXT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*math-context*"), nil).setDynamic()))
    (§ def #_"Keyword" RT'LINE_KEY (Keyword'intern-2 nil, "line"))
    (§ def #_"Keyword" RT'COLUMN_KEY (Keyword'intern-2 nil, "column"))
    (§ def #_"Keyword" RT'FILE_KEY (Keyword'intern-2 nil, "file"))
    (§ def #_"Keyword" RT'DECLARED_KEY (Keyword'intern-2 nil, "declared"))
    (§ def #_"Keyword" RT'DOC_KEY (Keyword'intern-2 nil, "doc"))
    (def #_"Var" RT'USE_CONTEXT_CLASSLOADER (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*use-context-classloader*"), RT'T).setDynamic()))
    ;; boolean
    (def #_"Var" RT'UNCHECKED_MATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*unchecked-math*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Symbol" RT'LOAD_FILE (Symbol'intern-1 "load-file"))
    (§ def #_"Symbol" RT'IN_NAMESPACE (Symbol'intern-1 "in-ns"))
    (§ def #_"Symbol" RT'NAMESPACE (Symbol'intern-1 "ns"))
    (§ def #_"Symbol" RT'IDENTICAL (Symbol'intern-1 "identical?"))
    (def #_"Var" RT'CMD_LINE_ARGS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*command-line-args*"), nil).setDynamic()))
    ;; symbol
    (def #_"Var" RT'CURRENT_NS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*ns*"), RT'CLOIURE_NS).setDynamic()))

    (def #_"Var" RT'FLUSH_ON_NEWLINE (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*flush-on-newline*"), RT'T).setDynamic()))
    (def #_"Var" RT'PRINT_META (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-meta*"), RT'F).setDynamic()))
    (def #_"Var" RT'PRINT_READABLY (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-readably*"), RT'T).setDynamic()))
    (def #_"Var" RT'PRINT_DUP (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-dup*"), RT'F).setDynamic()))
    (def #_"Var" RT'WARN_ON_REFLECTION (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*warn-on-reflection*"), RT'F).setDynamic()))
    (def #_"Var" RT'ALLOW_UNRESOLVED_VARS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*allow-unresolved-vars*"), RT'F).setDynamic()))
    (def #_"Var" RT'READER_RESOLVER (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*reader-resolver*"), nil).setDynamic()))

    (def #_"Var" RT'IN_NS_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("in-ns"), RT'F)))
    (def #_"Var" RT'NS_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("ns"), RT'F)))
    (def #_"Var" RT'FN_LOADER_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*fn-loader*"), nil).setDynamic()))
    (def #_"Var" RT'PRINT_INITIALIZED (ß Var'intern-2n(RT'CLOIURE_NS, Symbol'intern-1("print-initialized"))))
    (def #_"Var" RT'PR_ON (ß Var'intern-2n(RT'CLOIURE_NS, Symbol'intern-1("pr-on"))))

    (def #_"IFn" RT'inNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (cast' Symbol ___arg1)]
                    (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsname)]
                        (.set RT'CURRENT_NS, ___ns)
                        ___ns
                    )
                )
            )
        )
    )

    (def #_"IFn" RT'bootNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" _____form, #_"Object" _____env, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (cast' Symbol ___arg1)]
                    (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsname)]
                        (.set RT'CURRENT_NS, ___ns)
                        ___ns
                    )
                )
            )
        )
    )

    (defn #_"List<String>" RT'processCommandLine [#_"String[]" ___args]
        (let [#_"List<String>" ___arglist (Arrays/asList ___args)]
            (let [#_"int" ___split (.indexOf ___arglist, "--")]
                (when (>= ___split 0)
                    (ß RT'CMD_LINE_ARGS.bindRoot(RT'seq(___arglist.subList(___split + 1, (§ alength ___args)))))
                    (§ return (.subList ___arglist, 0, ___split))
                )
                ___arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" ___w (cast Writer (.deref RT'ERR))]
            (if (instance? PrintWriter ___w)
                (do
                    (cast PrintWriter ___w)
                )
                (do
                    (§ unsure PrintWriter. ___w)
                )
            )
        )
    )

    (def #_"Object[]" RT'EMPTY_ARRAY (make-array Object 0))
    (§ def #_"Comparator" RT'DEFAULT_COMPARATOR (DefaultComparator'new))

    (def #_"AtomicInteger" RT'ID (AtomicInteger. 1))

    (defn #_"void" RT'addURL [#_"Object" ___url] #_(§ throws MalformedURLException)
        (let [#_"URL" ___u (if (instance? String ___url) (URL. (cast String ___url)) (cast URL ___url))]
            (let [#_"ClassLoader" ___ccl (ß Thread/currentThread().getContextClassLoader())]
                (if (§ instance? DynamicClassLoader ___ccl)
                    (do
                        (.addURL (cast' DynamicClassLoader ___ccl), ___u)
                    )
                    (do
                        (throw (IllegalAccessError. "Context classloader is not a DynamicClassLoader"))
                    )
                )
                nil
            )
        )
    )

    (def #_"boolean" RT'CHECK_SPEC_ASSERTS false #_"cloiure.spec.check-asserts")
    (def #_"boolean" RT'INSTRUMENT_MACROS true #_"cloiure.spec.skip-macros")
    #_volatile
    (def #_"boolean" RT'CHECK_SPECS false)

    (§ static
        (let [#_"Keyword" ___arglistskw (Keyword'intern-2 nil, "arglists")]
            (let [#_"Symbol" ___namesym (Symbol'intern-1 "name")]
                (ß RT'OUT.setTag(Symbol'intern-1("java.io.Writer")))
                (ß RT'CURRENT_NS.setTag(Symbol'intern-1("cloiure.lang.Namespace")))
                (ß RT'AGENT.setMeta(map(RT'DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß RT'AGENT.setTag(Symbol'intern-1("cloiure.lang.Agent")))
                (ß RT'MATH_CONTEXT.setTag(Symbol'intern-1("java.math.MathContext")))
                (let [#_"Var" ___nv (Var'intern-3 RT'CLOIURE_NS, RT'NAMESPACE, bootNamespace)]
                    (.setMacro ___nv)
                    (§ let [#_"Var" ___v]
                        (§ ass ___v (Var'intern-3 RT'CLOIURE_NS, RT'IN_NAMESPACE, inNamespace))
                        (ß ___v.setMeta(map(RT'DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", ___arglistskw, list(vector(___namesym)))))
                        (§ ass ___v (ß Var'intern-3(RT'CLOIURE_NS, RT'LOAD_FILE,
                                (§ reify AFn()
                                    #_method
                                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1]
                                        (try
                                            (Compiler'loadFile (cast String ___arg1))
                                            (catch IOException ___e
                                                (throw (Util'sneakyThrow ___e))
                                            )
                                        )
                                    )
                                )
                            ))
                        )
                        (ß ___v.setMeta(map(RT'DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", ___arglistskw, list(vector(___namesym)))))
                        (try
                            (doInit)
                            (catch Exception ___e
                                (throw (Util'sneakyThrow ___e))
                            )
                        )

                        (§ ass RT'CHECK_SPECS RT'INSTRUMENT_MACROS)
                    )
                )
            )
        )
    )

    (defn #_"Keyword" RT'keyword [#_"String" ___ns, #_"String" ___name]
        (Keyword'intern (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Var" RT'var-2 [#_"String" ___ns, #_"String" ___name]
        (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-2(nil, ___ns)), Symbol'intern-2(nil, ___name)))
    )

    (defn #_"Var" RT'var-3 [#_"String" ___ns, #_"String" ___name, #_"Object" ___init]
        (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-2(nil, ___ns)), Symbol'intern-2(nil, ___name), ___init))
    )

    (defn #_"void" RT'loadResourceScript-1 [#_"String" ___name] #_(§ throws IOException)
        (RT'loadResourceScript-2s ___name, true)
        nil
    )

    (defn #_"void" RT'maybeLoadResourceScript [#_"String" ___name] #_(§ throws IOException)
        (RT'loadResourceScript-2s ___name, false)
        nil
    )

    (defn #_"void" RT'loadResourceScript-2s [#_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (ß RT'loadResourceScript-3((§ class RT), ___name, ___failIfNotFound))
        nil
    )

    (defn #_"void" RT'loadResourceScript-2c [#_"Class" ___c, #_"String" ___name] #_(§ throws IOException)
        (RT'loadResourceScript-3 ___c, ___name, true)
        nil
    )

    (defn #_"void" RT'loadResourceScript-3 [#_"Class" ___c, #_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (let [#_"int" ___slash (.lastIndexOf ___name, \/)]
            (let [#_"String" ___file (if (>= ___slash 0) (ß ___name.substring(___slash + 1)) ___name)]
                (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___name))]
                    (cond (some? ___ins)
                        (do
                            (try
                                (Compiler'load-3 (InputStreamReader. ___ins, RT'UTF8), ___name, ___file)
                                (finally
                                    (.close ___ins)
                                )
                            )
                        )
                        ___failIfNotFound
                        (do
                            (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " ___name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (defn #_"long" RT'lastModified [#_"URL" ___url, #_"String" ___libfile] #_(§ throws IOException)
        (let [#_"URLConnection" ___connection (.openConnection ___url)]
            (try
                (if (ß (.getProtocol ___url).equals("jar"))
                    (do
                        (ß (cast JarURLConnection ___connection).getJarFile().getEntry(___libfile).getTime())
                    )
                    (do
                        (.getLastModified ___connection)
                    )
                )
                (finally
                    (let [#_"InputStream" ___ins (.getInputStream ___connection)]
                        (when (some? ___ins)
                            (.close ___ins)
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'compile [#_"String" ___cljfile] #_(§ throws IOException)
        (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___cljfile))]
            (if (some? ___ins)
                (do
                    (try
                        (ß Compiler'compile((InputStreamReader. ___ins, RT'UTF8), ___cljfile, ___cljfile.substring(1 + ___cljfile.lastIndexOf("/"))))
                        (finally
                            (.close ___ins)
                        )
                    )
                )
                (do
                    (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " ___cljfile)))
                )
            )
            nil
        )
    )

    (defn #_"void" RT'load-1 [#_"String" ___scriptbase] #_(§ throws IOException, ClassNotFoundException)
        (RT'load-2 ___scriptbase, true)
        nil
    )

    (defn #_"void" RT'load-2 [#_"String" ___scriptbase, #_"boolean" ___failIfNotFound] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"String" ___classfile (str ___scriptbase RT'LOADER_SUFFIX ".class")]
            (let [#_"String" ___cljfile (str ___scriptbase ".cli")]
                (let [#_"String" ___scriptfile ___cljfile]
                    (let [#_"URL" ___classURL (ß RT'getResource(baseLoader(), ___classfile))]
                        (let [#_"URL" ___cljURL (ß RT'getResource(baseLoader(), ___scriptfile))]
                            (when (nil? ___cljURL)
                                (§ ass ___scriptfile (str ___scriptbase ".clic"))
                                (§ ass ___cljURL (ß RT'getResource(baseLoader(), ___scriptfile)))
                            )
                            (let [#_"boolean" ___loaded false]
                                (when (or (and (some? ___classURL) (or (nil? ___cljURL) (< (RT'lastModified ___cljURL, ___scriptfile) (RT'lastModified ___classURL, ___classfile)))) (nil? ___classURL))
                                    (try
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (object-array [
                                                RT'CURRENT_NS         (.deref RT'CURRENT_NS)
                                                RT'WARN_ON_REFLECTION (.deref RT'WARN_ON_REFLECTION)
                                                RT'UNCHECKED_MATH     (.deref RT'UNCHECKED_MATH)
                                            ])
                                        )))
                                        (§ ass ___loaded (some? (RT'loadClassForName (str (ß ___scriptbase.replace(\/, \.)) RT'LOADER_SUFFIX))))
                                        (finally
                                            (Var'popThreadBindings)
                                        )
                                    )
                                )
                                (cond (and (not ___loaded) (some? ___cljURL))
                                    (do
                                        (if (ß RT'booleanCast-1o(Compiler'COMPILE_FILES.deref()))
                                            (do
                                                (RT'compile ___scriptfile)
                                            )
                                            (do
                                                (ß RT'loadResourceScript-2c((§ class RT), ___scriptfile))
                                            )
                                        )
                                    )
                                    (and (not ___loaded) ___failIfNotFound)
                                    (do
                                        (throw (FileNotFoundException. (String/format "Could not locate %s or %s on classpath.%s", (object-array [ ___classfile, ___cljfile, (if (.contains ___scriptbase, "_") " Please check that namespaces with dashes use underscores in the Cloiure file name." "") ]))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'doInit [] #_(§ throws ClassNotFoundException, IOException)
        (RT'load-1 "cloiure/core")

        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
            (object-array [
                RT'CURRENT_NS         (.deref RT'CURRENT_NS)
                RT'WARN_ON_REFLECTION (.deref RT'WARN_ON_REFLECTION)
                RT'UNCHECKED_MATH     (.deref RT'UNCHECKED_MATH)
            ])
        )))
        (try
            (let [#_"Symbol" ___USER (Symbol'intern-1 "user")]
                (let [#_"Symbol" ___CLOIURE (Symbol'intern-1 "cloiure.core")]
                    (let [#_"Var" ___in_ns (RT'var-2 "cloiure.core", "in-ns")]
                        (let [#_"Var" ___refer (RT'var-2 "cloiure.core", "refer")]
                            (.invoke ___in_ns, ___USER)
                            (.invoke ___refer, ___CLOIURE)
                            (RT'maybeLoadResourceScript "user.cli")

                            ;; start socket servers
                            (let [#_"Var" ___require (RT'var-2 "cloiure.core", "require")]
                                (let [#_"Symbol" ___SERVER (Symbol'intern-1 "cloiure.core.server")]
                                    (.invoke ___require, ___SERVER)
                                    (let [#_"Var" ___start_servers (RT'var-2 "cloiure.core.server", "start-servers")]
                                        (ß ___start_servers.invoke(System/getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
        nil
    )

    (defn #_"int" RT'nextID []
        (.getAndIncrement RT'ID)
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (defn #_"void" RT'loadLibrary [#_"String" ___libname]
        (System/loadLibrary ___libname)
        nil
    )

    (def- #_"int" RT'CHUNK_SIZE 32)

    (defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" ___iter]
        (when (.hasNext ___iter)
            (§ return (ß LazySeq'new-1(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
                            (let [#_"Object[]" ___arr (make-array Object RT'CHUNK_SIZE)]
                                (let [#_"int" ___n 0]
                                    (while (and (.hasNext ___iter) (< ___n RT'CHUNK_SIZE))
                                        (§ ass (§ aget ___arr ___n) (next ___iter))
                                        (§ ass ___n (inc ___n))
                                    )
                                    (ß ChunkedCons'new-2(ArrayChunk'new-3(___arr, 0, ___n), chunkIteratorSeq(___iter)))
                                )
                            )
                        )
                    )
                ))
            )
        )
        nil
    )

    (defn #_"ISeq" RT'seq [#_"Object" ___coll]
        (cond (§ instance? ASeq ___coll)
            (do
                (cast' ASeq ___coll)
            )
            (§ instance? LazySeq ___coll)
            (do
                (.seq (cast' LazySeq ___coll))
            )
            :else
            (do
                (RT'seqFrom ___coll)
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (defn #_"ISeq" RT'seqFrom [#_"Object" ___coll]
        (cond (§ instance? Seqable ___coll)
            (do
                (.seq (cast' Seqable ___coll))
            )
            (nil? ___coll)
            (do
                nil
            )
            (instance? Iterable ___coll)
            (do
                (ß chunkIteratorSeq((cast Iterable ___coll).iterator()))
            )
            (.isArray (.getClass ___coll))
            (do
                (ArraySeq'createFromObject ___coll)
            )
            (instance? CharSequence ___coll)
            (do
                (StringSeq'create (cast CharSequence ___coll))
            )
            (instance? Map ___coll)
            (do
                (RT'seq (.entrySet (cast Map ___coll)))
            )
            :else
            (do
                (throw (IllegalArgumentException. (str "Don't know how to create ISeq from: " (.getName (.getClass ___coll)))))
            )
        )
    )

    (defn #_"boolean" RT'canSeq [#_"Object" ___coll]
        (or (§ instance? ISeq ___coll)
            (§ instance? Seqable ___coll)
            (nil? ___coll)
            (instance? Iterable ___coll)
            (.isArray (.getClass ___coll))
            (instance? CharSequence ___coll)
            (instance? Map ___coll))
    )

    (defn #_"Iterator" RT'iter [#_"Object" ___coll]
        (cond (instance? Iterable ___coll)
            (do
                (.iterator (cast Iterable ___coll))
            )
            (nil? ___coll)
            (do
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_method
                    (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
            (instance? Map ___coll)
            (do
                (ß (cast Map ___coll).entrySet().iterator())
            )
            (instance? String ___coll)
            (do
                (let [#_"String" ___s (cast String ___coll)]
                    (§ reify Iterator()
                        (let [#_"int" ___i 0]
                            #_method
                            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                                (ß (___i < (.length ___s)))
                            )

                            #_method
                            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                                (let [_ (.charAt ___s, ___i)]
                                    (§ ass ___i (inc ___i))
                                    _
                                )
                            )

                            #_method
                            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                                (throw (UnsupportedOperationException.))
                            )
                        )
                    )
                )
            )
            (.isArray (.getClass ___coll))
            (do
                (ArrayIter'createFromObject ___coll)
            )
            :else
            (do
                (RT'iter (RT'seq ___coll))
            )
        )
    )

    (defn #_"Object" RT'seqOrElse [#_"Object" ___o]
        (when (some? (RT'seq ___o)) ___o)
    )

    (defn #_"ISeq" RT'keys [#_"Object" ___coll]
        (if (§ instance? IPersistentMap ___coll)
            (do
                (KeySeq'createFromMap (cast' IPersistentMap ___coll))
            )
            (do
                (KeySeq'create (RT'seq ___coll))
            )
        )
    )

    (defn #_"ISeq" RT'vals [#_"Object" ___coll]
        (if (§ instance? IPersistentMap ___coll)
            (do
                (ValSeq'createFromMap (cast' IPersistentMap ___coll))
            )
            (do
                (ValSeq'create (RT'seq ___coll))
            )
        )
    )

    (defn #_"IPersistentMap" RT'meta [#_"Object" ___x]
        (when (§ instance? IMeta ___x)
            (§ return (.meta (cast' IMeta ___x)))
        )
        nil
    )

    (defn #_"int" RT'count [#_"Object" ___o]
        (when (§ instance? Counted ___o)
            (§ return (.count (cast' Counted ___o)))
        )
        (ß countFrom(Util'ret1(___o, (§ ass ___o nil))))
    )

    (defn #_"int" RT'countFrom [#_"Object" ___o]
        (cond (nil? ___o)
            (do
                (§ return 0)
            )
            (§ instance? IPersistentCollection ___o)
            (do
                (let [#_"ISeq" ___s (RT'seq ___o)]
                    (§ ass ___o nil)
                    (let [#_"int" ___i 0]
                        (loop-when-recur [___s ___s] (some? ___s) [(next ___s)]
                            (when (§ instance? Counted ___s)
                                (§ return (ß ___i + (count ___s)))
                            )
                            (§ ass ___i (inc ___i))
                        )
                        (§ return ___i)
                    )
                )
            )
            (instance? CharSequence ___o)
            (do
                (§ return (.length (cast CharSequence ___o)))
            )
            (instance? Collection ___o)
            (do
                (§ return (.size (cast Collection ___o)))
            )
            (instance? Map ___o)
            (do
                (§ return (.size (cast Map ___o)))
            )
            (instance? Map$Entry ___o)
            (do
                (§ return 2)
            )
            (.isArray (.getClass ___o))
            (do
                (§ return (Array/getLength ___o))
            )
        )

        (throw (UnsupportedOperationException. (str "count not supported on this type: " (.getSimpleName (.getClass ___o)))))
    )

    (defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" ___coll, #_"Object" ___x]
        (when (nil? ___coll)
            (§ return (PersistentList'new-1 ___x))
        )
        (.cons ___coll, ___x)
    )

    (defn #_"ISeq" RT'cons [#_"Object" ___x, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                (PersistentList'new-1 ___x)
            )
            (§ instance? ISeq ___coll)
            (do
                (ß Cons'new-2(___x, (cast' ISeq ___coll)))
            )
            :else
            (do
                (ß Cons'new-2(___x, (RT'seq ___coll)))
            )
        )
    )

    (defn #_"Object" RT'first [#_"Object" ___x]
        (when (§ instance? ISeq ___x)
            (§ return (.first (cast' ISeq ___x)))
        )
        (let [#_"ISeq" ___seq (RT'seq ___x)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (first ___seq)
        )
    )

    (defn #_"Object" RT'second [#_"Object" ___x]
        (RT'first (RT'next ___x))
    )

    (defn #_"Object" RT'third [#_"Object" ___x]
        (RT'first (RT'next (RT'next ___x)))
    )

    (defn #_"Object" RT'fourth [#_"Object" ___x]
        (RT'first (RT'next (RT'next (RT'next ___x))))
    )

    (defn #_"ISeq" RT'next [#_"Object" ___x]
        (when (§ instance? ISeq ___x)
            (§ return (.next (cast' ISeq ___x)))
        )
        (let [#_"ISeq" ___seq (RT'seq ___x)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (next ___seq)
        )
    )

    (defn #_"ISeq" RT'more [#_"Object" ___x]
        (when (§ instance? ISeq ___x)
            (§ return (.more (cast' ISeq ___x)))
        )
        (let [#_"ISeq" ___seq (RT'seq ___x)]
            (when (nil? ___seq)
                (§ return PersistentList'EMPTY)
            )
            (.more ___seq)
        )
    )

    (defn #_"Object" RT'peek [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (.peek (cast' IPersistentStack ___x))
    )

    (defn #_"Object" RT'pop [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (.pop (cast' IPersistentStack ___x))
    )

    (defn #_"Object" RT'get-2 [#_"Object" ___coll, #_"Object" ___key]
        (when (§ instance? ILookup ___coll)
            (§ return (.valAt (cast' ILookup ___coll), ___key))
        )
        (RT'getFrom-2 ___coll, ___key)
    )

    (defn #_"Object" RT'getFrom-2 [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (instance? Map ___coll)
            (do
                (let [#_"Map" ___m (cast Map ___coll)]
                    (§ return (.get ___m, ___key))
                )
            )
            (§ instance? IPersistentSet ___coll)
            (do
                (let [#_"IPersistentSet" ___set (cast' IPersistentSet ___coll)]
                    (§ return (.get ___set, ___key))
                )
            )
            (and (instance? Number ___key) (or (instance? String ___coll) (.isArray (.getClass ___coll))))
            (do
                (let [#_"int" ___n (.intValue (cast Number ___key))]
                    (when (and (<= 0 ___n) (< ___n (RT'count ___coll)))
                        (§ return (RT'nth ___coll, ___n))
                    )
                    (§ return nil)
                )
            )
            (§ instance? ITransientSet ___coll)
            (do
                (let [#_"ITransientSet" ___set (cast' ITransientSet ___coll)]
                    (§ return (.get ___set, ___key))
                )
            )
        )

        nil
    )

    (defn #_"Object" RT'get-3 [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (when (§ instance? ILookup ___coll)
            (§ return (.valAt (cast' ILookup ___coll), ___key, ___notFound))
        )
        (RT'getFrom-3 ___coll, ___key, ___notFound)
    )

    (defn #_"Object" RT'getFrom-3 [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                (§ return ___notFound)
            )
            (instance? Map ___coll)
            (do
                (let [#_"Map" ___m (cast Map ___coll)]
                    (when (.containsKey ___m, ___key)
                        (§ return (.get ___m, ___key))
                    )
                    (§ return ___notFound)
                )
            )
            (§ instance? IPersistentSet ___coll)
            (do
                (let [#_"IPersistentSet" ___set (cast' IPersistentSet ___coll)]
                    (when (.contains ___set, ___key)
                        (§ return (.get ___set, ___key))
                    )
                    (§ return ___notFound)
                )
            )
            (and (instance? Number ___key) (or (instance? String ___coll) (.isArray (.getClass ___coll))))
            (do
                (let [#_"int" ___n (.intValue (cast Number ___key))]
                    (§ return (if (and (<= 0 ___n) (< ___n (RT'count ___coll))) (RT'nth ___coll, ___n) ___notFound))
                )
            )
            (§ instance? ITransientSet ___coll)
            (do
                (let [#_"ITransientSet" ___set (cast' ITransientSet ___coll)]
                    (when (.contains ___set, ___key)
                        (§ return (.get ___set, ___key))
                    )
                    (§ return ___notFound)
                )
            )
        )
        ___notFound
    )

    (defn #_"Associative" RT'assoc [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___coll)
            (§ return (PersistentArrayMap'new-1 (object-array [ ___key, ___val ])))
        )
        (.assoc (cast' Associative ___coll), ___key, ___val)
    )

    (defn #_"Object" RT'contains [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return RT'F)
            )
            (§ instance? Associative ___coll)
            (do
                (§ return (if (.containsKey (cast' Associative ___coll), ___key) RT'T RT'F))
            )
            (§ instance? IPersistentSet ___coll)
            (do
                (§ return (if (.contains (cast' IPersistentSet ___coll), ___key) RT'T RT'F))
            )
            (instance? Map ___coll)
            (do
                (let [#_"Map" ___m (cast Map ___coll)]
                    (§ return (if (.containsKey ___m, ___key) RT'T RT'F))
                )
            )
            (instance? Set ___coll)
            (do
                (let [#_"Set" ___s (cast Set ___coll)]
                    (§ return (if (.contains ___s, ___key) RT'T RT'F))
                )
            )
            (and (instance? Number ___key) (or (instance? String ___coll) (.isArray (.getClass ___coll))))
            (do
                (let [#_"int" ___n (.intValue (cast Number ___key))]
                    (§ return (if (and (<= 0 ___n) (< ___n (RT'count ___coll))) RT'T RT'F))
                )
            )
            (§ instance? ITransientSet ___coll)
            (do
                (§ return (if (.contains (cast' ITransientSet ___coll), ___key) RT'T RT'F))
            )
            (§ instance? ITransientAssociative2 ___coll)
            (do
                (§ return (if (.containsKey (cast' ITransientAssociative2 ___coll), ___key) RT'T RT'F))
            )
        )
        (throw (IllegalArgumentException. (str "contains? not supported on type: " (.getName (.getClass ___coll)))))
    )

    (defn #_"Object" RT'find [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (§ instance? Associative ___coll)
            (do
                (§ return (.entryAt (cast' Associative ___coll), ___key))
            )
            (instance? Map ___coll)
            (do
                (let [#_"Map" ___m (cast Map ___coll)]
                    (when (.containsKey ___m, ___key)
                        (§ return (ß MapEntry'create(___key, ___m.get(___key))))
                    )
                    (§ return nil)
                )
            )
            (§ instance? ITransientAssociative2 ___coll)
            (do
                (§ return (.entryAt (cast' ITransientAssociative2 ___coll), ___key))
            )
        )
        (throw (IllegalArgumentException. (str "find not supported on type: " (.getName (.getClass ___coll)))))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (defn #_"ISeq" RT'findKey [#_"Keyword" ___key, #_"ISeq" ___keyvals]
        (while (some? ___keyvals)
            (let [#_"ISeq" ___r (next ___keyvals)]
                (when (nil? ___r)
                    (throw (Util'runtimeException-1 "Malformed keyword argslist"))
                )
                (when (ß (first ___keyvals) == ___key)
                    (§ return ___r)
                )
                (§ ass ___keyvals (next ___r))
            )
        )
        nil
    )

    (defn #_"Object" RT'dissoc [#_"Object" ___coll, #_"Object" ___key]
        (when (nil? ___coll)
            (§ return nil)
        )
        (.without (cast' IPersistentMap ___coll), ___key)
    )

    (defn #_"Object" RT'nth-2 [#_"Object" ___coll, #_"int" ___n]
        (when (§ instance? Indexed ___coll)
            (§ return (.nth (cast' Indexed ___coll), ___n))
        )
        (ß RT'nthFrom-2(Util'ret1(___coll, (§ ass ___coll nil)), ___n))
    )

    (defn #_"Object" RT'nthFrom-2 [#_"Object" ___coll, #_"int" ___n]
        (cond (nil? ___coll)
            (do
                nil
            )
            (instance? CharSequence ___coll)
            (do
                (ß Character/valueOf((cast CharSequence ___coll).charAt(___n)))
            )
            (.isArray (.getClass ___coll))
            (do
                (ß Reflector'prepRet((.getClass ___coll).getComponentType(), Array/get(___coll, ___n)))
            )
            (instance? RandomAccess ___coll)
            (do
                (.get (cast List ___coll), ___n)
            )
            (instance? Matcher ___coll)
            (do
                (.group (cast Matcher ___coll), ___n)
            )
            (instance? Map$Entry ___coll)
            (do
                (let [#_"Map$Entry" ___e (cast Map$Entry ___coll)]
                    (cond (zero? ___n)
                        (do
                            (§ return (.getKey ___e))
                        )
                        (= ___n 1)
                        (do
                            (§ return (.getValue ___e))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            (§ instance? Sequential ___coll)
            (do
                (let [#_"ISeq" ___seq (RT'seq ___coll)]
                    (§ ass ___coll nil)
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (and (<= ___i ___n) (some? ___seq)) [(inc ___i) (next ___seq)]
                        (when (= ___i ___n)
                            (§ return (first ___seq))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            :else
            (do
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass ___coll)))))
            )
        )
    )

    (defn #_"Object" RT'nth-3 [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (when (§ instance? Indexed ___coll)
            (let [#_"Indexed" ___v (cast' Indexed ___coll)]
                (§ return (.nth ___v, ___n, ___notFound))
            )
        )
        (RT'nthFrom-3 ___coll, ___n, ___notFound)
    )

    (defn #_"Object" RT'nthFrom-3 [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                ___notFound
            )
            (< ___n 0)
            (do
                ___notFound
            )
            (instance? CharSequence ___coll)
            (do
                (let [#_"CharSequence" ___s (cast CharSequence ___coll)]
                    (when (ß ___n < (.length ___s))
                        (§ return (ß Character/valueOf(___s.charAt(___n))))
                    )
                    ___notFound
                )
            )
            (.isArray (.getClass ___coll))
            (do
                (when (ß ___n < Array/getLength(___coll))
                    (§ return (ß Reflector'prepRet((.getClass ___coll).getComponentType(), Array/get(___coll, ___n))))
                )
                ___notFound
            )
            (instance? RandomAccess ___coll)
            (do
                (let [#_"List" ___list (cast List ___coll)]
                    (when (ß ___n < (.size ___list))
                        (§ return (.get ___list, ___n))
                    )
                    ___notFound
                )
            )
            (instance? Matcher ___coll)
            (do
                (let [#_"Matcher" ___m (cast Matcher ___coll)]
                    (when (ß ___n < (.groupCount ___m))
                        (§ return (.group ___m, ___n))
                    )
                    ___notFound
                )
            )
            (instance? Map$Entry ___coll)
            (do
                (let [#_"Map$Entry" ___e (cast Map$Entry ___coll)]
                    (cond (zero? ___n)
                        (do
                            (§ return (.getKey ___e))
                        )
                        (= ___n 1)
                        (do
                            (§ return (.getValue ___e))
                        )
                    )
                    ___notFound
                )
            )
            (§ instance? Sequential ___coll)
            (do
                (let [#_"ISeq" ___seq (RT'seq ___coll)]
                    (§ ass ___coll nil)
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (and (<= ___i ___n) (some? ___seq)) [(inc ___i) (next ___seq)]
                        (when (= ___i ___n)
                            (§ return (first ___seq))
                        )
                    )
                    ___notFound
                )
            )
            :else
            (do
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass ___coll)))))
            )
        )
    )

    (defn #_"Object" RT'assocN [#_"int" ___n, #_"Object" ___val, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                nil
            )
            (§ instance? IPersistentVector ___coll)
            (do
                (.assocN (cast' IPersistentVector ___coll), ___n, ___val)
            )
            (§ instance? Object[] ___coll)
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" ___array (ß ((Object[]) ___coll))]
                    (§ ass (§ aget ___array ___n) ___val)
                    ___array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (defn #_"boolean" RT'hasTag [#_"Object" ___o, #_"Object" ___tag]
        (ß Util'equals(___tag, RT'get-2(RT'meta(___o), RT'TAG_KEY)))
    )

    (defn #_"Object" RT'box-1o [#_"Object" ___x]
        ___x
    )

    (defn #_"Character" RT'box-1c [#_"char" ___x]
        (Character/valueOf ___x)
    )

    (defn #_"Object" RT'box-1z [#_"boolean" ___x]
        (if ___x RT'T RT'F)
    )

    (defn #_"Object" RT'box-1Z [#_"Boolean" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1s [#_"short" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1i [#_"int" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1l [#_"long" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1f [#_"float" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1d [#_"double" ___x]
        ___x
    )

    (defn #_"char" RT'charCast-1o [#_"Object" ___x]
        (when (instance? Character ___x)
            (§ return (.charValue (cast Character ___x)))
        )
        (let [#_"long" ___n (.longValue (cast Number ___x))]
            (when (or (< ___n Character/MIN_VALUE) (< Character/MAX_VALUE ___n))
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            (ß (char) ___n)
        )
    )

    (defn #_"char" RT'charCast-1b [#_"byte" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1s [#_"short" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"char" RT'charCast-1i [#_"int" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1l [#_"long" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1f [#_"float" ___x]
        (when (<= Character/MIN_VALUE ___x Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
    )

    (defn #_"char" RT'charCast-1d [#_"double" ___x]
        (when (<= Character/MIN_VALUE ___x Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
    )

    (defn #_"boolean" RT'booleanCast-1o [#_"Object" ___x]
        (when (instance? Boolean ___x)
            (§ return (.booleanValue (cast Boolean ___x)))
        )
        (some? ___x)
    )

    (defn #_"boolean" RT'booleanCast-1b [#_"boolean" ___x]
        ___x
    )

    (defn #_"byte" RT'byteCast-1o [#_"Object" ___x]
        (when (instance? Byte ___x)
            (§ return (.byteValue (cast Byte ___x)))
        )
        (let [#_"long" ___n (RT'longCast-1o ___x)]
            (when (or (< ___n Byte/MIN_VALUE) (< Byte/MAX_VALUE ___n))
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            (ß (byte) ___n)
        )
    )

    (defn #_"byte" RT'byteCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"byte" RT'byteCast-1s [#_"short" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1i [#_"int" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1l [#_"long" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1f [#_"float" ___x]
        (when (<= Byte/MIN_VALUE ___x Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
    )

    (defn #_"byte" RT'byteCast-1d [#_"double" ___x]
        (when (<= Byte/MIN_VALUE ___x Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
    )

    (defn #_"short" RT'shortCast-1o [#_"Object" ___x]
        (when (instance? Short ___x)
            (§ return (.shortValue (cast Short ___x)))
        )
        (let [#_"long" ___n (RT'longCast-1o ___x)]
            (when (or (< ___n Short/MIN_VALUE) (< Short/MAX_VALUE ___n))
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            (ß (short) ___n)
        )
    )

    (defn #_"short" RT'shortCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"short" RT'shortCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"short" RT'shortCast-1i [#_"int" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            ___i
        )
    )

    (defn #_"short" RT'shortCast-1l [#_"long" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            ___i
        )
    )

    (defn #_"short" RT'shortCast-1f [#_"float" ___x]
        (when (<= Short/MIN_VALUE ___x Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
    )

    (defn #_"short" RT'shortCast-1d [#_"double" ___x]
        (when (<= Short/MIN_VALUE ___x Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
    )

    (defn #_"int" RT'intCast-1o [#_"Object" ___x]
        (when (instance? Integer ___x)
            (§ return (.intValue (cast Integer ___x)))
        )
        (when (instance? Number ___x)
            (let [#_"long" ___n (RT'longCast-1o ___x)]
                (§ return (intCast ___n))
            )
        )
        (.charValue (cast Character ___x))
    )

    (defn #_"int" RT'intCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1f [#_"float" ___x]
        (when (or (< ___x Integer/MIN_VALUE) (< Integer/MAX_VALUE ___x))
            (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
        )
        (ß (int) ___x)
    )

    (defn #_"int" RT'intCast-1l [#_"long" ___x]
        (let [#_"int" ___i (ß (int) ___x)]
            (when (not= ___i ___x)
                (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
            )
            ___i
        )
    )

    (defn #_"int" RT'intCast-1d [#_"double" ___x]
        (when (or (< ___x Integer/MIN_VALUE) (< Integer/MAX_VALUE ___x))
            (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
        )
        (ß (int) ___x)
    )

    (defn #_"long" RT'longCast-1o [#_"Object" ___x]
        (cond (or (instance? Integer ___x) (instance? Long ___x))
            (do
                (.longValue (cast Number ___x))
            )
            (§ instance? BigInt ___x)
            (do
                (let [#_"BigInt" ___bi (cast' BigInt ___x)]
                    (if (ß (nil? (:bipart ___bi)))
                        (do
                            (:lpart ___bi)
                        )
                        (do
                            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
                        )
                    )
                )
            )
            (instance? BigInteger ___x)
            (do
                (let [#_"BigInteger" ___bi (cast BigInteger ___x)]
                    (if (ß (.bitLength ___bi) < 64)
                        (do
                            (.longValue ___bi)
                        )
                        (do
                            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
                        )
                    )
                )
            )
            (or (instance? Byte ___x) (instance? Short ___x))
            (do
                (.longValue (cast Number ___x))
            )
            (§ instance? Ratio ___x)
            (do
                (ß RT'longCast-1o((cast' Ratio ___x).bigIntegerValue()))
            )
            (instance? Character ___x)
            (do
                (ß RT'longCast-1l((cast Character ___x).charValue()))
            )
            :else
            (do
                (ß RT'longCast-1d((cast Number ___x).doubleValue()))
            )
        )
    )

    (defn #_"long" RT'longCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1f [#_"float" ___x]
        (when (or (< ___x Long/MIN_VALUE) (< Long/MAX_VALUE ___x))
            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
        )
        (ß (long) ___x)
    )

    (defn #_"long" RT'longCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1d [#_"double" ___x]
        (when (or (< ___x Long/MIN_VALUE) (< Long/MAX_VALUE ___x))
            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
        )
        (ß (long) ___x)
    )

    (defn #_"float" RT'floatCast-1o [#_"Object" ___x]
        (when (instance? Float ___x)
            (§ return (.floatValue (cast Float ___x)))
        )
        (let [#_"double" ___n (.doubleValue (cast Number ___x))]
            (when (or (ß ___n < (- Float/MAX_VALUE)) (ß ___n > Float/MAX_VALUE))
                (throw (IllegalArgumentException. (str "Value out of range for float: " ___x)))
            )
            (ß (float) ___n)
        )
    )

    (defn #_"float" RT'floatCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1d [#_"double" ___x]
        (when (or (ß ___x < (- Float/MAX_VALUE)) (ß ___x > Float/MAX_VALUE))
            (throw (IllegalArgumentException. (str "Value out of range for float: " ___x)))
        )
        (ß (float) ___x)
    )

    (defn #_"double" RT'doubleCast-1o [#_"Object" ___x]
        (.doubleValue (cast Number ___x))
    )

    (defn #_"double" RT'doubleCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1d [#_"double" ___x]
        ___x
    )

    (defn #_"byte" RT'uncheckedByteCast-1o [#_"Object" ___x]
        (.byteValue (cast Number ___x))
    )

    (defn #_"byte" RT'uncheckedByteCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"byte" RT'uncheckedByteCast-1s [#_"short" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1i [#_"int" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1l [#_"long" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1f [#_"float" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1d [#_"double" ___x]
        (ß (byte) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1o [#_"Object" ___x]
        (.shortValue (cast Number ___x))
    )

    (defn #_"short" RT'uncheckedShortCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"short" RT'uncheckedShortCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"short" RT'uncheckedShortCast-1i [#_"int" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1l [#_"long" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1f [#_"float" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1d [#_"double" ___x]
        (ß (short) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1o [#_"Object" ___x]
        (when (instance? Character ___x)
            (§ return (.charValue (cast Character ___x)))
        )
        (ß (char) (cast Number ___x).longValue())
    )

    (defn #_"char" RT'uncheckedCharCast-1b [#_"byte" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1s [#_"short" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"char" RT'uncheckedCharCast-1i [#_"int" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1l [#_"long" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1f [#_"float" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1d [#_"double" ___x]
        (ß (char) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1o [#_"Object" ___x]
        (when (instance? Number ___x)
            (§ return (.intValue (cast Number ___x)))
        )
        (.charValue (cast Character ___x))
    )

    (defn #_"int" RT'uncheckedIntCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1l [#_"long" ___x]
        (ß (int) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1f [#_"float" ___x]
        (ß (int) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1d [#_"double" ___x]
        (ß (int) ___x)
    )

    (defn #_"long" RT'uncheckedLongCast-1o [#_"Object" ___x]
        (.longValue (cast Number ___x))
    )

    (defn #_"long" RT'uncheckedLongCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1f [#_"float" ___x]
        (ß (long) ___x)
    )

    (defn #_"long" RT'uncheckedLongCast-1d [#_"double" ___x]
        (ß (long) ___x)
    )

    (defn #_"float" RT'uncheckedFloatCast-1o [#_"Object" ___x]
        (.floatValue (cast Number ___x))
    )

    (defn #_"float" RT'uncheckedFloatCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1d [#_"double" ___x]
        (ß (float) ___x)
    )

    (defn #_"double" RT'uncheckedDoubleCast-1o [#_"Object" ___x]
        (.doubleValue (cast Number ___x))
    )

    (defn #_"double" RT'uncheckedDoubleCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1d [#_"double" ___x]
        ___x
    )

    (defn #_"IPersistentMap" RT'map [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return PersistentArrayMap'EMPTY)
            )
            (<= (§ alength ___init) PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap'createWithCheck ___init))
            )
        )
        (PersistentHashMap'createWithCheck-1a ___init)
    )

    (defn #_"IPersistentMap" RT'mapUniqueKeys [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return PersistentArrayMap'EMPTY)
            )
            (<= (§ alength ___init) PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap'new-1 ___init))
            )
        )
        (PersistentHashMap'create-1a ___init)
    )

    (defn #_"IPersistentSet" RT'set [#_"Object..." ___init]
        (PersistentHashSet'createWithCheck-1a ___init)
    )

    (defn #_"IPersistentVector" RT'vector [#_"Object..." ___init]
        (LazilyPersistentVector'createOwning ___init)
    )

    (defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (when-not (<= 0 ___start ___end (count ___v))
            (throw (IndexOutOfBoundsException.))
        )
        (when (= ___start ___end)
            (§ return PersistentVector'EMPTY)
        )
        (SubVector'new nil, ___v, ___start, ___end)
    )

    (defn #_"ISeq" RT'list-0 []
        nil
    )

    (defn #_"ISeq" RT'list-1 [#_"Object" ___arg1]
        (PersistentList'new-1 ___arg1)
    )

    (defn #_"ISeq" RT'list-2 [#_"Object" ___arg1, #_"Object" ___arg2]
        (RT'listStar-3 ___arg1, ___arg2, nil)
    )

    (defn #_"ISeq" RT'list-3 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (RT'listStar-4 ___arg1, ___arg2, ___arg3, nil)
    )

    (defn #_"ISeq" RT'list-4 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (RT'listStar-5 ___arg1, ___arg2, ___arg3, ___arg4, nil)
    )

    (defn #_"ISeq" RT'list-5 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (RT'listStar-6 ___arg1, ___arg2, ___arg3, ___arg4, ___arg5, nil)
    )

    (defn #_"ISeq" RT'listStar-2 [#_"Object" ___arg1, #_"ISeq" ___rest]
        (cast' ISeq (RT'cons ___arg1, ___rest))
    )

    (defn #_"ISeq" RT'listStar-3 [#_"Object" ___arg1, #_"Object" ___arg2, #_"ISeq" ___rest]
        (cast' ISeq (ß RT'cons(___arg1, RT'cons(___arg2, ___rest))))
    )

    (defn #_"ISeq" RT'listStar-4 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"ISeq" ___rest]
        (cast' ISeq (ß RT'cons(___arg1, RT'cons(___arg2, RT'cons(___arg3, ___rest)))))
    )

    (defn #_"ISeq" RT'listStar-5 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"ISeq" ___rest]
        (cast' ISeq (ß RT'cons(___arg1, RT'cons(___arg2, RT'cons(___arg3, RT'cons(___arg4, ___rest))))))
    )

    (defn #_"ISeq" RT'listStar-6 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"ISeq" ___rest]
        (cast' ISeq (ß RT'cons(___arg1, RT'cons(___arg2, RT'cons(___arg3, RT'cons(___arg4, RT'cons(___arg5, ___rest)))))))
    )

    (defn #_"ISeq" RT'arrayToList [#_"Object[]" ___a]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [#_"int" ___i (- (§ alength ___a) 1)] (>= ___i 0) [(dec ___i)]
                (§ ass ___ret (cast' ISeq (ß RT'cons(___a[___i], ___ret))))
            )
            ___ret
        )
    )

    (defn #_"Object[]" RT'object_array [#_"Object" ___sizeOrSeq]
        (if (instance? Number ___sizeOrSeq)
            (do
                (make-array Object (.intValue (cast Number ___sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"Object[]" ___ret (make-array Object ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (and (< ___i ___size) (some? ___s)) [(inc ___i) (next ___s)]
                                (§ ass (§ aget ___ret ___i) (first ___s))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object[]" RT'toArray [#_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                RT'EMPTY_ARRAY
            )
            (§ instance? Object[] ___coll)
            (do
                (ß (Object[]) ___coll)
            )
            (instance? Collection ___coll)
            (do
                (.toArray (cast Collection ___coll))
            )
            (instance? Iterable ___coll)
            (do
                (let [#_"ArrayList" ___ret (ArrayList.)]
                    (doseq [#_"Object" ___o (cast Iterable ___coll)]
                        (.add ___ret, ___o)
                    )
                    (.toArray ___ret)
                )
            )
            (instance? Map ___coll)
            (do
                (ß (cast Map ___coll).entrySet().toArray())
            )
            (instance? String ___coll)
            (do
                (let [#_"char[]" ___chars (.toCharArray (cast String ___coll))]
                    (let [#_"Object[]" ___ret (make-array Object (§ alength ___chars))]
                        (loop-when-recur [#_"int" ___i 0] (< ___i (§ alength ___chars)) [(inc ___i)]
                            (§ ass (§ aget ___ret ___i) (§ aget ___chars ___i))
                        )
                        ___ret
                    )
                )
            )
            (.isArray (.getClass ___coll))
            (do
                (let [#_"ISeq" ___s (RT'seq ___coll)]
                    (let [#_"Object[]" ___ret (make-array Object (RT'count ___s))]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (< ___i (§ alength ___ret)) [(inc ___i) (next ___s)]
                            (§ ass (§ aget ___ret ___i) (first ___s))
                        )
                        ___ret
                    )
                )
            )
            :else
            (do
                (throw (Util'runtimeException-1 (str "Unable to convert: " (.getClass ___coll) " to Object[]")))
            )
        )
    )

    (defn #_"Object[]" RT'seqToArray [#_"ISeq" ___seq]
        (let [#_"int" ___len (RT'length ___seq)]
            (let [#_"Object[]" ___ret (make-array Object ___len)]
                (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                    (§ ass (§ aget ___ret ___i) (first ___seq))
                )
                ___ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" ___seq, #_"Object[]" ___passed]
        (let [#_"Object[]" ___dest ___passed]
            (let [#_"int" ___len (RT'count ___seq)]
                (when (> ___len (§ alength ___dest))
                    (§ ass ___dest (ß (Object[]) Array/newInstance((.getClass ___passed).getComponentType(), ___len)))
                )
                (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                    (§ ass (§ aget ___dest ___i) (first ___seq))
                )
                (when (< ___len (§ alength ___passed))
                    (§ ass (§ aget ___dest ___len) nil)
                )
                ___dest
            )
        )
    )

    (defn #_"Object" RT'seqToTypedArray-1 [#_"ISeq" ___seq]
        (let [#_"Class" ___type (if (and (some? ___seq) (some? (first ___seq))) (.getClass (first ___seq)) Object)]
            (RT'seqToTypedArray-2 ___type, ___seq)
        )
    )

    (defn #_"Object" RT'seqToTypedArray-2 [#_"Class" ___type, #_"ISeq" ___seq]
        (let [#_"Object" ___ret (ß Array/newInstance(___type, RT'length(___seq)))]
            (cond (= ___type Integer/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, intCast((first ___seq))))
                    )
                )
                (= ___type Byte/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, byteCast((first ___seq))))
                    )
                )
                (= ___type Float/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, floatCast((first ___seq))))
                    )
                )
                (= ___type Short/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, shortCast((first ___seq))))
                    )
                )
                (= ___type Character/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, charCast((first ___seq))))
                    )
                )
                :else
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, (first ___seq)))
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"int" RT'length [#_"ISeq" ___list]
        (let [#_"int" ___i 0]
            (loop-when-recur [#_"ISeq" ___c ___list] (some? ___c) [(next ___c)]
                (§ ass ___i (inc ___i))
            )
            ___i
        )
    )

    (defn #_"int" RT'boundedLength [#_"ISeq" ___list, #_"int" ___limit]
        (let [#_"int" ___i 0]
            (loop-when-recur [#_"ISeq" ___c ___list] (and (some? ___c) (ß ___i <= ___limit)) [(next ___c)]
                (§ ass ___i (inc ___i))
            )
            ___i
        )
    )

    (defn #_"Character" RT'readRet [#_"int" ___ret]
        (when (= ___ret -1)
            (§ return nil)
        )
        (RT'box-1c (char ___ret))
    )

    (defn #_"Character" RT'readChar [#_"Reader" ___r] #_(§ throws IOException)
        (let [#_"int" ___ret (.read ___r)]
            (RT'readRet ___ret)
        )
    )

    (defn #_"Character" RT'peekChar [#_"Reader" ___r] #_(§ throws IOException)
        (§ let [#_"int" ___ret]
            (if (instance? PushbackReader ___r)
                (do
                    (§ ass ___ret (.read ___r))
                    (.unread (cast PushbackReader ___r), ___ret)
                )
                (do
                    (.mark ___r, 1)
                    (§ ass ___ret (.read ___r))
                    (.reset ___r)
                )
            )

            (RT'readRet ___ret)
        )
    )

    (defn #_"int" RT'getLineNumber [#_"Reader" ___r]
        (when (§ instance? LineNumberingPushbackReader ___r)
            (§ return (.getLineNumber (cast' LineNumberingPushbackReader ___r)))
        )
        0
    )

    (defn #_"int" RT'getColumnNumber [#_"Reader" ___r]
        (when (§ instance? LineNumberingPushbackReader ___r)
            (§ return (.getColumnNumber (cast' LineNumberingPushbackReader ___r)))
        )
        0
    )

    (defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" ___r]
        (when (RT'isLineNumberingReader ___r)
            (§ return (cast' LineNumberingPushbackReader ___r))
        )
        (LineNumberingPushbackReader'new-1 ___r)
    )

    (defn #_"boolean" RT'isLineNumberingReader [#_"Reader" ___r]
        (§ instance? LineNumberingPushbackReader ___r)
    )

    (defn #_"boolean" RT'isReduced [#_"Object" ___r]
        (§ instance? Reduced ___r)
    )

    (defn #_"String" RT'resolveClassNameInContext [#_"String" ___className]
        ;; todo - look up in context var
        ___className
    )

    (defn #_"boolean" RT'suppressRead []
        (ß RT'booleanCast-1o(RT'SUPPRESS_READ.deref()))
    )

    (defn #_"String" RT'printString [#_"Object" ___x]
        (try
            (let [#_"StringWriter" ___sw (StringWriter.)]
                (print ___x, ___sw)
                (.toString ___sw)
            )
            (catch Exception ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (defn #_"Object" RT'readString-1 [#_"String" ___s]
        (RT'readString-2 ___s, nil)
    )

    (defn #_"Object" RT'readString-2 [#_"String" ___s, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (PushbackReader. (StringReader. ___s))]
            (LispReader'read-2 ___r, ___opts)
        )
    )

    (defn #_"void" RT'print [#_"Object" ___x, #_"Writer" ___w] #_(§ throws IOException)
        ;; call multimethod
        (if (and (.isBound RT'PRINT_INITIALIZED) (RT'booleanCast-1o (.deref RT'PRINT_INITIALIZED)))
            (do
                (.invoke RT'PR_ON, ___x, ___w)
            )
            (do
                (let [#_"boolean" ___readably (RT'booleanCast-1o (.deref RT'PRINT_READABLY))]
                    (when (§ instance? Obj ___x)
                        (let [#_"Obj" ___o (cast' Obj ___x)]
                            (when (and (pos? (RT'count (.meta ___o))) (or (and ___readably (RT'booleanCast-1o (.deref RT'PRINT_META))) (RT'booleanCast-1o (.deref RT'PRINT_DUP))))
                                (let [#_"IPersistentMap" ___meta (.meta ___o)]
                                    (.write ___w, "#^")
                                    (if (and (ß (count ___meta) == 1) (.containsKey ___meta, RT'TAG_KEY))
                                        (do
                                            (ß print(___meta.valAt(RT'TAG_KEY), ___w))
                                        )
                                        (do
                                            (print ___meta, ___w)
                                        )
                                    )
                                    (.write ___w, \space)
                                )
                            )
                        )
                    )
                    (cond (nil? ___x)
                        (do
                            (.write ___w, "nil")
                        )
                        (or (§ instance? ISeq ___x) (§ instance? IPersistentList ___x))
                        (do
                            (ß ___w.write(\())
                            (ß printInnerSeq(RT'seq(___x), ___w))
                            (.write ___w, \))
                        )
                        (instance? String ___x)
                        (do
                            (let [#_"String" ___s (cast String ___x)]
                                (if (not ___readably)
                                    (do
                                        (.write ___w, ___s)
                                    )
                                    (do
                                        (ß ___w.write(\")) ;; oops! "
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (.length ___s)) [(inc ___i)]
                                            (let [#_"char" ___c (.charAt ___s, ___i)]
                                                (§ switch ___c
                                                    (§ case \newline)
                                                    (do
                                                        (.write ___w, "\\n")
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (.write ___w, "\\t")
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (.write ___w, "\\r")
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß ___w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (.write ___w, "\\\\")
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (.write ___w, "\\f")
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (.write ___w, "\\b")
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (.write ___w, ___c)
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß ___w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (§ instance? IPersistentMap ___x)
                        (do
                            (ß ___w.write(\{))
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___x)] (some? ___s) [(next ___s)]
                                (let [#_"IMapEntry" ___e (cast' IMapEntry (first ___s))]
                                    (ß print((.key ___e), ___w))
                                    (.write ___w, \space)
                                    (ß print((.val ___e), ___w))
                                    (when (some? (next ___s))
                                        (.write ___w, ", ")
                                    )
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (§ instance? IPersistentVector ___x)
                        (do
                            (let [#_"IPersistentVector" ___a (cast' IPersistentVector ___x)]
                                (ß ___w.write(\[))
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___a)) [(inc ___i)]
                                    (ß print(___a.nth(___i), ___w))
                                    (when (ß ___i < (count ___a) - 1)
                                        (.write ___w, \space)
                                    )
                                )
                                (ß ___w.write(\]))
                            )
                        )
                        (§ instance? IPersistentSet ___x)
                        (do
                            (.write ___w, "#{")
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___x)] (some? ___s) [(next ___s)]
                                (ß print((first ___s), ___w))
                                (when (some? (next ___s))
                                    (.write ___w, " ")
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (instance? Character ___x)
                        (do
                            (let [#_"char" ___c (.charValue (cast Character ___x))]
                                (if (not ___readably)
                                    (do
                                        (.write ___w, ___c)
                                    )
                                    (do
                                        (.write ___w, \\)
                                        (§ switch ___c
                                            (§ case \newline)
                                            (do
                                                (.write ___w, "newline")
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (.write ___w, "tab")
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (.write ___w, "space")
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (.write ___w, "backspace")
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (.write ___w, "formfeed")
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (.write ___w, "return")
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (.write ___w, ___c)
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (instance? Class ___x)
                        (do
                            (.write ___w, "#=")
                            (ß ___w.write((cast Class ___x).getName()))
                        )
                        (and (instance? BigDecimal ___x) ___readably)
                        (do
                            (.write ___w, (.toString ___x))
                            (.write ___w, \M)
                        )
                        (and (§ instance? BigInt ___x) ___readably)
                        (do
                            (.write ___w, (.toString ___x))
                            (.write ___w, \N)
                        )
                        (and (instance? BigInteger ___x) ___readably)
                        (do
                            (.write ___w, (.toString ___x))
                            (.write ___w, "BIGINT")
                        )
                        (§ instance? Var ___x)
                        (do
                            (let [#_"Var" ___v (cast' Var ___x)]
                                (.write ___w, (str "#=(var " (:name (:ns ___v)) "/" (:sym ___v) ")"))
                            )
                        )
                        (instance? Pattern ___x)
                        (do
                            (let [#_"Pattern" ___p (cast Pattern ___x)]
                                (.write ___w, (str "#\"" (.pattern ___p) "\""))
                            )
                        )
                        :else
                        (do
                            (.write ___w, (.toString ___x))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" RT'printInnerSeq [#_"ISeq" ___x, #_"Writer" ___w] #_(§ throws IOException)
        (loop-when-recur [#_"ISeq" ___s ___x] (some? ___s) [(next ___s)]
            (ß print((first ___s), ___w))
            (when (some? (next ___s))
                (.write ___w, \space)
            )
        )
        nil
    )

    (defn #_"void" RT'formatAesthetic [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (if (nil? ___obj)
            (do
                (.write ___w, "nil")
            )
            (do
                (.write ___w, (.toString ___obj))
            )
        )
        nil
    )

    (defn #_"void" RT'formatStandard [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (cond (nil? ___obj)
            (do
                (.write ___w, "nil")
            )
            (instance? String ___obj)
            (do
                (ß ___w.write(\")) ;; oops! "
                (.write ___w, (cast String ___obj))
                (ß ___w.write(\")) ;; oops! "
            )
            (instance? Character ___obj)
            (do
                (.write ___w, \\)
                (let [#_"char" ___c (.charValue (cast Character ___obj))]
                    (§ switch ___c
                        (§ case \newline)
                        (do
                            (.write ___w, "newline")
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (.write ___w, "tab")
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (.write ___w, "space")
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (.write ___w, "backspace")
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (.write ___w, "formfeed")
                            (§ break )
                        )
                        (§ default )
                        (do
                            (.write ___w, ___c)
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (.write ___w, (.toString ___obj))
            )
        )
        nil
    )

    (defn #_"Object" RT'format [#_"Object" ___o, #_"String" ___s, #_"Object..." ___args] #_(§ throws IOException)
        (§ let [#_"Writer" ___w]
            (cond (nil? ___o)
                (do
                    (§ ass ___w (StringWriter.))
                )
                (Util'equals ___o, RT'T)
                (do
                    (§ ass ___w (cast Writer (.deref RT'OUT)))
                )
                :else
                (do
                    (§ ass ___w (cast Writer ___o))
                )
            )
            (ß doFormat(___w, ___s, ArraySeq'create-1(___args)))
            (when (nil? ___o)
                (§ return (.toString ___w))
            )
            nil
        )
    )

    (defn #_"ISeq" RT'doFormat [#_"Writer" ___w, #_"String" ___s, #_"ISeq" ___args] #_(§ throws IOException)
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (.length ___s)) [___i]
            (let [#_"char" ___c (.charAt ___s, ___i)]
                (§ ass ___i (inc ___i))
                (§ switch (Character/toLowerCase ___c)
                    (§ case \~)
                    (do
                        (let [#_"char" ___d (.charAt ___s, ___i)]
                            (§ ass ___i (inc ___i))
                            (§ switch (Character/toLowerCase ___d)
                                (§ case \%)
                                (do
                                    (.write ___w, \newline)
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (.write ___w, \tab)
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatAesthetic(___w, RT'first(___args)))
                                    (§ ass ___args (RT'next ___args))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatStandard(___w, RT'first(___args)))
                                    (§ ass ___args (RT'next ___args))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" ___j (.indexOf ___s, "~}", ___i)] ;; note - does not nest
                                        (when (= ___j -1)
                                            (throw (IllegalArgumentException. "Missing ~}"))
                                        )
                                        (let [#_"String" ___subs (.substring ___s, ___i, ___j)]
                                            (loop-when-recur [#_"ISeq" ___sargs (ß RT'seq(RT'first(___args)))] (some? ___sargs) [___sargs]
                                                (§ ass ___sargs (doFormat ___w, ___subs, ___sargs))
                                            )
                                            (§ ass ___args (RT'next ___args))
                                            (§ ass ___i (+ ___j 2)) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (nil? ___args)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß ___w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (IllegalArgumentException. (str "Unsupported ~ directive: " ___d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (.write ___w, ___c)
                        (§ break )
                    )
                )
            )
        )
        ___args
    )

    (defn #_"Object[]" RT'setValues [#_"Object..." ___vals]
        (when (> (§ alength ___vals) 0)
            (§ return ___vals)
        )
        nil
    )

    (defn #_"ClassLoader" RT'makeClassLoader []
        (cast ClassLoader (AccessController/doPrivileged(
                (§ reify PrivilegedAction()
                    #_method
                    (§ defn #_"Object" (§ method run) [#_"PrivilegedAction" this]
                        (try
                            (ß Var'pushThreadBindings(RT'map(RT'USE_CONTEXT_CLASSLOADER, RT'T)))
                            (ß DynamicClassLoader'new-1(baseLoader()))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
            )
        ))
    )

    (defn #_"ClassLoader" RT'baseLoader []
        (cond (.isBound Compiler'LOADER)
            (do
                (§ return (cast ClassLoader (.deref Compiler'LOADER)))
            )
            (ß RT'booleanCast-1o(RT'USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread/currentThread().getContextClassLoader()))
            )
        )
        (.getClassLoader (§ class Compiler))
    )

    (defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ClassLoader/getSystemResourceAsStream ___name)
            )
            (do
                (.getResourceAsStream ___loader, ___name)
            )
        )
    )

    (defn #_"URL" RT'getResource [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ClassLoader/getSystemResource ___name)
            )
            (do
                (.getResource ___loader, ___name)
            )
        )
    )

    (defn #_"Class" RT'classForName-3 [#_"String" ___name, #_"boolean" ___load, #_"ClassLoader" ___loader]
        (try
            (let [#_"Class" ___c nil]
                (when (not (§ instance? DynamicClassLoader ___loader))
                    (§ ass ___c (DynamicClassLoader'findInMemoryClass ___name))
                )
                (when (some? ___c)
                    (§ return ___c)
                )
                (Class/forName ___name, ___load, ___loader)
            )
            (catch ClassNotFoundException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (defn #_"Class" RT'classForName-1 [#_"String" ___name]
        (ß RT'classForName-3(___name, true, baseLoader()))
    )

    (defn #_"Class" RT'classForNameNonLoading [#_"String" ___name]
        (ß RT'classForName-3(___name, false, baseLoader()))
    )

    (defn #_"Class" RT'loadClassForName [#_"String" ___name]
        (try
            (RT'classForNameNonLoading ___name)
            (catch Exception ___e
                (if (instance? ClassNotFoundException ___e)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
        )
        (RT'classForName-1 ___name)
    )

    (defn #_"float" RT'aget-2f [#_"float[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"float" RT'aset-3f [#_"float[]" ___xs, #_"int" ___i, #_"float" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1f [#_"float[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"float[]" RT'aclone-1f [#_"float[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"double" RT'aget-2d [#_"double[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"double" RT'aset-3d [#_"double[]" ___xs, #_"int" ___i, #_"double" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1d [#_"double[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"double[]" RT'aclone-1d [#_"double[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"int" RT'aget-2i [#_"int[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"int" RT'aset-3i [#_"int[]" ___xs, #_"int" ___i, #_"int" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1i [#_"int[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"int[]" RT'aclone-1i [#_"int[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"long" RT'aget-2l [#_"long[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"long" RT'aset-3l [#_"long[]" ___xs, #_"int" ___i, #_"long" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1l [#_"long[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"long[]" RT'aclone-1l [#_"long[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"char" RT'aget-2c [#_"char[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"char" RT'aset-3c [#_"char[]" ___xs, #_"int" ___i, #_"char" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1c [#_"char[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"char[]" RT'aclone-1c [#_"char[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"byte" RT'aget-2b [#_"byte[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"byte" RT'aset-3b [#_"byte[]" ___xs, #_"int" ___i, #_"byte" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1b [#_"byte[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"byte[]" RT'aclone-1b [#_"byte[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"short" RT'aget-2s [#_"short[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"short" RT'aset-3s [#_"short[]" ___xs, #_"int" ___i, #_"short" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1s [#_"short[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"short[]" RT'aclone-1s [#_"short[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"boolean" RT'aget-2z [#_"boolean[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"boolean" RT'aset-3z [#_"boolean[]" ___xs, #_"int" ___i, #_"boolean" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1z [#_"boolean[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"boolean[]" RT'aclone-1z [#_"boolean[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"Object" RT'aget-2o [#_"Object[]" ___xs, #_"int" ___i]
        (§ aget ___xs ___i)
    )

    (defn #_"Object" RT'aset-3o [#_"Object[]" ___xs, #_"int" ___i, #_"Object" ___v]
        (§ ass (§ aget ___xs ___i) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1o [#_"Object[]" ___xs]
        (§ alength ___xs)
    )

    (defn #_"Object[]" RT'aclone-1o [#_"Object[]" ___xs]
        (.clone ___xs)
    )
)
)

(java-ns cloiure.lang.Seqable

(§ defprotocol Seqable
    #_abstract
    (#_"ISeq" Seqable'''(§ method seq) [#_"Seqable" this])
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (defn- #_"SeqEnumeration" SeqEnumeration'init []
        (hash-map
            #_"ISeq" :seq nil
        )
    )

    (defn #_"SeqEnumeration" SeqEnumeration'new [#_"ISeq" ___seq]
        (let [this (SeqEnumeration'init)]
            (§ ass (:seq this) ___seq)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasMoreElements) [#_"SeqEnumeration" this]
        (some? (:seq this))
    )

    #_method
    (§ defn #_"Object" (§ method nextElement) [#_"SeqEnumeration" this]
        (let [#_"Object" ___ret (RT'first (:seq this))]
            (§ ass (:seq this) (RT'next (:seq this)))
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (def #_"Object" SeqIterator'START (Object.))

    (defn- #_"SeqIterator" SeqIterator'init []
        (hash-map
            #_"Object" :seq nil
            #_"Object" :next nil
        )
    )

    (defn #_"SeqIterator" SeqIterator'new [#_"Object" ___o]
        (let [this (SeqIterator'init)]
            (§ ass (:seq this) SeqIterator'START)
            (§ ass (:next this) ___o)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"SeqIterator" this]
        (cond (ß (:seq this) == SeqIterator'START)
            (do
                (§ ass (:seq this) nil)
                (§ ass (:next this) (RT'seq (:next this)))
            )
            (ß (:seq this) == (:next this))
            (do
                (§ ass (:next this) (RT'next (:seq this)))
            )
        )
        (some? (:next this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"SeqIterator" this] #_(§ throws NoSuchElementException)
        (when (not (.hasNext this))
            (throw (NoSuchElementException.))
        )
        (§ ass (:seq this) (:next this))
        (RT'first (:next this))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Sequential

(§ defprotocol Sequential
)
)

(java-ns cloiure.lang.Settable

(§ defprotocol Settable
    #_abstract
    (#_"Object" Settable'''(§ method doSet) [#_"Settable" this, #_"Object" ___val])
    #_abstract
    (#_"Object" Settable'''(§ method doReset) [#_"Settable" this, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ defprotocol Sorted
    #_abstract
    (#_"Comparator" Sorted'''(§ method comparator) [#_"Sorted" this])
    #_abstract
    (#_"Object" Sorted'''(§ method entryKey) [#_"Sorted" this, #_"Object" ___entry])
    #_abstract
    (#_"ISeq" Sorted'''(§ method seq) [#_"Sorted" this, #_"boolean" ___ascending])
    #_abstract
    (#_"ISeq" Sorted'''(§ method seqFrom) [#_"Sorted" this, #_"Object" ___key, #_"boolean" ___ascending])
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (defn #_"StringSeq" StringSeq'create [#_"CharSequence" ___s]
        (when (zero? (.length ___s))
            (§ return nil)
        )
        (StringSeq'new nil, ___s, 0)
    )

    (defn- #_"StringSeq" StringSeq'init []
        (hash-map
            #_"CharSequence" :s nil
            #_"int" :i 0
        )
    )

    (defn #_"StringSeq" StringSeq'new [#_"IPersistentMap" ___meta, #_"CharSequence" ___s, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (StringSeq'init))]
            (§ ass (:s this) ___s)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"StringSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (.meta this))
            (§ return this)
        )
        (StringSeq'new ___meta, (:s this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"StringSeq" this]
        (ß Character/valueOf((:s this).charAt((:i this))))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"StringSeq" this]
        (when (ß (:i this) + 1 < (:s this).length())
            (§ return (ß StringSeq'new((:_meta this), (:s this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"StringSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"StringSeq" this]
        (ß (:s this).length() - (:i this))
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (defn #_"Symbol" Symbol'create-2 [#_"String" ___ns, #_"String" ___name]
        (Symbol'intern-2 ___ns, ___name)
    )

    (defn #_"Symbol" Symbol'create-1 [#_"String" ___nsname]
        (Symbol'intern-1 ___nsname)
    )

    (defn #_"Symbol" Symbol'intern-2 [#_"String" ___ns, #_"String" ___name]
        (Symbol'new-2 ___ns, ___name)
    )

    (defn #_"Symbol" Symbol'intern-1 [#_"String" ___nsname]
        (let [#_"int" ___i (.indexOf ___nsname, \/)]
            (if (or (ß ___i == -1) (.equals ___nsname, "/"))
                (do
                    (Symbol'new-2 nil, ___nsname)
                )
                (do
                    (ß Symbol'new-2(___nsname.substring(0, ___i), ___nsname.substring(___i + 1)))
                )
            )
        )
    )

    (defn- #_"Symbol" Symbol'init []
        (hash-map
            #_"String" :ns nil
            #_"String" :name nil
            #_"int" :_hasheq 0
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Symbol" Symbol'new-2 [#_"String" ___ns_interned, #_"String" ___name_interned]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass (:name this) ___name_interned)
            (§ ass (:ns this) ___ns_interned)
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Symbol" this]
        (when (nil? (:_str this))
            (if (some? (:ns this))
                (do
                    (§ ass (:_str this) (str (:ns this) "/" (:name this)))
                )
                (do
                    (§ ass (:_str this) (:name this))
                )
            )
        )
        (:_str this)
    )

    #_method
    (§ defn #_"String" (§ method getNamespace) [#_"Symbol" this]
        (:ns this)
    )

    #_method
    (§ defn #_"String" (§ method getName) [#_"Symbol" this]
        (:name this)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"Symbol" this, #_"Object" ___o]
        (when (= this ___o)
            (§ return true)
        )
        (when (not (§ instance? Symbol ___o))
            (§ return false)
        )

        (let [#_"Symbol" ___symbol (cast' Symbol ___o)]
            (and (Util'equals (:ns this), (:ns ___symbol)) (.equals (:name this), (:name ___symbol)))
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Symbol" this]
        (ß Util'hashCombine((:name this).hashCode(), Util'hash((:ns this))))
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"Symbol" this]
        (when (zero? (:_hasheq this))
            (§ ass (:_hasheq this) (ß Util'hashCombine(Murmur3'hashUnencodedChars((:name this)), Util'hash((:ns this)))))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"Symbol" this, #_"IPersistentMap" ___meta]
        (Symbol'new-3 ___meta, (:ns this), (:name this))
    )

    (defn- #_"Symbol" Symbol'new-3 [#_"IPersistentMap" ___meta, #_"String" ___ns, #_"String" ___name]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass (:name this) ___name)
            (§ ass (:ns this) ___ns)
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Symbol" this, #_"Object" ___o]
        (let [#_"Symbol" ___s (cast' Symbol ___o)]
            (when (.equals this, ___o)
                (§ return 0)
            )
            (when (and (nil? (:ns this)) (some? (:ns ___s)))
                (§ return -1)
            )
            (when (ß (some? (:ns this)))
                (when (ß (nil? (:ns ___s)))
                    (§ return 1)
                )
                (let [#_"int" ___nsc (.compareTo (:ns this), (:ns ___s))]
                    (when (not= ___nsc 0)
                        (§ return ___nsc)
                    )
                )
            )
            (.compareTo (:name this), (:name ___s))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Symbol" this, #_"Object" ___obj]
        (RT'get-2 ___obj, this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Symbol" this, #_"Object" ___obj, #_"Object" ___notFound]
        (RT'get-3 ___obj, this, ___notFound)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Symbol" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def #_"Keyword" TaggedLiteral'TAG_KW (Keyword'intern-1 "tag"))
    (§ def #_"Keyword" TaggedLiteral'FORM_KW (Keyword'intern-1 "form"))

    (defn #_"TaggedLiteral" TaggedLiteral'create [#_"Symbol" ___tag, #_"Object" ___form]
        (TaggedLiteral'new ___tag, ___form)
    )

    (defn- #_"TaggedLiteral" TaggedLiteral'init []
        (hash-map
            #_"Symbol" :tag nil
            #_"Object" :form nil
        )
    )

    (defn- #_"TaggedLiteral" TaggedLiteral'new [#_"Symbol" ___tag, #_"Object" ___form]
        (let [this (TaggedLiteral'init)]
            (§ ass (:tag this) ___tag)
            (§ ass (:form this) ___form)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TaggedLiteral" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TaggedLiteral" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (.equals TaggedLiteral'FORM_KW, ___key)
            (do
                (:form this)
            )
            (.equals TaggedLiteral'TAG_KW, ___key)
            (do
                (:tag this)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" (§ method equals) [#_"TaggedLiteral" this, #_"Object" ___o]
        (when (= this ___o)
            (§ return true)
        )
        (when (or (nil? ___o) (ß getClass() != (.getClass ___o)))
            (§ return false)
        )

        (let [#_"TaggedLiteral" ___that (cast' TaggedLiteral ___o)]
            (when (if (some? (:form this)) (not (.equals (:form this), (:form ___that))) (some? (:form ___that)))
                (§ return false)
            )
            (when (if (some? (:tag this)) (not (.equals (:tag this), (:tag ___that))) (some? (:tag ___that)))
                (§ return false)
            )

            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"TaggedLiteral" this]
        (let [#_"int" ___result (Util'hash (:tag this))]
            (§ ass ___result (ß 31 * ___result + Util'hash((:form this))))
            ___result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (defn- #_"TransactionalHashMap" TransactionalHashMap'init []
        (hash-map
            #_"Ref[]" :bins nil
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-0 []
        (TransactionalHashMap'new-1i 421)
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1i [#_"int" ___nBins]
        (let [this (merge (AbstractMap'new) (TransactionalHashMap'init))]
            (§ ass (:bins this) (§ typeless make-array Ref ___nBins))
            (loop-when-recur [#_"int" ___i 0] (< ___i ___nBins) [(inc ___i)]
                (§ ass (§ aget (:bins this) ___i) (Ref'new-1 PersistentHashMap'EMPTY))
            )
            this
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1m [#_"Map<? extends K, ? extends V>" ___m]
        (let [this (TransactionalHashMap'new-1i (.size ___m))]
            (.putAll this, ___m)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method mapAt) [#_"TransactionalHashMap" this, #_"int" ___bin]
        (cast' IPersistentMap (ß (:bins this)[___bin].deref()))
    )

    #_method
    (§ defn #_"int" (§ method binFor) [#_"TransactionalHashMap" this, #_"Object" ___k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" ___h (.hashCode ___k)]
            (§ ass ___h (ß ___h :xor ((___h >>> 20) :xor (___h >>> 12))))
            (§ ass ___h (ß ___h :xor ((___h >>> 7) :xor (___h >>> 4))))
            (ß ___h % (§ alength (:bins this)))
        )
    )

    #_method
    (§ defn #_"Entry" (§ method entryAt) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß this.mapAt(this.binFor(___k)).entryAt(___k))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"TransactionalHashMap" this]
        (let [#_"int" ___n 0]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:bins this))) [(inc ___i)]
                (§ ass ___n (ß ___n + this.mapAt(___i).count()))
            )
            ___n
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"TransactionalHashMap" this]
        (zero? (.size this))
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (some? (.entryAt this, ___k))
    )

    #_method
    (§ defn #_"V" (§ method get) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Entry" ___e (.entryAt this, ___k)]
            (when (some? ___e)
                (§ return (cast' V (.getValue ___e)))
            )
            nil
        )
    )

    #_method
    (§ defn #_"V" (§ method put) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (§ aget (:bins this) (ß this.binFor(___k)))]
            (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                (let [#_"Object" ___ret (.valAt ___map, ___k)]
                    (ß ___r.set(___map.assoc(___k, ___v)))
                    (cast' V ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method remove) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Ref" ___r (§ aget (:bins this) (ß this.binFor(___k)))]
            (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                (let [#_"Object" ___ret (.valAt ___map, ___k)]
                    (ß ___r.set(___map.without(___k)))
                    (cast' V ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method putAll) [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" ___map]
        (loop-when-recur [#_"Iterator" ___i (.iterator (.entrySet ___map))] (.hasNext ___i) [___i]
            (let [#_"Entry<K, V>" ___e (cast' Entry (next ___i))]
                (ß this.put((.getKey ___e), (.getValue ___e)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"TransactionalHashMap" this]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:bins this))) [(inc ___i)]
            (let [#_"Ref" ___r (§ aget (:bins this) ___i)]
                (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                    (when (pos? (count ___map))
                        (.set ___r, PersistentHashMap'EMPTY)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" (§ method entrySet) [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map$Entry<K, V>>" ___entries (ArrayList. (§ alength (:bins this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:bins this))) [(inc ___i)]
                (let [#_"IPersistentMap" ___map (.mapAt this, ___i)]
                    (when (pos? (count ___map))
                        (ß ___entries.addAll((cast Collection (RT'seq ___map))))
                    )
                )
            )
            (§ reify AbstractSet<Entry<K, V>>()
                #_method
                (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet<Entry<K, V>>" this]
                    (ß Collections/unmodifiableList(___entries).iterator())
                )

                #_method
                (§ defn #_"int" (§ method size) [#_"AbstractSet<Entry<K, V>>" this]
                    (.size ___entries)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method putIfAbsent) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (§ aget (:bins this) (ß this.binFor(___k)))]
            (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (if (nil? ___e)
                        (do
                            (ß ___r.set(___map.assoc(___k, ___v)))
                            nil
                        )
                        (do
                            (cast' V (.getValue ___e))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"TransactionalHashMap" this, #_"Object" ___k, #_"Object" ___v]
        (let [#_"Ref" ___r (§ aget (:bins this) (ß this.binFor(___k)))]
            (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (when (and (some? ___e) (ß (.getValue ___e).equals(___v)))
                        (ß ___r.set(___map.without(___k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method replace) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___oldv, #_"V" ___newv]
        (let [#_"Ref" ___r (§ aget (:bins this) (ß this.binFor(___k)))]
            (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (when (and (some? ___e) (ß (.getValue ___e).equals(___oldv)))
                        (ß ___r.set(___map.assoc(___k, ___newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method replace) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (§ aget (:bins this) (ß this.binFor(___k)))]
            (let [#_"IPersistentMap" ___map (cast' IPersistentMap (.deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (when (some? ___e)
                        (ß ___r.set(___map.assoc(___k, ___v)))
                        (§ return (cast' V (.getValue ___e)))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_private
(§ defprotocol Buffer
    #_abstract
    (#_"Buffer" Buffer'''(§ method add) [#_"Buffer" this, #_"Object" ___o])
    #_abstract
    (#_"Object" Buffer'''(§ method remove) [#_"Buffer" this])
    #_abstract
    (#_"boolean" Buffer'''(§ method isEmpty) [#_"Buffer" this])
)

#_private
(class-ns EmptyBuffer (§ implements Buffer)
    (defn #_"EmptyBuffer" EmptyBuffer'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"EmptyBuffer" this, #_"Object" ___o]
        (SingleBuffer'new ___o)
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"EmptyBuffer" this]
        (throw (IllegalStateException. "Removing object from empty buffer"))
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"EmptyBuffer" this]
        true
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"EmptyBuffer" this]
        "EmptyBuffer"
    )
)

#_private
(class-ns SingleBuffer (§ implements Buffer)
    (defn- #_"SingleBuffer" SingleBuffer'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"SingleBuffer" SingleBuffer'new [#_"Object" ___o]
        (let [this (SingleBuffer'init)]
            (§ ass (:val this) ___o)
            this
        )
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"SingleBuffer" this, #_"Object" ___o]
        (if (ß (:val this) == TransformerIterator'NONE)
            (do
                (§ ass (:val this) ___o)
                this
            )
            (do
                (ManyBuffer'new (:val this), ___o)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"SingleBuffer" this]
        (when (ß (:val this) == TransformerIterator'NONE)
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )
        (let [#_"Object" ___ret (:val this)]
            (§ ass (:val this) TransformerIterator'NONE)
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"SingleBuffer" this]
        (ß ((:val this) == TransformerIterator'NONE))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"SingleBuffer" this]
        (str "SingleBuffer: " (:val this))
    )
)

#_private
(class-ns ManyBuffer (§ implements Buffer)
    (defn- #_"ManyBuffer" ManyBuffer'init []
        (hash-map
            #_"Queue" :vals (LinkedList.)
        )
    )

    (defn #_"ManyBuffer" ManyBuffer'new [#_"Object" ___o1, #_"Object" ___o2]
        (let [this (ManyBuffer'init)]
            (.add (:vals this), ___o1)
            (.add (:vals this), ___o2)
            this
        )
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"ManyBuffer" this, #_"Object" ___o]
        (.add (:vals this), ___o)
        this
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"ManyBuffer" this]
        (.remove (:vals this))
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"ManyBuffer" this]
        (.isEmpty (:vals this))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ManyBuffer" this]
        (str "ManyBuffer: " (.toString (:vals this)))
    )
)

#_private
(class-ns MultiIterator (§ implements Iterator)
    (defn- #_"MultiIterator" MultiIterator'init []
        (hash-map
            #_"Iterator[]" :iters nil
        )
    )

    (defn #_"MultiIterator" MultiIterator'new [#_"Iterator[]" ___iters]
        (let [this (MultiIterator'init)]
            (§ ass (:iters this) ___iters)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"MultiIterator" this]
        (doseq [#_"Iterator" ___iter (:iters this)]
            (when (not (.hasNext ___iter))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"MultiIterator" this]
        (let [#_"Object[]" ___nexts (make-array Object (§ alength (:iters this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (§ alength (:iters this))) [(inc ___i)]
                (§ ass (§ aget ___nexts ___i) (ß (:iters this)[___i].next()))
            )
            (ArraySeq'new-2 ___nexts, 0)
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"MultiIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransformerIterator (§ implements Iterator)
    (def- #_"Buffer" TransformerIterator'EMPTY (EmptyBuffer'new))
    (def- #_"Object" TransformerIterator'NONE (Object.))

    (defn- #_"TransformerIterator" TransformerIterator'init []
        (hash-map
            ;; Source
            #_"Iterator" :sourceIter nil
            #_"IFn" :xf nil
            #_"boolean" :multi false

            ;; Iteration state
            #_volatile
            #_"Buffer" :buffer TransformerIterator'EMPTY
            #_volatile
            #_"Object" :next TransformerIterator'NONE
            #_volatile
            #_"boolean" :completed false
        )
    )

    (defn- #_"TransformerIterator" TransformerIterator'new [#_"IFn" ___xform, #_"Iterator" ___sourceIter, #_"boolean" ___multi]
        (let [this (TransformerIterator'init)]
            (§ ass (:sourceIter this) ___sourceIter)
            (§ ass (:xf this) (cast' IFn (.invoke ___xform,
                (§ reify AFn()
                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
                        nil
                    )

                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___acc]
                        ___acc
                    )

                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___acc, #_"Object" ___o]
                        (§ ass (:buffer this) (.add (:buffer this), ___o))
                        ___acc
                    )
                )
            )))
            (§ ass (:multi this) ___multi)
            this
        )
    )

    (defn #_"Iterator" TransformerIterator'create [#_"IFn" ___xform, #_"Iterator" ___source]
        (TransformerIterator'new ___xform, ___source, false)
    )

    (defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" ___xform, #_"List" ___sources]
        (let [#_"Iterator[]" ___iters (make-array Iterator (.size ___sources))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___sources)) [(inc ___i)]
                (§ ass (§ aget ___iters ___i) (cast Iterator (.get ___sources, ___i)))
            )
            (ß TransformerIterator'new(___xform, MultiIterator'new(___iters), true))
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method step) [#_"TransformerIterator" this]
        (when (ß (:next this) != TransformerIterator'NONE)
            (§ return true)
        )

        (while (ß (:next this) == TransformerIterator'NONE)
            (if (.isEmpty (:buffer this))
                (do
                    (cond (:completed this)
                        (do
                            (§ return false)
                        )
                        (.hasNext (:sourceIter this))
                        (do
                            (let [#_"Object" ___iter nil]
                                (if (:multi this)
                                    (do
                                        (§ ass ___iter (ß (:xf this).applyTo(RT'cons(nil, (:sourceIter this).next()))))
                                    )
                                    (do
                                        (§ ass ___iter (ß (:xf this).invoke(nil, (:sourceIter this).next())))
                                    )
                                )

                                (when (RT'isReduced ___iter)
                                    (.invoke (:xf this), nil)
                                    (§ ass (:completed this) true)
                                )
                            )
                        )
                        :else
                        (do
                            (.invoke (:xf this), nil)
                            (§ ass (:completed this) true)
                        )
                    )
                )
                (do
                    (§ ass (:next this) (.remove (:buffer this)))
                )
            )
        )
        true
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"TransformerIterator" this]
        (.step this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"TransformerIterator" this]
        (when (.hasNext this)
            (let [#_"Object" ___ret (:next this)]
                (§ ass (:next this) TransformerIterator'NONE)
                (§ return ___ret)
            )
        )
        (throw (NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns Tuple
    (def #_"int" Tuple'MAX_SIZE 6)

    (defn #_"IPersistentVector" Tuple'create-0 []
        PersistentVector'EMPTY
    )

    (defn #_"IPersistentVector" Tuple'create-1 [#_"Object" ___v0]
        (RT'vector ___v0)
    )

    (defn #_"IPersistentVector" Tuple'create-2 [#_"Object" ___v0, #_"Object" ___v1]
        (RT'vector ___v0, ___v1)
    )

    (defn #_"IPersistentVector" Tuple'create-3 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2]
        (RT'vector ___v0, ___v1, ___v2)
    )

    (defn #_"IPersistentVector" Tuple'create-4 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3]
        (RT'vector ___v0, ___v1, ___v2, ___v3)
    )

    (defn #_"IPersistentVector" Tuple'create-5 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4]
        (RT'vector ___v0, ___v1, ___v2, ___v3, ___v4)
    )

    (defn #_"IPersistentVector" Tuple'create-6 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4, #_"Object" ___v5]
        (RT'vector ___v0, ___v1, ___v2, ___v3, ___v4, ___v5)
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(§ defprotocol EquivPred
    #_abstract
    (#_"boolean" EquivPred'''(§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2])
)

#_stateless
(class-ns Util
    (defn #_"boolean" Util'equiv-2oo [#_"Object" ___k1, #_"Object" ___k2]
        (when (= ___k1 ___k2)
            (§ return true)
        )
        (when (some? ___k1)
            (cond (and (instance? Number ___k1) (instance? Number ___k2))
                (do
                    (§ return (ß Numbers'equal((cast Number ___k1), (cast Number ___k2))))
                )
                (or (§ instance? IPersistentCollection ___k1) (§ instance? IPersistentCollection ___k2))
                (do
                    (§ return (Util'pcequiv ___k1, ___k2))
                )
            )
            (§ return (.equals ___k1, ___k2))
        )
        false
    )

    (def #_"EquivPred" Util'equivNull
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (nil? ___k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivEquals
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (.equals ___k1, ___k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivNumber
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (instance? Number ___k2)
                    (§ return (ß Numbers'equal((cast Number ___k1), (cast Number ___k2))))
                )
                false
            )
        )
    )

    (def #_"EquivPred" Util'equivColl
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (or (§ instance? IPersistentCollection ___k1) (§ instance? IPersistentCollection ___k2))
                    (§ return (Util'pcequiv ___k1, ___k2))
                )
                (.equals ___k1, ___k2)
            )
        )
    )

    (defn #_"EquivPred" Util'equivPred [#_"Object" ___k1]
        (cond (nil? ___k1)
            (do
                (§ return Util'equivNull)
            )
            (instance? Number ___k1)
            (do
                (§ return Util'equivNumber)
            )
            (or (instance? String ___k1) (§ instance? Symbol ___k1))
            (do
                (§ return Util'equivEquals)
            )
            (or (instance? Collection ___k1) (instance? Map ___k1))
            (do
                (§ return Util'equivColl)
            )
        )
        Util'equivEquals
    )

    (defn #_"boolean" Util'equiv-2ll [#_"long" ___k1, #_"long" ___k2]
        (= ___k1 ___k2)
    )

    (defn #_"boolean" Util'equiv-2ol [#_"Object" ___k1, #_"long" ___k2]
        (ß this.equiv(___k1, (cast Object ___k2)))
    )

    (defn #_"boolean" Util'equiv-2lo [#_"long" ___k1, #_"Object" ___k2]
        (ß this.equiv((cast Object ___k1), ___k2))
    )

    (defn #_"boolean" Util'equiv-2dd [#_"double" ___k1, #_"double" ___k2]
        (= ___k1 ___k2)
    )

    (defn #_"boolean" Util'equiv-2od [#_"Object" ___k1, #_"double" ___k2]
        (ß this.equiv(___k1, (cast Object ___k2)))
    )

    (defn #_"boolean" Util'equiv-2do [#_"double" ___k1, #_"Object" ___k2]
        (ß this.equiv((cast Object ___k1), ___k2))
    )

    (defn #_"boolean" Util'equiv-2bb [#_"boolean" ___k1, #_"boolean" ___k2]
        (= ___k1 ___k2)
    )

    (defn #_"boolean" Util'equiv-2ob [#_"Object" ___k1, #_"boolean" ___k2]
        (ß this.equiv(___k1, (cast Object ___k2)))
    )

    (defn #_"boolean" Util'equiv-2bo [#_"boolean" ___k1, #_"Object" ___k2]
        (ß this.equiv((cast Object ___k1), ___k2))
    )

    (defn #_"boolean" Util'equiv-2cc [#_"char" ___c1, #_"char" ___c2]
        (= ___c1 ___c2)
    )

    (defn #_"boolean" Util'pcequiv [#_"Object" ___k1, #_"Object" ___k2]
        (when (§ instance? IPersistentCollection ___k1)
            (§ return (.equiv (cast' IPersistentCollection ___k1), ___k2))
        )
        (.equiv (cast' IPersistentCollection ___k2), ___k1)
    )

    (defn #_"boolean" Util'equals [#_"Object" ___k1, #_"Object" ___k2]
        (when (= ___k1 ___k2)
            (§ return true)
        )
        (and (some? ___k1) (.equals ___k1, ___k2))
    )

    (defn #_"boolean" Util'identical [#_"Object" ___k1, #_"Object" ___k2]
        (= ___k1 ___k2)
    )

    (defn #_"Class" Util'classOf [#_"Object" ___x]
        (when (some? ___x)
            (§ return (.getClass ___x))
        )
        nil
    )

    (defn #_"int" Util'compare [#_"Object" ___k1, #_"Object" ___k2]
        (when (= ___k1 ___k2)
            (§ return 0)
        )
        (when (some? ___k1)
            (when (nil? ___k2)
                (§ return 1)
            )
            (when (instance? Number ___k1)
                (§ return (ß Numbers'compare((cast Number ___k1), (cast Number ___k2))))
            )
            (§ return (.compareTo (cast Comparable ___k1), ___k2))
        )
        -1
    )

    (defn #_"int" Util'hash [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (.hashCode ___o)
    )

    (defn #_"int" Util'hasheq [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (when (§ instance? IHashEq ___o)
            (§ return (Util'dohasheq (cast' IHashEq ___o)))
        )
        (when (instance? Number ___o)
            (§ return (Numbers'hasheq (cast Number ___o)))
        )
        (when (instance? String ___o)
            (§ return (Murmur3'hashInt (.hashCode ___o)))
        )
        (.hashCode ___o)
    )

    (defn- #_"int" Util'dohasheq [#_"IHashEq" ___o]
        (.hasheq ___o)
    )

    (defn #_"int" Util'hashCombine [#_"int" ___seed, #_"int" ___hash]
        ;; a la boost
        (§ ass ___seed (ß ___seed :xor (___hash + 0x9e3779b9 + (___seed << 6) + (___seed >> 2))))
        ___seed
    )

    (defn #_"boolean" Util'isPrimitive [#_"Class" ___c]
        (and (some? ___c) (.isPrimitive ___c) (not (= ___c Void/TYPE)))
    )

    (defn #_"boolean" Util'isInteger [#_"Object" ___x]
        (or (instance? Integer ___x) (instance? Long ___x) (§ instance? BigInt ___x) (instance? BigInteger ___x))
    )

    (defn #_"Object" Util'ret1 [#_"Object" ___ret, #_"Object" ___nil]
        ___ret
    )

    (defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" ___rq, #_"ConcurrentHashMap<K, Reference<V>>" ___cache]
        ;; cleanup any dead entries
        (when (some? (.poll ___rq))
            (while (some? (.poll ___rq))
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" ___e (.entrySet ___cache)]
                (let [#_"Reference<V>" ___val (.getValue ___e)]
                    (when (and (some? ___val) (nil? (.get ___val)))
                        (ß ___cache.remove((.getKey ___e), ___val))
                    )
                )
            )
        )
        nil
    )

    (defn #_"RuntimeException" Util'runtimeException-1 [#_"String" ___s]
        (RuntimeException. ___s)
    )

    (defn #_"RuntimeException" Util'runtimeException-2 [#_"String" ___s, #_"Throwable" ___e]
        (RuntimeException. ___s, ___e)
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (defn #_"RuntimeException" Util'sneakyThrow [#_"Throwable" ___t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (nil? ___t)
            (throw (NullPointerException.))
        )
        (ß Util'<RuntimeException>sneakyThrow0(___t))
        nil
    )

    (defn- #_"<T extends Throwable> void" Util'sneakyThrow0 [#_"Throwable" ___t] #_(§ throws T)
        (throw (cast' T ___t))
    )

    (defn #_"Object" Util'loadWithClass [#_"String" ___scriptbase, #_"Class<?>" ___loadFrom] #_(§ throws IOException, ClassNotFoundException)
        (ß Var'pushThreadBindings(RT'map(
            (object-array [
                Compiler'LOADER (.getClassLoader ___loadFrom)
            ])
        )))
        (try
            (ß RT'var-2("cloiure.core", "load").invoke(___scriptbase))
            (finally
                (Var'popThreadBindings)
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns TBox
    (defn- #_"TBox" TBox'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_"Thread" :thread nil
        )
    )

    (defn #_"TBox" TBox'new [#_"Thread" ___t, #_"Object" ___val]
        (let [this (TBox'init)]
            (§ ass (:thread this) ___t)
            (§ ass (:val this) ___val)
            this
        )
    )
)

(class-ns Unbound (§ extends AFn)
    (defn- #_"Unbound" Unbound'init []
        (hash-map
            #_"Var" :v nil
        )
    )

    (defn #_"Unbound" Unbound'new [#_"Var" ___v]
        (let [this (merge (AFn'new) (Unbound'init))]
            (§ ass (:v this) ___v)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Unbound" this]
        (str "Unbound: " (:v this))
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"Unbound" this, #_"int" ___n]
        (throw (IllegalStateException. (str "Attempting to call unbound fn: " (:v this))))
    )
)

(class-ns Frame
    (§ def #_"Frame" Frame'TOP (Frame'new PersistentHashMap'EMPTY, nil))

    (defn- #_"Frame" Frame'init []
        (hash-map
            ;; Var->TBox
            #_"Associative" :bindings nil
            ;; Var->val
            #_"Frame" :prev nil
        )
    )

    (defn #_"Frame" Frame'new [#_"Associative" ___bindings, #_"Frame" ___prev]
        (let [this (Frame'init)]
            (§ ass (:bindings this) ___bindings)
            (§ ass (:prev this) ___prev)
            this
        )
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method clone) [#_"Frame" this]
        (ß Frame'new((:bindings this), nil))
    )
)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (def #_"ThreadLocal<Frame>" Var'dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_method
            (§ defn #_"Frame" (§ method initialValue) [#_"ThreadLocal<Frame>" this]
                Frame'TOP
            )
        )
    )

    #_volatile
    (def #_"int" Var'rev 0)

    (§ def #_"Keyword" Var'privateKey (Keyword'intern-2 nil, "private"))
    (§ def #_"IPersistentMap" Var'privateMeta (PersistentArrayMap'new-1 (object-array [ privateKey, Boolean/TRUE ])))
    (§ def #_"Keyword" Var'macroKey (Keyword'intern-2 nil, "macro"))
    (§ def #_"Keyword" Var'nameKey (Keyword'intern-2 nil, "name"))
    (§ def #_"Keyword" Var'nsKey (Keyword'intern-2 nil, "ns"))

    (defn #_"Object" Var'getThreadBindingFrame []
        (.get Var'dvals)
    )

    (defn #_"Object" Var'cloneThreadBindingFrame []
        (.clone (.get Var'dvals))
    )

    (defn #_"void" Var'resetThreadBindingFrame [#_"Object" ___frame]
        (.set Var'dvals, (cast' Frame ___frame))
        nil
    )

    (defn #_"Var" Var'intern-3 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (Var'intern-4 ___ns, ___sym, ___root, true)
    )

    (defn #_"Var" Var'intern-4 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root, #_"boolean" ___replaceRoot]
        (let [#_"Var" ___dvout (.intern ___ns, ___sym)]
            (when (or (not (.hasRoot ___dvout)) ___replaceRoot)
                (.bindRoot ___dvout, ___root)
            )
            ___dvout
        )
    )

    (defn #_"Var" Var'find [#_"Symbol" ___nsQualifiedSym]
        (when (ß (nil? (:ns ___nsQualifiedSym)))
            (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
        )
        (let [#_"Namespace" ___ns (ß Namespace'find(Symbol'intern-1((:ns ___nsQualifiedSym))))]
            (when (nil? ___ns)
                (throw (IllegalArgumentException. (str "No such namespace: " (:ns ___nsQualifiedSym))))
            )
            (ß ___ns.findInternedVar(Symbol'intern-1((:name ___nsQualifiedSym))))
        )
    )

    (defn #_"Var" Var'intern-2n [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (.intern ___ns, ___sym)
    )

    (defn #_"Var" Var'intern-2s [#_"Symbol" ___nsName, #_"Symbol" ___sym]
        (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsName)]
            (Var'intern-2n ___ns, ___sym)
        )
    )

    (defn #_"Var" Var'internPrivate [#_"String" ___nsName, #_"String" ___sym]
        (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(Symbol'intern-1(___nsName)))]
            (let [#_"Var" ___ret (Var'intern-2n ___ns, (Symbol'intern-1 ___sym))]
                (.setMeta ___ret, Var'privateMeta)
                ___ret
            )
        )
    )

    (defn #_"Var" Var'create-0 []
        (Var'new-2 nil, nil)
    )

    (defn #_"Var" Var'create-1 [#_"Object" ___root]
        (Var'new-3 nil, nil, ___root)
    )

    (defn- #_"Var" Var'init []
        (hash-map
            #_volatile
            #_"Object" :root nil

            #_volatile
            #_"boolean" :dynamic false
            #_transient
            #_"AtomicBoolean" :threadBound nil
            #_"Symbol" :sym nil
            #_"Namespace" :ns nil
        )
    )

    (defn #_"Var" Var'new-2 [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (let [this (merge (ARef'new-0) (Var'init))]
            (§ ass (:ns this) ___ns)
            (§ ass (:sym this) ___sym)
            (§ ass (:threadBound this) (AtomicBoolean. false))
            (§ ass (:root this) (Unbound'new this))
            (.setMeta this, PersistentHashMap'EMPTY)
            this
        )
    )

    (defn #_"Var" Var'new-3 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (let [this (Var'new-2 ___ns, ___sym)]
            (§ ass (:root this) ___root)
            (§ ass rev (+ rev 1))
            this
        )
    )

    #_method
    (§ defn #_"Var" (§ method setDynamic) [#_"Var" this]
        (§ ass (:dynamic this) true)
        this
    )

    #_method
    (§ defn #_"Var" (§ method setDynamic) [#_"Var" this, #_"boolean" ___b]
        (§ ass (:dynamic this) ___b)
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isDynamic) [#_"Var" this]
        (:dynamic this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Var" this]
        (when (some? (:ns this))
            (§ return (str "#'" (:name (:ns this)) "/" (:sym this)))
        )
        (str "#<Var: " (if (some? (:sym this)) (.toString (:sym this)) "--unnamed--") ">")
    )

    #_method
    (§ defn #_"boolean" (§ method isBound) [#_"Var" this]
        (or (.hasRoot this) (and (.get (:threadBound this)) (.containsKey (:bindings (.get Var'dvals)), this)))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"Var" this]
        (when (not (.get (:threadBound this)))
            (§ return (:root this))
        )
        (.deref this)
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Var" this]
        (let [#_"TBox" ___b (.getThreadBinding this)]
            (when (some? ___b)
                (§ return (:val ___b))
            )
            (:root this)
        )
    )

    #_method
    (§ defn #_"void" (§ method setValidator) [#_"Var" this, #_"IFn" ___vf]
        (when (.hasRoot this)
            (.validate this, ___vf, (:root this))
        )
        (§ ass (:validator this) ___vf)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method alter) [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß this.set(___fn.applyTo(RT'cons((.deref this), ___args))))
        this
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"Var" this, #_"Object" ___val]
        (ß this.validate((.getValidator this), ___val))
        (let [#_"TBox" ___b (.getThreadBinding this)]
            (when (some? ___b)
                (when (ß Thread/currentThread() != (:thread ___b))
                    (throw (IllegalStateException. (String/format "Can't set!: %s from non-binding thread", (object-array [ (:sym this) ]))))
                )
                (§ ass (:val ___b) ___val)
                (§ return ___val)
            )
            (throw (IllegalStateException. (String/format "Can't change/establish root binding of: %s with set", (object-array [ (:sym this) ]))))
        )
    )

    #_method
    (§ defn #_"Object" (§ method doSet) [#_"Var" this, #_"Object" ___val]
        (.set this, ___val)
    )

    #_method
    (§ defn #_"Object" (§ method doReset) [#_"Var" this, #_"Object" ___val]
        (.bindRoot this, ___val)
        ___val
    )

    #_method
    (§ defn #_"void" (§ method setMeta) [#_"Var" this, #_"IPersistentMap" ___m]
        ;; ensure these basis keys
        (ß this.resetMeta(___m.assoc(nameKey, (:sym this)).assoc(nsKey, (:ns this))))
        nil
    )

    #_method
    (§ defn #_"void" (§ method setMacro) [#_"Var" this]
        (ß this.alterMeta(assoc, RT'list-2(macroKey, RT'T)))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isMacro) [#_"Var" this]
        (ß RT'booleanCast-1o((.meta this).valAt(macroKey)))
    )

    #_method
    (§ defn #_"boolean" (§ method isPublic) [#_"Var" this]
        (not (RT'booleanCast-1o (ß (.meta this).valAt(privateKey))))
    )

    #_method
    (§ defn #_"Object" (§ method getRawRoot) [#_"Var" this]
        (:root this)
    )

    #_method
    (§ defn #_"Object" (§ method getTag) [#_"Var" this]
        (ß (.meta this).valAt(RT'TAG_KEY))
    )

    #_method
    (§ defn #_"void" (§ method setTag) [#_"Var" this, #_"Symbol" ___tag]
        (ß this.alterMeta(assoc, RT'list-2(RT'TAG_KEY, ___tag)))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasRoot) [#_"Var" this]
        (not (§ instance? Unbound (:root this)))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" (§ method bindRoot) [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß this.validate((.getValidator this), ___root))
            (let [#_"Object" ___oldroot (:root this)]
                (§ ass (:root this) ___root)
                (§ ass rev (+ rev 1))
                (ß this.alterMeta(Var'dissoc, RT'list-1(macroKey)))
                (.notifyWatches this, ___oldroot, (:root this))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method swapRoot) [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß this.validate((.getValidator this), ___root))
            (let [#_"Object" ___oldroot (:root this)]
                (§ ass (:root this) ___root)
                (§ ass rev (+ rev 1))
                (.notifyWatches this, ___oldroot, ___root)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method unbindRoot) [#_"Var" this]
        (§ sync this
            (§ ass (:root this) (Unbound'new this))
            (§ ass rev (+ rev 1))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method commuteRoot) [#_"Var" this, #_"IFn" ___fn]
        (§ sync this
            (let [#_"Object" ___newRoot (.invoke ___fn, (:root this))]
                (ß this.validate((.getValidator this), ___newRoot))
                (let [#_"Object" ___oldroot (:root this)]
                    (§ ass (:root this) ___newRoot)
                    (§ ass rev (+ rev 1))
                    (.notifyWatches this, ___oldroot, ___newRoot)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method alterRoot) [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (§ sync this
            (let [#_"Object" ___newRoot (ß ___fn.applyTo(RT'cons((:root this), ___args)))]
                (ß this.validate((.getValidator this), ___newRoot))
                (let [#_"Object" ___oldroot (:root this)]
                    (§ ass (:root this) ___newRoot)
                    (§ ass rev (+ rev 1))
                    (.notifyWatches this, ___oldroot, ___newRoot)
                    ___newRoot
                )
            )
        )
    )

    (defn #_"void" Var'pushThreadBindings [#_"Associative" ___bindings]
        (let [#_"Frame" ___f (.get Var'dvals)]
            (let [#_"Associative" ___bmap (:bindings ___f)]
                (loop-when-recur [#_"ISeq" ___bs (.seq ___bindings)] (some? ___bs) [(next ___bs)]
                    (let [#_"IMapEntry" ___e (cast' IMapEntry (first ___bs))]
                        (let [#_"Var" ___v (cast' Var (.key ___e))]
                            (when (not (:dynamic ___v))
                                (throw (IllegalStateException. (String/format "Can't dynamically bind non-dynamic var: %s/%s", (object-array [ (:ns ___v), (:sym ___v) ]))))
                            )
                            (ß ___v.validate((.getValidator ___v), (.val ___e)))
                            (.set (:threadBound ___v), true)
                            (§ ass ___bmap (ß ___bmap.assoc(___v, TBox'new(Thread/currentThread(), (.val ___e)))))
                        )
                    )
                )
                (ß Var'dvals.set(Frame'new(___bmap, ___f)))
                nil
            )
        )
    )

    (defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" ___f (:prev (.get Var'dvals))]
            (cond (nil? ___f)
                (do
                    (throw (IllegalStateException. "Pop without matching push"))
                )
                (= ___f Frame'TOP)
                (do
                    (.remove Var'dvals)
                )
                :else
                (do
                    (.set Var'dvals, ___f)
                )
            )
            nil
        )
    )

    (defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" ___f (.get Var'dvals)]
            (let [#_"IPersistentMap" ___ret PersistentHashMap'EMPTY]
                (loop-when-recur [#_"ISeq" ___bs (.seq (:bindings ___f))] (some? ___bs) [(next ___bs)]
                    (let [#_"IMapEntry" ___e (cast' IMapEntry (first ___bs))]
                        (let [#_"Var" ___v (cast' Var (.key ___e))]
                            (let [#_"TBox" ___b (cast' TBox (.val ___e))]
                                (§ ass ___ret (.assoc ___ret, ___v, (:val ___b)))
                            )
                        )
                    )
                )
                ___ret
            )
        )
    )

    #_method
    (§ defn #_"TBox" (§ method getThreadBinding) [#_"Var" this]
        (when (.get (:threadBound this))
            (let [#_"IMapEntry" ___e (.entryAt (:bindings (.get Var'dvals)), this)]
                (when (some? ___e)
                    (§ return (cast' TBox (.val ___e)))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method fn) [#_"Var" this]
        (cast' IFn (.deref this))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Var" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Var" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this]
        (.invoke (.fn this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil)),
                (Object[])Util'ret1(___args, (§ ass ___args nil))))
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Var" this, #_"ISeq" ___arglist]
        (ß (.fn this).applyTo(___arglist))
    )

    (def #_"IFn" Var'assoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___m, #_"Object" ___k, #_"Object" ___v]
                (RT'assoc ___m, ___k, ___v)
            )
        )
    )

    (def #_"IFn" Var'dissoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___c, #_"Object" ___k]
                (RT'dissoc ___c, ___k)
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (defn- #_"Volatile" Volatile'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"Volatile" Volatile'new [#_"Object" ___val]
        (let [this (Volatile'init)]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Volatile" this]
        (:val this)
    )

    #_method
    (§ defn #_"Object" (§ method reset) [#_"Volatile" this, #_"Object" ___newval]
        (§ ass (:val this) ___newval)
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" main'CLOIURE_MAIN (Symbol'intern-1 "cloiure.main"))
    (§ def- #_"Var" main'REQUIRE (RT'var-2 "cloiure.core", "require"))
    (§ def- #_"Var" main'MAIN (RT'var-2 "cloiure.main", "main"))

    (defn #_"void" -main [#_"String[]" ___args]
        (.invoke main'REQUIRE, main'CLOIURE_MAIN)
        (ß main'MAIN.applyTo(RT'seq(___args)))
        nil
    )
)
)
