(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(defmacro cond-let [x y & w]
    (let [x (if (vector? x) x [`_# x]) z (when (seq w) `(cond-let ~@w))]
        `(if-let ~x ~y ~z)))

(def % rem)
(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro cast' [_ x] #_(ensure symbol? _) `(do ~x))

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(import
    [java.io File FileInputStream FileNotFoundException FileOutputStream InputStreamReader IOException LineNumberReader OutputStreamWriter PrintWriter PushbackReader Reader #_StringReader StringWriter Writer]
  #_[java.lang Character Class Exception IllegalArgumentException IllegalStateException Integer Number NumberFormatException Object RuntimeException String StringBuilder Throwable UnsupportedOperationException]
    [java.lang.ref Reference ReferenceQueue SoftReference WeakReference]
    [java.lang.reflect Array Constructor Field InvocationHandler #_Method Modifier]
    [java.math BigDecimal BigInteger MathContext]
    [java.net JarURLConnection URL URLClassLoader URLConnection]
    [java.nio ByteBuffer]
    [java.nio.charset Charset]
    [java.security AccessController PrivilegedAction]
    [java.util ArrayList Arrays Collection Comparator HashMap HashSet IdentityHashMap Iterator LinkedList List Map Map$Entry NoSuchElementException Queue RandomAccess Set Stack TreeMap]
    [java.util.concurrent Callable ConcurrentHashMap ConcurrentMap CountDownLatch Executor ExecutorService Executors ThreadFactory TimeUnit]
    [java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicLong AtomicReference]
    [java.util.concurrent.locks ReentrantReadWriteLock]
    [java.util.regex Matcher Pattern]
    [cloiure.asm Attribute ByteVector ClassVisitor ClassWriter FieldVisitor Label MethodVisitor Opcodes Type]
    [cloiure.asm.commons GeneratorAdapter Method]
)

(declare AFn'new AFunction'new AMapEntry'new APersistentMap'new APersistentVector'new AReference'new ASeq'new ATransientMap'new AbortException'new AbstractMap'new ArgReader'new AssignParser'new Attribute'new BigDecimalOps'new BigIntOps'new BodyParser'new CaseParser'new ConstantParser'new CtorReader'new DefParser'new DefaultComparator'new DeftypeParser'new DoubleOps'new EmptyBuffer'new Error'new EvalReader'new Exception'new FieldExpr'new FnReader'new HostExpr'new HostParser'new IfParser'new IllegalArgumentException'new ImportParser'new IteratorSeqState'new LetFnParser'new LetParser'new CharacterReader'new CommentReader'new DiscardReader'new DispatchReader'new ListReader'new MapReader'new MetaReader'new NamespaceMapReader'new SetReader'new StringReader'new SymbolicValueReader'new UnmatchedDelimiterReader'new UnreadableReader'new VectorReader'new LiteralExpr'new LockingTransaction'new LongOps'new MethodExpr'new MonitorEnterParser'new MonitorExitParser'new NewParser'new NilExpr'new Number'new Obj'new OpsP'new Primordial'new PushbackReader'new RatioOps'new RecurParser'new RegexReader'new ReifyParser'new RestFn'new RetryEx'new RuntimeException'new SyntaxQuoteReader'new TheVarParser'new ThrowParser'new TryParser'new URLClassLoader'new UnquoteReader'new UntypedExpr'new VarReader'new)
(declare AFn'applyToHelper)
(declare ActionQueue'EMPTY ActionQueue'new)
(declare AgentAction'new AgentAction'doRun)
(declare Agent'CONTINUE Agent'FAIL Agent'sendThreadPoolCounter Agent'sendOffThreadPoolCounter Agent'createThreadFactory Agent'pooledExecutor Agent'soloExecutor Agent'nested Agent'shutdown Agent'new-1 Agent'new-2 Agent'dispatchAction Agent'releasePendingSends)
(declare KeySeq'create KeySeq'createFromMap KeySeq'new-2 KeySeq'new-3)
(declare ValSeq'create ValSeq'createFromMap ValSeq'new-2 ValSeq'new-3)
(declare APersistentMap'mapEquals APersistentMap'mapHash APersistentMap'mapHasheq APersistentMap'MAKE_ENTRY APersistentMap'MAKE_KEY APersistentMap'MAKE_VAL)
(declare APersistentSet'new APersistentSet'setEquals)
(declare VSeq'new-2 VSeq'new-3)
(declare RSeq'new-2 RSeq'new-3)
(declare SubVector'new)
(declare APersistentVector'doEquals APersistentVector'doEquiv)
(declare ARef'new-0 ARef'new-1)
(declare AReference'new-0 AReference'new-1)
(declare ArityException'new-2 ArityException'new-3)
(declare ArrayChunk'new-1 ArrayChunk'new-2 ArrayChunk'new-3)
(declare ArrayIter_int'new ArrayIter_float'new ArrayIter_double'new ArrayIter_long'new ArrayIter_byte'new ArrayIter_char'new ArrayIter_short'new ArrayIter_boolean'new ArrayIter'EMPTY_ITERATOR ArrayIter'create-0 ArrayIter'create-1 ArrayIter'createFromObject ArrayIter'new)
(declare ArraySeq_int'new ArraySeq_float'new ArraySeq_double'new ArraySeq_long'new ArraySeq_byte'new ArraySeq_char'new ArraySeq_short'new ArraySeq_boolean'new ArraySeq'create-0 ArraySeq'create-1 ArraySeq'createFromObject ArraySeq'new-2 ArraySeq'new-3)
(declare ASeq'new-1 ASeq'new-0)
(declare Atom'new-1 Atom'new-2)
(declare ATransientMap'NOT_FOUND)
(declare ATransientSet'new)
(declare BigInt'ZERO BigInt'ONE BigInt'new BigInt'fromBigInteger BigInt'fromLong BigInt'valueOf)
(declare Binding'new-1 Binding'new-2)
(declare Box'new)
(declare ChunkBuffer'new)
(declare ChunkedCons'new-3 ChunkedCons'new-2)
(declare DefExpr'bindRootMethod DefExpr'setTagMethod DefExpr'setMetaMethod DefExpr'setDynamicMethod DefExpr'internVar DefExpr'new)
(declare AssignExpr'new)
(declare VarExpr'getMethod VarExpr'setMethod VarExpr'new)
(declare TheVarExpr'new)
(declare KeywordExpr'new)
(declare ImportExpr'forNameMethod ImportExpr'importClassMethod ImportExpr'derefMethod ImportExpr'new)
(declare HostExpr'BOOLEAN_TYPE HostExpr'CHAR_TYPE HostExpr'INTEGER_TYPE HostExpr'LONG_TYPE HostExpr'FLOAT_TYPE HostExpr'DOUBLE_TYPE HostExpr'SHORT_TYPE HostExpr'BYTE_TYPE HostExpr'NUMBER_TYPE HostExpr'charValueMethod HostExpr'booleanValueMethod HostExpr'charValueOfMethod HostExpr'intValueOfMethod HostExpr'longValueOfMethod HostExpr'floatValueOfMethod HostExpr'doubleValueOfMethod HostExpr'shortValueOfMethod HostExpr'byteValueOfMethod HostExpr'intValueMethod HostExpr'longValueMethod HostExpr'floatValueMethod HostExpr'doubleValueMethod HostExpr'byteValueMethod HostExpr'shortValueMethod HostExpr'fromIntMethod HostExpr'fromLongMethod HostExpr'fromDoubleMethod HostExpr'emitBoxReturn HostExpr'emitUnboxArg HostExpr'maybeClass HostExpr'maybeSpecialTag HostExpr'tagToClass)
(declare InstanceFieldExpr'invokeNoArgInstanceMember InstanceFieldExpr'setInstanceFieldMethod InstanceFieldExpr'new)
(declare StaticFieldExpr'new)
(declare MethodExpr'emitArgsAsArray MethodExpr'emitTypedArgs)
(declare InstanceMethodExpr'invokeInstanceMethodMethod InstanceMethodExpr'new)
(declare StaticMethodExpr'forNameMethod StaticMethodExpr'invokeStaticMethodMethod StaticMethodExpr'new)
(declare UnresolvedVarExpr'new)
(declare NumberExpr'new NumberExpr'parse)
(declare ConstantParser'formKey)
(declare ConstantExpr'new)
(declare BooleanExpr'new)
(declare StringExpr'new)
(declare MonitorEnterExpr'new)
(declare MonitorExitExpr'new)
(declare CatchClause'new)
(declare TryExpr'new)
(declare ThrowExpr'new)
(declare NewExpr'invokeConstructorMethod NewExpr'forNameMethod NewExpr'new)
(declare MetaExpr'IOBJ_TYPE MetaExpr'withMetaMethod MetaExpr'new)
(declare IfExpr'new)
(declare EmptyExpr'HASHMAP_TYPE EmptyExpr'HASHSET_TYPE EmptyExpr'VECTOR_TYPE EmptyExpr'IVECTOR_TYPE EmptyExpr'TUPLE_TYPE EmptyExpr'LIST_TYPE EmptyExpr'EMPTY_LIST_TYPE EmptyExpr'new)
(declare ListExpr'arrayToListMethod ListExpr'new)
(declare MapExpr'mapMethod MapExpr'mapUniqueKeysMethod MapExpr'new MapExpr'parse)
(declare SetExpr'setMethod SetExpr'new SetExpr'parse)
(declare VectorExpr'vectorMethod VectorExpr'new VectorExpr'parse)
(declare KeywordInvokeExpr'ILOOKUP_TYPE KeywordInvokeExpr'new)
(declare InstanceOfExpr'new)
(declare StaticInvokeExpr'new StaticInvokeExpr'parse)
(declare InvokeExpr'onKey InvokeExpr'methodMapKey InvokeExpr'new InvokeExpr'parse)
(declare SourceDebugExtensionAttribute'new)
(declare FnExpr'aFnType FnExpr'restFnType FnExpr'new FnExpr'parse)
(declare ObjExpr'CONST_PREFIX ObjExpr'voidctor ObjExpr'DYNAMIC_CLASSLOADER_TYPE ObjExpr'getClassMethod ObjExpr'getClassLoaderMethod ObjExpr'getConstantsMethod ObjExpr'readStringMethod ObjExpr'ILOOKUP_SITE_TYPE ObjExpr'ILOOKUP_THUNK_TYPE ObjExpr'KEYWORD_LOOKUPSITE_TYPE ObjExpr'new ObjExpr'trimGenID ObjExpr'varGetMethod ObjExpr'varGetRawMethod)
(declare PathNode'new)
(declare FnMethod'new FnMethod'classChar FnMethod'primInterface FnMethod'parse)
(declare ObjMethod'new ObjMethod'emitBody)
(declare LocalBinding'new)
(declare LocalBindingExpr'new)
(declare BodyExpr'new)
(declare BindingInit'new)
(declare LetFnExpr'new)
(declare LetExpr'new)
(declare RecurExpr'new)
(declare CompilerException'new)
(declare NewInstanceExpr'new NewInstanceExpr'build NewInstanceExpr'compileStub NewInstanceExpr'interfaceNames NewInstanceExpr'slashname NewInstanceExpr'msig NewInstanceExpr'considerMethod NewInstanceExpr'gatherMethods-2m NewInstanceExpr'gatherMethods-2s)
(declare NewInstanceMethod'dummyThis NewInstanceMethod'new NewInstanceMethod'msig NewInstanceMethod'parse NewInstanceMethod'findMethodsWithNameAndArity NewInstanceMethod'findMethodsWithName)
(declare MethodParamExpr'new)
(declare CaseExpr'NUMBER_TYPE CaseExpr'intValueMethod CaseExpr'hashMethod CaseExpr'hashCodeMethod CaseExpr'equivMethod CaseExpr'compactKey CaseExpr'sparseKey CaseExpr'hashIdentityKey CaseExpr'hashEquivKey CaseExpr'intKey CaseExpr'new CaseExpr'emitExpr)
(declare Compiler'DEF Compiler'LOOP Compiler'RECUR Compiler'IF Compiler'LET Compiler'LETFN Compiler'DO Compiler'FN Compiler'FNONCE Compiler'QUOTE Compiler'THE_VAR Compiler'DOT Compiler'ASSIGN Compiler'TRY Compiler'CATCH Compiler'FINALLY Compiler'THROW Compiler'MONITOR_ENTER Compiler'MONITOR_EXIT Compiler'IMPORT Compiler'DEFTYPE Compiler'CASE Compiler'CLASS Compiler'NEW Compiler'THIS Compiler'REIFY Compiler'LIST Compiler'HASHMAP Compiler'VECTOR Compiler'IDENTITY Compiler'_AMP_ Compiler'ISEQ Compiler'loadNs Compiler'inlineKey Compiler'inlineAritiesKey Compiler'volatileKey Compiler'implementsKey Compiler'COMPILE_STUB_PREFIX Compiler'protocolKey Compiler'onKey Compiler'dynamicKey Compiler'redefKey Compiler'NS Compiler'IN_NS Compiler'specials Compiler'MAX_POSITIONAL_ARITY Compiler'OBJECT_TYPE Compiler'KEYWORD_TYPE Compiler'VAR_TYPE Compiler'SYMBOL_TYPE Compiler'IFN_TYPE Compiler'AFUNCTION_TYPE Compiler'RT_TYPE Compiler'NUMBERS_TYPE Compiler'CLASS_TYPE Compiler'NS_TYPE Compiler'UTIL_TYPE Compiler'REFLECTOR_TYPE Compiler'THROWABLE_TYPE Compiler'BOOLEAN_OBJECT_TYPE Compiler'IPERSISTENTMAP_TYPE Compiler'IOBJ_TYPE Compiler'TUPLE_TYPE Compiler'createTupleMethods Compiler'ARG_TYPES Compiler'EXCEPTION_TYPES Compiler'LOCAL_ENV Compiler'LOOP_LOCALS Compiler'LOOP_LABEL Compiler'CONSTANTS Compiler'CONSTANT_IDS Compiler'KEYWORD_CALLSITES Compiler'PROTOCOL_CALLSITES Compiler'VAR_CALLSITES Compiler'KEYWORDS Compiler'VARS Compiler'METHOD Compiler'IN_CATCH_FINALLY Compiler'METHOD_RETURN_CONTEXT Compiler'NO_RECUR Compiler'LOADER Compiler'INSTANCE Compiler'LINE Compiler'COLUMN Compiler'lineDeref Compiler'columnDeref Compiler'NEXT_LOCAL_NUM Compiler'RET_LOCAL_NUM Compiler'COMPILE_STUB_SYM Compiler'COMPILE_STUB_CLASS Compiler'CLEAR_PATH Compiler'CLEAR_ROOT Compiler'CLEAR_SITES Compiler'RECUR_CLASS Compiler'isSpecial Compiler'inTailCall Compiler'resolveSymbol Compiler'maybePrimitiveType Compiler'maybeJavaClass Compiler'NIL_EXPR Compiler'TRUE_EXPR Compiler'FALSE_EXPR Compiler'subsumes Compiler'getTypeStringForArgs Compiler'getMatchingParams Compiler'CHAR_MAP Compiler'DEMUNGE_MAP Compiler'DEMUNGE_PATTERN Compiler'munge Compiler'demunge Compiler'clearPathRoot Compiler'registerLocal Compiler'getAndIncLocalNum Compiler'analyze-2 Compiler'analyze-3 Compiler'isMacro Compiler'isInline Compiler'namesStaticMember Compiler'preserveTag Compiler'MACRO_CHECK Compiler'MACRO_CHECK_LOADING Compiler'MACRO_CHECK_LOCK Compiler'ensureMacroCheck Compiler'checkSpecs Compiler'macroexpand1 Compiler'macroexpand Compiler'analyzeSeq Compiler'eval-1 Compiler'eval-2 Compiler'registerConstant Compiler'registerKeyword Compiler'registerKeywordCallsite Compiler'registerProtocolCallsite Compiler'registerVarCallsite Compiler'fwdPath Compiler'commonPath Compiler'analyzeSymbol Compiler'destubClassName Compiler'getType Compiler'resolve-2 Compiler'resolve-1 Compiler'namespaceFor-1 Compiler'namespaceFor-2 Compiler'resolveIn Compiler'maybeResolveIn Compiler'lookupVar-3 Compiler'lookupVar-2 Compiler'registerVar Compiler'currentNS Compiler'closeOver Compiler'referenceLocal Compiler'tagOf Compiler'consumeWhitespaces Compiler'load Compiler'pushNS Compiler'pushNSandLoader Compiler'getLookupThunk Compiler'inty Compiler'retType Compiler'primClass-1s Compiler'tagClass Compiler'primClass-1c Compiler'boxClass Compiler'emptyVarCallSites)
(declare Cons'new-2 Cons'new-3)
(declare Cycle'new-3 Cycle'new-5 Cycle'create)
(declare Delay'new Delay'force)
(declare DynamicClassLoader'classCache DynamicClassLoader'RQ DynamicClassLoader'new DynamicClassLoader'findInMemoryClass)
(declare ExceptionInfo'new-2 ExceptionInfo'new-3)
(declare FnLoaderThunk'new)
(declare Intrinsics'oa Intrinsics'ops Intrinsics'preds)
(declare Iterate'UNREALIZED_SEED Iterate'new-3 Iterate'new-5 Iterate'create)
(declare IteratorSeq'create IteratorSeq'new-1 IteratorSeq'new-3)
(declare Keyword'TABLE Keyword'RQ Keyword'intern Keyword'new Keyword'find Keyword'find-2 Keyword'find-1)
(declare KeywordLookupSite'new)
(declare LazilyPersistentVector'createOwning LazilyPersistentVector'fcount LazilyPersistentVector'create)
(declare LazySeq'new-1 LazySeq'new-2)
(declare LineNumberingPushbackReader'newline LineNumberingPushbackReader'new-1 LineNumberingPushbackReader'new-2)
(declare LispReaderException'new)
(declare RegexReader'stringrdr)
(declare SymbolicValueReader'specials)
(declare WrappingReader'new)
(declare SyntaxQuoteReader'syntaxQuote SyntaxQuoteReader'sqExpandList SyntaxQuoteReader'flattenMap)
(declare LispReader'QUOTE LispReader'THE_VAR LispReader'UNQUOTE LispReader'UNQUOTE_SPLICING LispReader'CONCAT LispReader'SEQ LispReader'LIST LispReader'APPLY LispReader'HASHMAP LispReader'HASHSET LispReader'VECTOR LispReader'WITH_META LispReader'META LispReader'DEREF LispReader'UNKNOWN LispReader'macros LispReader'dispatchMacros LispReader'symbolPat LispReader'intPat LispReader'ratioPat LispReader'floatPat LispReader'GENSYM_ENV LispReader'ARG_ENV LispReader'ctorReader LispReader'isWhitespace LispReader'unread LispReader'read1 LispReader'OPT_EOF LispReader'EOFTHROW LispReader'read-1 LispReader'read-4 LispReader'read-5 LispReader'ensurePending LispReader'read-8 LispReader'readToken LispReader'readNumber LispReader'readUnicodeChar-4 LispReader'readUnicodeChar-5 LispReader'interpretToken LispReader'matchSymbol LispReader'matchNumber LispReader'getMacro LispReader'isMacro LispReader'isTerminatingMacro LispReader'garg LispReader'registerArg LispReader'isUnquoteSplicing LispReader'isUnquote LispReader'READ_EOF LispReader'READ_FINISHED LispReader'readDelimitedList)
(declare LockingTransactionInfo'new)
(declare CFn'new)
(declare Notify'new)
(declare LockingTransaction'RETRY_LIMIT LockingTransaction'LOCK_WAIT_MSECS LockingTransaction'BARGE_WAIT_NANOS LockingTransaction'RUNNING LockingTransaction'COMMITTING LockingTransaction'RETRY LockingTransaction'KILLED LockingTransaction'COMMITTED LockingTransaction'transaction LockingTransaction'lastPoint LockingTransaction'getEx LockingTransaction'isRunning LockingTransaction'getRunning LockingTransaction'runInTransaction)
(declare LongRangeIterator'new)
(declare LongChunk'new)
(declare LongRange'CHUNK_SIZE LongRange'positiveStep LongRange'negativeStep LongRange'new-4 LongRange'new-6 LongRange'new-7 LongRange'create-1 LongRange'create-2 LongRange'create-3)
(declare MapEntry'create MapEntry'new)
(declare Entry'new)
(declare MethodImplCache'new-2 MethodImplCache'new-5 MethodImplCache'new-3)
(declare MultiFn'assoc MultiFn'dissoc MultiFn'isa MultiFn'parents MultiFn'new)
(declare Murmur3'seed Murmur3'C1 Murmur3'C2 Murmur3'hashInt Murmur3'hashLong Murmur3'hashUnencodedChars Murmur3'mixCollHash Murmur3'hashOrdered Murmur3'hashUnordered Murmur3'mixK1 Murmur3'mixH1 Murmur3'fmix)
(declare Namespace'namespaces Namespace'new Namespace'all Namespace'areDifferentInstancesOfSameClassName Namespace'findOrCreate Namespace'remove Namespace'find)
(declare LongOps'gcd)
(declare RatioOps'normalizeRet)
(declare BigDecimalOps'MATH_CONTEXT)
(declare Numbers'isZero-1o Numbers'isPos-1o Numbers'isNeg-1o Numbers'minus-1o Numbers'minusP-1o Numbers'inc-1o Numbers'incP-1o Numbers'dec-1o Numbers'decP-1o Numbers'add-2oo Numbers'addP-2oo Numbers'minus-2oo Numbers'minusP-2oo Numbers'multiply-2oo Numbers'multiplyP-2oo Numbers'divide-2oo Numbers'quotient-2oo Numbers'remainder-2oo Numbers'quotient-2dd Numbers'remainder-2dd Numbers'equiv-2oo Numbers'equiv-2nn Numbers'equal Numbers'lt-2oo Numbers'lte-2oo Numbers'gt-2oo Numbers'gte-2oo Numbers'compare Numbers'toBigInt Numbers'toBigInteger Numbers'toBigDecimal Numbers'toRatio Numbers'rationalize Numbers'reduceBigInt Numbers'divide-2ii Numbers'shiftLeftInt Numbers'shiftLeft-2oo Numbers'shiftLeft-2ol Numbers'shiftLeft-2lo Numbers'shiftLeft-2ll Numbers'shiftRightInt Numbers'shiftRight-2oo Numbers'shiftRight-2ol Numbers'shiftRight-2lo Numbers'shiftRight-2ll Numbers'unsignedShiftRightInt Numbers'unsignedShiftRight-2oo Numbers'unsignedShiftRight-2ol Numbers'unsignedShiftRight-2lo Numbers'unsignedShiftRight-2ll Numbers'LONG_OPS Numbers'DOUBLE_OPS Numbers'RATIO_OPS Numbers'BIGINT_OPS Numbers'BIGDECIMAL_OPS Numbers'ops Numbers'hasheqFrom Numbers'hasheq Numbers'category Numbers'bitOpsCast Numbers'float_array-2 Numbers'float_array-1 Numbers'double_array-2 Numbers'double_array-1 Numbers'int_array-2 Numbers'int_array-1 Numbers'long_array-2 Numbers'long_array-1 Numbers'short_array-2 Numbers'short_array-1 Numbers'char_array-2 Numbers'char_array-1 Numbers'byte_array-2 Numbers'byte_array-1 Numbers'boolean_array-2 Numbers'boolean_array-1 Numbers'booleans Numbers'bytes Numbers'chars Numbers'shorts Numbers'floats Numbers'doubles Numbers'ints Numbers'longs Numbers'num-1o Numbers'num-1f Numbers'num-1d Numbers'add-2dd Numbers'addP-2dd Numbers'minus-2dd Numbers'minusP-2dd Numbers'minus-1d Numbers'minusP-1d Numbers'inc-1d Numbers'incP-1d Numbers'dec-1d Numbers'decP-1d Numbers'multiply-2dd Numbers'multiplyP-2dd Numbers'divide-2dd Numbers'equiv-2dd Numbers'lt-2dd Numbers'lte-2dd Numbers'gt-2dd Numbers'gte-2dd Numbers'isPos-1d Numbers'isNeg-1d Numbers'isZero-1d Numbers'throwIntOverflow Numbers'unchecked_int_add Numbers'unchecked_int_subtract Numbers'unchecked_int_negate Numbers'unchecked_int_inc Numbers'unchecked_int_dec Numbers'unchecked_int_multiply Numbers'not-1o Numbers'not-1l Numbers'and-2oo Numbers'and-2ol Numbers'and-2lo Numbers'and-2ll Numbers'or-2oo Numbers'or-2ol Numbers'or-2lo Numbers'or-2ll Numbers'xor-2oo Numbers'xor-2ol Numbers'xor-2lo Numbers'xor-2ll Numbers'andNot-2oo Numbers'andNot-2ol Numbers'andNot-2lo Numbers'andNot-2ll Numbers'clearBit-2oo Numbers'clearBit-2ol Numbers'clearBit-2lo Numbers'clearBit-2ll Numbers'setBit-2oo Numbers'setBit-2ol Numbers'setBit-2lo Numbers'setBit-2ll Numbers'flipBit-2oo Numbers'flipBit-2ol Numbers'flipBit-2lo Numbers'flipBit-2ll Numbers'testBit-2oo Numbers'testBit-2ol Numbers'testBit-2lo Numbers'testBit-2ll Numbers'unchecked_int_divide Numbers'unchecked_int_remainder Numbers'num-1l Numbers'unchecked_add-2ll Numbers'unchecked_minus-2ll Numbers'unchecked_multiply-2ll Numbers'unchecked_minus-1l Numbers'unchecked_inc-1l Numbers'unchecked_dec-1l Numbers'unchecked_add-2oo Numbers'unchecked_minus-2oo Numbers'unchecked_multiply-2oo Numbers'unchecked_minus-1o Numbers'unchecked_inc-1o Numbers'unchecked_dec-1o Numbers'unchecked_add-2dd Numbers'unchecked_minus-2dd Numbers'unchecked_multiply-2dd Numbers'unchecked_minus-1d Numbers'unchecked_inc-1d Numbers'unchecked_dec-1d Numbers'unchecked_add-2do Numbers'unchecked_minus-2do Numbers'unchecked_multiply-2do Numbers'unchecked_add-2od Numbers'unchecked_minus-2od Numbers'unchecked_multiply-2od Numbers'unchecked_add-2dl Numbers'unchecked_minus-2dl Numbers'unchecked_multiply-2dl Numbers'unchecked_add-2ld Numbers'unchecked_minus-2ld Numbers'unchecked_multiply-2ld Numbers'unchecked_add-2lo Numbers'unchecked_minus-2lo Numbers'unchecked_multiply-2lo Numbers'unchecked_add-2ol Numbers'unchecked_minus-2ol Numbers'unchecked_multiply-2ol Numbers'quotient-2do Numbers'quotient-2od Numbers'quotient-2lo Numbers'quotient-2ol Numbers'quotient-2dl Numbers'quotient-2ld Numbers'remainder-2do Numbers'remainder-2od Numbers'remainder-2lo Numbers'remainder-2ol Numbers'remainder-2dl Numbers'remainder-2ld Numbers'add-2ll Numbers'addP-2ll Numbers'minus-2ll Numbers'minusP-2ll Numbers'minus-1l Numbers'minusP-1l Numbers'inc-1l Numbers'incP-1l Numbers'dec-1l Numbers'decP-1l Numbers'multiply-2ll Numbers'multiplyP-2ll Numbers'quotient-2ll Numbers'remainder-2ll Numbers'equiv-2ll Numbers'lt-2ll Numbers'lte-2ll Numbers'gt-2ll Numbers'gte-2ll Numbers'isPos-1l Numbers'isNeg-1l Numbers'isZero-1l Numbers'add-2lo Numbers'add-2ol Numbers'addP-2lo Numbers'addP-2ol Numbers'add-2do Numbers'add-2od Numbers'add-2dl Numbers'add-2ld Numbers'addP-2do Numbers'addP-2od Numbers'addP-2dl Numbers'addP-2ld Numbers'minus-2lo Numbers'minus-2ol Numbers'minusP-2lo Numbers'minusP-2ol Numbers'minus-2do Numbers'minus-2od Numbers'minus-2dl Numbers'minus-2ld Numbers'minusP-2do Numbers'minusP-2od Numbers'minusP-2dl Numbers'minusP-2ld Numbers'multiply-2lo Numbers'multiply-2ol Numbers'multiplyP-2lo Numbers'multiplyP-2ol Numbers'multiply-2do Numbers'multiply-2od Numbers'multiply-2dl Numbers'multiply-2ld Numbers'multiplyP-2do Numbers'multiplyP-2od Numbers'multiplyP-2dl Numbers'multiplyP-2ld Numbers'divide-2lo Numbers'divide-2ol Numbers'divide-2do Numbers'divide-2od Numbers'divide-2dl Numbers'divide-2ld Numbers'divide-2ll Numbers'lt-2lo Numbers'lt-2ol Numbers'lt-2do Numbers'lt-2od Numbers'lt-2dl Numbers'lt-2ld Numbers'lte-2lo Numbers'lte-2ol Numbers'lte-2do Numbers'lte-2od Numbers'lte-2dl Numbers'lte-2ld Numbers'gt-2lo Numbers'gt-2ol Numbers'gt-2do Numbers'gt-2od Numbers'gt-2dl Numbers'gt-2ld Numbers'gte-2lo Numbers'gte-2ol Numbers'gte-2do Numbers'gte-2od Numbers'gte-2dl Numbers'gte-2ld Numbers'equiv-2lo Numbers'equiv-2ol Numbers'equiv-2do Numbers'equiv-2od Numbers'equiv-2dl Numbers'equiv-2ld Numbers'isNaN Numbers'max-2dd Numbers'max-2dl Numbers'max-2do Numbers'max-2ld Numbers'max-2ll Numbers'max-2lo Numbers'max-2ol Numbers'max-2od Numbers'max-2oo Numbers'min-2dd Numbers'min-2dl Numbers'min-2do Numbers'min-2ld Numbers'min-2ll Numbers'min-2lo Numbers'min-2ol Numbers'min-2od Numbers'min-2oo)
(declare Obj'new-1 Obj'new-0)
(declare MSeq'new-2 MSeq'new-3)
(declare MIter'new-2 MIter'new-3)
(declare TransientArrayMap'new)
(declare PersistentArrayMap'EMPTY PersistentArrayMap'HASHTABLE_THRESHOLD PersistentArrayMap'create PersistentArrayMap'new-0 PersistentArrayMap'createWithCheck PersistentArrayMap'createAsIfByAssoc PersistentArrayMap'new-1 PersistentArrayMap'new-2 PersistentArrayMap'equalKey)
(declare TransientHashMap'new-1 TransientHashMap'new-5)
(declare HSeq'create-1 HSeq'create-4 HSeq'new)
(declare HIter'new)
(declare ArrayNode'new ArrayNode'foldTasks)
(declare BitmapIndexedNode'EMPTY BitmapIndexedNode'new)
(declare HashCollisionNode'new)
(declare NodeIter'NULL NodeIter'new)
(declare NodeSeq'new-2 NodeSeq'create-1 NodeSeq'kvreduce NodeSeq'create-3 NodeSeq'new-4)
(declare PersistentHashMap'EMPTY PersistentHashMap'NOT_FOUND PersistentHashMap'create-1m PersistentHashMap'create-1a PersistentHashMap'createWithCheck-1a PersistentHashMap'create-1s PersistentHashMap'createWithCheck-1s PersistentHashMap'create-2 PersistentHashMap'new-4 PersistentHashMap'new-5 PersistentHashMap'hash PersistentHashMap'EMPTY_ITER PersistentHashMap'mask PersistentHashMap'cloneAndSet-3 PersistentHashMap'cloneAndSet-5 PersistentHashMap'removePair PersistentHashMap'createNode-6 PersistentHashMap'createNode-7 PersistentHashMap'bitpos)
(declare TransientHashSet'new)
(declare PersistentHashSet'EMPTY PersistentHashSet'create-1a PersistentHashSet'create-1l PersistentHashSet'create-1s PersistentHashSet'createWithCheck-1a PersistentHashSet'createWithCheck-1l PersistentHashSet'createWithCheck-1s PersistentHashSet'new)
(declare Primordial'invokeStatic)
(declare EmptyList'HASHEQ EmptyList'new EmptyList'hasheq)
(declare PersistentList'creator PersistentList'EMPTY PersistentList'new-1 PersistentList'new-4 PersistentList'create)
(declare QSeq'new-2 QSeq'new-3)
(declare PersistentQueue'EMPTY PersistentQueue'new)
(declare TNode'new)
(declare Black'new)
(declare BlackVal'new)
(declare BlackBranch'new)
(declare BlackBranchVal'new)
(declare Red'new)
(declare RedVal'new)
(declare RedBranch'new)
(declare RedBranchVal'new)
(declare TSeq'new-2 TSeq'new-3 TSeq'new-4 TSeq'create TSeq'push)
(declare NodeIterator'new)
(declare KeyIterator'new)
(declare ValIterator'new)
(declare PersistentTreeMap'EMPTY PersistentTreeMap'create-1m PersistentTreeMap'new-0 PersistentTreeMap'new-1 PersistentTreeMap'new-2 PersistentTreeMap'new-4m PersistentTreeMap'create-1s PersistentTreeMap'create-2 PersistentTreeMap'append PersistentTreeMap'balanceLeftDel PersistentTreeMap'balanceRightDel PersistentTreeMap'leftBalance PersistentTreeMap'rightBalance PersistentTreeMap'new-4c PersistentTreeMap'red PersistentTreeMap'black)
(declare PersistentTreeSet'EMPTY PersistentTreeSet'create-1 PersistentTreeSet'create-2 PersistentTreeSet'new)
(declare VNode'new-2 VNode'new-1)
(declare ChunkedSeq'new-3 ChunkedSeq'new-5 ChunkedSeq'new-4)
(declare TransientVector'new-4 TransientVector'new-1 TransientVector'editableRoot TransientVector'editableTail TransientVector'NOT_FOUND)
(declare PersistentVector'NOEDIT PersistentVector'EMPTY_NODE PersistentVector'EMPTY PersistentVector'TRANSIENT_VECTOR_CONJ PersistentVector'adopt PersistentVector'create-1r PersistentVector'create-1s PersistentVector'create-1l PersistentVector'create-1i PersistentVector'create-1a PersistentVector'new-4 PersistentVector'new-5 PersistentVector'doAssoc PersistentVector'newPath)
(declare ProxyHandler'new)
(declare RangeIterator'new)
(declare Range'CHUNK_SIZE Range'positiveStep Range'negativeStep Range'new-4 Range'new-6 Range'new-7 Range'create-1 Range'create-2 Range'create-3)
(declare Ratio'new)
(declare RecordIterator'new)
(declare Reduced'new)
(declare RefTVal'new-3 RefTVal'new-2)
(declare Ref'ids Ref'new-1 Ref'new-2)
(declare Reflector'invokeInstanceMethod Reflector'getCauseOrElse Reflector'throwCauseOrElseException Reflector'noMethodReport Reflector'invokeMatchingMethod Reflector'getAsMethodOfPublicBase Reflector'isMatch Reflector'invokeConstructor Reflector'invokeStaticMethodVariadic Reflector'invokeStaticMethod-3s Reflector'invokeStaticMethod-3c Reflector'getStaticField-2s Reflector'getStaticField-2c Reflector'setStaticField-3s Reflector'setStaticField-3c Reflector'getInstanceField Reflector'setInstanceField Reflector'invokeNoArgInstanceMember Reflector'invokeInstanceMember-2 Reflector'invokeInstanceMember-3o Reflector'invokeInstanceMember-3a Reflector'getField Reflector'getMethods Reflector'boxArg Reflector'boxArgs Reflector'paramArgTypeMatch Reflector'isCongruent Reflector'prepRet)
(declare Repeat'INFINITE Repeat'new-2 Repeat'new-3 Repeat'create-1 Repeat'create-2)
(declare RestFn'ontoArrayPrepend RestFn'findKey)
(declare RT'T RT'F RT'LOADER_SUFFIX RT'DEFAULT_IMPORTS RT'UTF8 RT'CLOIURE_NS RT'OUT RT'IN RT'ERR RT'TAG_KEY RT'CONST_KEY RT'AGENT RT'READEVAL RT'ASSERT RT'MATH_CONTEXT RT'LINE_KEY RT'COLUMN_KEY RT'DECLARED_KEY RT'DOC_KEY RT'IN_NAMESPACE RT'NAMESPACE RT'IDENTICAL RT'CURRENT_NS RT'FLUSH_ON_NEWLINE RT'PRINT_READABLY RT'WARN_ON_REFLECTION RT'ALLOW_UNRESOLVED_VARS RT'READER_RESOLVER RT'IN_NS_VAR RT'NS_VAR RT'FN_LOADER_VAR RT'PRINT_INITIALIZED RT'PR_ON RT'inNamespace RT'bootNamespace RT'errPrintWriter RT'EMPTY_ARRAY RT'DEFAULT_COMPARATOR RT'ID RT'CHECK_SPEC_ASSERTS RT'INSTRUMENT_MACROS RT'CHECK_SPECS RT'keyword RT'var RT'loadResourceScript RT'lastModified RT'load-1 RT'load-2 RT'nextID RT'CHUNK_SIZE RT'chunkIteratorSeq RT'seq RT'seqFrom RT'canSeq RT'iter RT'seqOrElse RT'keys RT'vals RT'meta RT'count RT'countFrom RT'conj RT'cons RT'first RT'second RT'third RT'fourth RT'next RT'more RT'peek RT'pop RT'get-2 RT'getFrom-2 RT'get-3 RT'getFrom-3 RT'assoc RT'contains RT'find RT'findKey RT'dissoc RT'nth-2 RT'nthFrom-2 RT'nth-3 RT'nthFrom-3 RT'assocN RT'hasTag RT'box-1o RT'box-1c RT'box-1z RT'box-1Z RT'box-1b RT'box-1s RT'box-1i RT'box-1l RT'box-1f RT'box-1d RT'charCast-1o RT'charCast-1b RT'charCast-1s RT'charCast-1c RT'charCast-1i RT'charCast-1l RT'charCast-1f RT'charCast-1d RT'booleanCast-1o RT'booleanCast-1b RT'byteCast-1o RT'byteCast-1b RT'byteCast-1s RT'byteCast-1i RT'byteCast-1l RT'byteCast-1f RT'byteCast-1d RT'shortCast-1o RT'shortCast-1b RT'shortCast-1s RT'shortCast-1i RT'shortCast-1l RT'shortCast-1f RT'shortCast-1d RT'intCast-1o RT'intCast-1c RT'intCast-1b RT'intCast-1s RT'intCast-1i RT'intCast-1f RT'intCast-1l RT'intCast-1d RT'longCast-1o RT'longCast-1b RT'longCast-1s RT'longCast-1i RT'longCast-1f RT'longCast-1l RT'longCast-1d RT'floatCast-1o RT'floatCast-1b RT'floatCast-1s RT'floatCast-1i RT'floatCast-1f RT'floatCast-1l RT'floatCast-1d RT'doubleCast-1o RT'doubleCast-1b RT'doubleCast-1s RT'doubleCast-1i RT'doubleCast-1f RT'doubleCast-1l RT'doubleCast-1d RT'uncheckedByteCast-1o RT'uncheckedByteCast-1b RT'uncheckedByteCast-1s RT'uncheckedByteCast-1i RT'uncheckedByteCast-1l RT'uncheckedByteCast-1f RT'uncheckedByteCast-1d RT'uncheckedShortCast-1o RT'uncheckedShortCast-1b RT'uncheckedShortCast-1s RT'uncheckedShortCast-1i RT'uncheckedShortCast-1l RT'uncheckedShortCast-1f RT'uncheckedShortCast-1d RT'uncheckedCharCast-1o RT'uncheckedCharCast-1b RT'uncheckedCharCast-1s RT'uncheckedCharCast-1c RT'uncheckedCharCast-1i RT'uncheckedCharCast-1l RT'uncheckedCharCast-1f RT'uncheckedCharCast-1d RT'uncheckedIntCast-1o RT'uncheckedIntCast-1b RT'uncheckedIntCast-1s RT'uncheckedIntCast-1c RT'uncheckedIntCast-1i RT'uncheckedIntCast-1l RT'uncheckedIntCast-1f RT'uncheckedIntCast-1d RT'uncheckedLongCast-1o RT'uncheckedLongCast-1b RT'uncheckedLongCast-1s RT'uncheckedLongCast-1i RT'uncheckedLongCast-1l RT'uncheckedLongCast-1f RT'uncheckedLongCast-1d RT'uncheckedFloatCast-1o RT'uncheckedFloatCast-1b RT'uncheckedFloatCast-1s RT'uncheckedFloatCast-1i RT'uncheckedFloatCast-1l RT'uncheckedFloatCast-1f RT'uncheckedFloatCast-1d RT'uncheckedDoubleCast-1o RT'uncheckedDoubleCast-1b RT'uncheckedDoubleCast-1s RT'uncheckedDoubleCast-1i RT'uncheckedDoubleCast-1l RT'uncheckedDoubleCast-1f RT'uncheckedDoubleCast-1d RT'map RT'mapUniqueKeys RT'set RT'vector RT'subvec RT'list-0 RT'list-1 RT'list-2 RT'list-3 RT'list-4 RT'list-5 RT'listStar-2 RT'listStar-3 RT'listStar-4 RT'listStar-5 RT'listStar-6 RT'arrayToList RT'object_array RT'toArray RT'seqToArray RT'seqToPassedArray RT'seqToTypedArray-1 RT'seqToTypedArray-2 RT'length RT'boundedLength RT'readRet RT'readChar RT'peekChar RT'getLineNumber RT'getColumnNumber RT'getLineNumberingReader RT'isLineNumberingReader RT'isReduced RT'printString RT'readString RT'print RT'printInnerSeq RT'makeClassLoader RT'baseLoader RT'resourceAsStream RT'getResource RT'classForName-3 RT'classForName-1 RT'classForNameNonLoading RT'loadClassForName RT'aget_float RT'aset_float RT'alength_float RT'aclone_float RT'aget_double RT'aset_double RT'alength_double RT'aclone_double RT'aget_int RT'aset_int RT'alength_int RT'aclone_int RT'aget_long RT'aset_long RT'alength_long RT'aclone_long RT'aget_char RT'aset_char RT'alength_char RT'aclone_char RT'aget_byte RT'aset_byte RT'alength_byte RT'aclone_byte RT'aget_short RT'aset_short RT'alength_short RT'aclone_short RT'aget_boolean RT'aset_boolean RT'alength_boolean RT'aclone_boolean RT'aget_object RT'aset_object RT'alength_object RT'aclone_object)
(declare SeqIterator'START SeqIterator'new)
(declare StringSeq'create StringSeq'new)
(declare Symbol'create-2 Symbol'create-1 Symbol'intern Symbol'new-2 Symbol'new-3)
(declare TransactionalHashMap'new-0 TransactionalHashMap'new-1i TransactionalHashMap'new-1m)
(declare SingleBuffer'new)
(declare ManyBuffer'new)
(declare MultiIterator'new)
(declare TransformerIterator'EMPTY TransformerIterator'NONE TransformerIterator'new TransformerIterator'create TransformerIterator'createMulti)
(declare Tuple'MAX_SIZE Tuple'create)
(declare Util'equiv-2oo Util'equivNull Util'equivEquals Util'equivNumber Util'equivColl Util'equivPred Util'equiv-2ll Util'equiv-2ol Util'equiv-2lo Util'equiv-2dd Util'equiv-2od Util'equiv-2do Util'equiv-2bb Util'equiv-2ob Util'equiv-2bo Util'equiv-2cc Util'pcequiv Util'equals Util'identical Util'classOf Util'compare Util'hash Util'hasheq Util'hashCombine Util'isPrimitive Util'isInteger Util'ret1 Util'clearCache Util'sneakyThrow Util'sneakyThrow0)
(declare TBox'new)
(declare Unbound'new)
(declare Frame'TOP Frame'new)
(declare Var'dvals Var'rev Var'privateKey Var'privateMeta Var'macroKey Var'nameKey Var'nsKey Var'getThreadBindingFrame Var'cloneThreadBindingFrame Var'resetThreadBindingFrame Var'intern Var'find Var'internPrivate Var'create Var'new Var'pushThreadBindings Var'popThreadBindings Var'getThreadBindings Var'assoc Var'dissoc)
(declare Volatile'new)
(declare main'CLOIURE_MAIN main'REQUIRE main'MAIN)

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_protected
    (defn #_"AFn" AFn'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"AFn" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"AFn" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
        (.throwArity this, 0)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1]
        (.throwArity this, 1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2]
        (.throwArity this, 2)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.throwArity this, 3)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.throwArity this, 4)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.throwArity this, 5)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.throwArity this, 6)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.throwArity this, 7)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.throwArity this, 8)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.throwArity this, 9)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.throwArity this, 10)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.throwArity this, 11)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.throwArity this, 12)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.throwArity this, 13)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.throwArity this, 14)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.throwArity this, 15)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.throwArity this, 16)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.throwArity this, 17)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.throwArity this, 18)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.throwArity this, 19)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.throwArity this, 20)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.throwArity this, 21)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"AFn" this, #_"ISeq" args]
        (AFn'applyToHelper this, (Util'ret1 args, (§ ass args nil)))
    )

    (defn #_"Object" AFn'applyToHelper [#_"IFn" ifn, #_"ISeq" args]
        (case (RT'boundedLength args, 20)
            0
            (do
                (§ ass args nil)
                (.invoke ifn)
            )
            1
            (do
                (.invoke ifn, (Util'ret1 (.first args), (§ ass args nil)))
            )
            2
            (do
                (.invoke ifn, (.first args),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            3
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            4
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            5
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            6
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            7
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            8
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            9
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            10
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            11
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            12
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            13
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            14
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            15
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            16
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            17
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            18
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            19
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            20
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            #_else
            (do
                (.invoke ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (RT'seqToArray (Util'ret1 (.next args), (§ ass args nil))))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"AFn" this, #_"int" n]
        (let [#_"String" name (.getSimpleName (.getClass this))]
            (throw (ArityException'new-2 n, (Compiler'demunge name)))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (defn- #_"AFunction" AFunction'init []
        (hash-map
            #_volatile
            #_"MethodImplCache" :__methodImplCache nil
        )
    )

    #_protected
    (defn #_"AFunction" AFunction'new []
        (merge (AFn'new) (AFunction'init))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"AFunction" this]
        nil
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"AFunction" this, #_"IPersistentMap" meta]
        (§ reify RestFn()
            #_protected
            #_method
            (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" args]
                (.applyTo (§ this AFunction), (cast' ISeq args))
            )

            #_method
            (§ defn #_"IPersistentMap" (§ method meta) [#_"RestFn" this]
                meta
            )

            #_method
            (§ defn #_"IObj" (§ method withMeta) [#_"RestFn" this, #_"IPersistentMap" meta]
                (.withMeta (§ this AFunction), meta)
            )

            #_method
            (§ defn #_"int" (§ method getRequiredArity) [#_"RestFn" this]
                0
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method compare) [#_"AFunction" this, #_"Object" o1, #_"Object" o2]
        (let [#_"Object" o (.invoke this, o1, o2)]
            (if (instance? Boolean o)
                (cond (RT'booleanCast-1o o) -1 (RT'booleanCast-1o (.invoke this, o2, o1)) 1 :else 0)
                (.intValue (cast Number o))
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns ActionQueue
    (§ def #_"ActionQueue" ActionQueue'EMPTY (ActionQueue'new PersistentQueue'EMPTY, nil))

    (defn- #_"ActionQueue" ActionQueue'init []
        (hash-map
            #_"IPersistentStack" :q nil
            #_"Throwable" :error nil ;; non-null indicates fail state
        )
    )

    (defn #_"ActionQueue" ActionQueue'new [#_"IPersistentStack" q, #_"Throwable" error]
        (let [this (ActionQueue'init)]
            (§ ass this (assoc this :q q))
            (§ ass this (assoc this :error error))
            this
        )
    )
)

(class-ns AgentAction (§ implements Runnable)
    (defn- #_"AgentAction" AgentAction'init []
        (hash-map
            #_"Agent" :agent nil
            #_"IFn" :fn nil
            #_"ISeq" :args nil
            #_"Executor" :exec nil
        )
    )

    (defn #_"AgentAction" AgentAction'new [#_"Agent" agent, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let [this (AgentAction'init)]
            (§ ass this (assoc this :agent agent))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :fn fn))
            (§ ass this (assoc this :exec exec))
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method execute) [#_"AgentAction" this]
        (try
            (.execute (:exec this), this)
            (catch Throwable error
                (when (some? (:errorHandler (:agent this)))
                    (try
                        (.invoke (:errorHandler (:agent this)), (:agent this), error)
                        (catch Throwable e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AgentAction'doRun [#_"AgentAction" action]
        (try
            (.set Agent'nested, PersistentVector'EMPTY)

            (let [#_"Throwable" error nil]
                (try
                    (let [#_"Object" oldval (:state (:agent action))]
                        (let [#_"Object" newval (.applyTo (:fn action), (RT'cons (:state (:agent action)), (:args action)))]
                            (.setState (:agent action), newval)
                            (.notifyWatches (:agent action), oldval, newval)
                        )
                    )
                    (catch Throwable e
                        (§ ass error e)
                    )
                )

                (if (nil? error)
                    (do
                        (Agent'releasePendingSends)
                    )
                    (do
                        (.set Agent'nested, nil) ;; allow errorHandler to send
                        (when (some? (:errorHandler (:agent action)))
                            (try
                                (.invoke (:errorHandler (:agent action)), (:agent action), error)
                                (catch Throwable e
                                    ;; ignore errorHandler errors
                                )
                            )
                        )
                        (when (= (:errorMode (:agent action)) Agent'CONTINUE)
                            (§ ass error nil)
                        )
                    )
                )

                (let [#_"boolean" popped false]
                    (let [#_"ActionQueue" next nil]
                        (while (not popped)
                            (let [#_"ActionQueue" prior (.get (:aq (:agent action)))]
                                (§ ass next (ActionQueue'new (.pop (:q prior)), error))
                                (§ ass popped (.compareAndSet (:aq (:agent action)), prior, next))
                            )
                        )

                        (when (and (nil? error) (pos? (.count (:q next))))
                            (.execute (cast' AgentAction (.peek (:q next))))
                        )
                    )
                )
            )
            (finally
                (.set Agent'nested, nil)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"AgentAction" this]
        (AgentAction'doRun this)
        nil
    )
)

(class-ns Agent (§ extends ARef)
    (§ def #_"Keyword" Agent'CONTINUE (Keyword'intern (Symbol'intern nil, "continue")))
    (§ def #_"Keyword" Agent'FAIL (Keyword'intern (Symbol'intern nil, "fail")))

    (def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" format, #_"AtomicLong" threadPoolCounter]
        (§ reify ThreadFactory()
            #_method
            (§ defn #_"Thread" (§ method newThread) [#_"ThreadFactory" this, #_"Runnable" runnable]
                (let [#_"Thread" thread (Thread. runnable)]
                    (.setName thread, (String/format format, (object-array [ (.getAndIncrement threadPoolCounter) ])))
                    thread
                )
            )
        )
    )

    #_volatile
    (§ def #_"ExecutorService" Agent'pooledExecutor (Executors/newFixedThreadPool (+ 2 (.availableProcessors (Runtime/getRuntime))), (Agent'createThreadFactory "cloiure-agent-send-pool-%d", Agent'sendThreadPoolCounter)))

    #_volatile
    (§ def #_"ExecutorService" Agent'soloExecutor (Executors/newCachedThreadPool (Agent'createThreadFactory "cloiure-agent-send-off-pool-%d", Agent'sendOffThreadPoolCounter)))

    (def #_"ThreadLocal<IPersistentVector>" Agent'nested (ThreadLocal.))

    (defn #_"void" Agent'shutdown []
        (.shutdown Agent'soloExecutor)
        (.shutdown Agent'pooledExecutor)
        nil
    )

    (defn- #_"Agent" Agent'init []
        (hash-map
            #_volatile
            #_"Object" :state nil
            #_"AtomicReference<ActionQueue>" :aq (AtomicReference. ActionQueue'EMPTY)

            #_volatile
            #_"Keyword" :errorMode Agent'CONTINUE
            #_volatile
            #_"IFn" :errorHandler nil
        )
    )

    (defn #_"Agent" Agent'new-1 [#_"Object" state]
        (Agent'new-2 state, nil)
    )

    (defn #_"Agent" Agent'new-2 [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Agent'init))]
            (.setState this, state)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method setState) [#_"Agent" this, #_"Object" newState]
        (.validate this, newState)
        (let [#_"boolean" ret (not= (:state this) newState)]
            (§ ass this (assoc this :state newState))
            ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Agent" this]
        (:state this)
    )

    #_method
    (§ defn #_"Throwable" (§ method getError) [#_"Agent" this]
        (:error (.get (:aq this)))
    )

    #_method
    (§ defn #_"void" (§ method setErrorMode) [#_"Agent" this, #_"Keyword" k]
        (§ ass this (assoc this :errorMode k))
        nil
    )

    #_method
    (§ defn #_"Keyword" (§ method getErrorMode) [#_"Agent" this]
        (:errorMode this)
    )

    #_method
    (§ defn #_"void" (§ method setErrorHandler) [#_"Agent" this, #_"IFn" f]
        (§ ass this (assoc this :errorHandler f))
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method getErrorHandler) [#_"Agent" this]
        (:errorHandler this)
    )

    #_method
    (§ defn #_"Object" (§ method restart) [#_"Agent" this, #_"Object" newState, #_"boolean" clearActions]
        (§ sync this
            (when (nil? (.getError this))
                (throw (RuntimeException. "Agent does not need a restart"))
            )
            (.validate this, newState)
            (§ ass this (assoc this :state newState))

            (if clearActions
                (do
                    (.set (:aq this), ActionQueue'EMPTY)
                )
                (do
                    (let [#_"boolean" restarted false]
                        (let [#_"ActionQueue" prior nil]
                            (while (not restarted)
                                (§ ass prior (.get (:aq this)))
                                (§ ass restarted (.compareAndSet (:aq this), prior, (ActionQueue'new (:q prior), nil)))
                            )

                            (when (pos? (.count (:q prior)))
                                (.execute (cast' AgentAction (.peek (:q prior))))
                            )
                        )
                    )
                )
            )

            newState
        )
    )

    #_method
    (§ defn #_"Object" (§ method dispatch) [#_"Agent" this, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let-when [#_"Throwable" e (.getError this)] (nil? e) => (throw (RuntimeException. "Agent is failed, needs restart", e))
            (let [#_"AgentAction" action (AgentAction'new this, fn, args, exec)]
                (Agent'dispatchAction action)
                this
            )
        )
    )

    (defn #_"void" Agent'dispatchAction [#_"AgentAction" action]
        (let [#_"LockingTransaction" trans (LockingTransaction'getRunning)]
            (cond
                (some? trans)               (.enqueue trans, action)
                (some? (.get Agent'nested)) (.set Agent'nested, (.cons (.get Agent'nested), action))
                :else                       (.enqueue (:agent action), action)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method enqueue) [#_"Agent" this, #_"AgentAction" action]
        (let [#_"ActionQueue" prior
                (loop-when [prior nil #_"boolean" queued false] (not queued) => prior
                    (let [prior (.get (:aq this))]
                        (recur prior (.compareAndSet (:aq this), prior, (ActionQueue'new (cast' IPersistentStack (.cons (:q prior), action)), (:error prior))))
                    )
                )]
            (when (and (zero? (.count (:q prior))) (nil? (:error prior)))
                (.execute action)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getQueueCount) [#_"Agent" this]
        (.count (:q (.get (:aq this))))
    )

    (defn #_"int" Agent'releasePendingSends []
        (let-when [#_"IPersistentVector" sends (.get Agent'nested)] (some? sends) => 0
            (dotimes [#_"int" i (.count sends)]
                (let [#_"AgentAction" a (cast' AgentAction (.valAt sends, i))]
                    (.enqueue (:agent a), a)
                )
            )
            (.set Agent'nested, PersistentVector'EMPTY)
            (.count sends)
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_protected
    (defn #_"AMapEntry" AMapEntry'new []
        (APersistentVector'new)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"AMapEntry" this, #_"int" i]
        (cond (zero? i)
            (do
                (.key this)
            )
            (= i 1)
            (do
                (.val this)
            )
            :else
            (do
                (throw (IndexOutOfBoundsException.))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" (§ method asVector) [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (.key this), (.val this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assocN) [#_"AMapEntry" this, #_"int" i, #_"Object" val]
        (.assocN (.asVector this), i, val)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"AMapEntry" this]
        2
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"AMapEntry" this]
        (.seq (.asVector this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method cons) [#_"AMapEntry" this, #_"Object" o]
        (.cons (.asVector this), o)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"AMapEntry" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" (§ method pop) [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (.key this))
    )

    #_method
    (§ defn #_"Object" (§ method setValue) [#_"AMapEntry" this, #_"Object" value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

(class-ns KeySeq (§ extends ASeq)
    (defn #_"KeySeq" KeySeq'create [#_"ISeq" seq]
        (when (some? seq)
            (KeySeq'new-2 seq, nil)
        )
    )

    (defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" map]
        (when (some? map)
            (let [#_"ISeq" seq (.seq map)]
                (when (some? seq)
                    (KeySeq'new-2 seq, map)
                )
            )
        )
    )

    (defn- #_"KeySeq" KeySeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"KeySeq" KeySeq'new-2 [#_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new) (KeySeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    (defn- #_"KeySeq" KeySeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new meta) (KeySeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"KeySeq" this]
        (.getKey (cast Map$Entry (.first (:seq this))))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"KeySeq" this]
        (.create this, (.next (:seq this)))
    )

    #_method
    (§ defn #_"KeySeq" (§ method withMeta) [#_"KeySeq" this, #_"IPersistentMap" meta]
        (KeySeq'new-3 meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"KeySeq" this]
        (cond
            (nil? (:iterable this))
                (.iterator (§ super ))
            (§ instance? IMapIterable (:iterable this))
                (.keyIterator (cast' IMapIterable (:iterable this)))
            :else
                (let [#_"Iterator" mapIter (.iterator (:iterable this))]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext mapIter)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (.getKey (cast Map$Entry (.next mapIter)))
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
        )
    )
)

(class-ns ValSeq (§ extends ASeq)
    (defn #_"ValSeq" ValSeq'create [#_"ISeq" seq]
        (when (some? seq)
            (ValSeq'new-2 seq, nil)
        )
    )

    (defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" map]
        (when (some? map)
            (let [#_"ISeq" seq (.seq map)]
                (when (some? seq)
                    (ValSeq'new-2 seq, map)
                )
            )
        )
    )

    (defn- #_"ValSeq" ValSeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"ValSeq" ValSeq'new-2 [#_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new) (ValSeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    (defn- #_"ValSeq" ValSeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new meta) (ValSeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ValSeq" this]
        (.getValue (cast Map$Entry (.first (:seq this))))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ValSeq" this]
        (.create this, (.next (:seq this)))
    )

    #_method
    (§ defn #_"ValSeq" (§ method withMeta) [#_"ValSeq" this, #_"IPersistentMap" meta]
        (ValSeq'new-3 meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ValSeq" this]
        (cond
            (nil? (:iterable this))
                (.iterator (§ super ))
            (§ instance? IMapIterable (:iterable this))
                (.valIterator (cast' IMapIterable (:iterable this)))
            :else
                (let [#_"Iterator" mapIter (.iterator (:iterable this))]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext mapIter)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (.getValue (cast Map$Entry (.next mapIter)))
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
        )
    )
)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (defn- #_"APersistentMap" APersistentMap'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentMap" APersistentMap'new []
        (merge (AFn'new) (APersistentMap'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentMap" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method cons) [#_"APersistentMap" this, #_"Object" o]
        (cond
            (instance? Map$Entry o)
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (.assoc this, (.getKey e), (.getValue e))
                )
            (§ instance? IPersistentVector o)
                (let [#_"IPersistentVector" v (cast' IPersistentVector o)]
                    (when (= (.count v) 2) => (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                        (.assoc this, (.nth v, 0), (.nth v, 1))
                    )
                )
            :else
                (loop-when [#_"IPersistentMap" m this #_"ISeq" s (RT'seq o)] (some? s) => m
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (recur (.assoc m, (.getKey e), (.getValue e)) (.next s))
                    )
                )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentMap" this, #_"Object" obj]
        (APersistentMap'mapEquals this, obj)
    )

    (defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" m1, #_"Object" obj]
        (cond
            (= m1 obj)
                true
            (not (instance? Map obj))
                false
            :else
                (let-when [#_"Map" m (cast Map obj)] (= (.size m) (.count m1)) => false
                    (loop-when [#_"ISeq" s (.seq m1)] (some? s) => true
                        (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e)]
                            (and (.containsKey m, k) (Util'equals (.getValue e), (.get m, k))
                                (recur (.next s))
                            )
                        )
                    )
                )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentMap" this, #_"Object" obj]
        (cond
            (not (instance? Map obj))
                false
            (and (§ instance? IPersistentMap obj) (not (§ instance? MapEquivalence obj)))
                false
            :else
                (let-when [#_"Map" m (cast Map obj)] (= (.size m) (.size this)) => false
                    (loop-when [#_"ISeq" s (.seq this)] (some? s) => true
                        (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e)]
                            (and (.containsKey m, k) (Util'equiv-2oo (.getValue e), (.get m, k))
                                (recur (.next s))
                            )
                        )
                    )
                )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentMap" this]
        (let [#_"int" cached (:_hash this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hash (§ ass cached (APersistentMap'mapHash this))))
            )
            cached
        )
    )

    (defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" m]
        (loop-when [#_"int" hash 0 #_"ISeq" s (.seq m)] (some? s) => hash
            (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e) #_"Object" v (.getValue e)]
                (recur (+ hash (bit-xor (if (some? k) (.hashCode k) 0) (if (some? v) (.hashCode v) 0))) (.next s))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentMap" this]
        (let [#_"int" cached (:_hasheq this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hasheq (§ ass cached (Murmur3'hashUnordered this))))
            )
            cached
        )
    )

    (defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" m]
        (Murmur3'hashUnordered m)
    )

    (def #_"IFn" APersistentMap'MAKE_ENTRY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" key, #_"Object" val]
                (MapEntry'create key, val)
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_KEY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" key, #_"Object" val]
                key
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_VAL
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" key, #_"Object" val]
                val
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentMap" this, #_"Object" arg1]
        (.valAt this, arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentMap" this, #_"Object" arg1, #_"Object" notFound]
        (.valAt this, arg1, notFound)
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsValue) [#_"APersistentMap" this, #_"Object" value]
        (.contains (.values this), value)
    )

    #_method
    (§ defn #_"Set" (§ method entrySet) [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet" this]
                (.iterator (§ this APersistentMap))
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractSet" this]
                (.count this)
            )

            #_method
            (§ defn #_"int" (§ method hashCode) [#_"AbstractSet" this]
                (.hashCode (§ this APersistentMap))
            )

            #_method
            (§ defn #_"boolean" (§ method contains) [#_"AbstractSet" this, #_"Object" o]
                (and (§ instance? Entry o)
                    (let [#_"Entry" e (cast' Entry o) #_"Entry" found (.entryAt this, (.getKey e))]
                        (and (some? found) (Util'equals (.getValue found), (.getValue e)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentMap" this, #_"Object" key]
        (.valAt this, key)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentMap" this]
        (zero? (.count this))
    )

    #_method
    (§ defn #_"Set" (§ method keySet) [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet" this]
                (let [#_"Iterator" mi (.iterator (§ this APersistentMap))]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext mi)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [#_"Entry" e (cast' Entry (.next mi))]
                                (.getKey e)
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractSet" this]
                (.count this)
            )

            #_method
            (§ defn #_"boolean" (§ method contains) [#_"AbstractSet" this, #_"Object" o]
                (.containsKey (§ this APersistentMap), o)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method put) [#_"APersistentMap" this, #_"Object" key, #_"Object" value]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method putAll) [#_"APersistentMap" this, #_"Map" t]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"APersistentMap" this, #_"Object" key]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentMap" this]
        (.count this)
    )

    #_method
    (§ defn #_"Collection" (§ method values) [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractCollection" this]
                (let [#_"Iterator" mi (.iterator (§ this APersistentMap))]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext mi)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [#_"Entry" e (cast' Entry (.next mi))]
                                (.getValue e)
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractCollection" this]
                (.count this)
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (defn- #_"APersistentSet" APersistentSet'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
            #_"IPersistentMap" :impl nil
        )
    )

    #_protected
    (defn #_"APersistentSet" APersistentSet'new [#_"IPersistentMap" impl]
        (let [this (merge (AFn'new) (APersistentSet'init))]
            (§ ass this (assoc this :impl impl))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentSet" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"APersistentSet" this, #_"Object" key]
        (.containsKey (:impl this), key)
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentSet" this, #_"Object" key]
        (.valAt (:impl this), key)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"APersistentSet" this]
        (.count (:impl this))
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"APersistentSet" this]
        (RT'keys (:impl this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentSet" this, #_"Object" arg1]
        (.get this, arg1)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentSet" this, #_"Object" obj]
        (APersistentSet'setEquals this, obj)
    )

    (defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" s1, #_"Object" obj]
        (cond
            (= s1 obj)
                true
            (not (instance? Set obj))
                false
            :else
                (let-when [#_"Set" m (cast Set obj)] (= (.size m) (.count s1)) => false
                    (doseq [#_"Object" aM m]
                        (when (not (.contains s1, aM))
                            (§ return false)
                        )
                    )
                    true
                )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentSet" this, #_"Object" obj]
        (and (instance? Set obj)
            (let-when [#_"Set" m (cast Set obj)] (= (.size m) (.size this)) => false
                (doseq [#_"Object" aM m]
                    (when (not (.contains this, aM))
                        (§ return false)
                    )
                )
                true
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentSet" this]
        (let [#_"int" hash (:_hash this)]
            (when (zero? hash)
                (loop-when-recur [#_"ISeq" s (.seq this)] (some? s) [(.next s)]
                    (let [#_"Object" e (.first s)]
                        (§ ass hash (+ hash (Util'hash e)))
                    )
                )
                (§ ass this (assoc this :_hash hash))
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentSet" this]
        (let [#_"int" cached (:_hasheq this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hasheq (§ ass cached (Murmur3'hashUnordered this))))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentSet" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"APersistentSet" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"APersistentSet" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"APersistentSet" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (not (.contains this, o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentSet" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentSet" this]
        (.count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentSet" this]
        (zero? (.count this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"APersistentSet" this]
        (if (§ instance? IMapIterable (:impl this))
            (do
                (.keyIterator (cast' IMapIterable (:impl this)))
            )
            (do
                (§ reify Iterator()
                    (§ init
                        (hash-map
                            #_"Iterator" :iter (.iterator (:impl this))
                        )
                    )

                    #_method
                    (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                        (.hasNext (:iter this))
                    )

                    #_method
                    (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                        (.key (cast' IMapEntry (.next (:iter this))))
                    )

                    #_method
                    (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

(class-ns VSeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"VSeq" VSeq'init []
        (hash-map
            ;; todo - something more efficient
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"VSeq" VSeq'new-2 [#_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new) (VSeq'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :i i))
            this
        )
    )

    (defn #_"VSeq" VSeq'new-3 [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new meta) (VSeq'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"VSeq" this]
        (.nth (:v this), (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"VSeq" this]
        (when (< (inc (:i this)) (.count (:v this)))
            (VSeq'new-2 (:v this), (inc (:i this)))
        )
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"VSeq" this]
        (:i this)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"VSeq" this]
        (- (.count (:v this)) (:i this))
    )

    #_method
    (§ defn #_"VSeq" (§ method withMeta) [#_"VSeq" this, #_"IPersistentMap" meta]
        (VSeq'new-3 meta, (:v this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"VSeq" this, #_"IFn" f]
        (let [#_"IPersistentVector" v (:v this) #_"int" i (:i this) #_"int" n (.count v)]
            (loop-when [#_"Object" r (.nth v, i) i (inc i)] (< i n) => r
                (let-when [r (.invoke f, r, (.nth v, i))] (RT'isReduced r) => (recur r (inc i))
                    (.deref (cast' IDeref r))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"VSeq" this, #_"IFn" f, #_"Object" r]
        (let [#_"IPersistentVector" v (:v this) #_"int" i (:i this) #_"int" n (.count v)]
            (loop-when [r (.invoke f, r, (.nth v, i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (when (RT'isReduced r) => (recur (.invoke f, r, (.nth v, i)) (inc i))
                    (.deref (cast' IDeref r))
                )
            )
        )
    )
)

(class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
    (defn- #_"RSeq" RSeq'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"RSeq" RSeq'new-2 [#_"IPersistentVector" vector, #_"int" i]
        (let [this (merge (ASeq'new) (RSeq'init))]
            (§ ass this (assoc this :v vector))
            (§ ass this (assoc this :i i))
            this
        )
    )

    (defn #_"RSeq" RSeq'new-3 [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new meta) (RSeq'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"RSeq" this]
        (.nth (:v this), (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"RSeq" this]
        (when (pos? (:i this))
            (RSeq'new-2 (:v this), (dec (:i this)))
        )
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"RSeq" this]
        (:i this)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"RSeq" this]
        (inc (:i this))
    )

    #_method
    (§ defn #_"RSeq" (§ method withMeta) [#_"RSeq" this, #_"IPersistentMap" meta]
        (RSeq'new-3 meta, (:v this), (:i this))
    )
)

(class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
    (defn- #_"SubVector" SubVector'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :start 0
            #_"int" :end 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"SubVector" SubVector'new [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" start, #_"int" end]
        (let [this (merge (APersistentVector'new) (SubVector'init))]
            (§ ass this (assoc this :_meta meta))

            (when (§ instance? SubVector v)
                (let [#_"SubVector" sv (cast' SubVector v)]
                    (§ ass start (+ start (:start sv)))
                    (§ ass end (+ end (:start sv)))
                    (§ ass v (:v sv))
                )
            )
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            this
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"SubVector" this]
        (if (§ instance? APersistentVector (:v this))
            (.rangedIterator (cast' APersistentVector (:v this)), (:start this), (:end this))
            (.iterator (§ super ))
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"SubVector" this, #_"int" i]
        (if (and (<= 0 i) (< (+ (:start this) i) (:end this)))
            (.nth (:v this), (+ (:start this) i))
            (throw (IndexOutOfBoundsException.))
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assocN) [#_"SubVector" this, #_"int" i, #_"Object" val]
        (cond
            (< (:end this) (+ (:start this) i)) (throw (IndexOutOfBoundsException.))
            (= (+ (:start this) i) (:end this)) (.cons this, val)
            :else (SubVector'new (:_meta this), (.assocN (:v this), (+ (:start this) i), val), (:start this), (:end this))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"SubVector" this]
        (- (:end this) (:start this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method cons) [#_"SubVector" this, #_"Object" o]
        (SubVector'new (:_meta this), (.assocN (:v this), (:end this), o), (:start this), (inc (:end this)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"SubVector" this]
        (.withMeta PersistentVector'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"IPersistentStack" (§ method pop) [#_"SubVector" this]
        (if (= (dec (:end this)) (:start this))
            PersistentVector'EMPTY
            (SubVector'new (:_meta this), (:v this), (:start this), (dec (:end this)))
        )
    )

    #_method
    (§ defn #_"SubVector" (§ method withMeta) [#_"SubVector" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (SubVector'new meta, (:v this), (:start this), (:end this))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"SubVector" this]
        (:_meta this)
    )
)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (defn- #_"APersistentVector" APersistentVector'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentVector" APersistentVector'new []
        (merge (AFn'new) (APersistentVector'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentVector" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"APersistentVector" this]
        (when (pos? (.count this))
            (VSeq'new-2 this, 0)
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"APersistentVector" this]
        (when (pos? (.count this))
            (RSeq'new-2 this, (dec (.count this)))
        )
    )

    (defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" v, #_"Object" obj]
        (cond
            (§ instance? IPersistentVector obj)
                (let-when [#_"IPersistentVector" ov (cast' IPersistentVector obj)] (= (.count ov) (.count v)) => false
                    (loop-when [#_"int" i 0] (< i (.count v)) => true
                        (recur-if (Util'equals (.nth v, i), (.nth ov, i)) [(inc i)] => false)
                    )
                )
            (instance? List obj)
                (let-when [#_"Collection" ma (cast Collection obj)] (and (= (.size ma) (.count v)) (= (.hashCode ma) (.hashCode v))) => false
                    (loop-when [#_"Iterator" i1 (.iterator (cast List v)) #_"Iterator" i2 (.iterator ma)] (.hasNext i1) => true
                        (recur-if (Util'equals (.next i1), (.next i2)) [i1 i2] => false)
                    )
                )
            :else
                (when (§ instance? Sequential obj) => false
                    (loop-when [#_"int" i 0 #_"ISeq" ms (RT'seq obj)] (< i (.count v)) => (nil? ms)
                        (recur-if (and (some? ms) (Util'equals (.nth v, i), (.first ms))) [(inc i) (.next ms)] => false)
                    )
                )
        )
    )

    (defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" v, #_"Object" obj]
        (cond
            (§ instance? IPersistentVector obj)
                (let-when [#_"IPersistentVector" ov (cast' IPersistentVector obj)] (= (.count ov) (.count v)) => false
                    (loop-when [#_"int" i 0] (< i (.count v)) => true
                        (recur-if (Util'equiv-2oo (.nth v, i), (.nth ov, i)) [(inc i)] => false)
                    )
                )
            (instance? List obj)
                (let-when [#_"Collection" ma (cast Collection obj)] (= (.size ma) (.count v)) => false
                    (loop-when [#_"Iterator" i1 (.iterator (cast List v)) #_"Iterator" i2 (.iterator ma)] (.hasNext i1) => true
                        (recur-if (Util'equiv-2oo (.next i1), (.next i2)) [i1 i2] => false)
                    )
                )
            :else
                (when (§ instance? Sequential obj) => false
                    (loop-when [#_"int" i 0 #_"ISeq" ms (RT'seq obj)] (< i (.count v)) => (nil? ms)
                        (recur-if (and (some? ms) (Util'equiv-2oo (.nth v, i), (.first ms))) [(inc i) (.next ms)] => false)
                    )
                )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentVector" this, #_"Object" obj]
        (or (= obj this) (APersistentVector'doEquals this, obj))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentVector" this, #_"Object" obj]
        (or (= obj this) (APersistentVector'doEquiv this, obj))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentVector" this]
        (let [#_"int" hash (:_hash this)]
            (when (zero? hash)
                (§ ass hash 1)
                (loop-when-recur [#_"int" i 0] (< i (.count this)) [(inc i)]
                    (let [#_"Object" obj (.nth this, i)]
                        (§ ass hash (+ (* 31 hash) (if (nil? obj) 0 (.hashCode obj))))
                    )
                )
                (§ ass this (assoc this :_hash hash))
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentVector" this]
        (let [#_"int" hash (:_hasheq this)]
            (when (zero? hash)
                (§ let [#_"int" n]
                    (§ ass hash 1)

                    (loop-when-recur [n 0] (< n (.count this)) [(inc n)]
                        (§ ass hash (+ (* 31 hash) (Util'hasheq (.nth this, n))))
                    )

                    (§ ass this (assoc this :_hasheq (§ ass hash (Murmur3'mixCollHash hash, n))))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentVector" this, #_"int" index]
        (.nth this, index)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"APersistentVector" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (.count this)) (.nth this, i) notFound)
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"APersistentVector" this, #_"int" i]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"int" i 0] (< i (.count this)) => -1
            (if (Util'equiv-2oo (.nth this, i), o) i (recur (inc i)))
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"int" i (dec (.count this))] (<= 0 i) => -1
            (if (Util'equiv-2oo (.nth this, i), o) i (recur (dec i)))
        )
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"APersistentVector" this]
        (.listIterator this, 0)
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"APersistentVector" this, #_"int" index]
        (§ reify ListIterator()
            (§ init
                (hash-map
                    #_"int" :nexti index
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"ListIterator" this]
                (< (:nexti this) (.count this))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"ListIterator" this]
                (if (< (:nexti this) (.count this))
                    (let [_ (.nth this, (:nexti this))]
                        (§ ass (:nexti this) (inc (:nexti this)))
                        _
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasPrevious) [#_"ListIterator" this]
                (< 0 (:nexti this))
            )

            #_method
            (§ defn #_"Object" (§ method previous) [#_"ListIterator" this]
                (if (< 0 (:nexti this))
                    (do
                        (§ ass (:nexti this) (dec (:nexti this)))
                        (.nth this, (:nexti this))
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method nextIndex) [#_"ListIterator" this]
                (:nexti this)
            )

            #_method
            (§ defn #_"int" (§ method previousIndex) [#_"ListIterator" this]
                (dec (:nexti this))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"ListIterator" this]
                (throw (UnsupportedOperationException.))
            )

            #_method
            (§ defn #_"void" (§ method set) [#_"ListIterator" this, #_"Object" o]
                (throw (UnsupportedOperationException.))
            )

            #_method
            (§ defn #_"void" (§ method add) [#_"ListIterator" this, #_"Object" o]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method rangedIterator) [#_"APersistentVector" this, #_"int" start, #_"int" end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i start
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (< (:i this) end)
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (if (< (:i this) end)
                    (let [_ (.nth this, (:i this))]
                        (§ ass (:i this) (inc (:i this)))
                        _
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"APersistentVector" this, #_"int" fromIndex, #_"int" toIndex]
        (cast List (RT'subvec this, fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"APersistentVector" this, #_"int" i, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"APersistentVector" this, #_"int" i, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentVector" this, #_"int" i, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentVector" this, #_"Object" arg1]
        (if (Util'isInteger arg1)
            (.nth this, (.intValue (cast Number arg1)))
            (throw (IllegalArgumentException. "Key must be integer"))
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i 0
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (< (:i this) (.count this))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (if (< (:i this) (.count this))
                    (let [_ (.nth this, (:i this))]
                        (§ ass (:i this) (inc (:i this)))
                        _
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"APersistentVector" this]
        (when (pos? (.count this))
            (.nth this, (dec (.count this)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"APersistentVector" this, #_"Object" key]
        (and (Util'isInteger key) (< -1 (.intValue (cast Number key)) (.count this)))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"APersistentVector" this, #_"Object" key]
        (when (Util'isInteger key)
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (.count this))
                (cast' IMapEntry (MapEntry'create key, (.nth this, i)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assoc) [#_"APersistentVector" this, #_"Object" key, #_"Object" val]
        (when (Util'isInteger key) => (throw (IllegalArgumentException. "Key must be integer"))
            (.assocN this, (.intValue (cast Number key)), val)
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"APersistentVector" this, #_"Object" key, #_"Object" notFound]
        (when (Util'isInteger key) => notFound
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (.count this)) => notFound
                (.nth this, i)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"APersistentVector" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentVector" this]
        (let [#_"Object[]" a (make-array Object (.count this))]
            (loop-when-recur [#_"int" i 0] (< i (.count this)) [(inc i)]
                (aset a i (.nth this, i))
            )
            a
        )
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"APersistentVector" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"APersistentVector" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"APersistentVector" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (not (.contains this, o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentVector" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentVector" this]
        (.count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentVector" this]
        (zero? (.count this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_method
    (§ defn #_"int" (§ method length) [#_"APersistentVector" this]
        (.count this)
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"APersistentVector" this, #_"Object" o]
        (let [#_"IPersistentVector" v (cast' IPersistentVector o) #_"int" n (.count this) #_"int" m (.count v)]
            (cond (< n m) -1 (< m n) 1
                :else
                    (loop-when [#_"int" i 0] (< i n) => 0
                        (let [#_"int" cmp (Util'compare (.nth this, i), (.nth v, i))]
                            (recur-if (zero? cmp) [(inc i)] => cmp)
                        )
                    )
            )
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (defn- #_"ARef" ARef'init []
        (hash-map
            #_protected
            #_volatile
            #_"IFn" :validator nil
            #_volatile
            #_"IPersistentMap" :watches PersistentHashMap'EMPTY
        )
    )

    (defn #_"ARef" ARef'new-0 []
        (merge (AReference'new) (ARef'init))
    )

    (defn #_"ARef" ARef'new-1 [#_"IPersistentMap" meta]
        (merge (AReference'new meta) (ARef'init))
    )

    #_method
    (§ defn #_"void" (§ method validate) [#_"ARef" this, #_"IFn" vf, #_"Object" val]
        (try
            (when (and (some? vf) (not (RT'booleanCast-1o (.invoke vf, val))))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException re
                (throw re)
            )
            (catch Exception e
                (throw (IllegalStateException. "Invalid reference state", e))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method validate) [#_"ARef" this, #_"Object" val]
        (.validate this, (:validator this), val)
        nil
    )

    #_method
    (§ defn #_"void" (§ method setValidator) [#_"ARef" this, #_"IFn" vf]
        (.validate this, vf, (.deref this))
        (§ ass this (assoc this :validator vf))
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method getValidator) [#_"ARef" this]
        (:validator this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getWatches) [#_"ARef" this]
        (:watches this)
    )

    #_method
    (§ defn #_"IRef" (§ method addWatch) [#_"ARef" this, #_"Object" key, #_"IFn" callback]
        (§ sync this
            (§ ass this (assoc this :watches (.assoc (:watches this), key, callback)))
            this
        )
    )

    #_method
    (§ defn #_"IRef" (§ method removeWatch) [#_"ARef" this, #_"Object" key]
        (§ sync this
            (§ ass this (assoc this :watches (.without (:watches this), key)))
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method notifyWatches) [#_"ARef" this, #_"Object" oldval, #_"Object" newval]
        (let [#_"IPersistentMap" ws (:watches this)]
            (when (pos? (.count ws))
                (loop-when-recur [#_"ISeq" s (.seq ws)] (some? s) [(.next s)]
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (let [#_"IFn" fn (cast' IFn (.getValue e))]
                            (when (some? fn)
                                (.invoke fn, (.getKey e), this, oldval, newval)
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (defn- #_"AReference" AReference'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"AReference" AReference'new-0 []
        (AReference'new-1 nil)
    )

    (defn #_"AReference" AReference'new-1 [#_"IPersistentMap" meta]
        (let [this (AReference'init)]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"AReference" this]
        (§ sync this
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method alterMeta) [#_"AReference" this, #_"IFn" alter, #_"ISeq" args]
        (§ sync this
            (§ ass this (assoc this :_meta (cast' IPersistentMap (.applyTo alter, (Cons'new-2 (:_meta this), args)))))
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method resetMeta) [#_"AReference" this, #_"IPersistentMap" m]
        (§ sync this
            (§ ass this (assoc this :_meta m))
            m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (defn- #_"ArityException" ArityException'init []
        (hash-map
            #_"int" :actual 0
            #_"String" :name nil
        )
    )

    (defn #_"ArityException" ArityException'new-2 [#_"int" actual, #_"String" name]
        (ArityException'new-3 actual, name, nil)
    )

    (defn #_"ArityException" ArityException'new-3 [#_"int" actual, #_"String" name, #_"Throwable" cause]
        (let [this (merge (§ foreign IllegalArgumentException'new (str "Wrong number of args (" actual ") passed to: " name), cause) (ArityException'init))]
            (§ ass this (assoc this :actual actual))
            (§ ass this (assoc this :name name))
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (defn- #_"ArrayChunk" ArrayChunk'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :off 0
            #_"int" :end 0
        )
    )

    (defn #_"ArrayChunk" ArrayChunk'new-1 [#_"Object[]" array]
        (ArrayChunk'new-3 array, 0, (alength array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-2 [#_"Object[]" array, #_"int" off]
        (ArrayChunk'new-3 array, off, (alength array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-3 [#_"Object[]" array, #_"int" off, #_"int" end]
        (let [this (ArrayChunk'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :off off))
            (§ ass this (assoc this :end end))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"ArrayChunk" this, #_"int" i]
        (aget (:array this) (+ (:off this) i))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"ArrayChunk" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (.count this)) (.nth this, i) notFound)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArrayChunk" this]
        (- (:end this) (:off this))
    )

    #_method
    (§ defn #_"IChunk" (§ method dropFirst) [#_"ArrayChunk" this]
        (if (= (:off this) (:end this))
            (throw (IllegalStateException. "dropFirst of empty chunk"))
            (ArrayChunk'new-3 (:array this), (inc (:off this)), (:end this))
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArrayChunk" this, #_"IFn" f, #_"Object" r]
        (let [r (.invoke f, r, (aget (:array this) (:off this)))]
            (when-not (RT'isReduced r) => r
                (loop-when [#_"int" i (inc (:off this))] (< i (:end this)) => r
                    (let [r (.invoke f, r, (aget (:array this) i))]
                        (when-not (RT'isReduced r) => r
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns ArrayIter_int (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_int" ArrayIter_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_int" ArrayIter_int'new [#_"int[]" array, #_"int" i]
        (let [this (ArrayIter_int'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_int" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_int" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Long/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_int" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_float (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_float" ArrayIter_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_float" ArrayIter_float'new [#_"float[]" array, #_"int" i]
        (let [this (ArrayIter_float'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_float" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Double" (§ method next) [#_"ArrayIter_float" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Double/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_float" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_double (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_double" ArrayIter_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_double" ArrayIter_double'new [#_"double[]" array, #_"int" i]
        (let [this (ArrayIter_double'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_double" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Double" (§ method next) [#_"ArrayIter_double" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_double" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_long (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_long" ArrayIter_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_long" ArrayIter_long'new [#_"long[]" array, #_"int" i]
        (let [this (ArrayIter_long'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_long" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_long" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Long/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_long" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_byte (§ implements Iterator<Byte>)
    (defn- #_"ArrayIter_byte" ArrayIter_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_byte" ArrayIter_byte'new [#_"byte[]" array, #_"int" i]
        (let [this (ArrayIter_byte'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_byte" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Byte" (§ method next) [#_"ArrayIter_byte" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_byte" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_char (§ implements Iterator<Character>)
    (defn- #_"ArrayIter_char" ArrayIter_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_char" ArrayIter_char'new [#_"char[]" array, #_"int" i]
        (let [this (ArrayIter_char'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_char" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Character" (§ method next) [#_"ArrayIter_char" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_char" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_short (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_short" ArrayIter_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_short" ArrayIter_short'new [#_"short[]" array, #_"int" i]
        (let [this (ArrayIter_short'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_short" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_short" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Long/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_short" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
    (defn- #_"ArrayIter_boolean" ArrayIter_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_boolean" ArrayIter_boolean'new [#_"boolean[]" array, #_"int" i]
        (let [this (ArrayIter_boolean'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_boolean" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Boolean" (§ method next) [#_"ArrayIter_boolean" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Boolean/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_boolean" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter (§ implements Iterator)
    (def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException. "remove() not supported"))
            )
        )
    )

    (defn #_"Iterator" ArrayIter'create-0 []
        ArrayIter'EMPTY_ITERATOR
    )

    (defn #_"Iterator" ArrayIter'create-1 [& #_"Object..." array]
        (if (and (some? array) (pos? (alength array)))
            (ArrayIter'new array, 0)
            ArrayIter'EMPTY_ITERATOR
        )
    )

    (defn #_"Iterator" ArrayIter'createFromObject [#_"Object" array]
        (when (and (some? array) (pos? (Array/getLength array))) => ArrayIter'EMPTY_ITERATOR
            (condp = (.getClass array)
                (§ class int[])     (ArrayIter_int'new     (§ cast int[]     array), 0)
                (§ class float[])   (ArrayIter_float'new   (§ cast float[]   array), 0)
                (§ class double[])  (ArrayIter_double'new  (§ cast double[]  array), 0)
                (§ class long[])    (ArrayIter_long'new    (§ cast long[]    array), 0)
                (§ class byte[])    (ArrayIter_byte'new    (§ cast byte[]    array), 0)
                (§ class char[])    (ArrayIter_char'new    (§ cast char[]    array), 0)
                (§ class short[])   (ArrayIter_short'new   (§ cast short[]   array), 0)
                (§ class boolean[]) (ArrayIter_boolean'new (§ cast boolean[] array), 0)
                                    (ArrayIter'new                           array,  0)
            )
        )
    )

    (defn- #_"ArrayIter" ArrayIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter" ArrayIter'new [#_"Object" array, #_"int" i]
        (let [this (ArrayIter'init)]
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :array (§ cast Object[] array)))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"ArrayIter" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_int" ArraySeq_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_int" ArraySeq_int'new [#_"IPersistentMap" meta, #_"int[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_int'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_int" this]
        (aget (:array this) (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_int" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_int'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_int" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_int" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_int" (§ method withMeta) [#_"ArraySeq_int" this, #_"IPersistentMap" meta]
        (ArraySeq_int'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_int" this, #_"IFn" f]
        (let [#_"int[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_int" this, #_"IFn" f, #_"Object" r]
        (let [#_"int[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_int" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"int" k (.intValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= k (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_int" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"int" k (.intValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= k (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_float" ArraySeq_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_float" ArraySeq_float'new [#_"IPersistentMap" meta, #_"float[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_float'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_float" this]
        (Numbers'num-1f (aget (:array this) (:i this)))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_float" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_float'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_float" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_float" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_float" (§ method withMeta) [#_"ArraySeq_float" this, #_"IPersistentMap" meta]
        (ArraySeq_float'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_float" this, #_"IFn" f]
        (let [#_"float[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (Numbers'num-1f (aget a i)) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (Numbers'num-1f (aget a i)))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_float" this, #_"IFn" f, #_"Object" r]
        (let [#_"float[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (Numbers'num-1f (aget a i))) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (Numbers'num-1f (aget a i))) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_float" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"float" f (.floatValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= f (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_float" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"float" f (.floatValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= f (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_double" ArraySeq_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_double" ArraySeq_double'new [#_"IPersistentMap" meta, #_"double[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_double'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_double" this]
        (aget (:array this) (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_double" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_double'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_double" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_double" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_double" (§ method withMeta) [#_"ArraySeq_double" this, #_"IPersistentMap" meta]
        (ArraySeq_double'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_double" this, #_"IFn" f]
        (let [#_"double[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_double" this, #_"IFn" f, #_"Object" r]
        (let [#_"double[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_double" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"double" d (.doubleValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= d (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_double" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"double" d (.doubleValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= d (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_long" ArraySeq_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_long" ArraySeq_long'new [#_"IPersistentMap" meta, #_"long[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_long'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_long" this]
        (Numbers'num-1l (aget (:array this) (:i this)))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_long" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_long'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_long" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_long" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_long" (§ method withMeta) [#_"ArraySeq_long" this, #_"IPersistentMap" meta]
        (ArraySeq_long'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_long" this, #_"IFn" f]
        (let [#_"long[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (Numbers'num-1l (aget a i)) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (Numbers'num-1l (aget a i)))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_long" this, #_"IFn" f, #_"Object" r]
        (let [#_"long[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (Numbers'num-1l (aget a i))) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (Numbers'num-1l (aget a i))) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_long" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"long" l (.longValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= l (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_long" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"long" l (.longValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= l (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_byte" ArraySeq_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_byte" ArraySeq_byte'new [#_"IPersistentMap" meta, #_"byte[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_byte'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_byte" this]
        (aget (:array this) (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_byte" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_byte'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_byte" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_byte" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_byte" (§ method withMeta) [#_"ArraySeq_byte" this, #_"IPersistentMap" meta]
        (ArraySeq_byte'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_byte" this, #_"IFn" f]
        (let [#_"byte[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_byte" this, #_"IFn" f, #_"Object" r]
        (let [#_"byte[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_byte" this, #_"Object" o]
        (or
            (when (instance? Byte o)
                (let [#_"byte" b (.byteValue (cast Byte o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_byte" this, #_"Object" o]
        (or
            (when (instance? Byte o)
                (let [#_"byte" b (.byteValue (cast Byte o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_char" ArraySeq_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_char" ArraySeq_char'new [#_"IPersistentMap" meta, #_"char[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_char'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_char" this]
        (aget (:array this) (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_char" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_char'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_char" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_char" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_char" (§ method withMeta) [#_"ArraySeq_char" this, #_"IPersistentMap" meta]
        (ArraySeq_char'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_char" this, #_"IFn" f]
        (let [#_"char[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_char" this, #_"IFn" f, #_"Object" r]
        (let [#_"char[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_char" this, #_"Object" o]
        (or
            (when (instance? Character o)
                (let [#_"char" c (.charValue (cast Character o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= c (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_char" this, #_"Object" o]
        (or
            (when (instance? Character o)
                (let [#_"char" c (.charValue (cast Character o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= c (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_short" ArraySeq_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_short" ArraySeq_short'new [#_"IPersistentMap" meta, #_"short[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_short'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_short" this]
        (aget (:array this) (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_short" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_short'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_short" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_short" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_short" (§ method withMeta) [#_"ArraySeq_short" this, #_"IPersistentMap" meta]
        (ArraySeq_short'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_short" this, #_"IFn" f]
        (let [#_"short[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_short" this, #_"IFn" f, #_"Object" r]
        (let [#_"short[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_short" this, #_"Object" o]
        (or
            (when (instance? Short o)
                (let [#_"short" s (.shortValue (cast Short o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= s (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_short" this, #_"Object" o]
        (or
            (when (instance? Short o)
                (let [#_"short" s (.shortValue (cast Short o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= s (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_boolean" ArraySeq_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_boolean" ArraySeq_boolean'new [#_"IPersistentMap" meta, #_"boolean[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq_boolean'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq_boolean" this]
        (aget (:array this) (:i this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq_boolean" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_boolean'new (.meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq_boolean" this]
        (- (alength (:array this)) (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_boolean" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_boolean" (§ method withMeta) [#_"ArraySeq_boolean" this, #_"IPersistentMap" meta]
        (ArraySeq_boolean'new meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_boolean" this, #_"IFn" f]
        (let [#_"boolean[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (.invoke f, r, (aget a i))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_boolean" this, #_"IFn" f, #_"Object" r]
        (let [#_"boolean[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_boolean" this, #_"Object" o]
        (or
            (when (instance? Boolean o)
                (let [#_"boolean" b (.booleanValue (cast Boolean o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_boolean" this, #_"Object" o]
        (or
            (when (instance? Boolean o)
                (let [#_"boolean" b (.booleanValue (cast Boolean o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn #_"ArraySeq" ArraySeq'create-0 []
        nil
    )

    (defn #_"ArraySeq" ArraySeq'create-1 [& #_"Object..." array]
        (when (and (some? array) (pos? (alength array)))
            (ArraySeq'new-2 array, 0)
        )
    )

    (defn #_"ISeq" ArraySeq'createFromObject [#_"Object" array]
        (when (and (some? array) (pos? (Array/getLength array)))
            (condp = (.getClass array)
                (§ class int[])     (ArraySeq_int'new     nil, (§ cast int[]     array), 0)
                (§ class float[])   (ArraySeq_float'new   nil, (§ cast float[]   array), 0)
                (§ class double[])  (ArraySeq_double'new  nil, (§ cast double[]  array), 0)
                (§ class long[])    (ArraySeq_long'new    nil, (§ cast long[]    array), 0)
                (§ class byte[])    (ArraySeq_byte'new    nil, (§ cast byte[]    array), 0)
                (§ class char[])    (ArraySeq_char'new    nil, (§ cast char[]    array), 0)
                (§ class short[])   (ArraySeq_short'new   nil, (§ cast short[]   array), 0)
                (§ class boolean[]) (ArraySeq_boolean'new nil, (§ cast boolean[] array), 0)
                                    (ArraySeq'new-2                              array,  0)
            )
        )
    )

    (defn- #_"ArraySeq" ArraySeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-2 [#_"Object" array, #_"int" i]
        (let [this (merge (ASeq'new) (ArraySeq'init))]
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :array (§ cast Object[] array)))
            this
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-3 [#_"IPersistentMap" meta, #_"Object" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (ArraySeq'init))]
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :array (§ cast Object[] array)))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ArraySeq" this]
        (when (some? (:array this))
            (aget (:array this) (:i this))
        )
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ArraySeq" this]
        (when (and (some? (:array this)) (< (inc (:i this)) (alength (:array this))))
            (ArraySeq'new-2 (:array this), (inc (:i this)))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ArraySeq" this]
        (if (some? (:array this)) (- (alength (:array this)) (:i this)) 0)
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq" (§ method withMeta) [#_"ArraySeq" this, #_"IPersistentMap" meta]
        (ArraySeq'new-3 meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq" this, #_"IFn" f]
        (when-let [#_"Object[]" a (:array this)]
            (let [#_"int" i (:i this) #_"int" n (alength a)]
                (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                    (let [r (.invoke f, r, (aget a i))]
                        (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq" this, #_"IFn" f, #_"Object" r]
        (when-let [#_"Object[]" a (:array this)]
            (let [#_"int" i (:i this) #_"int" n (alength a)]
                (loop-when [r (.invoke f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (aget a i)) (inc i)))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq" this, #_"Object" o]
        (when (some? (:array this)) => -1
            (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                (if (Util'equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq" this, #_"Object" o]
        (when (some? (:array this)) => -1
            (if (nil? o)
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (nil? (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (defn- #_"ASeq" ASeq'init []
        (hash-map
            #_transient
            #_"int" :_hash 0
            #_transient
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"ASeq" ASeq'new-1 [#_"IPersistentMap" meta]
        (merge (Obj'new meta) (ASeq'init))
    )

    #_protected
    (defn #_"ASeq" ASeq'new-0 []
        (merge (Obj'new) (ASeq'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ASeq" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"ASeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"ASeq" this, #_"Object" obj]
        (and (or (§ instance? Sequential obj) (instance? List obj))
            (let [#_"ISeq" ms (RT'seq obj)]
                (loop-when [#_"ISeq" s (.seq this) ms ms] (some? s) => (nil? ms)
                    (and (some? ms) (Util'equiv-2oo (.first s), (.first ms)) (recur (.next s) (.next ms)))
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"ASeq" this, #_"Object" obj]
        (or (= this obj)
            (and (or (§ instance? Sequential obj) (instance? List obj))
                (let [#_"ISeq" ms (RT'seq obj)]
                    (loop-when [#_"ISeq" s (.seq this) ms ms] (some? s) => (nil? ms)
                        (and (some? ms) (Util'equals (.first s), (.first ms)) (recur (.next s) (.next ms)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"ASeq" this]
        (when (zero? (:_hash this))
            (let [#_"int" hash 1]
                (loop-when-recur [#_"ISeq" s (.seq this)] (some? s) [(.next s)]
                    (§ ass hash (+ (* 31 hash) (if (nil? (.first s)) 0 (.hashCode (.first s)))))
                )
                (§ ass this (assoc this :_hash hash))
            )
        )
        (:_hash this)
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"ASeq" this]
        (when (zero? (:_hasheq this))
            (§ ass this (assoc this :_hasheq (Murmur3'hashOrdered this)))
        )
        (:_hasheq this)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ASeq" this]
        (loop-when [#_"ISeq" s (.next this) #_"int" i 1] (some? s) => i
            (if (§ instance? Counted s) (+ i (.count s)) (recur (.next s) (inc i)))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"ASeq" this]
        this
    )

    #_method
    (§ defn #_"ISeq" (§ method cons) [#_"ASeq" this, #_"Object" o]
        (Cons'new-2 o, this)
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"ASeq" this]
        (or (.next this) PersistentList'EMPTY)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"ASeq" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"ASeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"ASeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"ASeq" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (not (.contains this, o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"ASeq" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"ASeq" this]
        (.count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"ASeq" this]
        (nil? (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"ASeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ASeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"ASeq" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"ASeq" this, #_"int" fromIndex, #_"int" toIndex]
        (.subList (.reify this), fromIndex, toIndex)
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"ASeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"ASeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ASeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this) #_"int" i 0] (some? s) => -1
            (if (Util'equiv-2oo (.first s), o) i (recur (.next s) (inc i)))
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ASeq" this, #_"Object" o]
        (.lastIndexOf (.reify this), o)
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"ASeq" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"ASeq" this, #_"int" index]
        (.listIterator (.reify this), index)
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"ASeq" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"ASeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"ASeq" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Associative

(§ defprotocol Associative #_(§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" Associative'''(§ method containsKey) [#_"Associative" this, #_"Object" key])
    #_abstract
    (#_"IMapEntry" Associative'''(§ method entryAt) [#_"Associative" this, #_"Object" key])
    #_abstract
    (#_"Associative" Associative'''(§ method assoc) [#_"Associative" this, #_"Object" key, #_"Object" val])
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (defn- #_"Atom" Atom'init []
        (hash-map
            #_"AtomicReference" :state nil
        )
    )

    (defn #_"Atom" Atom'new-1 [#_"Object" state]
        (let [this (merge (ARef'new-0) (Atom'init))]
            (§ ass this (assoc this :state (AtomicReference. state)))
            this
        )
    )

    (defn #_"Atom" Atom'new-2 [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Atom'init))]
            (§ ass this (assoc this :state (AtomicReference. state)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Atom" this]
        (.get (:state this))
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" f]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.invoke f, v)]
                (.validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (.notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.invoke f, v, arg)]
                (.validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (.notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.invoke f, v, arg1, arg2)]
                (.validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (.notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (loop []
            (let [#_"Object" v (.deref this) #_"Object" newv (.applyTo f, (RT'listStar-4 v, x, y, args))]
                (.validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (.notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" f]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.invoke f, oldv)]
                (.validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (.notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.invoke f, oldv, arg)]
                (.validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (.notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.invoke f, oldv, arg1, arg2)]
                (.validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (.notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (loop []
            (let [#_"Object" oldv (.deref this) #_"Object" newv (.applyTo f, (RT'listStar-4 oldv, x, y, args))]
                (.validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (.notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method compareAndSet) [#_"Atom" this, #_"Object" oldv, #_"Object" newv]
        (.validate this, newv)
        (let [#_"boolean" ret (.compareAndSet (:state this), oldv, newv)]
            (when ret
                (.notifyWatches this, oldv, newv)
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reset) [#_"Atom" this, #_"Object" newval]
        (let [#_"Object" oldval (.get (:state this))]
            (.validate this, newval)
            (.set (:state this), newval)
            (.notifyWatches this, oldval, newval)
            newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method resetVals) [#_"Atom" this, #_"Object" newv]
        (.validate this, newv)
        (loop []
            (let [#_"Object" oldv (.deref this)]
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (.notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_protected
    (defn #_"ATransientMap" ATransientMap'new []
        (AFn'new)
    )

    #_abstract
    (§ defn #_"void" (§ method ensureEditable) [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"ATransientMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"ATransientMap" this, #_"Object" key])
    #_abstract
    (§ defn #_"Object" (§ method doValAt) [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound])
    #_abstract
    (§ defn #_"int" (§ method doCount) [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"ATransientMap" this])

    #_method
    (§ defn #_"ITransientMap" (§ method conj) [#_"ATransientMap" this, #_"Object" o]
        (.ensureEditable this)
        (cond
            (instance? Map$Entry o)
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (.assoc this, (.getKey e), (.getValue e))
                )
            (§ instance? IPersistentVector o)
                (let [#_"IPersistentVector" v (cast' IPersistentVector o)]
                    (when (= (.count v) 2) => (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                        (.assoc this, (.nth v, 0), (.nth v, 1))
                    )
                )
            :else
                (loop-when [#_"ITransientMap" m this #_"ISeq" s (RT'seq o)] (some? s) => m
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (recur (.assoc m, (.getKey e), (.getValue e)) (.next s))
                    )
                )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientMap" this, #_"Object" arg1]
        (.valAt this, arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientMap" this, #_"Object" arg1, #_"Object" notFound]
        (.valAt this, arg1, notFound)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ATransientMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (§ defn #_"ITransientMap" (§ method assoc) [#_"ATransientMap" this, #_"Object" key, #_"Object" val]
        (.ensureEditable this)
        (.doAssoc this, key, val)
    )

    #_method
    (§ defn #_"ITransientMap" (§ method without) [#_"ATransientMap" this, #_"Object" key]
        (.ensureEditable this)
        (.doWithout this, key)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method persistent) [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doPersistent this)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound]
        (.ensureEditable this)
        (.doValAt this, key, notFound)
    )

    (def- #_"Object" ATransientMap'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"ATransientMap" this, #_"Object" key]
        (not= (.valAt this, key, ATransientMap'NOT_FOUND) ATransientMap'NOT_FOUND)
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"ATransientMap" this, #_"Object" key]
        (let [#_"Object" v (.valAt this, key, ATransientMap'NOT_FOUND)]
            (when-not (= v ATransientMap'NOT_FOUND)
                (MapEntry'create key, v)
            )
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doCount this)
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (defn- #_"ATransientSet" ATransientSet'init []
        (hash-map
            #_volatile
            #_"ITransientMap" :impl nil
        )
    )

    (defn #_"ATransientSet" ATransientSet'new [#_"ITransientMap" impl]
        (let [this (merge (AFn'new) (ATransientSet'init))]
            (§ ass this (assoc this :impl impl))
            this
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ATransientSet" this]
        (.count (:impl this))
    )

    #_method
    (§ defn #_"ITransientSet" (§ method conj) [#_"ATransientSet" this, #_"Object" val]
        (let [#_"ITransientMap" m (.assoc (:impl this), val, val)]
            (when-not (= m (:impl this))
                (§ ass this (assoc this :impl m))
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"ATransientSet" this, #_"Object" key]
        (not= this (.valAt (:impl this), key, this))
    )

    #_method
    (§ defn #_"ITransientSet" (§ method disjoin) [#_"ATransientSet" this, #_"Object" key]
        (let [#_"ITransientMap" m (.without (:impl this), key)]
            (when-not (= m (:impl this))
                (§ ass this (assoc this :impl m))
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"ATransientSet" this, #_"Object" key]
        (.valAt (:impl this), key)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientSet" this, #_"Object" key, #_"Object" notFound]
        (.valAt (:impl this), key, notFound)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientSet" this, #_"Object" key]
        (.valAt (:impl this), key)
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" BigInt'ZERO (BigInt'new 0, nil))
    (§ def #_"BigInt" BigInt'ONE (BigInt'new 1, nil))

    (defn- #_"BigInt" BigInt'init []
        (hash-map
            #_"long" :lpart 0
            #_"BigInteger" :bipart nil
        )
    )

    (defn- #_"BigInt" BigInt'new [#_"long" lpart, #_"BigInteger" bipart]
        (let [this (merge (Number'new) (BigInt'init))]
            (§ ass this (assoc this :lpart lpart))
            (§ ass this (assoc this :bipart bipart))
            this
        )
    )

    ;; must follow Long
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (int (bit-xor (:lpart this) (>>> (:lpart this) 32)))
            (.hashCode (:bipart this))
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (Murmur3'hashLong (:lpart this))
            (.hashCode (:bipart this))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"BigInt" this, #_"Object" obj]
        (cond
            (= this obj)
                true
            (§ instance? BigInt obj)
                (let [#_"BigInt" o (cast' BigInt obj)]
                    (if (nil? (:bipart this))
                        (and (nil? (:bipart o)) (= (:lpart this) (:lpart o)))
                        (and (some? (:bipart o)) (.equals (:bipart this), (:bipart o)))
                    )
                )
            :else
                false
        )
    )

    (defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" val]
        (if (< (.bitLength val) 64)
            (BigInt'new (.longValue val), nil)
            (BigInt'new 0, val)
        )
    )

    (defn #_"BigInt" BigInt'fromLong [#_"long" val]
        (BigInt'new val, nil)
    )

    #_method
    (§ defn #_"BigInteger" (§ method toBigInteger) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (BigInteger/valueOf (:lpart this))
            (:bipart this)
        )
    )

    #_method
    (§ defn #_"BigDecimal" (§ method toBigDecimal) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (BigDecimal/valueOf (:lpart this))
            (BigDecimal. (:bipart this))
        )
    )

    #_method
    (§ defn #_"int" (§ method intValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (int (:lpart this))
            (.intValue (:bipart this))
        )
    )

    #_method
    (§ defn #_"long" (§ method longValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.longValue (:bipart this))
        )
    )

    #_method
    (§ defn #_"float" (§ method floatValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.floatValue (:bipart this))
        )
    )

    #_method
    (§ defn #_"double" (§ method doubleValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.doubleValue (:bipart this))
        )
    )

    #_method
    (§ defn #_"byte" (§ method byteValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (byte (:lpart this))
            (.byteValue (:bipart this))
        )
    )

    #_method
    (§ defn #_"short" (§ method shortValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (short (:lpart this))
            (.shortValue (:bipart this))
        )
    )

    (defn #_"BigInt" BigInt'valueOf [#_"long" val]
        (BigInt'new val, nil)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (String/valueOf (:lpart this))
            (.toString (:bipart this))
        )
    )

    #_method
    (§ defn #_"int" (§ method bitLength) [#_"BigInt" this]
        (.bitLength (.toBigInteger this))
    )

    #_method
    (§ defn #_"BigInt" (§ method add) [#_"BigInt" this, #_"BigInt" y]
        (or
            (when (and (nil? (:bipart this)) (nil? (:bipart y)))
                (let [#_"long" ret (+ (:lpart this) (:lpart y))]
                    (when (or (<= 0 (bit-xor ret (:lpart this))) (<= 0 (bit-xor ret (:lpart y))))
                        (BigInt'valueOf ret)
                    )
                )
            )
            (BigInt'fromBigInteger (.add (.toBigInteger this), (.toBigInteger y)))
        )
    )

    #_method
    (§ defn #_"BigInt" (§ method multiply) [#_"BigInt" this, #_"BigInt" y]
        (or
            (when (and (nil? (:bipart this)) (nil? (:bipart y)))
                (let [#_"long" ret (* (:lpart this) (:lpart y))]
                    (when (or (zero? (:lpart y)) (and (= (/ ret (:lpart y)) (:lpart this)) (not= (:lpart this) Long/MIN_VALUE)))
                        (BigInt'valueOf ret)
                    )
                )
            )
            (BigInt'fromBigInteger (.multiply (.toBigInteger this), (.toBigInteger y)))
        )
    )

    #_method
    (§ defn #_"BigInt" (§ method quotient) [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (if (and (= (:lpart this) Long/MIN_VALUE) (= (:lpart y) -1))
                (BigInt'fromBigInteger (.negate (.toBigInteger this)))
                (BigInt'valueOf (/ (:lpart this) (:lpart y)))
            )
            (BigInt'fromBigInteger (.divide (.toBigInteger this), (.toBigInteger y)))
        )
    )

    #_method
    (§ defn #_"BigInt" (§ method remainder) [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (BigInt'valueOf (% (:lpart this) (:lpart y)))
            (BigInt'fromBigInteger (.remainder (.toBigInteger this), (.toBigInteger y)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (< (:lpart this) (:lpart y))
            (neg? (.compareTo (.toBigInteger this), (.toBigInteger y)))
        )
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (defn- #_"Binding" Binding'init []
        (hash-map
            #_"T" :val nil
            #_"Binding" :rest nil
        )
    )

    (defn #_"Binding" Binding'new-1 [#_"T" val]
        (let [this (Binding'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :rest nil))
            this
        )
    )

    (defn #_"Binding" Binding'new-2 [#_"T" val, #_"Binding" rest]
        (let [this (Binding'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :rest rest))
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (defn- #_"Box" Box'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Box" Box'new [#_"Object" val]
        (let [this (Box'init)]
            (§ ass this (assoc this :val val))
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (defn- #_"ChunkBuffer" ChunkBuffer'init []
        (hash-map
            #_"Object[]" :buffer nil
            #_"int" :end 0
        )
    )

    (defn #_"ChunkBuffer" ChunkBuffer'new [#_"int" capacity]
        (let [this (ChunkBuffer'init)]
            (§ ass this (assoc this :buffer (make-array Object capacity)))
            (§ ass this (assoc this :end 0))
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"ChunkBuffer" this, #_"Object" o]
        (aset (:buffer this) (:end this) o)
        (§ ass this (assoc this :end (inc (:end this))))
        nil
    )

    #_method
    (§ defn #_"IChunk" (§ method chunk) [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ret (ArrayChunk'new-3 (:buffer this), 0, (:end this))]
            (§ ass this (assoc this :buffer nil))
            ret
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ChunkBuffer" this]
        (:end this)
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (defn- #_"ChunkedCons" ChunkedCons'init []
        (hash-map
            #_"IChunk" :chunk nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-3 [#_"IPersistentMap" meta, #_"IChunk" chunk, #_"ISeq" more]
        (let [this (merge (ASeq'new meta) (ChunkedCons'init))]
            (§ ass this (assoc this :chunk chunk))
            (§ ass this (assoc this :_more more))
            this
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-2 [#_"IChunk" chunk, #_"ISeq" more]
        (ChunkedCons'new-3 nil, chunk, more)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"ChunkedCons" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (ChunkedCons'new-3 meta, (:chunk this), (:_more this))
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ChunkedCons" this]
        (.nth (:chunk this), 0)
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ChunkedCons" this]
        (if (< 1 (.count (:chunk this)))
            (ChunkedCons'new-2 (.dropFirst (:chunk this)), (:_more this))
            (.chunkedNext this)
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"ChunkedCons" this]
        (if (< 1 (.count (:chunk this)))
            (ChunkedCons'new-2 (.dropFirst (:chunk this)), (:_more this))
            (or (:_more this) PersistentList'EMPTY)
        )
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"ChunkedCons" this]
        (:chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"ChunkedCons" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"ChunkedCons" this]
        (or (:_more this) PersistentList'EMPTY)
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

#_private
#_stateless
(class-ns Recur
)

(§ defprotocol Expr
    #_abstract
    (#_"Object" Expr'''(§ method eval) [#_"Expr" this])
    #_abstract
    (#_"void" Expr'''(§ method emit) [#_"Expr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
    #_abstract
    (#_"boolean" Expr'''(§ method hasJavaClass) [#_"Expr" this])
    #_abstract
    (#_"Class" Expr'''(§ method getJavaClass) [#_"Expr" this])
)

#_stateless
#_abstract
(class-ns UntypedExpr (§ implements Expr)
    #_protected
    (defn #_"UntypedExpr" UntypedExpr'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"UntypedExpr" this]
        false
    )
)

(§ defprotocol IParser
    #_abstract
    (#_"Expr" IParser'''(§ method parse) [#_"IParser" this, #_"Context" context, #_"Object" form])
)

#_closure
(class-ns DefParser (§ implements IParser)
    (defn #_"DefParser" DefParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"DefParser" this, #_"Context" context, #_"Object" form]
        ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
        (let [#_"String" docstring nil]
            (when (and (= (RT'count form) 4) (instance? String (RT'third form)))
                (§ ass docstring (cast String (RT'third form)))
                (§ ass form (RT'list-3 (RT'first form), (RT'second form), (RT'fourth form)))
            )
            (cond (< 3 (RT'count form))
                (do
                    (throw (RuntimeException. "Too many arguments to def"))
                )
                (< (RT'count form) 2)
                (do
                    (throw (RuntimeException. "Too few arguments to def"))
                )
                (not (§ instance? Symbol (RT'second form)))
                (do
                    (throw (RuntimeException. "First argument to def must be a Symbol"))
                )
            )
            (let [#_"Symbol" sym (cast' Symbol (RT'second form))]
                (let [#_"Var" v (Compiler'lookupVar-2 sym, true)]
                    (when (nil? v)
                        (throw (RuntimeException. "Can't refer to qualified var that doesn't exist"))
                    )
                    (let [#_"boolean" shadowsCoreMapping false]
                        (when (not (.equals (:ns v), (Compiler'currentNS)))
                            (if (nil? (:ns sym))
                                (do
                                    (§ ass v (.intern (Compiler'currentNS), sym))
                                    (§ ass shadowsCoreMapping true)
                                    (Compiler'registerVar v)
                                )
                                (do
                                    (throw (RuntimeException. "Can't create defs outside of current ns"))
                                )
                            )
                        )
                        (let [#_"IPersistentMap" mm (.meta sym)]
                            (let [#_"boolean" isDynamic (RT'booleanCast-1o (RT'get-2 mm, Compiler'dynamicKey))]
                                (when isDynamic
                                    (.setDynamic v)
                                )
                                (when (and (not isDynamic) (.startsWith (:name sym), "*") (.endsWith (:name sym), "*") (< 2 (.length (:name sym))))
                                    (.format (RT'errPrintWriter), "Warning: %s not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic or change the name.\n", (object-array [ sym ]))
                                )
                                (§ ass mm (cast' IPersistentMap
                                    (-> mm
                                        (RT'assoc RT'LINE_KEY, (.get Compiler'LINE))
                                        (.assoc RT'COLUMN_KEY, (.get Compiler'COLUMN))
                                    )
                                ))
                                (when (some? docstring)
                                    (§ ass mm (cast' IPersistentMap (RT'assoc mm, RT'DOC_KEY, docstring)))
                                )
                                (let [#_"Expr" meta (if (zero? (.count mm)) nil (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), mm))]
                                    (DefExpr'new (Compiler'lineDeref), (Compiler'columnDeref), v, (Compiler'analyze-3 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'third form), (:name (:sym v))), meta, (= (RT'count form) 3), isDynamic, shadowsCoreMapping)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr (§ implements Expr)
    (def #_"Method" DefExpr'bindRootMethod (Method/getMethod "void bindRoot(Object)"))
    (def #_"Method" DefExpr'setTagMethod (Method/getMethod "void setTag(cloiure.lang.Symbol)"))
    (def #_"Method" DefExpr'setMetaMethod (Method/getMethod "void setMeta(cloiure.lang.IPersistentMap)"))
    (def #_"Method" DefExpr'setDynamicMethod (Method/getMethod "cloiure.lang.Var setDynamic(boolean)"))
    (def #_"Method" DefExpr'internVar (Method/getMethod "cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

    (defn- #_"DefExpr" DefExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Expr" :init nil
            #_"Expr" :meta nil
            #_"boolean" :initProvided false
            #_"boolean" :isDynamic false
            #_"boolean" :shadowsCoreMapping false
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"DefExpr" DefExpr'new [#_"int" line, #_"int" column, #_"Var" var, #_"Expr" init, #_"Expr" meta, #_"boolean" initProvided, #_"boolean" isDynamic, #_"boolean" shadowsCoreMapping]
        (let [this (DefExpr'init)]
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :var var))
            (§ ass this (assoc this :init init))
            (§ ass this (assoc this :meta meta))
            (§ ass this (assoc this :isDynamic isDynamic))
            (§ ass this (assoc this :shadowsCoreMapping shadowsCoreMapping))
            (§ ass this (assoc this :initProvided initProvided))
            this
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method includesExplicitMetadata) [#_"DefExpr" this, #_"MapExpr" expr]
        (loop-when [#_"int" i 0] (< i (.count (:keyvals expr))) => false
            (let [#_"Keyword" k (:k (cast' KeywordExpr (.nth (:keyvals expr), i)))]
                (recur-if (any = k RT'DECLARED_KEY RT'LINE_KEY RT'COLUMN_KEY) [(+ i 2)] => true)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"DefExpr" this]
        (try
            (when (:initProvided this)
                (.bindRoot (:var this), (.eval (:init this)))
            )
            (when (some? (:meta this))
                (let [#_"IPersistentMap" metaMap (cast' IPersistentMap (.eval (:meta this)))]
                    (when (or (:initProvided this) true) ;; includesExplicitMetadata((MapExpr) meta)
                        (.setMeta (:var this), metaMap)
                    )
                )
            )
            (.setDynamic (:var this), (:isDynamic this))
            (catch Throwable e
                (if (not (§ instance? CompilerException e))
                    (do
                        (throw (CompilerException'new (:line this), (:column this), e))
                    )
                    (do
                        (throw (cast' CompilerException e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"DefExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitVar objx, gen, (:var this))
        (when (:shadowsCoreMapping this)
            (.dup gen)
            (.getField gen, Compiler'VAR_TYPE, "ns", Compiler'NS_TYPE)
            (.swap gen)
            (.dup gen)
            (.getField gen, Compiler'VAR_TYPE, "sym", Compiler'SYMBOL_TYPE)
            (.swap gen)
            (.invokeVirtual gen, Compiler'NS_TYPE, DefExpr'internVar)
        )
        (when (:isDynamic this)
            (.push gen, (:isDynamic this))
            (.invokeVirtual gen, Compiler'VAR_TYPE, setDynamicMethod)
        )
        (when (some? (:meta this))
            (.dup gen)
            (.emit (:meta this), :Context'EXPRESSION, objx, gen)
            (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
            (.invokeVirtual gen, Compiler'VAR_TYPE, setMetaMethod)
        )
        (when (:initProvided this)
            (.dup gen)
            (if (§ instance? FnExpr (:init this))
                (.emitForDefn (cast' FnExpr (:init this)), objx, gen)
                (.emit (:init this), :Context'EXPRESSION, objx, gen)
            )
            (.invokeVirtual gen, Compiler'VAR_TYPE, bindRootMethod)
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"DefExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"DefExpr" this]
        (§ class Var)
    )
)

#_closure
(class-ns AssignParser (§ implements IParser)
    (defn #_"AssignParser" AssignParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"AssignParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            (when-not (= (RT'length form) 3)
                (throw (IllegalArgumentException. "Malformed assignment, expecting (set! target val)"))
            )
            (let [#_"Expr" target (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form))]
                (when (not (§ instance? AssignableExpr target))
                    (throw (IllegalArgumentException. "Invalid assignment target"))
                )
                (AssignExpr'new (cast' AssignableExpr target), (Compiler'analyze-2 :Context'EXPRESSION, (RT'third form)))
            )
        )
    )
)

(class-ns AssignExpr (§ implements Expr)
    (defn- #_"AssignExpr" AssignExpr'init []
        (hash-map
            #_"AssignableExpr" :target nil
            #_"Expr" :val nil
        )
    )

    (defn #_"AssignExpr" AssignExpr'new [#_"AssignableExpr" target, #_"Expr" val]
        (let [this (AssignExpr'init)]
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"AssignExpr" this]
        (.evalAssign (:target this), (:val this))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"AssignExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitAssign (:target this), context, objx, gen, (:val this))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"AssignExpr" this]
        (.hasJavaClass (:val this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"AssignExpr" this]
        (.getJavaClass (:val this))
    )
)

(class-ns VarExpr (§ implements Expr, AssignableExpr)
    (def #_"Method" VarExpr'getMethod (Method/getMethod "Object get()"))
    (def #_"Method" VarExpr'setMethod (Method/getMethod "Object set(Object)"))

    (defn- #_"VarExpr" VarExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"VarExpr" VarExpr'new [#_"Var" var, #_"Symbol" tag]
        (let [this (VarExpr'init)]
            (§ ass this (assoc this :var var))
            (§ ass this (assoc this :tag (or tag (.getTag var))))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"VarExpr" this]
        (.deref (:var this))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"VarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitVarValue objx, gen, (:var this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"VarExpr" this]
        (some? (:tag this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"VarExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"VarExpr" this, #_"Expr" val]
        (.set (:var this), (.eval val))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"VarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (.emitVar objx, gen, (:var this))
        (.emit val, :Context'EXPRESSION, objx, gen)
        (.invokeVirtual gen, Compiler'VAR_TYPE, VarExpr'setMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

#_closure
(class-ns TheVarParser (§ implements IParser)
    (defn #_"TheVarParser" TheVarParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"TheVarParser" this, #_"Context" context, #_"Object" form]
        (let [#_"Symbol" sym (cast' Symbol (RT'second form)) #_"Var" v (Compiler'lookupVar-2 sym, false)]
            (when (some? v) => (throw (RuntimeException. (str "Unable to resolve var: " sym " in this context")))
                (TheVarExpr'new v)
            )
        )
    )
)

(class-ns TheVarExpr (§ implements Expr)
    (defn- #_"TheVarExpr" TheVarExpr'init []
        (hash-map
            #_"Var" :var nil
        )
    )

    (defn #_"TheVarExpr" TheVarExpr'new [#_"Var" var]
        (let [this (TheVarExpr'init)]
            (§ ass this (assoc this :var var))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"TheVarExpr" this]
        (:var this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"TheVarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitVar objx, gen, (:var this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"TheVarExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"TheVarExpr" this]
        (§ class Var)
    )
)

(class-ns KeywordExpr (§ extends LiteralExpr)
    (defn- #_"KeywordExpr" KeywordExpr'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordExpr" KeywordExpr'new [#_"Keyword" k]
        (let [this (merge (LiteralExpr'new) (KeywordExpr'init))]
            (§ ass this (assoc this :k k))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"KeywordExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitKeyword objx, gen, (:k this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"KeywordExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"KeywordExpr" this]
        (§ class Keyword)
    )
)

#_closure
(class-ns ImportParser (§ implements IParser)
    (defn #_"ImportParser" ImportParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ImportParser" this, #_"Context" context, #_"Object" form]
        (ImportExpr'new (cast String (RT'second form)))
    )
)

(class-ns ImportExpr (§ implements Expr)
    (def #_"Method" ImportExpr'forNameMethod (Method/getMethod "Class classForNameNonLoading(String)"))
    (def #_"Method" ImportExpr'importClassMethod (Method/getMethod "Class importClass(Class)"))
    (def #_"Method" ImportExpr'derefMethod (Method/getMethod "Object deref()"))

    (defn- #_"ImportExpr" ImportExpr'init []
        (hash-map
            #_"String" :c nil
        )
    )

    (defn #_"ImportExpr" ImportExpr'new [#_"String" c]
        (let [this (ImportExpr'init)]
            (§ ass this (assoc this :c c))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ImportExpr" this]
        (let [#_"Namespace" ns (cast' Namespace (.deref RT'CURRENT_NS))]
            (.importClass ns, (RT'classForNameNonLoading (:c this)))
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ImportExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.getStatic gen, Compiler'RT_TYPE, "CURRENT_NS", Compiler'VAR_TYPE)
        (.invokeVirtual gen, Compiler'VAR_TYPE, ImportExpr'derefMethod)
        (.checkCast gen, Compiler'NS_TYPE)
        (.push gen, (:c this))
        (.invokeStatic gen, Compiler'RT_TYPE, ImportExpr'forNameMethod)
        (.invokeVirtual gen, Compiler'NS_TYPE, importClassMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ImportExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

#_stateless
#_abstract
(class-ns LiteralExpr (§ implements Expr)
    #_protected
    (defn #_"LiteralExpr" LiteralExpr'new []
        (hash-map)
    )

    #_abstract
    (§ defn #_"Object" (§ method val) [#_"LiteralExpr" this])

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LiteralExpr" this]
        (.val this)
    )
)

(§ defprotocol AssignableExpr
    #_abstract
    (#_"Object" AssignableExpr'''(§ method evalAssign) [#_"AssignableExpr" this, #_"Expr" val])
    #_abstract
    (#_"void" AssignableExpr'''(§ method emitAssign) [#_"AssignableExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val])
)

(§ defprotocol MaybePrimitiveExpr #_(§ extends Expr)
    #_abstract
    (#_"boolean" MaybePrimitiveExpr'''(§ method canEmitPrimitive) [#_"MaybePrimitiveExpr" this])
    #_abstract
    (#_"void" MaybePrimitiveExpr'''(§ method emitUnboxed) [#_"MaybePrimitiveExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
)

#_closure
(class-ns HostParser (§ implements IParser)
    (defn #_"HostParser" HostParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"HostParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            ;; (. x fieldname-sym) or
            ;; (. x 0-ary-method)
            ;; (. x methodname-sym args+)
            ;; (. x (methodname-sym args?))
            (when (< (RT'length form) 3)
                (throw (IllegalArgumentException. "Malformed member expression, expecting (. target member ...)"))
            )
            ;; determine static or instance
            ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
            (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref)]
                (let [#_"Class" c (HostExpr'maybeClass (RT'second form), false)]
                    ;; at this point c will be non-null if static
                    (let [#_"Expr" instance nil]
                        (when (nil? c)
                            (§ ass instance (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'second form)))
                        )

                        (let [#_"boolean" maybeField (and (= (RT'length form) 3) (§ instance? Symbol (RT'third form)))]
                            (when (and maybeField (not= (.charAt (:name (cast' Symbol (RT'third form))), 0) \-))
                                (let [#_"Symbol" sym (cast' Symbol (RT'third form))]
                                    (cond (some? c)
                                        (do
                                            (§ ass maybeField (zero? (.size (Reflector'getMethods c, 0, (Compiler'munge (:name sym)), true))))
                                        )
                                        (and (some? instance) (.hasJavaClass instance) (some? (.getJavaClass instance)))
                                        (do
                                            (§ ass maybeField (zero? (.size (Reflector'getMethods (.getJavaClass instance), 0, (Compiler'munge (:name sym)), false))))
                                        )
                                    )
                                )
                            )

                            (if maybeField ;; field
                                (do
                                    (let [#_"Symbol" sym (if (= (.charAt (:name (cast' Symbol (RT'third form))), 0) \-) (Symbol'intern (.substring (:name (cast' Symbol (RT'third form))), 1)) (cast' Symbol (RT'third form)))]
                                        (let [#_"Symbol" tag (Compiler'tagOf form)]
                                            (if (some? c)
                                                (do
                                                    (StaticFieldExpr'new line, column, c, (Compiler'munge (:name sym)), tag)
                                                )
                                                (do
                                                    (InstanceFieldExpr'new line, column, instance, (Compiler'munge (:name sym)), tag, (= (.charAt (:name (cast' Symbol (RT'third form))), 0) \-))
                                                )
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"ISeq" call (cast' ISeq (if (§ instance? ISeq (RT'third form)) (RT'third form) (RT'next (RT'next form))))]
                                        (when (not (§ instance? Symbol (RT'first call)))
                                            (throw (IllegalArgumentException. "Malformed member expression"))
                                        )
                                        (let [#_"Symbol" sym (cast' Symbol (RT'first call))]
                                            (let [#_"Symbol" tag (Compiler'tagOf form)]
                                                (let [#_"PersistentVector" args PersistentVector'EMPTY]
                                                    (let [#_"boolean" tailPosition (Compiler'inTailCall context)]
                                                        (loop-when-recur [#_"ISeq" s (RT'next call)] (some? s) [(.next s)]
                                                            (§ ass args (.cons args, (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))))
                                                        )
                                                        (if (some? c)
                                                            (StaticMethodExpr'new line, column, tag, c, (Compiler'munge (:name sym)), args, tailPosition)
                                                            (InstanceMethodExpr'new line, column, tag, instance, (Compiler'munge (:name sym)), args, tailPosition)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
#_abstract
(class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
    #_protected
    (defn #_"HostExpr" HostExpr'new []
        (hash-map)
    )

    (def #_"Type" HostExpr'BOOLEAN_TYPE (Type/getType Boolean))
    (def #_"Type" HostExpr'CHAR_TYPE (Type/getType Character))
    (def #_"Type" HostExpr'INTEGER_TYPE (Type/getType Integer))
    (def #_"Type" HostExpr'LONG_TYPE (Type/getType Long))
    (def #_"Type" HostExpr'FLOAT_TYPE (Type/getType Float))
    (def #_"Type" HostExpr'DOUBLE_TYPE (Type/getType Double))
    (def #_"Type" HostExpr'SHORT_TYPE (Type/getType Short))
    (def #_"Type" HostExpr'BYTE_TYPE (Type/getType Byte))
    (def #_"Type" HostExpr'NUMBER_TYPE (Type/getType Number))

    (def #_"Method" HostExpr'charValueMethod (Method/getMethod "char charValue()"))
    (def #_"Method" HostExpr'booleanValueMethod (Method/getMethod "boolean booleanValue()"))

    (def #_"Method" HostExpr'charValueOfMethod (Method/getMethod "Character valueOf(char)"))
    (def #_"Method" HostExpr'intValueOfMethod (Method/getMethod "Integer valueOf(int)"))
    (def #_"Method" HostExpr'longValueOfMethod (Method/getMethod "Long valueOf(long)"))
    (def #_"Method" HostExpr'floatValueOfMethod (Method/getMethod "Float valueOf(float)"))
    (def #_"Method" HostExpr'doubleValueOfMethod (Method/getMethod "Double valueOf(double)"))
    (def #_"Method" HostExpr'shortValueOfMethod (Method/getMethod "Short valueOf(short)"))
    (def #_"Method" HostExpr'byteValueOfMethod (Method/getMethod "Byte valueOf(byte)"))

    (def #_"Method" HostExpr'intValueMethod (Method/getMethod "int intValue()"))
    (def #_"Method" HostExpr'longValueMethod (Method/getMethod "long longValue()"))
    (def #_"Method" HostExpr'floatValueMethod (Method/getMethod "float floatValue()"))
    (def #_"Method" HostExpr'doubleValueMethod (Method/getMethod "double doubleValue()"))
    (def #_"Method" HostExpr'byteValueMethod (Method/getMethod "byte byteValue()"))
    (def #_"Method" HostExpr'shortValueMethod (Method/getMethod "short shortValue()"))

    (def #_"Method" HostExpr'fromIntMethod (Method/getMethod "cloiure.lang.Num from(int)"))
    (def #_"Method" HostExpr'fromLongMethod (Method/getMethod "cloiure.lang.Num from(long)"))
    (def #_"Method" HostExpr'fromDoubleMethod (Method/getMethod "cloiure.lang.Num from(double)"))

    (defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" returnType]
        (when (.isPrimitive returnType)
            (condp = returnType
                Boolean/TYPE
                    (let [#_"Label" falseLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
                        (.ifZCmp gen, GeneratorAdapter/EQ, falseLabel)
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE)
                        (.goTo gen, endLabel)
                        (.mark gen, falseLabel)
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                        (.mark gen, endLabel)
                    )
                Void/TYPE      (.emit Compiler'NIL_EXPR, :Context'EXPRESSION, objx, gen)
                Character/TYPE (.invokeStatic gen, HostExpr'CHAR_TYPE, HostExpr'charValueOfMethod)
                Integer/TYPE   (.invokeStatic gen, HostExpr'INTEGER_TYPE, HostExpr'intValueOfMethod)
                Float/TYPE     (.invokeStatic gen, HostExpr'FLOAT_TYPE, HostExpr'floatValueOfMethod)
                Double/TYPE    (.invokeStatic gen, HostExpr'DOUBLE_TYPE, HostExpr'doubleValueOfMethod)
                Long/TYPE      (.invokeStatic gen, Compiler'NUMBERS_TYPE, (Method/getMethod "Number num(long)"))
                Byte/TYPE      (.invokeStatic gen, HostExpr'BYTE_TYPE, HostExpr'byteValueOfMethod)
                Short/TYPE     (.invokeStatic gen, HostExpr'SHORT_TYPE, HostExpr'shortValueOfMethod)
            )
        )
        nil
    )

    (defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" paramType]
        (when (.isPrimitive paramType) => (.checkCast gen, (Type/getType paramType))
            (condp = paramType
                Boolean/TYPE
                (do
                    (.checkCast gen, HostExpr'BOOLEAN_TYPE)
                    (.invokeVirtual gen, HostExpr'BOOLEAN_TYPE, HostExpr'booleanValueMethod)
                )
                Character/TYPE
                (do
                    (.checkCast gen, HostExpr'CHAR_TYPE)
                    (.invokeVirtual gen, HostExpr'CHAR_TYPE, HostExpr'charValueMethod)
                )
                (do
                    (.checkCast gen, HostExpr'NUMBER_TYPE)
                    (let [#_"Method" m
                            (condp = paramType
                                Integer/TYPE (Method/getMethod "int intCast(Object)")
                                Float/TYPE   (Method/getMethod "float floatCast(Object)")
                                Double/TYPE  (Method/getMethod "double doubleCast(Object)")
                                Long/TYPE    (Method/getMethod "long longCast(Object)")
                                Byte/TYPE    (Method/getMethod "byte byteCast(Object)")
                                Short/TYPE   (Method/getMethod "short shortCast(Object)")
                                             nil
                            )]
                        (.invokeStatic gen, Compiler'RT_TYPE, m)
                    )
                )
            )
        )
        nil
    )

    (defn #_"Class" HostExpr'maybeClass [#_"Object" form, #_"boolean" stringOk]
        (cond
            (instance? Class form)
                (cast Class form)
            (§ instance? Symbol form)
                (let-when [#_"Symbol" sym (cast' Symbol form)] (nil? (:ns sym)) ;; if ns-qualified can't be classname
                    (cond
                        (Util'equals sym, (.get Compiler'COMPILE_STUB_SYM))
                            (cast Class (.get Compiler'COMPILE_STUB_CLASS))
                        (or (pos? (.indexOf (:name sym), \.)) (= (.charAt (:name sym), 0) \[))
                            (RT'classForNameNonLoading (:name sym))
                        :else
                            (let [#_"Object" o (.getMapping (Compiler'currentNS), sym)]
                                (cond
                                    (instance? Class o)
                                        (cast Class o)
                                    (and (some? (.deref Compiler'LOCAL_ENV)) (.containsKey (cast java.util.Map (.deref Compiler'LOCAL_ENV)), form))
                                        nil
                                    :else
                                        (try
                                            (RT'classForNameNonLoading (:name sym))
                                            (catch Exception _
                                                nil
                                            )
                                        )
                                )
                            )
                    )
                )
            (and stringOk (instance? String form))
                (RT'classForNameNonLoading (cast String form))
        )
    )

    (defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" sym]
        (or (Compiler'primClass-1s sym)
            (case (:name sym)
                "objects"  (§ class Object[])
                "ints"     (§ class int[])
                "longs"    (§ class long[])
                "floats"   (§ class float[])
                "doubles"  (§ class double[])
                "chars"    (§ class char[])
                "shorts"   (§ class short[])
                "bytes"    (§ class byte[])
                "booleans" (§ class boolean[])
                           nil
            )
        )
    )

    (defn #_"Class" HostExpr'tagToClass [#_"Object" tag]
        (or
            (when (§ instance? Symbol tag)
                (let-when [#_"Symbol" sym (cast' Symbol tag)] (nil? (:ns sym)) ;; if ns-qualified can't be classname
                    (HostExpr'maybeSpecialTag sym)
                )
            )
            (HostExpr'maybeClass tag, true)
            (throw (IllegalArgumentException. (str "Unable to resolve classname: " tag)))
        )
    )
)

#_stateless
#_abstract
(class-ns FieldExpr (§ extends HostExpr)
    #_protected
    (defn #_"FieldExpr" FieldExpr'new []
        (HostExpr'new)
    )

)

(class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (Method/getMethod "Object invokeNoArgInstanceMember(Object, String, boolean)"))
    (def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (Method/getMethod "Object setInstanceField(Object, String, Object)"))

    (defn- #_"InstanceFieldExpr" InstanceFieldExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"Class" :targetClass nil
            #_"java.lang.reflect.Field" :field nil
            #_"String" :fieldName nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :requireField false

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceFieldExpr" InstanceFieldExpr'new [#_"int" line, #_"int" column, #_"Expr" target, #_"String" fieldName, #_"Symbol" tag, #_"boolean" requireField]
        (let [this (merge (FieldExpr'new) (InstanceFieldExpr'init))]
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :targetClass (when (.hasJavaClass target) (.getJavaClass target))))
            (§ ass this (assoc this :field (when (some? (:targetClass this)) (Reflector'getField (:targetClass this), fieldName, false))))
            (§ ass this (assoc this :fieldName fieldName))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :requireField requireField))

            (when (and (nil? (:field this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                (if (nil? (:targetClass this))
                    (do
                        (.format (RT'errPrintWriter), "Reflection warning, %d:%d - reference to field %s can't be resolved.\n", (object-array [ line, column, fieldName ]))
                    )
                    (do
                        (.format (RT'errPrintWriter), "Reflection warning, %d:%d - reference to field %s on %s can't be resolved.\n", (object-array [ line, column, fieldName, (.getName (:targetClass this)) ]))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceFieldExpr" this]
        (Reflector'invokeNoArgInstanceMember (.eval (:target this)), (:fieldName this), (:requireField this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceFieldExpr" this]
        (and (some? (:targetClass this)) (some? (:field this)) (Util'isPrimitive (.getType (:field this))))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (.getField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (.getField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
                (HostExpr'emitBoxReturn objx, gen, (.getType (:field this)))
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.push gen, (:fieldName this))
                (.push gen, (:requireField this))
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'invokeNoArgInstanceMember)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceFieldExpr" this]
        (or (some? (:field this)) (some? (:tag this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this)))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"InstanceFieldExpr" this, #_"Expr" val]
        (Reflector'setInstanceField (.eval (:target this)), (:fieldName this), (.eval val))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (.emit val, :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.dupX1 gen)
                (HostExpr'emitUnboxArg objx, gen, (.getType (:field this)))
                (.putField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
            )
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.push gen, (:fieldName this))
                (.emit val, :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

(class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (defn- #_"StaticFieldExpr" StaticFieldExpr'init []
        (hash-map
            #_"String" :fieldName nil
            #_"Class" :c nil
            #_"java.lang.reflect.Field" :field nil
            #_"Symbol" :tag nil

            #_"int" :line 0
            #_"int" :column 0

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticFieldExpr" StaticFieldExpr'new [#_"int" line, #_"int" column, #_"Class" c, #_"String" fieldName, #_"Symbol" tag]
        (let [this (merge (FieldExpr'new) (StaticFieldExpr'init))]
            (§ ass this (assoc this :fieldName fieldName))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :c c))
            (try
                (§ ass this (assoc this :field (.getField c, fieldName)))
                (catch NoSuchFieldException e
                    (throw (Util'sneakyThrow e))
                )
            )
            (§ ass this (assoc this :tag tag))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticFieldExpr" this]
        (Reflector'getStaticField-2c (:c this), (:fieldName this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticFieldExpr" this]
        (Util'isPrimitive (.getType (:field this)))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitLineNumber gen, (:line this), (.mark gen))
        (.getStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitLineNumber gen, (:line this), (.mark gen))

        (.getStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        (HostExpr'emitBoxReturn objx, gen, (.getType (:field this)))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticFieldExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this)))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"StaticFieldExpr" this, #_"Expr" val]
        (Reflector'setStaticField-3c (:c this), (:fieldName this), (.eval val))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (.emit val, :Context'EXPRESSION, objx, gen)
        (.visitLineNumber gen, (:line this), (.mark gen))
        (.dup gen)
        (HostExpr'emitUnboxArg objx, gen, (.getType (:field this)))
        (.putStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

#_stateless
#_abstract
(class-ns MethodExpr (§ extends HostExpr)
    #_protected
    (defn #_"MethodExpr" MethodExpr'new []
        (HostExpr'new)
    )

    (defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" args, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.push gen, (.count args))
        (.newArray gen, Compiler'OBJECT_TYPE)
        (loop-when-recur [#_"int" i 0] (< i (.count args)) [(inc i)]
            (.dup gen)
            (.push gen, i)
            (.emit (cast' Expr (.nth args, i)), :Context'EXPRESSION, objx, gen)
            (.arrayStore gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    (defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class[]" parameterTypes, #_"IPersistentVector" args]
        (loop-when-recur [#_"int" i 0] (< i (alength parameterTypes)) [(inc i)]
            (let [#_"Expr" e (cast' Expr (.nth args, i))]
                (try
                    (let [#_"Class" primc (Compiler'maybePrimitiveType e)]
                        (cond (= primc (aget parameterTypes i))
                            (do
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                )
                            )
                            (and (= primc Integer/TYPE) (= (aget parameterTypes i) Long/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/I2L)
                                )
                            )
                            (and (= primc Long/TYPE) (= (aget parameterTypes i) Integer/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                                )
                            )
                            (and (= primc Float/TYPE) (= (aget parameterTypes i) Double/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/F2D)
                                )
                            )
                            (and (= primc Double/TYPE) (= (aget parameterTypes i) Float/TYPE))
                            (do
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (.emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/D2F)
                                )
                            )
                            :else
                            (do
                                (.emit e, :Context'EXPRESSION, objx, gen)
                                (HostExpr'emitUnboxArg objx, gen, (aget parameterTypes i))
                            )
                        )
                    )
                    (catch Exception e1
                        (throw (Util'sneakyThrow e1))
                    )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr (§ extends MethodExpr)
    (def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (Method/getMethod "Object invokeInstanceMethod(Object, String, Object[])"))

    (defn- #_"InstanceMethodExpr" InstanceMethodExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
            #_"java.lang.reflect.Method" :method nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceMethodExpr" InstanceMethodExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" target, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (merge (MethodExpr'new) (InstanceMethodExpr'init))]
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :methodName methodName))
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :tailPosition tailPosition))
            (if (and (.hasJavaClass target) (some? (.getJavaClass target)))
                (do
                    (let [#_"List" methods (Reflector'getMethods (.getJavaClass target), (.count args), methodName, false)]
                        (if (.isEmpty methods)
                            (do
                                (§ ass this (assoc this :method nil))
                                (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s on %s can't be resolved (no such method).\n", (object-array [ line, column, methodName, (.getName (.getJavaClass target)) ]))
                                )
                            )
                            (do
                                (let [#_"int" methodidx 0]
                                    (when (< 1 (.size methods))
                                        (let [#_"ArrayList<Class[]>" params (ArrayList.)]
                                            (let [#_"ArrayList<Class>" rets (ArrayList.)]
                                                (loop-when-recur [#_"int" i 0] (< i (.size methods)) [(inc i)]
                                                    (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.get methods, i))]
                                                        (.add params, (.getParameterTypes m))
                                                        (.add rets, (.getReturnType m))
                                                    )
                                                )
                                                (§ ass methodidx (Compiler'getMatchingParams methodName, params, args, rets))
                                            )
                                        )
                                    )
                                    (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (when (<= 0 methodidx) (.get methods, methodidx)))]
                                        (when (and (some? m) (not (Modifier/isPublic (.getModifiers (.getDeclaringClass m)))))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (§ ass m (Reflector'getAsMethodOfPublicBase (.getDeclaringClass m), m))
                                        )
                                        (§ ass this (assoc this :method m))
                                        (when (and (nil? (:method this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                            (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", (object-array [ line, column, methodName, (.getName (.getJavaClass target)), (Compiler'getTypeStringForArgs args) ]))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (§ ass this (assoc this :method nil))
                    (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                        (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s can't be resolved (target class is unknown).\n", (object-array [ line, column, methodName ]))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" target (.eval (:target this)) #_"Object[]" args (make-array Object (.count (:args this)))]
                (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                    (aset args i (.eval (cast' Expr (.nth (:args this), i))))
                )
                (if (some? (:method this))
                    (let [#_"LinkedList" ms (LinkedList.)]
                        (.add ms, (:method this))
                        (Reflector'invokeMatchingMethod (:methodName this), ms, target, args)
                    )
                    (Reflector'invokeInstanceMethod target, (:methodName this), args)
                )
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (let [#_"Type" type (Type/getType (.getDeclaringClass (:method this)))]
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, type)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (and (:tailPosition this) (not (:canBeDirect objx)))
                    (.emitClearThis (cast' ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (if (.isInterface (.getDeclaringClass (:method this)))
                        (.invokeInterface gen, type, m)
                        (.invokeVirtual gen, type, m)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:method this))
            (let [#_"Type" type (Type/getType (.getDeclaringClass (:method this)))]
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, type)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (.emitClearLocals (cast' ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (if (.isInterface (.getDeclaringClass (:method this)))
                        (.invokeInterface gen, type, m)
                        (.invokeVirtual gen, type, m)
                    )
                    (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:method this)))
                )
            )
            (do
                (.emit (:target this), :Context'EXPRESSION, objx, gen)
                (.push gen, (:methodName this))
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (.emitClearLocals (cast' ObjMethod (.deref Compiler'METHOD)), gen)
                )
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this))))))
        )
        (:jc this)
    )
)

(class-ns StaticMethodExpr (§ extends MethodExpr)
    (def #_"Method" StaticMethodExpr'forNameMethod (Method/getMethod "Class classForName(String)"))
    (def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (Method/getMethod "Object invokeStaticMethod(Class, String, Object[])"))

    (defn- #_"StaticMethodExpr" StaticMethodExpr'init []
        (hash-map
            #_"Class" :c nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"java.lang.reflect.Method" :method nil
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticMethodExpr" StaticMethodExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Class" c, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (merge (MethodExpr'new) (StaticMethodExpr'init))]
            (§ ass this (assoc this :c c))
            (§ ass this (assoc this :methodName methodName))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :tailPosition tailPosition))

            (let [#_"List" methods (Reflector'getMethods c, (.count args), methodName, true)]
                (when (.isEmpty methods)
                    (throw (IllegalArgumentException. (str "No matching method: " methodName)))
                )

                (let [#_"int" methodidx 0]
                    (when (< 1 (.size methods))
                        (let [#_"ArrayList<Class[]>" params (ArrayList.)]
                            (let [#_"ArrayList<Class>" rets (ArrayList.)]
                                (loop-when-recur [#_"int" i 0] (< i (.size methods)) [(inc i)]
                                    (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.get methods, i))]
                                        (.add params, (.getParameterTypes m))
                                        (.add rets, (.getReturnType m))
                                    )
                                )
                                (§ ass methodidx (Compiler'getMatchingParams methodName, params, args, rets))
                            )
                        )
                    )
                    (§ ass this (assoc this :method (cast java.lang.reflect.Method (when (<= 0 methodidx) (.get methods, methodidx)))))
                    (when (and (nil? (:method this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                        (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", (object-array [ line, column, methodName, (.getName c), (Compiler'getTypeStringForArgs args) ]))
                    )
                    this
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" args (make-array Object (.count (:args this)))]
                (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                    (aset args i (.eval (cast' Expr (.nth (:args this), i))))
                )
                (if (some? (:method this))
                    (let [#_"LinkedList" ms (LinkedList.)]
                        (.add ms, (:method this))
                        (Reflector'invokeMatchingMethod (:methodName this), ms, nil, args)
                    )
                    (Reflector'invokeStaticMethod-3c (:c this), (:methodName this), args)
                )
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitIntrinsicPredicate) [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (some? (RT'get-2 Intrinsics'preds, (.toString (:method this)))))
    )

    #_method
    (§ defn #_"void" (§ method emitIntrinsicPredicate) [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Label" falseLabel]
        (.visitLineNumber gen, (:line this), (.mark gen))
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
            (when (= context :Context'RETURN)
                (.emitClearLocals (cast' ObjMethod (.deref Compiler'METHOD)), gen)
            )
            (let [#_"Object[]" predOps (§ cast Object[] (RT'get-2 Intrinsics'preds, (.toString (:method this))))]
                (loop-when-recur [#_"int" i 0] (< i (dec (alength predOps))) [(inc i)]
                    (.visitInsn gen, (cast Integer (aget predOps i)))
                )
                (.visitJumpInsn gen, (cast Integer (aget predOps (dec (alength predOps)))), falseLabel)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
            (.visitLineNumber gen, (:line this), (.mark gen))
            (when (= context :Context'RETURN)
                (.emitClearLocals (cast' ObjMethod (.deref Compiler'METHOD)), gen)
            )
            (let [#_"Object" ops (RT'get-2 Intrinsics'ops, (.toString (:method this)))]
                (if (some? ops)
                    (if (§ instance? Object[] ops)
                        (doseq [#_"Object" op (§ cast Object[] ops)]
                            (.visitInsn gen, (cast Integer op))
                        )
                        (.visitInsn gen, (cast Integer ops))
                    )
                    (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (.invokeStatic gen, (Type/getType (:c this)), m)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:method this))
            (do
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (and (:tailPosition this) (not (:canBeDirect objx)))
                    (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearThis method, gen)
                    )
                )
                (let [#_"Type" type (Type/getType (:c this))]
                    (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (.invokeStatic gen, type, m)
                        (let [#_"Class" retClass (.getReturnType (:method this))]
                            (if (= context :Context'STATEMENT)
                                (do
                                    (cond (or (= retClass Long/TYPE) (= retClass Double/TYPE))
                                        (do
                                            (.pop2 gen)
                                        )
                                        (not= retClass Void/TYPE)
                                        (do
                                            (.pop gen)
                                        )
                                    )
                                )
                                (do
                                    (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:method this)))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.push gen, (.getName (:c this)))
                (.invokeStatic gen, Compiler'RT_TYPE, StaticMethodExpr'forNameMethod)
                (.push gen, (:methodName this))
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (.emitClearLocals method, gen)
                    )
                )
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, StaticMethodExpr'invokeStaticMethodMethod)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this))))))
        )
        (:jc this)
    )
)

(class-ns UnresolvedVarExpr (§ implements Expr)
    (defn- #_"UnresolvedVarExpr" UnresolvedVarExpr'init []
        (hash-map
            #_"Symbol" :symbol nil
        )
    )

    (defn #_"UnresolvedVarExpr" UnresolvedVarExpr'new [#_"Symbol" symbol]
        (let [this (UnresolvedVarExpr'init)]
            (§ ass this (assoc this :symbol symbol))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"UnresolvedVarExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"UnresolvedVarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
    (defn- #_"NumberExpr" NumberExpr'init []
        (hash-map
            #_"Number" :n nil
            #_"int" :id 0
        )
    )

    (defn #_"NumberExpr" NumberExpr'new [#_"Number" n]
        (let [this (merge (LiteralExpr'new) (NumberExpr'init))]
            (§ ass this (assoc this :n n))
            (§ ass this (assoc this :id (Compiler'registerConstant n)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"NumberExpr" this]
        (:n this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NumberExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (.emitConstant objx, gen, (:id this))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NumberExpr" this]
        (cond
            (instance? Integer (:n this)) Long/TYPE
            (instance? Double (:n this))  Double/TYPE
            (instance? Long (:n this))    Long/TYPE
            :else                         (throw (IllegalStateException. (str "Unsupported Number type: " (.getName (.getClass (:n this))))))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"NumberExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (cond
            (instance? Integer (:n this)) (.push gen, (.longValue (:n this)))
            (instance? Double (:n this))  (.push gen, (.doubleValue (:n this)))
            (instance? Long (:n this))    (.push gen, (.longValue (:n this)))
        )
        nil
    )

    (defn #_"Expr" NumberExpr'parse [#_"Number" form]
        (if (or (instance? Integer form) (instance? Double form) (instance? Long form))
            (do
                (NumberExpr'new form)
            )
            (do
                (ConstantExpr'new form)
            )
        )
    )
)

#_closure
(class-ns ConstantParser (§ implements IParser)
    (§ def #_"Keyword" ConstantParser'formKey (Keyword'intern (Symbol'intern "form")))

    (defn #_"ConstantParser" ConstantParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ConstantParser" this, #_"Context" context, #_"Object" form]
        (let [#_"int" argCount (dec (RT'count form))]
            (if-not (= argCount 1)
                (let [#_"IPersistentMap" exData (PersistentArrayMap'new-1 (object-array [ ConstantParser'formKey, form ]))]
                    (throw (ExceptionInfo'new-2 (str "Wrong number of args (" argCount ") passed to quote"), exData))
                )
                (let [#_"Object" v (RT'second form)]
                    (cond
                        (nil? v)             Compiler'NIL_EXPR
                        (= v Boolean/TRUE)   Compiler'TRUE_EXPR
                        (= v Boolean/FALSE)  Compiler'FALSE_EXPR
                        (instance? Number v) (NumberExpr'parse (cast Number v))
                        (instance? String v) (StringExpr'new (cast String v))
                        (and (§ instance? IPersistentCollection v) (zero? (.count (cast' IPersistentCollection v)))) (EmptyExpr'new v)
                        :else                (ConstantExpr'new v)
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr (§ extends LiteralExpr)
    (defn- #_"ConstantExpr" ConstantExpr'init []
        (hash-map
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            #_"Object" :v nil
            #_"int" :id 0
        )
    )

    (defn #_"ConstantExpr" ConstantExpr'new [#_"Object" v]
        (let [this (merge (LiteralExpr'new) (ConstantExpr'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :id (Compiler'registerConstant v)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"ConstantExpr" this]
        (:v this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ConstantExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitConstant objx, gen, (:id this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ConstantExpr" this]
        (Modifier/isPublic (.getModifiers (.getClass (:v this))))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ConstantExpr" this]
        (cond (§ instance? APersistentMap (:v this))
            (do
                (§ class APersistentMap)
            )
            (§ instance? APersistentSet (:v this))
            (do
                (§ class APersistentSet)
            )
            (§ instance? APersistentVector (:v this))
            (do
                (§ class APersistentVector)
            )
            :else
            (do
                (.getClass (:v this))
            )
        )
    )
)

(class-ns NilExpr (§ extends LiteralExpr)
    (defn #_"NilExpr" NilExpr'new []
        (LiteralExpr'new)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"NilExpr" this]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NilExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitInsn gen, Opcodes/ACONST_NULL)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NilExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr (§ extends LiteralExpr)
    (defn- #_"BooleanExpr" BooleanExpr'init []
        (hash-map
            #_"boolean" :val false
        )
    )

    (defn #_"BooleanExpr" BooleanExpr'new [#_"boolean" val]
        (let [this (merge (LiteralExpr'new) (BooleanExpr'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BooleanExpr" this]
        (if (:val this) RT'T RT'F)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"BooleanExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, (if (:val this) "TRUE" "FALSE"), Compiler'BOOLEAN_OBJECT_TYPE)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"BooleanExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"BooleanExpr" this]
        Boolean
    )
)

(class-ns StringExpr (§ extends LiteralExpr)
    (defn- #_"StringExpr" StringExpr'init []
        (hash-map
            #_"String" :str nil
        )
    )

    (defn #_"StringExpr" StringExpr'new [#_"String" str]
        (let [this (merge (LiteralExpr'new) (StringExpr'init))]
            (§ ass this (assoc this :str str))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"StringExpr" this]
        (:str this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StringExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (.push gen, (:str this))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StringExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StringExpr" this]
        String
    )
)

#_closure
(class-ns MonitorEnterParser (§ implements IParser)
    (defn #_"MonitorEnterParser" MonitorEnterParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"MonitorEnterParser" this, #_"Context" context, #_"Object" form]
        (MonitorEnterExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
    )
)

(class-ns MonitorEnterExpr (§ extends UntypedExpr)
    (defn- #_"MonitorEnterExpr" MonitorEnterExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorEnterExpr" MonitorEnterExpr'new [#_"Expr" target]
        (let [this (merge (UntypedExpr'new) (MonitorEnterExpr'init))]
            (§ ass this (assoc this :target target))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MonitorEnterExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:target this), :Context'EXPRESSION, objx, gen)
        (.monitorEnter gen)
        (.emit Compiler'NIL_EXPR, context, objx, gen)
        nil
    )
)

#_closure
(class-ns MonitorExitParser (§ implements IParser)
    (defn #_"MonitorExitParser" MonitorExitParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"MonitorExitParser" this, #_"Context" context, #_"Object" form]
        (MonitorExitExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
    )
)

(class-ns MonitorExitExpr (§ extends UntypedExpr)
    (defn- #_"MonitorExitExpr" MonitorExitExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorExitExpr" MonitorExitExpr'new [#_"Expr" target]
        (let [this (merge (UntypedExpr'new) (MonitorExitExpr'init))]
            (§ ass this (assoc this :target target))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MonitorExitExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:target this), :Context'EXPRESSION, objx, gen)
        (.monitorExit gen)
        (.emit Compiler'NIL_EXPR, context, objx, gen)
        nil
    )
)

(class-ns CatchClause
    (defn- #_"CatchClause" CatchClause'init []
        (hash-map
            #_"Class" :c nil
            #_"LocalBinding" :lb nil
            #_"Expr" :handler nil
            #_"Label" :label nil
            #_"Label" :endLabel nil
        )
    )

    (defn #_"CatchClause" CatchClause'new [#_"Class" c, #_"LocalBinding" lb, #_"Expr" handler]
        (let [this (CatchClause'init)]
            (§ ass this (assoc this :c c))
            (§ ass this (assoc this :lb lb))
            (§ ass this (assoc this :handler handler))
            this
        )
    )
)

#_closure
(class-ns TryParser (§ implements IParser)
    (defn #_"TryParser" TryParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"TryParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            (when (= context :Context'RETURN) => (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                ;; (try try-expr* catch-expr* finally-expr?)
                ;; catch-expr: (catch class sym expr*)
                ;; finally-expr: (finally expr*)
                (let [#_"PersistentVector" body PersistentVector'EMPTY #_"PersistentVector" catches PersistentVector'EMPTY
                      #_"Expr" bodyExpr nil #_"Expr" finallyExpr nil #_"boolean" caught false
                      #_"int" retLocal (Compiler'getAndIncLocalNum) #_"int" finallyLocal (Compiler'getAndIncLocalNum)]

                    (loop-when-recur [#_"ISeq" fs (.next form)] (some? fs) [(.next fs)]
                        (let [#_"Object" f (.first fs) #_"Object" op (when (§ instance? ISeq f) (.first (cast' ISeq f)))]
                            (if (and (not (Util'equals op, Compiler'CATCH)) (not (Util'equals op, Compiler'FINALLY)))
                                (do
                                    (when-not caught => (throw (RuntimeException. "Only catch or finally clause can follow catch in try expression"))
                                        (§ ass body (.cons body, f))
                                    )
                                )
                                (do
                                    (when (nil? bodyExpr)
                                        (try
                                            (Var'pushThreadBindings (RT'map
                                                (object-array [
                                                    Compiler'NO_RECUR              true
                                                    Compiler'METHOD_RETURN_CONTEXT nil
                                                ])
                                            ))
                                            (§ ass bodyExpr (.parse (BodyParser'new), context, (RT'seq body)))
                                            (finally
                                                (Var'popThreadBindings)
                                            )
                                        )
                                    )

                                    (cond (Util'equals op, Compiler'CATCH)
                                        (let [#_"Class" c (HostExpr'maybeClass (RT'second f), false)]
                                            (when (nil? c)
                                                (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second f))))
                                            )
                                            (when (not (§ instance? Symbol (RT'third f)))
                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (RT'third f))))
                                            )
                                            (let [#_"Symbol" sym (cast' Symbol (RT'third f))]
                                                (when (some? (.getNamespace sym))
                                                    (throw (RuntimeException. (str "Can't bind qualified name:" sym)))
                                                )

                                                (let [#_"IPersistentMap" dynamicBindings
                                                        (RT'map
                                                            (object-array [
                                                                Compiler'LOCAL_ENV        (.deref Compiler'LOCAL_ENV)
                                                                Compiler'NEXT_LOCAL_NUM   (.deref Compiler'NEXT_LOCAL_NUM)
                                                                Compiler'IN_CATCH_FINALLY RT'T
                                                            ])
                                                        )]
                                                    (try
                                                        (Var'pushThreadBindings dynamicBindings)
                                                        (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (cast' Symbol (when (§ instance? Symbol (RT'second f)) (RT'second f))), nil, false)]
                                                            (let [#_"Expr" handler (.parse (BodyParser'new), :Context'EXPRESSION, (RT'next (RT'next (RT'next f))))]
                                                                (§ ass catches (.cons catches, (CatchClause'new c, lb, handler)))
                                                            )
                                                        )
                                                        (finally
                                                            (Var'popThreadBindings)
                                                        )
                                                    )
                                                    (§ ass caught true)
                                                )
                                            )
                                        )
                                        :else ;; finally
                                        (do
                                            (when (some? (.next fs))
                                                (throw (RuntimeException. "finally clause must be last in try expression"))
                                            )
                                            (try
                                                (Var'pushThreadBindings (RT'map
                                                    (object-array [
                                                        Compiler'IN_CATCH_FINALLY RT'T
                                                    ])
                                                ))
                                                (§ ass finallyExpr (.parse (BodyParser'new), :Context'STATEMENT, (RT'next f)))
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (nil? bodyExpr) => (TryExpr'new bodyExpr, catches, finallyExpr, retLocal, finallyLocal)
                        ;; when there is neither catch nor finally, e.g. (try (expr)) return a body expr directly
                        (try
                            (Var'pushThreadBindings (RT'map
                                (object-array [
                                    Compiler'NO_RECUR true
                                ])
                            ))
                            (.parse (BodyParser'new), context, (RT'seq body))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr (§ implements Expr)
    (defn- #_"TryExpr" TryExpr'init []
        (hash-map
            #_"Expr" :tryExpr nil
            #_"Expr" :finallyExpr nil
            #_"PersistentVector" :catchExprs nil
            #_"int" :retLocal 0
            #_"int" :finallyLocal 0
        )
    )

    (defn #_"TryExpr" TryExpr'new [#_"Expr" tryExpr, #_"PersistentVector" catchExprs, #_"Expr" finallyExpr, #_"int" retLocal, #_"int" finallyLocal]
        (let [this (TryExpr'init)]
            (§ ass this (assoc this :tryExpr tryExpr))
            (§ ass this (assoc this :catchExprs catchExprs))
            (§ ass this (assoc this :finallyExpr finallyExpr))
            (§ ass this (assoc this :retLocal retLocal))
            (§ ass this (assoc this :finallyLocal finallyLocal))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"TryExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" startTry (.newLabel gen) #_"Label" endTry (.newLabel gen) #_"Label" end (.newLabel gen) #_"Label" ret (.newLabel gen) #_"Label" finallyLabel (.newLabel gen)]
            (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                (let [#_"CatchClause" clause (cast' CatchClause (.nth (:catchExprs this), i))]
                    (§ ass (:label clause) (.newLabel gen))
                    (§ ass (:endLabel clause) (.newLabel gen))
                )
            )

            (.mark gen, startTry)
            (.emit (:tryExpr this), context, objx, gen)
            (when (not= context :Context'STATEMENT)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:retLocal this))
            )
            (.mark gen, endTry)
            (when (some? (:finallyExpr this))
                (.emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
            )
            (.goTo gen, ret)

            (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                (let [#_"CatchClause" clause (cast' CatchClause (.nth (:catchExprs this), i))]
                    (.mark gen, (:label clause))
                    ;; exception should be on stack
                    ;; put in clause local
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:lb clause)))
                    (.emit (:handler clause), context, objx, gen)
                    (when (not= context :Context'STATEMENT)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:retLocal this))
                    )
                    (.mark gen, (:endLabel clause))

                    (when (some? (:finallyExpr this))
                        (.emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
                    )
                    (.goTo gen, ret)
                )
            )
            (when (some? (:finallyExpr this))
                (.mark gen, finallyLabel)
                ;; exception should be on stack
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:finallyLocal this))
                (.emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:finallyLocal this))
                (.throwException gen)
            )
            (.mark gen, ret)
            (when (not= context :Context'STATEMENT)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:retLocal this))
            )
            (.mark gen, end)
            (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                (let [#_"CatchClause" clause (cast' CatchClause (.nth (:catchExprs this), i))]
                    (.visitTryCatchBlock gen, startTry, endTry, (:label clause), (.replace (.getName (:c clause)), \., \/))
                )
            )
            (when (some? (:finallyExpr this))
                (.visitTryCatchBlock gen, startTry, endTry, finallyLabel, nil)
                (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                    (let [#_"CatchClause" clause (cast' CatchClause (.nth (:catchExprs this), i))]
                        (.visitTryCatchBlock gen, (:label clause), (:endLabel clause), finallyLabel, nil)
                    )
                )
            )
            (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                (let [#_"CatchClause" clause (cast' CatchClause (.nth (:catchExprs this), i))]
                    (.visitLocalVariable gen, (:name (:lb clause)), "Ljava/lang/Object;", nil, (:label clause), (:endLabel clause), (:idx (:lb clause)))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"TryExpr" this]
        (.hasJavaClass (:tryExpr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"TryExpr" this]
        (.getJavaClass (:tryExpr this))
    )
)

#_closure
(class-ns ThrowParser (§ implements IParser)
    (defn #_"ThrowParser" ThrowParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ThrowParser" this, #_"Context" context, #_"Object" form]
        (cond
            (= context :Context'EVAL) (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
            (= (RT'count form) 1)     (throw (RuntimeException. "Too few arguments to throw, throw expects a single Throwable instance"))
            (< 2 (RT'count form))     (throw (RuntimeException. "Too many arguments to throw, throw expects a single Throwable instance"))
            :else                     (ThrowExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
        )
    )
)

(class-ns ThrowExpr (§ extends UntypedExpr)
    (defn- #_"ThrowExpr" ThrowExpr'init []
        (hash-map
            #_"Expr" :excExpr nil
        )
    )

    (defn #_"ThrowExpr" ThrowExpr'new [#_"Expr" excExpr]
        (let [this (merge (UntypedExpr'new) (ThrowExpr'init))]
            (§ ass this (assoc this :excExpr excExpr))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ThrowExpr" this]
        (throw (RuntimeException. "Can't eval throw"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ThrowExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:excExpr this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, Compiler'THROWABLE_TYPE)
        (.throwException gen)
        nil
    )
)

#_closure
(class-ns NewParser (§ implements IParser)
    (defn #_"NewParser" NewParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"NewParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"int" line (Compiler'lineDeref)]
            (let [#_"int" column (Compiler'columnDeref)]
                (let [#_"ISeq" form (cast' ISeq frm)]
                    ;; (new Classname args...)
                    (when (< (.count form) 2)
                        (throw (RuntimeException. "wrong number of arguments, expecting: (new Classname args...)"))
                    )
                    (let [#_"Class" c (HostExpr'maybeClass (RT'second form), false)]
                        (when (nil? c)
                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second form))))
                        )
                        (let [#_"PersistentVector" args PersistentVector'EMPTY]
                            (loop-when-recur [#_"ISeq" s (RT'next (RT'next form))] (some? s) [(.next s)]
                                (§ ass args (.cons args, (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))))
                            )
                            (NewExpr'new c, args, line, column)
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr (§ implements Expr)
    (def #_"Method" NewExpr'invokeConstructorMethod (Method/getMethod "Object invokeConstructor(Class, Object[])"))
    (def #_"Method" NewExpr'forNameMethod (Method/getMethod "Class classForName(String)"))

    (defn- #_"NewExpr" NewExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"Constructor" :ctor nil
            #_"Class" :c nil
        )
    )

    (defn #_"NewExpr" NewExpr'new [#_"Class" c, #_"IPersistentVector" args, #_"int" line, #_"int" column]
        (let [this (NewExpr'init)]
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :c c))
            (let [#_"Constructor[]" allctors (.getConstructors c)]
                (let [#_"ArrayList" ctors (ArrayList.)]
                    (let [#_"ArrayList<Class[]>" params (ArrayList.)]
                        (let [#_"ArrayList<Class>" rets (ArrayList.)]
                            (loop-when-recur [#_"int" i 0] (< i (alength allctors)) [(inc i)]
                                (let [#_"Constructor" ctor (aget allctors i)]
                                    (when (= (alength (.getParameterTypes ctor)) (.count args))
                                        (.add ctors, ctor)
                                        (.add params, (.getParameterTypes ctor))
                                        (.add rets, c)
                                    )
                                )
                            )
                            (when (.isEmpty ctors)
                                (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                            )

                            (let [#_"int" ctoridx 0]
                                (when (< 1 (.size ctors))
                                    (§ ass ctoridx (Compiler'getMatchingParams (.getName c), params, args, rets))
                                )

                                (§ ass this (assoc this :ctor (when (<= 0 ctoridx) (cast Constructor (.get ctors, ctoridx)))))
                                (when (and (nil? (:ctor this)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to %s ctor can't be resolved.\n", (object-array [ line, column, (.getName c) ]))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"NewExpr" this]
        (let [#_"Object[]" args (make-array Object (.count (:args this)))]
            (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                (aset args i (.eval (cast' Expr (.nth (:args this), i))))
            )
            (when (some? (:ctor this)) => (Reflector'invokeConstructor (:c this), args)
                (try
                    (.newInstance (:ctor this), (Reflector'boxArgs (.getParameterTypes (:ctor this)), args))
                    (catch Exception e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NewExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:ctor this))
            (let [#_"Type" type (Compiler'getType (:c this))]
                (.newInstance gen, type)
                (.dup gen)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:ctor this)), (:args this))
                (.invokeConstructor gen, type, (Method. "<init>", (Type/getConstructorDescriptor (:ctor this))))
            )
            (do
                (.push gen, (Compiler'destubClassName (.getName (:c this))))
                (.invokeStatic gen, Compiler'RT_TYPE, NewExpr'forNameMethod)
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, invokeConstructorMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NewExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NewExpr" this]
        (:c this)
    )
)

(class-ns MetaExpr (§ implements Expr)
    (def #_"Type" MetaExpr'IOBJ_TYPE (§ unsure Type/getType (§ class IObj)))
    (def #_"Method" MetaExpr'withMetaMethod (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

    (defn- #_"MetaExpr" MetaExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Expr" :meta nil
        )
    )

    (defn #_"MetaExpr" MetaExpr'new [#_"Expr" expr, #_"Expr" meta]
        (let [this (MetaExpr'init)]
            (§ ass this (assoc this :expr expr))
            (§ ass this (assoc this :meta meta))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MetaExpr" this]
        (.withMeta (cast' IObj (.eval (:expr this))), (cast' IPersistentMap (.eval (:meta this))))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MetaExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, MetaExpr'IOBJ_TYPE)
        (.emit (:meta this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
        (.invokeInterface gen, MetaExpr'IOBJ_TYPE, MetaExpr'withMetaMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MetaExpr" this]
        (.hasJavaClass (:expr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MetaExpr" this]
        (.getJavaClass (:expr this))
    )
)

#_closure
(class-ns IfParser (§ implements IParser)
    (defn #_"IfParser" IfParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"IfParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            ;; (if test then) or (if test then else)
            (cond (< 4 (.count form))
                (do
                    (throw (RuntimeException. "Too many arguments to if"))
                )
                (< (.count form) 3)
                (do
                    (throw (RuntimeException. "Too few arguments to if"))
                )
            )
            (let [#_"PathNode" branch (PathNode'new :PathType'BRANCH, (cast' PathNode (.get Compiler'CLEAR_PATH)))]
                (let [#_"Expr" testexpr (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'second form))]
                    (§ let [#_"Expr" thenexpr]
                        (§ let [#_"Expr" elseexpr]
                            (try
                                (Var'pushThreadBindings (RT'map
                                    (object-array [
                                        Compiler'CLEAR_PATH (PathNode'new :PathType'PATH, branch)
                                    ])
                                ))
                                (§ ass thenexpr (Compiler'analyze-2 context, (RT'third form)))
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                            (try
                                (Var'pushThreadBindings (RT'map
                                    (object-array [
                                        Compiler'CLEAR_PATH (PathNode'new :PathType'PATH, branch)
                                    ])
                                ))
                                (§ ass elseexpr (Compiler'analyze-2 context, (RT'fourth form)))
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                            (IfExpr'new (Compiler'lineDeref), (Compiler'columnDeref), testexpr, thenexpr, elseexpr)
                        )
                    )
                )
            )
        )
    )
)

(class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"IfExpr" IfExpr'init []
        (hash-map
            #_"Expr" :testExpr nil
            #_"Expr" :thenExpr nil
            #_"Expr" :elseExpr nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"IfExpr" IfExpr'new [#_"int" line, #_"int" column, #_"Expr" testExpr, #_"Expr" thenExpr, #_"Expr" elseExpr]
        (let [this (IfExpr'init)]
            (§ ass this (assoc this :testExpr testExpr))
            (§ ass this (assoc this :thenExpr thenExpr))
            (§ ass this (assoc this :elseExpr elseExpr))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"IfExpr" this]
        (let [#_"Object" t (.eval (:testExpr this))]
            (if (and (some? t) (not= t Boolean/FALSE))
                (.eval (:thenExpr this))
                (.eval (:elseExpr this))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.doEmit this, context, objx, gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"Label" nullLabel (.newLabel gen) #_"Label" falseLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
            (.visitLineNumber gen, (:line this), (.mark gen))

            (cond (and (§ instance? StaticMethodExpr (:testExpr this)) (.canEmitIntrinsicPredicate (cast' StaticMethodExpr (:testExpr this))))
                (do
                    (.emitIntrinsicPredicate (cast' StaticMethodExpr (:testExpr this)), :Context'EXPRESSION, objx, gen, falseLabel)
                )
                (= (Compiler'maybePrimitiveType (:testExpr this)) Boolean/TYPE)
                (do
                    (.emitUnboxed (cast' MaybePrimitiveExpr (:testExpr this)), :Context'EXPRESSION, objx, gen)
                    (.ifZCmp gen, GeneratorAdapter/EQ, falseLabel)
                )
                :else
                (do
                    (.emit (:testExpr this), :Context'EXPRESSION, objx, gen)
                    (.dup gen)
                    (.ifNull gen, nullLabel)
                    (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                    (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, falseLabel)
                )
            )
            (if emitUnboxed
                (do
                    (.emitUnboxed (cast' MaybePrimitiveExpr (:thenExpr this)), context, objx, gen)
                )
                (do
                    (.emit (:thenExpr this), context, objx, gen)
                )
            )
            (.goTo gen, endLabel)
            (.mark gen, nullLabel)
            (.pop gen)
            (.mark gen, falseLabel)
            (if emitUnboxed
                (do
                    (.emitUnboxed (cast' MaybePrimitiveExpr (:elseExpr this)), context, objx, gen)
                )
                (do
                    (.emit (:elseExpr this), context, objx, gen)
                )
            )
            (.mark gen, endLabel)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"IfExpr" this]
        (and (.hasJavaClass (:thenExpr this))
             (.hasJavaClass (:elseExpr this))
            (or (= (.getJavaClass (:thenExpr this)) (.getJavaClass (:elseExpr this)))
                (= (.getJavaClass (:thenExpr this)) Compiler'RECUR_CLASS)
                (= (.getJavaClass (:elseExpr this)) Compiler'RECUR_CLASS)
                (and (nil? (.getJavaClass (:thenExpr this))) (not (.isPrimitive (.getJavaClass (:elseExpr this)))))
                (and (nil? (.getJavaClass (:elseExpr this))) (not (.isPrimitive (.getJavaClass (:thenExpr this)))))))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"IfExpr" this]
        (try
            (and (§ instance? MaybePrimitiveExpr (:thenExpr this))
                 (§ instance? MaybePrimitiveExpr (:elseExpr this))
                (or (= (.getJavaClass (:thenExpr this)) (.getJavaClass (:elseExpr this)))
                    (= (.getJavaClass (:thenExpr this)) Compiler'RECUR_CLASS)
                    (= (.getJavaClass (:elseExpr this)) Compiler'RECUR_CLASS))
                 (.canEmitPrimitive (cast' MaybePrimitiveExpr (:thenExpr this)))
                 (.canEmitPrimitive (cast' MaybePrimitiveExpr (:elseExpr this))))
            (catch Exception e
                false
            )
        )
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"IfExpr" this]
        (let [#_"Class" thenClass (.getJavaClass (:thenExpr this))]
            (if (and (some? thenClass) (not= thenClass Compiler'RECUR_CLASS))
                thenClass
                (.getJavaClass (:elseExpr this))
            )
        )
    )
)

(class-ns EmptyExpr (§ implements Expr)
    (def #_"Type" EmptyExpr'HASHMAP_TYPE (§ unsure Type/getType (§ class PersistentArrayMap)))
    (def #_"Type" EmptyExpr'HASHSET_TYPE (§ unsure Type/getType (§ class PersistentHashSet)))
    (def #_"Type" EmptyExpr'VECTOR_TYPE (§ unsure Type/getType (§ class PersistentVector)))
    (def #_"Type" EmptyExpr'IVECTOR_TYPE (§ unsure Type/getType (§ class IPersistentVector)))
    (def #_"Type" EmptyExpr'TUPLE_TYPE (§ unsure Type/getType (§ class Tuple)))
    (def #_"Type" EmptyExpr'LIST_TYPE (§ unsure Type/getType (§ class PersistentList)))
    (def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (§ unsure Type/getType (§ class EmptyList)))

    (defn- #_"EmptyExpr" EmptyExpr'init []
        (hash-map
            #_"Object" :coll nil
        )
    )

    (defn #_"EmptyExpr" EmptyExpr'new [#_"Object" coll]
        (let [this (EmptyExpr'init)]
            (§ ass this (assoc this :coll coll))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"EmptyExpr" this]
        (:coll this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"EmptyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (cond
            (§ instance? IPersistentList (:coll this))   (.getStatic gen, EmptyExpr'LIST_TYPE,    "EMPTY", EmptyExpr'EMPTY_LIST_TYPE)
            (§ instance? IPersistentVector (:coll this)) (.getStatic gen, EmptyExpr'VECTOR_TYPE,  "EMPTY", EmptyExpr'VECTOR_TYPE)
            (§ instance? IPersistentMap (:coll this))    (.getStatic gen, EmptyExpr'HASHMAP_TYPE, "EMPTY", EmptyExpr'HASHMAP_TYPE)
            (§ instance? IPersistentSet (:coll this))    (.getStatic gen, EmptyExpr'HASHSET_TYPE, "EMPTY", EmptyExpr'HASHSET_TYPE)
            :else                                        (throw (UnsupportedOperationException. "Unknown Collection type"))
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"EmptyExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"EmptyExpr" this]
        (cond
            (§ instance? IPersistentList (:coll this))   (§ class IPersistentList)
            (§ instance? IPersistentVector (:coll this)) (§ class IPersistentVector)
            (§ instance? IPersistentMap (:coll this))    (§ class IPersistentMap)
            (§ instance? IPersistentSet (:coll this))    (§ class IPersistentSet)
            :else                                        (throw (UnsupportedOperationException. "Unknown Collection type"))
        )
    )
)

(class-ns ListExpr (§ implements Expr)
    (def #_"Method" ListExpr'arrayToListMethod (Method/getMethod "cloiure.lang.ISeq arrayToList(Object[])"))

    (defn- #_"ListExpr" ListExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"ListExpr" ListExpr'new [#_"IPersistentVector" args]
        (let [this (ListExpr'init)]
            (§ ass this (assoc this :args args))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ListExpr" this]
        (let [#_"IPersistentVector" ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                (§ ass ret (cast' IPersistentVector (.cons ret, (.eval (cast' Expr (.nth (:args this), i))))))
            )
            (.seq ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ListExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MethodExpr'emitArgsAsArray (:args this), objx, gen)
        (.invokeStatic gen, Compiler'RT_TYPE, ListExpr'arrayToListMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ListExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ListExpr" this]
        (§ class IPersistentList)
    )
)

(class-ns MapExpr (§ implements Expr)
    (def #_"Method" MapExpr'mapMethod (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
    (def #_"Method" MapExpr'mapUniqueKeysMethod (Method/getMethod "cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

    (defn- #_"MapExpr" MapExpr'init []
        (hash-map
            #_"IPersistentVector" :keyvals nil
        )
    )

    (defn #_"MapExpr" MapExpr'new [#_"IPersistentVector" keyvals]
        (let [this (MapExpr'init)]
            (§ ass this (assoc this :keyvals keyvals))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MapExpr" this]
        (let [#_"Object[]" ret (make-array Object (.count (:keyvals this)))]
            (loop-when-recur [#_"int" i 0] (< i (.count (:keyvals this))) [(inc i)]
                (aset ret i (.eval (cast' Expr (.nth (:keyvals this), i))))
            )
            (RT'map ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MapExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"boolean" allKeysConstant true #_"boolean" allConstantKeysUnique true]
            (let [#_"IPersistentSet" constantKeys PersistentHashSet'EMPTY]
                (loop-when-recur [#_"int" i 0] (< i (.count (:keyvals this))) [(+ i 2)]
                    (let [#_"Expr" k (cast' Expr (.nth (:keyvals this), i))]
                        (if (§ instance? LiteralExpr k)
                            (let [#_"Object" kval (.eval k)]
                                (if (.contains constantKeys, kval)
                                    (§ ass allConstantKeysUnique false)
                                    (§ ass constantKeys (cast' IPersistentSet (.cons constantKeys, kval)))
                                )
                            )
                            (§ ass allKeysConstant false)
                        )
                    )
                )
                (MethodExpr'emitArgsAsArray (:keyvals this), objx, gen)
                (if (or (and allKeysConstant allConstantKeysUnique) (<= (.count (:keyvals this)) 2))
                    (.invokeStatic gen, Compiler'RT_TYPE, mapUniqueKeysMethod)
                    (.invokeStatic gen, Compiler'RT_TYPE, mapMethod)
                )
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MapExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MapExpr" this]
        (§ class IPersistentMap)
    )

    (defn #_"Expr" MapExpr'parse [#_"Context" context, #_"IPersistentMap" form]
        (let [#_"IPersistentVector" keyvals PersistentVector'EMPTY]
            (let [#_"boolean" keysConstant true]
                (let [#_"boolean" valsConstant true]
                    (let [#_"boolean" allConstantKeysUnique true]
                        (let [#_"IPersistentSet" constantKeys PersistentHashSet'EMPTY]
                            (loop-when-recur [#_"ISeq" s (RT'seq form)] (some? s) [(.next s)]
                                (let [#_"IMapEntry" e (cast' IMapEntry (.first s))]
                                    (let [#_"Expr" k (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.key e))]
                                        (let [#_"Expr" v (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.val e))]
                                            (§ ass keyvals (cast' IPersistentVector (.cons keyvals, k)))
                                            (§ ass keyvals (cast' IPersistentVector (.cons keyvals, v)))
                                            (if (§ instance? LiteralExpr k)
                                                (do
                                                    (let [#_"Object" kval (.eval k)]
                                                        (if (.contains constantKeys, kval)
                                                            (do
                                                                (§ ass allConstantKeysUnique false)
                                                            )
                                                            (do
                                                                (§ ass constantKeys (cast' IPersistentSet (.cons constantKeys, kval)))
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (§ ass keysConstant false)
                                                )
                                            )
                                            (when (not (§ instance? LiteralExpr v))
                                                (§ ass valsConstant false)
                                            )
                                        )
                                    )
                                )
                            )

                            (let [#_"Expr" ret (MapExpr'new keyvals)]
                                (cond (and (§ instance? IObj form) (some? (.meta (cast' IObj form))))
                                    (do
                                        (MetaExpr'new ret, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast' IObj form))))
                                    )
                                    keysConstant
                                    (do
                                        ;; TBD: Add more detail to exception thrown below.
                                        (when (not allConstantKeysUnique)
                                            (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                                        )
                                        (if valsConstant
                                            (do
                                                (let [#_"IPersistentMap" m PersistentArrayMap'EMPTY]
                                                    (loop-when-recur [#_"int" i 0] (< i (.length keyvals)) [(+ i 2)]
                                                        (§ ass m (.assoc m, (.val (cast' LiteralExpr (.nth keyvals, i))), (.val (cast' LiteralExpr (.nth keyvals, (inc i))))))
                                                    )
                                                    (ConstantExpr'new m)
                                                )
                                            )
                                            (do
                                                ret
                                            )
                                        )
                                    )
                                    :else
                                    (do
                                        ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns SetExpr (§ implements Expr)
    (def #_"Method" SetExpr'setMethod (Method/getMethod "cloiure.lang.IPersistentSet set(Object[])"))

    (defn- #_"SetExpr" SetExpr'init []
        (hash-map
            #_"IPersistentVector" :keys nil
        )
    )

    (defn #_"SetExpr" SetExpr'new [#_"IPersistentVector" keys]
        (let [this (SetExpr'init)]
            (§ ass this (assoc this :keys keys))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"SetExpr" this]
        (let [#_"Object[]" ret (make-array Object (.count (:keys this)))]
            (loop-when-recur [#_"int" i 0] (< i (.count (:keys this))) [(inc i)]
                (aset ret i (.eval (cast' Expr (.nth (:keys this), i))))
            )
            (RT'set ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"SetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MethodExpr'emitArgsAsArray (:keys this), objx, gen)
        (.invokeStatic gen, Compiler'RT_TYPE, setMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"SetExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"SetExpr" this]
        (§ class IPersistentSet)
    )

    (defn #_"Expr" SetExpr'parse [#_"Context" context, #_"IPersistentSet" form]
        (let [#_"IPersistentVector" keys PersistentVector'EMPTY]
            (let [#_"boolean" constant true]
                (loop-when-recur [#_"ISeq" s (RT'seq form)] (some? s) [(.next s)]
                    (let [#_"Object" e (.first s)]
                        (let [#_"Expr" expr (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), e)]
                            (§ ass keys (cast' IPersistentVector (.cons keys, expr)))
                            (when (not (§ instance? LiteralExpr expr))
                                (§ ass constant false)
                            )
                        )
                    )
                )
                (let [#_"Expr" ret (SetExpr'new keys)]
                    (cond (and (§ instance? IObj form) (some? (.meta (cast' IObj form))))
                        (do
                            (MetaExpr'new ret, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast' IObj form))))
                        )
                        constant
                        (do
                            (let [#_"IPersistentSet" set PersistentHashSet'EMPTY]
                                (loop-when-recur [#_"int" i 0] (< i (.count keys)) [(inc i)]
                                    (let [#_"LiteralExpr" ve (cast' LiteralExpr (.nth keys, i))]
                                        (§ ass set (cast' IPersistentSet (.cons set, (.val ve))))
                                    )
                                )
                                (ConstantExpr'new set)
                            )
                        )
                        :else
                        (do
                            ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns VectorExpr (§ implements Expr)
    (def #_"Method" VectorExpr'vectorMethod (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))

    (defn- #_"VectorExpr" VectorExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"VectorExpr" VectorExpr'new [#_"IPersistentVector" args]
        (let [this (VectorExpr'init)]
            (§ ass this (assoc this :args args))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"VectorExpr" this]
        (let [#_"IPersistentVector" ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                (§ ass ret (cast' IPersistentVector (.cons ret, (.eval (cast' Expr (.nth (:args this), i))))))
            )
            ret
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"VectorExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (<= (.count (:args this)) Tuple'MAX_SIZE)
            (do
                (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                    (.emit (cast' Expr (.nth (:args this), i)), :Context'EXPRESSION, objx, gen)
                )
                (.invokeStatic gen, Compiler'TUPLE_TYPE, (aget Compiler'createTupleMethods (.count (:args this))))
            )
            (do
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.invokeStatic gen, Compiler'RT_TYPE, vectorMethod)
            )
        )

        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"VectorExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"VectorExpr" this]
        (§ class IPersistentVector)
    )

    (defn #_"Expr" VectorExpr'parse [#_"Context" context, #_"IPersistentVector" form]
        (let [#_"boolean" constant true]
            (let [#_"IPersistentVector" args PersistentVector'EMPTY]
                (loop-when-recur [#_"int" i 0] (< i (.count form)) [(inc i)]
                    (let [#_"Expr" v (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.nth form, i))]
                        (§ ass args (cast' IPersistentVector (.cons args, v)))
                        (when (not (§ instance? LiteralExpr v))
                            (§ ass constant false)
                        )
                    )
                )
                (let [#_"Expr" ret (VectorExpr'new args)]
                    (cond (and (§ instance? IObj form) (some? (.meta (cast' IObj form))))
                        (do
                            (MetaExpr'new ret, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast' IObj form))))
                        )
                        constant
                        (do
                            (let [#_"IPersistentVector" rv PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" i 0] (< i (.count args)) [(inc i)]
                                    (let [#_"LiteralExpr" ve (cast' LiteralExpr (.nth args, i))]
                                        (§ ass rv (.cons rv, (.val ve)))
                                    )
                                )
                                (ConstantExpr'new rv)
                            )
                        )
                        :else
                        (do
                            ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns KeywordInvokeExpr (§ implements Expr)
    (def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (§ unsure Type/getType (§ class ILookup)))

    (defn- #_"KeywordInvokeExpr" KeywordInvokeExpr'init []
        (hash-map
            #_"KeywordExpr" :kw nil
            #_"Object" :tag nil
            #_"Expr" :target nil
            #_"int" :line 0
            #_"int" :column 0
            #_"int" :siteIndex 0

            #_"Class" :jc nil
        )
    )

    (defn #_"KeywordInvokeExpr" KeywordInvokeExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"KeywordExpr" kw, #_"Expr" target]
        (let [this (KeywordInvokeExpr'init)]
            (§ ass this (assoc this :kw kw))
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :siteIndex (Compiler'registerKeywordCallsite (:k kw))))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"KeywordInvokeExpr" this]
        (try
            (.invoke (:k (:kw this)), (.eval (:target this)))
            (catch Throwable e
                (if (not (§ instance? CompilerException e))
                    (do
                        (throw (CompilerException'new (:line this), (:column this), e))
                    )
                    (do
                        (throw (cast' CompilerException e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"KeywordInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" endLabel (.newLabel gen) #_"Label" faultLabel (.newLabel gen)]
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.getStatic gen, (:objtype objx), (.thunkNameStatic objx, (:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE)
            (.dup gen) ;; thunk, thunk
            (.emit (:target this), :Context'EXPRESSION, objx, gen) ;; thunk, thunk, target
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.dupX2 gen) ;; target, thunk, thunk, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_THUNK_TYPE, (Method/getMethod "Object get(Object)")) ;; target, thunk, result
            (.dupX2 gen) ;; result, target, thunk, result
            (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, faultLabel) ;; result, target
            (.pop gen) ;; result
            (.goTo gen, endLabel)

            (.mark gen, faultLabel) ;; result, target
            (.swap gen) ;; target, result
            (.pop gen) ;; target
            (.dup gen) ;; target, target
            (.getStatic gen, (:objtype objx), (.siteNameStatic objx, (:siteIndex this)), ObjExpr'KEYWORD_LOOKUPSITE_TYPE) ;; target, target, site
            (.swap gen) ;; target, site, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_SITE_TYPE, (Method/getMethod "cloiure.lang.ILookupThunk fault(Object)")) ;; target, new-thunk
            (.dup gen) ;; target, new-thunk, new-thunk
            (.putStatic gen, (:objtype objx), (.thunkNameStatic objx, (:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE) ;; target, new-thunk
            (.swap gen) ;; new-thunk, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_THUNK_TYPE, (Method/getMethod "Object get(Object)")) ;; result

            (.mark gen, endLabel)
            (when (= context :Context'STATEMENT)
                (.pop gen)
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"KeywordInvokeExpr" this]
        (some? (:tag this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"KeywordInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
        )
        (:jc this)
    )
)

(class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"InstanceOfExpr" InstanceOfExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Class" :c nil
        )
    )

    (defn #_"InstanceOfExpr" InstanceOfExpr'new [#_"Class" c, #_"Expr" expr]
        (let [this (InstanceOfExpr'init)]
            (§ ass this (assoc this :expr expr))
            (§ ass this (assoc this :c c))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceOfExpr" this]
        (if (.isInstance (:c this), (.eval (:expr this))) RT'T RT'F)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceOfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.instanceOf gen, (Compiler'getType (:c this)))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceOfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitUnboxed this, context, objx, gen)
        (HostExpr'emitBoxReturn objx, gen, Boolean/TYPE)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceOfExpr" this]
        Boolean/TYPE
    )
)

(class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"StaticInvokeExpr" StaticInvokeExpr'init []
        (hash-map
            #_"Type" :target nil
            #_"Class" :retClass nil
            #_"Class[]" :paramclasses nil
            #_"Type[]" :paramtypes nil
            #_"IPersistentVector" :args nil
            #_"boolean" :variadic false
            #_"boolean" :tailPosition false
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticInvokeExpr" StaticInvokeExpr'new [#_"Type" target, #_"Class" retClass, #_"Class[]" paramclasses, #_"Type[]" paramtypes, #_"boolean" variadic, #_"IPersistentVector" args, #_"Object" tag, #_"boolean" tailPosition]
        (let [this (StaticInvokeExpr'init)]
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :retClass retClass))
            (§ ass this (assoc this :paramclasses paramclasses))
            (§ ass this (assoc this :paramtypes paramtypes))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :variadic variadic))
            (§ ass this (assoc this :tailPosition tailPosition))
            (§ ass this (assoc this :tag tag))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitUnboxed this, context, objx, gen)
        (when (not= context :Context'STATEMENT)
            (HostExpr'emitBoxReturn objx, gen, (:retClass this))
        )
        (when (= context :Context'STATEMENT)
            (if (or (= (:retClass this) Long/TYPE) (= (:retClass this) Double/TYPE))
                (.pop2 gen)
                (.pop gen)
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticInvokeExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (:retClass this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticInvokeExpr" this]
        (.isPrimitive (:retClass this))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Method" ms (Method. "invokeStatic", (.getReturnType this), (:paramtypes this))]
            (if (:variadic this)
                (do
                    (loop-when-recur [#_"int" i 0] (< i (dec (alength (:paramclasses this)))) [(inc i)]
                        (let [#_"Expr" e (cast' Expr (.nth (:args this), i))]
                            (if (= (Compiler'maybePrimitiveType e) (aget (:paramclasses this) i))
                                (do
                                    (.emitUnboxed (cast' MaybePrimitiveExpr e), :Context'EXPRESSION, objx, gen)
                                )
                                (do
                                    (.emit e, :Context'EXPRESSION, objx, gen)
                                    (HostExpr'emitUnboxArg objx, gen, (aget (:paramclasses this) i))
                                )
                            )
                        )
                    )
                    (let [#_"IPersistentVector" restArgs (RT'subvec (:args this), (dec (alength (:paramclasses this))), (.count (:args this)))]
                        (MethodExpr'emitArgsAsArray restArgs, objx, gen)
                        (.invokeStatic gen, (§ unsure Type/getType (§ class ArraySeq)), (Method/getMethod "cloiure.lang.ArraySeq create(Object[])"))
                    )
                )
                (do
                    (MethodExpr'emitTypedArgs objx, gen, (:paramclasses this), (:args this))
                )
            )

            (when (and (:tailPosition this) (not (:canBeDirect objx)))
                (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                    (.emitClearThis method, gen)
                )
            )

            (.invokeStatic gen, (:target this), ms)
        )
        nil
    )

    #_method
    (§ defn- #_"Type" (§ method getReturnType) [#_"StaticInvokeExpr" this]
        (Type/getType (:retClass this))
    )

    (defn #_"Expr" StaticInvokeExpr'parse [#_"Var" v, #_"ISeq" args, #_"Object" tag, #_"boolean" tailPosition]
        (when (and (.isBound v) (some? (.get v)))
            (let [#_"Class" c (.getClass (.get v)) #_"String" cname (.getName c) #_"int" argcount (RT'count args)
                  #_"java.lang.reflect.Method" method nil #_"boolean" variadic false
                  _ (doseq [#_"java.lang.reflect.Method" m (.getMethods c)]
                        (when (and (Modifier/isStatic (.getModifiers m)) (= (.getName m) "invokeStatic"))
                            (let [#_"Class[]" params (.getParameterTypes m)]
                                (cond (= argcount (alength params))
                                    (do
                                        (§ ass method m)
                                        (§ ass variadic (and (pos? argcount) (= (aget params (dec (alength params))) (§ class ISeq))))
                                        (§ break )
                                    )
                                    (and (< 0 (alength params) argcount) (= (aget params (dec (alength params))) (§ class ISeq)))
                                    (do
                                        (§ ass method m)
                                        (§ ass variadic true)
                                        (§ break )
                                    )
                                )
                            )
                        )
                    )]
                (when (some? method)
                    (let [#_"Class" retClass (.getReturnType method) #_"Class[]" paramClasses (.getParameterTypes method)
                          #_"Type[]" paramTypes (make-array Type (alength paramClasses))
                          _ (loop-when-recur [#_"int" i 0] (< i (alength paramClasses)) [(inc i)]
                                (aset paramTypes i (§ unsure Type/getType (aget paramClasses i)))
                            )
                          #_"Type" target (§ unsure Type/getType c)
                          #_"PersistentVector" argv PersistentVector'EMPTY
                          _ (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                                (§ ass argv (.cons argv, (Compiler'analyze-2 :Context'EXPRESSION, (.first s))))
                            )]
                        (StaticInvokeExpr'new target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition)
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr (§ implements Expr)
    (§ def #_"Keyword" InvokeExpr'onKey (Keyword'intern (Symbol'intern "on")))
    (§ def #_"Keyword" InvokeExpr'methodMapKey (Keyword'intern (Symbol'intern "method-map")))

    (defn- #_"InvokeExpr" InvokeExpr'init []
        (hash-map
            #_"Expr" :fexpr nil
            #_"Object" :tag nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :tailPosition false

            #_"boolean" :isProtocol false
            #_"boolean" :isDirect false
            #_"int" :siteIndex -1
            #_"Class" :protocolOn nil
            #_"java.lang.reflect.Method" :onMethod nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InvokeExpr" InvokeExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" fexpr, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (InvokeExpr'init)]
            (§ ass this (assoc this :fexpr fexpr))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tailPosition tailPosition))

            (when (§ instance? VarExpr fexpr)
                (let [#_"Var" fvar (:var (cast' VarExpr fexpr))]
                    (let [#_"Var" pvar (cast' Var (RT'get-2 (.meta fvar), Compiler'protocolKey))]
                        (when (and (some? pvar) (.isBound Compiler'PROTOCOL_CALLSITES))
                            (§ ass this (assoc this :isProtocol true))
                            (§ ass this (assoc this :siteIndex (Compiler'registerProtocolCallsite (:var (cast' VarExpr fexpr)))))
                            (let [#_"Object" pon (RT'get-2 (.get pvar), Compiler'onKey)]
                                (§ ass this (assoc this :protocolOn (HostExpr'maybeClass pon, false)))
                                (when (some? (:protocolOn this))
                                    (let [#_"IPersistentMap" mmap (cast' IPersistentMap (RT'get-2 (.get pvar), InvokeExpr'methodMapKey))]
                                        (let [#_"Keyword" mmapVal (cast' Keyword (.valAt mmap, (Keyword'intern (:sym fvar))))]
                                            (when (nil? mmapVal)
                                                (throw (IllegalArgumentException. (str "No method of interface: " (.getName (:protocolOn this)) " found for function: " (:sym fvar) " of protocol: " (:sym pvar) " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" mname (Compiler'munge (.toString (:sym mmapVal)))]
                                                (let [#_"List" methods (Reflector'getMethods (:protocolOn this), (dec (.count args)), mname, false)]
                                                    (when (not= (.size methods) 1)
                                                        (throw (IllegalArgumentException. (str "No single method: " mname " of interface: " (.getName (:protocolOn this)) " found for function: " (:sym fvar) " of protocol: " (:sym pvar))))
                                                    )
                                                    (§ ass this (assoc this :onMethod (cast java.lang.reflect.Method (.get methods, 0))))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (some? tag)
                (do
                    (§ ass this (assoc this :tag tag))
                )
                (§ instance? VarExpr fexpr)
                (do
                    (let [#_"Var" v (:var (cast' VarExpr fexpr))]
                        (§ ass this (assoc this :tag (:tag (cast' VarExpr fexpr))))
                    )
                )
                :else
                (do
                    (§ ass this (assoc this :tag nil))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" fn (cast' IFn (.eval (:fexpr this)))]
                (let [#_"PersistentVector" argvs PersistentVector'EMPTY]
                    (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                        (§ ass argvs (.cons argvs, (.eval (cast' Expr (.nth (:args this), i)))))
                    )
                    (.applyTo fn, (RT'seq (Util'ret1 argvs, (§ ass argvs nil))))
                )
            )
            (catch Throwable e
                (if (not (§ instance? CompilerException e))
                    (do
                        (throw (CompilerException'new (:line this), (:column this), e))
                    )
                    (do
                        (throw (cast' CompilerException e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (:isProtocol this)
            (do
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.emitProto this, context, objx, gen)
            )
            (do
                (.emit (:fexpr this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, Compiler'IFN_TYPE)
                (.emitArgsAndCall this, 0, context, objx, gen)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitProto) [#_"InvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" onLabel (.newLabel gen) #_"Label" callLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
            (let [#_"Var" v (:var (cast' VarExpr (:fexpr this)))]
                (let [#_"Expr" e (cast' Expr (.nth (:args this), 0))]
                    (.emit e, :Context'EXPRESSION, objx, gen)
                    (.dup gen) ;; target, target
                    (.invokeStatic gen, Compiler'UTIL_TYPE, (Method/getMethod "Class classOf(Object)")) ;; target, class
                    (.getStatic gen, (:objtype objx), (.cachedClassName objx, (:siteIndex this)), Compiler'CLASS_TYPE) ;; target, class, cached-class
                    (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, callLabel) ;; target
                    (when (some? (:protocolOn this))
                        (.dup gen) ;; target, target
                        (.instanceOf gen, (Type/getType (:protocolOn this)))
                        (.ifZCmp gen, GeneratorAdapter/NE, onLabel)
                    )

                    (.dup gen) ;; target, target
                    (.invokeStatic gen, Compiler'UTIL_TYPE, (Method/getMethod "Class classOf(Object)")) ;; target, class
                    (.putStatic gen, (:objtype objx), (.cachedClassName objx, (:siteIndex this)), Compiler'CLASS_TYPE) ;; target

                    (.mark gen, callLabel) ;; target
                    (.emitVar objx, gen, v)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, (Method/getMethod "Object getRawRoot()")) ;; target, proto-fn
                    (.swap gen)
                    (.emitArgsAndCall this, 1, context, objx, gen)
                    (.goTo gen, endLabel)

                    (.mark gen, onLabel) ;; target
                    (when (some? (:protocolOn this))
                        (.checkCast gen, (Type/getType (:protocolOn this)))
                        (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:onMethod this)), (RT'subvec (:args this), 1, (.count (:args this))))
                        (when (= context :Context'RETURN)
                            (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                                (.emitClearLocals method, gen)
                            )
                        )
                        (let [#_"Method" m (Method. (.getName (:onMethod this)), (Type/getReturnType (:onMethod this)), (Type/getArgumentTypes (:onMethod this)))]
                            (.invokeInterface gen, (Type/getType (:protocolOn this)), m)
                            (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:onMethod this)))
                        )
                    )
                    (.mark gen, endLabel)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitArgsAndCall) [#_"InvokeExpr" this, #_"int" firstArgToEmit, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i firstArgToEmit] (< i (Math/min Compiler'MAX_POSITIONAL_ARITY, (.count (:args this)))) [(inc i)]
            (let [#_"Expr" e (cast' Expr (.nth (:args this), i))]
                (.emit e, :Context'EXPRESSION, objx, gen)
            )
        )
        (when (< Compiler'MAX_POSITIONAL_ARITY (.count (:args this)))
            (let [#_"PersistentVector" restArgs PersistentVector'EMPTY]
                (loop-when-recur [#_"int" i Compiler'MAX_POSITIONAL_ARITY] (< i (.count (:args this))) [(inc i)]
                    (§ ass restArgs (.cons restArgs, (.nth (:args this), i)))
                )
                (MethodExpr'emitArgsAsArray restArgs, objx, gen)
            )
        )
        (.visitLineNumber gen, (:line this), (.mark gen))

        (when (and (:tailPosition this) (not (:canBeDirect objx)))
            (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                (.emitClearThis method, gen)
            )
        )

        (.invokeInterface gen, Compiler'IFN_TYPE, (Method. "invoke", Compiler'OBJECT_TYPE, (aget Compiler'ARG_TYPES (Math/min (inc Compiler'MAX_POSITIONAL_ARITY), (.count (:args this))))))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InvokeExpr" this]
        (some? (:tag this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
        )
        (:jc this)
    )

    (defn #_"Expr" InvokeExpr'parse [#_"Context" context, #_"ISeq" form]
        (let [#_"boolean" tailPosition (Compiler'inTailCall context) context (if (= context :Context'EVAL) context :Context'EXPRESSION)
              #_"Expr" fexpr (Compiler'analyze-2 context, (.first form))]
            (or
                (when (and (§ instance? VarExpr fexpr) (.equals (:var (cast' VarExpr fexpr)), Compiler'INSTANCE) (= (RT'count form) 3))
                    (let-when [#_"Expr" sexpr (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form))] (§ instance? ConstantExpr sexpr)
                        (let-when [#_"Object" val (.val (cast' ConstantExpr sexpr))] (instance? Class val)
                            (InstanceOfExpr'new (cast Class val), (Compiler'analyze-2 context, (RT'third form)))
                        )
                    )
                )

                (when (and #_"direct-linking" false (§ instance? VarExpr fexpr) (not= context :Context'EVAL))
                    (let [#_"Var" v (:var (cast' VarExpr fexpr))]
                        (when (and (not (.isDynamic v)) (not (RT'booleanCast-1o (RT'get-3 (.meta v), Compiler'redefKey, false))))
                            (let [#_"Symbol" formtag (Compiler'tagOf form) #_"Object" vtag (RT'get-2 (RT'meta v), RT'TAG_KEY)]
                                (StaticInvokeExpr'parse v, (RT'next form), (or formtag vtag), tailPosition)
                            )
                        )
                    )
                )

                (when (and (§ instance? KeywordExpr fexpr) (= (RT'count form) 2) (.isBound Compiler'KEYWORD_CALLSITES))
                    (let [#_"Expr" target (Compiler'analyze-2 context, (RT'second form))]
                        (KeywordInvokeExpr'new (Compiler'lineDeref), (Compiler'columnDeref), (Compiler'tagOf form), (cast' KeywordExpr fexpr), target)
                    )
                )

                (let [#_"PersistentVector" args PersistentVector'EMPTY
                      _ (loop-when-recur [#_"ISeq" s (RT'seq (.next form))] (some? s) [(.next s)]
                            (§ ass args (.cons args, (Compiler'analyze-2 context, (.first s))))
                        )]
                    (InvokeExpr'new (Compiler'lineDeref), (Compiler'columnDeref), (Compiler'tagOf form), fexpr, args, tailPosition)
                )
            )
        )
    )
)

#_stateless
(class-ns SourceDebugExtensionAttribute (§ extends Attribute)
    (defn #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute'new []
        (Attribute'new "SourceDebugExtension")
    )

    #_method
    (§ defn #_"void" (§ method writeSMAP) [#_"SourceDebugExtensionAttribute" this, #_"ClassWriter" cw, #_"String" smap]
        (let [#_"ByteVector" bv (.write this, cw, nil, -1, -1, -1)]
            (.putUTF8 bv, smap)
        )
        nil
    )
)

(class-ns FnExpr (§ extends ObjExpr)
    (def #_"Type" FnExpr'aFnType (§ unsure Type/getType (§ class AFunction)))
    (def #_"Type" FnExpr'restFnType (§ unsure Type/getType (§ class RestFn)))

    (defn- #_"FnExpr" FnExpr'init []
        (hash-map
            ;; if there is a variadic overload (there can only be one) it is stored here
            #_"FnMethod" :variadicMethod nil
            #_"IPersistentCollection" :methods nil
            #_"boolean" :hasPrimSigs false
            #_"boolean" :hasMeta false
            #_"boolean" :hasEnclosingMethod false

            #_"Class" :jc nil
        )
    )

    (defn #_"FnExpr" FnExpr'new [#_"Object" tag]
        (merge (ObjExpr'new tag) (FnExpr'init))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"FnExpr" this]
        true
    )

    #_method
    (§ defn #_"boolean" (§ method supportsMeta) [#_"FnExpr" this]
        (:hasMeta this)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"FnExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (§ class AFunction))))
        )
        (:jc this)
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"FnExpr" this, #_"ClassVisitor" cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [#_"ISeq" s (RT'seq (:methods this))] (some? s) [(.next s)]
            (let [#_"ObjMethod" method (cast' ObjMethod (.first s))]
                (.emit method, this, cv)
            )
        )

        (when (.isVariadic this)
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, (Method/getMethod "int getRequiredArity()"), nil, nil, cv)]
                (.visitCode gen)
                (.push gen, (.count (:reqParms (:variadicMethod this))))
                (.returnValue gen)
                (.endMethod gen)
            )
        )
        nil
    )

    (defn #_"Expr" FnExpr'parse [#_"Context" context, #_"ISeq" form, #_"String" name]
        (let [#_"ISeq" origForm form]
            (let [#_"FnExpr" fn (FnExpr'new (Compiler'tagOf form))]
                (let [#_"Keyword" retkey (Keyword'intern (Symbol'intern nil, "rettag"))]
                    (let [#_"Object" rettag (RT'get-2 (RT'meta form), retkey)]
                        (§ ass (:src fn) form)
                        (let [#_"ObjMethod" enclosingMethod (cast' ObjMethod (.deref Compiler'METHOD))]
                            (§ ass (:hasEnclosingMethod fn) (some? enclosingMethod))
                            (when (some? (.meta (cast' IMeta (.first form))))
                                (§ ass (:onceOnly fn) (RT'booleanCast-1o (RT'get-2 (RT'meta (.first form)), (Keyword'intern (Symbol'intern nil, "once")))))
                            )

                            (let [#_"String" basename (str (if (some? enclosingMethod) (:name (:objx enclosingMethod)) (Compiler'munge (:name (:name (Compiler'currentNS))))) "$")]
                                (let [#_"Symbol" nm nil]
                                    (if (§ instance? Symbol (RT'second form))
                                        (do
                                            (§ ass nm (cast' Symbol (RT'second form)))
                                            (§ ass name (str (:name nm) "__" (RT'nextID)))
                                        )
                                        (do
                                            (cond (nil? name)
                                                (do
                                                    (§ ass name (str "fn__" (RT'nextID)))
                                                )
                                                (some? enclosingMethod)
                                                (do
                                                    (§ ass name (str name "__"(RT'nextID)))
                                                )
                                            )
                                        )
                                    )

                                    (let [#_"String" simpleName (.replace (Compiler'munge name), ".", "_DOT_")]
                                        (§ ass (:name fn) (+ basename simpleName))
                                        (§ ass (:internalName fn) (.replace (:name fn), \., \/))
                                        (§ ass (:objtype fn) (Type/getObjectType (:internalName fn)))
                                        (let [#_"ArrayList<String>" prims (ArrayList.)]
                                            (try
                                                (Var'pushThreadBindings (RT'mapUniqueKeys
                                                    (object-array [
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                                                        Compiler'NO_RECUR           nil
                                                    ])
                                                ))

                                                ;; arglist might be preceded by symbol naming this fn
                                                (when (some? nm)
                                                    (§ ass (:thisName fn) (:name nm))
                                                    (§ ass form (RT'cons Compiler'FN, (RT'next (RT'next form))))
                                                )

                                                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                ;; turn former into latter
                                                (when (§ instance? IPersistentVector (RT'second form))
                                                    (§ ass form (RT'list-2 Compiler'FN, (RT'next form)))
                                                )
                                                (§ ass (:line fn) (Compiler'lineDeref))
                                                (§ ass (:column fn) (Compiler'columnDeref))
                                                (let [#_"FnMethod[]" methodArray (make-array #_"FnMethod" Object (inc Compiler'MAX_POSITIONAL_ARITY))]
                                                    (let [#_"FnMethod" variadicMethod nil]
                                                        (let [#_"boolean" usesThis false]
                                                            (loop-when-recur [#_"ISeq" s (RT'next form)] (some? s) [(RT'next s)]
                                                                (let [#_"FnMethod" f (FnMethod'parse fn, (cast' ISeq (RT'first s)), rettag)]
                                                                    (when (:usesThis f)
                                                                        (§ ass usesThis true)
                                                                    )
                                                                    (cond (.isVariadic f)
                                                                        (do
                                                                            (if (nil? variadicMethod)
                                                                                (do
                                                                                    (§ ass variadicMethod f)
                                                                                )
                                                                                (do
                                                                                    (throw (RuntimeException. "Can't have more than 1 variadic overload"))
                                                                                )
                                                                            )
                                                                        )
                                                                        (nil? (aget methodArray (.count (:reqParms f))))
                                                                        (do
                                                                            (aset methodArray (.count (:reqParms f)) f)
                                                                        )
                                                                        :else
                                                                        (do
                                                                            (throw (RuntimeException. "Can't have 2 overloads with same arity"))
                                                                        )
                                                                    )
                                                                    (when (some? (:prim f))
                                                                        (.add prims, (:prim f))
                                                                    )
                                                                )
                                                            )
                                                            (when (some? variadicMethod)
                                                                (loop-when-recur [#_"int" i (inc (.count (:reqParms variadicMethod)))] (<= i Compiler'MAX_POSITIONAL_ARITY) [(inc i)]
                                                                    (when (some? (aget methodArray i))
                                                                        (throw (RuntimeException. "Can't have fixed arity function with more params than variadic function"))
                                                                    )
                                                                )
                                                            )

                                                            (§ ass (:canBeDirect fn) (and (not (:hasEnclosingMethod fn)) (zero? (.count (:closes fn))) (not usesThis)))

                                                            (let [#_"IPersistentCollection" methods nil]
                                                                (loop-when-recur [#_"int" i 0] (< i (alength methodArray)) [(inc i)]
                                                                    (when (some? (aget methodArray i))
                                                                        (§ ass methods (RT'conj methods, (aget methodArray i)))
                                                                    )
                                                                )
                                                                (when (some? variadicMethod)
                                                                    (§ ass methods (RT'conj methods, variadicMethod))
                                                                )

                                                                (when (:canBeDirect fn)
                                                                    (doseq [#_"FnMethod" fm (cast Collection #_"<FnMethod>" methods)]
                                                                        (when (some? (:locals fm))
                                                                            (doseq [#_"LocalBinding" lb (cast Collection #_"<LocalBinding>" (RT'keys (:locals fm)))]
                                                                                (when (:isArg lb)
                                                                                    (§ ass (:idx lb) (dec (:idx lb)))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )

                                                                (§ ass (:methods fn) methods)
                                                                (§ ass (:variadicMethod fn) variadicMethod)
                                                                (§ ass (:keywords fn) (cast' IPersistentMap (.deref Compiler'KEYWORDS)))
                                                                (§ ass (:vars fn) (cast' IPersistentMap (.deref Compiler'VARS)))
                                                                (§ ass (:constants fn) (cast' PersistentVector (.deref Compiler'CONSTANTS)))
                                                                (§ ass (:keywordCallsites fn) (cast' IPersistentVector (.deref Compiler'KEYWORD_CALLSITES)))
                                                                (§ ass (:protocolCallsites fn) (cast' IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES)))
                                                                (§ ass (:varCallsites fn) (cast' IPersistentSet (.deref Compiler'VAR_CALLSITES)))

                                                                (§ ass (:constantsID fn) (RT'nextID))
                                                            )
                                                        )
                                                    )
                                                )
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                            (§ ass (:hasPrimSigs fn) (pos? (.size prims)))
                                            (let [#_"IPersistentMap" fmeta (RT'meta origForm)]
                                                (when (some? fmeta)
                                                    (§ ass fmeta (-> fmeta (.without RT'LINE_KEY) (.without RT'COLUMN_KEY) (.without retkey)))
                                                )

                                                (§ ass (:hasMeta fn) (pos? (RT'count fmeta)))

                                                (try
                                                    (.compile fn, (if (.isVariadic fn) "cloiure/lang/RestFn" "cloiure/lang/AFunction"), (if (zero? (.size prims)) nil (.toArray prims, (make-array String (.size prims)))), (:onceOnly fn))
                                                    (catch IOException e
                                                        (throw (Util'sneakyThrow e))
                                                    )
                                                )
                                                (.getCompiledClass fn)

                                                (if (.supportsMeta fn)
                                                    (do
                                                        (MetaExpr'new fn, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), fmeta))
                                                    )
                                                    (do
                                                        fn
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ObjMethod" (§ method variadicMethod) [#_"FnExpr" this]
        (:variadicMethod this)
    )

    #_method
    (§ defn #_"boolean" (§ method isVariadic) [#_"FnExpr" this]
        (some? (:variadicMethod this))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method methods) [#_"FnExpr" this]
        (:methods this)
    )

    #_method
    (§ defn #_"void" (§ method emitForDefn) [#_"FnExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit this, :Context'EXPRESSION, objx, gen)
        nil
    )
)

(class-ns ObjExpr (§ implements Expr)
    (def #_"String" ObjExpr'CONST_PREFIX "const__")

    (def #_"Method" ObjExpr'voidctor (Method/getMethod "void <init>()"))

    (def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (§ unsure Type/getType (§ class DynamicClassLoader)))
    (def #_"Method" ObjExpr'getClassMethod (Method/getMethod "Class getClass()"))
    (def #_"Method" ObjExpr'getClassLoaderMethod (Method/getMethod "ClassLoader getClassLoader()"))
    (def #_"Method" ObjExpr'getConstantsMethod (Method/getMethod "Object[] getConstants(int)"))
    (def #_"Method" ObjExpr'readStringMethod (Method/getMethod "Object readString(String)"))

    (def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (§ unsure Type/getType (§ class ILookupSite)))
    (def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (§ unsure Type/getType (§ class ILookupThunk)))
    (def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (§ unsure Type/getType (§ class KeywordLookupSite)))

    (defn- #_"ObjExpr" ObjExpr'init []
        (hash-map
            #_"String" :name nil
            #_"String" :internalName nil
            #_"String" :thisName nil
            #_"Type" :objtype nil
            #_"Object" :tag nil
            ;; localbinding->itself
            #_"IPersistentMap" :closes PersistentHashMap'EMPTY
            ;; localbndingexprs
            #_"IPersistentVector" :closesExprs PersistentVector'EMPTY
            ;; symbols
            #_"IPersistentSet" :volatiles PersistentHashSet'EMPTY

            ;; symbol->lb
            #_"IPersistentMap" :fields nil

            ;; hinted fields
            #_"IPersistentVector" :hintedFields PersistentVector'EMPTY

            ;; Keyword->KeywordExpr
            #_"IPersistentMap" :keywords PersistentHashMap'EMPTY
            #_"IPersistentMap" :vars PersistentHashMap'EMPTY
            #_"Class" :compiledClass nil
            #_"int" :line 0
            #_"int" :column 0
            #_"PersistentVector" :constants nil
            #_"IPersistentSet" :usedConstants PersistentHashSet'EMPTY

            #_"int" :constantsID 0
            #_"int" :altCtorDrops 0

            #_"IPersistentVector" :keywordCallsites nil
            #_"IPersistentVector" :protocolCallsites nil
            #_"IPersistentSet" :varCallsites nil
            #_"boolean" :onceOnly false

            #_"Object" :src nil

            #_"IPersistentMap" :opts PersistentHashMap'EMPTY

            #_protected
            #_"IPersistentMap" :classMeta nil
            #_protected
            #_"boolean" :canBeDirect false

            #_"DynamicClassLoader" :loader nil
            #_"byte[]" :bytecode nil

            #_"Class" :jc nil
        )
    )

    (defn #_"ObjExpr" ObjExpr'new [#_"Object" tag]
        (let [this (ObjExpr'init)]
            (§ ass this (assoc this :tag tag))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method name) [#_"ObjExpr" this]
        (:name this)
    )

    #_method
    (§ defn #_"String" (§ method internalName) [#_"ObjExpr" this]
        (:internalName this)
    )

    #_method
    (§ defn #_"String" (§ method thisName) [#_"ObjExpr" this]
        (:thisName this)
    )

    #_method
    (§ defn #_"Type" (§ method objtype) [#_"ObjExpr" this]
        (:objtype this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method closes) [#_"ObjExpr" this]
        (:closes this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method keywords) [#_"ObjExpr" this]
        (:keywords this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method vars) [#_"ObjExpr" this]
        (:vars this)
    )

    #_method
    (§ defn #_"Class" (§ method compiledClass) [#_"ObjExpr" this]
        (:compiledClass this)
    )

    #_method
    (§ defn #_"int" (§ method line) [#_"ObjExpr" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" (§ method column) [#_"ObjExpr" this]
        (:column this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method constants) [#_"ObjExpr" this]
        (:constants this)
    )

    #_method
    (§ defn #_"int" (§ method constantsID) [#_"ObjExpr" this]
        (:constantsID this)
    )

    (defn #_"String" ObjExpr'trimGenID [#_"String" name]
        (let [#_"int" i (.lastIndexOf name, "__")]
            (if (= i -1) name (.substring name, 0, i))
        )
    )

    #_method
    (§ defn #_"Type[]" (§ method ctorTypes) [#_"ObjExpr" this]
        (let [#_"IPersistentVector" tv (if (not (.supportsMeta this)) PersistentVector'EMPTY (RT'vector Compiler'IPERSISTENTMAP_TYPE))]
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                    (if (some? (.getPrimitiveType lb))
                        (do
                            (§ ass tv (.cons tv, (Type/getType (.getPrimitiveType lb))))
                        )
                        (do
                            (§ ass tv (.cons tv, Compiler'OBJECT_TYPE))
                        )
                    )
                )
            )
            (let [#_"Type[]" ret (make-array Type (.count tv))]
                (loop-when-recur [#_"int" i 0] (< i (.count tv)) [(inc i)]
                    (aset ret i (cast Type (.nth tv, i)))
                )
                ret
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method compile) [#_"ObjExpr" this, #_"String" superName, #_"String[]" interfaceNames, #_"boolean" oneTimeUse] #_(§ throws IOException)
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" cw (ClassWriter. ClassWriter/COMPUTE_MAXS) #_"ClassVisitor" cv cw]
            (.visit cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER Opcodes/ACC_FINAL), (:internalName this), nil, superName, interfaceNames)
            (when (.supportsMeta this)
                (.visitField cv, Opcodes/ACC_FINAL, "__meta", (.getDescriptor Compiler'IPERSISTENTMAP_TYPE), nil, nil)
            )
            ;; instance fields for closed-overs
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))
                      #_"String" fd
                        (if (some? (.getPrimitiveType lb))
                            (.getDescriptor (Type/getType (.getPrimitiveType lb)))
                            ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                            (.getDescriptor Compiler'OBJECT_TYPE)
                        )]
                    (if (.isDeftype this)
                        (let [#_"int" access
                                (cond
                                    (.isVolatile this, lb) Opcodes/ACC_VOLATILE
                                    (.isMutable this, lb) 0
                                    :else (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL)
                                )]
                            (.visitField cv, access, (:name lb), fd, nil, nil)
                        )
                        ;; todo - only enable this non-private+writability for letfns where we need it
                        (let [#_"int" access
                                (if (some? (.getPrimitiveType lb))
                                    (if (.isVolatile this, lb) Opcodes/ACC_VOLATILE 0)
                                    0
                                )]
                            (.visitField cv, access, (:name lb), fd, nil, nil)
                        )
                    )
                )
            )

            ;; static fields for callsites and thunks
            (loop-when-recur [#_"int" i 0] (< i (.count (:protocolCallsites this))) [(inc i)]
                (.visitField cv, (+ Opcodes/ACC_PRIVATE Opcodes/ACC_STATIC), (.cachedClassName this, i), (.getDescriptor Compiler'CLASS_TYPE), nil, nil)
            )

            ;; ctor that takes closed-overs and inits base + fields
            (let [#_"Method" m (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))]
                (let [#_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, nil, cv)]
                    (let [#_"Label" start (.newLabel ctorgen)]
                        (let [#_"Label" end (.newLabel ctorgen)]
                            (.visitCode ctorgen)
                            (.visitLineNumber ctorgen, (:line this), (.mark ctorgen))
                            (.visitLabel ctorgen, start)
                            (.loadThis ctorgen)
                            (.invokeConstructor ctorgen, (Type/getObjectType superName), ObjExpr'voidctor)

                            (when (.supportsMeta this)
                                (.loadThis ctorgen)
                                (.visitVarInsn ctorgen, (.getOpcode Compiler'IPERSISTENTMAP_TYPE, Opcodes/ILOAD), 1)
                                (.putField ctorgen, (:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE)
                            )

                            (let [#_"int" a (if (.supportsMeta this) 2 1)]
                                (loop-when-recur [#_"ISeq" s (RT'keys (:closes this)) a a] (some? s) [(.next s) (inc a)]
                                    (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                                        (.loadThis ctorgen)
                                        (let [#_"Class" primc (.getPrimitiveType lb)]
                                            (if (some? primc)
                                                (do
                                                    (.visitVarInsn ctorgen, (.getOpcode (Type/getType primc), Opcodes/ILOAD), a)
                                                    (.putField ctorgen, (:objtype this), (:name lb), (Type/getType primc))
                                                    (when (or (= primc Long/TYPE) (= primc Double/TYPE))
                                                        (§ ass a (inc a))
                                                    )
                                                )
                                                (do
                                                    (.visitVarInsn ctorgen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), a)
                                                    (.putField ctorgen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                                                )
                                            )
                                            (§ ass this (assoc this :closesExprs (.cons (:closesExprs this), (LocalBindingExpr'new lb, nil))))
                                        )
                                    )
                                )

                                (.visitLabel ctorgen, end)

                                (.returnValue ctorgen)

                                (.endMethod ctorgen)

                                (when (pos? (:altCtorDrops this))
                                    ;; ctor that takes closed-overs and inits base + fields
                                    (let [#_"Type[]" ctorTypes (.ctorTypes this)]
                                        (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) (:altCtorDrops this)))]
                                            (loop-when-recur [#_"int" i 0] (< i (alength altCtorTypes)) [(inc i)]
                                                (aset altCtorTypes i (aget ctorTypes i))
                                            )
                                            (let [#_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)]
                                                (§ ass ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv))
                                                (.visitCode ctorgen)
                                                (.loadThis ctorgen)
                                                (.loadArgs ctorgen)

                                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __meta
                                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                                (.returnValue ctorgen)
                                                (.endMethod ctorgen)

                                                ;; alt ctor no __hash, __hasheq
                                                (§ ass altCtorTypes (make-array Type (- (alength ctorTypes) 2)))
                                                (loop-when-recur [#_"int" i 0] (< i (alength altCtorTypes)) [(inc i)]
                                                    (aset altCtorTypes i (aget ctorTypes i))
                                                )

                                                (§ ass alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes))
                                                (§ ass ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv))
                                                (.visitCode ctorgen)
                                                (.loadThis ctorgen)
                                                (.loadArgs ctorgen)

                                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                                (.returnValue ctorgen)
                                                (.endMethod ctorgen)
                                            )
                                        )
                                    )
                                )

                                (when (.supportsMeta this)
                                    ;; ctor that takes closed-overs but not meta
                                    (let [#_"Type[]" ctorTypes (.ctorTypes this)]
                                        (let [#_"Type[]" noMetaCtorTypes (make-array Type (dec (alength ctorTypes)))]
                                            (loop-when-recur [#_"int" i 1] (< i (alength ctorTypes)) [(inc i)]
                                                (aset noMetaCtorTypes (dec i) (aget ctorTypes i))
                                            )
                                            (let [#_"Method" alt (Method. "<init>", Type/VOID_TYPE, noMetaCtorTypes)]
                                                (§ ass ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv))
                                                (.visitCode ctorgen)
                                                (.loadThis ctorgen)
                                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; nil meta
                                                (.loadArgs ctorgen)
                                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                                (.returnValue ctorgen)
                                                (.endMethod ctorgen)

                                                ;; meta()
                                                (let [#_"Method" meth (Method/getMethod "cloiure.lang.IPersistentMap meta()")]
                                                    (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, meth, nil, nil, cv)]
                                                        (.visitCode gen)
                                                        (.loadThis gen)
                                                        (.getField gen, (:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE)

                                                        (.returnValue gen)
                                                        (.endMethod gen)

                                                        ;; withMeta()
                                                        (§ ass meth (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                                                        (§ ass gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, meth, nil, nil, cv))
                                                        (.visitCode gen)
                                                        (.newInstance gen, (:objtype this))
                                                        (.dup gen)
                                                        (.loadArg gen, 0)

                                                        (loop-when-recur [#_"ISeq" s (RT'keys (:closes this)) a a] (some? s) [(.next s) (inc a)]
                                                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                                                                (.loadThis gen)
                                                                (let [#_"Class" primc (.getPrimitiveType lb)]
                                                                    (if (some? primc)
                                                                        (do
                                                                            (.getField gen, (:objtype this), (:name lb), (Type/getType primc))
                                                                        )
                                                                        (do
                                                                            (.getField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (.invokeConstructor gen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))
                                                        (.returnValue gen)
                                                        (.endMethod gen)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )

                                (.emitStatics this, cv)
                                (.emitMethods this, cv)

                                ;; static fields for constants
                                (loop-when-recur [#_"int" i 0] (< i (.count (:constants this))) [(inc i)]
                                    (when (.contains (:usedConstants this), i)
                                        (.visitField cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL Opcodes/ACC_STATIC), (.constantName this, i), (.getDescriptor (.constantType this, i)), nil, nil)
                                    )
                                )

                                ;; static fields for lookup sites
                                (loop-when-recur [#_"int" i 0] (< i (.count (:keywordCallsites this))) [(inc i)]
                                    (.visitField cv, (+ Opcodes/ACC_FINAL Opcodes/ACC_STATIC), (.siteNameStatic this, i), (.getDescriptor ObjExpr'KEYWORD_LOOKUPSITE_TYPE), nil, nil)
                                    (.visitField cv, Opcodes/ACC_STATIC, (.thunkNameStatic this, i), (.getDescriptor ObjExpr'ILOOKUP_THUNK_TYPE), nil, nil)
                                )

                                ;; static init for constants, keywords and vars
                                (let [#_"GeneratorAdapter" clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, cv)]
                                    (.visitCode clinitgen)
                                    (.visitLineNumber clinitgen, (:line this), (.mark clinitgen))

                                    (when (pos? (.count (:constants this)))
                                        (.emitConstants this, clinitgen)
                                    )

                                    (when (pos? (.count (:keywordCallsites this)))
                                        (.emitKeywordCallsites this, clinitgen)
                                    )

                                    (when (and (.isDeftype this) (RT'booleanCast-1o (RT'get-2 (:opts this), Compiler'loadNs)))
                                        (let [#_"String" nsname (.getNamespace (cast' Symbol (RT'second (:src this))))]
                                            (when (not (= nsname "cloiure.core"))
                                                (.push clinitgen, "cloiure.core")
                                                (.push clinitgen, "require")
                                                (.invokeStatic clinitgen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Var var(String, String)"))
                                                (.invokeVirtual clinitgen, Compiler'VAR_TYPE, (Method/getMethod "Object getRawRoot()"))
                                                (.checkCast clinitgen, Compiler'IFN_TYPE)
                                                (.push clinitgen, nsname)
                                                (.invokeStatic clinitgen, Compiler'SYMBOL_TYPE, (Method/getMethod "cloiure.lang.Symbol create(String)"))
                                                (.invokeInterface clinitgen, Compiler'IFN_TYPE, (Method/getMethod "Object invoke(Object)"))
                                                (.pop clinitgen)
                                            )
                                        )
                                    )

                                    (.returnValue clinitgen)

                                    (.endMethod clinitgen)

                                    ;; end of class
                                    (.visitEnd cv)

                                    (§ ass this (assoc this :bytecode (.toByteArray cw)))
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitKeywordCallsites) [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
        (loop-when-recur [#_"int" i 0] (< i (.count (:keywordCallsites this))) [(inc i)]
            (let [#_"Keyword" k (cast' Keyword (.nth (:keywordCallsites this), i))]
                (.newInstance clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.dup clinitgen)
                (.emitValue this, k, clinitgen)
                (.invokeConstructor clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE, (Method/getMethod "void <init>(cloiure.lang.Keyword)"))
                (.dup clinitgen)
                (.putStatic clinitgen, (:objtype this), (.siteNameStatic this, i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.putStatic clinitgen, (:objtype this), (.thunkNameStatic this, i), ObjExpr'ILOOKUP_THUNK_TYPE)
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitStatics) [#_"ObjExpr" this, #_"ClassVisitor" gen]
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"ObjExpr" this, #_"ClassVisitor" gen]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitListAsObjectArray) [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
        (.push gen, (.size (cast List value)))
        (.newArray gen, Compiler'OBJECT_TYPE)
        (loop-when-recur [#_"Iterator" it (.iterator (cast List value)) #_"int" i 0] (.hasNext it) [it (inc i)]
            (.dup gen)
            (.push gen, i)
            (.emitValue this, (.next it), gen)
            (.arrayStore gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitValue) [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
        (let [#_"boolean" partial true]
            (cond (nil? value)
                (do
                    (.visitInsn gen, Opcodes/ACONST_NULL)
                )
                (instance? String value)
                (do
                    (.push gen, (cast String value))
                )
                (instance? Boolean value)
                (do
                    (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, (if (.booleanValue (cast Boolean value)) "TRUE" "FALSE"), Compiler'BOOLEAN_OBJECT_TYPE)
                )
                (instance? Integer value)
                (do
                    (.push gen, (.intValue (cast Integer value)))
                    (.invokeStatic gen, (Type/getType Integer), (Method/getMethod "Integer valueOf(int)"))
                )
                (instance? Long value)
                (do
                    (.push gen, (.longValue (cast Long value)))
                    (.invokeStatic gen, (Type/getType Long), (Method/getMethod "Long valueOf(long)"))
                )
                (instance? Double value)
                (do
                    (.push gen, (.doubleValue (cast Double value)))
                    (.invokeStatic gen, (Type/getType Double), (Method/getMethod "Double valueOf(double)"))
                )
                (instance? Character value)
                (do
                    (.push gen, (.charValue (cast Character value)))
                    (.invokeStatic gen, (Type/getType Character), (Method/getMethod "Character valueOf(char)"))
                )
                (instance? Class value)
                (do
                    (let [#_"Class" cc (cast Class value)]
                        (if (.isPrimitive cc)
                            (do
                                (let [#_"Type" bt
                                        (condp = cc
                                            Boolean/TYPE   (Type/getType Boolean)
                                            Byte/TYPE      (Type/getType Byte)
                                            Character/TYPE (Type/getType Character)
                                            Double/TYPE    (Type/getType Double)
                                            Float/TYPE     (Type/getType Float)
                                            Integer/TYPE   (Type/getType Integer)
                                            Long/TYPE      (Type/getType Long)
                                            Short/TYPE     (Type/getType Short)
                                            (throw (RuntimeException. (str "Can't embed unknown primitive in code: " value)))
                                        )]
                                    (.getStatic gen, bt, "TYPE", (Type/getType Class))
                                )
                            )
                            (do
                                (.push gen, (Compiler'destubClassName (.getName cc)))
                                (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "Class classForName(String)"))
                            )
                        )
                    )
                )
                (§ instance? Symbol value)
                (do
                    (.push gen, (:ns (cast' Symbol value)))
                    (.push gen, (:name (cast' Symbol value)))
                    (.invokeStatic gen, (§ unsure Type/getType (§ class Symbol)), (Method/getMethod "cloiure.lang.Symbol intern(String, String)"))
                )
                (§ instance? Keyword value)
                (do
                    (.push gen, (:ns (:sym (cast' Keyword value))))
                    (.push gen, (:name (:sym (cast' Keyword value))))
                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Keyword keyword(String, String)"))
                )
                (§ instance? Var value)
                (do
                    (let [#_"Var" var (cast' Var value)]
                        (.push gen, (.toString (:name (:ns var))))
                        (.push gen, (.toString (:sym var)))
                        (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Var var(String, String)"))
                    )
                )
                (§ instance? IType value)
                (do
                    (let [#_"Method" ctor (Method. "<init>", (Type/getConstructorDescriptor (aget (.getConstructors (.getClass value)) 0)))]
                        (.newInstance gen, (Type/getType (.getClass value)))
                        (.dup gen)
                        (let [#_"IPersistentVector" fields (cast' IPersistentVector (Reflector'invokeStaticMethod-3c (.getClass value), "getBasis", (object-array 0)))]
                            (loop-when-recur [#_"ISeq" s (RT'seq fields)] (some? s) [(.next s)]
                                (let [#_"Symbol" field (cast' Symbol (.first s))]
                                    (let [#_"Class" k (Compiler'tagClass (Compiler'tagOf field))]
                                        (let [#_"Object" val (Reflector'getInstanceField value, (Compiler'munge (:name field)))]
                                            (.emitValue this, val, gen)

                                            (when (.isPrimitive k)
                                                (let [#_"Type" b (Type/getType (Compiler'boxClass k))]
                                                    (let [#_"String" p (.getDescriptor (Type/getType k))]
                                                        (let [#_"String" n (.getName k)]
                                                            (.invokeVirtual gen, b, (Method. (str n "Value"), (str "()" p)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (.invokeConstructor gen, (Type/getType (.getClass value)), ctor)
                        )
                    )
                )
                (§ instance? IRecord value)
                (do
                    (let [#_"Method" createMethod (Method/getMethod (str (.getName (.getClass value)) " create(cloiure.lang.IPersistentMap)"))]
                        (.emitValue this, (PersistentArrayMap'create (cast java.util.Map value)), gen)
                        (.invokeStatic gen, (Compiler'getType (.getClass value)), createMethod)
                    )
                )
                (§ instance? IPersistentMap value)
                (do
                    (let [#_"List" entries (ArrayList.)]
                        (doseq [#_"Map$Entry" entry (cast Set #_"<Map$Entry>" (.entrySet (cast Map value)))]
                            (.add entries, (.getKey entry))
                            (.add entries, (.getValue entry))
                        )
                        (.emitListAsObjectArray this, entries, gen)
                        (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
                    )
                )
                (§ instance? IPersistentVector value)
                (do
                    (let [#_"IPersistentVector" args (cast' IPersistentVector value)]
                        (if (<= (.count args) Tuple'MAX_SIZE)
                            (do
                                (loop-when-recur [#_"int" i 0] (< i (.count args)) [(inc i)]
                                    (.emitValue this, (.nth args, i), gen)
                                )
                                (.invokeStatic gen, Compiler'TUPLE_TYPE, (aget Compiler'createTupleMethods (.count args)))
                            )
                            (do
                                (.emitListAsObjectArray this, value, gen)
                                (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))
                            )
                        )
                    )
                )
                (§ instance? PersistentHashSet value)
                (do
                    (let [#_"ISeq" vs (RT'seq value)]
                        (if (nil? vs)
                            (do
                                (.getStatic gen, (§ unsure Type/getType (§ class PersistentHashSet)), "EMPTY", (§ unsure Type/getType (§ class PersistentHashSet)))
                            )
                            (do
                                (.emitListAsObjectArray this, vs, gen)
                                (.invokeStatic gen, (§ unsure Type/getType (§ class PersistentHashSet)), (Method/getMethod "cloiure.lang.PersistentHashSet create(Object[])"))
                            )
                        )
                    )
                )
                (or (§ instance? ISeq value) (§ instance? IPersistentList value))
                (do
                    (.emitListAsObjectArray this, value, gen)
                    (.invokeStatic gen, (Type/getType java.util.Arrays), (Method/getMethod "java.util.List asList(Object[])"))
                    (.invokeStatic gen, (§ unsure Type/getType (§ class PersistentList)), (Method/getMethod "cloiure.lang.IPersistentList create(java.util.List)"))
                )
                (instance? Pattern value)
                (do
                    (.emitValue this, (.toString value), gen)
                    (.invokeStatic gen, (Type/getType Pattern), (Method/getMethod "java.util.regex.Pattern compile(String)"))
                )
                :else
                (do
                    (let [#_"String" cs nil]
                        (try
                            (§ ass cs (RT'printString value))
                            (catch Exception e
                                (throw (RuntimeException. (str "Can't embed object in code: " value)))
                            )
                        )
                        (when (zero? (.length cs))
                            (throw (RuntimeException. (str "Can't embed unreadable object in code: " value)))
                        )
                        (when (.startsWith cs, "#<")
                            (throw (RuntimeException. (str "Can't embed unreadable object in code: " cs)))
                        )

                        (.push gen, cs)
                        (.invokeStatic gen, Compiler'RT_TYPE, readStringMethod)
                        (§ ass partial false)
                    )
                )
            )

            (when partial
                (when (and (§ instance? IObj value) (pos? (RT'count (.meta (cast' IObj value)))))
                    (.checkCast gen, Compiler'IOBJ_TYPE)
                    (.emitValue this, (.meta (cast' IObj value)), gen)
                    (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
                    (.invokeInterface gen, Compiler'IOBJ_TYPE, (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitConstants) [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
        (loop-when-recur [#_"int" i 0] (< i (.count (:constants this))) [(inc i)]
            (when (.contains (:usedConstants this), i)
                (.emitValue this, (.nth (:constants this), i), clinitgen)
                (.checkCast clinitgen, (.constantType this, i))
                (.putStatic clinitgen, (:objtype this), (.constantName this, i), (.constantType this, i))
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isMutable) [#_"ObjExpr" this, #_"LocalBinding" lb]
        (or (.isVolatile this, lb) (and (RT'booleanCast-1o (RT'contains (:fields this), (:sym lb))) (RT'booleanCast-1o (RT'get-2 (.meta (:sym lb)), (Keyword'intern (Symbol'intern "unsynchronized-mutable"))))))
    )

    #_method
    (§ defn #_"boolean" (§ method isVolatile) [#_"ObjExpr" this, #_"LocalBinding" lb]
        (and (RT'booleanCast-1o (RT'contains (:fields this), (:sym lb))) (RT'booleanCast-1o (RT'get-2 (.meta (:sym lb)), (Keyword'intern (Symbol'intern "volatile-mutable")))))
    )

    #_method
    (§ defn #_"boolean" (§ method isDeftype) [#_"ObjExpr" this]
        (some? (:fields this))
    )

    #_method
    (§ defn #_"boolean" (§ method supportsMeta) [#_"ObjExpr" this]
        (not (.isDeftype this))
    )

    #_method
    (§ defn #_"void" (§ method emitClearCloses) [#_"ObjExpr" this, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (§ defn #_"Class" (§ method getCompiledClass) [#_"ObjExpr" this]
        (§ sync this
            (when (nil? (:compiledClass this))
                (§ ass this (assoc this :loader (cast' DynamicClassLoader (.deref Compiler'LOADER))))
                (§ ass this (assoc this :compiledClass (.defineClass (:loader this), (:name this), (:bytecode this), (:src this))))
            )
            (:compiledClass this)
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ObjExpr" this]
        (when-not (.isDeftype this)
            (try
                (.newInstance (.getCompiledClass this))
                (catch Exception e
                    (throw (Util'sneakyThrow e))
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitLetFnInits) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"IPersistentSet" letFnLocals]
        ;; objx arg is enclosing objx, not this
        (.checkCast gen, (:objtype this))

        (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
            (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                (when (.contains letFnLocals, lb)
                    (let [#_"Class" primc (.getPrimitiveType lb)]
                        (.dup gen)
                        (if (some? primc)
                            (do
                                (.emitUnboxedLocal objx, gen, lb)
                                (.putField gen, (:objtype this), (:name lb), (Type/getType primc))
                            )
                            (do
                                (.emitLocal objx, gen, lb, false)
                                (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                            )
                        )
                    )
                )
            )
        )
        (.pop gen)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ObjExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (if (.isDeftype this)
            (do
                (.visitInsn gen, Opcodes/ACONST_NULL)
            )
            (do
                (.newInstance gen, (:objtype this))
                (.dup gen)
                (when (.supportsMeta this)
                    (.visitInsn gen, Opcodes/ACONST_NULL)
                )
                (loop-when-recur [#_"ISeq" s (RT'seq (:closesExprs this))] (some? s) [(.next s)]
                    (let [#_"LocalBindingExpr" lbe (cast' LocalBindingExpr (.first s))]
                        (let [#_"LocalBinding" lb (:b lbe)]
                            (if (some? (.getPrimitiveType lb))
                                (do
                                    (.emitUnboxedLocal objx, gen, lb)
                                )
                                (do
                                    (.emitLocal objx, gen, lb, (:shouldClear lbe))
                                )
                            )
                        )
                    )
                )
                (.invokeConstructor gen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this)))
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ObjExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ObjExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (cond (some? (:compiledClass this)) (:compiledClass this) (some? (:tag this)) (HostExpr'tagToClass (:tag this)) :else (§ class IFn))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"void" (§ method emitAssignLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"Expr" val]
        (when (.isMutable this, lb) => (throw (IllegalArgumentException. (str "Cannot assign to non-mutable: " (:name lb))))
            (let [#_"Class" primc (.getPrimitiveType lb)]
                (.loadThis gen)
                (if (some? primc)
                    (do
                        (when (not (and (§ instance? MaybePrimitiveExpr val) (.canEmitPrimitive (cast' MaybePrimitiveExpr val))))
                            (throw (IllegalArgumentException. (str "Must assign primitive to primitive mutable: " (:name lb))))
                        )
                        (let [#_"MaybePrimitiveExpr" me (cast' MaybePrimitiveExpr val)]
                            (.emitUnboxed me, :Context'EXPRESSION, this, gen)
                            (.putField gen, (:objtype this), (:name lb), (Type/getType primc))
                        )
                    )
                    (do
                        (.emit val, :Context'EXPRESSION, this, gen)
                        (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"boolean" clear]
        (if (.containsKey (:closes this), lb)
            (do
                (let [#_"Class" primc (.getPrimitiveType lb)]
                    (.loadThis gen)
                    (if (some? primc)
                        (do
                            (.getField gen, (:objtype this), (:name lb), (Type/getType primc))
                            (HostExpr'emitBoxReturn this, gen, primc)
                        )
                        (do
                            (.getField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                            (when (and (:onceOnly this) clear (:canBeCleared lb))
                                (.loadThis gen)
                                (.visitInsn gen, Opcodes/ACONST_NULL)
                                (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                            )
                        )
                    )
                )
            )
            (do
                (let [#_"int" argoff (if (:canBeDirect this) 0 1)]
                    (let [#_"Class" primc (.getPrimitiveType lb)]
                        (if (:isArg lb)
                            (do
                                (.loadArg gen, (- (:idx lb) argoff))
                                (cond (some? primc)
                                    (do
                                        (HostExpr'emitBoxReturn this, gen, primc)
                                    )
                                    (and clear (:canBeCleared lb))
                                    (do
                                        (.visitInsn gen, Opcodes/ACONST_NULL)
                                        (.storeArg gen, (- (:idx lb) argoff))
                                    )
                                )
                            )
                            (do
                                (if (some? primc)
                                    (do
                                        (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ILOAD), (:idx lb))
                                        (HostExpr'emitBoxReturn this, gen, primc)
                                    )
                                    (do
                                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:idx lb))
                                        (when (and clear (:canBeCleared lb))
                                            (.visitInsn gen, Opcodes/ACONST_NULL)
                                            (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx lb))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitUnboxedLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb]
        (cond (.containsKey (:closes this), lb)
            (do
                (.loadThis gen)
                (.getField gen, (:objtype this), (:name lb), (Type/getType (.getPrimitiveType lb)))
            )
            (:isArg lb)
            (do
                (.loadArg gen, (- (:idx lb) (if (:canBeDirect this) 0 1)))
            )
            :else
            (do
                (.visitVarInsn gen, (.getOpcode (Type/getType (.getPrimitiveType lb)), Opcodes/ILOAD), (:idx lb))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitVar) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" var]
        (let [#_"Integer" i (cast Integer (.valAt (:vars this), var))]
            (.emitConstant this, gen, i)
        )
        nil
    )

    (def #_"Method" ObjExpr'varGetMethod (Method/getMethod "Object get()"))
    (def #_"Method" ObjExpr'varGetRawMethod (Method/getMethod "Object getRawRoot()"))

    #_method
    (§ defn #_"void" (§ method emitVarValue) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" v]
        (let [#_"Integer" i (cast Integer (.valAt (:vars this), v))]
            (if (not (.isDynamic v))
                (do
                    (.emitConstant this, gen, i)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, ObjExpr'varGetRawMethod)
                )
                (do
                    (.emitConstant this, gen, i)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, varGetMethod)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitKeyword) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Keyword" k]
        (let [#_"Integer" i (cast Integer (.valAt (:keywords this), k))]
            (.emitConstant this, gen, i)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitConstant) [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"int" id]
        (§ ass this (assoc this :usedConstants (cast' IPersistentSet (.cons (:usedConstants this), id))))
        (.getStatic gen, (:objtype this), (.constantName this, id), (.constantType this, id))
        nil
    )

    #_method
    (§ defn #_"String" (§ method constantName) [#_"ObjExpr" this, #_"int" id]
        (str ObjExpr'CONST_PREFIX id)
    )

    #_method
    (§ defn #_"String" (§ method siteName) [#_"ObjExpr" this, #_"int" n]
        (str "__site__" n)
    )

    #_method
    (§ defn #_"String" (§ method siteNameStatic) [#_"ObjExpr" this, #_"int" n]
        (str (.siteName this, n) "__")
    )

    #_method
    (§ defn #_"String" (§ method thunkName) [#_"ObjExpr" this, #_"int" n]
        (str "__thunk__" n)
    )

    #_method
    (§ defn #_"String" (§ method cachedClassName) [#_"ObjExpr" this, #_"int" n]
        (str "__cached_class__" n)
    )

    #_method
    (§ defn #_"String" (§ method cachedVarName) [#_"ObjExpr" this, #_"int" n]
        (str "__cached_var__" n)
    )

    #_method
    (§ defn #_"String" (§ method varCallsiteName) [#_"ObjExpr" this, #_"int" n]
        (str "__var__callsite__" n)
    )

    #_method
    (§ defn #_"String" (§ method thunkNameStatic) [#_"ObjExpr" this, #_"int" n]
        (str (.thunkName this, n) "__")
    )

    #_method
    (§ defn #_"Type" (§ method constantType) [#_"ObjExpr" this, #_"int" id]
        (let [#_"Object" o (.nth (:constants this), id) #_"Class" c (Util'classOf o)]
            (or
                (when (and (some? c) (Modifier/isPublic (.getModifiers c)))
                    ;; can't emit derived fn types due to visibility
                    (cond
                        (.isAssignableFrom (§ class LazySeq), c) (§ unsure Type/getType (§ class ISeq))
                        (= c (§ class Keyword))                  (§ unsure Type/getType (§ class Keyword))
                        (.isAssignableFrom (§ class RestFn), c)  (§ unsure Type/getType (§ class RestFn))
                        (.isAssignableFrom (§ class AFn), c)     (§ unsure Type/getType (§ class AFn))
                        (= c (§ class Var))                      (§ unsure Type/getType (§ class Var))
                        (= c String)                             (Type/getType String)
                    )
                )
                Compiler'OBJECT_TYPE
            )
        )
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (defn- #_"PathNode" PathNode'init []
        (hash-map
            #_"PathType" :type nil
            #_"PathNode" :parent nil
        )
    )

    (defn #_"PathNode" PathNode'new [#_"PathType" type, #_"PathNode" parent]
        (let [this (PathNode'init)]
            (§ ass this (assoc this :type type))
            (§ ass this (assoc this :parent parent))
            this
        )
    )
)

(def PState'enum-set
    (hash-set
        :PState'REQ
        :PState'REST
        :PState'DONE
    )
)

(class-ns FnMethod (§ extends ObjMethod)
    (defn- #_"FnMethod" FnMethod'init []
        (hash-map
            ;; localbinding->localbinding
            #_"PersistentVector" :reqParms PersistentVector'EMPTY
            #_"LocalBinding" :restParm nil
            #_"Type[]" :argtypes nil
            #_"Class[]" :argclasses nil
            #_"Class" :retClass nil
            #_"String" :prim nil
        )
    )

    (defn #_"FnMethod" FnMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (merge (ObjMethod'new objx, parent) (FnMethod'init))
    )

    (defn #_"char" FnMethod'classChar [#_"Object" x]
        (let [#_"Class" c
                (cond
                    (instance? Class x)    (cast Class x)
                    (§ instance? Symbol x) (Compiler'primClass-1s (cast' Symbol x))
                )]
            (cond
                (or (nil? c) (not (.isPrimitive c))) \O
                (= c Long/TYPE)                      \L
                (= c Double/TYPE)                    \D
                :else
                    (throw (IllegalArgumentException. "Only long and double primitives are supported"))
            )
        )
    )

    (defn #_"String" FnMethod'primInterface [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (dotimes [#_"int" i (.count args)]
                (.append sb, (FnMethod'classChar (Compiler'tagOf (.nth args, i))))
            )
            (.append sb, (FnMethod'classChar (Compiler'tagOf args)))
            (let [#_"String" s (.toString sb) #_"boolean" prim? (or (.contains s, "L") (.contains s, "D"))]
                (cond
                    (and prim? (< 4 (.count args))) (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    prim?                           (str "cloiure.lang.IFn$" s)
                )
            )
        )
    )

    (defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Object" rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" parms (cast' IPersistentVector (RT'first form))]
            (let [#_"ISeq" body (RT'next form)]
                (try
                    (let [#_"FnMethod" method (FnMethod'new objx, (cast' ObjMethod (.deref Compiler'METHOD)))]
                        (§ ass (:line method) (Compiler'lineDeref))
                        (§ ass (:column method) (Compiler'columnDeref))
                        ;; register as the current method and set up a new env frame
                        (let [#_"PathNode" pnode (cast' PathNode (.get Compiler'CLEAR_PATH))]
                            (when (nil? pnode)
                                (§ ass pnode (PathNode'new :PathType'PATH, nil))
                            )
                            (Var'pushThreadBindings (RT'mapUniqueKeys
                                (object-array [
                                    Compiler'METHOD                method
                                    Compiler'LOCAL_ENV             (.deref Compiler'LOCAL_ENV)
                                    Compiler'LOOP_LOCALS           nil
                                    Compiler'NEXT_LOCAL_NUM        0
                                    Compiler'CLEAR_PATH            pnode
                                    Compiler'CLEAR_ROOT            pnode
                                    Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                    Compiler'METHOD_RETURN_CONTEXT RT'T
                                ])
                            ))

                            (§ ass (:prim method) (FnMethod'primInterface parms))
                            (when (some? (:prim method))
                                (§ ass (:prim method) (.replace (:prim method), \., \/))
                            )

                            (when (instance? String rettag)
                                (§ ass rettag (Symbol'intern nil, (cast String rettag)))
                            )
                            (when (not (§ instance? Symbol rettag))
                                (§ ass rettag nil)
                            )
                            (when (some? rettag)
                                (let [#_"String" retstr (.getName (cast' Symbol rettag))]
                                    (when (not (or (= retstr "long") (= retstr "double")))
                                        (§ ass rettag nil)
                                    )
                                )
                            )
                            (§ ass (:retClass method) (Compiler'tagClass (or (Compiler'tagOf parms) rettag)))
                            (if (.isPrimitive (:retClass method))
                                (do
                                    (when (not (or (= (:retClass method) Double/TYPE) (= (:retClass method) Long/TYPE)))
                                        (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                    )
                                )
                                (do
                                    (§ ass (:retClass method) Object)
                                )
                            )
                            ;; register 'this' as local 0
                            (if (some? (:thisName objx))
                                (do
                                    (Compiler'registerLocal (Symbol'intern (:thisName objx)), nil, nil, false)
                                )
                                (do
                                    (Compiler'getAndIncLocalNum)
                                )
                            )
                            (let [#_"PState" state :PState'REQ]
                                (let [#_"PersistentVector" argLocals PersistentVector'EMPTY]
                                    (let [#_"ArrayList<Type>" argtypes (ArrayList.)]
                                        (let [#_"ArrayList<Class>" argclasses (ArrayList.)]
                                            (loop-when-recur [#_"int" i 0] (< i (.count parms)) [(inc i)]
                                                (when (not (§ instance? Symbol (.nth parms, i)))
                                                    (throw (IllegalArgumentException. "fn params must be Symbols"))
                                                )
                                                (let [#_"Symbol" p (cast' Symbol (.nth parms, i))]
                                                    (when (some? (.getNamespace p))
                                                        (throw (RuntimeException. (str "Can't use qualified name as parameter: " p)))
                                                    )
                                                    (if (.equals p, Compiler'_AMP_)
                                                        (do
                                                            (if (= state :PState'REQ)
                                                                (do
                                                                    (§ ass state :PState'REST)
                                                                )
                                                                (do
                                                                    (throw (RuntimeException. "Invalid parameter list"))
                                                                )
                                                            )
                                                        )
                                                        (do
                                                            (let [#_"Class" pc (Compiler'primClass-1c (Compiler'tagClass (Compiler'tagOf p)))]
                                                                (when (and (.isPrimitive pc) (not (or (= pc Double/TYPE) (= pc Long/TYPE))))
                                                                    (throw (IllegalArgumentException. (str "Only long and double primitives are supported: " p)))
                                                                )

                                                                (when (and (= state :PState'REST) (some? (Compiler'tagOf p)))
                                                                    (throw (RuntimeException. "& arg cannot have type hint"))
                                                                )
                                                                (when (and (= state :PState'REST) (some? (:prim method)))
                                                                    (throw (RuntimeException. "fns taking primitives cannot be variadic"))
                                                                )

                                                                (when (= state :PState'REST)
                                                                    (§ ass pc (§ class ISeq))
                                                                )
                                                                (.add argtypes, (Type/getType pc))
                                                                (.add argclasses, pc)
                                                                (let [#_"LocalBinding" lb (if (.isPrimitive pc) (Compiler'registerLocal p, nil, (MethodParamExpr'new pc), true) (Compiler'registerLocal p, (if (= state :PState'REST) Compiler'ISEQ (Compiler'tagOf p)), nil, true))]
                                                                    (§ ass argLocals (.cons argLocals, lb))
                                                                    (case state
                                                                        :PState'REQ
                                                                        (do
                                                                            (§ ass (:reqParms method) (.cons (:reqParms method), lb))
                                                                            (§ break )
                                                                        )
                                                                        :PState'REST
                                                                        (do
                                                                            (§ ass (:restParm method) lb)
                                                                            (§ ass state :PState'DONE)
                                                                            (§ break )
                                                                        )
                                                                        (do
                                                                            (throw (RuntimeException. "Unexpected parameter"))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (when (< Compiler'MAX_POSITIONAL_ARITY (.count (:reqParms method)))
                                                (throw (RuntimeException. (str "Can't specify more than " Compiler'MAX_POSITIONAL_ARITY " params")))
                                            )
                                            (.set Compiler'LOOP_LOCALS, argLocals)
                                            (§ ass (:argLocals method) argLocals)
                                            (§ ass (:argtypes method) (.toArray argtypes, (make-array Type (.size argtypes))))
                                            (§ ass (:argclasses method) (.toArray argclasses, (make-array Class (.size argtypes))))
                                            (when (some? (:prim method))
                                                (loop-when-recur [#_"int" i 0] (< i (alength (:argclasses method))) [(inc i)]
                                                    (when (or (= (aget (:argclasses method) i) Long/TYPE) (= (aget (:argclasses method) i) Double/TYPE))
                                                        (Compiler'getAndIncLocalNum)
                                                    )
                                                )
                                            )
                                            (§ ass (:body method) (.parse (BodyParser'new), :Context'RETURN, body))
                                            method
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (cond
            (:canBeDirect fn)    (.doEmitStatic this, fn, cv)
            (some? (:prim this)) (.doEmitPrim this, fn, cv)
            :else                (.doEmit this, fn, cv)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmitStatic) [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Type" returnType (Type/getType (:retClass this))
              #_"Method" ms (Method. "invokeStatic", returnType, (:argtypes this))
              ;; todo don't hardwire EXCEPTION_TYPES
              #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ms, nil, Compiler'EXCEPTION_TYPES, cv)]
            (.visitCode gen)

            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map
                        (object-array [
                            Compiler'LOOP_LABEL loopLabel
                            Compiler'METHOD     this
                        ])
                    ))
                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))

                    (let [#_"Label" end (.mark gen)]
                        (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argtypes this) (:idx lb))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )

                (.returnValue gen)
                (.endMethod gen)

                ;; generate the regular invoke, calling the static method
                (let [#_"Method" m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (§ ass gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv))
                    (.visitCode gen)
                    (loop-when-recur [#_"int" i 0] (< i (alength (:argtypes this))) [(inc i)]
                        (.loadArg gen, i)
                        (HostExpr'emitUnboxArg fn, gen, (aget (:argclasses this) i))
                        (when (not (.isPrimitive (aget (:argclasses this) i)))
                            (.visitInsn gen, Opcodes/ACONST_NULL)
                            (.storeArg gen, i)
                        )
                    )
                    (let [#_"Label" callLabel (.mark gen)]
                        (.visitLineNumber gen, (:line this), callLabel)
                        (.invokeStatic gen, (:objtype (:objx this)), ms)
                        (.box gen, returnType)

                        (.returnValue gen)
                        (.endMethod gen)

                        ;; generate primInvoke if prim
                        (when (some? (:prim this))
                            (when (or (= (:retClass this) Double/TYPE) (= (:retClass this) Long/TYPE))
                                (§ ass returnType (.getReturnType this))
                            )
                            (let [#_"else" returnType Compiler'OBJECT_TYPE]
                                (let [#_"Method" pm (Method. "invokePrim", returnType, (:argtypes this))]
                                    ;; todo don't hardwire EXCEPTION_TYPES
                                    (§ ass gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), pm, nil, Compiler'EXCEPTION_TYPES, cv))
                                    (.visitCode gen)
                                    (loop-when-recur [#_"int" i 0] (< i (alength (:argtypes this))) [(inc i)]
                                        (.loadArg gen, i)
                                        (when (not (.isPrimitive (aget (:argclasses this) i)))
                                            (.visitInsn gen, Opcodes/ACONST_NULL)
                                            (.storeArg gen, i)
                                        )
                                    )
                                    (.invokeStatic gen, (:objtype (:objx this)), ms)

                                    (.returnValue gen)
                                    (.endMethod gen)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmitPrim) [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Type" returnType (if (any = (:retClass this) Double/TYPE Long/TYPE) (.getReturnType this) Compiler'OBJECT_TYPE)
              #_"Method" ms (Method. "invokePrim", returnType, (:argtypes this))
              ;; todo don't hardwire EXCEPTION_TYPES
              #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ms, nil, Compiler'EXCEPTION_TYPES, cv)]
            (.visitCode gen)

            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map
                        (object-array [
                            Compiler'LOOP_LABEL loopLabel
                            Compiler'METHOD     this
                        ])
                    ))
                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))

                    (let [#_"Label" end (.mark gen)]
                        (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                        (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argtypes this) (dec (:idx lb)))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )

                (.returnValue gen)
                (.endMethod gen)

                ;; generate the regular invoke, calling the prim method
                (let [#_"Method" m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (§ ass gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv))
                    (.visitCode gen)
                    (.loadThis gen)
                    (loop-when-recur [#_"int" i 0] (< i (alength (:argtypes this))) [(inc i)]
                        (.loadArg gen, i)
                        (HostExpr'emitUnboxArg fn, gen, (aget (:argclasses this) i))
                    )
                    (.invokeInterface gen, (Type/getType (str "L" (:prim this) ";")), ms)
                    (.box gen, (.getReturnType this))

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                (.visitCode gen)

                (let [#_"Label" loopLabel (.mark gen)]
                    (.visitLineNumber gen, (:line this), loopLabel)
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'LOOP_LABEL loopLabel
                                Compiler'METHOD     this
                            ])
                        ))

                        (.emit (:body this), :Context'RETURN, fn, gen)
                        (let [#_"Label" end (.mark gen)]
                            (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                            (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                    (.visitLocalVariable gen, (:name lb), "Ljava/lang/Object;", nil, loopLabel, end, (:idx lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"PersistentVector" (§ method reqParms) [#_"FnMethod" this]
        (:reqParms this)
    )

    #_method
    (§ defn #_"LocalBinding" (§ method restParm) [#_"FnMethod" this]
        (:restParm this)
    )

    #_method
    (§ defn #_"boolean" (§ method isVariadic) [#_"FnMethod" this]
        (some? (:restParm this))
    )

    #_method
    (§ defn #_"int" (§ method numParams) [#_"FnMethod" this]
        (+ (.count (:reqParms this)) (if (.isVariadic this) 1 0))
    )

    #_method
    (§ defn #_"String" (§ method getMethodName) [#_"FnMethod" this]
        (if (.isVariadic this) "doInvoke" "invoke")
    )

    #_method
    (§ defn #_"Type" (§ method getReturnType) [#_"FnMethod" this]
        (if (some? (:prim this)) ;; objx.isStatic
            (Type/getType (:retClass this))
            Compiler'OBJECT_TYPE
        )
    )

    #_method
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"FnMethod" this]
        (if (and (.isVariadic this) (= (.count (:reqParms this)) Compiler'MAX_POSITIONAL_ARITY))
            (let [#_"int" n (inc Compiler'MAX_POSITIONAL_ARITY) #_"Type[]" a (make-array Type n)]
                (dotimes [#_"int" i n]
                    (aset a i Compiler'OBJECT_TYPE)
                )
                a
            )
            (aget Compiler'ARG_TYPES (.numParams this))
        )
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocals) [#_"FnMethod" this, #_"GeneratorAdapter" gen]
        nil
    )
)

#_abstract
(class-ns ObjMethod
    (defn- #_"ObjMethod" ObjMethod'init []
        (hash-map
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            #_"ObjMethod" :parent nil
            ;; localbinding->localbinding
            #_"IPersistentMap" :locals nil
            ;; num->localbinding
            #_"IPersistentMap" :indexlocals nil
            #_"Expr" :body nil
            #_"ObjExpr" :objx nil
            #_"PersistentVector" :argLocals nil
            #_"int" :maxLocal 0
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :usesThis false
            #_"PersistentHashSet" :localsUsedInCatchFinally PersistentHashSet'EMPTY
            #_protected
            #_"IPersistentMap" :methodMeta nil
        )
    )

    (defn #_"ObjMethod" ObjMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (let [this (ObjMethod'init)]
            (§ ass this (assoc this :parent parent))
            (§ ass this (assoc this :objx objx))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method locals) [#_"ObjMethod" this]
        (:locals this)
    )

    #_method
    (§ defn #_"Expr" (§ method body) [#_"ObjMethod" this]
        (:body this)
    )

    #_method
    (§ defn #_"ObjExpr" (§ method objx) [#_"ObjMethod" this]
        (:objx this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method argLocals) [#_"ObjMethod" this]
        (:argLocals this)
    )

    #_method
    (§ defn #_"int" (§ method maxLocal) [#_"ObjMethod" this]
        (:maxLocal this)
    )

    #_method
    (§ defn #_"int" (§ method line) [#_"ObjMethod" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" (§ method column) [#_"ObjMethod" this]
        (:column this)
    )

    (defn #_"void" ObjMethod'emitBody [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" retClass, #_"Expr" body]
        (let [#_"MaybePrimitiveExpr" be (cast' MaybePrimitiveExpr body)]
            (if (and (Util'isPrimitive retClass) (.canEmitPrimitive be))
                (do
                    (let [#_"Class" bc (Compiler'maybePrimitiveType be)]
                        (cond (= bc retClass)
                            (do
                                (.emitUnboxed be, :Context'RETURN, objx, gen)
                            )
                            (and (= retClass Long/TYPE) (= bc Integer/TYPE))
                            (do
                                (.emitUnboxed be, :Context'RETURN, objx, gen)
                                (.visitInsn gen, Opcodes/I2L)
                            )
                            (and (= retClass Double/TYPE) (= bc Float/TYPE))
                            (do
                                (.emitUnboxed be, :Context'RETURN, objx, gen)
                                (.visitInsn gen, Opcodes/F2D)
                            )
                            (and (= retClass Integer/TYPE) (= bc Long/TYPE))
                            (do
                                (.emitUnboxed be, :Context'RETURN, objx, gen)
                                (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                            )
                            (and (= retClass Float/TYPE) (= bc Double/TYPE))
                            (do
                                (.emitUnboxed be, :Context'RETURN, objx, gen)
                                (.visitInsn gen, Opcodes/D2F)
                            )
                            :else
                            (do
                                (throw (IllegalArgumentException. (str "Mismatched primitive return, expected: " retClass ", had: " (.getJavaClass be))))
                            )
                        )
                    )
                )
                (do
                    (.emit body, :Context'RETURN, objx, gen)
                    (if (= retClass Void/TYPE)
                        (do
                            (.pop gen)
                        )
                        (do
                            (.unbox gen, (Type/getType retClass))
                        )
                    )
                )
            )
        )
        nil
    )

    #_abstract
    (§ defn #_"int" (§ method numParams) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"String" (§ method getMethodName) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type" (§ method getReturnType) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"ObjMethod" this])

    #_method
    (§ defn #_"void" (§ method emit) [#_"ObjMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                (.visitCode gen)

                (let [#_"Label" loopLabel (.mark gen)]
                    (.visitLineNumber gen, (:line this), loopLabel)
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'LOOP_LABEL loopLabel
                                Compiler'METHOD     this
                            ])
                        ))

                        (.emit (:body this), :Context'RETURN, fn, gen)
                        (let [#_"Label" end (.mark gen)]
                            (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                            (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                    (.visitLocalVariable gen, (:name lb), "Ljava/lang/Object;", nil, loopLabel, end, (:idx lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocals) [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocalsOld) [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i 0] (< i (.count (:argLocals this))) [(inc i)]
            (let [#_"LocalBinding" lb (cast' LocalBinding (.nth (:argLocals this), i))]
                (when (and (not (.contains (:localsUsedInCatchFinally this), (:idx lb))) (nil? (.getPrimitiveType lb)))
                    (.visitInsn gen, Opcodes/ACONST_NULL)
                    (.storeArg gen, (dec (:idx lb)))
                )
            )
        )
        (loop-when-recur [#_"int" i (inc (.numParams this))] (< i (inc (:maxLocal this))) [(inc i)]
            (when (not (.contains (:localsUsedInCatchFinally this), i))
                (let [#_"LocalBinding" b (cast' LocalBinding (RT'get-2 (:indexlocals this), i))]
                    (when (or (nil? b) (nil? (Compiler'maybePrimitiveType (:init b))))
                        (.visitInsn gen, Opcodes/ACONST_NULL)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), i)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearThis) [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        (.visitInsn gen, Opcodes/ACONST_NULL)
        (.visitVarInsn gen, Opcodes/ASTORE, 0)
        nil
    )
)

(class-ns LocalBinding
    (defn- #_"LocalBinding" LocalBinding'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"Symbol" :tag nil
            #_"Expr" :init nil
            #_"int" :idx 0
            #_"String" :name nil
            #_"boolean" :isArg false
            #_"PathNode" :clearPathRoot nil
            #_"boolean" :canBeCleared true
            #_"boolean" :recurMistmatch false
            #_"boolean" :used false

            #_"Boolean" :hjc nil

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBinding" LocalBinding'new [#_"int" num, #_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg, #_"PathNode" clearPathRoot]
        (let [this (LocalBinding'init)]
            (when (and (some? (Compiler'maybePrimitiveType init)) (some? tag))
                (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
            )
            (§ ass this (assoc this :idx num))
            (§ ass this (assoc this :sym sym))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :init init))
            (§ ass this (assoc this :isArg isArg))
            (§ ass this (assoc this :clearPathRoot clearPathRoot))
            (§ ass this (assoc this :name (Compiler'munge (:name sym))))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LocalBinding" this]
        (when (nil? (:hjc this))
            (if (and (some? (:init this)) (.hasJavaClass (:init this)) (Util'isPrimitive (.getJavaClass (:init this))) (not (§ instance? MaybePrimitiveExpr (:init this))))
                (do
                    (§ ass this (assoc this :hjc false))
                )
                (do
                    (§ ass this (assoc this :hjc (or (some? (:tag this)) (and (some? (:init this)) (.hasJavaClass (:init this))))))
                )
            )
        )
        (:hjc this)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LocalBinding" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getJavaClass (:init this)))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Class" (§ method getPrimitiveType) [#_"LocalBinding" this]
        (Compiler'maybePrimitiveType (:init this))
    )
)

(class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
    (defn- #_"LocalBindingExpr" LocalBindingExpr'init []
        (hash-map
            #_"LocalBinding" :b nil
            #_"Symbol" :tag nil

            #_"PathNode" :clearPath nil
            #_"PathNode" :clearRoot nil
            #_"boolean" :shouldClear false

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBindingExpr" LocalBindingExpr'new [#_"LocalBinding" b, #_"Symbol" tag]
        (let [this (LocalBindingExpr'init)]
            (when (and (some? (.getPrimitiveType b)) (some? tag))
                (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            )
            (§ ass this (assoc this :b b))
            (§ ass this (assoc this :tag tag))

            (§ ass this (assoc this :clearPath (cast' PathNode (.get Compiler'CLEAR_PATH))))
            (§ ass this (assoc this :clearRoot (cast' PathNode (.get Compiler'CLEAR_ROOT))))
            (let [#_"IPersistentCollection" sites (cast' IPersistentCollection (RT'get-2 (.get Compiler'CLEAR_SITES), b))]
                (§ ass (:used b) true)

                (when (pos? (:idx b))
                    (when (some? sites)
                        (loop-when-recur [#_"ISeq" s (.seq sites)] (some? s) [(.next s)]
                            (let [#_"LocalBindingExpr" o (cast' LocalBindingExpr (.first s))]
                                (let [#_"PathNode" common (Compiler'commonPath (:clearPath this), (:clearPath o))]
                                    (when (and (some? common) (= (:type common) :PathType'PATH))
                                        (§ ass (:shouldClear o) false)
                                    )
                                )
                            )
                        )
                    )

                    (when (= (:clearRoot this) (:clearPathRoot b))
                        (§ ass this (assoc this :shouldClear true))
                        (§ ass sites (RT'conj sites, this))
                        (.set Compiler'CLEAR_SITES, (RT'assoc (.get Compiler'CLEAR_SITES), b, sites))
                    )
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"LocalBindingExpr" this]
        (some? (.getPrimitiveType (:b this)))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emitUnboxedLocal objx, gen, (:b this))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (.emitLocal objx, gen, (:b this), (:shouldClear this))
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"LocalBindingExpr" this, #_"Expr" val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (.emitAssignLocal objx, gen, (:b this), val)
        (when (not= context :Context'STATEMENT)
            (.emitLocal objx, gen, (:b this), false)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LocalBindingExpr" this]
        (or (some? (:tag this)) (.hasJavaClass (:b this)))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LocalBindingExpr" this]
        (when (nil? (:jc this))
            (if (some? (:tag this))
                (do
                    (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
                )
                (do
                    (§ ass this (assoc this :jc (.getJavaClass (:b this))))
                )
            )
        )
        (:jc this)
    )
)

#_closure
(class-ns BodyParser (§ implements IParser)
    (defn #_"BodyParser" BodyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"BodyParser" this, #_"Context" context, #_"Object" frms]
        (let [#_"ISeq" forms (cast' ISeq frms)]
            (when (Util'equals (RT'first forms), Compiler'DO)
                (§ ass forms (RT'next forms))
            )
            (let [#_"PersistentVector" exprs PersistentVector'EMPTY]
                (loop-when-recur [forms forms] (some? forms) [(.next forms)]
                    (let [#_"Expr" e (if (and (not= context :Context'EVAL) (or (= context :Context'STATEMENT) (some? (.next forms)))) (Compiler'analyze-2 :Context'STATEMENT, (.first forms)) (Compiler'analyze-2 context, (.first forms)))]
                        (§ ass exprs (.cons exprs, e))
                    )
                )
                (when (zero? (.count exprs))
                    (§ ass exprs (.cons exprs, Compiler'NIL_EXPR))
                )
                (BodyExpr'new exprs)
            )
        )
    )
)

(class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"BodyExpr" BodyExpr'init []
        (hash-map
            #_"PersistentVector" :exprs nil
        )
    )

    (defn #_"BodyExpr" BodyExpr'new [#_"PersistentVector" exprs]
        (let [this (BodyExpr'init)]
            (§ ass this (assoc this :exprs exprs))
            this
        )
    )

    #_method
    (§ defn #_"PersistentVector" (§ method exprs) [#_"BodyExpr" this]
        (:exprs this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"BodyExpr" this]
        (let [#_"Object" ret nil]
            (doseq [#_"Object" o (:exprs this)]
                (let [#_"Expr" e (cast' Expr o)]
                    (§ ass ret (.eval e))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"BodyExpr" this]
        (and (§ instance? MaybePrimitiveExpr (.lastExpr this)) (.canEmitPrimitive (cast' MaybePrimitiveExpr (.lastExpr this))))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"BodyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i 0] (< i (dec (.count (:exprs this)))) [(inc i)]
            (let [#_"Expr" e (cast' Expr (.nth (:exprs this), i))]
                (.emit e, :Context'STATEMENT, objx, gen)
            )
        )
        (let [#_"MaybePrimitiveExpr" last (cast' MaybePrimitiveExpr (.nth (:exprs this), (dec (.count (:exprs this)))))]
            (.emitUnboxed last, context, objx, gen)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"BodyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i 0] (< i (dec (.count (:exprs this)))) [(inc i)]
            (let [#_"Expr" e (cast' Expr (.nth (:exprs this), i))]
                (.emit e, :Context'STATEMENT, objx, gen)
            )
        )
        (let [#_"Expr" last (cast' Expr (.nth (:exprs this), (dec (.count (:exprs this)))))]
            (.emit last, context, objx, gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"BodyExpr" this]
        (.hasJavaClass (.lastExpr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"BodyExpr" this]
        (.getJavaClass (.lastExpr this))
    )

    #_method
    (§ defn- #_"Expr" (§ method lastExpr) [#_"BodyExpr" this]
        (cast' Expr (.nth (:exprs this), (dec (.count (:exprs this)))))
    )
)

(class-ns BindingInit
    (defn- #_"BindingInit" BindingInit'init []
        (hash-map
            #_"LocalBinding" :binding nil
            #_"Expr" :init nil
        )
    )

    (defn #_"BindingInit" BindingInit'new [#_"LocalBinding" binding, #_"Expr" init]
        (let [this (BindingInit'init)]
            (§ ass this (assoc this :binding binding))
            (§ ass this (assoc this :init init))
            this
        )
    )

    #_method
    (§ defn #_"LocalBinding" (§ method binding) [#_"BindingInit" this]
        (:binding this)
    )

    #_method
    (§ defn #_"Expr" (§ method init) [#_"BindingInit" this]
        (:init this)
    )
)

#_closure
(class-ns LetFnParser (§ implements IParser)
    (defn #_"LetFnParser" LetFnParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"LetFnParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            ;; (letfns* [var (fn [args] body) ...] body...)
            (when (§ instance? IPersistentVector (RT'second form)) => (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                (let [#_"IPersistentVector" bindings (cast' IPersistentVector (RT'second form))]
                    (when (zero? (% (.count bindings) 2)) => (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                        (if (= context :Context'EVAL)
                            (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                            (try
                                (Var'pushThreadBindings (RT'map
                                    (object-array [
                                        Compiler'LOCAL_ENV      (.deref Compiler'LOCAL_ENV)
                                        Compiler'NEXT_LOCAL_NUM (.deref Compiler'NEXT_LOCAL_NUM)
                                    ])
                                ))
                                ;; pre-seed env (like Lisp labels)
                                (let [#_"PersistentVector" lbs PersistentVector'EMPTY
                                      _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                            (when (not (§ instance? Symbol (.nth bindings, i)))
                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth bindings, i))))
                                            )
                                            (let [#_"Symbol" sym (cast' Symbol (.nth bindings, i))]
                                                (when (some? (.getNamespace sym))
                                                    (throw (RuntimeException. (str "Can't let qualified name: " sym)))
                                                )
                                                (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (Compiler'tagOf sym), nil, false)]
                                                    (§ ass (:canBeCleared lb) false)
                                                    (§ ass lbs (.cons lbs, lb))
                                                )
                                            )
                                        )
                                      #_"PersistentVector" bindingInits PersistentVector'EMPTY
                                      _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                            (let [#_"Symbol" sym (cast' Symbol (.nth bindings, i))]
                                                (let [#_"Expr" init (Compiler'analyze-3 :Context'EXPRESSION, (.nth bindings, (inc i)), (:name sym))]
                                                    (let [#_"LocalBinding" lb (cast' LocalBinding (.nth lbs, (/ i 2)))]
                                                        (§ ass (:init lb) init)
                                                        (let [#_"BindingInit" bi (BindingInit'new lb, init)]
                                                            (§ ass bindingInits (.cons bindingInits, bi))
                                                        )
                                                    )
                                                )
                                            )
                                        )]
                                    (LetFnExpr'new bindingInits, (.parse (BodyParser'new), context, (RT'next (RT'next form))))
                                )
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr (§ implements Expr)
    (defn- #_"LetFnExpr" LetFnExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
        )
    )

    (defn #_"LetFnExpr" LetFnExpr'new [#_"PersistentVector" bindingInits, #_"Expr" body]
        (let [this (LetFnExpr'init)]
            (§ ass this (assoc this :bindingInits bindingInits))
            (§ ass this (assoc this :body body))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LetFnExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i 0] (< i (.count (:bindingInits this))) [(inc i)]
            (let [#_"BindingInit" bi (cast' BindingInit (.nth (:bindingInits this), i))]
                (.visitInsn gen, Opcodes/ACONST_NULL)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
            )
        )

        (let [#_"IPersistentSet" lbset PersistentHashSet'EMPTY]
            (loop-when-recur [#_"int" i 0] (< i (.count (:bindingInits this))) [(inc i)]
                (let [#_"BindingInit" bi (cast' BindingInit (.nth (:bindingInits this), i))]
                    (§ ass lbset (cast' IPersistentSet (.cons lbset, (:binding bi))))
                    (.emit (:init bi), :Context'EXPRESSION, objx, gen)
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
                )
            )

            (loop-when-recur [#_"int" i 0] (< i (.count (:bindingInits this))) [(inc i)]
                (let [#_"BindingInit" bi (cast' BindingInit (.nth (:bindingInits this), i))]
                    (let [#_"ObjExpr" fe (cast' ObjExpr (:init bi))]
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:idx (:binding bi)))
                        (.emitLetFnInits fe, gen, objx, lbset)
                    )
                )
            )

            (let [#_"Label" loopLabel (.mark gen)]
                (.emit (:body this), context, objx, gen)

                (let [#_"Label" end (.mark gen)]
                    (loop-when-recur [#_"ISeq" bis (.seq (:bindingInits this))] (some? bis) [(.next bis)]
                        (let [#_"BindingInit" bi (cast' BindingInit (.first bis))]
                            (let [#_"String" lname (:name (:binding bi))]
                                (when (.endsWith lname, "__auto__")
                                    (§ ass lname (+ lname (RT'nextID)))
                                )
                                (let [#_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                                    (if (some? primc)
                                        (do
                                            (.visitLocalVariable gen, lname, (Type/getDescriptor primc), nil, loopLabel, end, (:idx (:binding bi)))
                                        )
                                        (do
                                            (.visitLocalVariable gen, lname, "Ljava/lang/Object;", nil, loopLabel, end, (:idx (:binding bi)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LetFnExpr" this]
        (.hasJavaClass (:body this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LetFnExpr" this]
        (.getJavaClass (:body this))
    )
)

#_closure
(class-ns LetParser (§ implements IParser)
    (defn #_"LetParser" LetParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"LetParser" this, #_"Context" context, #_"Object" frm]
        ;; (let [var val var2 val2 ...] body...)
        (let [#_"ISeq" form (cast' ISeq frm) #_"boolean" isLoop (.equals (RT'first form), Compiler'LOOP)]
            (when (§ instance? IPersistentVector (RT'second form)) => (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                (let [#_"IPersistentVector" bindings (cast' IPersistentVector (RT'second form))]
                    (when (zero? (% (.count bindings) 2)) => (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                        (if (or (= context :Context'EVAL) (and (= context :Context'EXPRESSION) isLoop))
                            (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                            (let [#_"ISeq" body (RT'next (RT'next form))
                                  #_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))
                                  #_"IPersistentMap" backupMethodLocals (:locals method)
                                  #_"IPersistentMap" backupMethodIndexLocals (:indexlocals method)
                                  #_"IPersistentVector" recurMismatches PersistentVector'EMPTY
                                  _ (loop-when-recur [#_"int" i 0] (< i (/ (.count bindings) 2)) [(inc i)]
                                        (§ ass recurMismatches (.cons recurMismatches, RT'F))
                                    )]
                                ;; may repeat once for each binding with a mismatch, return breaks
                                (while true
                                    (let [#_"IPersistentMap" dynamicBindings
                                            (RT'map
                                                (object-array [
                                                    Compiler'LOCAL_ENV      (.deref Compiler'LOCAL_ENV)
                                                    Compiler'NEXT_LOCAL_NUM (.deref Compiler'NEXT_LOCAL_NUM)
                                                ])
                                            )
                                          _ (§ ass (:locals method) backupMethodLocals)
                                          _ (§ ass (:indexlocals method) backupMethodIndexLocals)
                                          #_"PathNode" looproot (PathNode'new :PathType'PATH, (cast' PathNode (.get Compiler'CLEAR_PATH)))
                                          #_"PathNode" clearroot (PathNode'new :PathType'PATH, looproot)
                                          #_"PathNode" clearpath (PathNode'new :PathType'PATH, looproot)]
                                        (when isLoop
                                            (§ ass dynamicBindings (.assoc dynamicBindings, Compiler'LOOP_LOCALS, nil))
                                        )
                                        (try
                                            (Var'pushThreadBindings dynamicBindings)
                                            (let [#_"PersistentVector" bindingInits PersistentVector'EMPTY
                                                  #_"PersistentVector" loopLocals PersistentVector'EMPTY
                                                  _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                                        (when (not (§ instance? Symbol (.nth bindings, i)))
                                                            (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth bindings, i))))
                                                        )
                                                        (let [#_"Symbol" sym (cast' Symbol (.nth bindings, i))]
                                                            (when (some? (.getNamespace sym))
                                                                (throw (RuntimeException. (str "Can't let qualified name: " sym)))
                                                            )
                                                            (let [#_"Expr" init (Compiler'analyze-3 :Context'EXPRESSION, (.nth bindings, (inc i)), (:name sym))]
                                                                (when isLoop
                                                                    (cond
                                                                        (and (some? recurMismatches) (RT'booleanCast-1o (.nth recurMismatches, (/ i 2))))
                                                                        (do
                                                                            (§ ass init (StaticMethodExpr'new 0, 0, nil, (§ class RT), "box", (RT'vector init), false))
                                                                            (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                                                                                (.println (RT'errPrintWriter), (str "Auto-boxing loop arg: " sym))
                                                                            )
                                                                        )
                                                                        (= (Compiler'maybePrimitiveType init) Integer/TYPE)
                                                                            (§ ass init (StaticMethodExpr'new 0, 0, nil, (§ class RT), "longCast", (RT'vector init), false))
                                                                        (= (Compiler'maybePrimitiveType init) Float/TYPE)
                                                                            (§ ass init (StaticMethodExpr'new 0, 0, nil, (§ class RT), "doubleCast", (RT'vector init), false))
                                                                    )
                                                                )
                                                                ;; sequential enhancement of env (like Lisp let*)
                                                                (try
                                                                    (when isLoop
                                                                        (Var'pushThreadBindings (RT'map
                                                                            (object-array [
                                                                                Compiler'CLEAR_PATH clearpath
                                                                                Compiler'CLEAR_ROOT clearroot
                                                                                Compiler'NO_RECUR   nil
                                                                            ])
                                                                        ))
                                                                    )
                                                                    (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (Compiler'tagOf sym), init, false)]
                                                                        (§ ass bindingInits (.cons bindingInits, (BindingInit'new lb, init)))
                                                                        (when isLoop
                                                                            (§ ass loopLocals (.cons loopLocals, lb))
                                                                        )
                                                                    )
                                                                    (finally
                                                                        (when isLoop
                                                                            (Var'popThreadBindings)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )]
                                                (when isLoop
                                                    (.set Compiler'LOOP_LOCALS, loopLocals)
                                                )
                                                (§ let [#_"Expr" bodyExpr]
                                                    (let [#_"boolean" moreMismatches false]
                                                        (try
                                                            (when isLoop
                                                                (Var'pushThreadBindings (RT'map
                                                                    (object-array [
                                                                        Compiler'CLEAR_PATH            clearpath
                                                                        Compiler'CLEAR_ROOT            clearroot
                                                                        Compiler'NO_RECUR              nil
                                                                        Compiler'METHOD_RETURN_CONTEXT (when (= context :Context'RETURN) (.deref Compiler'METHOD_RETURN_CONTEXT))
                                                                    ])
                                                                ))
                                                            )
                                                            (§ ass bodyExpr (.parse (BodyParser'new), (if isLoop :Context'RETURN context), body))
                                                            (finally
                                                                (when isLoop
                                                                    (Var'popThreadBindings)
                                                                    (loop-when-recur [#_"int" i 0] (< i (.count loopLocals)) [(inc i)]
                                                                        (when (:recurMistmatch (cast' LocalBinding (.nth loopLocals, i)))
                                                                            (§ ass recurMismatches (cast' IPersistentVector (.assoc recurMismatches, i, RT'T)))
                                                                            (§ ass moreMismatches true)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (when (not moreMismatches)
                                                            (§ return (LetExpr'new bindingInits, bodyExpr, isLoop))
                                                        )
                                                    )
                                                )
                                            )
                                            (finally
                                                (Var'popThreadBindings)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"LetExpr" LetExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
            #_"boolean" :isLoop false
        )
    )

    (defn #_"LetExpr" LetExpr'new [#_"PersistentVector" bindingInits, #_"Expr" body, #_"boolean" isLoop]
        (let [this (LetExpr'init)]
            (§ ass this (assoc this :bindingInits bindingInits))
            (§ ass this (assoc this :body body))
            (§ ass this (assoc this :isLoop isLoop))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.doEmit this, context, objx, gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" bindingLabels (HashMap.)]
            (loop-when-recur [#_"int" i 0] (< i (.count (:bindingInits this))) [(inc i)]
                (let [#_"BindingInit" bi (cast' BindingInit (.nth (:bindingInits this), i))]
                    (let [#_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                        (if (some? primc)
                            (do
                                (.emitUnboxed (cast' MaybePrimitiveExpr (:init bi)), :Context'EXPRESSION, objx, gen)
                                (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ISTORE), (:idx (:binding bi)))
                            )
                            (do
                                (.emit (:init bi), :Context'EXPRESSION, objx, gen)
                                (if (and (not (:used (:binding bi))) (:canBeCleared (:binding bi)))
                                    (do
                                        (.pop gen)
                                    )
                                    (do
                                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
                                    )
                                )
                            )
                        )
                        (.put bindingLabels, bi, (.mark gen))
                    )
                )
            )
            (let [#_"Label" loopLabel (.mark gen)]
                (if (:isLoop this)
                    (do
                        (try
                            (Var'pushThreadBindings (RT'map Compiler'LOOP_LABEL, loopLabel))
                            (if emitUnboxed
                                (do
                                    (.emitUnboxed (cast' MaybePrimitiveExpr (:body this)), context, objx, gen)
                                )
                                (do
                                    (.emit (:body this), context, objx, gen)
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                    (do
                        (if emitUnboxed
                            (do
                                (.emitUnboxed (cast' MaybePrimitiveExpr (:body this)), context, objx, gen)
                            )
                            (do
                                (.emit (:body this), context, objx, gen)
                            )
                        )
                    )
                )
                (let [#_"Label" end (.mark gen)]
                    (loop-when-recur [#_"ISeq" bis (.seq (:bindingInits this))] (some? bis) [(.next bis)]
                        (let [#_"BindingInit" bi (cast' BindingInit (.first bis))]
                            (let [#_"String" lname (:name (:binding bi))]
                                (when (.endsWith lname, "__auto__")
                                    (§ ass lname (+ lname (RT'nextID)))
                                )
                                (let [#_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                                    (if (some? primc)
                                        (do
                                            (.visitLocalVariable gen, lname, (Type/getDescriptor primc), nil, (.get bindingLabels, bi), end, (:idx (:binding bi)))
                                        )
                                        (do
                                            (.visitLocalVariable gen, lname, "Ljava/lang/Object;", nil, (.get bindingLabels, bi), end, (:idx (:binding bi)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LetExpr" this]
        (.hasJavaClass (:body this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LetExpr" this]
        (.getJavaClass (:body this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"LetExpr" this]
        (and (§ instance? MaybePrimitiveExpr (:body this)) (.canEmitPrimitive (cast' MaybePrimitiveExpr (:body this))))
    )
)

#_closure
(class-ns RecurParser (§ implements IParser)
    (defn #_"RecurParser" RecurParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"RecurParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref)]
            (let [#_"ISeq" form (cast' ISeq frm)]
                (let [#_"IPersistentVector" loopLocals (cast' IPersistentVector (.deref Compiler'LOOP_LOCALS))]
                    (when (or (not= context :Context'RETURN) (nil? loopLocals))
                        (throw (UnsupportedOperationException. "Can only recur from tail position"))
                    )
                    (when (some? (.deref Compiler'NO_RECUR))
                        (throw (UnsupportedOperationException. "Cannot recur across try"))
                    )
                    (let [#_"PersistentVector" args PersistentVector'EMPTY]
                        (loop-when-recur [#_"ISeq" s (RT'seq (.next form))] (some? s) [(.next s)]
                            (§ ass args (.cons args, (Compiler'analyze-2 :Context'EXPRESSION, (.first s))))
                        )
                        (when-not (= (.count args) (.count loopLocals))
                            (throw (IllegalArgumentException. (str "Mismatched argument count to recur, expected: " (.count loopLocals) " args, got: " (.count args))))
                        )
                        (loop-when-recur [#_"int" i 0] (< i (.count loopLocals)) [(inc i)]
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.nth loopLocals, i))]
                                (let [#_"Class" primc (.getPrimitiveType lb)]
                                    (when (some? primc)
                                        (let [#_"boolean" mismatch false]
                                            (let [#_"Class" pc (Compiler'maybePrimitiveType (cast' Expr (.nth args, i)))]
                                                (cond (= primc Long/TYPE)
                                                    (do
                                                        (when (not (or (= pc Long/TYPE) (= pc Integer/TYPE) (= pc Short/TYPE) (= pc Character/TYPE) (= pc Byte/TYPE)))
                                                            (§ ass mismatch true)
                                                        )
                                                    )
                                                    (= primc Double/TYPE)
                                                    (do
                                                        (when (not (or (= pc Double/TYPE) (= pc Float/TYPE)))
                                                            (§ ass mismatch true)
                                                        )
                                                    )
                                                )
                                                (when mismatch
                                                    (§ ass (:recurMistmatch lb) true)
                                                    (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                                                        (.println (RT'errPrintWriter), (str "line " line ": recur arg for primitive local: " (:name lb) " is not matching primitive, had: " (if (some? pc) (.getName pc) "Object") ", needed: " (.getName primc)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (RecurExpr'new loopLocals, args, line, column)
                    )
                )
            )
        )
    )
)

(class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"RecurExpr" RecurExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"IPersistentVector" :loopLocals nil

            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"RecurExpr" RecurExpr'new [#_"IPersistentVector" loopLocals, #_"IPersistentVector" args, #_"int" line, #_"int" column]
        (let [this (RecurExpr'init)]
            (§ ass this (assoc this :loopLocals loopLocals))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"RecurExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" loopLabel (cast Label (.deref Compiler'LOOP_LABEL))]
            (when (nil? loopLabel)
                (throw (IllegalStateException.))
            )
            (loop-when-recur [#_"int" i 0] (< i (.count (:loopLocals this))) [(inc i)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.nth (:loopLocals this), i))]
                    (let [#_"Expr" arg (cast' Expr (.nth (:args this), i))]
                        (if (some? (.getPrimitiveType lb))
                            (do
                                (let [#_"Class" primc (.getPrimitiveType lb)]
                                    (let [#_"Class" pc (Compiler'maybePrimitiveType arg)]
                                        (cond (= pc primc)
                                            (do
                                                (.emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                            )
                                            (and (= primc Long/TYPE) (= pc Integer/TYPE))
                                            (do
                                                (.emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                                (.visitInsn gen, Opcodes/I2L)
                                            )
                                            (and (= primc Double/TYPE) (= pc Float/TYPE))
                                            (do
                                                (.emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                                (.visitInsn gen, Opcodes/F2D)
                                            )
                                            (and (= primc Integer/TYPE) (= pc Long/TYPE))
                                            (do
                                                (.emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                                (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                                            )
                                            (and (= primc Float/TYPE) (= pc Double/TYPE))
                                            (do
                                                (.emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                                (.visitInsn gen, Opcodes/D2F)
                                            )
                                            :else
                                            (do
                                                (throw (IllegalArgumentException. (str "recur arg for primitive local: " (:name lb) " is not matching primitive, had: " (if (.hasJavaClass arg) (.getName (.getJavaClass arg)) "Object") ", needed: " (.getName primc))))
                                            )
                                        )
                                    )
                                )
                            )
                            (do
                                (.emit arg, :Context'EXPRESSION, objx, gen)
                            )
                        )
                    )
                )
            )

            (loop-when-recur [#_"int" i (dec (.count (:loopLocals this)))] (<= 0 i) [(dec i)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.nth (:loopLocals this), i))]
                    (let [#_"Class" primc (.getPrimitiveType lb)]
                        (if (:isArg lb)
                            (do
                                (.storeArg gen, (- (:idx lb) (if (:canBeDirect objx) 0 1)))
                            )
                            (do
                                (if (some? primc)
                                    (do
                                        (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ISTORE), (:idx lb))
                                    )
                                    (do
                                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx lb))
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (.goTo gen, loopLabel)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"RecurExpr" this]
        Compiler'RECUR_CLASS
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"RecurExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit this, context, objx, gen)
        nil
    )
)

(class-ns CompilerException (§ extends RuntimeException)
    (defn- #_"CompilerException" CompilerException'init []
        (hash-map
            #_"int" :line 0
        )
    )

    (defn #_"CompilerException" CompilerException'new [#_"int" line, #_"int" column, #_"Throwable" cause]
        (let [this (merge (§ foreign RuntimeException'new (str cause ", compiling at (" line ":" column ")"), cause) (CompilerException'init))]
            (§ ass this (assoc this :line line))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"CompilerException" this]
        (.getMessage this)
    )
)

#_closure
(class-ns DeftypeParser (§ implements IParser)
    (defn #_"DeftypeParser" DeftypeParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"DeftypeParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" rform (cast' ISeq frm)]
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            (§ ass rform (RT'next rform))
            (let [#_"String" tagname (.getName (cast' Symbol (.first rform)))]
                (§ ass rform (.next rform))
                (let [#_"Symbol" classname (cast' Symbol (.first rform))]
                    (§ ass rform (.next rform))
                    (let [#_"IPersistentVector" fields (cast' IPersistentVector (.first rform))]
                        (§ ass rform (.next rform))
                        (let [#_"IPersistentMap" opts PersistentHashMap'EMPTY]
                            (while (and (some? rform) (§ instance? Keyword (.first rform)))
                                (§ ass opts (.assoc opts, (.first rform), (RT'second rform)))
                                (§ ass rform (.next (.next rform)))
                            )

                            (let [#_"ObjExpr" ret (NewInstanceExpr'build (cast' IPersistentVector (RT'get-3 opts, Compiler'implementsKey, PersistentVector'EMPTY)), fields, nil, tagname, classname, (cast' Symbol (RT'get-2 opts, RT'TAG_KEY)), rform, frm, opts)]
                                ret
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ReifyParser (§ implements IParser)
    (defn #_"ReifyParser" ReifyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ReifyParser" this, #_"Context" context, #_"Object" frm]
        ;; (reify this-name? [interfaces] (method-name [args] body)*)
        (let [#_"ISeq" form (cast' ISeq frm)]
            (let [#_"ObjMethod" enclosingMethod (cast' ObjMethod (.deref Compiler'METHOD))]
                (let [#_"String" basename (str (if (some? enclosingMethod) (ObjExpr'trimGenID (:name (:objx enclosingMethod))) (Compiler'munge (:name (:name (Compiler'currentNS))))) "$")]
                    (let [#_"String" simpleName (str "reify__" (RT'nextID))]
                        (let [#_"String" classname (+ basename simpleName)]
                            (let [#_"ISeq" rform (RT'next form)]
                                (let [#_"IPersistentVector" interfaces (.cons (cast' IPersistentVector (RT'first rform)), (Symbol'intern "cloiure.lang.IObj"))]
                                    (§ ass rform (RT'next rform))

                                    (let [#_"ObjExpr" ret (NewInstanceExpr'build interfaces, nil, nil, classname, (Symbol'intern classname), nil, rform, frm, nil)]
                                        (if (and (§ instance? IObj frm) (some? (.meta (cast' IObj frm))))
                                            (do
                                                (MetaExpr'new ret, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast' IObj frm))))
                                            )
                                            (do
                                                ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewInstanceExpr (§ extends ObjExpr)
    (defn- #_"NewInstanceExpr" NewInstanceExpr'init []
        (hash-map
            #_"IPersistentCollection" :methods nil

            #_"Map<IPersistentVector, java.lang.reflect.Method>" :mmap nil
            #_"Map<IPersistentVector, Set<Class>>" :covariants nil
        )
    )

    (defn #_"NewInstanceExpr" NewInstanceExpr'new [#_"Object" tag]
        (merge (ObjExpr'new tag) (NewInstanceExpr'init))
    )

    (defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" interfaceSyms, #_"IPersistentVector" fieldSyms, #_"Symbol" thisSym, #_"String" tagName, #_"Symbol" className, #_"Symbol" typeTag, #_"ISeq" methodForms, #_"Object" frm, #_"IPersistentMap" opts]
        (let [#_"NewInstanceExpr" ret (NewInstanceExpr'new nil)]
            (§ ass (:src ret) frm)
            (§ ass (:name ret) (.toString className))
            (§ ass (:classMeta ret) (RT'meta className))
            (§ ass (:internalName ret) (.replace (:name ret), \., \/))
            (§ ass (:objtype ret) (Type/getObjectType (:internalName ret)))
            (§ ass (:opts ret) opts)

            (when (some? thisSym)
                (§ ass (:thisName ret) (:name thisSym))
            )

            (when (some? fieldSyms)
                (let [#_"IPersistentMap" fmap PersistentHashMap'EMPTY]
                    (let [#_"Object[]" closesvec (make-array Object (* 2 (.count fieldSyms)))]
                        (loop-when-recur [#_"int" i 0] (< i (.count fieldSyms)) [(inc i)]
                            (let [#_"Symbol" sym (cast' Symbol (.nth fieldSyms, i))]
                                (let [#_"LocalBinding" lb (LocalBinding'new -1, sym, nil, (MethodParamExpr'new (Compiler'tagClass (Compiler'tagOf sym))), false, nil)]
                                    (§ ass fmap (.assoc fmap, sym, lb))
                                    (aset closesvec (* i 2) lb)
                                    (aset closesvec (inc (* i 2)) lb)
                                )
                            )
                        )

                        ;; todo - inject __meta et al into closes - when?
                        ;; use array map to preserve ctor order
                        (§ ass (:closes ret) (PersistentArrayMap'new-1 closesvec))
                        (§ ass (:fields ret) fmap)
                        (loop-when-recur [#_"int" i (dec (.count fieldSyms))] (and (<= 0 i) (any = (:name (cast' Symbol (.nth fieldSyms, i))) "__meta" "__extmap" "__hash" "__hasheq")) [(dec i)]
                            (§ ass (:altCtorDrops ret) (inc (:altCtorDrops ret)))
                        )
                    )
                )
            )

            (let [#_"PersistentVector" interfaces PersistentVector'EMPTY]
                (loop-when-recur [#_"ISeq" s (RT'seq interfaceSyms)] (some? s) [(.next s)]
                    (let [#_"Class" c (cast Class (Compiler'resolve-1 (cast' Symbol (.first s))))]
                        (when (not (.isInterface c))
                            (throw (IllegalArgumentException. (str "only interfaces are supported, had: " (.getName c))))
                        )
                        (§ ass interfaces (.cons interfaces, c))
                    )
                )
                (let [#_"Class" superClass Object]
                    (let [#_"Map[]" mc (NewInstanceExpr'gatherMethods-2s superClass, (RT'seq interfaces))]
                        (let [#_"Map" overrideables (aget mc 0)]
                            (let [#_"Map" covariants (aget mc 1)]
                                (§ ass (:mmap ret) overrideables)
                                (§ ass (:covariants ret) covariants)

                                (let [#_"String[]" inames (NewInstanceExpr'interfaceNames interfaces)]
                                    (let [#_"Class" stub (NewInstanceExpr'compileStub (NewInstanceExpr'slashname superClass), ret, inames, frm)]
                                        (let [#_"Symbol" thistag (Symbol'intern nil, (.getName stub))]
                                            (try
                                                (Var'pushThreadBindings (RT'mapUniqueKeys
                                                    (object-array [
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                                                        Compiler'NO_RECUR           nil
                                                    ])
                                                ))
                                                (when (.isDeftype ret)
                                                    (Var'pushThreadBindings (RT'mapUniqueKeys
                                                        (object-array [
                                                            Compiler'METHOD             nil
                                                            Compiler'LOCAL_ENV          (:fields ret)
                                                            Compiler'COMPILE_STUB_SYM   (Symbol'intern nil, tagName)
                                                            Compiler'COMPILE_STUB_CLASS stub
                                                        ])
                                                    ))

                                                    (§ ass (:hintedFields ret) (RT'subvec fieldSyms, 0, (- (.count fieldSyms) (:altCtorDrops ret))))
                                                )

                                                ;; now (methodname [args] body)*
                                                (§ ass (:line ret) (Compiler'lineDeref))
                                                (§ ass (:column ret) (Compiler'columnDeref))
                                                (let [#_"IPersistentCollection" methods nil]
                                                    (loop-when-recur [#_"ISeq" s methodForms] (some? s) [(RT'next s)]
                                                        (let [#_"NewInstanceMethod" m (NewInstanceMethod'parse ret, (cast' ISeq (RT'first s)), thistag, overrideables)]
                                                            (§ ass methods (RT'conj methods, m))
                                                        )
                                                    )

                                                    (§ ass (:methods ret) methods)
                                                    (§ ass (:keywords ret) (cast' IPersistentMap (.deref Compiler'KEYWORDS)))
                                                    (§ ass (:vars ret) (cast' IPersistentMap (.deref Compiler'VARS)))
                                                    (§ ass (:constants ret) (cast' PersistentVector (.deref Compiler'CONSTANTS)))
                                                    (§ ass (:constantsID ret) (RT'nextID))
                                                    (§ ass (:keywordCallsites ret) (cast' IPersistentVector (.deref Compiler'KEYWORD_CALLSITES)))
                                                    (§ ass (:protocolCallsites ret) (cast' IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES)))
                                                    (§ ass (:varCallsites ret) (cast' IPersistentSet (.deref Compiler'VAR_CALLSITES)))
                                                )
                                                (finally
                                                    (when (.isDeftype ret)
                                                        (Var'popThreadBindings)
                                                    )
                                                    (Var'popThreadBindings)
                                                )
                                            )

                                            (try
                                                (.compile ret, (NewInstanceExpr'slashname superClass), inames, false)
                                                (catch IOException e
                                                    (throw (Util'sneakyThrow e))
                                                )
                                            )
                                            (.getCompiledClass ret)
                                            ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Current host interop uses reflection, which requires pre-existing classes
     ; Work around this by:
     ; Generate a stub class that has the same interfaces and fields as the class we are generating.
     ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
     ; Unmunge the name (using a magic prefix) on any code gen for classes
     ;;
    (defn #_"Class" NewInstanceExpr'compileStub [#_"String" superName, #_"NewInstanceExpr" ret, #_"String[]" interfaceNames, #_"Object" frm]
        (let [#_"ClassWriter" cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" cv cw]
                (.visit cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER), (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret)), nil, superName, interfaceNames)

                ;; instance fields for closed-overs
                (loop-when-recur [#_"ISeq" s (RT'keys (:closes ret))] (some? s) [(.next s)]
                    (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                        (let [#_"int" access (+ Opcodes/ACC_PUBLIC (if (.isVolatile ret, lb) Opcodes/ACC_VOLATILE (if (.isMutable ret, lb) 0 Opcodes/ACC_FINAL)))]
                            (if (some? (.getPrimitiveType lb))
                                (do
                                    (.visitField cv, access, (:name lb), (.getDescriptor (Type/getType (.getPrimitiveType lb))), nil, nil)
                                )
                                (do
                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                    (.visitField cv, access, (:name lb), (.getDescriptor Compiler'OBJECT_TYPE), nil, nil)
                                )
                            )
                        )
                    )
                )

                ;; ctor that takes closed-overs and does nothing
                (let [#_"Method" m (Method. "<init>", Type/VOID_TYPE, (.ctorTypes ret))]
                    (let [#_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, nil, cv)]
                        (.visitCode ctorgen)
                        (.loadThis ctorgen)
                        (.invokeConstructor ctorgen, (Type/getObjectType superName), ObjExpr'voidctor)
                        (.returnValue ctorgen)
                        (.endMethod ctorgen)

                        (when (pos? (:altCtorDrops ret))
                            (let [#_"Type[]" ctorTypes (.ctorTypes ret)]
                                (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) (:altCtorDrops ret)))]
                                    (loop-when-recur [#_"int" i 0] (< i (alength altCtorTypes)) [(inc i)]
                                        (aset altCtorTypes i (aget ctorTypes i))
                                    )
                                    (let [#_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)]
                                        (§ ass ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv))
                                        (.visitCode ctorgen)
                                        (.loadThis ctorgen)
                                        (.loadArgs ctorgen)

                                        (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __meta
                                        (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                        (.invokeConstructor ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret))), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                        (.returnValue ctorgen)
                                        (.endMethod ctorgen)

                                        ;; alt ctor no __hash, __hasheq
                                        (§ ass altCtorTypes (make-array Type (- (alength ctorTypes) 2)))
                                        (loop-when-recur [#_"int" i 0] (< i (alength altCtorTypes)) [(inc i)]
                                            (aset altCtorTypes i (aget ctorTypes i))
                                        )

                                        (§ ass alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes))
                                        (§ ass ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv))
                                        (.visitCode ctorgen)
                                        (.loadThis ctorgen)
                                        (.loadArgs ctorgen)

                                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                        (.invokeConstructor ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret))), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                        (.returnValue ctorgen)
                                        (.endMethod ctorgen)
                                    )
                                )
                            )
                        )
                        ;; end of class
                        (.visitEnd cv)

                        (let [#_"byte[]" bytecode (.toByteArray cw)]
                            (let [#_"DynamicClassLoader" loader (cast' DynamicClassLoader (.deref Compiler'LOADER))]
                                (.defineClass loader, (str Compiler'COMPILE_STUB_PREFIX "." (:name ret)), bytecode, frm)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" interfaces]
        (let [#_"int" icnt (.count interfaces)]
            (let [#_"String[]" inames (when (pos? icnt) (make-array String icnt))]
                (loop-when-recur [#_"int" i 0] (< i icnt) [(inc i)]
                    (aset inames i (NewInstanceExpr'slashname (cast Class (.nth interfaces, i))))
                )
                inames
            )
        )
    )

    (defn #_"String" NewInstanceExpr'slashname [#_"Class" c]
        (.replace (.getName c), \., \/)
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitStatics) [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
        (when (.isDeftype this)
            ;; getBasis()
            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IPersistentVector getBasis()")]
                (let [#_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), meth, nil, nil, cv)]
                    (.emitValue this, (:hintedFields this), gen)
                    (.returnValue gen)
                    (.endMethod gen)

                    (when (and (.isDeftype this) (< (.count (:hintedFields this)) (.count (:fields this))))
                        ;; create(IPersistentMap)
                        (let [#_"String" className (.replace (:name this), \., \/)]
                            (let [#_"int" i 1]
                                (let [#_"int" fieldCount (.count (:hintedFields this))]
                                    (let [#_"MethodVisitor" mv (.visitMethod cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), "create", (str "(Lcloiure/lang/IPersistentMap;)L" className ";"), nil, nil)]
                                        (.visitCode mv)

                                        (loop-when-recur [#_"ISeq" s (RT'seq (:hintedFields this)) i i] (some? s) [(.next s) (inc i)]
                                            (let [#_"String" bName (:name (cast' Symbol (.first s)))]
                                                (let [#_"Class" k (Compiler'tagClass (Compiler'tagOf (.first s)))]
                                                    (.visitVarInsn mv, Opcodes/ALOAD, 0)
                                                    (.visitLdcInsn mv, bName)
                                                    (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                                    (.visitInsn mv, Opcodes/ACONST_NULL)
                                                    (.visitMethodInsn mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                                                    (when (.isPrimitive k)
                                                        (.visitTypeInsn mv, Opcodes/CHECKCAST, (.getInternalName (Type/getType (Compiler'boxClass k))))
                                                    )
                                                    (.visitVarInsn mv, Opcodes/ASTORE, i)
                                                    (.visitVarInsn mv, Opcodes/ALOAD, 0)
                                                    (.visitLdcInsn mv, bName)
                                                    (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                                    (.visitMethodInsn mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                                                    (.visitVarInsn mv, Opcodes/ASTORE, 0)
                                                )
                                            )
                                        )

                                        (.visitTypeInsn mv, Opcodes/NEW, className)
                                        (.visitInsn mv, Opcodes/DUP)

                                        (let [#_"Method" ctor (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))]
                                            (when (pos? (.count (:hintedFields this)))
                                                (loop-when-recur [i 1] (<= i fieldCount) [(inc i)]
                                                    (.visitVarInsn mv, Opcodes/ALOAD, i)
                                                    (let [#_"Class" k (Compiler'tagClass (Compiler'tagOf (.nth (:hintedFields this), (dec i))))]
                                                        (when (.isPrimitive k)
                                                            (let [#_"String" b (.getInternalName (Type/getType (Compiler'boxClass k)))]
                                                                (let [#_"String" p (.getDescriptor (Type/getType k))]
                                                                    (let [#_"String" n (.getName k)]
                                                                        (.visitMethodInsn mv, Opcodes/INVOKEVIRTUAL, b, (str n "Value"), (str "()" p))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )

                                            (.visitInsn mv, Opcodes/ACONST_NULL) ;; __meta
                                            (.visitVarInsn mv, Opcodes/ALOAD, 0) ;; __extmap
                                            (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                                            (.visitInsn mv, Opcodes/ICONST_0) ;; __hash
                                            (.visitInsn mv, Opcodes/ICONST_0) ;; __hasheq
                                            (.visitMethodInsn mv, Opcodes/INVOKESPECIAL, className, "<init>", (.getDescriptor ctor))
                                            (.visitInsn mv, Opcodes/ARETURN)
                                            (.visitMaxs mv, (+ 4 fieldCount), (+ 1 fieldCount))
                                            (.visitEnd mv)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
        (loop-when-recur [#_"ISeq" s (RT'seq (:methods this))] (some? s) [(.next s)]
            (let [#_"ObjMethod" method (cast' ObjMethod (.first s))]
                (.emit method, this, cv)
            )
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" e (.entrySet (:covariants this))]
            (let [#_"java.lang.reflect.Method" m (.get (:mmap this), (.getKey e))]
                (let [#_"Class[]" params (.getParameterTypes m)]
                    (let [#_"Type[]" argTypes (make-array Type (alength params))]
                        (loop-when-recur [#_"int" i 0] (< i (alength params)) [(inc i)]
                            (aset argTypes i (§ unsure Type/getType (aget params i)))
                        )

                        (let [#_"Method" target (Method. (.getName m), (Type/getType (.getReturnType m)), argTypes)]
                            (doseq [#_"Class" retType (.getValue e)]
                                (let [#_"Method" meth (Method. (.getName m), (Type/getType retType), argTypes)]
                                    ;; todo don't hardwire EXCEPTION_TYPES
                                    (let [#_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_BRIDGE), meth, nil, Compiler'EXCEPTION_TYPES, cv)]
                                        (.visitCode gen)
                                        (.loadThis gen)
                                        (.loadArgs gen)
                                        (.invokeInterface gen, (Type/getType (.getDeclaringClass m)), target)
                                        (.returnValue gen)
                                        (.endMethod gen)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" m]
        (RT'vector (.getName m), (RT'seq (.getParameterTypes m)), (.getReturnType m))
    )

    (defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" m, #_"Map" mm]
        (let [#_"IPersistentVector" mk (NewInstanceExpr'msig m) #_"int" mods (.getModifiers m)]
            (when (not (or (.containsKey mm, mk) (not (or (Modifier/isPublic mods) (Modifier/isProtected mods))) (Modifier/isStatic mods) (Modifier/isFinal mods)))
                (.put mm, mk, m)
            )
        )
        nil
    )

    (defn #_"void" NewInstanceExpr'gatherMethods-2m [#_"Class" c, #_"Map" mm]
        (loop-when-recur [c c] (some? c) [(.getSuperclass c)]
            (doseq [#_"java.lang.reflect.Method" m (.getDeclaredMethods c)]
                (NewInstanceExpr'considerMethod m, mm)
            )
            (doseq [#_"java.lang.reflect.Method" m (.getMethods c)]
                (NewInstanceExpr'considerMethod m, mm)
            )
        )
        nil
    )

    (defn #_"Map[]" NewInstanceExpr'gatherMethods-2s [#_"Class" sc, #_"ISeq" interfaces]
        (let [#_"Map" allm (HashMap.)]
            (NewInstanceExpr'gatherMethods-2m sc, allm)
            (loop-when-recur [interfaces interfaces] (some? interfaces) [(.next interfaces)]
                (NewInstanceExpr'gatherMethods-2m (cast Class (.first interfaces)), allm)
            )

            (let [#_"Map<IPersistentVector, java.lang.reflect.Method>" mm (HashMap.)]
                (let [#_"Map<IPersistentVector, Set<Class>>" covariants (HashMap.)]
                    (doseq [#_"Object" o (.entrySet allm)]
                        (let [#_"Map$Entry" e (cast Map$Entry o)]
                            (let [#_"IPersistentVector" mk (cast' IPersistentVector (.getKey e))]
                                (§ ass mk (cast' IPersistentVector (.pop mk)))
                                (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                                    (if (.containsKey mm, mk) ;; covariant return
                                        (do
                                            (let [#_"Set<Class>" cvs (.get covariants, mk)]
                                                (when (nil? cvs)
                                                    (§ ass cvs (HashSet.))
                                                    (.put covariants, mk, cvs)
                                                )
                                                (let [#_"java.lang.reflect.Method" om (.get mm, mk)]
                                                    (if (.isAssignableFrom (.getReturnType om), (.getReturnType m))
                                                        (do
                                                            (.add cvs, (.getReturnType om))
                                                            (.put mm, mk, m)
                                                        )
                                                        (do
                                                            (.add cvs, (.getReturnType m))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (.put mm, mk, m)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (§ new Map[] (object-array [ mm, covariants ]))
                )
            )
        )
    )
)

(class-ns NewInstanceMethod (§ extends ObjMethod)
    (§ def #_"Symbol" NewInstanceMethod'dummyThis (Symbol'intern nil, "dummy_this_dlskjsdfower"))

    (defn- #_"NewInstanceMethod" NewInstanceMethod'init []
        (hash-map
            #_"String" :name nil
            #_"Type[]" :argTypes nil
            #_"Type" :retType nil
            #_"Class" :retClass nil
            #_"Class[]" :exclasses nil

            #_"IPersistentVector" :parms nil
        )
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (merge (ObjMethod'new objx, parent) (NewInstanceMethod'init))
    )

    #_method
    (§ defn #_"int" (§ method numParams) [#_"NewInstanceMethod" this]
        (.count (:argLocals this))
    )

    #_method
    (§ defn #_"String" (§ method getMethodName) [#_"NewInstanceMethod" this]
        (:name this)
    )

    #_method
    (§ defn #_"Type" (§ method getReturnType) [#_"NewInstanceMethod" this]
        (:retType this)
    )

    #_method
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"NewInstanceMethod" this]
        (:argTypes this)
    )

    (defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" name, #_"Class[]" paramTypes]
        (RT'vector name, (RT'seq paramTypes))
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Symbol" thistag, #_"Map" overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" method (NewInstanceMethod'new objx, (cast' ObjMethod (.deref Compiler'METHOD)))]
            (let [#_"Symbol" dotname (cast' Symbol (RT'first form))]
                (let [#_"Symbol" name (cast' Symbol (.withMeta (Symbol'intern nil, (Compiler'munge (:name dotname))), (RT'meta dotname)))]
                    (let [#_"IPersistentVector" parms (cast' IPersistentVector (RT'second form))]
                        (when (zero? (.count parms))
                            (throw (IllegalArgumentException. (str "Must supply at least one argument for 'this' in: " dotname)))
                        )
                        (let [#_"Symbol" thisName (cast' Symbol (.nth parms, 0))]
                            (§ ass parms (RT'subvec parms, 1, (.count parms)))
                            (let [#_"ISeq" body (RT'next (RT'next form))]
                                (try
                                    (§ ass (:line method) (Compiler'lineDeref))
                                    (§ ass (:column method) (Compiler'columnDeref))
                                    ;; register as the current method and set up a new env frame
                                    (let [#_"PathNode" pnode (PathNode'new :PathType'PATH, (cast' PathNode (.get Compiler'CLEAR_PATH)))]
                                        (Var'pushThreadBindings (RT'mapUniqueKeys
                                            (object-array [
                                                Compiler'METHOD                method
                                                Compiler'LOCAL_ENV             (.deref Compiler'LOCAL_ENV)
                                                Compiler'LOOP_LOCALS           nil
                                                Compiler'NEXT_LOCAL_NUM        0
                                                Compiler'CLEAR_PATH            pnode
                                                Compiler'CLEAR_ROOT            pnode
                                                Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                                Compiler'METHOD_RETURN_CONTEXT RT'T
                                            ])
                                        ))

                                        ;; register 'this' as local 0
                                        (if (some? thisName)
                                            (do
                                                (Compiler'registerLocal (or thisName NewInstanceMethod'dummyThis), thistag, nil, false)
                                            )
                                            (do
                                                (Compiler'getAndIncLocalNum)
                                            )
                                        )

                                        (let [#_"PersistentVector" argLocals PersistentVector'EMPTY]
                                            (§ ass (:retClass method) (Compiler'tagClass (Compiler'tagOf name)))
                                            (§ ass (:argTypes method) (make-array Type (.count parms)))
                                            (let [#_"boolean" hinted (some? (Compiler'tagOf name))]
                                                (let [#_"Class[]" pclasses (make-array Class (.count parms))]
                                                    (let [#_"Symbol[]" psyms (make-array #_"Symbol" Object (.count parms))]
                                                        (loop-when-recur [#_"int" i 0] (< i (.count parms)) [(inc i)]
                                                            (when (not (§ instance? Symbol (.nth parms, i)))
                                                                (throw (IllegalArgumentException. "params must be Symbols"))
                                                            )
                                                            (let [#_"Symbol" p (cast' Symbol (.nth parms, i))]
                                                                (let [#_"Object" tag (Compiler'tagOf p)]
                                                                    (when (some? tag)
                                                                        (§ ass hinted true)
                                                                    )
                                                                    (when (some? (.getNamespace p))
                                                                        (§ ass p (Symbol'intern (:name p)))
                                                                    )
                                                                    (let [#_"Class" pclass (Compiler'tagClass tag)]
                                                                        (aset pclasses i pclass)
                                                                        (aset psyms i p)
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (let [#_"Map" matches (NewInstanceMethod'findMethodsWithNameAndArity (:name name), (.count parms), overrideables)]
                                                            (let [#_"Object" mk (NewInstanceMethod'msig (:name name), pclasses)]
                                                                (let [#_"java.lang.reflect.Method" m nil]
                                                                    (if (pos? (.size matches))
                                                                        (do
                                                                            ;; multiple methods
                                                                            (cond (< 1 (.size matches))
                                                                                (do
                                                                                    ;; must be hinted and match one method
                                                                                    (when (not hinted)
                                                                                        (throw (IllegalArgumentException. (str "Must hint overloaded method: " (:name name))))
                                                                                    )
                                                                                    (§ ass m (cast java.lang.reflect.Method (.get matches, mk)))
                                                                                    (when (nil? m)
                                                                                        (throw (IllegalArgumentException. (str "Can't find matching overloaded method: " (:name name))))
                                                                                    )
                                                                                    (when-not (= (.getReturnType m) (:retClass method))
                                                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name name) ", expected: " (.getName (.getReturnType m)) ", had: " (.getName (:retClass method)))))
                                                                                    )
                                                                                )
                                                                                :else ;; one match
                                                                                (do
                                                                                    ;; if hinted, validate match
                                                                                    (cond hinted
                                                                                        (do
                                                                                            (§ ass m (cast java.lang.reflect.Method (.get matches, mk)))
                                                                                            (when (nil? m)
                                                                                                (throw (IllegalArgumentException. (str "Can't find matching method: " (:name name) ", leave off hints for auto match.")))
                                                                                            )
                                                                                            (when-not (= (.getReturnType m) (:retClass method))
                                                                                                (throw (IllegalArgumentException. (str "Mismatched return type: " (:name name) ", expected: " (.getName (.getReturnType m)) ", had: " (.getName (:retClass method)))))
                                                                                            )
                                                                                        )
                                                                                        :else ;; adopt found method sig
                                                                                        (do
                                                                                            (§ ass m (cast java.lang.reflect.Method (.next (.iterator (.values matches)))))
                                                                                            (§ ass (:retClass method) (.getReturnType m))
                                                                                            (§ ass pclasses (.getParameterTypes m))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (do
                                                                            (throw (IllegalArgumentException. (str "Can't define method not in interfaces: " (:name name))))
                                                                        )
                                                                    )

                                                                    ;; validate unque name+arity among additional methods

                                                                    (§ ass (:retType method) (Type/getType (:retClass method)))
                                                                    (§ ass (:exclasses method) (.getExceptionTypes m))

                                                                    (loop-when-recur [#_"int" i 0] (< i (.count parms)) [(inc i)]
                                                                        (let [#_"LocalBinding" lb (Compiler'registerLocal (aget psyms i), nil, (MethodParamExpr'new (aget pclasses i)), true)]
                                                                            (§ ass argLocals (.assocN argLocals, i, lb))
                                                                            (aset (:argTypes method) i (§ unsure Type/getType (aget pclasses i)))
                                                                        )
                                                                    )
                                                                    (loop-when-recur [#_"int" i 0] (< i (.count parms)) [(inc i)]
                                                                        (when (or (= (aget pclasses i) Long/TYPE) (= (aget pclasses i) Double/TYPE))
                                                                            (Compiler'getAndIncLocalNum)
                                                                        )
                                                                    )
                                                                    (.set Compiler'LOOP_LOCALS, argLocals)
                                                                    (§ ass (:name method) (:name name))
                                                                    (§ ass (:methodMeta method) (RT'meta name))
                                                                    (§ ass (:parms method) parms)
                                                                    (§ ass (:argLocals method) argLocals)
                                                                    (§ ass (:body method) (.parse (BodyParser'new), :Context'RETURN, body))
                                                                    method
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (finally
                                        (Var'popThreadBindings)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" name, #_"int" arity, #_"Map" mm]
        (let [#_"Map" ret (HashMap.)]
            (doseq [#_"Object" o (.entrySet mm)]
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                        (when (and (.equals name, (.getName m)) (= (alength (.getParameterTypes m)) arity))
                            (.put ret, (.getKey e), (.getValue e))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" name, #_"Map" mm]
        (let [#_"Map" ret (HashMap.)]
            (doseq [#_"Object" o (.entrySet mm)]
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                        (when (.equals name, (.getName m))
                            (.put ret, (.getKey e), (.getValue e))
                        )
                    )
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NewInstanceMethod" this, #_"ObjExpr" obj, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            (let [#_"Type[]" extypes nil]
                (when (pos? (alength (:exclasses this)))
                    (§ ass extypes (make-array Type (alength (:exclasses this))))
                    (loop-when-recur [#_"int" i 0] (< i (alength (:exclasses this))) [(inc i)]
                        (aset extypes i (§ unsure Type/getType (aget (:exclasses this) i)))
                    )
                )
                (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, extypes, cv)]
                    (.visitCode gen)

                    (let [#_"Label" loopLabel (.mark gen)]
                        (.visitLineNumber gen, (:line this), loopLabel)
                        (try
                            (Var'pushThreadBindings (RT'map Compiler'LOOP_LABEL, loopLabel, Compiler'METHOD, this))

                            (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))
                            (let [#_"Label" end (.mark gen)]
                                (.visitLocalVariable gen, "this", (.getDescriptor (:objtype obj)), nil, loopLabel, end, 0)
                                (loop-when-recur [#_"ISeq" lbs (.seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                    (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                        (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argTypes this) (dec (:idx lb)))), nil, loopLabel, end, (:idx lb))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue gen)
                        (.endMethod gen)
                    )
                )
            )
        )
        nil
    )
)

(class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"MethodParamExpr" MethodParamExpr'init []
        (hash-map
            #_"Class" :c nil
        )
    )

    (defn #_"MethodParamExpr" MethodParamExpr'new [#_"Class" c]
        (let [this (MethodParamExpr'init)]
            (§ ass this (assoc this :c c))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MethodParamExpr" this]
        (throw (RuntimeException. "Can't eval"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MethodParamExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (throw (RuntimeException. "Can't emit"))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MethodParamExpr" this]
        (some? (:c this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MethodParamExpr" this]
        (:c this)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"MethodParamExpr" this]
        (Util'isPrimitive (:c this))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"MethodParamExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (throw (RuntimeException. "Can't emit"))
    )
)

#_closure
(class-ns CaseParser (§ implements IParser)
    (defn #_"CaseParser" CaseParser'new []
        (hash-map)
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    ;; prepared by case macro and presumed correct
    ;; case macro binds actual expr in let so expr is always a local,
    ;; no need to worry about multiple evaluation
    #_method
    (§ defn #_"Expr" (§ method parse) [#_"CaseParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            (if (= context :Context'EVAL)
                (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                (let [#_"IPersistentVector" args (LazilyPersistentVector'create (.next form))
                      #_"Object" exprForm (.nth args, 0)
                      #_"int" shift (.intValue (cast Number (.nth args, 1)))
                      #_"int" mask (.intValue (cast Number (.nth args, 2)))
                      #_"Object" defaultForm (.nth args, 3)
                      #_"Map" caseMap (cast Map (.nth args, 4))
                      #_"Keyword" switchType (cast' Keyword (.nth args, 5))
                      #_"Keyword" testType (cast' Keyword (.nth args, 6))
                      #_"Set" skipCheck (when (< 7 (RT'count args)) (cast Set (.nth args, 7)))
                      #_"ISeq" keys (RT'keys caseMap)
                      #_"int" low (.intValue (cast Number (RT'first keys)))
                      #_"int" high (.intValue (cast Number (RT'nth-2 keys, (dec (RT'count keys)))))
                      #_"LocalBindingExpr" testexpr (cast' LocalBindingExpr (Compiler'analyze-2 :Context'EXPRESSION, exprForm))
                      _ (§ ass (:shouldClear testexpr) false)
                      #_"SortedMap<Integer, Expr>" tests (TreeMap.)
                      #_"HashMap<Integer, Expr>" thens (HashMap.)
                      #_"PathNode" branch (PathNode'new :PathType'BRANCH, (cast' PathNode (.get Compiler'CLEAR_PATH)))
                      _ (doseq [#_"Object" o (.entrySet caseMap)]
                            (let [#_"Map$Entry" e (cast Map$Entry o)
                                  #_"Integer" minhash (.intValue (cast Number (.getKey e)))
                                  #_"Object" pair (.getValue e) ;; [test-val then-expr]
                                  #_"Expr" testExpr
                                    (if (= testType CaseExpr'intKey)
                                        (NumberExpr'parse (.intValue (cast Number (RT'first pair))))
                                        (ConstantExpr'new (RT'first pair))
                                    )]
                                (.put tests, minhash, testExpr)
                                (let [#_"Expr" thenExpr
                                        (try
                                            (Var'pushThreadBindings (RT'map Compiler'CLEAR_PATH, (PathNode'new :PathType'PATH, branch)))
                                            (Compiler'analyze-2 context, (RT'second pair))
                                            (finally
                                                (Var'popThreadBindings)
                                            )
                                        )]
                                    (.put thens, minhash, thenExpr)
                                )
                            )
                        )
                      #_"Expr" defaultExpr
                        (try
                            (Var'pushThreadBindings (RT'map Compiler'CLEAR_PATH, (PathNode'new :PathType'PATH, branch)))
                            (Compiler'analyze-2 context, (.nth args, 3))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                      #_"int" line (.intValue (cast Number (.deref Compiler'LINE)))
                      #_"int" column (.intValue (cast Number (.deref Compiler'COLUMN)))]
                    (CaseExpr'new line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck)
                )
            )
        )
    )
)

(class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
    (def #_"Type" CaseExpr'NUMBER_TYPE (Type/getType Number))
    (def #_"Method" CaseExpr'intValueMethod (Method/getMethod "int intValue()"))

    (def #_"Method" CaseExpr'hashMethod (Method/getMethod "int hash(Object)"))
    (def #_"Method" CaseExpr'hashCodeMethod (Method/getMethod "int hashCode()"))
    (def #_"Method" CaseExpr'equivMethod (Method/getMethod "boolean equiv(Object, Object)"))
    (§ def #_"Keyword" CaseExpr'compactKey (Keyword'intern (Symbol'intern nil, "compact")))
    (§ def #_"Keyword" CaseExpr'sparseKey (Keyword'intern (Symbol'intern nil, "sparse")))
    (§ def #_"Keyword" CaseExpr'hashIdentityKey (Keyword'intern (Symbol'intern nil, "hash-identity")))
    (§ def #_"Keyword" CaseExpr'hashEquivKey (Keyword'intern (Symbol'intern nil, "hash-equiv")))
    (§ def #_"Keyword" CaseExpr'intKey (Keyword'intern (Symbol'intern nil, "int")))

    (defn- #_"CaseExpr" CaseExpr'init []
        (hash-map
            #_"LocalBindingExpr" :expr nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"int" :low 0
            #_"int" :high 0
            #_"Expr" :defaultExpr nil
            #_"SortedMap<Integer, Expr>" :tests nil
            #_"HashMap<Integer, Expr>" :thens nil
            #_"Keyword" :switchType nil
            #_"Keyword" :testType nil
            #_"Set<Integer>" :skipCheck nil
            #_"Class" :returnType nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (defn #_"CaseExpr" CaseExpr'new [#_"int" line, #_"int" column, #_"LocalBindingExpr" expr, #_"int" shift, #_"int" mask, #_"int" low, #_"int" high, #_"Expr" defaultExpr, #_"SortedMap<Integer, Expr>" tests, #_"HashMap<Integer, Expr>" thens, #_"Keyword" switchType, #_"Keyword" testType, #_"Set<Integer>" skipCheck]
        (let [this (CaseExpr'init)]
            (§ ass this (assoc this :expr expr))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :mask mask))
            (§ ass this (assoc this :low low))
            (§ ass this (assoc this :high high))
            (§ ass this (assoc this :defaultExpr defaultExpr))
            (§ ass this (assoc this :tests tests))
            (§ ass this (assoc this :thens thens))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (when (and (not= switchType CaseExpr'compactKey) (not= switchType CaseExpr'sparseKey))
                (throw (IllegalArgumentException. (str "Unexpected switch type: " switchType)))
            )
            (§ ass this (assoc this :switchType switchType))
            (when (and (not= testType CaseExpr'intKey) (not= testType CaseExpr'hashEquivKey) (not= testType CaseExpr'hashIdentityKey))
                (throw (IllegalArgumentException. (str "Unexpected test type: " switchType)))
            )
            (§ ass this (assoc this :testType testType))
            (§ ass this (assoc this :skipCheck skipCheck))
            (let [#_"Collection<Expr>" returns (ArrayList. (.values thens))]
                (.add returns, defaultExpr)
                (§ ass this (assoc this :returnType (Compiler'maybeJavaClass returns)))
                (when (and (pos? (RT'count skipCheck)) (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION)))
                    (.format (RT'errPrintWriter), "Performance warning, %d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", (object-array [ line, column ]))
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"CaseExpr" this]
        (some? (:returnType this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"CaseExpr" this]
        (Util'isPrimitive (:returnType this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"CaseExpr" this]
        (:returnType this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.doEmit this, context, objx, gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"Label" defaultLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)
              #_"SortedMap<Integer, Label>" labels (TreeMap.) _ (doseq [#_"Integer" i (.keySet (:tests this))] (.put labels, i, (.newLabel gen)))]

            (.visitLineNumber gen, (:line this), (.mark gen))

            (let [#_"Class" primExprClass (Compiler'maybePrimitiveType (:expr this))
                  #_"Type" primExprType (when (some? primExprClass) (Type/getType primExprClass))]
                (if (= (:testType this) CaseExpr'intKey)
                    (.emitExprForInts this, objx, gen, primExprType, defaultLabel)
                    (.emitExprForHashes this, objx, gen)
                )

                (if (= (:switchType this) CaseExpr'sparseKey)
                    (let [#_"Label[]" la (make-array Label (.size labels))]
                        (§ ass la (.toArray (.values labels), la))
                        (let [#_"int[]" ints (Numbers'int_array-1 (.keySet (:tests this)))]
                            (.visitLookupSwitchInsn gen, defaultLabel, ints, la)
                        )
                    )
                    (let [#_"Label[]" la (make-array Label (inc (- (:high this) (:low this))))]
                        (loop-when-recur [#_"int" i (:low this)] (<= i (:high this)) [(inc i)]
                            (aset la (- i (:low this)) (if (.containsKey labels, i) (.get labels, i) defaultLabel))
                        )
                        (.visitTableSwitchInsn gen, (:low this), (:high this), defaultLabel, la)
                    )
                )

                (doseq [#_"Integer" i (.keySet labels)]
                    (.mark gen, (.get labels, i))
                    (cond
                        (= (:testType this) CaseExpr'intKey)
                            (.emitThenForInts this, objx, gen, primExprType, (.get (:tests this), i), (.get (:thens this), i), defaultLabel, emitUnboxed)
                        (= (RT'contains (:skipCheck this), i) RT'T)
                            (CaseExpr'emitExpr objx, gen, (.get (:thens this), i), emitUnboxed)
                        :else
                            (.emitThenForHashes this, objx, gen, (.get (:tests this), i), (.get (:thens this), i), defaultLabel, emitUnboxed)
                    )
                    (.goTo gen, endLabel)
                )

                (.mark gen, defaultLabel)
                (CaseExpr'emitExpr objx, gen, (:defaultExpr this), emitUnboxed)
                (.mark gen, endLabel)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"boolean" (§ method isShiftMasked) [#_"CaseExpr" this]
        (not= (:mask this) 0)
    )

    #_method
    (§ defn- #_"void" (§ method emitShiftMask) [#_"CaseExpr" this, #_"GeneratorAdapter" gen]
        (when (.isShiftMasked this)
            (.push gen, (:shift this))
            (.visitInsn gen, Opcodes/ISHR)
            (.push gen, (:mask this))
            (.visitInsn gen, Opcodes/IAND)
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitExprForInts) [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Label" defaultLabel]
        (cond (nil? exprType)
            (do
                (when (RT'booleanCast-1o (.deref RT'WARN_ON_REFLECTION))
                    (.format (RT'errPrintWriter), "Performance warning, %d:%d - case has int tests, but tested expression is not primitive.\n", (object-array [ (:line this), (:column this) ]))
                )
                (.emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.instanceOf gen, CaseExpr'NUMBER_TYPE)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
                (.emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, CaseExpr'NUMBER_TYPE)
                (.invokeVirtual gen, CaseExpr'NUMBER_TYPE, HostExpr'intValueMethod)
                (.emitShiftMask this, gen)
            )
            (or (= exprType Type/LONG_TYPE) (= exprType Type/INT_TYPE) (= exprType Type/SHORT_TYPE) (= exprType Type/BYTE_TYPE))
            (do
                (.emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                (.cast gen, exprType, Type/INT_TYPE)
                (.emitShiftMask this, gen)
            )
            :else
            (do
                (.goTo gen, defaultLabel)
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitThenForInts) [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
        (cond (nil? exprType)
            (do
                (.emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.emit test, :Context'EXPRESSION, objx, gen)
                (.invokeStatic gen, Compiler'UTIL_TYPE, equivMethod)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            (= exprType Type/LONG_TYPE)
            (do
                (.emitUnboxed (cast' NumberExpr test), :Context'EXPRESSION, objx, gen)
                (.emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                (.ifCmp gen, Type/LONG_TYPE, GeneratorAdapter/NE, defaultLabel)
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            (or (= exprType Type/INT_TYPE) (= exprType Type/SHORT_TYPE) (= exprType Type/BYTE_TYPE))
            (do
                (when (.isShiftMasked this)
                    (.emitUnboxed (cast' NumberExpr test), :Context'EXPRESSION, objx, gen)
                    (.emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                    (.cast gen, exprType, Type/LONG_TYPE)
                    (.ifCmp gen, Type/LONG_TYPE, GeneratorAdapter/NE, defaultLabel)
                )
                ;; else direct match
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            :else
            (do
                (.goTo gen, defaultLabel)
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitExprForHashes) [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.invokeStatic gen, Compiler'UTIL_TYPE, hashMethod)
        (.emitShiftMask this, gen)
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitThenForHashes) [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
        (.emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.emit test, :Context'EXPRESSION, objx, gen)
        (if (= (:testType this) CaseExpr'hashIdentityKey)
            (do
                (.visitJumpInsn gen, Opcodes/IF_ACMPNE, defaultLabel)
            )
            (do
                (.invokeStatic gen, Compiler'UTIL_TYPE, equivMethod)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
            )
        )
        (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
        nil
    )

    (defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" expr, #_"boolean" emitUnboxed]
        (if (and emitUnboxed (§ instance? MaybePrimitiveExpr expr))
            (.emitUnboxed (cast' MaybePrimitiveExpr expr), :Context'EXPRESSION, objx, gen)
            (.emit expr, :Context'EXPRESSION, objx, gen)
        )
        nil
    )
)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" Compiler'DEF (Symbol'intern "def"))
    (§ def #_"Symbol" Compiler'LOOP (Symbol'intern "loop*"))
    (§ def #_"Symbol" Compiler'RECUR (Symbol'intern "recur"))
    (§ def #_"Symbol" Compiler'IF (Symbol'intern "if"))
    (§ def #_"Symbol" Compiler'LET (Symbol'intern "let*"))
    (§ def #_"Symbol" Compiler'LETFN (Symbol'intern "letfn*"))
    (§ def #_"Symbol" Compiler'DO (Symbol'intern "do"))
    (§ def #_"Symbol" Compiler'FN (Symbol'intern "fn*"))
    (§ def #_"Symbol" Compiler'FNONCE (cast' Symbol (.withMeta (Symbol'intern "fn*"), (RT'map (Keyword'intern (Symbol'intern nil, "once")), RT'T))))
    (§ def #_"Symbol" Compiler'QUOTE (Symbol'intern "quote"))
    (§ def #_"Symbol" Compiler'THE_VAR (Symbol'intern "var"))
    (§ def #_"Symbol" Compiler'DOT (Symbol'intern "."))
    (§ def #_"Symbol" Compiler'ASSIGN (Symbol'intern "set!"))
    (§ def #_"Symbol" Compiler'TRY (Symbol'intern "try"))
    (§ def #_"Symbol" Compiler'CATCH (Symbol'intern "catch"))
    (§ def #_"Symbol" Compiler'FINALLY (Symbol'intern "finally"))
    (§ def #_"Symbol" Compiler'THROW (Symbol'intern "throw"))
    (§ def #_"Symbol" Compiler'MONITOR_ENTER (Symbol'intern "monitor-enter"))
    (§ def #_"Symbol" Compiler'MONITOR_EXIT (Symbol'intern "monitor-exit"))
    (§ def #_"Symbol" Compiler'IMPORT (Symbol'intern "cloiure.core", "import*"))
    (§ def #_"Symbol" Compiler'DEFTYPE (Symbol'intern "deftype*"))
    (§ def #_"Symbol" Compiler'CASE (Symbol'intern "case*"))

    (§ def #_"Symbol" Compiler'CLASS (Symbol'intern "Class"))
    (§ def #_"Symbol" Compiler'NEW (Symbol'intern "new"))
    (§ def #_"Symbol" Compiler'THIS (Symbol'intern "this"))
    (§ def #_"Symbol" Compiler'REIFY (Symbol'intern "reify*"))
    (§ def #_"Symbol" Compiler'LIST (Symbol'intern "cloiure.core", "list"))
    (§ def #_"Symbol" Compiler'HASHMAP (Symbol'intern "cloiure.core", "hash-map"))
    (§ def #_"Symbol" Compiler'VECTOR (Symbol'intern "cloiure.core", "vector"))
    (§ def #_"Symbol" Compiler'IDENTITY (Symbol'intern "cloiure.core", "identity"))

    (§ def #_"Symbol" Compiler'_AMP_ (Symbol'intern "&"))
    (§ def #_"Symbol" Compiler'ISEQ (Symbol'intern "cloiure.lang.ISeq"))

    (§ def #_"Keyword" Compiler'loadNs (Keyword'intern (Symbol'intern nil, "load-ns")))
    (§ def #_"Keyword" Compiler'inlineKey (Keyword'intern (Symbol'intern nil, "inline")))
    (§ def #_"Keyword" Compiler'inlineAritiesKey (Keyword'intern (Symbol'intern nil, "inline-arities")))

    (§ def #_"Keyword" Compiler'volatileKey (Keyword'intern (Symbol'intern nil, "volatile")))
    (§ def #_"Keyword" Compiler'implementsKey (Keyword'intern (Symbol'intern nil, "implements")))
    (def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" Compiler'protocolKey (Keyword'intern (Symbol'intern nil, "protocol")))
    (§ def #_"Keyword" Compiler'onKey (Keyword'intern (Symbol'intern nil, "on")))
    (§ def #_"Keyword" Compiler'dynamicKey (Keyword'intern (Symbol'intern "dynamic")))
    (§ def #_"Keyword" Compiler'redefKey (Keyword'intern (Symbol'intern nil, "redef")))

    (§ def #_"Symbol" Compiler'NS (Symbol'intern "ns"))
    (§ def #_"Symbol" Compiler'IN_NS (Symbol'intern "in-ns"))

    (§ def #_"IPersistentMap" Compiler'specials (PersistentHashMap'create-1a
        (object-array [
            Compiler'DEF           (DefParser'new)
            Compiler'LOOP          (LetParser'new)
            Compiler'RECUR         (RecurParser'new)
            Compiler'IF            (IfParser'new)
            Compiler'CASE          (CaseParser'new)
            Compiler'LET           (LetParser'new)
            Compiler'LETFN         (LetFnParser'new)
            Compiler'DO            (BodyParser'new)
            Compiler'FN            nil
            Compiler'QUOTE         (ConstantParser'new)
            Compiler'THE_VAR       (TheVarParser'new)
            Compiler'IMPORT        (ImportParser'new)
            Compiler'DOT           (HostParser'new)
            Compiler'ASSIGN        (AssignParser'new)
            Compiler'DEFTYPE       (DeftypeParser'new)
            Compiler'REIFY         (ReifyParser'new)
            Compiler'TRY           (TryParser'new)
            Compiler'THROW         (ThrowParser'new)
            Compiler'MONITOR_ENTER (MonitorEnterParser'new)
            Compiler'MONITOR_EXIT  (MonitorExitParser'new)
            Compiler'CATCH         nil
            Compiler'FINALLY       nil
            Compiler'NEW           (NewParser'new)
            Compiler'_AMP_         nil
        ])
    ))

    (def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)

    (def #_"Type" Compiler'CLASS_TYPE (Type/getType Class))
    (def #_"Type" Compiler'OBJECT_TYPE (Type/getType Object))
    (def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (Type/getType Boolean))
    (def #_"Type" Compiler'THROWABLE_TYPE (Type/getType Throwable))

    (def- #_"Type" Compiler'KEYWORD_TYPE (§ unsure Type/getType (§ class Keyword)))
    (def- #_"Type" Compiler'VAR_TYPE (§ unsure Type/getType (§ class Var)))
    (def- #_"Type" Compiler'SYMBOL_TYPE (§ unsure Type/getType (§ class Symbol)))
    (def- #_"Type" Compiler'IFN_TYPE (§ unsure Type/getType (§ class IFn)))
    (def- #_"Type" Compiler'AFUNCTION_TYPE (§ unsure Type/getType (§ class AFunction)))
    (def- #_"Type" Compiler'RT_TYPE (§ unsure Type/getType (§ class RT)))
    (def- #_"Type" Compiler'NUMBERS_TYPE (§ unsure Type/getType (§ class Numbers)))

    (def #_"Type" Compiler'NS_TYPE (§ unsure Type/getType (§ class Namespace)))
    (def #_"Type" Compiler'UTIL_TYPE (§ unsure Type/getType (§ class Util)))
    (def #_"Type" Compiler'REFLECTOR_TYPE (§ unsure Type/getType (§ class Reflector)))
    (def #_"Type" Compiler'IPERSISTENTMAP_TYPE (§ unsure Type/getType (§ class IPersistentMap)))
    (def #_"Type" Compiler'IOBJ_TYPE (§ unsure Type/getType (§ class IObj)))
    (def #_"Type" Compiler'TUPLE_TYPE (§ unsure Type/getType (§ class Tuple)))

    (def #_"Method[]" Compiler'createTupleMethods
        (object-array [
            (Method/getMethod "cloiure.lang.IPersistentVector create()")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object, Object)")
        ])
    )

    (def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (def- #_"Type[]" Compiler'EXCEPTION_TYPES (object-array 0))

    (§ static
        (§ ass Compiler'ARG_TYPES (§ new Type[(+ Compiler'MAX_POSITIONAL_ARITY 2)][]))
        (loop-when-recur [#_"int" i 0] (<= i Compiler'MAX_POSITIONAL_ARITY) [(inc i)]
            (let [#_"Type[]" a (make-array Type i)]
                (loop-when-recur [#_"int" j 0] (< j i) [(inc j)]
                    (aset a j Compiler'OBJECT_TYPE)
                )
                (aset Compiler'ARG_TYPES i a)
            )
        )
        (let [#_"Type[]" a (make-array Type (inc Compiler'MAX_POSITIONAL_ARITY))]
            (loop-when-recur [#_"int" j 0] (< j Compiler'MAX_POSITIONAL_ARITY) [(inc j)]
                (aset a j Compiler'OBJECT_TYPE)
            )
            (aset a Compiler'MAX_POSITIONAL_ARITY (Type/getType "[Ljava/lang/Object;"))
            (aset Compiler'ARG_TYPES (inc Compiler'MAX_POSITIONAL_ARITY) a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" Compiler'LOCAL_ENV (.setDynamic (Var'create nil)))

    ;; vector<localbinding>
    (§ def #_"Var" Compiler'LOOP_LOCALS (.setDynamic (Var'create)))

    ;; Label
    (§ def #_"Var" Compiler'LOOP_LABEL (.setDynamic (Var'create)))

    ;; vector<object>
    (§ def #_"Var" Compiler'CONSTANTS (.setDynamic (Var'create)))

    ;; IdentityHashMap
    (§ def #_"Var" Compiler'CONSTANT_IDS (.setDynamic (Var'create)))

    ;; vector<keyword>
    (§ def #_"Var" Compiler'KEYWORD_CALLSITES (.setDynamic (Var'create)))

    ;; vector<var>
    (§ def #_"Var" Compiler'PROTOCOL_CALLSITES (.setDynamic (Var'create)))

    ;; set<var>
    (§ def #_"Var" Compiler'VAR_CALLSITES (.setDynamic (Var'create)))

    ;; keyword->constid
    (§ def #_"Var" Compiler'KEYWORDS (.setDynamic (Var'create)))

    ;; var->constid
    (§ def #_"Var" Compiler'VARS (.setDynamic (Var'create)))

    ;; FnFrame
    (§ def #_"Var" Compiler'METHOD (.setDynamic (Var'create nil)))

    ;; nil or not
    (§ def #_"Var" Compiler'IN_CATCH_FINALLY (.setDynamic (Var'create nil)))

    (§ def #_"Var" Compiler'METHOD_RETURN_CONTEXT (.setDynamic (Var'create nil)))

    (§ def #_"Var" Compiler'NO_RECUR (.setDynamic (Var'create nil)))

    ;; DynamicClassLoader
    (§ def #_"Var" Compiler'LOADER (.setDynamic (Var'create)))

    (§ def #_"Var" Compiler'INSTANCE (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "instance?")))

    ;; Integer
    (§ def #_"Var" Compiler'LINE (.setDynamic (Var'create 0)))
    (§ def #_"Var" Compiler'COLUMN (.setDynamic (Var'create 0)))

    (defn #_"int" Compiler'lineDeref []
        (.intValue (cast Number (.deref Compiler'LINE)))
    )

    (defn #_"int" Compiler'columnDeref []
        (.intValue (cast Number (.deref Compiler'COLUMN)))
    )

    ;; Integer
    (§ def #_"Var" Compiler'NEXT_LOCAL_NUM (.setDynamic (Var'create 0)))

    ;; Integer
    (§ def #_"Var" Compiler'RET_LOCAL_NUM (.setDynamic (Var'create)))

    (§ def #_"Var" Compiler'COMPILE_STUB_SYM (.setDynamic (Var'create nil)))
    (§ def #_"Var" Compiler'COMPILE_STUB_CLASS (.setDynamic (Var'create nil)))

    ;; PathNode chain
    (§ def #_"Var" Compiler'CLEAR_PATH (.setDynamic (Var'create nil)))

    ;; tail of PathNode chain
    (§ def #_"Var" Compiler'CLEAR_ROOT (.setDynamic (Var'create nil)))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" Compiler'CLEAR_SITES (.setDynamic (Var'create nil)))

    (def #_"Class" Compiler'RECUR_CLASS (§ class Recur))

    (defn #_"boolean" Compiler'isSpecial [#_"Object" sym]
        (.containsKey Compiler'specials, sym)
    )

    (defn #_"boolean" Compiler'inTailCall [#_"Context" context]
        (and (= context :Context'RETURN) (some? (.deref Compiler'METHOD_RETURN_CONTEXT)) (nil? (.deref Compiler'IN_CATCH_FINALLY)))
    )

    (defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" sym]
        ;; already qualified or classname?
        (cond
            (pos? (.indexOf (:name sym), \.))
                sym
            (some? (:ns sym))
                (let [#_"Namespace" ns (Compiler'namespaceFor-1 sym)]
                    (if (and (some? ns) (not (and (some? (:name (:name ns))) (.equals (:name (:name ns)), (:ns sym)))))
                        (Symbol'intern (:name (:name ns)), (:name sym))
                        sym
                    )
                )
            :else
                (let [#_"Object" o (.getMapping (Compiler'currentNS), sym)]
                    (cond
                        (nil? o)            (Symbol'intern (:name (:name (Compiler'currentNS))), (:name sym))
                        (instance? Class o) (Symbol'intern nil, (.getName (cast Class o)))
                        (§ instance? Var o) (let [#_"Var" v (cast' Var o)] (Symbol'intern (:name (:name (:ns v))), (:name (:sym v))))
                    )
                )
        )
    )

    (defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" e]
        (when (and (§ instance? MaybePrimitiveExpr e) (.hasJavaClass e) (.canEmitPrimitive (cast' MaybePrimitiveExpr e)))
            (let [#_"Class" c (.getJavaClass e)]
                (when (Util'isPrimitive c)
                    c
                )
            )
        )
    )

    (defn #_"Class" Compiler'maybeJavaClass [#_"Collection<Expr>" exprs]
        (try
            (let [#_"Class" match nil]
                (doseq [#_"Expr" e exprs]
                    (when-not (§ instance? ThrowExpr e)
                        (if (.hasJavaClass e)
                            (let [#_"Class" c (.getJavaClass e)]
                                (cond
                                    (nil? match)
                                        (§ ass match c)
                                    (not= match c)
                                        (§ return nil)
                                )
                            )
                            (§ return nil)
                        )
                    )
                )
                match
            )
            (catch Exception e
                nil
            )
        )
    )

    (§ def #_"NilExpr" Compiler'NIL_EXPR (NilExpr'new))

    (§ def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr'new true))
    (§ def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr'new false))

    (defn #_"boolean" Compiler'subsumes [#_"Class[]" c1, #_"Class[]" c2]
        ;; presumes matching lengths
        (loop-when [#_"boolean" better false #_"int" i 0] (< i (alength c1)) => better
            (when-not (= (aget c1 i) (aget c2 i)) => (recur better (inc i))
                (and (or (and (not (.isPrimitive (aget c1 i))) (.isPrimitive (aget c2 i))) (.isAssignableFrom (aget c2 i), (aget c1 i)))
                    (recur true (inc i))
                )
            )
        )
    )

    (defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (loop-when-recur [#_"int" i 0] (< i (.count args)) [(inc i)]
                (let [#_"Expr" arg (cast' Expr (.nth args, i))]
                    (when (pos? i)
                        (.append sb, ", ")
                    )
                    (.append sb, (if (and (.hasJavaClass arg) (some? (.getJavaClass arg))) (.getName (.getJavaClass arg)) "unknown"))
                )
            )
            (.toString sb)
        )
    )

    (defn #_"int" Compiler'getMatchingParams [#_"String" methodName, #_"ArrayList<Class[]>" paramlists, #_"IPersistentVector" argexprs, #_"List<Class>" rets]
        ;; presumes matching lengths
        (let [#_"int" matchIdx -1]
            (let [#_"boolean" tied false]
                (let [#_"boolean" foundExact false]
                    (loop-when-recur [#_"int" i 0] (< i (.size paramlists)) [(inc i)]
                        (let [#_"boolean" match true]
                            (let [#_"ISeq" aseq (.seq argexprs)]
                                (let [#_"int" exact 0]
                                    (loop-when-recur [#_"int" p 0 aseq aseq] (and match (< p (.count argexprs)) (some? aseq)) [(inc p) (.next aseq)]
                                        (let [#_"Expr" arg (cast' Expr (.first aseq))]
                                            (let [#_"Class" aclass (if (.hasJavaClass arg) (.getJavaClass arg) Object)]
                                                (let [#_"Class" pclass (aget (.get paramlists, i) p)]
                                                    (if (and (.hasJavaClass arg) (= aclass pclass))
                                                        (§ ass exact (inc exact))
                                                        (§ ass match (Reflector'paramArgTypeMatch pclass, aclass))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (= exact (.count argexprs))
                                        (do
                                            (when (or (not foundExact) (= matchIdx -1) (.isAssignableFrom (.get rets, matchIdx), (.get rets, i)))
                                                (§ ass matchIdx i)
                                            )
                                            (§ ass tied false)
                                            (§ ass foundExact true)
                                        )
                                        (and match (not foundExact))
                                        (do
                                            (if (= matchIdx -1)
                                                (do
                                                    (§ ass matchIdx i)
                                                )
                                                (do
                                                    (cond (Compiler'subsumes (.get paramlists, i), (.get paramlists, matchIdx))
                                                        (do
                                                            (§ ass matchIdx i)
                                                            (§ ass tied false)
                                                        )
                                                        (Arrays/equals (.get paramlists, matchIdx), (.get paramlists, i))
                                                        (do
                                                            (when (.isAssignableFrom (.get rets, matchIdx), (.get rets, i))
                                                                (§ ass matchIdx i)
                                                            )
                                                        )
                                                        (not (Compiler'subsumes (.get paramlists, matchIdx), (.get paramlists, i)))
                                                        (do
                                                            (§ ass tied true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when tied
                        (throw (IllegalArgumentException. (str "More than one matching method found: " methodName)))
                    )
                    matchIdx
                )
            )
        )
    )

    (§ def #_"IPersistentMap" Compiler'CHAR_MAP (PersistentHashMap'create-1a
        (object-array [
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        ])
    ))

    (def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" m (RT'map "$", \/)]
            (loop-when-recur [#_"ISeq" s (RT'seq Compiler'CHAR_MAP)] (some? s) [(.next s)]
                (let [#_"IMapEntry" e (cast' IMapEntry (.first s))]
                    (let [#_"Character" origCh (cast Character (.key e))]
                        (let [#_"String" escapeStr (cast String (.val e))]
                            (§ ass m (.assoc m, escapeStr, origCh))
                        )
                    )
                )
            )
            (§ ass Compiler'DEMUNGE_MAP m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired. Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" mungeStrs (RT'toArray (RT'keys m))]
                (Arrays/sort mungeStrs,
                    (§ reify Comparator()
                        #_method
                        (§ defn #_"int" (§ method compare) [#_"Comparator" this, #_"Object" s1, #_"Object" s2]
                            (- (.length (cast String s2)) (.length (cast String s1)))
                        )
                    )
                )
                (let [#_"StringBuilder" sb (StringBuilder.)]
                    (let [#_"boolean" first true]
                        (doseq [#_"Object" s mungeStrs]
                            (let [#_"String" escapeStr (cast String s)]
                                (when (not first)
                                    (.append sb, "|")
                                )
                                (§ ass first false)
                                (.append sb, "\\Q")
                                (.append sb, escapeStr)
                                (.append sb, "\\E")
                            )
                        )
                        (§ ass Compiler'DEMUNGE_PATTERN (Pattern/compile (.toString sb)))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'munge [#_"String" name]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (doseq [#_"char" c (.toCharArray name)]
                (let [#_"String" sub (cast String (.valAt Compiler'CHAR_MAP, c))]
                    (if (some? sub)
                        (do
                            (.append sb, sub)
                        )
                        (do
                            (.append sb, c)
                        )
                    )
                )
            )
            (.toString sb)
        )
    )

    (defn #_"String" Compiler'demunge [#_"String" mungedName]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (let [#_"Matcher" m (.matcher Compiler'DEMUNGE_PATTERN, mungedName)]
                (let [#_"int" lastMatchEnd 0]
                    (while (.find m)
                        (let [#_"int" start (.start m)]
                            (let [#_"int" end (.end m)]
                                ;; Keep everything before the match
                                (.append sb, (.substring mungedName, lastMatchEnd, start))
                                (§ ass lastMatchEnd end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" origCh (cast Character (.valAt Compiler'DEMUNGE_MAP, (.group m)))]
                                    (.append sb, origCh)
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (.append sb, (.substring mungedName, lastMatchEnd))
                    (.toString sb)
                )
            )
        )
    )

    (defn #_"PathNode" Compiler'clearPathRoot []
        (cast' PathNode (.get Compiler'CLEAR_ROOT))
    )

    (defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg]
        (let [#_"int" num (Compiler'getAndIncLocalNum)]
            (let [#_"LocalBinding" b (LocalBinding'new num, sym, tag, init, isArg, (Compiler'clearPathRoot))]
                (let [#_"IPersistentMap" localsMap (cast' IPersistentMap (.deref Compiler'LOCAL_ENV))]
                    (.set Compiler'LOCAL_ENV, (RT'assoc localsMap, (:sym b), b))
                    (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                        (§ ass (:locals method) (cast' IPersistentMap (RT'assoc (:locals method), b, b)))
                        (§ ass (:indexlocals method) (cast' IPersistentMap (RT'assoc (:indexlocals method), num, b)))
                        b
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" num (.intValue (cast Number (.deref Compiler'NEXT_LOCAL_NUM)))]
            (let [#_"ObjMethod" m (cast' ObjMethod (.deref Compiler'METHOD))]
                (when (< (:maxLocal m) num)
                    (§ ass (:maxLocal m) num)
                )
                (.set Compiler'NEXT_LOCAL_NUM, (inc num))
                num
            )
        )
    )

    (defn #_"Expr" Compiler'analyze-2 [#_"Context" context, #_"Object" form]
        (Compiler'analyze-3 context, form, nil)
    )

    (defn- #_"Expr" Compiler'analyze-3 [#_"Context" context, #_"Object" form, #_"String" name]
        ;; todo symbol macro expansion?
        (try
            (let [form
                    (when (§ instance? LazySeq form) => form
                        (.withMeta (cast' IObj (or (RT'seq form) PersistentList'EMPTY)), (RT'meta form))
                    )]
                (cond
                    (nil? form)            Compiler'NIL_EXPR
                    (= form Boolean/TRUE)  Compiler'TRUE_EXPR
                    (= form Boolean/FALSE) Compiler'FALSE_EXPR
                    :else
                        (let [#_"Class" c (.getClass form)]
                            (cond
                                (= c (§ class Symbol))               (Compiler'analyzeSymbol (cast' Symbol form))
                                (= c (§ class Keyword))              (Compiler'registerKeyword (cast' Keyword form))
                                (instance? Number form)              (NumberExpr'parse (cast Number form))
                                (= c String)                         (StringExpr'new (.intern (cast String form)))
                                (and (§ instance? IPersistentCollection form) (not (§ instance? IRecord form)) (not (§ instance? IType form)) (zero? (.count (cast' IPersistentCollection form))))
                                    (let-when [#_"Expr" e (EmptyExpr'new form)] (some? (RT'meta form)) => e
                                        (MetaExpr'new e, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (.meta (cast' IObj form))))
                                    )
                                (§ instance? ISeq form)              (Compiler'analyzeSeq context, (cast' ISeq form), name)
                                (§ instance? IPersistentVector form) (VectorExpr'parse context, (cast' IPersistentVector form))
                                (§ instance? IRecord form)           (ConstantExpr'new form)
                                (§ instance? IType form)             (ConstantExpr'new form)
                                (§ instance? IPersistentMap form)    (MapExpr'parse context, (cast' IPersistentMap form))
                                (§ instance? IPersistentSet form)    (SetExpr'parse context, (cast' IPersistentSet form))
                                :else                                (ConstantExpr'new form)
                            )
                        )
                )
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e)))
            )
        )
    )

    (defn #_"Var" Compiler'isMacro [#_"Object" op]
        ;; no local macros for now
        (when-not (and (§ instance? Symbol op) (some? (Compiler'referenceLocal (cast' Symbol op))))
            (when (or (§ instance? Symbol op) (§ instance? Var op))
                (let [#_"Var" v (if (§ instance? Var op) (cast' Var op) (Compiler'lookupVar-3 (cast' Symbol op), false, false))]
                    (when (and (some? v) (.isMacro v))
                        (when (or (= (:ns v) (Compiler'currentNS)) (.isPublic v)) => (throw (IllegalStateException. (str "var: " v " is not public")))
                            v
                        )
                    )
                )
            )
        )
    )

    (defn #_"IFn" Compiler'isInline [#_"Object" op, #_"int" arity]
        ;; no local inlines for now
        (when-not (and (§ instance? Symbol op) (some? (Compiler'referenceLocal (cast' Symbol op))))
            (when (or (§ instance? Symbol op) (§ instance? Var op))
                (when-let [#_"Var" v (if (§ instance? Var op) (cast' Var op) (Compiler'lookupVar-2 (cast' Symbol op), false))]
                    (when (or (= (:ns v) (Compiler'currentNS)) (.isPublic v)) => (throw (IllegalStateException. (str "var: " v " is not public")))
                        (when-let [#_"IFn" f (cast' IFn (RT'get-2 (.meta v), Compiler'inlineKey))]
                            (let [#_"IFn" arityPred (cast' IFn (RT'get-2 (.meta v), Compiler'inlineAritiesKey))]
                                (when (or (nil? arityPred) (RT'booleanCast-1o (.invoke arityPred, arity)))
                                    f
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" sym]
        (and (some? (:ns sym)) (nil? (Compiler'namespaceFor-1 sym)))
    )

    (defn #_"Object" Compiler'preserveTag [#_"ISeq" src, #_"Object" dst]
        (let-when [#_"Symbol" tag (Compiler'tagOf src)] (and (some? tag) (§ instance? IObj dst)) => dst
            (.withMeta (cast' IObj dst), (cast' IPersistentMap (RT'assoc (RT'meta dst), RT'TAG_KEY, tag)))
        )
    )

    #_volatile
    (def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (defn- #_"Var" Compiler'ensureMacroCheck [] #_(§ throws ClassNotFoundException, IOException)
        (or Compiler'MACRO_CHECK
            (§ sync Compiler'MACRO_CHECK_LOCK
                (or Compiler'MACRO_CHECK
                    (do
                        (§ ass Compiler'MACRO_CHECK_LOADING true)
                        (RT'load-1 "cloiure/spec/alpha")
                        (RT'load-1 "cloiure/core/specs/alpha")
                        (§ ass Compiler'MACRO_CHECK (Var'find (Symbol'intern "cloiure.spec.alpha", "macroexpand-check")))
                        (§ ass Compiler'MACRO_CHECK_LOADING false)
                        Compiler'MACRO_CHECK
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'checkSpecs [#_"Var" v, #_"ISeq" form]
        (when (and RT'CHECK_SPECS (not Compiler'MACRO_CHECK_LOADING))
            (try
                (.applyTo (Compiler'ensureMacroCheck), (RT'cons v, (RT'list-1 (.next form))))
                (catch Exception e
                    (throw (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e))
                )
            )
        )
        nil
    )

    (defn #_"Object" Compiler'macroexpand1 [#_"Object" x]
        (when (§ instance? ISeq x) => x
            (let [#_"ISeq" form (cast' ISeq x) #_"Object" op (RT'first form)]
                (when-not (Compiler'isSpecial op) => x
                    ;; macro expansion
                    (let [#_"Var" v (Compiler'isMacro op)]
                        (if (some? v)
                            (do
                                (Compiler'checkSpecs v, form)
                                (try
                                    (.applyTo v, (RT'cons form, (RT'cons (.get Compiler'LOCAL_ENV), (.next form))))
                                    (§ catch ArityException e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ArityException'new-2 (- (:actual e) 2), (:name e)))
                                    )
                                )
                            )
                            (when (§ instance? Symbol op) => x
                                (let [#_"Symbol" sym (cast' Symbol op) #_"String" sname (:name sym)]
                                    ;; (.substring s 2 5) => (. s substring 2 5)
                                    (cond
                                        (= (.charAt (:name sym), 0) \.)
                                            (when (< 1 (RT'length form)) => (throw (IllegalArgumentException. "Malformed member expression, expecting (.member target ...)"))
                                                (let [#_"Symbol" meth (Symbol'intern (.substring sname, 1))
                                                      #_"Object" target (RT'second form)
                                                      target
                                                        (when (some? (HostExpr'maybeClass target, false)) => target
                                                            (.withMeta (cast' IObj (RT'list-2 Compiler'IDENTITY, target)), (RT'map RT'TAG_KEY, Compiler'CLASS))
                                                        )]
                                                    (Compiler'preserveTag form, (RT'listStar-4 Compiler'DOT, target, meth, (.next (.next form))))
                                                )
                                            )
                                        (Compiler'namesStaticMember sym)
                                            (let-when [#_"Symbol" target (Symbol'intern (:ns sym))] (some? (HostExpr'maybeClass target, false)) => x
                                                (let [#_"Symbol" meth (Symbol'intern (:name sym))]
                                                    (Compiler'preserveTag form, (RT'listStar-4 Compiler'DOT, target, meth, (.next form)))
                                                )
                                            )
                                        :else
                                            ;; (s.substring ...) => (. s substring ...)
                                            ;; (package.class.name ...) => (. package.class name ...)
                                            ;; (StringBuilder. ...) => (new StringBuilder ...)
                                            (let-when [#_"int" i (.lastIndexOf sname, \.)] (= i (dec (.length sname))) => x
                                                (RT'listStar-3 Compiler'NEW, (Symbol'intern (.substring sname, 0, i)), (.next form))
                                            )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Compiler'macroexpand [#_"Object" form]
        (let [#_"Object" f (Compiler'macroexpand1 form)]
            (if (= f form) form (recur f))
        )
    )

    (defn- #_"Expr" Compiler'analyzeSeq [#_"Context" context, #_"ISeq" form, #_"String" name]
        (let [#_"IPersistentMap" meta (RT'meta form)
              #_"Object" line   (if (and (some? meta) (.containsKey meta, RT'LINE_KEY))   (.valAt meta, RT'LINE_KEY)   (Compiler'lineDeref))
              #_"Object" column (if (and (some? meta) (.containsKey meta, RT'COLUMN_KEY)) (.valAt meta, RT'COLUMN_KEY) (Compiler'columnDeref))]
            (Var'pushThreadBindings (RT'map Compiler'LINE, line, Compiler'COLUMN, column))
            (try
                (let-when [#_"Object" me (Compiler'macroexpand1 form)] (= me form) => (Compiler'analyze-3 context, me, name)
                    (let-when [#_"Object" op (RT'first form)] (some? op) => (throw (IllegalArgumentException. (str "Can't call nil, form: " form)))
                        (let [#_"IFn" inline (Compiler'isInline op, (RT'count (RT'next form)))]
                            (cond
                                (some? inline)
                                    (Compiler'analyze-2 context, (Compiler'preserveTag form, (.applyTo inline, (RT'next form))))
                                (.equals op, Compiler'FN)
                                    (FnExpr'parse context, form, name)
                                :else
                                    (let [#_"IParser" p (cast' IParser (.valAt Compiler'specials, op))]
                                        (if (some? p)
                                            (.parse p, context, form)
                                            (InvokeExpr'parse context, form)
                                        )
                                    )
                            )
                        )
                    )
                )
                (catch Throwable e
                    (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e)))
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" Compiler'eval-1 [#_"Object" form]
        (Compiler'eval-2 form, true)
    )

    (defn #_"Object" Compiler'eval-2 [#_"Object" form, #_"boolean" freshLoader]
        (Var'pushThreadBindings (RT'map Compiler'LOADER, (RT'makeClassLoader)))
        (try
            (let [#_"IPersistentMap" meta (RT'meta form)
                  #_"Object" line   (if (and (some? meta) (.containsKey meta, RT'LINE_KEY))   (.valAt meta, RT'LINE_KEY)   (Compiler'lineDeref))
                  #_"Object" column (if (and (some? meta) (.containsKey meta, RT'COLUMN_KEY)) (.valAt meta, RT'COLUMN_KEY) (Compiler'columnDeref))]
                (Var'pushThreadBindings (RT'map Compiler'LINE, line, Compiler'COLUMN, column))
                (try
                    (let [form (Compiler'macroexpand form)]
                        (cond
                            (and (§ instance? ISeq form) (Util'equals (RT'first form), Compiler'DO))
                                (loop-when-recur [#_"ISeq" s (RT'next form)] (some? (RT'next s)) [(RT'next s)] => (Compiler'eval-2 (RT'first s), false)
                                    (Compiler'eval-2 (RT'first s), false)
                                )
                            (or (§ instance? IType form) (and (§ instance? IPersistentCollection form) (not (and (§ instance? Symbol (RT'first form)) (.startsWith (:name (cast' Symbol (RT'first form))), "def")))))
                                (let [#_"ObjExpr" fexpr (cast' ObjExpr (Compiler'analyze-3 :Context'EXPRESSION, (RT'list-3 Compiler'FN, PersistentVector'EMPTY, form), (str "eval" (RT'nextID))))]
                                    (let [#_"IFn" fn (cast' IFn (.eval fexpr))]
                                        (.invoke fn)
                                    )
                                )
                            :else
                                (let [#_"Expr" expr (Compiler'analyze-2 :Context'EVAL, form)]
                                    (.eval expr)
                                )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
    )

    (defn- #_"int" Compiler'registerConstant [#_"Object" o]
        (when (.isBound Compiler'CONSTANTS) => -1
            (let [#_"PersistentVector" v (cast' PersistentVector (.deref Compiler'CONSTANTS))
                  #_"IdentityHashMap<Object, Integer>" ids (cast IdentityHashMap #_"<Object, Integer>" (.deref Compiler'CONSTANT_IDS))]
                (or (.get ids, o)
                    (do
                        (.set Compiler'CONSTANTS, (RT'conj v, o))
                        (.put ids, o, (.count v))
                        (.count v)
                    )
                )
            )
        )
    )

    (defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" keyword]
        (when (.isBound Compiler'KEYWORDS) => (KeywordExpr'new keyword)
            (let [#_"IPersistentMap" keywordsMap (cast' IPersistentMap (.deref Compiler'KEYWORDS))
                  #_"Object" id (RT'get-2 keywordsMap, keyword)]
                (when (nil? id)
                    (.set Compiler'KEYWORDS, (RT'assoc keywordsMap, keyword, (Compiler'registerConstant keyword)))
                )
                (KeywordExpr'new keyword)
            )
        )
    )

    (defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" keyword]
        (when (.isBound Compiler'KEYWORD_CALLSITES) => (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
            (let [#_"IPersistentVector" callsites (-> (cast' IPersistentVector (.deref Compiler'KEYWORD_CALLSITES)) (.cons keyword))]
                (.set Compiler'KEYWORD_CALLSITES, callsites)
                (dec (.count callsites))
            )
        )
    )

    (defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" v]
        (when (.isBound Compiler'PROTOCOL_CALLSITES) => (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
            (let [#_"IPersistentVector" callsites (-> (cast' IPersistentVector (.deref Compiler'PROTOCOL_CALLSITES)) (.cons v))]
                (.set Compiler'PROTOCOL_CALLSITES, callsites)
                (dec (.count callsites))
            )
        )
    )

    (defn- #_"void" Compiler'registerVarCallsite [#_"Var" v]
        (when (.isBound Compiler'VAR_CALLSITES) => (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
            (let [#_"IPersistentCollection" callsites (-> (cast' IPersistentCollection (.deref Compiler'VAR_CALLSITES)) (.cons v))]
                (.set Compiler'VAR_CALLSITES, callsites)
            )
        )
        nil
    )

    (defn #_"ISeq" Compiler'fwdPath [#_"PathNode" p]
        (loop-when-recur [#_"ISeq" s nil p p] (some? p) [(RT'cons p, s) (:parent p)] => s)
    )

    (defn #_"PathNode" Compiler'commonPath [#_"PathNode" p1, #_"PathNode" p2]
        (let [#_"ISeq" s1 (Compiler'fwdPath p1) #_"ISeq" s2 (Compiler'fwdPath p2)]
            (when (= (RT'first s1) (RT'first s2))
                (loop-when-recur [s1 s1 s2 s2]
                                 (and (some? (RT'second s1)) (= (RT'second s1) (RT'second s2)))
                                 [(.next s1) (.next s2)]
                              => (cast' PathNode (RT'first s1))
                )
            )
        )
    )

    (defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" sym]
        (let [#_"Symbol" tag (Compiler'tagOf sym)]
            (or
                (cond
                    (nil? (:ns sym)) ;; ns-qualified syms are always Vars
                        (when-let [#_"LocalBinding" b (Compiler'referenceLocal sym)]
                            (LocalBindingExpr'new b, tag)
                        )
                    (nil? (Compiler'namespaceFor-1 sym))
                        (when-let [#_"Class" c (HostExpr'maybeClass (Symbol'intern (:ns sym)), false)]
                            (if (some? (Reflector'getField c, (:name sym), true))
                                (StaticFieldExpr'new (Compiler'lineDeref), (Compiler'columnDeref), c, (:name sym), tag)
                                (throw (RuntimeException. (str "Unable to find static field: " (:name sym) " in " c)))
                            )
                        )
                )
                (let [#_"Object" o (Compiler'resolve-1 sym)]
                    (cond
                        (§ instance? Var o)
                            (let [#_"Var" v (cast' Var o)]
                                (cond
                                    (some? (Compiler'isMacro v))
                                        (throw (RuntimeException. (str "Can't take value of a macro: " v)))
                                    (RT'booleanCast-1o (RT'get-2 (.meta v), RT'CONST_KEY))
                                        (Compiler'analyze-2 :Context'EXPRESSION, (RT'list-2 Compiler'QUOTE, (.get v)))
                                    :else
                                        (do
                                            (Compiler'registerVar v)
                                            (VarExpr'new v, tag)
                                        )
                                )
                            )
                        (instance? Class o)
                            (ConstantExpr'new o)
                        (§ instance? Symbol o)
                            (UnresolvedVarExpr'new (cast' Symbol o))
                        :else
                            (throw (RuntimeException. (str "Unable to resolve symbol: " sym " in this context")))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'destubClassName [#_"String" name]
        ;; skip over prefix + '.' or '/'
        (if (.startsWith name, Compiler'COMPILE_STUB_PREFIX)
            (.substring name, (inc (.length Compiler'COMPILE_STUB_PREFIX)))
            name
        )
    )

    (defn #_"Type" Compiler'getType [#_"Class" c]
        (let [#_"String" desc (.getDescriptor (Type/getType c))
              desc
                (when (.startsWith desc, "L") => desc
                    (str "L" (Compiler'destubClassName (.substring desc, 1)))
                )]
            (§ unsure Type/getType desc)
        )
    )

    (defn #_"Object" Compiler'resolve-2 [#_"Symbol" sym, #_"boolean" allowPrivate]
        (Compiler'resolveIn (Compiler'currentNS), sym, allowPrivate)
    )

    (defn #_"Object" Compiler'resolve-1 [#_"Symbol" sym]
        (Compiler'resolveIn (Compiler'currentNS), sym, false)
    )

    (defn #_"Namespace" Compiler'namespaceFor-1 [#_"Symbol" sym]
        (Compiler'namespaceFor-2 (Compiler'currentNS), sym)
    )

    (defn #_"Namespace" Compiler'namespaceFor-2 [#_"Namespace" inns, #_"Symbol" sym]
        ;; note, presumes non-nil sym.ns
        (let [#_"Symbol" nsSym (Symbol'intern (:ns sym))]
            ;; first check against currentNS' aliases, otherwise check the Namespaces map
            (or (.lookupAlias inns, nsSym) (Namespace'find nsSym))
        )
    )

    (defn #_"Object" Compiler'resolveIn [#_"Namespace" n, #_"Symbol" sym, #_"boolean" allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond
            (some? (:ns sym))
                (let-when [#_"Namespace" ns (Compiler'namespaceFor-2 n, sym)] (some? ns)               => (throw (RuntimeException. (str "No such namespace: " (:ns sym))))
                    (let-when [#_"Var" v (.findInternedVar ns, (Symbol'intern (:name sym)))] (some? v) => (throw (RuntimeException. (str "No such var: " sym)))
                        (when (or (= (:ns v) (Compiler'currentNS)) (.isPublic v) allowPrivate)         => (throw (IllegalStateException. (str "var: " sym " is not public")))
                            v
                        )
                    )
                )
            (or (pos? (.indexOf (:name sym), \.)) (= (.charAt (:name sym), 0) \[)) (RT'classForName-1 (:name sym))
            (.equals sym, Compiler'NS)                                             RT'NS_VAR
            (.equals sym, Compiler'IN_NS)                                          RT'IN_NS_VAR
            (Util'equals sym, (.get Compiler'COMPILE_STUB_SYM))                    (.get Compiler'COMPILE_STUB_CLASS)
            :else
                (or (.getMapping n, sym)
                    (when (RT'booleanCast-1o (.deref RT'ALLOW_UNRESOLVED_VARS)) => (throw (RuntimeException. (str "Unable to resolve symbol: " sym " in this context")))
                        sym
                    )
                )
        )
    )

    (defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" n, #_"Symbol" sym]
        ;; note - ns-qualified vars must already exist
        (cond
            (some? (:ns sym))
                (when-let [#_"Namespace" ns (Compiler'namespaceFor-2 n, sym)]
                    (when-let [#_"Var" v (.findInternedVar ns, (Symbol'intern (:name sym)))]
                        v
                    )
                )
            (or (and (pos? (.indexOf (:name sym), \.)) (not (.endsWith (:name sym), "."))) (= (.charAt (:name sym), 0) \[))
                (RT'classForName-1 (:name sym))
            (.equals sym, Compiler'NS)
                RT'NS_VAR
            (.equals sym, Compiler'IN_NS)
                RT'IN_NS_VAR
            :else
                (.getMapping n, sym)
        )
    )

    (defn #_"Var" Compiler'lookupVar-3 [#_"Symbol" sym, #_"boolean" internNew, #_"boolean" registerMacro]
        ;; note - ns-qualified vars in other namespaces must already exist
        (let [#_"Var" var
                (cond
                    (some? (:ns sym))
                        (when-let [#_"Namespace" ns (Compiler'namespaceFor-1 sym)]
                            (let [#_"Symbol" name (Symbol'intern (:name sym))]
                                (if (and internNew (= ns (Compiler'currentNS)))
                                    (.intern ns, name)
                                    (.findInternedVar ns, name)
                                )
                            )
                        )
                    (.equals sym, Compiler'NS)    RT'NS_VAR
                    (.equals sym, Compiler'IN_NS) RT'IN_NS_VAR
                    :else ;; is it mapped?
                        (let [#_"Object" o (.getMapping (Compiler'currentNS), sym)]
                            (cond
                                (nil? o) ;; introduce a new var in the current ns
                                    (when internNew
                                        (.intern (Compiler'currentNS), (Symbol'intern (:name sym)))
                                    )
                                (§ instance? Var o)
                                    (cast' Var o)
                                :else
                                    (throw (RuntimeException. (str "Expecting var, but " sym " is mapped to " o)))
                            )
                        )
                )]
            (when (and (some? var) (or (not (.isMacro var)) registerMacro))
                (Compiler'registerVar var)
            )
            var
        )
    )

    (defn #_"Var" Compiler'lookupVar-2 [#_"Symbol" sym, #_"boolean" internNew]
        (Compiler'lookupVar-3 sym, internNew, true)
    )

    (defn- #_"void" Compiler'registerVar [#_"Var" var]
        (when (.isBound Compiler'VARS)
            (let [#_"IPersistentMap" m (cast' IPersistentMap (.deref Compiler'VARS))]
                (let-when [#_"Object" id (RT'get-2 m, var)] (nil? id)
                    (.set Compiler'VARS, (RT'assoc m, var, (Compiler'registerConstant var)))
                )
            )
        )
        nil
    )

    (defn #_"Namespace" Compiler'currentNS []
        (cast' Namespace (.deref RT'CURRENT_NS))
    )

    (defn #_"void" Compiler'closeOver [#_"LocalBinding" b, #_"ObjMethod" method]
        (when (and (some? b) (some? method))
            (let [#_"LocalBinding" lb (cast' LocalBinding (RT'get-2 (:locals method), b))]
                (if (nil? lb)
                    (do
                        (§ ass (:closes (:objx method)) (cast' IPersistentMap (RT'assoc (:closes (:objx method)), b, b)))
                        (Compiler'closeOver b, (:parent method))
                    )
                    (do
                        (when (zero? (:idx lb))
                            (§ ass (:usesThis method) true)
                        )
                        (when (some? (.deref Compiler'IN_CATCH_FINALLY))
                            (§ ass (:localsUsedInCatchFinally method) (cast' PersistentHashSet (.cons (:localsUsedInCatchFinally method), (:idx b))))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" sym]
        (when (.isBound Compiler'LOCAL_ENV)
            (when-let [#_"LocalBinding" b (cast' LocalBinding (RT'get-2 (.deref Compiler'LOCAL_ENV), sym))]
                (let [#_"ObjMethod" method (cast' ObjMethod (.deref Compiler'METHOD))]
                    (when (zero? (:idx b))
                        (§ ass (:usesThis method) true)
                    )
                    (Compiler'closeOver b, method)
                    b
                )
            )
        )
    )

    (defn- #_"Symbol" Compiler'tagOf [#_"Object" o]
        (let [#_"Object" tag (RT'get-2 (RT'meta o), RT'TAG_KEY)]
            (cond
                (§ instance? Symbol tag) (cast' Symbol tag)
                (instance? String tag)   (Symbol'intern nil, (cast String tag))
            )
        )
    )

    (defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" pushbackReader]
        (loop-when-recur [#_"int" ch (LispReader'read1 pushbackReader)]
                         (LispReader'isWhitespace ch)
                         [(LispReader'read1 pushbackReader)]
                      => (LispReader'unread pushbackReader, ch)
        )
        nil
    )

    (defn #_"Object" Compiler'load [#_"Reader" rdr]
        (let [#_"Object" EOF (Object.)]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (if (§ instance? LineNumberingPushbackReader rdr) (cast' LineNumberingPushbackReader rdr) (LineNumberingPushbackReader'new-1 rdr))]
                    (Compiler'consumeWhitespaces pushbackReader)
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            Compiler'LOADER         (RT'makeClassLoader)
                            Compiler'METHOD         nil
                            Compiler'LOCAL_ENV      nil
                            Compiler'LOOP_LOCALS    nil
                            Compiler'NEXT_LOCAL_NUM 0
                            RT'READEVAL             RT'T
                            RT'CURRENT_NS           (.deref RT'CURRENT_NS)
                            RT'WARN_ON_REFLECTION   (.deref RT'WARN_ON_REFLECTION)
                        ])
                    ))

                    (try
                        (loop-when-recur [#_"Object" r (LispReader'read-4 pushbackReader, false, EOF, false)] (not= r EOF) [(LispReader'read-4 pushbackReader, false, EOF, false)]
                            (Compiler'consumeWhitespaces pushbackReader)
                            (§ ass ret (Compiler'eval-2 r, false))
                        )
                        (§ catch LispReaderException e
                            (throw (CompilerException'new (:line e), (:column e), (.getCause e)))
                        )
                        (catch Throwable e
                            (if (not (§ instance? CompilerException e))
                                (do
                                    (throw (CompilerException'new 0, 0, e))
                                )
                                (do
                                    (throw (cast' CompilerException e))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                    ret
                )
            )
        )
    )

    (defn #_"void" Compiler'pushNS []
        (Var'pushThreadBindings (PersistentHashMap'create-1a
            (object-array [
                (.setDynamic (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "*ns*"))) nil
            ])
        ))
        nil
    )

    (defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" loader]
        (Var'pushThreadBindings (RT'map
            (object-array [
                (.setDynamic (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "*ns*"))) nil
                RT'FN_LOADER_VAR loader
                RT'READEVAL RT'T
            ])
        ))
        nil
    )

    (defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" target, #_"Keyword" k]
        nil
    )

    (defn #_"boolean" Compiler'inty [#_"Class" c] (any = c Integer/TYPE Short/TYPE Byte/TYPE Character/TYPE))

    (defn #_"Class" Compiler'retType [#_"Class" tc, #_"Class" ret]
        (cond
            (nil? tc)
                ret
            (nil? ret)
                tc
            (and (.isPrimitive ret) (.isPrimitive tc))
                (if (or (and (Compiler'inty ret) (Compiler'inty tc)) (= ret tc))
                    tc
                    (throw (UnsupportedOperationException. (str "Cannot coerce " ret " to " tc ", use a cast instead")))
                )
            :else
                tc
        )
    )

    (defn #_"Class" Compiler'primClass-1s [#_"Symbol" sym]
        (when (some? sym)
            (condp = (:name sym)
                "int"     Integer/TYPE
                "long"    Long/TYPE
                "float"   Float/TYPE
                "double"  Double/TYPE
                "char"    Character/TYPE
                "short"   Short/TYPE
                "byte"    Byte/TYPE
                "boolean" Boolean/TYPE
                "void"    Void/TYPE
                          nil
            )
        )
    )

    (defn #_"Class" Compiler'tagClass [#_"Object" tag]
        (when (some? tag) => Object
            (or
                (when (§ instance? Symbol tag)
                    (Compiler'primClass-1s (cast' Symbol tag))
                )
                (HostExpr'tagToClass tag)
            )
        )
    )

    (defn #_"Class" Compiler'primClass-1c [#_"Class" c]
        (if (.isPrimitive c) c Object)
    )

    (defn #_"Class" Compiler'boxClass [#_"Class" p]
        (when (.isPrimitive p) => p
            (condp = p
                Integer/TYPE   Integer
                Long/TYPE      Long
                Float/TYPE     Float
                Double/TYPE    Double
                Character/TYPE Character
                Short/TYPE     Short
                Byte/TYPE      Byte
                Boolean/TYPE   Boolean
                               nil
            )
        )
    )

    (defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        PersistentHashSet'EMPTY
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (defn- #_"Cons" Cons'init []
        (hash-map
            #_"Object" :_first nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"Cons" Cons'new-2 [#_"Object" first, #_"ISeq" _more]
        (let [this (merge (ASeq'new) (Cons'init))]
            (§ ass this (assoc this :_first first))
            (§ ass this (assoc this :_more _more))
            this
        )
    )

    (defn #_"Cons" Cons'new-3 [#_"IPersistentMap" meta, #_"Object" _first, #_"ISeq" _more]
        (let [this (merge (ASeq'new meta) (Cons'init))]
            (§ ass this (assoc this :_first _first))
            (§ ass this (assoc this :_more _more))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"Cons" this]
        (:_first this)
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"Cons" this]
        (.seq (.more this))
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"Cons" this]
        (or (:_more this) PersistentList'EMPTY)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"Cons" this]
        (inc (RT'count (:_more this)))
    )

    #_method
    (§ defn #_"Cons" (§ method withMeta) [#_"Cons" this, #_"IPersistentMap" meta]
        (Cons'new-3 meta, (:_first this), (:_more this))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ defprotocol Counted
    #_abstract
    (#_"int" Counted'''count [#_"Counted" this])
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (defn- #_"Cycle" Cycle'init []
        (hash-map
            #_"ISeq" :all nil ;; never nil
            #_"ISeq" :prev nil
            #_volatile
            #_"ISeq" :_current nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Cycle" Cycle'new-3 [#_"ISeq" all, #_"ISeq" prev, #_"ISeq" current]
        (let [this (merge (ASeq'new) (Cycle'init))]
            (§ ass this (assoc this :all all))
            (§ ass this (assoc this :prev prev))
            (§ ass this (assoc this :_current current))
            this
        )
    )

    (defn- #_"Cycle" Cycle'new-5 [#_"IPersistentMap" meta, #_"ISeq" all, #_"ISeq" prev, #_"ISeq" current, #_"ISeq" next]
        (let [this (merge (ASeq'new meta) (Cycle'init))]
            (§ ass this (assoc this :all all))
            (§ ass this (assoc this :prev prev))
            (§ ass this (assoc this :_current current))
            (§ ass this (assoc this :_next next))
            this
        )
    )

    (defn #_"ISeq" Cycle'create [#_"ISeq" vals]
        (if (some? vals) (Cycle'new-3 vals, nil, vals) PersistentList'EMPTY)
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" (§ method current) [#_"Cycle" this]
        (when (nil? (:_current this))
            (let [#_"ISeq" current (.next (:prev this))]
                (§ ass this (assoc this :_current (or current (:all this))))
            )
        )
        (:_current this)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Cycle" this]
        (some? (:_current this))
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"Cycle" this]
        (.first (.current this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"Cycle" this]
        (when (nil? (:_next this))
            (§ ass this (assoc this :_next (Cycle'new-3 (:all this), (.current this), nil)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Cycle" (§ method withMeta) [#_"Cycle" this, #_"IPersistentMap" meta]
        (Cycle'new-5 meta, (:all this), (:prev this), (:_current this), (:_next this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Cycle" this, #_"IFn" f]
        (loop [#_"ISeq" s (.current this) #_"Object" r (.first s)]
            (let [s (or (.next s) (:all this)) r (.invoke f, r, (.first s))]
                (when-not (RT'isReduced r) => (.deref (cast' IDeref r))
                    (recur s r)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Cycle" this, #_"IFn" f, #_"Object" r]
        (loop [#_"ISeq" s (.current this) r (.invoke f, r, (.first s))]
            (when-not (RT'isReduced r) => (.deref (cast' IDeref r))
                (let [s (or (.next s) (:all this))]
                    (recur s (.invoke f, r, (.first s)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (defn- #_"Delay" Delay'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Throwable" :exception nil
            #_volatile
            #_"IFn" :fn nil
        )
    )

    (defn #_"Delay" Delay'new [#_"IFn" fn]
        (let [this (Delay'init)]
            (§ ass this (assoc this :fn fn))
            (§ ass this (assoc this :val nil))
            (§ ass this (assoc this :exception nil))
            this
        )
    )

    (defn #_"Object" Delay'force [#_"Object" x]
        (if (§ instance? Delay x) (.deref (cast' Delay x)) x)
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Delay" this]
        (when (some? (:fn this))
            (§ sync this
                ;; double check
                (when (some? (:fn this))
                    (try
                        (§ ass this (assoc this :val (.invoke (:fn this))))
                        (catch Throwable t
                            (§ ass this (assoc this :exception t))
                        )
                    )
                    (§ ass this (assoc this :fn nil))
                )
            )
        )
        (when (some? (:exception this))
            (throw (Util'sneakyThrow (:exception this)))
        )
        (:val this)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Delay" this]
        (§ sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ConcurrentHashMap.))

    (def #_"ReferenceQueue" DynamicClassLoader'RQ (ReferenceQueue.))

    (defn- #_"DynamicClassLoader" DynamicClassLoader'init []
        (hash-map
            #_"HashMap<Integer, Object[]>" :constantVals (HashMap.)
        )
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new [#_"ClassLoader" parent]
        (merge (URLClassLoader'new (make-array URL 0), parent) (DynamicClassLoader'init))
    )

    #_method
    (§ defn #_"Class" (§ method defineClass) [#_"DynamicClassLoader" this, #_"String" name, #_"byte[]" bytes, #_"Object" srcForm]
        (Util'clearCache DynamicClassLoader'RQ, DynamicClassLoader'classCache)
        (let [#_"Class" c (.defineClass this, name, bytes, 0, (alength bytes))]
            (.put DynamicClassLoader'classCache, name, (SoftReference. c, DynamicClassLoader'RQ))
            c
        )
    )

    (defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" name]
        (when-let [#_"Reference<Class>" r (.get DynamicClassLoader'classCache, name)]
            (or (.get r) (do (.remove DynamicClassLoader'classCache, name, r) nil))
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" (§ method findClass) [#_"DynamicClassLoader" this, #_"String" name] #_(§ throws ClassNotFoundException)
        (or (DynamicClassLoader'findInMemoryClass name) (.findClass (§ super ), name))
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" (§ method loadClass) [#_"DynamicClassLoader" this, #_"String" name, #_"boolean" resolve] #_(§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" c (.findLoadedClass this, name)]
                (when (nil? c)
                    (§ ass c (DynamicClassLoader'findInMemoryClass name))
                    (when (nil? c)
                        (§ ass c (.loadClass (§ super ), name, false))
                    )
                )
                (when resolve
                    (.resolveClass this, c)
                )
                c
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method registerConstants) [#_"DynamicClassLoader" this, #_"int" id, #_"Object[]" val]
        (.put (:constantVals this), id, val)
        nil
    )

    #_method
    (§ defn #_"Object[]" (§ method getConstants) [#_"DynamicClassLoader" this, #_"int" id]
        (.get (:constantVals this), id)
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (defn- #_"ExceptionInfo" ExceptionInfo'init []
        (hash-map
            #_"IPersistentMap" :data nil
        )
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-2 [#_"String" s, #_"IPersistentMap" data]
        (ExceptionInfo'new-3 s, data, nil)
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-3 [#_"String" s, #_"IPersistentMap" data, #_"Throwable" throwable]
        (let [this (merge (§ foreign RuntimeException'new s, throwable) (ExceptionInfo'init))]
            ;; nil cause is equivalent to not passing a cause
            (if (some? data)
                (do
                    (§ ass this (assoc this :data data))
                )
                (do
                    (throw (IllegalArgumentException. "Additional data must be non-nil."))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getData) [#_"ExceptionInfo" this]
        (:data this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ExceptionInfo" this]
        (str "cloiure.lang.ExceptionInfo: " (.getMessage this) " " (.toString (:data this)))
    )
)
)

(java-ns cloiure.lang.Fn

(§ defprotocol Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (defn- #_"FnLoaderThunk" FnLoaderThunk'init []
        (hash-map
            #_"Var" :v nil
            #_"ClassLoader" :loader nil
            #_"String" :fnClassName nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"FnLoaderThunk" FnLoaderThunk'new [#_"Var" v, #_"String" fnClassName]
        (let [this (merge (RestFn'new) (FnLoaderThunk'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :loader (cast ClassLoader (.get RT'FN_LOADER_VAR))))
            (§ ass this (assoc this :fnClassName fnClassName))
            (§ ass this (assoc this :fn nil))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" arg1]
        (.load this)
        (.invoke (:fn this), arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" arg1, #_"Object" arg2]
        (.load this)
        (.invoke (:fn this), arg1, arg2)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.load this)
        (.invoke (:fn this), arg1, arg2, arg3)
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"FnLoaderThunk" this, #_"Object" args]
        (.load this)
        (.applyTo (:fn this), (cast' ISeq args))
    )

    #_method
    (§ defn- #_"void" (§ method load) [#_"FnLoaderThunk" this]
        (when (nil? (:fn this))
            (try
                (§ ass this (assoc this :fn (cast' IFn (.newInstance (Class/forName (:fnClassName this), true, (:loader this))))))
                (catch Exception e
                    (throw (Util'sneakyThrow e))
                )
            )
            (§ ass (:root (:v this)) (:fn this))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getRequiredArity) [#_"FnLoaderThunk" this]
        0
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"FnLoaderThunk" this, #_"IPersistentMap" meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ defprotocol IAtom
    #_abstract
    (#_"Object" IAtom'''(§ method swap-2) [#_"IAtom" this, #_"IFn" f])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-3) [#_"IAtom" this, #_"IFn" f, #_"Object" arg])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-4) [#_"IAtom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-5) [#_"IAtom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
    #_abstract
    (#_"boolean" IAtom'''(§ method compareAndSet) [#_"IAtom" this, #_"Object" oldv, #_"Object" newv])
    #_abstract
    (#_"Object" IAtom'''(§ method reset) [#_"IAtom" this, #_"Object" newval])
)
)

(java-ns cloiure.lang.IAtom2

(§ defprotocol IAtom2 #_(§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-2) [#_"IAtom2" this, #_"IFn" f])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-3) [#_"IAtom2" this, #_"IFn" f, #_"Object" arg])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-4) [#_"IAtom2" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-5) [#_"IAtom2" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method resetVals) [#_"IAtom2" this, #_"Object" newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ defprotocol IBlockingDeref
    #_abstract
    (#_"Object" IBlockingDeref'''(§ method deref) [#_"IBlockingDeref" this, #_"long" ms, #_"Object" timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(§ defprotocol IChunk #_(§ extends Indexed)
    #_abstract
    (#_"IChunk" IChunk'''(§ method dropFirst) [#_"IChunk" this])
    #_abstract
    (#_"Object" IChunk'''(§ method reduce) [#_"IChunk" this, #_"IFn" f, #_"Object" start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ defprotocol IChunkedSeq #_(§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" IChunkedSeq'''(§ method chunkedFirst) [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''(§ method chunkedNext) [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''(§ method chunkedMore) [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(§ defprotocol IDeref
    #_abstract
    (#_"Object" IDeref'''(§ method deref) [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(§ defprotocol IEditableCollection
    #_abstract
    (#_"ITransientCollection" IEditableCollection'''(§ method asTransient) [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ defprotocol IExceptionInfo
    #_abstract
    (#_"IPersistentMap" IExceptionInfo'''(§ method getData) [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

(§ defprotocol L
    #_abstract
    (#_"long" L'''(§ method invokePrim) [#_"L" this])
)

(§ defprotocol D
    #_abstract
    (#_"double" D'''(§ method invokePrim) [#_"D" this])
)

(§ defprotocol OL
    #_abstract
    (#_"long" OL'''(§ method invokePrim) [#_"OL" this, #_"Object" arg0])
)

(§ defprotocol OD
    #_abstract
    (#_"double" OD'''(§ method invokePrim) [#_"OD" this, #_"Object" arg0])
)

(§ defprotocol LO
    #_abstract
    (#_"Object" LO'''(§ method invokePrim) [#_"LO" this, #_"long" arg0])
)

(§ defprotocol LL
    #_abstract
    (#_"long" LL'''(§ method invokePrim) [#_"LL" this, #_"long" arg0])
)

(§ defprotocol LD
    #_abstract
    (#_"double" LD'''(§ method invokePrim) [#_"LD" this, #_"long" arg0])
)

(§ defprotocol DO
    #_abstract
    (#_"Object" DO'''(§ method invokePrim) [#_"DO" this, #_"double" arg0])
)

(§ defprotocol DL
    #_abstract
    (#_"long" DL'''(§ method invokePrim) [#_"DL" this, #_"double" arg0])
)

(§ defprotocol DD
    #_abstract
    (#_"double" DD'''(§ method invokePrim) [#_"DD" this, #_"double" arg0])
)

(§ defprotocol OOL
    #_abstract
    (#_"long" OOL'''(§ method invokePrim) [#_"OOL" this, #_"Object" arg0, #_"Object" arg1])
)

(§ defprotocol OOD
    #_abstract
    (#_"double" OOD'''(§ method invokePrim) [#_"OOD" this, #_"Object" arg0, #_"Object" arg1])
)

(§ defprotocol OLO
    #_abstract
    (#_"Object" OLO'''(§ method invokePrim) [#_"OLO" this, #_"Object" arg0, #_"long" arg1])
)

(§ defprotocol OLL
    #_abstract
    (#_"long" OLL'''(§ method invokePrim) [#_"OLL" this, #_"Object" arg0, #_"long" arg1])
)

(§ defprotocol OLD
    #_abstract
    (#_"double" OLD'''(§ method invokePrim) [#_"OLD" this, #_"Object" arg0, #_"long" arg1])
)

(§ defprotocol ODO
    #_abstract
    (#_"Object" ODO'''(§ method invokePrim) [#_"ODO" this, #_"Object" arg0, #_"double" arg1])
)

(§ defprotocol ODL
    #_abstract
    (#_"long" ODL'''(§ method invokePrim) [#_"ODL" this, #_"Object" arg0, #_"double" arg1])
)

(§ defprotocol ODD
    #_abstract
    (#_"double" ODD'''(§ method invokePrim) [#_"ODD" this, #_"Object" arg0, #_"double" arg1])
)

(§ defprotocol LOO
    #_abstract
    (#_"Object" LOO'''(§ method invokePrim) [#_"LOO" this, #_"long" arg0, #_"Object" arg1])
)

(§ defprotocol LOL
    #_abstract
    (#_"long" LOL'''(§ method invokePrim) [#_"LOL" this, #_"long" arg0, #_"Object" arg1])
)

(§ defprotocol LOD
    #_abstract
    (#_"double" LOD'''(§ method invokePrim) [#_"LOD" this, #_"long" arg0, #_"Object" arg1])
)

(§ defprotocol LLO
    #_abstract
    (#_"Object" LLO'''(§ method invokePrim) [#_"LLO" this, #_"long" arg0, #_"long" arg1])
)

(§ defprotocol LLL
    #_abstract
    (#_"long" LLL'''(§ method invokePrim) [#_"LLL" this, #_"long" arg0, #_"long" arg1])
)

(§ defprotocol LLD
    #_abstract
    (#_"double" LLD'''(§ method invokePrim) [#_"LLD" this, #_"long" arg0, #_"long" arg1])
)

(§ defprotocol LDO
    #_abstract
    (#_"Object" LDO'''(§ method invokePrim) [#_"LDO" this, #_"long" arg0, #_"double" arg1])
)

(§ defprotocol LDL
    #_abstract
    (#_"long" LDL'''(§ method invokePrim) [#_"LDL" this, #_"long" arg0, #_"double" arg1])
)

(§ defprotocol LDD
    #_abstract
    (#_"double" LDD'''(§ method invokePrim) [#_"LDD" this, #_"long" arg0, #_"double" arg1])
)

(§ defprotocol DOO
    #_abstract
    (#_"Object" DOO'''(§ method invokePrim) [#_"DOO" this, #_"double" arg0, #_"Object" arg1])
)

(§ defprotocol DOL
    #_abstract
    (#_"long" DOL'''(§ method invokePrim) [#_"DOL" this, #_"double" arg0, #_"Object" arg1])
)

(§ defprotocol DOD
    #_abstract
    (#_"double" DOD'''(§ method invokePrim) [#_"DOD" this, #_"double" arg0, #_"Object" arg1])
)

(§ defprotocol DLO
    #_abstract
    (#_"Object" DLO'''(§ method invokePrim) [#_"DLO" this, #_"double" arg0, #_"long" arg1])
)

(§ defprotocol DLL
    #_abstract
    (#_"long" DLL'''(§ method invokePrim) [#_"DLL" this, #_"double" arg0, #_"long" arg1])
)

(§ defprotocol DLD
    #_abstract
    (#_"double" DLD'''(§ method invokePrim) [#_"DLD" this, #_"double" arg0, #_"long" arg1])
)

(§ defprotocol DDO
    #_abstract
    (#_"Object" DDO'''(§ method invokePrim) [#_"DDO" this, #_"double" arg0, #_"double" arg1])
)

(§ defprotocol DDL
    #_abstract
    (#_"long" DDL'''(§ method invokePrim) [#_"DDL" this, #_"double" arg0, #_"double" arg1])
)

(§ defprotocol DDD
    #_abstract
    (#_"double" DDD'''(§ method invokePrim) [#_"DDD" this, #_"double" arg0, #_"double" arg1])
)

(§ defprotocol OOOL
    #_abstract
    (#_"long" OOOL'''(§ method invokePrim) [#_"OOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol OOOD
    #_abstract
    (#_"double" OOOD'''(§ method invokePrim) [#_"OOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol OOLO
    #_abstract
    (#_"Object" OOLO'''(§ method invokePrim) [#_"OOLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol OOLL
    #_abstract
    (#_"long" OOLL'''(§ method invokePrim) [#_"OOLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol OOLD
    #_abstract
    (#_"double" OOLD'''(§ method invokePrim) [#_"OOLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol OODO
    #_abstract
    (#_"Object" OODO'''(§ method invokePrim) [#_"OODO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol OODL
    #_abstract
    (#_"long" OODL'''(§ method invokePrim) [#_"OODL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol OODD
    #_abstract
    (#_"double" OODD'''(§ method invokePrim) [#_"OODD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol OLOO
    #_abstract
    (#_"Object" OLOO'''(§ method invokePrim) [#_"OLOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol OLOL
    #_abstract
    (#_"long" OLOL'''(§ method invokePrim) [#_"OLOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol OLOD
    #_abstract
    (#_"double" OLOD'''(§ method invokePrim) [#_"OLOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol OLLO
    #_abstract
    (#_"Object" OLLO'''(§ method invokePrim) [#_"OLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol OLLL
    #_abstract
    (#_"long" OLLL'''(§ method invokePrim) [#_"OLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol OLLD
    #_abstract
    (#_"double" OLLD'''(§ method invokePrim) [#_"OLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol OLDO
    #_abstract
    (#_"Object" OLDO'''(§ method invokePrim) [#_"OLDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol OLDL
    #_abstract
    (#_"long" OLDL'''(§ method invokePrim) [#_"OLDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol OLDD
    #_abstract
    (#_"double" OLDD'''(§ method invokePrim) [#_"OLDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol ODOO
    #_abstract
    (#_"Object" ODOO'''(§ method invokePrim) [#_"ODOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol ODOL
    #_abstract
    (#_"long" ODOL'''(§ method invokePrim) [#_"ODOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol ODOD
    #_abstract
    (#_"double" ODOD'''(§ method invokePrim) [#_"ODOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol ODLO
    #_abstract
    (#_"Object" ODLO'''(§ method invokePrim) [#_"ODLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol ODLL
    #_abstract
    (#_"long" ODLL'''(§ method invokePrim) [#_"ODLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol ODLD
    #_abstract
    (#_"double" ODLD'''(§ method invokePrim) [#_"ODLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol ODDO
    #_abstract
    (#_"Object" ODDO'''(§ method invokePrim) [#_"ODDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol ODDL
    #_abstract
    (#_"long" ODDL'''(§ method invokePrim) [#_"ODDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol ODDD
    #_abstract
    (#_"double" ODDD'''(§ method invokePrim) [#_"ODDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol LOOO
    #_abstract
    (#_"Object" LOOO'''(§ method invokePrim) [#_"LOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol LOOL
    #_abstract
    (#_"long" LOOL'''(§ method invokePrim) [#_"LOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol LOOD
    #_abstract
    (#_"double" LOOD'''(§ method invokePrim) [#_"LOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol LOLO
    #_abstract
    (#_"Object" LOLO'''(§ method invokePrim) [#_"LOLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol LOLL
    #_abstract
    (#_"long" LOLL'''(§ method invokePrim) [#_"LOLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol LOLD
    #_abstract
    (#_"double" LOLD'''(§ method invokePrim) [#_"LOLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol LODO
    #_abstract
    (#_"Object" LODO'''(§ method invokePrim) [#_"LODO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol LODL
    #_abstract
    (#_"long" LODL'''(§ method invokePrim) [#_"LODL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol LODD
    #_abstract
    (#_"double" LODD'''(§ method invokePrim) [#_"LODD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol LLOO
    #_abstract
    (#_"Object" LLOO'''(§ method invokePrim) [#_"LLOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol LLOL
    #_abstract
    (#_"long" LLOL'''(§ method invokePrim) [#_"LLOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol LLOD
    #_abstract
    (#_"double" LLOD'''(§ method invokePrim) [#_"LLOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol LLLO
    #_abstract
    (#_"Object" LLLO'''(§ method invokePrim) [#_"LLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol LLLL
    #_abstract
    (#_"long" LLLL'''(§ method invokePrim) [#_"LLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol LLLD
    #_abstract
    (#_"double" LLLD'''(§ method invokePrim) [#_"LLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol LLDO
    #_abstract
    (#_"Object" LLDO'''(§ method invokePrim) [#_"LLDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol LLDL
    #_abstract
    (#_"long" LLDL'''(§ method invokePrim) [#_"LLDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol LLDD
    #_abstract
    (#_"double" LLDD'''(§ method invokePrim) [#_"LLDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol LDOO
    #_abstract
    (#_"Object" LDOO'''(§ method invokePrim) [#_"LDOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol LDOL
    #_abstract
    (#_"long" LDOL'''(§ method invokePrim) [#_"LDOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol LDOD
    #_abstract
    (#_"double" LDOD'''(§ method invokePrim) [#_"LDOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol LDLO
    #_abstract
    (#_"Object" LDLO'''(§ method invokePrim) [#_"LDLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol LDLL
    #_abstract
    (#_"long" LDLL'''(§ method invokePrim) [#_"LDLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol LDLD
    #_abstract
    (#_"double" LDLD'''(§ method invokePrim) [#_"LDLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol LDDO
    #_abstract
    (#_"Object" LDDO'''(§ method invokePrim) [#_"LDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol LDDL
    #_abstract
    (#_"long" LDDL'''(§ method invokePrim) [#_"LDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol LDDD
    #_abstract
    (#_"double" LDDD'''(§ method invokePrim) [#_"LDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol DOOO
    #_abstract
    (#_"Object" DOOO'''(§ method invokePrim) [#_"DOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol DOOL
    #_abstract
    (#_"long" DOOL'''(§ method invokePrim) [#_"DOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol DOOD
    #_abstract
    (#_"double" DOOD'''(§ method invokePrim) [#_"DOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
)

(§ defprotocol DOLO
    #_abstract
    (#_"Object" DOLO'''(§ method invokePrim) [#_"DOLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol DOLL
    #_abstract
    (#_"long" DOLL'''(§ method invokePrim) [#_"DOLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol DOLD
    #_abstract
    (#_"double" DOLD'''(§ method invokePrim) [#_"DOLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
)

(§ defprotocol DODO
    #_abstract
    (#_"Object" DODO'''(§ method invokePrim) [#_"DODO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol DODL
    #_abstract
    (#_"long" DODL'''(§ method invokePrim) [#_"DODL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol DODD
    #_abstract
    (#_"double" DODD'''(§ method invokePrim) [#_"DODD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
)

(§ defprotocol DLOO
    #_abstract
    (#_"Object" DLOO'''(§ method invokePrim) [#_"DLOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol DLOL
    #_abstract
    (#_"long" DLOL'''(§ method invokePrim) [#_"DLOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol DLOD
    #_abstract
    (#_"double" DLOD'''(§ method invokePrim) [#_"DLOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
)

(§ defprotocol DLLO
    #_abstract
    (#_"Object" DLLO'''(§ method invokePrim) [#_"DLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol DLLL
    #_abstract
    (#_"long" DLLL'''(§ method invokePrim) [#_"DLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol DLLD
    #_abstract
    (#_"double" DLLD'''(§ method invokePrim) [#_"DLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
)

(§ defprotocol DLDO
    #_abstract
    (#_"Object" DLDO'''(§ method invokePrim) [#_"DLDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol DLDL
    #_abstract
    (#_"long" DLDL'''(§ method invokePrim) [#_"DLDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol DLDD
    #_abstract
    (#_"double" DLDD'''(§ method invokePrim) [#_"DLDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
)

(§ defprotocol DDOO
    #_abstract
    (#_"Object" DDOO'''(§ method invokePrim) [#_"DDOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol DDOL
    #_abstract
    (#_"long" DDOL'''(§ method invokePrim) [#_"DDOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol DDOD
    #_abstract
    (#_"double" DDOD'''(§ method invokePrim) [#_"DDOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
)

(§ defprotocol DDLO
    #_abstract
    (#_"Object" DDLO'''(§ method invokePrim) [#_"DDLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol DDLL
    #_abstract
    (#_"long" DDLL'''(§ method invokePrim) [#_"DDLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol DDLD
    #_abstract
    (#_"double" DDLD'''(§ method invokePrim) [#_"DDLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
)

(§ defprotocol DDDO
    #_abstract
    (#_"Object" DDDO'''(§ method invokePrim) [#_"DDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol DDDL
    #_abstract
    (#_"long" DDDL'''(§ method invokePrim) [#_"DDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol DDDD
    #_abstract
    (#_"double" DDDD'''(§ method invokePrim) [#_"DDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
)

(§ defprotocol OOOOL
    #_abstract
    (#_"long" OOOOL'''(§ method invokePrim) [#_"OOOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol OOOOD
    #_abstract
    (#_"double" OOOOD'''(§ method invokePrim) [#_"OOOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol OOOLO
    #_abstract
    (#_"Object" OOOLO'''(§ method invokePrim) [#_"OOOLO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol OOOLL
    #_abstract
    (#_"long" OOOLL'''(§ method invokePrim) [#_"OOOLL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol OOOLD
    #_abstract
    (#_"double" OOOLD'''(§ method invokePrim) [#_"OOOLD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol OOODO
    #_abstract
    (#_"Object" OOODO'''(§ method invokePrim) [#_"OOODO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol OOODL
    #_abstract
    (#_"long" OOODL'''(§ method invokePrim) [#_"OOODL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol OOODD
    #_abstract
    (#_"double" OOODD'''(§ method invokePrim) [#_"OOODD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol OOLOO
    #_abstract
    (#_"Object" OOLOO'''(§ method invokePrim) [#_"OOLOO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol OOLOL
    #_abstract
    (#_"long" OOLOL'''(§ method invokePrim) [#_"OOLOL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol OOLOD
    #_abstract
    (#_"double" OOLOD'''(§ method invokePrim) [#_"OOLOD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol OOLLO
    #_abstract
    (#_"Object" OOLLO'''(§ method invokePrim) [#_"OOLLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol OOLLL
    #_abstract
    (#_"long" OOLLL'''(§ method invokePrim) [#_"OOLLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol OOLLD
    #_abstract
    (#_"double" OOLLD'''(§ method invokePrim) [#_"OOLLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol OOLDO
    #_abstract
    (#_"Object" OOLDO'''(§ method invokePrim) [#_"OOLDO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol OOLDL
    #_abstract
    (#_"long" OOLDL'''(§ method invokePrim) [#_"OOLDL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol OOLDD
    #_abstract
    (#_"double" OOLDD'''(§ method invokePrim) [#_"OOLDD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol OODOO
    #_abstract
    (#_"Object" OODOO'''(§ method invokePrim) [#_"OODOO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol OODOL
    #_abstract
    (#_"long" OODOL'''(§ method invokePrim) [#_"OODOL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol OODOD
    #_abstract
    (#_"double" OODOD'''(§ method invokePrim) [#_"OODOD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol OODLO
    #_abstract
    (#_"Object" OODLO'''(§ method invokePrim) [#_"OODLO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol OODLL
    #_abstract
    (#_"long" OODLL'''(§ method invokePrim) [#_"OODLL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol OODLD
    #_abstract
    (#_"double" OODLD'''(§ method invokePrim) [#_"OODLD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol OODDO
    #_abstract
    (#_"Object" OODDO'''(§ method invokePrim) [#_"OODDO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol OODDL
    #_abstract
    (#_"long" OODDL'''(§ method invokePrim) [#_"OODDL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol OODDD
    #_abstract
    (#_"double" OODDD'''(§ method invokePrim) [#_"OODDD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol OLOOO
    #_abstract
    (#_"Object" OLOOO'''(§ method invokePrim) [#_"OLOOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol OLOOL
    #_abstract
    (#_"long" OLOOL'''(§ method invokePrim) [#_"OLOOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol OLOOD
    #_abstract
    (#_"double" OLOOD'''(§ method invokePrim) [#_"OLOOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol OLOLO
    #_abstract
    (#_"Object" OLOLO'''(§ method invokePrim) [#_"OLOLO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol OLOLL
    #_abstract
    (#_"long" OLOLL'''(§ method invokePrim) [#_"OLOLL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol OLOLD
    #_abstract
    (#_"double" OLOLD'''(§ method invokePrim) [#_"OLOLD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol OLODO
    #_abstract
    (#_"Object" OLODO'''(§ method invokePrim) [#_"OLODO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol OLODL
    #_abstract
    (#_"long" OLODL'''(§ method invokePrim) [#_"OLODL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol OLODD
    #_abstract
    (#_"double" OLODD'''(§ method invokePrim) [#_"OLODD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol OLLOO
    #_abstract
    (#_"Object" OLLOO'''(§ method invokePrim) [#_"OLLOO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol OLLOL
    #_abstract
    (#_"long" OLLOL'''(§ method invokePrim) [#_"OLLOL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol OLLOD
    #_abstract
    (#_"double" OLLOD'''(§ method invokePrim) [#_"OLLOD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol OLLLO
    #_abstract
    (#_"Object" OLLLO'''(§ method invokePrim) [#_"OLLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol OLLLL
    #_abstract
    (#_"long" OLLLL'''(§ method invokePrim) [#_"OLLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol OLLLD
    #_abstract
    (#_"double" OLLLD'''(§ method invokePrim) [#_"OLLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol OLLDO
    #_abstract
    (#_"Object" OLLDO'''(§ method invokePrim) [#_"OLLDO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol OLLDL
    #_abstract
    (#_"long" OLLDL'''(§ method invokePrim) [#_"OLLDL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol OLLDD
    #_abstract
    (#_"double" OLLDD'''(§ method invokePrim) [#_"OLLDD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol OLDOO
    #_abstract
    (#_"Object" OLDOO'''(§ method invokePrim) [#_"OLDOO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol OLDOL
    #_abstract
    (#_"long" OLDOL'''(§ method invokePrim) [#_"OLDOL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol OLDOD
    #_abstract
    (#_"double" OLDOD'''(§ method invokePrim) [#_"OLDOD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol OLDLO
    #_abstract
    (#_"Object" OLDLO'''(§ method invokePrim) [#_"OLDLO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol OLDLL
    #_abstract
    (#_"long" OLDLL'''(§ method invokePrim) [#_"OLDLL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol OLDLD
    #_abstract
    (#_"double" OLDLD'''(§ method invokePrim) [#_"OLDLD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol OLDDO
    #_abstract
    (#_"Object" OLDDO'''(§ method invokePrim) [#_"OLDDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol OLDDL
    #_abstract
    (#_"long" OLDDL'''(§ method invokePrim) [#_"OLDDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol OLDDD
    #_abstract
    (#_"double" OLDDD'''(§ method invokePrim) [#_"OLDDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol ODOOO
    #_abstract
    (#_"Object" ODOOO'''(§ method invokePrim) [#_"ODOOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol ODOOL
    #_abstract
    (#_"long" ODOOL'''(§ method invokePrim) [#_"ODOOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol ODOOD
    #_abstract
    (#_"double" ODOOD'''(§ method invokePrim) [#_"ODOOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol ODOLO
    #_abstract
    (#_"Object" ODOLO'''(§ method invokePrim) [#_"ODOLO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol ODOLL
    #_abstract
    (#_"long" ODOLL'''(§ method invokePrim) [#_"ODOLL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol ODOLD
    #_abstract
    (#_"double" ODOLD'''(§ method invokePrim) [#_"ODOLD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol ODODO
    #_abstract
    (#_"Object" ODODO'''(§ method invokePrim) [#_"ODODO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol ODODL
    #_abstract
    (#_"long" ODODL'''(§ method invokePrim) [#_"ODODL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol ODODD
    #_abstract
    (#_"double" ODODD'''(§ method invokePrim) [#_"ODODD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol ODLOO
    #_abstract
    (#_"Object" ODLOO'''(§ method invokePrim) [#_"ODLOO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol ODLOL
    #_abstract
    (#_"long" ODLOL'''(§ method invokePrim) [#_"ODLOL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol ODLOD
    #_abstract
    (#_"double" ODLOD'''(§ method invokePrim) [#_"ODLOD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol ODLLO
    #_abstract
    (#_"Object" ODLLO'''(§ method invokePrim) [#_"ODLLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol ODLLL
    #_abstract
    (#_"long" ODLLL'''(§ method invokePrim) [#_"ODLLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol ODLLD
    #_abstract
    (#_"double" ODLLD'''(§ method invokePrim) [#_"ODLLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol ODLDO
    #_abstract
    (#_"Object" ODLDO'''(§ method invokePrim) [#_"ODLDO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol ODLDL
    #_abstract
    (#_"long" ODLDL'''(§ method invokePrim) [#_"ODLDL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol ODLDD
    #_abstract
    (#_"double" ODLDD'''(§ method invokePrim) [#_"ODLDD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol ODDOO
    #_abstract
    (#_"Object" ODDOO'''(§ method invokePrim) [#_"ODDOO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol ODDOL
    #_abstract
    (#_"long" ODDOL'''(§ method invokePrim) [#_"ODDOL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol ODDOD
    #_abstract
    (#_"double" ODDOD'''(§ method invokePrim) [#_"ODDOD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol ODDLO
    #_abstract
    (#_"Object" ODDLO'''(§ method invokePrim) [#_"ODDLO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol ODDLL
    #_abstract
    (#_"long" ODDLL'''(§ method invokePrim) [#_"ODDLL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol ODDLD
    #_abstract
    (#_"double" ODDLD'''(§ method invokePrim) [#_"ODDLD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol ODDDO
    #_abstract
    (#_"Object" ODDDO'''(§ method invokePrim) [#_"ODDDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol ODDDL
    #_abstract
    (#_"long" ODDDL'''(§ method invokePrim) [#_"ODDDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol ODDDD
    #_abstract
    (#_"double" ODDDD'''(§ method invokePrim) [#_"ODDDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LOOOO
    #_abstract
    (#_"Object" LOOOO'''(§ method invokePrim) [#_"LOOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LOOOL
    #_abstract
    (#_"long" LOOOL'''(§ method invokePrim) [#_"LOOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LOOOD
    #_abstract
    (#_"double" LOOOD'''(§ method invokePrim) [#_"LOOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LOOLO
    #_abstract
    (#_"Object" LOOLO'''(§ method invokePrim) [#_"LOOLO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LOOLL
    #_abstract
    (#_"long" LOOLL'''(§ method invokePrim) [#_"LOOLL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LOOLD
    #_abstract
    (#_"double" LOOLD'''(§ method invokePrim) [#_"LOOLD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LOODO
    #_abstract
    (#_"Object" LOODO'''(§ method invokePrim) [#_"LOODO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LOODL
    #_abstract
    (#_"long" LOODL'''(§ method invokePrim) [#_"LOODL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LOODD
    #_abstract
    (#_"double" LOODD'''(§ method invokePrim) [#_"LOODD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LOLOO
    #_abstract
    (#_"Object" LOLOO'''(§ method invokePrim) [#_"LOLOO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LOLOL
    #_abstract
    (#_"long" LOLOL'''(§ method invokePrim) [#_"LOLOL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LOLOD
    #_abstract
    (#_"double" LOLOD'''(§ method invokePrim) [#_"LOLOD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LOLLO
    #_abstract
    (#_"Object" LOLLO'''(§ method invokePrim) [#_"LOLLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LOLLL
    #_abstract
    (#_"long" LOLLL'''(§ method invokePrim) [#_"LOLLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LOLLD
    #_abstract
    (#_"double" LOLLD'''(§ method invokePrim) [#_"LOLLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LOLDO
    #_abstract
    (#_"Object" LOLDO'''(§ method invokePrim) [#_"LOLDO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LOLDL
    #_abstract
    (#_"long" LOLDL'''(§ method invokePrim) [#_"LOLDL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LOLDD
    #_abstract
    (#_"double" LOLDD'''(§ method invokePrim) [#_"LOLDD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LODOO
    #_abstract
    (#_"Object" LODOO'''(§ method invokePrim) [#_"LODOO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LODOL
    #_abstract
    (#_"long" LODOL'''(§ method invokePrim) [#_"LODOL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LODOD
    #_abstract
    (#_"double" LODOD'''(§ method invokePrim) [#_"LODOD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LODLO
    #_abstract
    (#_"Object" LODLO'''(§ method invokePrim) [#_"LODLO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LODLL
    #_abstract
    (#_"long" LODLL'''(§ method invokePrim) [#_"LODLL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LODLD
    #_abstract
    (#_"double" LODLD'''(§ method invokePrim) [#_"LODLD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LODDO
    #_abstract
    (#_"Object" LODDO'''(§ method invokePrim) [#_"LODDO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LODDL
    #_abstract
    (#_"long" LODDL'''(§ method invokePrim) [#_"LODDL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LODDD
    #_abstract
    (#_"double" LODDD'''(§ method invokePrim) [#_"LODDD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LLOOO
    #_abstract
    (#_"Object" LLOOO'''(§ method invokePrim) [#_"LLOOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LLOOL
    #_abstract
    (#_"long" LLOOL'''(§ method invokePrim) [#_"LLOOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LLOOD
    #_abstract
    (#_"double" LLOOD'''(§ method invokePrim) [#_"LLOOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LLOLO
    #_abstract
    (#_"Object" LLOLO'''(§ method invokePrim) [#_"LLOLO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LLOLL
    #_abstract
    (#_"long" LLOLL'''(§ method invokePrim) [#_"LLOLL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LLOLD
    #_abstract
    (#_"double" LLOLD'''(§ method invokePrim) [#_"LLOLD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LLODO
    #_abstract
    (#_"Object" LLODO'''(§ method invokePrim) [#_"LLODO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LLODL
    #_abstract
    (#_"long" LLODL'''(§ method invokePrim) [#_"LLODL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LLODD
    #_abstract
    (#_"double" LLODD'''(§ method invokePrim) [#_"LLODD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LLLOO
    #_abstract
    (#_"Object" LLLOO'''(§ method invokePrim) [#_"LLLOO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LLLOL
    #_abstract
    (#_"long" LLLOL'''(§ method invokePrim) [#_"LLLOL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LLLOD
    #_abstract
    (#_"double" LLLOD'''(§ method invokePrim) [#_"LLLOD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LLLLO
    #_abstract
    (#_"Object" LLLLO'''(§ method invokePrim) [#_"LLLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LLLLL
    #_abstract
    (#_"long" LLLLL'''(§ method invokePrim) [#_"LLLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LLLLD
    #_abstract
    (#_"double" LLLLD'''(§ method invokePrim) [#_"LLLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LLLDO
    #_abstract
    (#_"Object" LLLDO'''(§ method invokePrim) [#_"LLLDO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LLLDL
    #_abstract
    (#_"long" LLLDL'''(§ method invokePrim) [#_"LLLDL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LLLDD
    #_abstract
    (#_"double" LLLDD'''(§ method invokePrim) [#_"LLLDD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LLDOO
    #_abstract
    (#_"Object" LLDOO'''(§ method invokePrim) [#_"LLDOO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LLDOL
    #_abstract
    (#_"long" LLDOL'''(§ method invokePrim) [#_"LLDOL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LLDOD
    #_abstract
    (#_"double" LLDOD'''(§ method invokePrim) [#_"LLDOD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LLDLO
    #_abstract
    (#_"Object" LLDLO'''(§ method invokePrim) [#_"LLDLO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LLDLL
    #_abstract
    (#_"long" LLDLL'''(§ method invokePrim) [#_"LLDLL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LLDLD
    #_abstract
    (#_"double" LLDLD'''(§ method invokePrim) [#_"LLDLD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LLDDO
    #_abstract
    (#_"Object" LLDDO'''(§ method invokePrim) [#_"LLDDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LLDDL
    #_abstract
    (#_"long" LLDDL'''(§ method invokePrim) [#_"LLDDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LLDDD
    #_abstract
    (#_"double" LLDDD'''(§ method invokePrim) [#_"LLDDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LDOOO
    #_abstract
    (#_"Object" LDOOO'''(§ method invokePrim) [#_"LDOOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LDOOL
    #_abstract
    (#_"long" LDOOL'''(§ method invokePrim) [#_"LDOOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LDOOD
    #_abstract
    (#_"double" LDOOD'''(§ method invokePrim) [#_"LDOOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol LDOLO
    #_abstract
    (#_"Object" LDOLO'''(§ method invokePrim) [#_"LDOLO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LDOLL
    #_abstract
    (#_"long" LDOLL'''(§ method invokePrim) [#_"LDOLL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LDOLD
    #_abstract
    (#_"double" LDOLD'''(§ method invokePrim) [#_"LDOLD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol LDODO
    #_abstract
    (#_"Object" LDODO'''(§ method invokePrim) [#_"LDODO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LDODL
    #_abstract
    (#_"long" LDODL'''(§ method invokePrim) [#_"LDODL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LDODD
    #_abstract
    (#_"double" LDODD'''(§ method invokePrim) [#_"LDODD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol LDLOO
    #_abstract
    (#_"Object" LDLOO'''(§ method invokePrim) [#_"LDLOO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LDLOL
    #_abstract
    (#_"long" LDLOL'''(§ method invokePrim) [#_"LDLOL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LDLOD
    #_abstract
    (#_"double" LDLOD'''(§ method invokePrim) [#_"LDLOD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol LDLLO
    #_abstract
    (#_"Object" LDLLO'''(§ method invokePrim) [#_"LDLLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LDLLL
    #_abstract
    (#_"long" LDLLL'''(§ method invokePrim) [#_"LDLLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LDLLD
    #_abstract
    (#_"double" LDLLD'''(§ method invokePrim) [#_"LDLLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol LDLDO
    #_abstract
    (#_"Object" LDLDO'''(§ method invokePrim) [#_"LDLDO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LDLDL
    #_abstract
    (#_"long" LDLDL'''(§ method invokePrim) [#_"LDLDL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LDLDD
    #_abstract
    (#_"double" LDLDD'''(§ method invokePrim) [#_"LDLDD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol LDDOO
    #_abstract
    (#_"Object" LDDOO'''(§ method invokePrim) [#_"LDDOO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LDDOL
    #_abstract
    (#_"long" LDDOL'''(§ method invokePrim) [#_"LDDOL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LDDOD
    #_abstract
    (#_"double" LDDOD'''(§ method invokePrim) [#_"LDDOD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol LDDLO
    #_abstract
    (#_"Object" LDDLO'''(§ method invokePrim) [#_"LDDLO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LDDLL
    #_abstract
    (#_"long" LDDLL'''(§ method invokePrim) [#_"LDDLL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LDDLD
    #_abstract
    (#_"double" LDDLD'''(§ method invokePrim) [#_"LDDLD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol LDDDO
    #_abstract
    (#_"Object" LDDDO'''(§ method invokePrim) [#_"LDDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LDDDL
    #_abstract
    (#_"long" LDDDL'''(§ method invokePrim) [#_"LDDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol LDDDD
    #_abstract
    (#_"double" LDDDD'''(§ method invokePrim) [#_"LDDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DOOOO
    #_abstract
    (#_"Object" DOOOO'''(§ method invokePrim) [#_"DOOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DOOOL
    #_abstract
    (#_"long" DOOOL'''(§ method invokePrim) [#_"DOOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DOOOD
    #_abstract
    (#_"double" DOOOD'''(§ method invokePrim) [#_"DOOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DOOLO
    #_abstract
    (#_"Object" DOOLO'''(§ method invokePrim) [#_"DOOLO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DOOLL
    #_abstract
    (#_"long" DOOLL'''(§ method invokePrim) [#_"DOOLL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DOOLD
    #_abstract
    (#_"double" DOOLD'''(§ method invokePrim) [#_"DOOLD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DOODO
    #_abstract
    (#_"Object" DOODO'''(§ method invokePrim) [#_"DOODO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DOODL
    #_abstract
    (#_"long" DOODL'''(§ method invokePrim) [#_"DOODL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DOODD
    #_abstract
    (#_"double" DOODD'''(§ method invokePrim) [#_"DOODD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DOLOO
    #_abstract
    (#_"Object" DOLOO'''(§ method invokePrim) [#_"DOLOO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DOLOL
    #_abstract
    (#_"long" DOLOL'''(§ method invokePrim) [#_"DOLOL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DOLOD
    #_abstract
    (#_"double" DOLOD'''(§ method invokePrim) [#_"DOLOD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DOLLO
    #_abstract
    (#_"Object" DOLLO'''(§ method invokePrim) [#_"DOLLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DOLLL
    #_abstract
    (#_"long" DOLLL'''(§ method invokePrim) [#_"DOLLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DOLLD
    #_abstract
    (#_"double" DOLLD'''(§ method invokePrim) [#_"DOLLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DOLDO
    #_abstract
    (#_"Object" DOLDO'''(§ method invokePrim) [#_"DOLDO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DOLDL
    #_abstract
    (#_"long" DOLDL'''(§ method invokePrim) [#_"DOLDL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DOLDD
    #_abstract
    (#_"double" DOLDD'''(§ method invokePrim) [#_"DOLDD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DODOO
    #_abstract
    (#_"Object" DODOO'''(§ method invokePrim) [#_"DODOO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DODOL
    #_abstract
    (#_"long" DODOL'''(§ method invokePrim) [#_"DODOL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DODOD
    #_abstract
    (#_"double" DODOD'''(§ method invokePrim) [#_"DODOD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DODLO
    #_abstract
    (#_"Object" DODLO'''(§ method invokePrim) [#_"DODLO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DODLL
    #_abstract
    (#_"long" DODLL'''(§ method invokePrim) [#_"DODLL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DODLD
    #_abstract
    (#_"double" DODLD'''(§ method invokePrim) [#_"DODLD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DODDO
    #_abstract
    (#_"Object" DODDO'''(§ method invokePrim) [#_"DODDO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DODDL
    #_abstract
    (#_"long" DODDL'''(§ method invokePrim) [#_"DODDL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DODDD
    #_abstract
    (#_"double" DODDD'''(§ method invokePrim) [#_"DODDD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DLOOO
    #_abstract
    (#_"Object" DLOOO'''(§ method invokePrim) [#_"DLOOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DLOOL
    #_abstract
    (#_"long" DLOOL'''(§ method invokePrim) [#_"DLOOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DLOOD
    #_abstract
    (#_"double" DLOOD'''(§ method invokePrim) [#_"DLOOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DLOLO
    #_abstract
    (#_"Object" DLOLO'''(§ method invokePrim) [#_"DLOLO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DLOLL
    #_abstract
    (#_"long" DLOLL'''(§ method invokePrim) [#_"DLOLL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DLOLD
    #_abstract
    (#_"double" DLOLD'''(§ method invokePrim) [#_"DLOLD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DLODO
    #_abstract
    (#_"Object" DLODO'''(§ method invokePrim) [#_"DLODO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DLODL
    #_abstract
    (#_"long" DLODL'''(§ method invokePrim) [#_"DLODL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DLODD
    #_abstract
    (#_"double" DLODD'''(§ method invokePrim) [#_"DLODD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DLLOO
    #_abstract
    (#_"Object" DLLOO'''(§ method invokePrim) [#_"DLLOO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DLLOL
    #_abstract
    (#_"long" DLLOL'''(§ method invokePrim) [#_"DLLOL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DLLOD
    #_abstract
    (#_"double" DLLOD'''(§ method invokePrim) [#_"DLLOD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DLLLO
    #_abstract
    (#_"Object" DLLLO'''(§ method invokePrim) [#_"DLLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DLLLL
    #_abstract
    (#_"long" DLLLL'''(§ method invokePrim) [#_"DLLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DLLLD
    #_abstract
    (#_"double" DLLLD'''(§ method invokePrim) [#_"DLLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DLLDO
    #_abstract
    (#_"Object" DLLDO'''(§ method invokePrim) [#_"DLLDO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DLLDL
    #_abstract
    (#_"long" DLLDL'''(§ method invokePrim) [#_"DLLDL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DLLDD
    #_abstract
    (#_"double" DLLDD'''(§ method invokePrim) [#_"DLLDD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DLDOO
    #_abstract
    (#_"Object" DLDOO'''(§ method invokePrim) [#_"DLDOO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DLDOL
    #_abstract
    (#_"long" DLDOL'''(§ method invokePrim) [#_"DLDOL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DLDOD
    #_abstract
    (#_"double" DLDOD'''(§ method invokePrim) [#_"DLDOD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DLDLO
    #_abstract
    (#_"Object" DLDLO'''(§ method invokePrim) [#_"DLDLO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DLDLL
    #_abstract
    (#_"long" DLDLL'''(§ method invokePrim) [#_"DLDLL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DLDLD
    #_abstract
    (#_"double" DLDLD'''(§ method invokePrim) [#_"DLDLD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DLDDO
    #_abstract
    (#_"Object" DLDDO'''(§ method invokePrim) [#_"DLDDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DLDDL
    #_abstract
    (#_"long" DLDDL'''(§ method invokePrim) [#_"DLDDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DLDDD
    #_abstract
    (#_"double" DLDDD'''(§ method invokePrim) [#_"DLDDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DDOOO
    #_abstract
    (#_"Object" DDOOO'''(§ method invokePrim) [#_"DDOOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DDOOL
    #_abstract
    (#_"long" DDOOL'''(§ method invokePrim) [#_"DDOOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DDOOD
    #_abstract
    (#_"double" DDOOD'''(§ method invokePrim) [#_"DDOOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(§ defprotocol DDOLO
    #_abstract
    (#_"Object" DDOLO'''(§ method invokePrim) [#_"DDOLO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DDOLL
    #_abstract
    (#_"long" DDOLL'''(§ method invokePrim) [#_"DDOLL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DDOLD
    #_abstract
    (#_"double" DDOLD'''(§ method invokePrim) [#_"DDOLD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(§ defprotocol DDODO
    #_abstract
    (#_"Object" DDODO'''(§ method invokePrim) [#_"DDODO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DDODL
    #_abstract
    (#_"long" DDODL'''(§ method invokePrim) [#_"DDODL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DDODD
    #_abstract
    (#_"double" DDODD'''(§ method invokePrim) [#_"DDODD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(§ defprotocol DDLOO
    #_abstract
    (#_"Object" DDLOO'''(§ method invokePrim) [#_"DDLOO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DDLOL
    #_abstract
    (#_"long" DDLOL'''(§ method invokePrim) [#_"DDLOL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DDLOD
    #_abstract
    (#_"double" DDLOD'''(§ method invokePrim) [#_"DDLOD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(§ defprotocol DDLLO
    #_abstract
    (#_"Object" DDLLO'''(§ method invokePrim) [#_"DDLLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DDLLL
    #_abstract
    (#_"long" DDLLL'''(§ method invokePrim) [#_"DDLLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DDLLD
    #_abstract
    (#_"double" DDLLD'''(§ method invokePrim) [#_"DDLLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(§ defprotocol DDLDO
    #_abstract
    (#_"Object" DDLDO'''(§ method invokePrim) [#_"DDLDO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DDLDL
    #_abstract
    (#_"long" DDLDL'''(§ method invokePrim) [#_"DDLDL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DDLDD
    #_abstract
    (#_"double" DDLDD'''(§ method invokePrim) [#_"DDLDD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(§ defprotocol DDDOO
    #_abstract
    (#_"Object" DDDOO'''(§ method invokePrim) [#_"DDDOO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DDDOL
    #_abstract
    (#_"long" DDDOL'''(§ method invokePrim) [#_"DDDOL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DDDOD
    #_abstract
    (#_"double" DDDOD'''(§ method invokePrim) [#_"DDDOD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(§ defprotocol DDDLO
    #_abstract
    (#_"Object" DDDLO'''(§ method invokePrim) [#_"DDDLO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DDDLL
    #_abstract
    (#_"long" DDDLL'''(§ method invokePrim) [#_"DDDLL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DDDLD
    #_abstract
    (#_"double" DDDLD'''(§ method invokePrim) [#_"DDDLD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(§ defprotocol DDDDO
    #_abstract
    (#_"Object" DDDDO'''(§ method invokePrim) [#_"DDDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DDDDL
    #_abstract
    (#_"long" DDDDL'''(§ method invokePrim) [#_"DDDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(§ defprotocol DDDDD
    #_abstract
    (#_"double" DDDDD'''(§ method invokePrim) [#_"DDDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ defprotocol IFn #_(§ extends Callable, Runnable)
    #_abstract
    (#_"Object" IFn'''(§ method invoke-1) [#_"IFn" this])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-2) [#_"IFn" this, #_"Object" arg1])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-3) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-4) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-5) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-6) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-7) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-8) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-9) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-10) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-11) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-12) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-13) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-14) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-15) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-16) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-17) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-18) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-19) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18])

    #_abstract
  #_(#_"Object" IFn'''(§ method invoke-20) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
  #_(#_"Object" IFn'''(§ method invoke-21) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-22) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" #_arg19, #_"Object" #_arg20 & #_"Object..." args])

    #_abstract
    (#_"Object" IFn'''(§ method applyTo) [#_"IFn" this, #_"ISeq" args])
)
)

(java-ns cloiure.lang.IHashEq

(§ defprotocol IHashEq
    #_abstract
    (#_"int" IHashEq'''(§ method hasheq) [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ defprotocol IKeywordLookup
    #_abstract
    (#_"ILookupThunk" IKeywordLookup'''(§ method getLookupThunk) [#_"IKeywordLookup" this, #_"Keyword" k])
)
)

(java-ns cloiure.lang.IKVReduce

(§ defprotocol IKVReduce
    #_abstract
    (#_"Object" IKVReduce'''(§ method kvreduce) [#_"IKVReduce" this, #_"IFn" f, #_"Object" init])
)
)

(java-ns cloiure.lang.ILookup

(§ defprotocol ILookup
    #_abstract
    (#_"Object" ILookup'''(§ method valAt-2) [#_"ILookup" this, #_"Object" key])
    #_abstract
    (#_"Object" ILookup'''(§ method valAt-3) [#_"ILookup" this, #_"Object" key, #_"Object" notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(§ defprotocol ILookupSite
    #_abstract
    (#_"ILookupThunk" ILookupSite'''(§ method fault) [#_"ILookupSite" this, #_"Object" target])
)
)

(java-ns cloiure.lang.ILookupThunk

(§ defprotocol ILookupThunk
    #_abstract
    (#_"Object" ILookupThunk'''(§ method get) [#_"ILookupThunk" this, #_"Object" target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ defprotocol IMapEntry #_(§ extends Map$Entry)
    #_abstract
    (#_"Object" IMapEntry'''(§ method key) [#_"IMapEntry" this])
    #_abstract
    (#_"Object" IMapEntry'''(§ method val) [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ defprotocol IMapIterable
    #_abstract
    (#_"Iterator" IMapIterable'''(§ method keyIterator) [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" IMapIterable'''(§ method valIterator) [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(§ defprotocol IMeta
    #_abstract
    (#_"IPersistentMap" IMeta'''(§ method meta) [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(§ defprotocol Indexed #_(§ extends Counted)
    #_abstract
    (#_"Object" Indexed'''(§ method nth-2) [#_"Indexed" this, #_"int" i])
    #_abstract
    (#_"Object" Indexed'''(§ method nth-3) [#_"Indexed" this, #_"int" i, #_"Object" notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(§ defprotocol IndexedSeq #_(§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" IndexedSeq'''(§ method index) [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (defn- #_"Object[]" Intrinsics'oa [& #_"Object..." arr]
        arr
    )

    (§ def #_"IPersistentMap" Intrinsics'ops (RT'map
        (object-array [
            "public static double cloiure.lang.Numbers.add(double,double)"                Opcodes/DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      Opcodes/LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       Opcodes/LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      Opcodes/LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           Opcodes/DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             Opcodes/DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                Opcodes/LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (Intrinsics'oa Opcodes/L2I, Opcodes/LSHL)
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (Intrinsics'oa Opcodes/L2I, Opcodes/LSHR)
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (Intrinsics'oa Opcodes/L2I, Opcodes/LUSHR)
            "public static double cloiure.lang.Numbers.minus(double)"                     Opcodes/DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              Opcodes/DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static double cloiure.lang.Numbers.dec(double)"                       (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 Opcodes/LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                Opcodes/ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               Opcodes/ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       Opcodes/IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           Opcodes/IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      Opcodes/ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            Opcodes/INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (Intrinsics'oa Opcodes/ICONST_1, Opcodes/IADD)
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (Intrinsics'oa Opcodes/ICONST_1, Opcodes/ISUB)
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      Opcodes/IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        Opcodes/IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     Opcodes/IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            Opcodes/LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      Opcodes/DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               Opcodes/LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           Opcodes/DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    Opcodes/DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          Opcodes/LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       Opcodes/LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" Opcodes/DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (Intrinsics'oa Opcodes/LCONST_1, Opcodes/LADD)
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (Intrinsics'oa Opcodes/LCONST_1, Opcodes/LSUB)

            "public static boolean cloiure.lang.RT.aget_boolean(boolean[],int)"                  Opcodes/BALOAD
            "public static byte cloiure.lang.RT.aget_byte(byte[],int)"                           Opcodes/BALOAD
            "public static short cloiure.lang.RT.aget_short(short[],int)"                        Opcodes/SALOAD
            "public static char cloiure.lang.RT.aget_char(char[],int)"                           Opcodes/CALOAD
            "public static int cloiure.lang.RT.aget_int(int[],int)"                              Opcodes/IALOAD
            "public static long cloiure.lang.RT.aget_long(long[],int)"                           Opcodes/LALOAD
            "public static float cloiure.lang.RT.aget_float(float[],int)"                        Opcodes/FALOAD
            "public static double cloiure.lang.RT.aget_double(double[],int)"                     Opcodes/DALOAD
            "public static java.lang.Object cloiure.lang.RT.aget_object(java.lang.Object[],int)" Opcodes/AALOAD

            "public static int cloiure.lang.RT.alength_boolean(boolean[])"         Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_byte(byte[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_short(short[])"             Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_char(char[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_int(int[])"                 Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_long(long[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_float(float[])"             Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_double(double[])"           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_object(java.lang.Object[])" Opcodes/ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            Opcodes/L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          Opcodes/NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           Opcodes/F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" Opcodes/NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  Opcodes/F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   Opcodes/L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   Opcodes/I2D
            "public static long cloiure.lang.RT.longCast(long)"                Opcodes/NOP
            "public static long cloiure.lang.RT.longCast(short)"               Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(byte)"                Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(int)"                 Opcodes/I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         Opcodes/L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       Opcodes/D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        Opcodes/F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      Opcodes/F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     Opcodes/D2L
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       Opcodes/NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        Opcodes/I2L
        ])
    ))

    ;; map to instructions terminated with comparator for branch to false
    (§ def #_"IPersistentMap" Intrinsics'preds (RT'map
        (object-array [
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (Intrinsics'oa Opcodes/DCMPG, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (Intrinsics'oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (Intrinsics'oa Opcodes/DCMPG, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (Intrinsics'oa Opcodes/LCMP, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (Intrinsics'oa Opcodes/LCMP, Opcodes/IFLT)
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFLT)
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (Intrinsics'oa Opcodes/IF_ICMPNE)
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFNE)

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPG, Opcodes/IFGE)
        ])
    ))
)
)

(java-ns cloiure.lang.IObj

(§ defprotocol IObj #_(§ extends IMeta)
    #_abstract
    (#_"IObj" IObj'''(§ method withMeta) [#_"IObj" this, #_"IPersistentMap" meta])
)
)

(java-ns cloiure.lang.IPending

(§ defprotocol IPending
    #_abstract
    (#_"boolean" IPending'''(§ method isRealized) [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ defprotocol IPersistentCollection #_(§ extends Seqable)
    #_abstract
    (#_"int" #_"IPersistentCollection'''" Counted'''count [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''(§ method cons) [#_"IPersistentCollection" this, #_"Object" o])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''(§ method empty) [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" IPersistentCollection'''(§ method equiv) [#_"IPersistentCollection" this, #_"Object" o])
)
)

(java-ns cloiure.lang.IPersistentList

(§ defprotocol IPersistentList #_(§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ defprotocol IPersistentMap #_(§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method assoc) [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method assocEx) [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method without) [#_"IPersistentMap" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IPersistentSet

(§ defprotocol IPersistentSet #_(§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" IPersistentSet'''(§ method disjoin) [#_"IPersistentSet" this, #_"Object" key])
    #_abstract
    (#_"boolean" IPersistentSet'''(§ method contains) [#_"IPersistentSet" this, #_"Object" key])
    #_abstract
    (#_"Object" IPersistentSet'''(§ method get) [#_"IPersistentSet" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IPersistentStack

(§ defprotocol IPersistentStack #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" IPersistentStack'''(§ method peek) [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" IPersistentStack'''(§ method pop) [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(§ defprotocol IPersistentVector #_(§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" IPersistentVector'''(§ method length) [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''(§ method assocN) [#_"IPersistentVector" this, #_"int" i, #_"Object" val])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''(§ method cons) [#_"IPersistentVector" this, #_"Object" o])
)
)

(java-ns cloiure.lang.IProxy

(§ defprotocol IProxy
    #_abstract
    (#_"void" IProxy'''(§ method __initCloiureFnMappings) [#_"IProxy" this, #_"IPersistentMap" m])
    #_abstract
    (#_"void" IProxy'''(§ method __updateCloiureFnMappings) [#_"IProxy" this, #_"IPersistentMap" m])
    #_abstract
    (#_"IPersistentMap" IProxy'''(§ method __getCloiureFnMappings) [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(§ defprotocol IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ defprotocol IReduce #_(§ extends IReduceInit)
    #_abstract
    (#_"Object" IReduce'''(§ method reduce) [#_"IReduce" this, #_"IFn" f])
)
)

(java-ns cloiure.lang.IReduceInit

(§ defprotocol IReduceInit
    #_abstract
    (#_"Object" IReduceInit'''(§ method reduce) [#_"IReduceInit" this, #_"IFn" f, #_"Object" start])
)
)

(java-ns cloiure.lang.IRef

(§ defprotocol IRef #_(§ extends IDeref)
    #_abstract
    (#_"void" IRef'''(§ method setValidator) [#_"IRef" this, #_"IFn" vf])
    #_abstract
    (#_"IFn" IRef'''(§ method getValidator) [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" IRef'''(§ method getWatches) [#_"IRef" this])
    #_abstract
    (#_"IRef" IRef'''(§ method addWatch) [#_"IRef" this, #_"Object" key, #_"IFn" callback])
    #_abstract
    (#_"IRef" IRef'''(§ method removeWatch) [#_"IRef" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IReference

(§ defprotocol IReference #_(§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" IReference'''(§ method alterMeta) [#_"IReference" this, #_"IFn" alter, #_"ISeq" args])
    #_abstract
    (#_"IPersistentMap" IReference'''(§ method resetMeta) [#_"IReference" this, #_"IPersistentMap" m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ defprotocol ISeq #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" ISeq'''first [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''next [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method more) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method cons) [#_"ISeq" this, #_"Object" o])
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (defn- #_"Iterate" Iterate'init []
        (hash-map
            #_"IFn" :f nil ;; never nil
            #_"Object" :prevSeed nil
            #_volatile
            #_"Object" :_seed nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Iterate" Iterate'new-3 [#_"IFn" f, #_"Object" prevSeed, #_"Object" seed]
        (let [this (merge (ASeq'new) (Iterate'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :prevSeed prevSeed))
            (§ ass this (assoc this :_seed seed))
            this
        )
    )

    (defn- #_"Iterate" Iterate'new-5 [#_"IPersistentMap" meta, #_"IFn" f, #_"Object" prevSeed, #_"Object" seed, #_"ISeq" next]
        (let [this (merge (ASeq'new meta) (Iterate'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :prevSeed prevSeed))
            (§ ass this (assoc this :_seed seed))
            (§ ass this (assoc this :_next next))
            this
        )
    )

    (defn #_"ISeq" Iterate'create [#_"IFn" f, #_"Object" seed]
        (Iterate'new-3 f, nil, seed)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Iterate" this]
        (not= (:_seed this) Iterate'UNREALIZED_SEED)
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"Iterate" this]
        (when (= (:_seed this) Iterate'UNREALIZED_SEED)
            (§ ass this (assoc this :_seed (.invoke (:f this), (:prevSeed this))))
        )
        (:_seed this)
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"Iterate" this]
        (when (nil? (:_next this))
            (§ ass this (assoc this :_next (Iterate'new-3 (:f this), (.first this), Iterate'UNREALIZED_SEED)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Iterate" (§ method withMeta) [#_"Iterate" this, #_"IPersistentMap" meta]
        (Iterate'new-5 meta, (:f this), (:prevSeed this), (:_seed this), (:_next this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Iterate" this, #_"IFn" f]
        (loop [#_"Object" r (.first this) #_"Object" v (.invoke (:f this), r)]
            (let [r (.invoke f, r, v)]
                (when-not (RT'isReduced r) => (.deref (cast' IDeref r))
                    (recur r (.invoke (:f this), v))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Iterate" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"Object" v (.first this)]
            (let [r (.invoke f, r, v)]
                (when-not (RT'isReduced r) => (.deref (cast' IDeref r))
                    (recur r (.invoke (:f this), v))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeqState
    (defn- #_"IteratorSeqState" IteratorSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"IteratorSeqState" IteratorSeqState'new []
        (IteratorSeqState'init)
    )
)

(class-ns IteratorSeq (§ extends ASeq)
    (defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" iter]
        (when (.hasNext iter)
            (IteratorSeq'new-1 iter)
        )
    )

    (defn- #_"IteratorSeq" IteratorSeq'init []
        (hash-map
            #_"Iterator" :iter nil
            #_"IteratorSeqState" :state nil
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-1 [#_"Iterator" iter]
        (let [this (merge (ASeq'new) (IteratorSeq'init))]
            (§ ass this (assoc this :iter iter))
            (§ ass this (assoc this :state (IteratorSeqState'new)))
            (§ ass (:val (:state this)) (:state this))
            (§ ass (:_rest (:state this)) (:state this))
            this
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-3 [#_"IPersistentMap" meta, #_"Iterator" iter, #_"IteratorSeqState" state]
        (let [this (merge (ASeq'new meta) (IteratorSeq'init))]
            (§ ass this (assoc this :iter iter))
            (§ ass this (assoc this :state state))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"IteratorSeq" this]
        (when (= (:val (:state this)) (:state this))
            (§ sync (:state this)
                (when (= (:val (:state this)) (:state this))
                    (§ ass (:val (:state this)) (.next (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"IteratorSeq" this]
        (when (= (:_rest (:state this)) (:state this))
            (§ sync (:state this)
                (when (= (:_rest (:state this)) (:state this))
                    (.first this)
                    (§ ass (:_rest (:state this)) (IteratorSeq'create (:iter this)))
                )
            )
        )
        (cast' ISeq (:_rest (:state this)))
    )

    #_method
    (§ defn #_"IteratorSeq" (§ method withMeta) [#_"IteratorSeq" this, #_"IPersistentMap" meta]
        (IteratorSeq'new-3 meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ defprotocol ITransientAssociative #_(§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" ITransientAssociative'''(§ method assoc) [#_"ITransientAssociative" this, #_"Object" key, #_"Object" val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ defprotocol ITransientAssociative2 #_(§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" ITransientAssociative2'''(§ method containsKey) [#_"ITransientAssociative2" this, #_"Object" key])
    #_abstract
    (#_"IMapEntry" ITransientAssociative2'''(§ method entryAt) [#_"ITransientAssociative2" this, #_"Object" key])
)
)

(java-ns cloiure.lang.ITransientCollection

(§ defprotocol ITransientCollection
    #_abstract
    (#_"ITransientCollection" ITransientCollection'''(§ method conj) [#_"ITransientCollection" this, #_"Object" val])
    #_abstract
    (#_"IPersistentCollection" ITransientCollection'''(§ method persistent) [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(§ defprotocol ITransientMap #_(§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" ITransientMap'''(§ method assoc) [#_"ITransientMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"ITransientMap" ITransientMap'''(§ method without) [#_"ITransientMap" this, #_"Object" key])
    #_abstract
    (#_"IPersistentMap" ITransientMap'''(§ method persistent) [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(§ defprotocol ITransientSet #_(§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" ITransientSet'''(§ method disjoin) [#_"ITransientSet" this, #_"Object" key])
    #_abstract
    (#_"boolean" ITransientSet'''(§ method contains) [#_"ITransientSet" this, #_"Object" key])
    #_abstract
    (#_"Object" ITransientSet'''(§ method get) [#_"ITransientSet" this, #_"Object" key])
)
)

(java-ns cloiure.lang.ITransientVector

(§ defprotocol ITransientVector #_(§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" ITransientVector'''(§ method assocN) [#_"ITransientVector" this, #_"int" i, #_"Object" val])
    #_abstract
    (#_"ITransientVector" ITransientVector'''(§ method pop) [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(§ defprotocol IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'TABLE (ConcurrentHashMap.))

    (def #_"ReferenceQueue" Keyword'RQ (ReferenceQueue.))

    (defn #_"Keyword" Keyword'intern [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" r (.get Keyword'TABLE, sym)
              [sym r #_"Keyword" k]
                (when (nil? r) => [sym r nil]
                    (Util'clearCache Keyword'RQ, Keyword'TABLE)
                    (let [sym
                            (when (some? (.meta sym)) => sym
                                (cast' Symbol (.withMeta sym, nil))
                            )
                          k (Keyword'new sym)
                          r (.putIfAbsent Keyword'TABLE, sym, (WeakReference. #_"<Keyword>" k, Keyword'RQ))]
                        [sym r k]
                    )
                )]
            (when (some? r) => k
                (or (.get r)
                    (do ;; entry died in the interim, do over
                        (.remove Keyword'TABLE, sym, r)
                        (recur #_"Keyword'intern" sym)
                    )
                )
            )
        )
    )

    (defn- #_"Keyword" Keyword'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"int" :hasheq 0
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Keyword" Keyword'new [#_"Symbol" sym]
        (let [this (Keyword'init)]
            (§ ass this (assoc this :sym sym))
            (§ ass this (assoc this :hasheq (+ (.hasheq sym) 0x9e3779b9)))
            this
        )
    )

    (defn #_"Keyword" Keyword'find [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" ref (.get Keyword'TABLE, sym)]
            (if (some? ref)
                (do
                    (.get ref)
                )
                (do
                    nil
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'find-2 [#_"String" ns, #_"String" name]
        (Keyword'find (Symbol'intern ns, name))
    )

    (defn #_"Keyword" Keyword'find-1 [#_"String" nsname]
        (Keyword'find (Symbol'intern nsname))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Keyword" this]
        (+ (.hashCode (:sym this)) 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"Keyword" this]
        (:hasheq this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Keyword" this]
        (when (nil? (:_str this))
            (§ ass this (assoc this :_str (str ":" (:sym this))))
        )
        (:_str this)
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"Keyword" this]
        (throw (IllegalArgumentException. (str "Wrong number of args passed to keyword: " (.toString this))))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Keyword" this]
        (.throwArity this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this]
        (.throwArity this)
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Keyword" this, #_"Object" o]
        (.compareTo (:sym this), (:sym (cast' Keyword o)))
    )

    #_method
    (§ defn #_"String" (§ method getNamespace) [#_"Keyword" this]
        (.getNamespace (:sym this))
    )

    #_method
    (§ defn #_"String" (§ method getName) [#_"Keyword" this]
        (.getName (:sym this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" obj]
        (if (§ instance? ILookup obj)
            (.valAt (cast' ILookup obj), this)
            (RT'get-2 obj, this)
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" obj, #_"Object" notFound]
        (if (§ instance? ILookup obj)
            (.valAt (cast' ILookup obj), this, notFound)
            (RT'get-3 obj, this, notFound)
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Keyword" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (defn- #_"KeywordLookupSite" KeywordLookupSite'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordLookupSite" KeywordLookupSite'new [#_"Keyword" k]
        (let [this (KeywordLookupSite'init)]
            (§ ass this (assoc this :k k))
            this
        )
    )

    #_method
    (§ defn #_"ILookupThunk" (§ method fault) [#_"KeywordLookupSite" this, #_"Object" target]
        (cond
            (§ instance? IKeywordLookup target) (.install this, target)
            (§ instance? ILookup target)        (.ilookupThunk this, (.getClass target))
            :else                               this
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"KeywordLookupSite" this, #_"Object" target]
        (if (or (§ instance? IKeywordLookup target) (§ instance? ILookup target))
            this
            (RT'get-2 target, (:k this))
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" (§ method ilookupThunk) [#_"KeywordLookupSite" this, #_"Class" c]
        (§ reify ILookupThunk()
            #_method
            (§ defn #_"Object" (§ method get) [#_"ILookupThunk" this, #_"Object" target]
                (if (and (some? target) (= (.getClass target) c))
                    (.valAt (cast' ILookup target), (:k this))
                    this
                )
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" (§ method install) [#_"KeywordLookupSite" this, #_"Object" target]
        (or (.getLookupThunk (cast' IKeywordLookup target), (:k this)) (.ilookupThunk this, (.getClass target)))
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (defn #_"IPersistentVector" LazilyPersistentVector'createOwning [& #_"Object..." items]
        (if (<= (alength items) 32)
            (PersistentVector'new-4 (alength items), 5, PersistentVector'EMPTY_NODE, items)
            (PersistentVector'create-1a items)
        )
    )

    (defn #_"int" LazilyPersistentVector'fcount [#_"Object" c]
        (if (§ instance? Counted c)
            (.count (cast' Counted c))
            (.size (cast Collection c))
        )
    )

    (defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" obj]
        (cond (§ instance? IReduceInit obj)
            (do
                (PersistentVector'create-1r (cast' IReduceInit obj))
            )
            (§ instance? ISeq obj)
            (do
                (PersistentVector'create-1s (RT'seq obj))
            )
            (instance? Iterable obj)
            (do
                (PersistentVector'create-1i (cast Iterable obj))
            )
            :else
            (do
                (LazilyPersistentVector'createOwning (RT'toArray obj))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (defn- #_"LazySeq" LazySeq'init []
        (hash-map
            #_"IFn" :fn nil
            #_"Object" :sv nil
            #_"ISeq" :s nil
        )
    )

    (defn #_"LazySeq" LazySeq'new-1 [#_"IFn" fn]
        (let [this (merge (Obj'new) (LazySeq'init))]
            (§ ass this (assoc this :fn fn))
            this
        )
    )

    (defn- #_"LazySeq" LazySeq'new-2 [#_"IPersistentMap" meta, #_"ISeq" s]
        (let [this (merge (Obj'new meta) (LazySeq'init))]
            (§ ass this (assoc this :fn nil))
            (§ ass this (assoc this :s s))
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"LazySeq" this, #_"IPersistentMap" meta]
        (LazySeq'new-2 meta, (.seq this))
    )

    #_method
    (§ defn #_"Object" (§ method sval) [#_"LazySeq" this]
        (§ sync this
            (when (some? (:fn this))
                (§ ass this (assoc this :sv (.invoke (:fn this))))
                (§ ass this (assoc this :fn nil))
            )
            (or (:sv this) (:s this))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"LazySeq" this]
        (§ sync this
            (.sval this)
            (when (some? (:sv this))
                (let [#_"Object" ls (:sv this)]
                    (§ ass this (assoc this :sv nil))
                    (while (§ instance? LazySeq ls)
                        (§ ass ls (.sval (cast' LazySeq ls)))
                    )
                    (§ ass this (assoc this :s (RT'seq ls)))
                )
            )
            (:s this)
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"LazySeq" this]
        (let [#_"int" c 0]
            (loop-when-recur [#_"ISeq" s (.seq this)] (some? s) [(.next s)]
                (§ ass c (inc c))
            )
            c
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"LazySeq" this]
        (.seq this)
        (when (some? (:s this))
            (.first (:s this))
        )
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"LazySeq" this]
        (.seq this)
        (when (some? (:s this))
            (.next (:s this))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"LazySeq" this]
        (.seq this)
        (if (some? (:s this)) (.more (:s this)) PersistentList'EMPTY)
    )

    #_method
    (§ defn #_"ISeq" (§ method cons) [#_"LazySeq" this, #_"Object" o]
        (RT'cons o, (.seq this))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"LazySeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (.seq this)]
            (if (some? s)
                (.equiv s, o)
                (and (or (§ instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"LazySeq" this]
        (let [#_"ISeq" s (.seq this)]
            (if (some? s) (Util'hash s) 1)
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"LazySeq" this]
        (Murmur3'hashOrdered this)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (.seq this)]
            (if (some? s)
                (.equals s, o)
                (and (or (§ instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
            )
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"LazySeq" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"LazySeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"LazySeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"LazySeq" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (not (.contains this, o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"LazySeq" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"LazySeq" this]
        (.count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"LazySeq" this]
        (nil? (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"LazySeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"LazySeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"LazySeq" this]
        (ArrayList. this)
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"LazySeq" this, #_"int" fromIndex, #_"int" toIndex]
        (.subList (.reify this), fromIndex, toIndex)
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"LazySeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"LazySeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"LazySeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this) #_"int" i 0] (some? s) => -1
            (if (Util'equiv-2oo (.first s), o) i (recur (.next s) (inc i)))
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"LazySeq" this, #_"Object" o]
        (.lastIndexOf (.reify this), o)
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"LazySeq" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"LazySeq" this, #_"int" index]
        (.listIterator (.reify this), index)
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"LazySeq" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"LazySeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"LazySeq" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"LazySeq" this]
        (§ sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (def- #_"int" LineNumberingPushbackReader'newline (int \newline))

    (defn- #_"LineNumberingPushbackReader" LineNumberingPushbackReader'init []
        (hash-map
            #_"boolean" :_atLineStart true
            #_"boolean" :_prev false
            #_"int" :_columnNumber 1
        )
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-1 [#_"Reader" r]
        (merge (PushbackReader'new (LineNumberReader. r)) (LineNumberingPushbackReader'init))
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-2 [#_"Reader" r, #_"int" size]
        (merge (PushbackReader'new (LineNumberReader. r, size)) (LineNumberingPushbackReader'init))
    )

    #_method
    (§ defn #_"int" (§ method getLineNumber) [#_"LineNumberingPushbackReader" this]
        (inc (.getLineNumber (cast LineNumberReader in)))
    )

    #_method
    (§ defn #_"void" (§ method setLineNumber) [#_"LineNumberingPushbackReader" this, #_"int" line]
        (.setLineNumber (cast LineNumberReader in), (dec line))
        nil
    )

    #_method
    (§ defn #_"int" (§ method getColumnNumber) [#_"LineNumberingPushbackReader" this]
        (:_columnNumber this)
    )

    #_method
    (§ defn #_"int" (§ method read) [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" c (.read (§ super ))]
            (§ ass this (assoc this :_prev (:_atLineStart this)))
            (if (or (= c LineNumberingPushbackReader'newline) (= c -1))
                (do
                    (§ ass this (assoc this :_atLineStart true))
                    (§ ass this (assoc this :_columnNumber 1))
                )
                (do
                    (§ ass this (assoc this :_atLineStart false))
                    (§ ass this (assoc this :_columnNumber (inc (:_columnNumber this))))
                )
            )
            c
        )
    )

    #_method
    (§ defn #_"void" (§ method unread) [#_"LineNumberingPushbackReader" this, #_"int" c] #_(§ throws IOException)
        (.unread (§ super ), c)
        (§ ass this (assoc this :_atLineStart (:_prev this)))
        (§ ass this (assoc this :_columnNumber (dec (:_columnNumber this))))
        nil
    )

    #_method
    (§ defn #_"String" (§ method readLine) [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" c (.read this)]
            (§ let [#_"String" line]
                (condp = c
                    -1
                    (do
                        (§ ass line nil)
                        (§ break )
                    )
                    LineNumberingPushbackReader'newline
                    (do
                        (§ ass line "")
                        (§ break )
                    )
                    (do
                        (let [#_"String" first (String/valueOf (char c))]
                            (let [#_"String" rest (.readLine (cast LineNumberReader in))]
                                (§ ass line (if (nil? rest) first (str first rest)))
                                (§ ass this (assoc this :_prev false))
                                (§ ass this (assoc this :_atLineStart true))
                                (§ ass this (assoc this :_columnNumber 1))
                                (§ break )
                            )
                        )
                    )
                )
                line
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method atLineStart) [#_"LineNumberingPushbackReader" this]
        (:_atLineStart this)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(§ defprotocol Resolver
    #_abstract
    (#_"Symbol" Resolver'''(§ method currentNS) [#_"Resolver" this])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveClass) [#_"Resolver" this, #_"Symbol" sym])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveAlias) [#_"Resolver" this, #_"Symbol" sym])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveVar) [#_"Resolver" this, #_"Symbol" sym])
)

(class-ns LispReaderException (§ extends RuntimeException)
    (defn- #_"LispReaderException" LispReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"LispReaderException" LispReaderException'new [#_"int" line, #_"int" column, #_"Throwable" cause]
        (let [this (merge (§ foreign RuntimeException'new cause) (LispReaderException'init))]
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            this
        )
    )
)

#_closure
(class-ns RegexReader (§ extends AFn)
    (defn #_"RegexReader" RegexReader'new []
        (AFn'new)
    )

    (§ def #_"StringReader" RegexReader'stringrdr (StringReader'new))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RegexReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" pendingForms]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (let [#_"Reader" r (cast Reader reader)]
                (loop-when-recur [#_"int" ch (LispReader'read1 r)] (not= ch \") [(LispReader'read1 r)] ;; oops! "
                    (when (= ch -1)
                        (throw (RuntimeException. "EOF while reading regex"))
                    )
                    (.append sb, (char ch))
                    (when (= ch \\) ;; escape
                        (§ ass ch (LispReader'read1 r))
                        (when (= ch -1)
                            (throw (RuntimeException. "EOF while reading regex"))
                        )
                        (.append sb, (char ch))
                    )
                )
                (Pattern/compile (.toString sb))
            )
        )
    )
)

#_closure
(class-ns StringReader (§ extends AFn)
    (defn #_"StringReader" StringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"StringReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" pendingForms]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (let [#_"Reader" r (cast Reader reader)]
                (loop-when-recur [#_"int" ch (LispReader'read1 r)] (not= ch \") [(LispReader'read1 r)] ;; oops! "
                    (when (= ch -1)
                        (throw (RuntimeException. "EOF while reading string"))
                    )
                    (when (= ch \\) ;; escape
                        (§ ass ch (LispReader'read1 r))
                        (when (= ch -1)
                            (throw (RuntimeException. "EOF while reading string"))
                        )
                        (case ch
                            \t
                            (do
                                (§ ass ch \tab)
                                (§ break )
                            )
                            \r
                            (do
                                (§ ass ch \return)
                                (§ break )
                            )
                            \n
                            (do
                                (§ ass ch \newline)
                                (§ break )
                            )
                            \\
                            (do
                                (§ break )
                            )
                            \" ;; oops! "
                            (do
                                (§ break )
                            )
                            \b
                            (do
                                (§ ass ch \backspace)
                                (§ break )
                            )
                            \f
                            (do
                                (§ ass ch \formfeed)
                                (§ break )
                            )
                            \u
                            (do
                                (§ ass ch (LispReader'read1 r))
                                (when (= (Character/digit ch, 16) -1)
                                    (throw (RuntimeException. (str "Invalid unicode escape: \\u" (char ch))))
                                )
                                (§ ass ch (LispReader'readUnicodeChar-5 (cast PushbackReader r), ch, 16, 4, true))
                                (§ break )
                            )
                            (do
                                (if (Character/isDigit ch)
                                    (do
                                        (§ ass ch (LispReader'readUnicodeChar-5 (cast PushbackReader r), ch, 8, 3, false))
                                        (when (< 0377 ch)
                                            (throw (RuntimeException. "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (RuntimeException. (str "Unsupported escape character: \\" (char ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (.append sb, (char ch))
                )
                (.toString sb)
            )
        )
    )
)

#_closure
(class-ns CommentReader (§ extends AFn)
    (defn #_"CommentReader" CommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"CommentReader" this, #_"Object" reader, #_"Object" semicolon, #_"Object" pendingForms]
        (let [#_"Reader" r (cast Reader reader)]
            (§ let [#_"int" ch]
                (§ loop
                    (§ ass ch (LispReader'read1 r))
                    (§ recur-if (not (or (= ch -1) (= ch \newline) (= ch \return))))
                )
                r
            )
        )
    )
)

#_closure
(class-ns DiscardReader (§ extends AFn)
    (defn #_"DiscardReader" DiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"DiscardReader" this, #_"Object" reader, #_"Object" underscore, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))
            r
        )
    )
)

;; :a.b{:c 1} => {:a.b/c 1}
;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
#_closure
(class-ns NamespaceMapReader (§ extends AFn)
    (defn #_"NamespaceMapReader" NamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"NamespaceMapReader" this, #_"Object" reader, #_"Object" colon, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let [#_"boolean" auto false]
                (let [#_"int" autoChar (LispReader'read1 r)]
                    (if (= autoChar \:)
                        (do
                            (§ ass auto true)
                        )
                        (do
                            (LispReader'unread r, autoChar)
                        )
                    )

                    (let [#_"Object" sym nil]
                        (let [#_"int" nextChar (LispReader'read1 r)]
                            (cond (LispReader'isWhitespace nextChar) ;; the #:: { } case or an error
                                (do
                                    (if auto
                                        (do
                                            (while (LispReader'isWhitespace nextChar)
                                                (§ ass nextChar (LispReader'read1 r))
                                            )
                                            (when (not= nextChar \{)
                                                (LispReader'unread r, nextChar)
                                                (throw (RuntimeException. "Namespaced map must specify a namespace"))
                                            )
                                        )
                                        (do
                                            (LispReader'unread r, nextChar)
                                            (throw (RuntimeException. "Namespaced map must specify a namespace"))
                                        )
                                    )
                                )
                                (not= nextChar \{) ;; #:foo { } or #::foo { }
                                (do
                                    (LispReader'unread r, nextChar)
                                    (§ ass sym (LispReader'read-5 r, true, nil, false, pendingForms))
                                    (§ ass nextChar (LispReader'read1 r))
                                    (while (LispReader'isWhitespace nextChar)
                                        (§ ass nextChar (LispReader'read1 r))
                                    )
                                )
                            )
                            (when (not= nextChar \{)
                                (throw (RuntimeException. "Namespaced map must specify a map"))
                            )

                            ;; Resolve autoresolved ns
                            (§ let [#_"String" ns]
                                (cond auto
                                    (do
                                        (let [#_"Resolver" resolver (cast' Resolver (.deref RT'READER_RESOLVER))]
                                            (cond (nil? sym)
                                                (do
                                                    (if (some? resolver)
                                                        (do
                                                            (§ ass ns (:name (.currentNS resolver)))
                                                        )
                                                        (do
                                                            (§ ass ns (.getName (.getName (Compiler'currentNS))))
                                                        )
                                                    )
                                                )
                                                (or (not (§ instance? Symbol sym)) (some? (.getNamespace (cast' Symbol sym))))
                                                (do
                                                    (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " sym)))
                                                )
                                                :else
                                                (do
                                                    (§ let [#_"Symbol" resolvedNS]
                                                        (if (some? resolver)
                                                            (do
                                                                (§ ass resolvedNS (.resolveAlias resolver, (cast' Symbol sym)))
                                                            )
                                                            (do
                                                                (let [#_"Namespace" rns (.lookupAlias (Compiler'currentNS), (cast' Symbol sym))]
                                                                    (§ ass resolvedNS (when (some? rns) (.getName rns)))
                                                                )
                                                            )
                                                        )

                                                        (if (nil? resolvedNS)
                                                            (do
                                                                (throw (RuntimeException. (str "Unknown auto-resolved namespace alias: " sym)))
                                                            )
                                                            (do
                                                                (§ ass ns (.getName resolvedNS))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (or (not (§ instance? Symbol sym)) (some? (.getNamespace (cast' Symbol sym))))
                                    (do
                                        (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " sym)))
                                    )
                                    :else
                                    (do
                                        (§ ass ns (.getName (cast' Symbol sym)))
                                    )
                                )

                                ;; Read map
                                (let [#_"List" kvs (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms))]
                                    (when (= (& (.size kvs) 1) 1)
                                        (throw (RuntimeException. "Namespaced map literal must contain an even number of forms"))
                                    )

                                    ;; Construct output map
                                    (let [#_"Object[]" a (make-array Object (.size kvs))]
                                        (let [#_"Iterator" iter (.iterator kvs)]
                                            (loop-when-recur [#_"int" i 0] (.hasNext iter) [(+ i 2)]
                                                (let [#_"Object" key (.next iter)]
                                                    (let [#_"Object" val (.next iter)]
                                                        (cond (§ instance? Keyword key)
                                                            (do
                                                                (let [#_"Keyword" kw (cast' Keyword key)]
                                                                    (cond (nil? (.getNamespace kw))
                                                                        (do
                                                                            (§ ass key (Keyword'intern (Symbol'intern ns, (.getName kw))))
                                                                        )
                                                                        (= (.getNamespace kw) "_")
                                                                        (do
                                                                            (§ ass key (Keyword'intern (Symbol'intern nil, (.getName kw))))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (§ instance? Symbol key)
                                                            (do
                                                                (let [#_"Symbol" s (cast' Symbol key)]
                                                                    (cond (nil? (.getNamespace s))
                                                                        (do
                                                                            (§ ass key (Symbol'intern ns, (.getName s)))
                                                                        )
                                                                        (= (.getNamespace s) "_")
                                                                        (do
                                                                            (§ ass key (Symbol'intern nil, (.getName s)))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (aset a i key)
                                                        (aset a (inc i) val)
                                                    )
                                                )
                                            )
                                            (RT'map a)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SymbolicValueReader (§ extends AFn)
    (defn #_"SymbolicValueReader" SymbolicValueReader'new []
        (AFn'new)
    )

    (§ def #_"IPersistentMap" SymbolicValueReader'specials (PersistentHashMap'create-1a
        (object-array [
            (Symbol'intern "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern "NaN")  Double/NaN
        ])
    ))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"SymbolicValueReader" this, #_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let [#_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (when (not (§ instance? Symbol o))
                    (throw (RuntimeException. (str "Invalid token: ##" o)))
                )
                (when (not (.containsKey SymbolicValueReader'specials, o))
                    (throw (RuntimeException. (str "Unknown symbolic value: ##" o)))
                )

                (.valAt SymbolicValueReader'specials, o)
            )
        )
    )
)

(class-ns WrappingReader (§ extends AFn)
    (defn- #_"WrappingReader" WrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
        )
    )

    (defn #_"WrappingReader" WrappingReader'new [#_"Symbol" sym]
        (let [this (merge (AFn'new) (WrappingReader'init))]
            (§ ass this (assoc this :sym sym))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"WrappingReader" this, #_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let [#_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (RT'list-2 (:sym this), o)
            )
        )
    )
)

#_closure
(class-ns VarReader (§ extends AFn)
    (defn #_"VarReader" VarReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"VarReader" this, #_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let [#_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (RT'list-2 LispReader'THE_VAR, o)
            )
        )
    )
)

#_closure
(class-ns DispatchReader (§ extends AFn)
    (defn #_"DispatchReader" DispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"DispatchReader" this, #_"Object" reader, #_"Object" hash, #_"Object" pendingForms]
        (let-when-not [#_"int" ch (LispReader'read1 (cast Reader reader))] (= ch -1) => (throw (RuntimeException. "EOF while reading character"))
            (let-when-not [#_"IFn" fn (aget LispReader'dispatchMacros ch)] (some? fn) => (.invoke fn, reader, ch, pendingForms)
                (LispReader'unread (cast PushbackReader reader), ch)
                (or (.invoke LispReader'ctorReader, reader, ch, (LispReader'ensurePending pendingForms))
                    (throw (RuntimeException. (str "No dispatch macro for: " (char ch))))
                )
            )
        )
    )
)

#_closure
(class-ns FnReader (§ extends AFn)
    (defn #_"FnReader" FnReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnReader" this, #_"Object" reader, #_"Object" lparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (when (some? (.deref LispReader'ARG_ENV))
                (throw (IllegalStateException. "Nested #()s are not allowed"))
            )
            (try
                (Var'pushThreadBindings (RT'map LispReader'ARG_ENV, PersistentTreeMap'EMPTY))
                (LispReader'unread r, \()
                (let [#_"Object" form (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                    (let [#_"PersistentVector" args PersistentVector'EMPTY]
                        (let [#_"PersistentTreeMap" argsyms (cast' PersistentTreeMap (.deref LispReader'ARG_ENV))]
                            (let [#_"ISeq" rargs (.rseq argsyms)]
                                (when (some? rargs)
                                    (let [#_"int" higharg (cast Integer (.getKey (cast Map$Entry (.first rargs))))]
                                        (when (< 0 higharg)
                                            (loop-when-recur [#_"int" i 1] (<= i higharg) [(inc i)]
                                                (let [#_"Object" sym (.valAt argsyms, i)]
                                                    (when (nil? sym)
                                                        (§ ass sym (LispReader'garg i))
                                                    )
                                                    (§ ass args (.cons args, sym))
                                                )
                                            )
                                        )
                                        (let [#_"Object" restsym (.valAt argsyms, -1)]
                                            (when (some? restsym)
                                                (§ ass args (.cons args, Compiler'_AMP_))
                                                (§ ass args (.cons args, restsym))
                                            )
                                        )
                                    )
                                )
                                (RT'list-3 Compiler'FN, args, form)
                            )
                        )
                    )
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )
)

#_closure
(class-ns ArgReader (§ extends AFn)
    (defn #_"ArgReader" ArgReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ArgReader" this, #_"Object" reader, #_"Object" pct, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (when (some? (.deref LispReader'ARG_ENV)) => (LispReader'interpretToken (LispReader'readToken r, \%), nil)
                (let [#_"int" ch (LispReader'read1 r) _ (LispReader'unread r, ch)]
                    ;; % alone is first arg
                    (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isTerminatingMacro ch))
                        (LispReader'registerArg 1)
                        (let [#_"Object" n (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                            (cond
                                (.equals n, Compiler'_AMP_) (LispReader'registerArg -1)
                                (instance? Number n)        (LispReader'registerArg (.intValue (cast Number n)))
                                :else                       (throw (IllegalStateException. "arg literal must be %, %& or %integer"))
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns MetaReader (§ extends AFn)
    (defn #_"MetaReader" MetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MetaReader" this, #_"Object" reader, #_"Object" caret, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              [#_"int" line #_"int" column]
                (when (§ instance? LineNumberingPushbackReader r) => [-1 -1]
                    [(.getLineNumber (cast' LineNumberingPushbackReader r)) (dec (.getColumnNumber (cast' LineNumberingPushbackReader r)))]
                )
              pendingForms (LispReader'ensurePending pendingForms)
              #_"Object" meta (LispReader'read-5 r, true, nil, true, pendingForms)
              meta
                (cond
                    (or (§ instance? Symbol meta) (instance? String meta)) (RT'map RT'TAG_KEY, meta)
                    (§ instance? Keyword meta)                             (RT'map meta, RT'T)
                    (§ instance? IPersistentMap meta)                      meta
                    :else (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                )
              #_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
            (when (§ instance? IMeta o) => (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                (let [meta
                        (when (and (not= line -1) (§ instance? ISeq o)) => meta
                            (-> (cast' IPersistentMap meta) (.assoc RT'LINE_KEY, line) (.assoc RT'COLUMN_KEY, column))
                        )]
                    (if (§ instance? IReference o)
                        (do
                            (.resetMeta (cast' IReference o), (cast' IPersistentMap meta))
                            o
                        )
                        (let [#_"Object" ometa
                                (loop-when [ometa (RT'meta o) #_"ISeq" s (RT'seq meta)] (some? s) => ometa
                                    (let [#_"IMapEntry" kv (cast' IMapEntry (.first s))]
                                        (recur (RT'assoc ometa, (.getKey kv), (.getValue kv)) (.next s))
                                    )
                                )]
                            (.withMeta (cast' IObj o), (cast' IPersistentMap ometa))
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SyntaxQuoteReader (§ extends AFn)
    (defn #_"SyntaxQuoteReader" SyntaxQuoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"SyntaxQuoteReader" this, #_"Object" reader, #_"Object" backquote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (try
                (Var'pushThreadBindings (RT'map LispReader'GENSYM_ENV, PersistentHashMap'EMPTY))
                (let [#_"Object" form (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                    (SyntaxQuoteReader'syntaxQuote form)
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" form]
        (let [#_"Object" ret
                (cond
                    (Compiler'isSpecial form)
                        (§ ass ret (RT'list-2 Compiler'QUOTE, form))
                    (§ instance? Symbol form)
                        (let [#_"Resolver" resolver (cast' Resolver (.deref RT'READER_RESOLVER))
                              #_"Symbol" sym (cast' Symbol form)]
                            (cond
                                (and (nil? (:ns sym)) (.endsWith (:name sym), "#"))
                                    (let [#_"IPersistentMap" gmap (cast' IPersistentMap (.deref LispReader'GENSYM_ENV))]
                                        (when (nil? gmap)
                                            (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                        )
                                        (let [#_"Symbol" gs (cast' Symbol (.valAt gmap, sym))]
                                            (when (nil? gs)
                                                (§ ass gs (Symbol'intern nil, (str (.substring (:name sym), 0, (dec (.length (:name sym)))) "__" (RT'nextID) "__auto__")))
                                                (.set LispReader'GENSYM_ENV, (.assoc gmap, sym, gs))
                                            )
                                            (§ ass sym gs)
                                        )
                                    )
                                (and (nil? (:ns sym)) (.endsWith (:name sym), "."))
                                    (let [#_"Symbol" csym (Symbol'intern nil, (.substring (:name sym), 0, (dec (.length (:name sym)))))]
                                        (if (some? resolver)
                                            (let [#_"Symbol" rc (.resolveClass resolver, csym)]
                                                (when (some? rc)
                                                    (§ ass csym rc)
                                                )
                                            )
                                            (§ ass csym (Compiler'resolveSymbol csym))
                                        )
                                        (§ ass sym (Symbol'intern nil, (.concat (:name csym), ".")))
                                    )
                                (and (nil? (:ns sym)) (.startsWith (:name sym), "."))
                                (do
                                    ;; Simply quote method names.
                                )
                                (some? resolver)
                                    (let [#_"Symbol" nsym nil]
                                        (when (some? (:ns sym))
                                            (let [#_"Symbol" alias (Symbol'intern nil, (:ns sym))]
                                                (§ ass nsym (.resolveClass resolver, alias))
                                                (when (nil? nsym)
                                                    (§ ass nsym (.resolveAlias resolver, alias))
                                                )
                                            )
                                        )
                                        (cond
                                            (some? nsym) ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass sym (Symbol'intern (:name nsym), (:name sym)))
                                            (nil? (:ns sym))
                                                (let [#_"Symbol" rsym (.resolveClass resolver, sym)]
                                                    (when (nil? rsym)
                                                        (§ ass rsym (.resolveVar resolver, sym))
                                                    )
                                                    (§ ass sym (or rsym (Symbol'intern (:name (.currentNS resolver)), (:name sym))))
                                                )
                                        )
                                        ;; leave alone if qualified
                                    )
                                :else
                                    (let [#_"Object" maybeClass nil]
                                        (when (some? (:ns sym))
                                            (§ ass maybeClass (.getMapping (Compiler'currentNS), (Symbol'intern nil, (:ns sym))))
                                        )
                                        (if (instance? Class maybeClass) ;; Classname/foo -> package.qualified.Classname/foo
                                            (§ ass sym (Symbol'intern (.getName (cast Class maybeClass)), (:name sym)))
                                            (§ ass sym (Compiler'resolveSymbol sym))
                                        )
                                    )
                            )
                            (§ ass ret (RT'list-2 Compiler'QUOTE, sym))
                        )
                    (LispReader'isUnquote form)
                        (§ return (RT'second form))
                    (LispReader'isUnquoteSplicing form)
                        (throw (IllegalStateException. "splice not in list"))
                    (§ instance? IPersistentCollection form)
                        (cond (§ instance? IRecord form)
                                (§ ass ret form)
                            (§ instance? IPersistentMap form)
                                (let [#_"IPersistentVector" keyvals (SyntaxQuoteReader'flattenMap form)]
                                    (§ ass ret (RT'list-3 LispReader'APPLY, LispReader'HASHMAP, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (.seq keyvals))))))
                                )
                            (§ instance? IPersistentVector form)
                                (§ ass ret (RT'list-3 LispReader'APPLY, LispReader'VECTOR, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (.seq (cast' IPersistentVector form)))))))
                            (§ instance? IPersistentSet form)
                                (§ ass ret (RT'list-3 LispReader'APPLY, LispReader'HASHSET, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (.seq (cast' IPersistentSet form)))))))
                            (or (§ instance? ISeq form) (§ instance? IPersistentList form))
                                (let [#_"ISeq" seq (RT'seq form)]
                                    (§ ass ret (if (some? seq) (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList seq))) (RT'cons LispReader'LIST, nil)))
                                )
                            :else
                                (throw (UnsupportedOperationException. "Unknown Collection type"))
                        )
                    (or (§ instance? Keyword form) (instance? Number form) (instance? Character form) (instance? String form))
                        (§ ass ret form)
                    :else
                        (§ ass ret (RT'list-2 Compiler'QUOTE, form))
                )]
            (when (and (§ instance? IObj form) (some? (RT'meta form))) => ret
                ;; filter line and column numbers
                (when (pos? (.count (.without (.without (.meta (cast' IObj form)), RT'LINE_KEY), RT'COLUMN_KEY))) => ret
                    (RT'list-3 LispReader'WITH_META, ret, (SyntaxQuoteReader'syntaxQuote (.meta (cast' IObj form))))
                )
            )
        )
    )

    (defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" seq]
        (loop-when [#_"PersistentVector" v PersistentVector'EMPTY seq seq] (some? seq) => (.seq v)
            (let [#_"Object" item (.first seq)
                  v (cond
                        (LispReader'isUnquote item)         (.cons v, (RT'list-2 LispReader'LIST, (RT'second item)))
                        (LispReader'isUnquoteSplicing item) (.cons v, (RT'second item))
                        :else                               (.cons v, (RT'list-2 LispReader'LIST, (SyntaxQuoteReader'syntaxQuote item)))
                    )]
                (recur v (.next seq))
            )
        )
    )

    (defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" form]
        (loop-when [#_"IPersistentVector" keyvals PersistentVector'EMPTY #_"ISeq" s (RT'seq form)] (some? s) => keyvals
            (let [#_"IMapEntry" e (cast' IMapEntry (.first s))
                  keyvals (cast' IPersistentVector (.cons keyvals, (.key e)))
                  keyvals (cast' IPersistentVector (.cons keyvals, (.val e)))]
                (recur keyvals (.next s))
            )
        )
    )
)

#_closure
(class-ns UnquoteReader (§ extends AFn)
    (defn #_"UnquoteReader" UnquoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"UnquoteReader" this, #_"Object" reader, #_"Object" comma, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let [#_"int" ch (LispReader'read1 r)]
                (when (= ch -1)
                    (throw (RuntimeException. "EOF while reading character"))
                )
                (§ ass pendingForms (LispReader'ensurePending pendingForms))
                (if (= ch \@)
                    (do
                        (let [#_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE_SPLICING, o)
                        )
                    )
                    (do
                        (LispReader'unread r, ch)
                        (let [#_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE, o)
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns CharacterReader (§ extends AFn)
    (defn #_"CharacterReader" CharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"CharacterReader" this, #_"Object" reader, #_"Object" backslash, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader) #_"int" ch (LispReader'read1 r)]
            (when-not (= ch -1) => (throw (RuntimeException. "EOF while reading character"))
                (let [#_"String" token (LispReader'readToken r, (char ch))]
                    (when-not (= (.length token) 1) => (Character/valueOf (.charAt token, 0))
                        (case token
                            "newline"   \newline
                            "space"     \space
                            "tab"       \tab
                            "backspace" \backspace
                            "formfeed"  \formfeed
                            "return"    \return
                            (cond
                                (.startsWith token, "u")
                                    (let [#_"char" c (char (LispReader'readUnicodeChar-4 token, 1, 4, 16))]
                                        (when (<= (§ char "\ud800") c (§ char "\udfff")) ;; surrogate code unit?
                                            (throw (RuntimeException. (str "Invalid character constant: \\u" (Integer/toString c, 16))))
                                        )
                                        c
                                    )
                                (.startsWith token, "o")
                                    (let [#_"int" len (dec (.length token))]
                                        (when (< 3 len)
                                            (throw (RuntimeException. (str "Invalid octal escape sequence length: " len)))
                                        )
                                        (let [#_"int" uc (LispReader'readUnicodeChar-4 token, 1, len, 8)]
                                            (when (< 0377 uc)
                                                (throw (RuntimeException. "Octal escape sequence must be in range [0, 377]."))
                                            )
                                            (char uc)
                                        )
                                    )
                                :else
                                    (throw (RuntimeException. (str "Unsupported character: \\" token)))
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ListReader (§ extends AFn)
    (defn #_"ListReader" ListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ListReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              [#_"int" line #_"int" column]
                (when (§ instance? LineNumberingPushbackReader r) => [-1 -1]
                    [(.getLineNumber (cast' LineNumberingPushbackReader r)) (dec (.getColumnNumber (cast' LineNumberingPushbackReader r)))]
                )
              #_"List" list (LispReader'readDelimitedList \), r, true, (LispReader'ensurePending pendingForms))]
            (when-not (.isEmpty list) => PersistentList'EMPTY
                (let [#_"IObj" s (cast' IObj (PersistentList'create list))]
                    (when-not (= line -1) => s
                        (.withMeta s, (RT'map
                            (object-array [
                                RT'LINE_KEY   line
                                RT'COLUMN_KEY column
                            ])
                        ))
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EvalReader (§ extends AFn)
    (defn #_"EvalReader" EvalReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EvalReader" this, #_"Object" reader, #_"Object" eq, #_"Object" pendingForms]
        (when (RT'booleanCast-1o (.deref RT'READEVAL)) => (throw (RuntimeException. "EvalReader not allowed when *read-eval* is false."))
            (let [#_"PushbackReader" r (cast PushbackReader reader)
                  #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                (cond
                    (§ instance? Symbol o)
                        (RT'classForName-1 (.toString o))
                    (§ instance? IPersistentList o)
                        (let [#_"Symbol" fs (cast' Symbol (RT'first o))]
                            (cond
                                (.equals fs, LispReader'THE_VAR)
                                    (let [#_"Symbol" vs (cast' Symbol (RT'second o))]
                                        (RT'var (:ns vs), (:name vs))
                                    )
                                (.endsWith (:name fs), ".")
                                    (let [#_"Object[]" args (RT'toArray (RT'next o))]
                                        (Reflector'invokeConstructor (RT'classForName-1 (.substring (:name fs), 0, (dec (.length (:name fs))))), args)
                                    )
                                (Compiler'namesStaticMember fs)
                                    (let [#_"Object[]" args (RT'toArray (RT'next o))]
                                        (Reflector'invokeStaticMethod-3s (:ns fs), (:name fs), args)
                                    )
                                :else
                                    (let [#_"Object" v (Compiler'maybeResolveIn (Compiler'currentNS), fs)]
                                        (when (§ instance? Var v) => (throw (RuntimeException. (str "Can't resolve " fs)))
                                            (.applyTo (cast' IFn v), (RT'next o))
                                        )
                                    )
                            )
                        )
                    :else
                        (throw (IllegalArgumentException. "Unsupported #= form"))
                )
            )
        )
    )
)

#_closure
(class-ns VectorReader (§ extends AFn)
    (defn #_"VectorReader" VectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"VectorReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (LazilyPersistentVector'create (LispReader'readDelimitedList \], r, true, (LispReader'ensurePending pendingForms)))
        )
    )
)

#_closure
(class-ns MapReader (§ extends AFn)
    (defn #_"MapReader" MapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MapReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let [#_"Object[]" a (.toArray (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms)))]
                (when (= (& (alength a) 1) 1)
                    (throw (RuntimeException. "Map literal must contain an even number of forms"))
                )
                (RT'map a)
            )
        )
    )
)

#_closure
(class-ns SetReader (§ extends AFn)
    (defn #_"SetReader" SetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"SetReader" this, #_"Object" reader, #_"Object" leftbracket, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (PersistentHashSet'createWithCheck-1l (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms)))
        )
    )
)

#_closure
(class-ns UnmatchedDelimiterReader (§ extends AFn)
    (defn #_"UnmatchedDelimiterReader" UnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"UnmatchedDelimiterReader" this, #_"Object" reader, #_"Object" rightdelim, #_"Object" pendingForms]
        (throw (RuntimeException. (str "Unmatched delimiter: " rightdelim)))
    )
)

#_closure
(class-ns UnreadableReader (§ extends AFn)
    (defn #_"UnreadableReader" UnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"UnreadableReader" this, #_"Object" reader, #_"Object" leftangle, #_"Object" pendingForms]
        (throw (RuntimeException. "Unreadable form"))
    )
)

#_closure
(class-ns CtorReader (§ extends AFn)
    (defn #_"CtorReader" CtorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"CtorReader" this, #_"Object" reader, #_"Object" firstChar, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (§ ass pendingForms (LispReader'ensurePending pendingForms))
            (let [#_"Object" name (LispReader'read-5 r, true, nil, false, pendingForms)]
                (when (not (§ instance? Symbol name))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" sym (cast' Symbol name)]
                    (let [#_"Object" form (LispReader'read-5 r, true, nil, true, pendingForms)]
                        (if (.contains (.getName sym), ".")
                            (.readRecord this, form, sym, pendingForms)
                            (.readTagged this, form, sym, pendingForms)
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method readTagged) [#_"CtorReader" this, #_"Object" o, #_"Symbol" tag, #_"Object" pendingForms]
        (throw (RuntimeException. (str "No reader function for tag " (.toString tag))))
    )

    #_method
    (§ defn- #_"Object" (§ method readRecord) [#_"CtorReader" this, #_"Object" form, #_"Symbol" recordName, #_"Object" pendingForms]
        (when-not (RT'booleanCast-1o (.deref RT'READEVAL))
            (throw (RuntimeException. "Record construction syntax can only be used when *read-eval* == true"))
        )

        (let [#_"Class" recordClass (RT'classForNameNonLoading (.toString recordName))]
            (let [#_"boolean" shortForm true]
                (cond (§ instance? IPersistentMap form)
                    (do
                        (§ ass shortForm false)
                    )
                    (§ instance? IPersistentVector form)
                    (do
                        (§ ass shortForm true)
                    )
                    :else
                    (do
                        (throw (RuntimeException. (str "Unreadable constructor form starting with \"#" recordName "\"")))
                    )
                )

                (let [#_"Object" ret nil]
                    (let [#_"Constructor[]" allctors (.getConstructors (cast Class recordClass))]
                        (if shortForm
                            (do
                                (let [#_"IPersistentVector" recordEntries (cast' IPersistentVector form)]
                                    (let [#_"boolean" ctorFound false]
                                        (doseq [#_"Constructor" ctor allctors]
                                            (when (= (alength (.getParameterTypes ctor)) (.count recordEntries))
                                                (§ ass ctorFound true)
                                            )
                                        )

                                        (when (not ctorFound)
                                            (throw (RuntimeException. (str "Unexpected number of constructor arguments to " (.toString recordClass) ": got " (.count recordEntries))))
                                        )

                                        (§ ass ret (Reflector'invokeConstructor recordClass, (RT'toArray recordEntries)))
                                    )
                                )
                            )
                            (do
                                (let [#_"IPersistentMap" vals (cast' IPersistentMap form)]
                                    (loop-when-recur [#_"ISeq" s (RT'keys vals)] (some? s) [(.next s)]
                                        (when (not (§ instance? Keyword (.first s)))
                                            (throw (RuntimeException. (str "Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " (.toString (.first s)))))
                                        )
                                    )
                                    (§ ass ret (Reflector'invokeStaticMethod-3c recordClass, "create", (object-array [ vals ])))
                                )
                            )
                        )

                        ret
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" LispReader'QUOTE (Symbol'intern "quote"))
    (§ def #_"Symbol" LispReader'THE_VAR (Symbol'intern "var"))

    (§ def #_"Symbol" LispReader'UNQUOTE (Symbol'intern "cloiure.core", "unquote"))
    (§ def #_"Symbol" LispReader'UNQUOTE_SPLICING (Symbol'intern "cloiure.core", "unquote-splicing"))
    (§ def #_"Symbol" LispReader'CONCAT (Symbol'intern "cloiure.core", "concat"))
    (§ def #_"Symbol" LispReader'SEQ (Symbol'intern "cloiure.core", "seq"))
    (§ def #_"Symbol" LispReader'LIST (Symbol'intern "cloiure.core", "list"))
    (§ def #_"Symbol" LispReader'APPLY (Symbol'intern "cloiure.core", "apply"))
    (§ def #_"Symbol" LispReader'HASHMAP (Symbol'intern "cloiure.core", "hash-map"))
    (§ def #_"Symbol" LispReader'HASHSET (Symbol'intern "cloiure.core", "hash-set"))
    (§ def #_"Symbol" LispReader'VECTOR (Symbol'intern "cloiure.core", "vector"))
    (§ def #_"Symbol" LispReader'WITH_META (Symbol'intern "cloiure.core", "with-meta"))
    (§ def #_"Symbol" LispReader'META (Symbol'intern "cloiure.core", "meta"))
    (§ def #_"Symbol" LispReader'DEREF (Symbol'intern "cloiure.core", "deref"))
    (§ def #_"Keyword" LispReader'UNKNOWN (Keyword'intern (Symbol'intern nil, "unknown")))

    (def #_"IFn[]" LispReader'macros (make-array #_"IFn" Object 256))
    (def #_"IFn[]" LispReader'dispatchMacros (make-array #_"IFn" Object 256))

    (def #_"Pattern" LispReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" LispReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" LispReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" LispReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def #_"Var" LispReader'GENSYM_ENV (.setDynamic (Var'create nil)))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" LispReader'ARG_ENV (.setDynamic (Var'create nil)))
    (§ def #_"IFn" LispReader'ctorReader (CtorReader'new))

    (§ static
        (aset LispReader'macros \" (StringReader'new)) ;; oops! "
        (aset LispReader'macros \; (CommentReader'new))
        (aset LispReader'macros \' (WrappingReader'new LispReader'QUOTE))
        (aset LispReader'macros \@ (WrappingReader'new LispReader'DEREF))
        (aset LispReader'macros \^ (MetaReader'new))
        (aset LispReader'macros \` (SyntaxQuoteReader'new))
        (aset LispReader'macros \~ (UnquoteReader'new))
        (aset LispReader'macros \( (ListReader'new))
        (aset LispReader'macros \) (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \[ (VectorReader'new))
        (aset LispReader'macros \] (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \{ (MapReader'new))
        (aset LispReader'macros \} (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \\ (CharacterReader'new))
        (aset LispReader'macros \% (ArgReader'new))
        (aset LispReader'macros \# (DispatchReader'new))

        (aset LispReader'dispatchMacros \^ (MetaReader'new))
        (aset LispReader'dispatchMacros \# (SymbolicValueReader'new))
        (aset LispReader'dispatchMacros \' (VarReader'new))
        (aset LispReader'dispatchMacros \" (RegexReader'new)) ;; oops! "
        (aset LispReader'dispatchMacros \( (FnReader'new))
        (aset LispReader'dispatchMacros \{ (SetReader'new))
        (aset LispReader'dispatchMacros \= (EvalReader'new))
        (aset LispReader'dispatchMacros \! (CommentReader'new))
        (aset LispReader'dispatchMacros \< (UnreadableReader'new))
        (aset LispReader'dispatchMacros \_ (DiscardReader'new))
        (aset LispReader'dispatchMacros \: (NamespaceMapReader'new))
    )

    (defn #_"boolean" LispReader'isWhitespace [#_"int" ch]
        (or (Character/isWhitespace ch) (= ch \,))
    )

    (defn #_"void" LispReader'unread [#_"PushbackReader" r, #_"int" ch]
        (when-not (= ch -1)
            (try
                (.unread r, ch)
                (catch IOException e
                    (throw (Util'sneakyThrow e))
                )
            )
        )
        nil
    )

    (defn #_"int" LispReader'read1 [#_"Reader" r]
        (try
            (.read r)
            (catch IOException e
                (throw (Util'sneakyThrow e))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" LispReader'OPT_EOF (Keyword'intern (Symbol'intern nil, "eof")))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" LispReader'EOFTHROW (Keyword'intern (Symbol'intern nil, "eofthrow")))

    (defn #_"Object" LispReader'read-1 [#_"PushbackReader" r]
        (LispReader'read-4 r, true, nil, false)
    )

    (defn #_"Object" LispReader'read-4 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (LispReader'read-8 r, eofIsError, eofValue, nil, nil, isRecursive, nil, (cast' Resolver (.deref RT'READER_RESOLVER)))
    )

    (defn- #_"Object" LispReader'read-5 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" pendingForms]
        (LispReader'read-8 r, eofIsError, eofValue, nil, nil, isRecursive, (LispReader'ensurePending pendingForms), (cast' Resolver (.deref RT'READER_RESOLVER)))
    )

    (defn- #_"Object" LispReader'ensurePending [#_"Object" pendingForms]
        (or pendingForms (LinkedList.))
    )

    (defn- #_"Object" LispReader'read-8 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"Character" returnOn, #_"Object" returnOnValue, #_"boolean" isRecursive, #_"Object" pendingForms, #_"Resolver" resolver]
        (when-not (= (.deref RT'READEVAL) LispReader'UNKNOWN) => (throw (RuntimeException. "Reading disallowed - *read-eval* bound to :unknown"))
            (try
                (loop-when [] (or (not (instance? List pendingForms)) (.isEmpty (cast List pendingForms))) => (.remove (cast List pendingForms), 0)
                    (let [#_"int" ch (loop-when-recur [ch (LispReader'read1 r)] (LispReader'isWhitespace ch) [(LispReader'read1 r)] => ch)]
                        (cond
                            (= ch -1)
                                (if eofIsError (throw (RuntimeException. "EOF while reading")) eofValue)
                            (and (some? returnOn) (= (.charValue returnOn) ch))
                                returnOnValue
                            (Character/isDigit ch)
                                (LispReader'readNumber r, (char ch))
                            :else
                                (let [#_"IFn" macroFn (LispReader'getMacro ch)]
                                    (if (some? macroFn)
                                        (let [#_"Object" ret (.invoke macroFn, r, (char ch), pendingForms)]
                                            ;; no op macros return the reader
                                            (recur-if (= ret r) [] => ret)
                                        )
                                        (do
                                            (when (any = ch \+ \-)
                                                (let [#_"int" ch2 (LispReader'read1 r)]
                                                    (when (Character/isDigit ch2)
                                                        (LispReader'unread r, ch2)
                                                        (§ return (LispReader'readNumber r, (char ch)))
                                                    )
                                                    (LispReader'unread r, ch2)
                                                )
                                            )
                                            (LispReader'interpretToken (LispReader'readToken r, (char ch)), resolver)
                                        )
                                    )
                                )
                        )
                    )
                )
                (catch Exception e
                    (when (and (not isRecursive) (§ instance? LineNumberingPushbackReader r)) => (throw (Util'sneakyThrow e))
                        (let [#_"LineNumberingPushbackReader" rdr (cast' LineNumberingPushbackReader r)]
                            (throw (LispReaderException'new (.getLineNumber rdr), (.getColumnNumber rdr), e))
                        )
                    )
                )
            )
        )
    )

    (defn- #_"String" LispReader'readToken [#_"PushbackReader" r, #_"char" ch]
        (let [#_"StringBuilder" sb (StringBuilder.) _ (.append sb, ch)]
            (loop []
                (let [ch (LispReader'read1 r)]
                    (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isTerminatingMacro ch))
                        (do
                            (LispReader'unread r, ch)
                            (.toString sb)
                        )
                        (do
                            (.append sb, (char ch))
                            (recur)
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'readNumber [#_"PushbackReader" r, #_"char" ch]
        (let [#_"String" s
                (let [#_"StringBuilder" sb (StringBuilder.) _ (.append sb, ch)]
                    (loop []
                        (let [ch (LispReader'read1 r)]
                            (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isMacro ch))
                                (do
                                    (LispReader'unread r, ch)
                                    (.toString sb)
                                )
                                (do
                                    (.append sb, (char ch))
                                    (recur)
                                )
                            )
                        )
                    )
                )]
            (or (LispReader'matchNumber s) (throw (NumberFormatException. (str "Invalid number: " s))))
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-4 [#_"String" token, #_"int" offset, #_"int" n, #_"int" base]
        (when (= (.length token) (+ offset n)) => (throw (IllegalArgumentException. (str "Invalid unicode character: \\" token)))
            (loop-when [#_"int" uc 0 #_"int" i offset] (< i (+ offset n)) => (char uc)
                (let [#_"int" d (Character/digit (.charAt token, i), base)]
                    (when-not (= d -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt token, i))))
                        (recur (+ (* uc base) d) (inc i))
                    )
                )
            )
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-5 [#_"PushbackReader" r, #_"int" ch, #_"int" base, #_"int" n, #_"boolean" exact?]
        (let-when-not [#_"int" uc (Character/digit ch, base)] (= uc -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (char ch))))
            (let [[uc #_"int" i]
                    (loop-when [uc uc i 1] (< i n) => [uc i]
                        (let [ch (LispReader'read1 r)]
                            (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isMacro ch))
                                (do
                                    (LispReader'unread r, ch)
                                    [uc i]
                                )
                                (let [#_"int" d (Character/digit ch, base)]
                                    (when-not (= d -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (char ch))))
                                        (recur (+ (* uc base) d) (inc i))
                                    )
                                )
                            )
                        )
                    )]
                (when (or (= i n) (not exact?)) => (throw (IllegalArgumentException. (str "Invalid character length: " i ", should be: " n)))
                    uc
                )
            )
        )
    )

    (defn- #_"Object" LispReader'interpretToken [#_"String" s, #_"Resolver" resolver]
        (case s "nil" nil "true" RT'T "false" RT'F
            (or (LispReader'matchSymbol s, resolver) (throw (RuntimeException. (str "Invalid token: " s))))
        )
    )

    (defn- #_"Object" LispReader'matchSymbol [#_"String" s, #_"Resolver" resolver]
        (let-when [#_"Matcher" m (.matcher LispReader'symbolPat, s)] (.matches m)
            (let [#_"int" gc (.groupCount m) #_"String" ns (.group m, 1) #_"String" name (.group m, 2)]
                (cond
                    (or (and (some? ns) (.endsWith ns, ":/")) (.endsWith name, ":") (not= (.indexOf s, "::", 1) -1))
                        nil
                    (.startsWith s, "::")
                        (let [#_"Symbol" ks (Symbol'intern (.substring s, 2))]
                            (if (some? resolver)
                                (let [#_"Symbol" nsym
                                        (if (some? (:ns ks))
                                            (.resolveAlias resolver, (Symbol'intern (:ns ks)))
                                            (.currentNS resolver)
                                        )]
                                    ;; auto-resolving keyword
                                    (when (some? nsym)
                                        (Keyword'intern (Symbol'intern (:name nsym), (:name ks)))
                                    )
                                )
                                (let [#_"Namespace" kns
                                        (if (some? (:ns ks))
                                            (.lookupAlias (Compiler'currentNS), (Symbol'intern (:ns ks)))
                                            (Compiler'currentNS)
                                        )]
                                    ;; auto-resolving keyword
                                    (when (some? kns)
                                        (Keyword'intern (Symbol'intern (:name (:name kns)), (:name ks)))
                                    )
                                )
                            )
                        )
                    :else
                        (let [#_"boolean" isKeyword (= (.charAt s, 0) \:) #_"Symbol" sym (Symbol'intern (.substring s, (if isKeyword 1 0)))]
                            (if isKeyword (Keyword'intern sym) sym)
                        )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'matchNumber [#_"String" s]
        (let [_ (or
                    (let-when [#_"Matcher" m (.matcher LispReader'intPat, s)] (.matches m)
                        (if (some? (.group m, 2))
                            (if (some? (.group m, 8))
                                BigInt'ZERO
                                (Numbers'num-1l 0)
                            )
                            (let [[#_"String" n #_"int" radix]
                                    (cond-let
                                        [n (.group m, 3)] [n 10]
                                        [n (.group m, 4)] [n 16]
                                        [n (.group m, 5)] [n 8]
                                        [n (.group m, 7)] [n (Integer/parseInt (.group m, 6))]
                                    )]
                                (when (some? n) => :nil
                                    (let [#_"BigInteger" bn (BigInteger. n, radix) bn (if (= (.group m, 1) "-") (.negate bn) bn)]
                                        (cond
                                            (some? (.group m, 8))  (BigInt'fromBigInteger bn)
                                            (< (.bitLength bn) 64) (Numbers'num-1l (.longValue bn))
                                            :else                  (BigInt'fromBigInteger bn)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (let-when [#_"Matcher" m (.matcher LispReader'floatPat, s)] (.matches m)
                        (if (some? (.group m, 4))
                            (§ unsure BigDecimal. (.group m, 1))
                            (Double/parseDouble s)
                        )
                    )
                    (let-when [#_"Matcher" m (.matcher LispReader'ratioPat, s)] (.matches m)
                        (let [#_"String" numerator (.group m, 1) numerator (if (.startsWith numerator, "+") (.substring numerator, 1) numerator)]
                            (Numbers'divide-2oo
                                (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. numerator))),
                                (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. (.group m, 2))))
                            )
                        )
                    )
                )]
            (when-not (= _ :nil) _)
        )
    )

    (defn- #_"IFn" LispReader'getMacro [#_"int" ch]
        (when (< ch (alength LispReader'macros))
            (aget LispReader'macros ch)
        )
    )

    (defn- #_"boolean" LispReader'isMacro [#_"int" ch]
        (and (< ch (alength LispReader'macros)) (some? (aget LispReader'macros ch)))
    )

    (defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ch]
        (and (not= ch \#) (not= ch \') (not= ch \%) (LispReader'isMacro ch))
    )

    (defn #_"Symbol" LispReader'garg [#_"int" n]
        (Symbol'intern nil, (str (if (= n -1) "rest" (str "p" n)) "__" (RT'nextID) "#"))
    )

    (defn #_"Symbol" LispReader'registerArg [#_"int" n]
        (let [#_"PersistentTreeMap" args (cast' PersistentTreeMap (.deref LispReader'ARG_ENV))]
            (when (some? args) => (throw (IllegalStateException. "arg literal not in #()"))
                (or (cast' Symbol (.valAt args, n))
                    (let [#_"Symbol" sym (LispReader'garg n)]
                        (.set LispReader'ARG_ENV, (.assoc args, n, sym))
                        sym
                    )
                )
            )
        )
    )

    (defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" form]
        (and (§ instance? ISeq form) (Util'equals (RT'first form), LispReader'UNQUOTE_SPLICING))
    )

    (defn #_"boolean" LispReader'isUnquote [#_"Object" form]
        (and (§ instance? ISeq form) (Util'equals (RT'first form), LispReader'UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (def- #_"Object" LispReader'READ_EOF (Object.))
    (def- #_"Object" LispReader'READ_FINISHED (Object.))

    (defn #_"List" LispReader'readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" pendingForms]
        (let [#_"Resolver" resolver (cast' Resolver (.deref RT'READER_RESOLVER))
              #_"int" firstline (if (§ instance? LineNumberingPushbackReader r) (.getLineNumber (cast' LineNumberingPushbackReader r)) -1)
              #_"ArrayList" a (ArrayList.)]
            (loop []
                (let [#_"Object" form (LispReader'read-8 r, false, LispReader'READ_EOF, delim, LispReader'READ_FINISHED, isRecursive, pendingForms, resolver)]
                    (condp = form
                        LispReader'READ_EOF
                            (if (neg? firstline)
                                (throw (RuntimeException. "EOF while reading"))
                                (throw (RuntimeException. (str "EOF while reading, starting at line " firstline)))
                            )
                        LispReader'READ_FINISHED
                            a
                        (do
                            (.add a, form)
                            (recur)
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(class-ns RetryEx (§ extends Error)
    (defn #_"RetryEx" RetryEx'new []
        (§ foreign Error'new)
    )
)

(class-ns AbortException (§ extends Exception)
    (defn #_"AbortException" AbortException'new []
        (§ foreign Exception'new)
    )
)

(class-ns LockingTransactionInfo
    (defn- #_"LockingTransactionInfo" LockingTransactionInfo'init []
        (hash-map
            #_"AtomicInteger" :status nil
            #_"long" :startPoint 0
            #_"CountDownLatch" :latch nil
        )
    )

    (defn #_"LockingTransactionInfo" LockingTransactionInfo'new [#_"int" status, #_"long" startPoint]
        (let [this (LockingTransactionInfo'init)]
            (§ ass this (assoc this :status (AtomicInteger. status)))
            (§ ass this (assoc this :startPoint startPoint))
            (§ ass this (assoc this :latch (CountDownLatch. 1)))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method running) [#_"LockingTransactionInfo" this]
        (let [#_"int" s (.get (:status this))]
            (or (= s LockingTransaction'RUNNING) (= s LockingTransaction'COMMITTING))
        )
    )
)

(class-ns CFn
    (defn- #_"CFn" CFn'init []
        (hash-map
            #_"IFn" :fn nil
            #_"ISeq" :args nil
        )
    )

    (defn #_"CFn" CFn'new [#_"IFn" fn, #_"ISeq" args]
        (let [this (CFn'init)]
            (§ ass this (assoc this :fn fn))
            (§ ass this (assoc this :args args))
            this
        )
    )
)

(class-ns Notify
    (defn- #_"Notify" Notify'init []
        (hash-map
            #_"Ref" :ref nil
            #_"Object" :oldval nil
            #_"Object" :newval nil
        )
    )

    (defn #_"Notify" Notify'new [#_"Ref" ref, #_"Object" oldval, #_"Object" newval]
        (let [this (Notify'init)]
            (§ ass this (assoc this :ref ref))
            (§ ass this (assoc this :oldval oldval))
            (§ ass this (assoc this :newval newval))
            this
        )
    )
)

(class-ns LockingTransaction
    (def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (def #_"long" LockingTransaction'BARGE_WAIT_NANOS (* 10 1000000))

    (def #_"int" LockingTransaction'RUNNING 0)
    (def #_"int" LockingTransaction'COMMITTING 1)
    (def #_"int" LockingTransaction'RETRY 2)
    (def #_"int" LockingTransaction'KILLED 3)
    (def #_"int" LockingTransaction'COMMITTED 4)

    (def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ThreadLocal.))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (defn- #_"LockingTransaction" LockingTransaction'init []
        (hash-map
            #_"LockingTransactionInfo" :info nil
            #_"long" :readPoint 0
            #_"long" :startPoint 0
            #_"long" :startTime 0

            #_"RetryEx" :retryex (RetryEx'new)
            #_"ArrayList<AgentAction>" :actions (ArrayList.)
            #_"HashMap<Ref, Object>" :vals (HashMap.)
            #_"HashSet<Ref>" :sets (HashSet.)
            #_"TreeMap<Ref, ArrayList<CFn>>" :commutes (TreeMap.)

            #_"HashSet<Ref>" :ensures (HashSet.) ;; all hold readLock
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'new []
        (LockingTransaction'init)
    )

    #_method
    (§ defn #_"void" (§ method getReadPoint) [#_"LockingTransaction" this]
        (§ ass this (assoc this :readPoint (.incrementAndGet lastPoint)))
        nil
    )

    #_method
    (§ defn #_"long" (§ method getCommitPoint) [#_"LockingTransaction" this]
        (.incrementAndGet lastPoint)
    )

    #_method
    (§ defn #_"void" (§ method stop) [#_"LockingTransaction" this, #_"int" status]
        (when (some? (:info this))
            (§ sync (:info this)
                (.set (:status (:info this)), status)
                (.countDown (:latch (:info this)))
            )
            (§ ass this (assoc this :info nil))
            (.clear (:vals this))
            (.clear (:sets this))
            (.clear (:commutes this))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method tryWriteLock) [#_"LockingTransaction" this, #_"Ref" ref]
        (try
            (when (not (.tryLock (.writeLock (:lock ref)), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
                (throw (:retryex this))
            )
            (catch InterruptedException e
                (throw (:retryex this))
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" (§ method lock) [#_"LockingTransaction" this, #_"Ref" ref]
        ;; can't upgrade readLock, so release it
        (.releaseIfEnsured this, ref)

        (let [#_"boolean" unlocked true]
            (try
                (.tryWriteLock this, ref)
                (§ ass unlocked false)

                (when-not (and (some? (:tvals ref)) (< (:readPoint this) (:point (:tvals ref)))) => (throw (:retryex this))
                    (let [#_"LockingTransactionInfo" refinfo (:tinfo ref)]
                        ;; write lock conflict
                        (if (and (some? refinfo) (not= refinfo (:info this)) (.running refinfo) (not (.barge this, refinfo)))
                            (do
                                (.unlock (.writeLock (:lock ref)))
                                (§ ass unlocked true)
                                (.blockAndBail this, refinfo)
                            )
                            (do
                                (§ ass (:tinfo ref) (:info this))
                                (when (some? (:tvals ref)) (:val (:tvals ref)))
                            )
                        )
                    )
                )
                (finally
                    (when-not unlocked
                        (.unlock (.writeLock (:lock ref)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method blockAndBail) [#_"LockingTransaction" this, #_"LockingTransactionInfo" refinfo]
        ;; stop prior to blocking
        (.stop this, LockingTransaction'RETRY)
        (try
            (.await (:latch refinfo), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS)
            (catch InterruptedException _
                ;; ignore
            )
        )
        (throw (:retryex this))
    )

    #_method
    (§ defn- #_"void" (§ method releaseIfEnsured) [#_"LockingTransaction" this, #_"Ref" ref]
        (when (.contains (:ensures this), ref)
            (.remove (:ensures this), ref)
            (.unlock (.readLock (:lock ref)))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method abort) [#_"LockingTransaction" this] #_(§ throws AbortException)
        (.stop this, LockingTransaction'KILLED)
        (throw (AbortException'new))
    )

    #_method
    (§ defn- #_"boolean" (§ method bargeTimeElapsed) [#_"LockingTransaction" this]
        (< LockingTransaction'BARGE_WAIT_NANOS (- (System/nanoTime) (:startTime this)))
    )

    #_method
    (§ defn- #_"boolean" (§ method barge) [#_"LockingTransaction" this, #_"LockingTransactionInfo" refinfo]
        (let [#_"boolean" barged false]
            ;; if this transaction is older, try to abort the other
            (when (and (.bargeTimeElapsed this) (< (:startPoint this) (:startPoint refinfo)))
                (§ ass barged (.compareAndSet (:status refinfo), LockingTransaction'RUNNING, LockingTransaction'KILLED))
                (when barged
                    (.countDown (:latch refinfo))
                )
            )
            barged
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (and (some? t) (some? (:info t))) => (throw (IllegalStateException. "No transaction running"))
                t
            )
        )
    )

    (defn #_"boolean" LockingTransaction'isRunning []
        (some? (LockingTransaction'getRunning))
    )

    (defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (and (some? t) (some? (:info t)))
                t
            )
        )
    )

    (defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" fn] #_(§ throws Exception)
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (nil? t) => (if (some? (:info t)) (.call fn) (.run t, fn))
                (let [t (LockingTransaction'new)]
                    (.set LockingTransaction'transaction, t)
                    (try
                        (.run t, fn)
                        (finally
                            (.remove LockingTransaction'transaction)
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method run) [#_"LockingTransaction" this, #_"Callable" fn] #_(§ throws Exception)
        (let [#_"boolean" done false]
            (let [#_"Object" ret nil]
                (let [#_"ArrayList<Ref>" locked (ArrayList.)]
                    (let [#_"ArrayList<Notify>" notify (ArrayList.)]
                        (loop-when-recur [#_"int" i 0] (and (not done) (< i LockingTransaction'RETRY_LIMIT)) [(inc i)]
                            (try
                                (.getReadPoint this)
                                (when (zero? i)
                                    (§ ass this (assoc this :startPoint (:readPoint this)))
                                    (§ ass this (assoc this :startTime (System/nanoTime)))
                                )
                                (§ ass this (assoc this :info (LockingTransactionInfo'new LockingTransaction'RUNNING, (:startPoint this))))
                                (§ ass ret (.call fn))
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (.compareAndSet (:status (:info this)), LockingTransaction'RUNNING, LockingTransaction'COMMITTING)
                                    (doseq [#_"Map$Entry<Ref, ArrayList<CFn>>" e (.entrySet (:commutes this))]
                                        (let [#_"Ref" ref (.getKey e)]
                                            (when (.contains (:sets this), ref)
                                                (§ continue )
                                            )

                                            (let [#_"boolean" wasEnsured (.contains (:ensures this), ref)]
                                                ;; can't upgrade readLock, so release it
                                                (.releaseIfEnsured this, ref)
                                                (.tryWriteLock this, ref)
                                                (.add locked, ref)
                                                (when (and wasEnsured (some? (:tvals ref)) (< (:readPoint this) (:point (:tvals ref))))
                                                    (throw (:retryex this))
                                                )

                                                (let [#_"LockingTransactionInfo" refinfo (:tinfo ref)]
                                                    (when (and (some? refinfo) (not= refinfo (:info this)) (.running refinfo))
                                                        (when (not (.barge this, refinfo))
                                                            (throw (:retryex this))
                                                        )
                                                    )
                                                    (let [#_"Object" val (when (some? (:tvals ref)) (:val (:tvals ref)))]
                                                        (.put (:vals this), ref, val)
                                                        (doseq [#_"CFn" f (.getValue e)]
                                                            (.put (:vals this), ref, (.applyTo (:fn f), (RT'cons (.get (:vals this), ref), (:args f))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ref (:sets this)]
                                        (.tryWriteLock this, ref)
                                        (.add locked, ref)
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map$Entry<Ref, Object>" e (.entrySet (:vals this))]
                                        (let [#_"Ref" ref (.getKey e)]
                                            (.validate ref, (.getValidator ref), (.getValue e))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" commitPoint (.getCommitPoint this)]
                                        (doseq [#_"Map$Entry<Ref, Object>" e (.entrySet (:vals this))]
                                            (let [#_"Ref" ref (.getKey e)]
                                                (let [#_"Object" oldval (when (some? (:tvals ref)) (:val (:tvals ref)))]
                                                    (let [#_"Object" newval (.getValue e)]
                                                        (let [#_"int" hcount (.histCount ref)]
                                                            (cond (nil? (:tvals ref))
                                                                (do
                                                                    (§ ass (:tvals ref) (RefTVal'new-2 newval, commitPoint))
                                                                )
                                                                (or (and (pos? (.get (:faults ref))) (< hcount (:maxHistory ref))) (< hcount (:minHistory ref)))
                                                                (do
                                                                    (§ ass (:tvals ref) (RefTVal'new-3 newval, commitPoint, (:tvals ref)))
                                                                    (.set (:faults ref), 0)
                                                                )
                                                                :else
                                                                (do
                                                                    (§ ass (:tvals ref) (:next (:tvals ref)))
                                                                    (§ ass (:val (:tvals ref)) newval)
                                                                    (§ ass (:point (:tvals ref)) commitPoint)
                                                                )
                                                            )
                                                            (when (pos? (.count (.getWatches ref)))
                                                                (.add notify, (Notify'new ref, oldval, newval))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (§ ass done true)
                                        (.set (:status (:info this)), LockingTransaction'COMMITTED)
                                    )
                                )
                                (§ catch RetryEx retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [#_"int" k (dec (.size locked))] (<= 0 k) [(dec k)]
                                        (.unlock (.writeLock (:lock (.get locked, k))))
                                    )
                                    (.clear locked)
                                    (doseq [#_"Ref" r (:ensures this)]
                                        (.unlock (.readLock (:lock r)))
                                    )
                                    (.clear (:ensures this))
                                    (.stop this, (if done LockingTransaction'COMMITTED LockingTransaction'RETRY))
                                    (try
                                        (when done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" n notify]
                                                (.notifyWatches (:ref n), (:oldval n), (:newval n))
                                            )
                                            (doseq [#_"AgentAction" action (:actions this)]
                                                (Agent'dispatchAction action)
                                            )
                                        )
                                        (finally
                                            (.clear notify)
                                            (.clear (:actions this))
                                        )
                                    )
                                )
                            )
                        )
                        (when (not done)
                            (throw (RuntimeException. "Transaction failed after reaching retry limit"))
                        )
                        ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method enqueue) [#_"LockingTransaction" this, #_"AgentAction" action]
        (.add (:actions this), action)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method doGet) [#_"LockingTransaction" this, #_"Ref" ref]
        (when (.running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:vals this), ref) => (.get (:vals this), ref)
                (let [_ (try
                            (.lock (.readLock (:lock ref)))
                            (let-when [#_"RefTVal" ver (:tvals ref)] (some? ver) => (throw (IllegalStateException. (str (.toString ref) " is unbound.")))
                                (loop-when [ver ver] (< (:readPoint this) (:point ver)) => (:val ver)
                                    (let-when [ver (:prior ver)] (not= ver (:tvals ref)) => :nil
                                        (recur ver)
                                    )
                                )
                            )
                            (finally
                                (.unlock (.readLock (:lock ref)))
                            )
                        )]
                    (when (= _ :nil) => _
                        ;; no version of val precedes the read point
                        (.incrementAndGet (:faults ref))
                        (throw (:retryex this))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method doSet) [#_"LockingTransaction" this, #_"Ref" ref, #_"Object" val]
        (when (.running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:commutes this), ref) => (throw (IllegalStateException. "Can't set after commute"))
                (when-not (.contains (:sets this), ref)
                    (.add (:sets this), ref)
                    (.lock this, ref)
                )
                (.put (:vals this), ref, val)
                val
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method doEnsure) [#_"LockingTransaction" this, #_"Ref" ref]
        (when (.running (:info this)) => (throw (:retryex this))
            (when-not (.contains (:ensures this), ref)
                (.lock (.readLock (:lock ref)))
                ;; someone completed a write after our snapshot
                (let-when [#_"RefTVal" ver (:tvals ref)] (and (some? ver) (< (:readPoint this) (:point ver)))
                    (.unlock (.readLock (:lock ref)))
                    (throw (:retryex this))
                )
                (let-when [#_"LockingTransactionInfo" refinfo (:tinfo ref)] (and (some? refinfo) (.running refinfo)) => (.add (:ensures this), ref)
                    ;; writer exists
                    (.unlock (.readLock (:lock ref)))
                    (when-not (= refinfo (:info this)) ;; not us, ensure is doomed
                        (.blockAndBail this, refinfo)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method doCommute) [#_"LockingTransaction" this, #_"Ref" ref, #_"IFn" fn, #_"ISeq" args]
        (when (.running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:vals this), ref)
                (let [#_"Object" val
                        (try
                            (.lock (.readLock (:lock ref)))
                            (when (some? (:tvals ref)) (:val (:tvals ref)))
                            (finally
                                (.unlock (.readLock (:lock ref)))
                            )
                        )]
                    (.put (:vals this), ref, val)
                )
            )
            (let [#_"ArrayList<CFn>" fns (.get (:commutes this), ref)]
                (when (nil? fns)
                    (.put (:commutes this), ref, (§ ass fns (ArrayList.)))
                )
                (.add fns, (CFn'new fn, args))
                (let [#_"Object" ret (.applyTo fn, (RT'cons (.get (:vals this), ref), args))]
                    (.put (:vals this), ref, ret)
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_private
(§ defprotocol LongRangeBoundsCheck
    #_abstract
    (#_"boolean" LongRangeBoundsCheck'''(§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" val])
)

#_non-static
(class-ns LongRangeIterator (§ implements Iterator)
    (defn- #_"LongRangeIterator" LongRangeIterator'init []
        (hash-map
            #_"long" :next 0
            #_"boolean" :hasNext false
        )
    )

    (defn #_"LongRangeIterator" LongRangeIterator'new []
        (let [this (LongRangeIterator'init)]
            (§ ass this (assoc this :next (:start this)))
            (§ ass this (assoc this :hasNext true))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"LongRangeIterator" this]
        (:hasNext this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"LongRangeIterator" this]
        (if (:hasNext this)
            (do
                (let [#_"long" ret (:next this)]
                    (try
                        (§ ass this (assoc this :next (Numbers'add-2ll (:next this), (:step this))))
                        (§ ass this (assoc this :hasNext (not (.exceededBounds (:boundsCheck this), (:next this)))))
                        (catch ArithmeticException e
                            (§ ass this (assoc this :hasNext false))
                        )
                    )
                    ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"LongRangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

#_private
(class-ns LongChunk (§ implements IChunk)
    (defn- #_"LongChunk" LongChunk'init []
        (hash-map
            #_"long" :start 0
            #_"long" :step 0
            #_"int" :count 0
        )
    )

    (defn #_"LongChunk" LongChunk'new [#_"long" start, #_"long" step, #_"int" count]
        (let [this (LongChunk'init)]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :count count))
            this
        )
    )

    #_method
    (§ defn #_"long" (§ method first) [#_"LongChunk" this]
        (:start this)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"LongChunk" this, #_"int" i]
        (+ (:start this) (* i (:step this)))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"LongChunk" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (:count this)) (+ (:start this) (* i (:step this))) notFound)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"LongChunk" this]
        (:count this)
    )

    #_method
    (§ defn #_"LongChunk" (§ method dropFirst) [#_"LongChunk" this]
        (when (< 1 (:count this)) => (throw (IllegalStateException. "dropFirst of empty chunk"))
            (LongChunk'new (+ (:start this) (:step this)), (:step this), (dec (:count this)))
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongChunk" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"long" x (:start this) #_"int" i 0] (< i (:count this)) => r
            (let-when-not [r (.invoke f, r, x)] (RT'isReduced r) => r
                (recur r (+ x (:step this)) (inc i))
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (def- #_"int" LongRange'CHUNK_SIZE 32)

    (defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" val]
                (<= end val)
            )
        )
    )

    (defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" val]
                (<= val end)
            )
        )
    )

    (defn- #_"LongRange" LongRange'init []
        (hash-map
            ;; Invariants guarantee this is never an empty or infinite seq
            #_"long" :start 0
            #_"long" :end 0
            #_"long" :step 0
            #_"LongRangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"LongChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"LongRange" LongRange'new-4 [#_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-6 [#_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-7 [#_"IPersistentMap" meta, #_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new meta) (LongRange'init))]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn #_"ISeq" LongRange'create-1 [#_"long" end]
        (if (< 0 end)
            (LongRange'new-4 0, end, 1, (LongRange'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" LongRange'create-2 [#_"long" start, #_"long" end]
        (if (< start end)
            (LongRange'new-4 start, end, 1, (LongRange'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" LongRange'create-3 [#_"long" start, #_"long" end, #_"long" step]
        (cond
            (pos? step) (if (< start end) (LongRange'new-4 start, end, step, (LongRange'positiveStep end)) PersistentList'EMPTY)
            (neg? step) (if (< end start) (LongRange'new-4 start, end, step, (LongRange'negativeStep end)) PersistentList'EMPTY)
            :else       (if (= start end) PersistentList'EMPTY (Repeat'create-1 start))
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"LongRange" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (LongRange'new-7 meta, (:start this), (:end this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"LongRange" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" (§ method forceChunk) [#_"LongRange" this]
        (when (nil? (:_chunk this))
            (let [#_"long" n
                    (try
                        (.rangeCount this, (:start this), (:end this), (:step this))
                        (catch ArithmeticException e
                            ;; size of total range is > Long.MAX_VALUE, so must step to count
                            ;; this only happens in pathological range cases like:
                            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                            (.steppingCount this, (:start this), (:end this), (:step this))
                        )
                    )]
                (if (< LongRange'CHUNK_SIZE n)
                    ;; not last chunk
                    (let [#_"long" nextStart (+ (:start this) (* (:step this) LongRange'CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass this (assoc this :_chunkNext (LongRange'new-4 nextStart, (:end this), (:step this), (:boundsCheck this))))
                        (§ ass this (assoc this :_chunk (LongChunk'new (:start this), (:step this), LongRange'CHUNK_SIZE)))
                    )
                    ;; last chunk
                    (§ ass this (assoc this :_chunk (LongChunk'new (:start this), (:step this), (int n)))) ;; n must be <= CHUNK_SIZE
                )
            )
        )
        nil
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"LongRange" this]
        (let-when [#_"ISeq" _next (:_next this)] (nil? _next) => _next
            (.forceChunk this)
            (when (< 1 (.count (:_chunk this))) => (.chunkedNext this)
                (let [#_"LongChunk" _rest (.dropFirst (:_chunk this))
                      _next (LongRange'new-6 (.first _rest), (:end this), (:step this), (:boundsCheck this), _rest, (:_chunkNext this))]
                    (§ ass this (assoc this :_next _next))
                    _next
                )
            )
        )
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"LongRange" this]
        (.forceChunk this)
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"LongRange" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"LongRange" this]
        (.forceChunk this)
        (or (:_chunkNext this) PersistentList'EMPTY)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" (§ method steppingCount) [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        (loop-when [#_"long" s start #_"long" n 1] (<= n LongRange'CHUNK_SIZE) => n
            (let [[s n]
                    (try
                        (let [s (Numbers'add-2ll s, step)]
                            (if (.exceededBounds (:boundsCheck this), s)
                                [nil n]
                                [s (inc n)]
                            )
                        )
                        (catch ArithmeticException _
                            [nil n]
                        )
                    )]
                (recur-if (some? s) [s n] => n)
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" (§ method rangeCount) [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (/ (Numbers'add-2ll (Numbers'add-2ll (Numbers'minus-2ll end, start), step), (if (pos? (:step this)) -1 1)) step)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"LongRange" this]
        (try
            (let [#_"long" n (.rangeCount this, (:start this), (:end this), (:step this))]
                (when (<= n Integer/MAX_VALUE) => (Numbers'throwIntOverflow)
                    (int n)
                )
            )
            (catch ArithmeticException _
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"long" n
                        (loop-when-recur [#_"Iterator" it (.iterator this) n 0] (.hasNext it) [it (inc n)] => n
                            (.next it)
                        )]
                    (when (<= n Integer/MAX_VALUE) => (Numbers'throwIntOverflow)
                        (int n)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongRange" this, #_"IFn" f]
        (loop [#_"Object" r (:start this) #_"long" n r]
            (let-when-not [n (+ n (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast' Reduced r))
                    (recur r n)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongRange" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"long" n (:start this)]
            (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast' Reduced r))
                (let-when-not [n (+ n (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                    (recur r n)
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"LongRange" this]
        (LongRangeIterator'new)
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (defn #_"MapEntry" MapEntry'create [#_"Object" key, #_"Object" val]
        (MapEntry'new key, val)
    )

    (defn- #_"MapEntry" MapEntry'init []
        (hash-map
            #_"Object" :_key nil
            #_"Object" :_val nil
        )
    )

    (defn #_"MapEntry" MapEntry'new [#_"Object" key, #_"Object" val]
        (let [this (merge (AMapEntry'new) (MapEntry'init))]
            (§ ass this (assoc this :_key key))
            (§ ass this (assoc this :_val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method key) [#_"MapEntry" this]
        (:_key this)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"MapEntry" this]
        (:_val this)
    )

    #_method
    (§ defn #_"Object" (§ method getKey) [#_"MapEntry" this]
        (.key this)
    )

    #_method
    (§ defn #_"Object" (§ method getValue) [#_"MapEntry" this]
        (.val this)
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ defprotocol MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns Entry
    (defn- #_"Entry" Entry'init []
        (hash-map
            #_"Class" :c nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"Entry" Entry'new [#_"Class" c, #_"IFn" fn]
        (let [this (Entry'init)]
            (§ ass this (assoc this :c c))
            (§ ass this (assoc this :fn fn))
            this
        )
    )
)

(class-ns MethodImplCache
    (defn- #_"MethodImplCache" MethodImplCache'init []
        (hash-map
            #_"IPersistentMap" :protocol nil
            #_"Keyword" :methodk nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"Object[]" :table nil ;; [class, entry. class, entry ...]
            #_"Map" :map nil

            #_"Entry" :mre nil
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-2 [#_"IPersistentMap" protocol, #_"Keyword" methodk]
        (MethodImplCache'new-5 protocol, methodk, 0, 0, RT'EMPTY_ARRAY)
    )

    (defn #_"MethodImplCache" MethodImplCache'new-5 [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"int" shift, #_"int" mask, #_"Object[]" table]
        (let [this (MethodImplCache'init)]
            (§ ass this (assoc this :protocol protocol))
            (§ ass this (assoc this :methodk methodk))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :mask mask))
            (§ ass this (assoc this :table table))
            (§ ass this (assoc this :map nil))
            this
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-3 [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"Map" map]
        (let [this (MethodImplCache'init)]
            (§ ass this (assoc this :protocol protocol))
            (§ ass this (assoc this :methodk methodk))
            (§ ass this (assoc this :shift 0))
            (§ ass this (assoc this :mask 0))
            (§ ass this (assoc this :table nil))
            (§ ass this (assoc this :map map))
            this
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fnFor) [#_"MethodImplCache" this, #_"Class" c]
        (let [#_"Entry" last (:mre this)]
            (if (and (some? last) (= (:c last) c)) (:fn last) (.findFnFor this, c))
        )
    )

    #_method
    (§ defn #_"IFn" (§ method findFnFor) [#_"MethodImplCache" this, #_"Class" c]
        (if (some? (:map this))
            (let [#_"Entry" e (cast' Entry (.get (:map this), c))]
                (§ ass this (assoc this :mre e))
                (when (some? e) (:fn e))
            )
            (let [#_"int" idx (<< (& (>> (Util'hash c) (:shift this)) (:mask this)) 1)]
                (when (and (< idx (alength (:table this))) (= (aget (:table this) idx) c))
                    (let [#_"Entry" e (cast' Entry (aget (:table this) (inc idx)))]
                        (§ ass this (assoc this :mre e))
                        (when (some? e) (:fn e))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" MultiFn'assoc (RT'var "cloiure.core", "assoc"))
    (§ def #_"Var" MultiFn'dissoc (RT'var "cloiure.core", "dissoc"))
    (§ def #_"Var" MultiFn'isa (RT'var "cloiure.core", "isa?"))
    (§ def #_"Var" MultiFn'parents (RT'var "cloiure.core", "parents"))

    (defn- #_"MultiFn" MultiFn'init []
        (hash-map
            #_"IFn" :dispatchFn nil
            #_"Object" :defaultDispatchVal nil
            #_"IRef" :hierarchy nil
            #_"String" :name nil
            #_"ReentrantReadWriteLock" :rw nil

            #_volatile
            #_"IPersistentMap" :methodTable nil
            #_volatile
            #_"IPersistentMap" :preferTable nil
            #_volatile
            #_"IPersistentMap" :methodCache nil
            #_volatile
            #_"Object" :cachedHierarchy nil
        )
    )

    (defn #_"MultiFn" MultiFn'new [#_"String" name, #_"IFn" dispatchFn, #_"Object" defaultDispatchVal, #_"IRef" hierarchy]
        (let [this (merge (AFn'new) (MultiFn'init))]
            (§ ass this (assoc this :rw (ReentrantReadWriteLock.)))
            (§ ass this (assoc this :name name))
            (§ ass this (assoc this :dispatchFn dispatchFn))
            (§ ass this (assoc this :defaultDispatchVal defaultDispatchVal))
            (§ ass this (assoc this :methodTable PersistentHashMap'EMPTY))
            (§ ass this (assoc this :methodCache (.getMethodTable this)))
            (§ ass this (assoc this :preferTable PersistentHashMap'EMPTY))
            (§ ass this (assoc this :hierarchy hierarchy))
            (§ ass this (assoc this :cachedHierarchy nil))
            this
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method reset) [#_"MultiFn" this]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodTable (§ ass this (assoc this :methodCache (§ ass this (assoc this :preferTable PersistentHashMap'EMPTY))))))
            (§ ass this (assoc this :cachedHierarchy nil))
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method addMethod) [#_"MultiFn" this, #_"Object" dispatchVal, #_"IFn" method]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodTable (.assoc (.getMethodTable this), dispatchVal, method)))
            (.resetCache this)
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method removeMethod) [#_"MultiFn" this, #_"Object" dispatchVal]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodTable (.without (.getMethodTable this), dispatchVal)))
            (.resetCache this)
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method preferMethod) [#_"MultiFn" this, #_"Object" dispatchValX, #_"Object" dispatchValY]
        (.lock (.writeLock (:rw this)))
        (try
            (when (.prefers this, dispatchValY, dispatchValX)
                (throw (IllegalStateException. (str "Preference conflict in multimethod '" (:name this) "': " dispatchValY " is already preferred to " dispatchValX)))
            )
            (§ ass this (assoc this :preferTable (.assoc (.getPreferTable this), dispatchValX, (RT'conj (cast' IPersistentCollection (RT'get-3 (.getPreferTable this), dispatchValX, PersistentHashSet'EMPTY)), dispatchValY))))
            (.resetCache this)
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method prefers) [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (or
            (let [#_"IPersistentSet" xprefs (cast' IPersistentSet (.valAt (.getPreferTable this), x))]
                (and (some? xprefs) (.contains xprefs, y))
            )
            (loop-when [#_"ISeq" ps (RT'seq (.invoke MultiFn'parents, y))] (some? ps) => false
                (or (.prefers this, x, (.first ps)) (recur (.next ps)))
            )
            (loop-when [#_"ISeq" ps (RT'seq (.invoke MultiFn'parents, x))] (some? ps) => false
                (or (.prefers this, (.first ps), y) (recur (.next ps)))
            )
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method isA) [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (RT'booleanCast-1o (.invoke isa, (.deref (:hierarchy this)), x, y))
    )

    #_method
    (§ defn- #_"boolean" (§ method dominates) [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (or (.prefers this, x, y) (.isA this, x, y))
    )

    #_method
    (§ defn- #_"IPersistentMap" (§ method resetCache) [#_"MultiFn" this]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodCache (.getMethodTable this)))
            (§ ass this (assoc this :cachedHierarchy (.deref (:hierarchy this))))
            (:methodCache this)
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method getMethod) [#_"MultiFn" this, #_"Object" dispatchVal]
        (when-not (= (:cachedHierarchy this) (.deref (:hierarchy this)))
            (.resetCache this)
        )
        (let [#_"IFn" targetFn (cast' IFn (.valAt (:methodCache this), dispatchVal))]
            (or targetFn (.findAndCacheBestMethod this, dispatchVal))
        )
    )

    #_method
    (§ defn- #_"IFn" (§ method getFn) [#_"MultiFn" this, #_"Object" dispatchVal]
        (let [#_"IFn" targetFn (.getMethod this, dispatchVal)]
            (or targetFn (throw (IllegalArgumentException. (str "No method in multimethod '" (:name this) "' for dispatch value: " dispatchVal))))
        )
    )

    #_method
    (§ defn- #_"IFn" (§ method findAndCacheBestMethod) [#_"MultiFn" this, #_"Object" dispatchVal]
        (.lock (.readLock (:rw this)))
        (let [#_"IPersistentMap" mt (:methodTable this) #_"IPersistentMap" pt (:preferTable this) #_"Object" ch (:cachedHierarchy this)]
            (let [#_"Object" bestValue
                    (try
                        (let [#_"Map$Entry" bestEntry nil
                              _ (doseq [#_"Object" o (.getMethodTable this)]
                                    (let-when [#_"Map$Entry" e (cast Map$Entry o)] (.isA this, dispatchVal, (.getKey e))
                                        (when (or (nil? bestEntry) (.dominates this, (.getKey e), (.getKey bestEntry)))
                                            (§ ass bestEntry e)
                                        )
                                        (when-not (.dominates this, (.getKey bestEntry), (.getKey e))
                                            (throw (IllegalArgumentException. (str "Multiple methods in multimethod '" (:name this) "' match dispatch value: " dispatchVal " -> " (.getKey e) " and " (.getKey bestEntry) ", and neither is preferred")))
                                        )
                                    )
                                )]
                            (if (some? bestEntry) (.getValue bestEntry) (.valAt (:methodTable this), (:defaultDispatchVal this)))
                        )
                        (finally
                            (.unlock (.readLock (:rw this)))
                        )
                    )]
                (when (some? bestValue)
                    ;; ensure basis has stayed stable throughout, else redo
                    (.lock (.writeLock (:rw this)))
                    (try
                        (if (and (= mt (:methodTable this)) (= pt (:preferTable this)) (= ch (:cachedHierarchy this)) (= (:cachedHierarchy this) (.deref (:hierarchy this))))
                            (do
                                ;; place in cache
                                (§ ass this (assoc this :methodCache (.assoc (:methodCache this), dispatchVal, bestValue)))
                                (cast' IFn bestValue)
                            )
                            (do
                                (.resetCache this)
                                (.findAndCacheBestMethod this, dispatchVal)
                            )
                        )
                        (finally
                            (.unlock (.writeLock (:rw this)))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this]
        (.invoke (.getFn this, (.invoke (:dispatchFn this))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1)),
            (Util'ret1 arg1, (§ ass arg1 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.invoke (.getFn this, (.invoke (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, args)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil)),
            args
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getMethodTable) [#_"MultiFn" this]
        (:methodTable this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getPreferTable) [#_"MultiFn" this]
        (:preferTable this)
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (def- #_"int" Murmur3'seed 0)
    (def- #_"int" Murmur3'C1 0xcc9e2d51)
    (def- #_"int" Murmur3'C2 0x1b873593)

    (defn #_"int" Murmur3'hashInt [#_"int" input]
        (when-not (zero? input) => 0
            (let [#_"int" k1 (Murmur3'mixK1 input)
                  #_"int" h1 (Murmur3'mixH1 Murmur3'seed, k1)]
                (Murmur3'fmix h1, 4)
            )
        )
    )

    (defn #_"int" Murmur3'hashLong [#_"long" input]
        (when-not (zero? input) => 0
            (let [#_"int" low (int input)
                  #_"int" high (int (>>> input 32))
                  #_"int" k1 (Murmur3'mixK1 low)
                  #_"int" h1 (Murmur3'mixH1 Murmur3'seed, k1)
                  k1 (Murmur3'mixK1 high)
                  h1 (Murmur3'mixH1 h1, k1)]
                (Murmur3'fmix h1, 8)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" input]
        (let [#_"int" h1 Murmur3'seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [#_"int" i 1] (< i (.length input)) [(+ i 2)]
                (let [#_"int" k1 (| (.charAt input, (dec i)) (<< (.charAt input, i) 16))]
                    (§ ass k1 (Murmur3'mixK1 k1))
                    (§ ass h1 (Murmur3'mixH1 h1, k1))
                )
            )

            ;; deal with any remaining characters
            (when (= (& (.length input) 1) 1)
                (let [#_"int" k1 (.charAt input, (dec (.length input)))]
                    (§ ass k1 (Murmur3'mixK1 k1))
                    (§ ass h1 (bit-xor h1 k1))
                )
            )

            (Murmur3'fmix h1, (* 2 (.length input)))
        )
    )

    (defn #_"int" Murmur3'mixCollHash [#_"int" hash, #_"int" count]
        (let [#_"int" h1 Murmur3'seed]
            (let [#_"int" k1 (Murmur3'mixK1 hash)]
                (§ ass h1 (Murmur3'mixH1 h1, k1))
                (Murmur3'fmix h1, count)
            )
        )
    )

    (defn #_"int" Murmur3'hashOrdered [#_"Iterable" xs]
        (let [#_"int" n 0]
            (let [#_"int" hash 1]
                (doseq [#_"Object" x xs]
                    (§ ass hash (+ (* 31 hash) (Util'hasheq x)))
                    (§ ass n (inc n))
                )

                (Murmur3'mixCollHash hash, n)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnordered [#_"Iterable" xs]
        (let [#_"int" hash 0]
            (let [#_"int" n 0]
                (doseq [#_"Object" x xs]
                    (§ ass hash (+ hash (Util'hasheq x)))
                    (§ ass n (inc n))
                )

                (Murmur3'mixCollHash hash, n)
            )
        )
    )

    (defn- #_"int" Murmur3'mixK1 [#_"int" k1]
        (§ ass k1 (* k1 Murmur3'C1))
        (§ ass k1 (Integer/rotateLeft k1, 15))
        (§ ass k1 (* k1 Murmur3'C2))
        k1
    )

    (defn- #_"int" Murmur3'mixH1 [#_"int" h1, #_"int" k1]
        (§ ass h1 (bit-xor h1 k1))
        (§ ass h1 (Integer/rotateLeft h1, 13))
        (§ ass h1 (+ (* h1 5) 0xe6546b64))
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (defn- #_"int" Murmur3'fmix [#_"int" h1, #_"int" length]
        (§ ass h1 (bit-xor h1 length))
        (§ ass h1 (bit-xor h1 (>>> h1 16)))
        (§ ass h1 (* h1 0x85ebca6b))
        (§ ass h1 (bit-xor h1 (>>> h1 13)))
        (§ ass h1 (* h1 0xc2b2ae35))
        (§ ass h1 (bit-xor h1 (>>> h1 16)))
        h1
    )
)
)

(java-ns cloiure.lang.Named

(§ defprotocol Named
    #_abstract
    (#_"String" Named'''(§ method getNamespace) [#_"Named" this])
    #_abstract
    (#_"String" Named'''(§ method getName) [#_"Named" this])
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ConcurrentHashMap.))

    (defn- #_"Namespace" Namespace'init []
        (hash-map
            #_"Symbol" :name nil

            #_transient
            #_"AtomicReference<IPersistentMap>" :mappings (AtomicReference.)
            #_transient
            #_"AtomicReference<IPersistentMap>" :aliases (AtomicReference.)
        )
    )

    (defn #_"Namespace" Namespace'new [#_"Symbol" name]
        (let [this (merge (AReference'new (.meta name)) (Namespace'init))]
            (§ ass this (assoc this :name name))
            (.set (:mappings this), RT'DEFAULT_IMPORTS)
            (.set (:aliases this), (RT'map))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Namespace" this]
        (.toString (:name this))
    )

    (defn #_"ISeq" Namespace'all []
        (RT'seq (.values Namespace'namespaces))
    )

    #_method
    (§ defn #_"Symbol" (§ method getName) [#_"Namespace" this]
        (:name this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getMappings) [#_"Namespace" this]
        (.get (:mappings this))
    )

    #_method
    (§ defn- #_"void" (§ method warnOrFailOnReplace) [#_"Namespace" this, #_"Symbol" sym, #_"Object" o, #_"Var" var]
        (or
            (when (§ instance? Var o)
                (let [#_"Namespace" ns (:ns (cast' Var o))]
                    (when-not (or (= ns this) (= (:ns var) RT'CLOIURE_NS)) => :ok
                        (when-not (= ns RT'CLOIURE_NS)
                            (throw (IllegalStateException. (str sym " already refers to: " o " in namespace: " (:name this))))
                        )
                    )
                )
            )
            (.println (RT'errPrintWriter), (str "WARNING: " sym " already refers to: " o " in namespace: " (:name this) ", being replaced by: " var))
        )
        nil
    )

    #_method
    (§ defn #_"Var" (§ method intern) [#_"Namespace" this, #_"Symbol" sym]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [[#_"IPersistentMap" m #_"Object" o #_"Var" v]
                    (loop [v nil]
                        (let-when [m (.getMappings this) o (.valAt m, sym)] (nil? o) => [m o v]
                            (let [v (or v (Var'new this, sym))]
                                (.compareAndSet (:mappings this), m, (.assoc m, sym, v))
                                (recur v)
                            )
                        )
                    )]
                (when-not (and (§ instance? Var o) (= (:ns (cast' Var o)) this)) => (cast' Var o)
                    (let [v (or v (Var'new this, sym))]
                        (.warnOrFailOnReplace this, sym, o, v)
                        (loop-when-recur m (not (.compareAndSet (:mappings this), m, (.assoc m, sym, v))) (.getMappings this))
                        v
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Var" (§ method referenceVar) [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [[#_"IPersistentMap" m #_"Object" o]
                    (loop []
                        (let-when [m (.getMappings this) o (.valAt m, sym)] (nil? o) => [m o]
                            (.compareAndSet (:mappings this), m, (.assoc m, sym, var))
                            (recur)
                        )
                    )]
                (when-not (= o var)
                    (.warnOrFailOnReplace this, sym, o, var)
                    (loop-when-recur m (not (.compareAndSet (:mappings this), m, (.assoc m, sym, var))) (.getMappings this))
                )
                var
            )
        )
    )

    (defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" cls1, #_"Class" cls2]
        (and (not= cls1 cls2) (.equals (.getName cls1), (.getName cls2)))
    )

    #_method
    (§ defn #_"Class" (§ method referenceClass) [#_"Namespace" this, #_"Symbol" sym, #_"Class" cls]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [#_"Class" c
                    (loop []
                        (let [#_"IPersistentMap" m (.getMappings this) c (cast Class (.valAt m, sym))]
                            (when (or (nil? c) (Namespace'areDifferentInstancesOfSameClassName c, cls)) => c
                                (.compareAndSet (:mappings this), m, (.assoc m, sym, cls))
                                (recur)
                            )
                        )
                    )]
                (when (= c cls) => (throw (IllegalStateException. (str sym " already refers to: " c " in namespace: " (:name this))))
                    c
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method unmap) [#_"Namespace" this, #_"Symbol" sym]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
            (loop-when-recur [#_"IPersistentMap" m (.getMappings this)] (.containsKey m, sym) [(.getMappings this)]
                (.compareAndSet (:mappings this), m, (.without m, sym))
            )
        )
        nil
    )

    #_method
    (§ defn #_"Class" (§ method importClass) [#_"Namespace" this, #_"Symbol" sym, #_"Class" cls]
        (.referenceClass this, sym, cls)
    )

    #_method
    (§ defn #_"Class" (§ method importClass) [#_"Namespace" this, #_"Class" cls]
        (let [#_"String" s (.getName cls)]
            (.importClass this, (Symbol'intern (.substring s, (inc (.lastIndexOf s, \.)))), cls)
        )
    )

    #_method
    (§ defn #_"Var" (§ method refer) [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (.referenceVar this, sym, var)
    )

    (defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" name]
        (or (.get Namespace'namespaces, name)
            (let [#_"Namespace" ns (Namespace'new name)]
                (or (.putIfAbsent Namespace'namespaces, name, ns) ns)
            )
        )
    )

    (defn #_"Namespace" Namespace'remove [#_"Symbol" name]
        (when (.equals name, (:name RT'CLOIURE_NS))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (.remove Namespace'namespaces, name)
    )

    (defn #_"Namespace" Namespace'find [#_"Symbol" name]
        (.get Namespace'namespaces, name)
    )

    #_method
    (§ defn #_"Object" (§ method getMapping) [#_"Namespace" this, #_"Symbol" name]
        (.valAt (.get (:mappings this)), name)
    )

    #_method
    (§ defn #_"Var" (§ method findInternedVar) [#_"Namespace" this, #_"Symbol" symbol]
        (let [#_"Object" o (.valAt (.get (:mappings this)), symbol)]
            (when (and (some? o) (§ instance? Var o) (= (:ns (cast' Var o)) this))
                (cast' Var o)
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getAliases) [#_"Namespace" this]
        (.get (:aliases this))
    )

    #_method
    (§ defn #_"Namespace" (§ method lookupAlias) [#_"Namespace" this, #_"Symbol" alias]
        (cast' Namespace (.valAt (.getAliases this), alias))
    )

    #_method
    (§ defn #_"void" (§ method addAlias) [#_"Namespace" this, #_"Symbol" alias, #_"Namespace" ns]
        (when (and (some? alias) (some? ns)) => (throw (NullPointerException. "Expecting Symbol + Namespace"))
            (let [#_"IPersistentMap" m
                    (loop-when-recur [m (.getAliases this)] (not (.containsKey m, alias)) [(.getAliases this)] => m
                        (.compareAndSet (:aliases this), m, (.assoc m, alias, ns))
                    )]
                ;; you can rebind an alias, but only to the initially-aliased namespace
                (when-not (.equals (.valAt m, alias), ns)
                    (throw (IllegalStateException. (str "Alias " alias " already exists in namespace " (:name this) ", aliasing " (.valAt m, alias))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method removeAlias) [#_"Namespace" this, #_"Symbol" alias]
        (loop-when-recur [#_"IPersistentMap" m (.getAliases this)] (.containsKey m, alias) [(.getAliases this)]
            (.compareAndSet (:aliases this), m, (.without m, alias))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(§ defprotocol Ops
    #_abstract
    (#_"Ops" Ops'''(§ method combine) [#_"Ops" this, #_"Ops" y])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithLong) [#_"Ops" this, #_"LongOps" x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithDouble) [#_"Ops" this, #_"DoubleOps" x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithRatio) [#_"Ops" this, #_"RatioOps" x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithBigInt) [#_"Ops" this, #_"BigIntOps" x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithBigDecimal) [#_"Ops" this, #_"BigDecimalOps" x])
    #_abstract
    (#_"boolean" Ops'''(§ method isZero) [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"boolean" Ops'''(§ method isPos) [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"boolean" Ops'''(§ method isNeg) [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''(§ method add) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method addP) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method multiply) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method multiplyP) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method divide) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method quotient) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method remainder) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''(§ method equiv) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''(§ method lt) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''(§ method lte) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''(§ method gte) [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''(§ method negate) [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''(§ method negateP) [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''inc [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''(§ method incP) [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''dec [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''(§ method decP) [#_"Ops" this, #_"Number" x])
)

#_stateless
#_abstract
(class-ns OpsP (§ implements Ops)
    #_protected
    (defn #_"OpsP" OpsP'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Number" (§ method addP) [#_"OpsP" this, #_"Number" x, #_"Number" y]
        (.add this, x, y)
    )

    #_method
    (§ defn #_"Number" (§ method multiplyP) [#_"OpsP" this, #_"Number" x, #_"Number" y]
        (.multiply this, x, y)
    )

    #_method
    (§ defn #_"Number" (§ method negateP) [#_"OpsP" this, #_"Number" x]
        (.negate this, x)
    )

    #_method
    (§ defn #_"Number" (§ method incP) [#_"OpsP" this, #_"Number" x]
        (.inc this, x)
    )

    #_method
    (§ defn #_"Number" (§ method decP) [#_"OpsP" this, #_"Number" x]
        (.dec this, x)
    )
)

(class-ns LongOps (§ implements Ops)
    (defn #_"LongOps" LongOps'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"LongOps" this, #_"Ops" y]
        (.opsWith y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"LongOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"RatioOps" x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"BigIntOps" x]
        Numbers'BIGINT_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"LongOps" this, #_"Number" x]
        (zero? (.longValue x))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"LongOps" this, #_"Number" x]
        (pos? (.longValue x))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"LongOps" this, #_"Number" x]
        (neg? (.longValue x))
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (Numbers'add-2ll (.longValue x), (.longValue y)))
    )

    #_method
    (§ defn #_"Number" (§ method addP) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y) #_"long" lz (+ lx ly)]
            (if (and (neg? (bit-xor lz lx)) (neg? (bit-xor lz ly)))
                (.add Numbers'BIGINT_OPS, x, y)
                (Numbers'num-1l lz)
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (Numbers'multiply-2ll (.longValue x), (.longValue y)))
    )

    #_method
    (§ defn #_"Number" (§ method multiplyP) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y)]
            (if (and (= lx Long/MIN_VALUE) (neg? ly))
                (.multiply Numbers'BIGINT_OPS, x, y)
                (let [#_"long" lz (* lx ly)]
                    (if (and (not= ly 0) (not= (/ lz ly) lx))
                        (.multiply Numbers'BIGINT_OPS, x, y)
                        (Numbers'num-1l lz)
                    )
                )
            )
        )
    )

    (defn #_"long" LongOps'gcd [#_"long" u, #_"long" v] (if (zero? v) u (recur v (% u v))))

    #_method
    (§ defn #_"Number" (§ method divide) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y)]
            (let-when-not [#_"long" gcd (LongOps'gcd lx, ly)] (zero? gcd) => (Numbers'num-1l 0)
                (let-when-not [lx (/ lx gcd) ly (/ ly gcd)] (= ly 1) => (Numbers'num-1l lx)
                    (let [[lx ly]
                            (when (neg? ly) => [lx ly]
                                [(- lx) (- ly)]
                            )]
                        (Ratio'new (BigInteger/valueOf lx), (BigInteger/valueOf ly))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (/ (.longValue x) (.longValue y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (% (.longValue x) (.longValue y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (= (.longValue x) (.longValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (< (.longValue x) (.longValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (<= (.longValue x) (.longValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (>= (.longValue x) (.longValue y))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'minus-1l val))
        )
    )

    #_method
    (§ defn #_"Number" (§ method negateP) [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< Long/MIN_VALUE val)
                (Numbers'num-1l (- val))
                (BigInt'fromBigInteger (.negate (BigInteger/valueOf val)))
            )
        )
    )

    #_override
    (§ defn #_"Number" Ops'''inc [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'inc-1l val))
        )
    )

    #_method
    (§ defn #_"Number" (§ method incP) [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< val Long/MAX_VALUE)
                (Numbers'num-1l (inc val))
                (.inc Numbers'BIGINT_OPS, x)
            )
        )
    )

    #_override
    (§ defn #_"Number" Ops'''dec [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'dec-1l val))
        )
    )

    #_method
    (§ defn #_"Number" (§ method decP) [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< Long/MIN_VALUE val)
                (Numbers'num-1l (dec val))
                (.dec Numbers'BIGINT_OPS, x)
            )
        )
    )
)

(class-ns DoubleOps (§ extends OpsP)
    (defn #_"DoubleOps" DoubleOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"DoubleOps" this, #_"Ops" y]
        (.opsWith y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"LongOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"DoubleOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"RatioOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"BigIntOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"BigDecimalOps" x]
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"DoubleOps" this, #_"Number" x]
        (zero? (.doubleValue x))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"DoubleOps" this, #_"Number" x]
        (pos? (.doubleValue x))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"DoubleOps" this, #_"Number" x]
        (neg? (.doubleValue x))
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (+ (.doubleValue x) (.doubleValue y)))
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (* (.doubleValue x) (.doubleValue y)))
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (/ (.doubleValue x) (.doubleValue y)))
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Numbers'quotient-2dd (.doubleValue x), (.doubleValue y))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Numbers'remainder-2dd (.doubleValue x), (.doubleValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (= (.doubleValue x) (.doubleValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (< (.doubleValue x) (.doubleValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (<= (.doubleValue x) (.doubleValue y))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (>= (.doubleValue x) (.doubleValue y))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (- (.doubleValue x)))
    )

    #_override
    (§ defn #_"Number" Ops'''inc [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (inc (.doubleValue x)))
    )

    #_override
    (§ defn #_"Number" Ops'''dec [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (dec (.doubleValue x)))
    )
)

(class-ns RatioOps (§ extends OpsP)
    (defn #_"RatioOps" RatioOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"RatioOps" this, #_"Ops" y]
        (.opsWith y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"LongOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"RatioOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"BigIntOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"RatioOps" this, #_"Number" x]
        (zero? (.signum (:numerator (cast' Ratio x))))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"RatioOps" this, #_"Number" x]
        (pos? (.signum (:numerator (cast' Ratio x))))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"RatioOps" this, #_"Number" x]
        (neg? (.signum (:numerator (cast' Ratio x))))
    )

    (defn #_"Number" RatioOps'normalizeRet [#_"Number" ret, #_"Number" x, #_"Number" y]
        ret
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (let [#_"Number" ret (.divide this, (.add (.multiply (:numerator ry), (:denominator rx)), (.multiply (:numerator rx), (:denominator ry))), (.multiply (:denominator ry), (:denominator rx)))]
                    (RatioOps'normalizeRet ret, x, y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (let [#_"Number" ret (.divide this, (.multiply (:numerator ry), (:numerator rx)), (.multiply (:denominator ry), (:denominator rx)))]
                    (RatioOps'normalizeRet ret, x, y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (let [#_"Number" ret (.divide this, (.multiply (:denominator ry), (:numerator rx)), (.multiply (:numerator ry), (:denominator rx)))]
                    (RatioOps'normalizeRet ret, x, y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (let [#_"BigInteger" q (.divide (.multiply (:numerator rx), (:denominator ry)), (.multiply (:denominator rx), (:numerator ry)))]
                    (RatioOps'normalizeRet (BigInt'fromBigInteger q), x, y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (let [#_"BigInteger" q (.divide (.multiply (:numerator rx), (:denominator ry)), (.multiply (:denominator rx), (:numerator ry)))]
                    (let [#_"Number" ret (Numbers'minus-2oo x, (Numbers'multiply-2oo q, y))]
                        (RatioOps'normalizeRet ret, x, y)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (and (.equals (:numerator rx), (:numerator ry)) (.equals (:denominator rx), (:denominator ry)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (Numbers'lt-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (Numbers'lte-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x)]
            (let [#_"Ratio" ry (Numbers'toRatio y)]
                (Numbers'gte-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"RatioOps" this, #_"Number" x]
        (let [#_"Ratio" r (cast' Ratio x)]
            (Ratio'new (.negate (:numerator r)), (:denominator r))
        )
    )

    #_override
    (§ defn #_"Number" Ops'''inc [#_"RatioOps" this, #_"Number" x]
        (Numbers'add-2ol x, 1)
    )

    #_override
    (§ defn #_"Number" Ops'''dec [#_"RatioOps" this, #_"Number" x]
        (Numbers'add-2ol x, -1)
    )
)

(class-ns BigIntOps (§ extends OpsP)
    (defn #_"BigIntOps" BigIntOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"BigIntOps" this, #_"Ops" y]
        (.opsWith y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"LongOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"RatioOps" x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"BigIntOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (zero? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (pos? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (neg? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.add (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.multiply (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (Numbers'divide-2ii (.toBigInteger this, x), (.toBigInteger this, y))
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.quotient (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.remainder (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.equals (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.lt (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (<= (.compareTo (.toBigInteger this, x), (.toBigInteger this, y)) 0)
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (>= (.compareTo (.toBigInteger this, x), (.toBigInteger this, y)) 0)
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.negate (.toBigInteger this, x)))
    )

    #_override
    (§ defn #_"Number" Ops'''inc [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInteger" bx (.toBigInteger this, x)]
            (BigInt'fromBigInteger (.add bx, BigInteger/ONE))
        )
    )

    #_override
    (§ defn #_"Number" Ops'''dec [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInteger" bx (.toBigInteger this, x)]
            (BigInt'fromBigInteger (.subtract bx, BigInteger/ONE))
        )
    )
)

(class-ns BigDecimalOps (§ extends OpsP)
    (§ def #_"Var" BigDecimalOps'MATH_CONTEXT RT'MATH_CONTEXT)

    (defn #_"BigDecimalOps" BigDecimalOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"BigDecimalOps" this, #_"Ops" y]
        (.opsWith y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"LongOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"RatioOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"BigIntOps" x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"BigDecimalOps" x]
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (zero? (.signum bx))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (pos? (.signum bx))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (neg? (.signum bx))
        )
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.add (.toBigDecimal this, x), (.toBigDecimal this, y)) (.add (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.multiply (.toBigDecimal this, x), (.toBigDecimal this, y)) (.multiply (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.divide (.toBigDecimal this, x), (.toBigDecimal this, y)) (.divide (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.divideToIntegralValue (.toBigDecimal this, x), (.toBigDecimal this, y)) (.divideToIntegralValue (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.remainder (.toBigDecimal this, x), (.toBigDecimal this, y)) (.remainder (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (zero? (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (neg? (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (<= (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)) 0)
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (>= (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)) 0)
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.negate (cast BigDecimal x)) (.negate (cast BigDecimal x), mc))
        )
    )

    #_override
    (§ defn #_"Number" Ops'''inc [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (let [#_"BigDecimal" bx (cast BigDecimal x)]
                (if (nil? mc) (.add bx, BigDecimal/ONE) (.add bx, BigDecimal/ONE, mc))
            )
        )
    )

    #_override
    (§ defn #_"Number" Ops'''dec [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (.deref BigDecimalOps'MATH_CONTEXT))]
            (let [#_"BigDecimal" bx (cast BigDecimal x)]
                (if (nil? mc) (.subtract bx, BigDecimal/ONE) (.subtract bx, BigDecimal/ONE, mc))
            )
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

#_stateless
(class-ns Numbers
    (defn #_"boolean" Numbers'isZero-1o [#_"Object" x]
        (.isZero (Numbers'ops x), (cast Number x))
    )

    (defn #_"boolean" Numbers'isPos-1o [#_"Object" x]
        (.isPos (Numbers'ops x), (cast Number x))
    )

    (defn #_"boolean" Numbers'isNeg-1o [#_"Object" x]
        (.isNeg (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'minus-1o [#_"Object" x]
        (.negate (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'minusP-1o [#_"Object" x]
        (.negateP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'inc-1o [#_"Object" x]
        (.inc (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'incP-1o [#_"Object" x]
        (.incP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'dec-1o [#_"Object" x]
        (.dec (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'decP-1o [#_"Object" x]
        (.decP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'add-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.add (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'addP-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.addP (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'minus-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (-> (.combine (Numbers'ops x), yops) (.add (cast Number x), (.negate yops, (cast Number y))))
        )
    )

    (defn #_"Number" Numbers'minusP-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (let [#_"Number" negativeY (.negateP yops, (cast Number y))]
                (let [#_"Ops" negativeYOps (Numbers'ops negativeY)]
                    (-> (.combine (Numbers'ops x), negativeYOps) (.addP (cast Number x), negativeY))
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiply-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.multiply (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'multiplyP-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.multiplyP (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'divide-2oo [#_"Object" x, #_"Object" y]
        (cond
            (Numbers'isNaN x) (cast Number x)
            (Numbers'isNaN y) (cast Number y)
            :else
                (let [#_"Ops" yops (Numbers'ops y)]
                    (when (.isZero yops, (cast Number y))
                        (throw (ArithmeticException. "Divide by zero"))
                    )
                    (-> (.combine (Numbers'ops x), yops) (.divide (cast Number x), (cast Number y)))
                )
        )
    )

    (defn #_"Number" Numbers'quotient-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (when (.isZero yops, (cast Number y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (-> (.combine (Numbers'ops x), yops) (.quotient (cast Number x), (cast Number y)))
        )
    )

    (defn #_"Number" Numbers'remainder-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (when (.isZero yops, (cast Number y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (-> (.combine (Numbers'ops x), yops) (.remainder (cast Number x), (cast Number y)))
        )
    )

    (defn #_"double" Numbers'quotient-2dd [#_"double" n, #_"double" d]
        (when (zero? d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (/ n d)]
            (cond (<= Long/MIN_VALUE q Long/MAX_VALUE)
                (do
                    (double (long q))
                )
                :else ;; bigint quotient
                (do
                    (.doubleValue (.toBigInteger (BigDecimal. q)))
                )
            )
        )
    )

    (defn #_"double" Numbers'remainder-2dd [#_"double" n, #_"double" d]
        (when (zero? d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (/ n d)]
            (cond (<= Long/MIN_VALUE q Long/MAX_VALUE)
                (do
                    (- n (* (long q) d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" bq (.toBigInteger (BigDecimal. q))]
                        (- n (* (.doubleValue bq) d))
                    )
                )
            )
        )
    )

    (defn #_"boolean" Numbers'equiv-2oo [#_"Object" x, #_"Object" y]
        (Numbers'equiv-2nn (cast Number x), (cast Number y))
    )

    (defn #_"boolean" Numbers'equiv-2nn [#_"Number" x, #_"Number" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.equiv x, y))
    )

    (defn #_"boolean" Numbers'equal [#_"Number" x, #_"Number" y]
        (and (= (Numbers'category x) (Numbers'category y)) (.equiv (.combine (Numbers'ops x), (Numbers'ops y)), x, y))
    )

    (defn #_"boolean" Numbers'lt-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.lt (cast Number x), (cast Number y)))
    )

    (defn #_"boolean" Numbers'lte-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.lte (cast Number x), (cast Number y)))
    )

    (defn #_"boolean" Numbers'gt-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.lt (cast Number y), (cast Number x)))
    )

    (defn #_"boolean" Numbers'gte-2oo [#_"Object" x, #_"Object" y]
        (-> (.combine (Numbers'ops x), (Numbers'ops y)) (.gte (cast Number x), (cast Number y)))
    )

    (defn #_"int" Numbers'compare [#_"Number" x, #_"Number" y]
        (let [#_"Ops" ops (.combine (Numbers'ops x), (Numbers'ops y))]
            (cond (.lt ops, x, y) -1 (.lt ops, y, x) 1 :else 0)
        )
    )

    (defn #_"BigInt" Numbers'toBigInt [#_"Object" x]
        (cond
            (§ instance? BigInt x)   (cast' BigInt x)
            (instance? BigInteger x) (BigInt'fromBigInteger (cast BigInteger x))
            :else                    (BigInt'fromLong (.longValue (cast Number x)))
        )
    )

    (defn #_"BigInteger" Numbers'toBigInteger [#_"Object" x]
        (cond
            (instance? BigInteger x) (cast BigInteger x)
            (§ instance? BigInt x)   (.toBigInteger (cast' BigInt x))
            :else                    (BigInteger/valueOf (.longValue (cast Number x)))
        )
    )

    (defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" x]
        (cond
            (instance? BigDecimal x)
                (cast BigDecimal x)
            (§ instance? BigInt x)
                (let [#_"BigInt" bi (cast' BigInt x)]
                    (if (nil? (:bipart bi))
                        (BigDecimal/valueOf (:lpart bi))
                        (§ unsure BigDecimal. (:bipart bi))
                    )
                )
            (instance? BigInteger x)
                (§ unsure BigDecimal. (cast BigInteger x))
            (instance? Double x)
                (§ unsure BigDecimal. (.doubleValue (cast Number x)))
            (instance? Float x)
                (§ unsure BigDecimal. (.doubleValue (cast Number x)))
            (§ instance? Ratio x)
                (let [#_"Ratio" r (cast' Ratio x)]
                    (cast BigDecimal (Numbers'divide-2oo (§ unsure BigDecimal. (:numerator r)), (:denominator r)))
                )
            :else
                (BigDecimal/valueOf (.longValue (cast Number x)))
        )
    )

    (defn #_"Ratio" Numbers'toRatio [#_"Object" x]
        (cond
            (§ instance? Ratio x)
                (cast' Ratio x)
            (instance? BigDecimal x)
                (let [#_"BigDecimal" bx (cast BigDecimal x) #_"BigInteger" bv (.unscaledValue bx) #_"int" scale (.scale bx)]
                    (if (neg? scale)
                        (Ratio'new (.multiply bv, (.pow BigInteger/TEN, (- scale))), BigInteger/ONE)
                        (Ratio'new bv, (.pow BigInteger/TEN, scale))
                    )
                )
            :else
                (Ratio'new (Numbers'toBigInteger x), BigInteger/ONE)
        )
    )

    (defn #_"Number" Numbers'rationalize [#_"Number" x]
        (cond
            (or (instance? Float x) (instance? Double x))
                (Numbers'rationalize (BigDecimal/valueOf (.doubleValue x)))
            (instance? BigDecimal x)
                (let [#_"BigDecimal" bx (cast BigDecimal x) #_"BigInteger" bv (.unscaledValue bx) #_"int" scale (.scale bx)]
                    (if (neg? scale)
                        (BigInt'fromBigInteger (.multiply bv, (.pow BigInteger/TEN, (- scale))))
                        (Numbers'divide-2ii bv, (.pow BigInteger/TEN, scale))
                    )
                )
            :else
                x
        )
    )

    (defn #_"Number" Numbers'reduceBigInt [#_"BigInt" val]
        (or (:bipart val) (Numbers'num-1l (:lpart val)))
    )

    (defn #_"Number" Numbers'divide-2ii [#_"BigInteger" n, #_"BigInteger" d]
        (when-not (.equals d, BigInteger/ZERO) => (throw (ArithmeticException. "Divide by zero"))
            (let [#_"BigInteger" gcd (.gcd n, d)]
                (when-not (.equals gcd, BigInteger/ZERO) => BigInt'ZERO
                    (let [n (.divide n, gcd) d (.divide d, gcd)]
                        (cond
                            (.equals d, BigInteger/ONE)
                                (BigInt'fromBigInteger n)
                            (.equals d, (.negate BigInteger/ONE))
                                (BigInt'fromBigInteger (.negate n))
                            :else
                                (Ratio'new (if (neg? (.signum d)) (.negate n) n), (if (neg? (.signum d)) (.negate d) d))
                        )
                    )
                )
            )
        )
    )

    (defn #_"int" Numbers'shiftLeftInt [#_"int" x, #_"int" n]
        (<< x n)
    )

    (defn #_"long" Numbers'shiftLeft-2oo [#_"Object" x, #_"Object" y]
        (Numbers'shiftLeft-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftLeft-2ol [#_"Object" x, #_"long" y]
        (Numbers'shiftLeft-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'shiftLeft-2lo [#_"long" x, #_"Object" y]
        (Numbers'shiftLeft-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftLeft-2ll [#_"long" x, #_"long" n]
        (<< x n)
    )

    (defn #_"int" Numbers'shiftRightInt [#_"int" x, #_"int" n]
        (>> x n)
    )

    (defn #_"long" Numbers'shiftRight-2oo [#_"Object" x, #_"Object" y]
        (Numbers'shiftRight-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftRight-2ol [#_"Object" x, #_"long" y]
        (Numbers'shiftRight-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'shiftRight-2lo [#_"long" x, #_"Object" y]
        (Numbers'shiftRight-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftRight-2ll [#_"long" x, #_"long" n]
        (>> x n)
    )

    (defn #_"int" Numbers'unsignedShiftRightInt [#_"int" x, #_"int" n]
        (>>> x n)
    )

    (defn #_"long" Numbers'unsignedShiftRight-2oo [#_"Object" x, #_"Object" y]
        (Numbers'unsignedShiftRight-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ol [#_"Object" x, #_"long" y]
        (Numbers'unsignedShiftRight-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'unsignedShiftRight-2lo [#_"long" x, #_"Object" y]
        (Numbers'unsignedShiftRight-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ll [#_"long" x, #_"long" n]
        (>>> x n)
    )

    (§ def #_"LongOps"       Numbers'LONG_OPS       (LongOps'new)      )
    (§ def #_"DoubleOps"     Numbers'DOUBLE_OPS     (DoubleOps'new)    )
    (§ def #_"RatioOps"      Numbers'RATIO_OPS      (RatioOps'new)     )
    (§ def #_"BigIntOps"     Numbers'BIGINT_OPS     (BigIntOps'new)    )
    (§ def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps'new))

    (defn #_"Ops" Numbers'ops [#_"Object" x]
        (condp = (.getClass x)
            Integer          Numbers'LONG_OPS
            Long             Numbers'LONG_OPS
            (§ class BigInt) Numbers'BIGINT_OPS
            BigInteger       Numbers'BIGINT_OPS
            (§ class Ratio)  Numbers'RATIO_OPS
            Float            Numbers'DOUBLE_OPS
            Double           Numbers'DOUBLE_OPS
            BigDecimal       Numbers'BIGDECIMAL_OPS
                             Numbers'LONG_OPS
        )
    )

    (defn #_"int" Numbers'hasheqFrom [#_"Number" x, #_"Class" xc]
        (cond
            (or (any = xc Integer Short Byte) (and (= xc BigInteger) (Numbers'lte-2ol x, Long/MAX_VALUE) (Numbers'gte-2ol x, Long/MIN_VALUE)))
                (Murmur3'hashLong (.longValue x))
            (= xc BigDecimal)
                ;; stripTrailingZeros() to make all numerically equal BigDecimal values come out the same before calling hashCode.
                ;; Special check for 0 because stripTrailingZeros() does not do anything to values equal to 0 with different scales.
                (.hashCode (if (Numbers'isZero-1o x) BigDecimal/ZERO (.stripTrailingZeros (cast BigDecimal x))))
            (and (= xc Float) (.equals x, (float -0.0)))
                0 ;; match 0.0f
            :else
                (.hashCode x)
        )
    )

    (defn #_"int" Numbers'hasheq [#_"Number" x]
        (let [#_"Class" xc (.getClass x)]
            (condp = xc
                Long
                    (Murmur3'hashLong (.longValue x))
                Double
                    (if (.equals x, -0.0)
                        0 ;; match 0.0
                        (.hashCode x)
                    )
                (Numbers'hasheqFrom x, xc)
            )
        )
    )

    (defn #_"Category" Numbers'category [#_"Object" x]
        (condp = (.getClass x)
            Integer          :Category'INTEGER
            Long             :Category'INTEGER
            (§ class BigInt) :Category'INTEGER
            (§ class Ratio)  :Category'RATIO
            Float            :Category'FLOATING
            Double           :Category'FLOATING
            BigDecimal       :Category'DECIMAL
                             :Category'INTEGER
        )
    )

    (defn #_"long" Numbers'bitOpsCast [#_"Object" x]
        (let [#_"Class" xc (.getClass x)]               ;; no bignums, no decimals
            (when (any = xc Long Integer Short Byte) => (throw (IllegalArgumentException. (str "bit operation not supported for: " xc)))
                (RT'longCast-1o x)
            )
        )
    )

    (defn #_"float[]" Numbers'float_array-2 [#_"int" size, #_"Object" init]
        (let [#_"float[]" ret (.float-array size)]
            (if (instance? Number init)
                (do
                    (let [#_"float" f (.floatValue (cast Number init))]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (.floatValue (cast Number (.first s))))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"float[]" Numbers'float_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.float-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"float[]" ret (.float-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (.floatValue (cast Number (.first s))))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"double[]" Numbers'double_array-2 [#_"int" size, #_"Object" init]
        (let [#_"double[]" ret (.double-array size)]
            (if (instance? Number init)
                (do
                    (let [#_"double" f (.doubleValue (cast Number init))]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (.doubleValue (cast Number (.first s))))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"double[]" Numbers'double_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.double-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"double[]" ret (.double-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (.doubleValue (cast Number (.first s))))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"int[]" Numbers'int_array-2 [#_"int" size, #_"Object" init]
        (let [#_"int[]" ret (.int-array size)]
            (if (instance? Number init)
                (do
                    (let [#_"int" f (.intValue (cast Number init))]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (.intValue (cast Number (.first s))))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"int[]" Numbers'int_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.int-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"int[]" ret (.int-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (.intValue (cast Number (.first s))))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"long[]" Numbers'long_array-2 [#_"int" size, #_"Object" init]
        (let [#_"long[]" ret (.long-array size)]
            (if (instance? Number init)
                (do
                    (let [#_"long" f (.longValue (cast Number init))]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (.longValue (cast Number (.first s))))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"long[]" Numbers'long_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.long-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"long[]" ret (.long-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (.longValue (cast Number (.first s))))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"short[]" Numbers'short_array-2 [#_"int" size, #_"Object" init]
        (let [#_"short[]" ret (.short-array size)]
            (if (instance? Short init)
                (do
                    (let [#_"short" s (cast Short init)]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (.shortValue (cast Number (.first s))))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"short[]" Numbers'short_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.short-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"short[]" ret (.short-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (.shortValue (cast Number (.first s))))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"char[]" Numbers'char_array-2 [#_"int" size, #_"Object" init]
        (let [#_"char[]" ret (.char-array size)]
            (if (instance? Character init)
                (do
                    (let [#_"char" c (cast Character init)]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (cast Character (.first s)))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"char[]" Numbers'char_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.char-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"char[]" ret (.char-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (cast Character (.first s)))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"byte[]" Numbers'byte_array-2 [#_"int" size, #_"Object" init]
        (let [#_"byte[]" ret (.byte-array size)]
            (if (instance? Byte init)
                (do
                    (let [#_"byte" b (cast Byte init)]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (.byteValue (cast Number (.first s))))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"byte[]" Numbers'byte_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.byte-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"byte[]" ret (.byte-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (.byteValue (cast Number (.first s))))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-2 [#_"int" size, #_"Object" init]
        (let [#_"boolean[]" ret (.boolean-array size)]
            (if (instance? Boolean init)
                (do
                    (let [#_"boolean" b (cast Boolean init)]
                        (loop-when-recur [#_"int" i 0] (< i (alength ret)) [(inc i)]
                            (aset ret i b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (RT'seq init)]
                        (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                            (aset ret i (cast Boolean (.first s)))
                        )
                    )
                )
            )
            ret
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (do
                (.boolean-array (.intValue (cast Number sizeOrSeq)))
            )
            (do
                (let [#_"ISeq" s (RT'seq sizeOrSeq)]
                    (let [#_"int" size (RT'count s)]
                        (let [#_"boolean[]" ret (.boolean-array size)]
                            (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                                (aset ret i (cast Boolean (.first s)))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'booleans [#_"Object" array]
        (.booleans array)
    )

    (defn #_"byte[]" Numbers'bytes [#_"Object" array]
        (.bytes array)
    )

    (defn #_"char[]" Numbers'chars [#_"Object" array]
        (.chars array)
    )

    (defn #_"short[]" Numbers'shorts [#_"Object" array]
        (.shorts array)
    )

    (defn #_"float[]" Numbers'floats [#_"Object" array]
        (.floats array)
    )

    (defn #_"double[]" Numbers'doubles [#_"Object" array]
        (.doubles array)
    )

    (defn #_"int[]" Numbers'ints [#_"Object" array]
        (.ints array)
    )

    (defn #_"long[]" Numbers'longs [#_"Object" array]
        (.longs array)
    )

    (defn #_"Number" Numbers'num-1o [#_"Object" x]
        (cast Number x)
    )

    (defn #_"Number" Numbers'num-1f [#_"float" x]
        (Float/valueOf x)
    )

    (defn #_"Number" Numbers'num-1d [#_"double" x]
        (Double/valueOf x)
    )

    (defn #_"double" Numbers'add-2dd [#_"double" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2dd [#_"double" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'minus-2dd [#_"double" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2dd [#_"double" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minus-1d [#_"double" x]
        (- x)
    )

    (defn #_"double" Numbers'minusP-1d [#_"double" x]
        (- x)
    )

    (defn #_"double" Numbers'inc-1d [#_"double" x]
        (inc x)
    )

    (defn #_"double" Numbers'incP-1d [#_"double" x]
        (inc x)
    )

    (defn #_"double" Numbers'dec-1d [#_"double" x]
        (dec x)
    )

    (defn #_"double" Numbers'decP-1d [#_"double" x]
        (dec x)
    )

    (defn #_"double" Numbers'multiply-2dd [#_"double" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2dd [#_"double" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'divide-2dd [#_"double" x, #_"double" y]
        (/ x y)
    )

    (defn #_"boolean" Numbers'equiv-2dd [#_"double" x, #_"double" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'lt-2dd [#_"double" x, #_"double" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2dd [#_"double" x, #_"double" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2dd [#_"double" x, #_"double" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2dd [#_"double" x, #_"double" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'isPos-1d [#_"double" x]
        (> x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1d [#_"double" x]
        (< x 0)
    )

    (defn #_"boolean" Numbers'isZero-1d [#_"double" x]
        (zero? x)
    )

    (defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (defn #_"int" Numbers'unchecked_int_add [#_"int" x, #_"int" y]
        (+ x y)
    )

    (defn #_"int" Numbers'unchecked_int_subtract [#_"int" x, #_"int" y]
        (- x y)
    )

    (defn #_"int" Numbers'unchecked_int_negate [#_"int" x]
        (- x)
    )

    (defn #_"int" Numbers'unchecked_int_inc [#_"int" x]
        (inc x)
    )

    (defn #_"int" Numbers'unchecked_int_dec [#_"int" x]
        (dec x)
    )

    (defn #_"int" Numbers'unchecked_int_multiply [#_"int" x, #_"int" y]
        (* x y)
    )

    (defn #_"long" Numbers'not-1o [#_"Object" x]
        (Numbers'not-1l (Numbers'bitOpsCast x))
    )

    (defn #_"long" Numbers'not-1l [#_"long" x]
        (bit-not x)
    )

    (defn #_"long" Numbers'and-2oo [#_"Object" x, #_"Object" y]
        (Numbers'and-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'and-2ol [#_"Object" x, #_"long" y]
        (Numbers'and-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'and-2lo [#_"long" x, #_"Object" y]
        (Numbers'and-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'and-2ll [#_"long" x, #_"long" y]
        (& x y)
    )

    (defn #_"long" Numbers'or-2oo [#_"Object" x, #_"Object" y]
        (Numbers'or-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'or-2ol [#_"Object" x, #_"long" y]
        (Numbers'or-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'or-2lo [#_"long" x, #_"Object" y]
        (Numbers'or-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'or-2ll [#_"long" x, #_"long" y]
        (| x y)
    )

    (defn #_"long" Numbers'xor-2oo [#_"Object" x, #_"Object" y]
        (Numbers'xor-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'xor-2ol [#_"Object" x, #_"long" y]
        (Numbers'xor-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'xor-2lo [#_"long" x, #_"Object" y]
        (Numbers'xor-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'xor-2ll [#_"long" x, #_"long" y]
        (bit-xor x y)
    )

    (defn #_"long" Numbers'andNot-2oo [#_"Object" x, #_"Object" y]
        (Numbers'andNot-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'andNot-2ol [#_"Object" x, #_"long" y]
        (Numbers'andNot-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'andNot-2lo [#_"long" x, #_"Object" y]
        (Numbers'andNot-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'andNot-2ll [#_"long" x, #_"long" y]
        (& x (bit-not y))
    )

    (defn #_"long" Numbers'clearBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'clearBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'clearBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'clearBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'clearBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'clearBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'clearBit-2ll [#_"long" x, #_"long" n]
        (& x (bit-not (<< 1 n)))
    )

    (defn #_"long" Numbers'setBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'setBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'setBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'setBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'setBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'setBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'setBit-2ll [#_"long" x, #_"long" n]
        (| x (<< 1 n))
    )

    (defn #_"long" Numbers'flipBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'flipBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'flipBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'flipBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'flipBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'flipBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'flipBit-2ll [#_"long" x, #_"long" n]
        (bit-xor x (<< 1 n))
    )

    (defn #_"boolean" Numbers'testBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'testBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"boolean" Numbers'testBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'testBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"boolean" Numbers'testBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'testBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"boolean" Numbers'testBit-2ll [#_"long" x, #_"long" n]
        (not= (& x (<< 1 n)) 0)
    )

    (defn #_"int" Numbers'unchecked_int_divide [#_"int" x, #_"int" y]
        (/ x y)
    )

    (defn #_"int" Numbers'unchecked_int_remainder [#_"int" x, #_"int" y]
        (% x y)
    )

    (defn #_"Number" Numbers'num-1l [#_"long" x]
        (Long/valueOf x)
    )

    (defn #_"long" Numbers'unchecked_add-2ll [#_"long" x, #_"long" y]
        (+ x y)
    )

    (defn #_"long" Numbers'unchecked_minus-2ll [#_"long" x, #_"long" y]
        (- x y)
    )

    (defn #_"long" Numbers'unchecked_multiply-2ll [#_"long" x, #_"long" y]
        (* x y)
    )

    (defn #_"long" Numbers'unchecked_minus-1l [#_"long" x]
        (- x)
    )

    (defn #_"long" Numbers'unchecked_inc-1l [#_"long" x]
        (inc x)
    )

    (defn #_"long" Numbers'unchecked_dec-1l [#_"long" x]
        (dec x)
    )

    (defn #_"Number" Numbers'unchecked_add-2oo [#_"Object" x, #_"Object" y]
        (Numbers'add-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2oo [#_"Object" x, #_"Object" y]
        (Numbers'minus-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2oo [#_"Object" x, #_"Object" y]
        (Numbers'multiply-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-1o [#_"Object" x]
        (Numbers'minus-1o x)
    )

    (defn #_"Number" Numbers'unchecked_inc-1o [#_"Object" x]
        (Numbers'inc-1o x)
    )

    (defn #_"Number" Numbers'unchecked_dec-1o [#_"Object" x]
        (Numbers'dec-1o x)
    )

    (defn #_"double" Numbers'unchecked_add-2dd [#_"double" x, #_"double" y]
        (Numbers'add-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dd [#_"double" x, #_"double" y]
        (Numbers'minus-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dd [#_"double" x, #_"double" y]
        (Numbers'multiply-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-1d [#_"double" x]
        (Numbers'minus-1d x)
    )

    (defn #_"double" Numbers'unchecked_inc-1d [#_"double" x]
        (Numbers'inc-1d x)
    )

    (defn #_"double" Numbers'unchecked_dec-1d [#_"double" x]
        (Numbers'dec-1d x)
    )

    (defn #_"double" Numbers'unchecked_add-2do [#_"double" x, #_"Object" y]
        (Numbers'add-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2do [#_"double" x, #_"Object" y]
        (Numbers'multiply-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2od [#_"Object" x, #_"double" y]
        (Numbers'add-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2od [#_"Object" x, #_"double" y]
        (Numbers'multiply-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2dl [#_"double" x, #_"long" y]
        (Numbers'add-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dl [#_"double" x, #_"long" y]
        (Numbers'minus-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dl [#_"double" x, #_"long" y]
        (Numbers'multiply-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2ld [#_"long" x, #_"double" y]
        (Numbers'add-2ld x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2ld [#_"long" x, #_"double" y]
        (Numbers'minus-2ld x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2ld [#_"long" x, #_"double" y]
        (Numbers'multiply-2ld x, y)
    )

    (defn #_"Number" Numbers'unchecked_add-2lo [#_"long" x, #_"Object" y]
        (Numbers'add-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2lo [#_"long" x, #_"Object" y]
        (Numbers'minus-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiply-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_add-2ol [#_"Object" x, #_"long" y]
        (Numbers'add-2ol x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2ol [#_"Object" x, #_"long" y]
        (Numbers'minus-2ol x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiply-2ol x, y)
    )

    (defn #_"Number" Numbers'quotient-2do [#_"double" x, #_"Object" y]
        (Numbers'quotient-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'quotient-2od [#_"Object" x, #_"double" y]
        (Numbers'quotient-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'quotient-2lo [#_"long" x, #_"Object" y]
        (Numbers'quotient-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'quotient-2ol [#_"Object" x, #_"long" y]
        (Numbers'quotient-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'quotient-2dl [#_"double" x, #_"long" y]
        (Numbers'quotient-2dd x, (double y))
    )

    (defn #_"double" Numbers'quotient-2ld [#_"long" x, #_"double" y]
        (Numbers'quotient-2dd (double x), y)
    )

    (defn #_"Number" Numbers'remainder-2do [#_"double" x, #_"Object" y]
        (Numbers'remainder-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'remainder-2od [#_"Object" x, #_"double" y]
        (Numbers'remainder-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'remainder-2lo [#_"long" x, #_"Object" y]
        (Numbers'remainder-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'remainder-2ol [#_"Object" x, #_"long" y]
        (Numbers'remainder-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'remainder-2dl [#_"double" x, #_"long" y]
        (Numbers'remainder-2dd x, (double y))
    )

    (defn #_"double" Numbers'remainder-2ld [#_"long" x, #_"double" y]
        (Numbers'remainder-2dd (double x), y)
    )

    (defn #_"long" Numbers'add-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (+ x y)]
            (when-not (and (neg? (bit-xor ret x)) (neg? (bit-xor ret y))) => (Numbers'throwIntOverflow)
                ret
            )
        )
    )

    (defn #_"Number" Numbers'addP-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (+ x y)]
            (if (and (neg? (bit-xor ret x)) (neg? (bit-xor ret y)))
                (Numbers'addP-2oo (cast Number x), (cast Number y))
                (Numbers'num-1l ret)
            )
        )
    )

    (defn #_"long" Numbers'minus-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (- x y)]
            (when-not (and (neg? (bit-xor ret x)) (neg? (bit-xor ret (bit-not y)))) => (Numbers'throwIntOverflow)
                ret
            )
        )
    )

    (defn #_"Number" Numbers'minusP-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (- x y)]
            (if (and (neg? (bit-xor ret x)) (neg? (bit-xor ret (bit-not y))))
                (Numbers'minusP-2oo (cast Number x), (cast Number y))
                (Numbers'num-1l ret)
            )
        )
    )

    (defn #_"long" Numbers'minus-1l [#_"long" x]
        (when-not (= x Long/MIN_VALUE) => (Numbers'throwIntOverflow)
            (- x)
        )
    )

    (defn #_"Number" Numbers'minusP-1l [#_"long" x]
        (if (= x Long/MIN_VALUE)
            (BigInt'fromBigInteger (.negate (BigInteger/valueOf x)))
            (Numbers'num-1l (- x))
        )
    )

    (defn #_"long" Numbers'inc-1l [#_"long" x] (if (= x Long/MAX_VALUE) (Numbers'throwIntOverflow) (inc x)))
    (defn #_"long" Numbers'dec-1l [#_"long" x] (if (= x Long/MIN_VALUE) (Numbers'throwIntOverflow) (dec x)))

    (defn #_"Number" Numbers'incP-1l [#_"long" x] (if (= x Long/MAX_VALUE) (.inc Numbers'BIGINT_OPS, x) (Numbers'num-1l (inc x))))
    (defn #_"Number" Numbers'decP-1l [#_"long" x] (if (= x Long/MIN_VALUE) (.dec Numbers'BIGINT_OPS, x) (Numbers'num-1l (dec x))))

    (defn #_"long" Numbers'multiply-2ll [#_"long" x, #_"long" y]
        (when-not (and (= x Long/MIN_VALUE) (neg? y)) => (Numbers'throwIntOverflow)
            (let [#_"long" ret (* x y)]
                (when (or (zero? y) (= (/ ret y) x)) => (Numbers'throwIntOverflow)
                    ret
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiplyP-2ll [#_"long" x, #_"long" y]
        (when-not (and (= x Long/MIN_VALUE) (neg? y)) => (Numbers'multiplyP-2oo (cast Number x), (cast Number y))
            (let [#_"long" ret (* x y)]
                (when (or (zero? y) (= (/ ret y) x)) => (Numbers'multiplyP-2oo (cast Number x), (cast Number y))
                    (Numbers'num-1l ret)
                )
            )
        )
    )

    (defn #_"long" Numbers'quotient-2ll [#_"long" x, #_"long" y]
        (/ x y)
    )

    (defn #_"long" Numbers'remainder-2ll [#_"long" x, #_"long" y]
        (% x y)
    )

    (defn #_"boolean" Numbers'equiv-2ll [#_"long" x, #_"long" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'lt-2ll [#_"long" x, #_"long" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2ll [#_"long" x, #_"long" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2ll [#_"long" x, #_"long" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2ll [#_"long" x, #_"long" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'isPos-1l [#_"long" x]
        (> x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1l [#_"long" x]
        (< x 0)
    )

    (defn #_"boolean" Numbers'isZero-1l [#_"long" x]
        (zero? x)
    )

    ;; overload resolution

    (defn #_"Number" Numbers'add-2lo [#_"long" x, #_"Object" y]
        (Numbers'add-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'add-2ol [#_"Object" x, #_"long" y]
        (Numbers'add-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'addP-2lo [#_"long" x, #_"Object" y]
        (Numbers'addP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'addP-2ol [#_"Object" x, #_"long" y]
        (Numbers'addP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'add-2do [#_"double" x, #_"Object" y]
        (Numbers'add-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'add-2od [#_"Object" x, #_"double" y]
        (Numbers'add-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'add-2dl [#_"double" x, #_"long" y]
        (+ x y)
    )

    (defn #_"double" Numbers'add-2ld [#_"long" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2do [#_"double" x, #_"Object" y]
        (Numbers'addP-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'addP-2od [#_"Object" x, #_"double" y]
        (Numbers'addP-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'addP-2dl [#_"double" x, #_"long" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2ld [#_"long" x, #_"double" y]
        (+ x y)
    )

    (defn #_"Number" Numbers'minus-2lo [#_"long" x, #_"Object" y]
        (Numbers'minus-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'minus-2ol [#_"Object" x, #_"long" y]
        (Numbers'minus-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'minusP-2lo [#_"long" x, #_"Object" y]
        (Numbers'minusP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'minusP-2ol [#_"Object" x, #_"long" y]
        (Numbers'minusP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'minus-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'minus-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'minus-2dl [#_"double" x, #_"long" y]
        (- x y)
    )

    (defn #_"double" Numbers'minus-2ld [#_"long" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'minusP-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'minusP-2dl [#_"double" x, #_"long" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2ld [#_"long" x, #_"double" y]
        (- x y)
    )

    (defn #_"Number" Numbers'multiply-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiply-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'multiply-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiply-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'multiplyP-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiplyP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'multiplyP-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiplyP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'multiply-2do [#_"double" x, #_"Object" y]
        (Numbers'multiply-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'multiply-2od [#_"Object" x, #_"double" y]
        (Numbers'multiply-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'multiply-2dl [#_"double" x, #_"long" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiply-2ld [#_"long" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2do [#_"double" x, #_"Object" y]
        (Numbers'multiplyP-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'multiplyP-2od [#_"Object" x, #_"double" y]
        (Numbers'multiplyP-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'multiplyP-2dl [#_"double" x, #_"long" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2ld [#_"long" x, #_"double" y]
        (* x y)
    )

    (defn #_"Number" Numbers'divide-2lo [#_"long" x, #_"Object" y]
        (Numbers'divide-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'divide-2ol [#_"Object" x, #_"long" y]
        (Numbers'divide-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'divide-2do [#_"double" x, #_"Object" y]
        (/ x (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'divide-2od [#_"Object" x, #_"double" y]
        (/ (.doubleValue (cast Number x)) y)
    )

    (defn #_"double" Numbers'divide-2dl [#_"double" x, #_"long" y]
        (/ x y)
    )

    (defn #_"double" Numbers'divide-2ld [#_"long" x, #_"double" y]
        (/ x y)
    )

    (defn #_"Number" Numbers'divide-2ll [#_"long" x, #_"long" y]
        (Numbers'divide-2oo (cast Number x), (cast Number y))
    )

    (defn #_"boolean" Numbers'lt-2lo [#_"long" x, #_"Object" y]
        (Numbers'lt-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'lt-2ol [#_"Object" x, #_"long" y]
        (Numbers'lt-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'lt-2do [#_"double" x, #_"Object" y]
        (< x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'lt-2od [#_"Object" x, #_"double" y]
        (< (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'lt-2dl [#_"double" x, #_"long" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lt-2ld [#_"long" x, #_"double" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2lo [#_"long" x, #_"Object" y]
        (Numbers'lte-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'lte-2ol [#_"Object" x, #_"long" y]
        (Numbers'lte-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'lte-2do [#_"double" x, #_"Object" y]
        (<= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'lte-2od [#_"Object" x, #_"double" y]
        (<= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'lte-2dl [#_"double" x, #_"long" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'lte-2ld [#_"long" x, #_"double" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2lo [#_"long" x, #_"Object" y]
        (Numbers'gt-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'gt-2ol [#_"Object" x, #_"long" y]
        (Numbers'gt-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'gt-2do [#_"double" x, #_"Object" y]
        (> x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'gt-2od [#_"Object" x, #_"double" y]
        (> (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'gt-2dl [#_"double" x, #_"long" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gt-2ld [#_"long" x, #_"double" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2lo [#_"long" x, #_"Object" y]
        (Numbers'gte-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'gte-2ol [#_"Object" x, #_"long" y]
        (Numbers'gte-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'gte-2do [#_"double" x, #_"Object" y]
        (>= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'gte-2od [#_"Object" x, #_"double" y]
        (>= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'gte-2dl [#_"double" x, #_"long" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'gte-2ld [#_"long" x, #_"double" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'equiv-2lo [#_"long" x, #_"Object" y]
        (Numbers'equiv-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'equiv-2ol [#_"Object" x, #_"long" y]
        (Numbers'equiv-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'equiv-2do [#_"double" x, #_"Object" y]
        (= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'equiv-2od [#_"Object" x, #_"double" y]
        (= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'equiv-2dl [#_"double" x, #_"long" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'equiv-2ld [#_"long" x, #_"double" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'isNaN [#_"Object" x]
        (or (and (instance? Double x) (.isNaN (cast Double x))) (and (instance? Float x) (.isNaN (cast Float x))))
    )

    (defn #_"long" Numbers'max-2ll [#_"long" x, #_"long" y]
        (if (> x y) x y)
    )

    (defn #_"double" Numbers'max-2dd [#_"double" x, #_"double" y]
        (Math/max x, y)
    )

    (defn #_"Object" Numbers'max-2ld [#_"long" x, #_"double" y] (cond (Double/isNaN y) y (> x y) x :else y))
    (defn #_"Object" Numbers'max-2dl [#_"double" x, #_"long" y] (cond (Double/isNaN x) x (> x y) x :else y))

    (defn #_"Object" Numbers'max-2lo [#_"long" x, #_"Object" y] (cond (Numbers'isNaN y) y (Numbers'gt-2lo x, y) x :else y))
    (defn #_"Object" Numbers'max-2ol [#_"Object" x, #_"long" y] (cond (Numbers'isNaN x) x (Numbers'gt-2ol x, y) x :else y))

    (defn #_"Object" Numbers'max-2do [#_"double" x, #_"Object" y]
        (cond (Double/isNaN x) x (Numbers'isNaN y) y (> x (.doubleValue (cast Number y))) x :else y)
    )

    (defn #_"Object" Numbers'max-2od [#_"Object" x, #_"double" y]
        (cond (Numbers'isNaN x) x (Double/isNaN y) y (< y (.doubleValue (cast Number x))) x :else y)
    )

    (defn #_"Object" Numbers'max-2oo [#_"Object" x, #_"Object" y]
        (cond (Numbers'isNaN x) x (Numbers'isNaN y) y (Numbers'gt-2oo x, y) x :else y)
    )

    (defn #_"long" Numbers'min-2ll [#_"long" x, #_"long" y]
        (if (< x y) x y)
    )

    (defn #_"double" Numbers'min-2dd [#_"double" x, #_"double" y]
        (Math/min x, y)
    )

    (defn #_"Object" Numbers'min-2ld [#_"long" x, #_"double" y] (cond (Double/isNaN y) y (< x y) x :else y))
    (defn #_"Object" Numbers'min-2dl [#_"double" x, #_"long" y] (cond (Double/isNaN x) x (< x y) x :else y))

    (defn #_"Object" Numbers'min-2lo [#_"long" x, #_"Object" y] (cond (Numbers'isNaN y) y (Numbers'lt-2lo x, y) x :else y))
    (defn #_"Object" Numbers'min-2ol [#_"Object" x, #_"long" y] (cond (Numbers'isNaN x) x (Numbers'lt-2ol x, y) x :else y))

    (defn #_"Object" Numbers'min-2do [#_"double" x, #_"Object" y]
        (cond (Double/isNaN x) x (Numbers'isNaN y) y (< x (.doubleValue (cast Number y))) x :else y)
    )

    (defn #_"Object" Numbers'min-2od [#_"Object" x, #_"double" y]
        (cond (Numbers'isNaN x) x (Double/isNaN y) y (< (.doubleValue (cast Number x)) y) x :else y)
    )

    (defn #_"Object" Numbers'min-2oo [#_"Object" x, #_"Object" y]
        (cond (Numbers'isNaN x) x (Numbers'isNaN y) y (Numbers'lt-2oo x, y) x :else y)
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (defn- #_"Obj" Obj'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"Obj" Obj'new-1 [#_"IPersistentMap" meta]
        (let [this (Obj'init)]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    (defn #_"Obj" Obj'new-0 []
        (let [this (Obj'init)]
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Obj" this]
        (:_meta this)
    )

    #_abstract
    (§ defn #_"Obj" (§ method withMeta) [#_"Obj" this, #_"IPersistentMap" meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

(class-ns MSeq (§ extends ASeq) (§ implements Counted)
    (defn- #_"MSeq" MSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"MSeq" MSeq'new-2 [#_"Object[]" array, #_"int" i]
        (let [this (merge (ASeq'new) (MSeq'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    (defn #_"MSeq" MSeq'new-3 [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i]
        (let [this (merge (ASeq'new meta) (MSeq'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"MSeq" this]
        (MapEntry'create (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"MSeq" this]
        (when (< (+ (:i this) 2) (alength (:array this)))
            (MSeq'new-2 (:array this), (+ (:i this) 2))
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"MSeq" this]
        (/ (- (alength (:array this)) (:i this)) 2)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"MSeq" this, #_"IPersistentMap" meta]
        (MSeq'new-3 meta, (:array this), (:i this))
    )
)

(class-ns MIter (§ implements Iterator)
    (defn- #_"MIter" MIter'init []
        (hash-map
            #_"IFn" :f nil
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    ;; for iterator
    (defn #_"MIter" MIter'new-2 [#_"Object[]" array, #_"IFn" f]
        (MIter'new-3 array, -2, f)
    )

    ;; for entryAt
    (defn #_"MIter" MIter'new-3 [#_"Object[]" array, #_"int" i, #_"IFn" f]
        (let [this (MIter'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :f f))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"MIter" this]
        (< (:i this) (- (alength (:array this)) 2))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"MIter" this]
        (try
            (§ ass this (assoc this :i (+ (:i this) 2)))
            (.invoke (:f this), (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
            (catch IndexOutOfBoundsException e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"MIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransientArrayMap (§ extends ATransientMap)
    (defn- #_"TransientArrayMap" TransientArrayMap'init []
        (hash-map
            #_volatile
            #_"int" :len 0
            #_"Object[]" :array nil
            #_volatile
            #_"Thread" :owner nil
        )
    )

    (defn #_"TransientArrayMap" TransientArrayMap'new [#_"Object[]" array]
        (let [this (merge (ATransientMap'new) (TransientArrayMap'init))]
            (§ ass this (assoc this :owner (Thread/currentThread)))
            (§ ass this (assoc this :array (make-array Object (Math/max PersistentArrayMap'HASHTABLE_THRESHOLD, (alength array)))))
            (System/arraycopy array, 0, (:array this), 0, (alength array))
            (§ ass this (assoc this :len (alength array)))
            this
        )
    )

    #_method
    (§ defn- #_"int" (§ method indexOf) [#_"TransientArrayMap" this, #_"Object" key]
        (loop-when [#_"int" i 0] (< i (:len this)) => -1
            (if (PersistentArrayMap'equalKey (aget (:array this) i), key) i (recur (+ i 2)))
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"TransientArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (.indexOf this, key)]
            (cond (<= 0 i) ;; already have key,
                (do
                    (when-not (= (aget (:array this) (inc i)) val) ;; no change, no op
                        (aset (:array this) (inc i) val)
                    )
                    this
                )
                :else ;; didn't have key, grow
                (if (< (:len this) (alength (:array this)))
                    (do
                        (aset (:array this) (:len this) key)
                        (§ ass this (assoc this :len (inc (:len this))))
                        (aset (:array this) (:len this) val)
                        (§ ass this (assoc this :len (inc (:len this))))
                        this
                    )
                    (-> (PersistentHashMap'create-1a (:array this)) (.asTransient) (.assoc key, val))
                )
            )
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"TransientArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (.indexOf this, key)] (<= 0 i) => this
            ;; have key, will remove
            (when (<= 2 (:len this))
                (aset (:array this) i (aget (:array this) (- (:len this) 2)))
                (aset (:array this) (inc i) (aget (:array this) (- (:len this) 1)))
            )
            (§ ass this (assoc this :len (- (:len this) 2)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method doValAt) [#_"TransientArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (.indexOf this, key)]
            (if (<= 0 i) (aget (:array this) (inc i)) notFound)
        )
    )

    #_method
    (§ defn #_"int" (§ method doCount) [#_"TransientArrayMap" this]
        (/ (:len this) 2)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"TransientArrayMap" this]
        (.ensureEditable this)
        (§ ass this (assoc this :owner nil))
        (let [#_"Object[]" a (make-array Object (:len this))]
            (System/arraycopy (:array this), 0, a, 0, (:len this))
            (PersistentArrayMap'new-1 a)
        )
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientArrayMap" this]
        (when (nil? (:owner this))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap'new-0))
    (def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" other]
        (let [#_"ITransientMap" ret (.asTransient PersistentArrayMap'EMPTY)]
            (doseq [#_"Object" o (.entrySet other)]
                (let [#_"Map$Entry" e (cast' Entry o)]
                    (§ ass ret (.assoc ret, (.getKey e), (.getValue e)))
                )
            )
            (.persistent ret)
        )
    )

    (defn- #_"PersistentArrayMap" PersistentArrayMap'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IPersistentMap" :_meta nil
        )
    )

    #_protected
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-0 []
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass this (assoc this :array (make-array Object 0)))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    #_method
    (§ defn #_"PersistentArrayMap" (§ method withMeta) [#_"PersistentArrayMap" this, #_"IPersistentMap" meta]
        (PersistentArrayMap'new-2 meta, (:array this))
    )

    #_method
    (§ defn #_"PersistentArrayMap" (§ method create) [#_"PersistentArrayMap" this & #_"Object..." init]
        (PersistentArrayMap'new-2 (.meta this), init)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method createHT) [#_"PersistentArrayMap" this, #_"Object[]" init]
        (PersistentHashMap'create-2 (.meta this), init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" init]
        (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
            (loop-when-recur [#_"int" j (+ i 2)] (< j (alength init)) [(+ j 2)]
                (when (PersistentArrayMap'equalKey (aget init i), (aget init j))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget init i))))
                )
            )
        )
        (PersistentArrayMap'new-1 init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" init]
        (when (= (& (alength init) 1) 1)
            (throw (IllegalArgumentException. (str "No value supplied for key: " (aget init (dec (alength init))))))
        )
        ;; If this looks like it is doing busy-work, it is because it is achieving these goals: O(n^2) run time
        ;; like createWithCheck(), never modify init arg, and only allocate memory if there are duplicate keys.
        (let [#_"int" n 0]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
                (let [#_"boolean" duplicateKey false]
                    (loop-when-recur [#_"int" j 0] (< j i) [(+ j 2)]
                        (when (PersistentArrayMap'equalKey (aget init i), (aget init j))
                            (§ ass duplicateKey true)
                            (§ break )
                        )
                    )
                    (when (not duplicateKey)
                        (§ ass n (+ n 2))
                    )
                )
            )
            (when (< n (alength init))
                ;; Create a new shorter array with unique keys, and the last value associated with each key.
                ;; To behave like assoc, the first occurrence of each key must be used, since its metadata
                ;; may be different than later equal keys.
                (let [#_"Object[]" nodups (make-array Object n)]
                    (let [#_"int" m 0]
                        (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
                            (let [#_"boolean" duplicateKey false]
                                (loop-when-recur [#_"int" j 0] (< j m) [(+ j 2)]
                                    (when (PersistentArrayMap'equalKey (aget init i), (aget nodups j))
                                        (§ ass duplicateKey true)
                                        (§ break )
                                    )
                                )
                                (when (not duplicateKey)
                                    (§ let [#_"int" j]
                                        (loop-when-recur [j (- (alength init) 2)] (<= i j) [(- j 2)]
                                            (when (PersistentArrayMap'equalKey (aget init i), (aget init j))
                                                (§ break )
                                            )
                                        )
                                        (aset nodups m (aget init i))
                                        (aset nodups (inc m) (aget init (inc j)))
                                        (§ ass m (+ m 2))
                                    )
                                )
                            )
                        )
                        (when-not (= m n)
                            (throw (IllegalArgumentException. (str "Internal error: m=" m)))
                        )
                        (§ ass init nodups)
                    )
                )
            )
            (PersistentArrayMap'new-1 init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-1 [#_"Object[]" init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass this (assoc this :array init))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-2 [#_"IPersistentMap" meta, #_"Object[]" init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :array init))
            this
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"PersistentArrayMap" this]
        (/ (alength (:array this)) 2)
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentArrayMap" this, #_"Object" key]
        (<= 0 (.indexOf this, key))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"PersistentArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (.indexOf this, key)] (<= 0 i)
            (cast' IMapEntry (MapEntry'create (aget (:array this) i), (aget (:array this) (inc i))))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assocEx) [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (.indexOf this, key)]
            (when-not (<= 0 i) => (throw (RuntimeException. "Key already present"))
                ;; didn't have key, grow
                (if (< PersistentArrayMap'HASHTABLE_THRESHOLD (alength (:array this)))
                    (.assocEx (.createHT this, (:array this)), key, val)
                    (let [#_"int" n (alength (:array this)) #_"Object[]" newArray (make-array Object (+ n 2))]
                        (when (pos? n)
                            (System/arraycopy (:array this), 0, newArray, 2, n)
                        )
                        (aset newArray 0 key)
                        (aset newArray 1 val)
                        (.create this, newArray)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assoc) [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (.indexOf this, key)]
            (if (<= 0 i) ;; already have key, same-sized replacement
                (if (= (aget (:array this) (inc i)) val) ;; no change, no op
                    this
                    (let [#_"Object[]" newArray (.clone (:array this))]
                        (aset newArray (inc i) val)
                        (.create this, newArray)
                    )
                )
                ;; didn't have key, grow
                (if (< PersistentArrayMap'HASHTABLE_THRESHOLD (alength (:array this)))
                    (.assoc (.createHT this, (:array this)), key, val)
                    (let [#_"int" n (alength (:array this)) #_"Object[]" newArray (make-array Object (+ n 2))]
                        (when (pos? n)
                            (System/arraycopy (:array this), 0, newArray, 0, n)
                        )
                        (aset newArray n key)
                        (aset newArray (inc n) val)
                        (.create this, newArray)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method without) [#_"PersistentArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (.indexOf this, key)] (<= 0 i) => this ;; don't have key, no op
            ;; have key, will remove
            (let-when [#_"int" n (- (alength (:array this)) 2)] (pos? n) => (.empty this)
                (let [#_"Object[]" a (make-array Object n)]
                    (System/arraycopy (:array this), 0, a, 0, i)
                    (System/arraycopy (:array this), (+ i 2), a, i, (- n i))
                    (.create this, a)
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method empty) [#_"PersistentArrayMap" this]
        (cast' IPersistentMap (.withMeta PersistentArrayMap'EMPTY, (.meta this)))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (.indexOf this, key)]
            (if (<= 0 i) (aget (:array this) (inc i)) notFound)
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentArrayMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (§ defn #_"int" (§ method capacity) [#_"PersistentArrayMap" this]
        (.count this)
    )

    #_method
    (§ defn- #_"int" (§ method indexOfObject) [#_"PersistentArrayMap" this, #_"Object" key]
        (let [#_"EquivPred" ep (Util'equivPred key)]
            (loop-when [#_"int" i 0] (< i (alength (:array this))) => -1
                (if (.equiv ep, key, (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    #_method
    (§ defn- #_"int" (§ method indexOf) [#_"PersistentArrayMap" this, #_"Object" key]
        (when (§ instance? Keyword key) => (.indexOfObject this, key)
            (loop-when [#_"int" i 0] (< i (alength (:array this))) => -1
                (if (= key (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    (defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" k1, #_"Object" k2]
        (if (§ instance? Keyword k1) (= k1 k2) (Util'equiv-2oo k1, k2))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_ENTRY)
    )

    #_method
    (§ defn #_"Iterator" (§ method keyIterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_KEY)
    )

    #_method
    (§ defn #_"Iterator" (§ method valIterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_VAL)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentArrayMap" this]
        (when (pos? (alength (:array this)))
            (MSeq'new-2 (:array this), 0)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentArrayMap" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentArrayMap" this, #_"IFn" f, #_"Object" init]
        (loop-when [init init #_"int" i 0] (< i (alength (:array this))) => init
            (let [init (.invoke f, init, (aget (:array this) i), (aget (:array this) (inc i)))]
                (if (RT'isReduced init) (.deref (cast' IDeref init)) (recur init (+ i 2)))
            )
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method asTransient) [#_"PersistentArrayMap" this]
        (TransientArrayMap'new (:array this))
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns TransientHashMap (§ extends ATransientMap)
    (defn- #_"TransientHashMap" TransientHashMap'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_volatile
            #_"INode" :root nil
            #_volatile
            #_"int" :count 0
            #_volatile
            #_"boolean" :hasNull false
            #_volatile
            #_"Object" :nullValue nil
            #_"Box" :leafFlag (Box'new nil)
        )
    )

    (defn #_"TransientHashMap" TransientHashMap'new-1 [#_"PersistentHashMap" m]
        (TransientHashMap'new-5 (AtomicReference. (Thread/currentThread)), (:root m), (:count m), (:hasNull m), (:nullValue m))
    )

    (defn #_"TransientHashMap" TransientHashMap'new-5 [#_"AtomicReference<Thread>" edit, #_"INode" root, #_"int" count, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (ATransientMap'new) (TransientHashMap'init))]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :hasNull hasNull))
            (§ ass this (assoc this :nullValue nullValue))
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"TransientHashMap" this, #_"Object" key, #_"Object" val]
        (if (nil? key)
            (do
                (when-not (= (:nullValue this) val)
                    (§ ass this (assoc this :nullValue val))
                )
                (when (not (:hasNull this))
                    (§ ass this (assoc this :count (inc (:count this))))
                    (§ ass this (assoc this :hasNull true))
                )
                this
            )
            (let [_ (§ ass (:val (:leafFlag this)) nil)
                  #_"INode" n (.assoc (or (:root this) BitmapIndexedNode'EMPTY), (:edit this), 0, (PersistentHashMap'hash key), key, val, (:leafFlag this))]
                (when (not= n (:root this))
                    (§ ass this (assoc this :root n))
                )
                (when (some? (:val (:leafFlag this)))
                    (§ ass this (assoc this :count (inc (:count this))))
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"TransientHashMap" this, #_"Object" key]
        (if (nil? key)
            (when (:hasNull this) => this
                (§ ass this (assoc this :hasNull false))
                (§ ass this (assoc this :nullValue nil))
                (§ ass this (assoc this :count (dec (:count this))))
                this
            )
            (when (some? (:root this)) => this
                (let [_ (§ ass (:val (:leafFlag this)) nil)
                      #_"INode" n (.without (:root this), (:edit this), 0, (PersistentHashMap'hash key), key, (:leafFlag this))]
                    (when (not= n (:root this))
                        (§ ass this (assoc this :root n))
                    )
                    (when (some? (:val (:leafFlag this)))
                        (§ ass this (assoc this :count (dec (:count this))))
                    )
                    this
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"TransientHashMap" this]
        (.set (:edit this), nil)
        (PersistentHashMap'new-4 (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"Object" (§ method doValAt) [#_"TransientHashMap" this, #_"Object" key, #_"Object" notFound]
        (if (nil? key)
            (when (:hasNull this) => notFound
                (:nullValue this)
            )
            (when (some? (:root this)) => notFound
                (.find (:root this), 0, (PersistentHashMap'hash key), key, notFound)
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method doCount) [#_"TransientHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientHashMap" this]
        (when (nil? (.get (:edit this)))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(§ defprotocol INode
    #_abstract
    (#_"INode" INode'''(§ method assoc-6) [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
    #_abstract
    (#_"INode" INode'''(§ method without-4) [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
    #_abstract
    (#_"IMapEntry" INode'''(§ method find-4) [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
    #_abstract
    (#_"Object" INode'''(§ method find-5) [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound])
    #_abstract
    (#_"ISeq" INode'''(§ method nodeSeq) [#_"INode" this])
    #_abstract
    (#_"INode" INode'''(§ method assoc-7) [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
    #_abstract
    (#_"INode" INode'''(§ method without-6) [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf])
    #_abstract
    (#_"Object" INode'''(§ method kvreduce) [#_"INode" this, #_"IFn" f, #_"Object" init])
    #_abstract
    (#_"Object" INode'''(§ method fold) [#_"INode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin])
    ;; returns the result of (f [k v]) for each iterated element
    #_abstract
    (#_"Iterator" INode'''(§ method iterator) [#_"INode" this, #_"IFn" f])
)

(class-ns HSeq (§ extends ASeq)
    (defn #_"ISeq" HSeq'create-1 [#_"INode[]" nodes]
        (HSeq'create-4 nil, nodes, 0, nil)
    )

    (defn- #_"ISeq" HSeq'create-4 [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
        (when (nil? s) => (HSeq'new meta, nodes, i, s)
            (loop-when i (< i (alength nodes))
                (let-when [#_"INode" ai (aget nodes i)] (some? ai) => (recur (inc i))
                    (let-when [s (.nodeSeq ai)] (some? s) => (recur (inc i))
                        (HSeq'new meta, nodes, (inc i), s)
                    )
                )
            )
        )
    )

    (defn- #_"HSeq" HSeq'init []
        (hash-map
            #_"INode[]" :nodes nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn- #_"HSeq" HSeq'new [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
        (let [this (merge (ASeq'new meta) (HSeq'init))]
            (§ ass this (assoc this :nodes nodes))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :s s))
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"HSeq" this, #_"IPersistentMap" meta]
        (HSeq'new meta, (:nodes this), (:i this), (:s this))
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"HSeq" this]
        (.first (:s this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"HSeq" this]
        (HSeq'create-4 nil, (:nodes this), (:i this), (.next (:s this)))
    )
)

(class-ns HIter (§ implements Iterator)
    (defn- #_"HIter" HIter'init []
        (hash-map
            #_"INode[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Iterator" :nestedIter nil
        )
    )

    (defn- #_"HIter" HIter'new [#_"INode[]" array, #_"IFn" f]
        (let [this (HIter'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :f f))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"HIter" this]
        (loop []
            (when (some? (:nestedIter this))
                (if (.hasNext (:nestedIter this))
                    (§ return true)
                    (§ ass this (assoc this :nestedIter nil))
                )
            )
            (when (< (:i this) (alength (:array this))) => false
                (let [#_"INode" ai (aget (:array this) (:i this))]
                    (§ ass this (assoc this :i (inc (:i this))))
                    (when (some? ai)
                        (§ ass this (assoc this :nestedIter (.iterator ai, (:f this))))
                    )
                    (recur)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"HIter" this]
        (when (.hasNext this) => (throw (NoSuchElementException.))
            (.next (:nestedIter this))
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"HIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ArrayNode (§ implements INode)
    (defn- #_"ArrayNode" ArrayNode'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_"int" :count 0
            #_"INode[]" :array nil
        )
    )

    (defn #_"ArrayNode" ArrayNode'new [#_"AtomicReference<Thread>" edit, #_"int" count, #_"INode[]" array]
        (let [this (ArrayNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :array array))
            this
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)]
            (if (some? ai)
                (let [#_"INode" node (.assoc ai, (+ shift 5), hash, key, val, addedLeaf)]
                    (when-not (= node ai) => this
                        (ArrayNode'new nil, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                    )
                )
                (let [#_"INode" node (.assoc BitmapIndexedNode'EMPTY, (+ shift 5), hash, key, val, addedLeaf)]
                    (ArrayNode'new nil, (inc (:count this)), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)] (some? ai) => this
            (let-when-not [#_"INode" node (.without ai, (+ shift 5), hash, key)] (= node ai) => this
                (cond
                    (some? node)         (ArrayNode'new nil, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                    (<= (:count this) 8) (.pack this, nil, i) ;; shrink
                    :else                (ArrayNode'new nil, (dec (:count this)), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" node (aget (:array this) i)]
            (when (some? node)
                (.find node, (+ shift 5), hash, key)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" node (aget (:array this) i)]
            (when (some? node) => notFound
                (.find node, (+ shift 5), hash, key, notFound)
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"ArrayNode" this]
        (HSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ArrayNode" this, #_"IFn" f]
        (HIter'new (:array this), f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"ArrayNode" this, #_"IFn" f, #_"Object" init]
        (doseq [#_"INode" node (:array this)]
            (when (some? node)
                (§ ass init (.kvreduce node, f, init))
                (when (RT'isReduced init)
                    (§ return init)
                )
            )
        )
        init
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"ArrayNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (let [#_"List<Callable>" tasks (ArrayList.)]
            (doseq [#_"INode" node (:array this)]
                (when (some? node)
                    (.add tasks,
                        (§ reify Callable()
                            #_method
                            (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                                (.fold node, combinef, reducef, fjtask, fjfork, fjjoin)
                            )
                        )
                    )
                )
            )
            (ArrayNode'foldTasks tasks, combinef, fjtask, fjfork, fjjoin)
        )
    )

    (defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" tasks, #_"IFn" combinef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (cond
            (.isEmpty tasks)
                (.invoke combinef)
            (= (.size tasks) 1)
                (try
                    (.call (.get tasks, 0))
                    (catch Exception e
                        (throw (Util'sneakyThrow e))
                    )
                )
            :else
                (let [#_"int" n (.size tasks)
                      #_"List<Callable>" t1 (.subList tasks, 0, (/ n 2)) #_"List<Callable>" t2 (.subList tasks, (/ n 2), n)
                      #_"Object" forked
                        (.invoke fjfork, (.invoke fjtask,
                            (§ reify Callable()
                                #_method
                                (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                                    (ArrayNode'foldTasks t2, combinef, fjtask, fjfork, fjjoin)
                                )
                            )
                        ))]
                    (.invoke combinef, (ArrayNode'foldTasks t1, combinef, fjtask, fjfork, fjjoin), (.invoke fjjoin, forked))
                )
        )
    )

    #_method
    (§ defn- #_"ArrayNode" (§ method ensureEditable) [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit]
        (if (= (:edit this) edit)
            this
            (ArrayNode'new edit, (:count this), (.clone (:array this)))
        )
    )

    #_method
    (§ defn- #_"ArrayNode" (§ method editAndSet) [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"INode" node]
        (let [#_"ArrayNode" e (.ensureEditable this, edit)]
            (aset (:array e) i node)
            e
        )
    )

    #_method
    (§ defn- #_"INode" (§ method pack) [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" idx]
        (let [#_"Object[]" a (make-array Object (* 2 (dec (:count this))))]
            (let [#_"int" j 1]
                (let [#_"int" bitmap 0]
                    (loop-when-recur [#_"int" i 0] (< i idx) [(inc i)]
                        (when (some? (aget (:array this) i))
                            (aset a j (aget (:array this) i))
                            (§ ass bitmap (| bitmap (<< 1 i)))
                            (§ ass j (+ j 2))
                        )
                    )
                    (loop-when-recur [#_"int" i (inc idx)] (< i (alength (:array this))) [(inc i)]
                        (when (some? (aget (:array this) i))
                            (aset a j (aget (:array this) i))
                            (§ ass bitmap (| bitmap (<< 1 i)))
                            (§ ass j (+ j 2))
                        )
                    )
                    (BitmapIndexedNode'new edit, bitmap, a)
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)]
            (if (some? ai)
                (let [#_"INode" node (.assoc ai, edit, (+ shift 5), hash, key, val, addedLeaf)]
                    (when-not (= node ai) => this
                        (.editAndSet this, edit, i, node)
                    )
                )
                (let [#_"ArrayNode" e (.editAndSet this, edit, i, (.assoc BitmapIndexedNode'EMPTY, edit, (+ shift 5), hash, key, val, addedLeaf))]
                    (§ ass (:count e) (inc (:count e)))
                    e
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)] (some? ai) => this
            (let-when-not [#_"INode" node (.without ai, edit, (+ shift 5), hash, key, removedLeaf)] (= node ai) => this
                (cond
                    (some? node)         (.editAndSet this, edit, i, node)
                    (<= (:count this) 8) (.pack this, edit, i) ;; shrink
                    :else
                        (let [#_"ArrayNode" e (.editAndSet this, edit, i, node)]
                            (§ ass (:count e) (dec (:count e)))
                            e
                        )
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode (§ implements INode)
    (§ def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (BitmapIndexedNode'new nil, 0, (object-array 0)))

    (defn- #_"BitmapIndexedNode" BitmapIndexedNode'init []
        (hash-map
            #_"int" :bitmap 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"BitmapIndexedNode" BitmapIndexedNode'new [#_"AtomicReference<Thread>" edit, #_"int" bitmap, #_"Object[]" array]
        (let [this (BitmapIndexedNode'init)]
            (§ ass this (assoc this :bitmap bitmap))
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :edit edit))
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"BitmapIndexedNode" this, #_"int" bit]
        (Integer/bitCount (& (:bitmap this) (dec bit)))
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" bit (PersistentHashMap'bitpos hash, shift) #_"int" idx (.index this, bit)]
            (if-not (zero? (& (:bitmap this) bit))
                (let [#_"Object" keyOrNull (aget (:array this) (* 2 idx))
                      #_"Object" valOrNode (aget (:array this) (inc (* 2 idx)))
                      _ (cond
                            (nil? keyOrNull)
                                (let [#_"INode" n (.assoc (cast' INode valOrNode), (+ shift 5), hash, key, val, addedLeaf)]
                                    (when-not (= n valOrNode)
                                        (PersistentHashMap'cloneAndSet-3 (:array this), (inc (* 2 idx)), n)
                                    )
                                )
                            (Util'equiv-2oo key, keyOrNull)
                                (when-not (= val valOrNode)
                                    (PersistentHashMap'cloneAndSet-3 (:array this), (inc (* 2 idx)), val)
                                )
                            :else
                                (let [_ (§ ass (:val addedLeaf) addedLeaf)]
                                    (PersistentHashMap'cloneAndSet-5 (:array this), (* 2 idx), nil, (inc (* 2 idx)), (PersistentHashMap'createNode-6 (+ shift 5), keyOrNull, valOrNode, hash, key, val))
                                )
                        )]
                    (if (some? _) (BitmapIndexedNode'new nil, (:bitmap this), _) this)
                )
                (let [#_"int" n (Integer/bitCount (:bitmap this))]
                    (if (<= 16 n)
                        (let [#_"INode[]" nodes (make-array #_"INode" Object 32) #_"int" jdx (PersistentHashMap'mask hash, shift)]
                            (aset nodes jdx (.assoc BitmapIndexedNode'EMPTY, (+ shift 5), hash, key, val, addedLeaf))
                            (loop-when [#_"int" j 0 #_"int" i 0] (< i 32)
                                (when-not (= (& (>>> (:bitmap this) i) 1) 0) => (recur j (inc i))
                                    (if (some? (aget (:array this) j))
                                        (aset nodes i (.assoc BitmapIndexedNode'EMPTY, (+ shift 5), (PersistentHashMap'hash (aget (:array this) j)), (aget (:array this) j), (aget (:array this) (inc j)), addedLeaf))
                                        (aset nodes i (cast' INode (aget (:array this) (inc j))))
                                    )
                                    (recur (+ j 2) (inc i))
                                )
                            )
                            (ArrayNode'new nil, (inc n), nodes)
                        )
                        (let [#_"Object[]" a (make-array Object (* 2 (inc n)))]
                            (System/arraycopy (:array this), 0, a, 0, (* 2 idx))
                            (aset a (* 2 idx) key)
                            (§ ass (:val addedLeaf) addedLeaf)
                            (aset a (inc (* 2 idx)) val)
                            (System/arraycopy (:array this), (* 2 idx), a, (* 2 (inc idx)), (* 2 (- n idx)))
                            (BitmapIndexedNode'new nil, (| (:bitmap this) bit), a)
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => this
            (let [#_"int" i (.index this, bit) #_"int" ii (* 2 i)
                  #_"Object" keyOrNull (aget (:array this) ii)
                  #_"Object" valOrNode (aget (:array this) (inc ii))]
                (if (some? keyOrNull)
                    (when (Util'equiv-2oo key, keyOrNull) => this
                        ;; TODO: collapse
                        (BitmapIndexedNode'new nil, (bit-xor (:bitmap this) bit), (PersistentHashMap'removePair (:array this), i))
                    )
                    (let [#_"INode" n (.without (cast' INode valOrNode), (+ shift 5), hash, key)]
                        (cond
                            (= n valOrNode)
                                this
                            (some? n)
                                (BitmapIndexedNode'new nil, (:bitmap this), (PersistentHashMap'cloneAndSet-3 (:array this), (inc ii), n))
                            (= (:bitmap this) bit)
                                nil
                            :else
                                (BitmapIndexedNode'new nil, (bit-xor (:bitmap this) bit), (PersistentHashMap'removePair (:array this), i))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit))
            (let [#_"int" i (.index this, bit)
                  #_"Object" keyOrNull (aget (:array this) (* 2 i))
                  #_"Object" valOrNode (aget (:array this) (inc (* 2 i)))]
                (cond
                    (nil? keyOrNull)                (.find (cast' INode valOrNode), (+ shift 5), hash, key)
                    (Util'equiv-2oo key, keyOrNull) (cast' IMapEntry (MapEntry'create keyOrNull, valOrNode))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => notFound
            (let [#_"int" i (.index this, bit)
                  #_"Object" keyOrNull (aget (:array this) (* 2 i))
                  #_"Object" valOrNode (aget (:array this) (inc (* 2 i)))]
                (cond
                    (nil? keyOrNull)                (.find (cast' INode valOrNode), (+ shift 5), hash, key, notFound)
                    (Util'equiv-2oo key, keyOrNull) valOrNode
                    :else                           notFound
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"BitmapIndexedNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"BitmapIndexedNode" this, #_"IFn" f]
        (NodeIter'new (:array this), f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"BitmapIndexedNode" this, #_"IFn" f, #_"Object" init]
        (NodeSeq'kvreduce (:array this), f, init)
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"BitmapIndexedNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (NodeSeq'kvreduce (:array this), reducef, (.invoke combinef))
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method ensureEditable) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit]
        (when-not (= (:edit this) edit) => this
            (let [#_"int" n (Integer/bitCount (:bitmap this)) #_"Object[]" a (make-array Object (* 2 (inc n)))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                (BitmapIndexedNode'new edit, (:bitmap this), a)
            )
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndSet) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" x]
        (let [#_"BitmapIndexedNode" e (.ensureEditable this, edit)]
            (aset (:array e) i x)
            e
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndSet) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" x, #_"int" j, #_"Object" y]
        (let [#_"BitmapIndexedNode" e (.ensureEditable this, edit)]
            (aset (:array e) i x)
            (aset (:array e) j y)
            e
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndRemovePair) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" bit, #_"int" i]
        (when-not (= (:bitmap this) bit)
            (let [#_"BitmapIndexedNode" e (.ensureEditable this, edit) #_"Object[]" a (:array e) #_"int" n (alength a)]
                (§ ass (:bitmap e) (bit-xor (:bitmap e) bit))
                (System/arraycopy a, (* 2 (inc i)), a, (* 2 i), (- n (* 2 (inc i))))
                (aset a (- n 2) nil)
                (aset a (- n 1) nil)
                e
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" bit (PersistentHashMap'bitpos hash, shift) #_"int" idx (.index this, bit)]
            (if-not (zero? (& (:bitmap this) bit))
                (let [#_"Object" keyOrNull (aget (:array this) (* 2 idx))
                      #_"Object" valOrNode (aget (:array this) (inc (* 2 idx)))]
                    (cond
                        (nil? keyOrNull)
                            (let [#_"INode" n (.assoc (cast' INode valOrNode), edit, (+ shift 5), hash, key, val, addedLeaf)]
                                (when-not (= n valOrNode) => this
                                    (.editAndSet this, edit, (inc (* 2 idx)), n)
                                )
                            )
                        (Util'equiv-2oo key, keyOrNull)
                            (when-not (= val valOrNode) => this
                                (.editAndSet this, edit, (inc (* 2 idx)), val)
                            )
                        :else
                            (let [_ (§ ass (:val addedLeaf) addedLeaf)]
                                (.editAndSet this, edit, (* 2 idx), nil, (inc (* 2 idx)), (PersistentHashMap'createNode-7 edit, (+ shift 5), keyOrNull, valOrNode, hash, key, val))
                            )
                    )
                )
                (let [#_"int" n (Integer/bitCount (:bitmap this))]
                    (cond
                        (< (* n 2) (alength (:array this)))
                            (let [_ (§ ass (:val addedLeaf) addedLeaf)
                                  #_"BitmapIndexedNode" e (.ensureEditable this, edit)]
                                (System/arraycopy (:array e), (* 2 idx), (:array e), (* 2 (inc idx)), (* 2 (- n idx)))
                                (aset (:array e) (* 2 idx) key)
                                (aset (:array e) (inc (* 2 idx)) val)
                                (§ ass (:bitmap e) (| (:bitmap e) bit))
                                e
                            )
                        (<= 16 n)
                            (let [#_"INode[]" nodes (make-array #_"INode" Object 32) #_"int" jdx (PersistentHashMap'mask hash, shift)]
                                (aset nodes jdx (.assoc BitmapIndexedNode'EMPTY, edit, (+ shift 5), hash, key, val, addedLeaf))
                                (loop-when [#_"int" j 0 #_"int" i 0] (< i 32)
                                    (when-not (= (& (>>> (:bitmap this) i) 1) 0) => (recur j (inc i))
                                        (if (some? (aget (:array this) j))
                                            (aset nodes i (.assoc BitmapIndexedNode'EMPTY, edit, (+ shift 5), (PersistentHashMap'hash (aget (:array this) j)), (aget (:array this) j), (aget (:array this) (inc j)), addedLeaf))
                                            (aset nodes i (cast' INode (aget (:array this) (inc j))))
                                        )
                                        (recur (+ j 2) (inc i))
                                    )
                                )
                                (ArrayNode'new edit, (inc n), nodes)
                            )
                        :else
                            (let [#_"Object[]" a (make-array Object (* 2 (+ n 4)))]
                                (System/arraycopy (:array this), 0, a, 0, (* 2 idx))
                                (aset a (* 2 idx) key)
                                (§ ass (:val addedLeaf) addedLeaf)
                                (aset a (inc (* 2 idx)) val)
                                (System/arraycopy (:array this), (* 2 idx), a, (* 2 (inc idx)), (* 2 (- n idx)))
                                (let [#_"BitmapIndexedNode" e (.ensureEditable this, edit)]
                                    (§ ass (:array e) a)
                                    (§ ass (:bitmap e) (| (:bitmap e) bit))
                                    e
                                )
                            )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => this
            (let [#_"int" i (.index this, bit) #_"int" ii ii
                  #_"Object" keyOrNull (aget (:array this) ii)
                  #_"Object" valOrNode (aget (:array this) (inc ii))]
                (if (some? keyOrNull)
                    (when (Util'equiv-2oo key, keyOrNull) => this
                        (§ ass (:val removedLeaf) removedLeaf)
                        ;; TODO: collapse
                        (.editAndRemovePair this, edit, bit, i)
                    )
                    (let [#_"INode" n (.without (cast' INode valOrNode), edit, (+ shift 5), hash, key, removedLeaf)]
                        (cond
                            (= n valOrNode)
                                this
                            (some? n)
                                (.editAndSet this, edit, (inc ii), n)
                            (= (:bitmap this) bit)
                                nil
                            :else
                                (.editAndRemovePair this, edit, bit, i)
                        )
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode (§ implements INode)
    (defn- #_"HashCollisionNode" HashCollisionNode'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_"int" :hash 0
            #_"int" :count 0
            #_"Object[]" :array nil
        )
    )

    (defn #_"HashCollisionNode" HashCollisionNode'new [#_"AtomicReference<Thread>" edit, #_"int" hash, #_"int" count & #_"Object..." array]
        (let [this (HashCollisionNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :hash hash))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :array array))
            this
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (if (= hash (:hash this))
            (let [#_"int" i (.findIndex this, key)]
                (if (<= 0 i)
                    (when-not (= (aget (:array this) (inc i)) val) => this
                        (HashCollisionNode'new nil, hash, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), (inc i), val))
                    )
                    (let [#_"int" n (:count this) #_"Object[]" a (make-array Object (* 2 (inc n)))]
                        (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                        (aset a (* 2 n) key)
                        (aset a (inc (* 2 n)) val)
                        (§ ass (:val addedLeaf) addedLeaf)
                        (HashCollisionNode'new (:edit this), hash, (inc n), a)
                    )
                )
            )
            ;; nest it in a bitmap node
            (let [#_"BitmapIndexedNode" node (BitmapIndexedNode'new nil, (PersistentHashMap'bitpos (:hash this), shift), (object-array [ nil, this ]))]
                (.assoc node, shift, hash, key, val, addedLeaf)
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (.findIndex this, key)] (<= 0 i) => this
            (let-when [#_"int" n (:count this)] (< 1 n)
                (HashCollisionNode'new nil, hash, (dec n), (PersistentHashMap'removePair (:array this), (/ i 2)))
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (.findIndex this, key)] (<= 0 i)
            (let-when [#_"Object" ai (aget (:array this) i)] (Util'equiv-2oo key, ai)
                (cast' IMapEntry (MapEntry'create ai, (aget (:array this) (inc i))))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let-when [#_"int" i (.findIndex this, key)] (<= 0 i) => notFound
            (when (Util'equiv-2oo key, (aget (:array this) i)) => notFound
                (aget (:array this) (inc i))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"HashCollisionNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"HashCollisionNode" this, #_"IFn" f]
        (NodeIter'new (:array this), f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"HashCollisionNode" this, #_"IFn" f, #_"Object" init]
        (NodeSeq'kvreduce (:array this), f, init)
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"HashCollisionNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (NodeSeq'kvreduce (:array this), reducef, (.invoke combinef))
    )

    #_method
    (§ defn #_"int" (§ method findIndex) [#_"HashCollisionNode" this, #_"Object" key]
        (let [#_"int" n (* 2 (:count this))]
            (loop-when [#_"int" i 0] (< i n) => -1
                (if (Util'equiv-2oo key, (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method ensureEditable) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit]
        (when-not (= (:edit this) edit) => this
            (let [#_"int" n (:count this) #_"Object[]" a (make-array Object (* 2 (inc n)))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                (HashCollisionNode'new edit, (:hash this), n, a)
            )
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method ensureEditable) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" count, #_"Object[]" array]
        (if (= (:edit this) edit)
            (assoc this :array array :count count)
            (HashCollisionNode'new edit, (:hash this), count, array)
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method editAndSet) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
        (let [#_"HashCollisionNode" e (.ensureEditable this, edit)]
            (aset (:array e) i a)
            e
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method editAndSet) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
        (let [#_"HashCollisionNode" e (.ensureEditable this, edit)]
            (aset (:array e) i a)
            (aset (:array e) j b)
            e
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (if (= hash (:hash this))
            (let [#_"int" i (.findIndex this, key)]
                (if (<= 0 i)
                    (when-not (= (aget (:array this) (inc i)) val) => this
                        (.editAndSet this, edit, (inc i), val)
                    )
                    (let [#_"int" n (:count this) #_"int" m (alength (:array this))]
                        (if (< (* 2 n) m)
                            (let [_ (§ ass (:val addedLeaf) addedLeaf)
                                  #_"HashCollisionNode" e (.editAndSet this, edit, (* 2 n), key, (inc (* 2 n)), val)]
                                (§ ass (:count e) (inc (:count e)))
                                e
                            )
                            (let [#_"Object[]" a (make-array Object (+ m 2))]
                                (System/arraycopy (:array this), 0, a, 0, m)
                                (aset a m key)
                                (aset a (inc m) val)
                                (§ ass (:val addedLeaf) addedLeaf)
                                (.ensureEditable this, edit, (inc n), a)
                            )
                        )
                    )
                )
            )
            ;; nest it in a bitmap node
            (let [#_"BitmapIndexedNode" node (BitmapIndexedNode'new edit, (PersistentHashMap'bitpos (:hash this), shift), (object-array [ nil, this, nil, nil ]))]
                (.assoc node, edit, shift, hash, key, val, addedLeaf)
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when [#_"int" i (.findIndex this, key)] (<= 0 i) => this
            (§ ass (:val removedLeaf) removedLeaf)
            (let-when [#_"int" n (:count this)] (< 1 n)
                (let [#_"HashCollisionNode" e (.ensureEditable this, edit) #_"int" m (* 2 n)]
                    (aset (:array e) i (aget (:array e) (- m 2)))
                    (aset (:array e) (inc i) (aget (:array e) (- m 1)))
                    (aset (:array e) (- m 2) nil)
                    (aset (:array e) (- m 1) nil)
                    (§ ass (:count e) (dec (:count e)))
                    e
                )
            )
        )
    )
)

(class-ns NodeIter (§ implements Iterator)
    (def- #_"Object" NodeIter'NULL (Object.))

    (defn- #_"NodeIter" NodeIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Object" :nextEntry NodeIter'NULL
            #_"Iterator" :nextIter nil
        )
    )

    (defn #_"NodeIter" NodeIter'new [#_"Object[]" array, #_"IFn" f]
        (let [this (NodeIter'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :f f))
            this
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method advance) [#_"NodeIter" this]
        (loop-when [] (< (:i this) (alength (:array this))) => false
            (let [#_"Object" key (aget (:array this) (:i this))
                  #_"Object" nodeOrVal (aget (:array this) (inc (:i this)))
                  _ (§ ass this (assoc this :i (+ (:i this) 2)))]
                (cond
                    (some? key)
                        (do
                            (§ ass this (assoc this :nextEntry (.invoke (:f this), key, nodeOrVal)))
                            true
                        )
                    (some? nodeOrVal)
                        (let [#_"Iterator" it (.iterator (cast' INode nodeOrVal), (:f this))]
                            (when (and (some? it) (.hasNext it)) => (recur)
                                (§ ass this (assoc this :nextIter it))
                                true
                            )
                        )
                    :else
                        (recur)
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"NodeIter" this]
        (or (not= (:nextEntry this) NodeIter'NULL) (some? (:nextIter this)) (.advance this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"NodeIter" this]
        (let [#_"Object" e (:nextEntry this)]
            (cond
                (not= e NodeIter'NULL)
                    (let [_ (§ ass this (assoc this :nextEntry NodeIter'NULL))]
                        e
                    )
                (some? (:nextIter this))
                    (let [_ (§ ass e (.next (:nextIter this)))
                          _ (when-not (.hasNext (:nextIter this))
                                (§ ass this (assoc this :nextIter nil))
                            )]
                        e
                    )
                (.advance this)
                    (.next this)
                :else
                    (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"NodeIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns NodeSeq (§ extends ASeq)
    (defn- #_"NodeSeq" NodeSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-2 [#_"Object[]" array, #_"int" i]
        (NodeSeq'new-4 nil, array, i, nil)
    )

    (defn #_"ISeq" NodeSeq'create-1 [#_"Object[]" array]
        (NodeSeq'create-3 array, 0, nil)
    )

    (defn #_"Object" NodeSeq'kvreduce [#_"Object[]" array, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (alength array)) => r
            (let [r (if (some? (aget array i))
                        (.invoke f, r, (aget array i), (aget array (inc i)))
                        (let-when [#_"INode" node (cast' INode (aget array (inc i)))] (some? node) => r
                            (.kvreduce node, f, r)
                        )
                    )]
                (when-not (RT'isReduced r) => r
                    (recur r (+ i 2))
                )
            )
        )
    )

    (defn- #_"ISeq" NodeSeq'create-3 [#_"Object[]" array, #_"int" i, #_"ISeq" s]
        (when (nil? s) => (NodeSeq'new-4 nil, array, i, s)
            (loop-when i (< i (alength array))
                (when (nil? (aget array i)) => (NodeSeq'new-4 nil, array, i, nil)
                    (or
                        (when-let [#_"INode" node (cast' INode (aget array (inc i)))]
                            (when-let [s (.nodeSeq node)]
                                (NodeSeq'new-4 nil, array, (+ i 2), s)
                            )
                        )
                        (recur (+ i 2))
                    )
                )
            )
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-4 [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i, #_"ISeq" s]
        (let [this (merge (ASeq'new meta) (NodeSeq'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :s s))
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"NodeSeq" this, #_"IPersistentMap" meta]
        (NodeSeq'new-4 meta, (:array this), (:i this), (:s this))
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"NodeSeq" this]
        (if (some? (:s this))
            (.first (:s this))
            (MapEntry'create (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
        )
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"NodeSeq" this]
        (if (some? (:s this))
            (NodeSeq'create-3 (:array this), (:i this), (.next (:s this)))
            (NodeSeq'create-3 (:array this), (+ (:i this) 2), nil)
        )
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" PersistentHashMap'EMPTY (PersistentHashMap'new-4 0, nil, false, nil))
    (def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (defn #_"IPersistentMap" PersistentHashMap'create-1m [#_"Map" other]
        (let [#_"ITransientMap" ret (.asTransient PersistentHashMap'EMPTY)]
            (doseq [#_"Object" o (.entrySet other)]
                (let [#_"Map$Entry" e (cast' Entry o)]
                    (§ ass ret (.assoc ret, (.getKey e), (.getValue e)))
                )
            )
            (.persistent ret)
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-1a [& #_"Object..." init]
        (let [#_"ITransientMap" ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
                (§ ass ret (.assoc ret, (aget init i), (aget init (inc i))))
            )
            (cast' PersistentHashMap (.persistent ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1a [& #_"Object..." init]
        (let [#_"ITransientMap" ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
                (§ ass ret (.assoc ret, (aget init i), (aget init (inc i))))
                (when (not= (.count ret) (inc (/ i 2)))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget init i))))
                )
            )
            (cast' PersistentHashMap (.persistent ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1s [#_"ISeq" items]
        (let [#_"ITransientMap" ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [items items] (some? items) [(.next (.next items))]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (.assoc ret, (.first items), (RT'second items)))
            )
            (cast' PersistentHashMap (.persistent ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1s [#_"ISeq" items]
        (let [#_"ITransientMap" ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [items items #_"int" i 0] (some? items) [(.next (.next items)) (inc i)]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (.assoc ret, (.first items), (RT'second items)))
                (when-not (= (.count ret) (inc i))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (.first items))))
                )
            )
            (cast' PersistentHashMap (.persistent ret))
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-2 [#_"IPersistentMap" meta & #_"Object..." init]
        (-> (PersistentHashMap'create-1a init) (.withMeta meta))
    )

    (defn- #_"PersistentHashMap" PersistentHashMap'init []
        (hash-map
            #_"int" :count 0
            #_"INode" :root nil
            #_"boolean" :hasNull false
            #_"Object" :nullValue nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-4 [#_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :hasNull hasNull))
            (§ ass this (assoc this :nullValue nullValue))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-5 [#_"IPersistentMap" meta, #_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :hasNull hasNull))
            (§ ass this (assoc this :nullValue nullValue))
            this
        )
    )

    (defn #_"int" PersistentHashMap'hash [#_"Object" k]
        (Util'hasheq k)
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentHashMap" this, #_"Object" key]
        (if (nil? key)
            (:hasNull this)
            (and (some? (:root this))
                 (not= (.find (:root this), 0, (PersistentHashMap'hash key), key, PersistentHashMap'NOT_FOUND) PersistentHashMap'NOT_FOUND)
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"PersistentHashMap" this, #_"Object" key]
        (if (nil? key)
            (when (:hasNull this) (cast' IMapEntry (MapEntry'create nil, (:nullValue this))))
            (when (some? (:root this)) (.find (:root this), 0, (PersistentHashMap'hash key), key))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assoc) [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (if (nil? key)
            (when-not (and (:hasNull this) (= val (:nullValue this))) => this
                (PersistentHashMap'new-5 (.meta this), (+ (:count this) (if (:hasNull this) 0 1)), (:root this), true, val)
            )
            (let [#_"Box" addedLeaf (Box'new nil)
                  #_"INode" newroot (.assoc (or (:root this) BitmapIndexedNode'EMPTY), 0, (PersistentHashMap'hash key), key, val, addedLeaf)]
                (when-not (= newroot (:root this)) => this
                    (PersistentHashMap'new-5 (.meta this), (+ (:count this) (if (some? (:val addedLeaf)) 1 0)), newroot, (:hasNull this), (:nullValue this))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentHashMap" this, #_"Object" key, #_"Object" notFound]
        (if (nil? key)
            (if (:hasNull this) (:nullValue this) notFound)
            (if (some? (:root this)) (.find (:root this), 0, (PersistentHashMap'hash key), key, notFound) notFound)
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentHashMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assocEx) [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (when (.containsKey this, key)
            (throw (RuntimeException. "Key already present"))
        )
        (.assoc this, key, val)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method without) [#_"PersistentHashMap" this, #_"Object" key]
        (cond
            (nil? key)
                (if (:hasNull this) (PersistentHashMap'new-5 (.meta this), (dec (:count this)), (:root this), false, nil) this)
            (nil? (:root this))
                this
            :else
                (let [#_"INode" newroot (.without (:root this), 0, (PersistentHashMap'hash key), key)]
                    (when-not (= newroot (:root this)) => this
                        (PersistentHashMap'new-5 (.meta this), (dec (:count this)), newroot, (:hasNull this), (:nullValue this))
                    )
                )
        )
    )

    (def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn- #_"Iterator" (§ method iterator) [#_"PersistentHashMap" this, #_"IFn" f]
        (let [#_"Iterator" rootIter (if (nil? (:root this)) PersistentHashMap'EMPTY_ITER (.iterator (:root this), f))]
            (if (:hasNull this)
                (do
                    (§ reify Iterator()
                        (§ init
                            (hash-map
                                #_"boolean" :seen false
                            )
                        )

                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (if (not (:seen this))
                                (do
                                    true
                                )
                                (do
                                    (.hasNext rootIter)
                                )
                            )
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (if (not (:seen this))
                                (do
                                    (§ ass this (assoc this :seen true))
                                    (.invoke f, nil, (:nullValue this))
                                )
                                (do
                                    (.next rootIter)
                                )
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
                (do
                    rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentHashMap" this]
        (.iterator this, APersistentMap'MAKE_ENTRY)
    )

    #_method
    (§ defn #_"Iterator" (§ method keyIterator) [#_"PersistentHashMap" this]
        (.iterator this, APersistentMap'MAKE_KEY)
    )

    #_method
    (§ defn #_"Iterator" (§ method valIterator) [#_"PersistentHashMap" this]
        (.iterator this, APersistentMap'MAKE_VAL)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentHashMap" this, #_"IFn" f, #_"Object" r]
        (let [r (if (:hasNull this) (.invoke f, r, nil, (:nullValue this)) r)]
            (when-not (RT'isReduced r) => (.deref (cast' IDeref r))
                (when (some? (:root this)) => r
                    (let [r (.kvreduce (:root this), f, r)]
                        (when-not (RT'isReduced r) => (.deref (cast' IDeref r))
                            r
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"PersistentHashMap" this, #_"long" n, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjinvoke, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" top
                (§ reify Callable()
                    #_method
                    (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                        (let [#_"Object" ret (.invoke combinef)]
                            (when (some? (:root this))
                                (§ ass ret (.invoke combinef, ret, (.fold (:root this), combinef, reducef, fjtask, fjfork, fjjoin)))
                            )
                            (if (:hasNull this) (.invoke combinef, ret, (.invoke reducef, (.invoke combinef), nil, (:nullValue this))) ret)
                        )
                    )
                )]
            (.invoke fjinvoke, top)
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"PersistentHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentHashMap" this]
        (let [#_"ISeq" s (when (some? (:root this)) (.nodeSeq (:root this)))]
            (if (:hasNull this) (Cons'new-2 (MapEntry'create nil, (:nullValue this)), s) s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentHashMap" this]
        (.withMeta PersistentHashMap'EMPTY, (.meta this))
    )

    (defn #_"int" PersistentHashMap'mask [#_"int" hash, #_"int" shift]
        (& (>>> hash shift) 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" (§ method withMeta) [#_"PersistentHashMap" this, #_"IPersistentMap" meta]
        (PersistentHashMap'new-5 meta, (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"TransientHashMap" (§ method asTransient) [#_"PersistentHashMap" this]
        (TransientHashMap'new-1 this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentHashMap" this]
        (:_meta this)
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-3 [#_"Object[]" array, #_"int" i, #_"Object" x]
        (let [#_"Object[]" a (.clone array)]
            (aset a i x)
            a
        )
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-5 [#_"Object[]" array, #_"int" i, #_"Object" x, #_"int" j, #_"Object" y]
        (let [#_"Object[]" a (.clone array)]
            (aset a i x)
            (aset a j y)
            a
        )
    )

    (defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" array, #_"int" i]
        (let [#_"Object[]" a (make-array Object (- (alength array) 2))]
            (System/arraycopy array, 0, a, 0, (* 2 i))
            (System/arraycopy array, (* 2 (inc i)), a, (* 2 i), (- (alength a) (* 2 i)))
            a
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-6 [#_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (PersistentHashMap'hash key1)]
            (when-not (= key1hash key2hash) => (HashCollisionNode'new nil, key1hash, 2, (object-array [ key1, val1, key2, val2 ]))
                (let [#_"Box" addedLeaf (Box'new nil) #_"AtomicReference<Thread>" edit (AtomicReference.)]
                    (-> BitmapIndexedNode'EMPTY
                        (.assoc edit, shift, key1hash, key1, val1, addedLeaf)
                        (.assoc edit, shift, key2hash, key2, val2, addedLeaf)
                    )
                )
            )
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-7 [#_"AtomicReference<Thread>" edit, #_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (PersistentHashMap'hash key1)]
            (when-not (= key1hash key2hash) => (HashCollisionNode'new nil, key1hash, 2, (object-array [ key1, val1, key2, val2 ]))
                (let [#_"Box" addedLeaf (Box'new nil)]
                    (-> BitmapIndexedNode'EMPTY
                        (.assoc edit, shift, key1hash, key1, val1, addedLeaf)
                        (.assoc edit, shift, key2hash, key2, val2, addedLeaf)
                    )
                )
            )
        )
    )

    (defn- #_"int" PersistentHashMap'bitpos [#_"int" hash, #_"int" shift]
        (<< 1 (PersistentHashMap'mask hash, shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_stateless
(class-ns TransientHashSet (§ extends ATransientSet)
    (defn #_"TransientHashSet" TransientHashSet'new [#_"ITransientMap" impl]
        (ATransientSet'new impl)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method persistent) [#_"TransientHashSet" this]
        (PersistentHashSet'new nil, (.persistent (:impl this)))
    )
)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" PersistentHashSet'EMPTY (PersistentHashSet'new nil, PersistentHashMap'EMPTY))

    (defn #_"PersistentHashSet" PersistentHashSet'create-1a [& #_"Object..." init]
        (let [#_"ITransientSet" ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(inc i)]
                (§ ass ret (cast' ITransientSet (.conj ret, (aget init i))))
            )
            (cast' PersistentHashSet (.persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1l [#_"List" init]
        (let [#_"ITransientSet" ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (doseq [#_"Object" key init]
                (§ ass ret (cast' ITransientSet (.conj ret, key)))
            )
            (cast' PersistentHashSet (.persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1s [#_"ISeq" items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [items items] (some? items) [(.next items)]
                (§ ass ret (cast' ITransientSet (.conj ret, (.first items))))
            )
            (cast' PersistentHashSet (.persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1a [& #_"Object..." init]
        (let [#_"ITransientSet" ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(inc i)]
                (§ ass ret (cast' ITransientSet (.conj ret, (aget init i))))
                (when-not (= (.count ret) (inc i))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget init i))))
                )
            )
            (cast' PersistentHashSet (.persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1l [#_"List" init]
        (let [#_"ITransientSet" ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (let [#_"int" i 0]
                (doseq [#_"Object" key init]
                    (§ ass ret (cast' ITransientSet (.conj ret, key)))
                    (when-not (= (.count ret) (inc i))
                        (throw (IllegalArgumentException. (str "Duplicate key: " key)))
                    )
                    (§ ass i (inc i))
                )
                (cast' PersistentHashSet (.persistent ret))
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1s [#_"ISeq" items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (.asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [items items #_"int" i 0] (some? items) [(.next items) (inc i)]
                (§ ass ret (cast' ITransientSet (.conj ret, (.first items))))
                (when-not (= (.count ret) (inc i))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (.first items))))
                )
            )
            (cast' PersistentHashSet (.persistent ret))
        )
    )

    (defn- #_"PersistentHashSet" PersistentHashSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'new [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (merge (APersistentSet'new impl) (PersistentHashSet'init))]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method disjoin) [#_"PersistentHashSet" this, #_"Object" key]
        (if (.contains this, key)
            (PersistentHashSet'new (.meta this), (.without (:impl this), key))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method cons) [#_"PersistentHashSet" this, #_"Object" o]
        (if (.contains this, o)
            this
            (PersistentHashSet'new (.meta this), (.assoc (:impl this), o, o))
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentHashSet" this]
        (.withMeta PersistentHashSet'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentHashSet" (§ method withMeta) [#_"PersistentHashSet" this, #_"IPersistentMap" meta]
        (PersistentHashSet'new meta, (:impl this))
    )

    #_method
    (§ defn #_"ITransientCollection" (§ method asTransient) [#_"PersistentHashSet" this]
        (TransientHashSet'new (.asTransient (cast' PersistentHashMap (:impl this))))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentHashSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns Primordial (§ extends RestFn)
    (defn #_"Primordial" Primordial'new []
        (RestFn'new)
    )

    #_method
    (§ defn #_"int" (§ method getRequiredArity) [#_"Primordial" this]
        0
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"Primordial" this, #_"Object" args]
        (if (§ instance? ArraySeq args)
            (let [#_"Object[]" a (:array (cast' ArraySeq args))]
                (loop-when-recur [#_"IPersistentList" l PersistentList'EMPTY #_"int" i (dec (alength a))]
                                 (<= (:i (cast' ArraySeq args)) i)
                                 [(cast' IPersistentList (.cons l, (aget a i))) (dec i)]
                              => l
                )
            )
            (let [#_"LinkedList" l (LinkedList.)]
                (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                    (.add l, (.first s))
                )
                (PersistentList'create l)
            )
        )
    )

    (defn #_"Object" Primordial'invokeStatic [#_"ISeq" args]
        (if (§ instance? ArraySeq args)
            (let [#_"Object[]" a (:array (cast' ArraySeq args))]
                (loop-when-recur [#_"IPersistentList" l PersistentList'EMPTY #_"int" i (dec (alength a))]
                                 (<= 0 i)
                                 [(cast' IPersistentList (.cons l, (aget a i))) (dec i)]
                              => l
                )
            )
            (let [#_"LinkedList" l (LinkedList.)]
                (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                    (.add l, (.first s))
                )
                (PersistentList'create l)
            )
        )
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"Primordial" this, #_"IPersistentMap" meta]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Primordial" this]
        nil
    )
)

#_stateless
(class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
    (§ def #_"int" EmptyList'HASHEQ (Murmur3'hashOrdered Collections/EMPTY_LIST))

    (defn #_"EmptyList" EmptyList'new [#_"IPersistentMap" meta]
        (Obj'new meta)
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"EmptyList" this]
        1
    )

    #_method
    (defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'HASHEQ
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"EmptyList" this]
        "()"
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"EmptyList" this, #_"Object" o]
        (and (or (§ instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"EmptyList" this, #_"Object" o]
        (.equals this, o)
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"EmptyList" this]
        nil
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"PersistentList" (§ method cons) [#_"EmptyList" this, #_"Object" o]
        (PersistentList'new-4 (.meta this), o, nil, 1)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"EmptyList" (§ method withMeta) [#_"EmptyList" this, #_"IPersistentMap" meta]
        (if (= meta (.meta this))
            this
            (EmptyList'new meta)
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentList" (§ method pop) [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"EmptyList" this]
        true
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"EmptyList" this, #_"Object" o]
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"EmptyList" this]
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"EmptyList" this]
        RT'EMPTY_ARRAY
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"EmptyList" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"EmptyList" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"EmptyList" this, #_"Collection" collection]
        (.isEmpty collection)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"EmptyList" this, #_"Object[]" objects]
        (when (pos? (alength objects))
            (aset objects 0 nil)
        )
        objects
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"EmptyList" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"EmptyList" this, #_"int" fromIndex, #_"int" toIndex]
        (.subList (.reify this), fromIndex, toIndex)
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"EmptyList" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"EmptyList" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"EmptyList" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this) #_"int" i 0] (some? s) => -1
            (if (Util'equiv-2oo (.first s), o) i (recur (.next s) (inc i)))
        )
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"EmptyList" this, #_"Object" o]
        (.lastIndexOf (.reify this), o)
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"EmptyList" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"EmptyList" this, #_"int" index]
        (.listIterator (.reify this), index)
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"EmptyList" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"EmptyList" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"EmptyList" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ def #_"IFn" PersistentList'creator (Primordial'new))

    (§ def #_"EmptyList" PersistentList'EMPTY (EmptyList'new nil))

    (defn- #_"PersistentList" PersistentList'init []
        (hash-map
            #_"Object" :_first nil
            #_"IPersistentList" :_rest nil
            #_"int" :_count 0
        )
    )

    (defn #_"PersistentList" PersistentList'new-1 [#_"Object" first]
        (let [this (merge (ASeq'new) (PersistentList'init))]
            (§ ass this (assoc this :_first first))
            (§ ass this (assoc this :_rest nil))
            (§ ass this (assoc this :_count 1))
            this
        )
    )

    (defn #_"PersistentList" PersistentList'new-4 [#_"IPersistentMap" meta, #_"Object" _first, #_"IPersistentList" _rest, #_"int" _count]
        (let [this (merge (ASeq'new meta) (PersistentList'init))]
            (§ ass this (assoc this :_first _first))
            (§ ass this (assoc this :_rest _rest))
            (§ ass this (assoc this :_count _count))
            this
        )
    )

    (defn #_"IPersistentList" PersistentList'create [#_"List" init]
        (let [#_"ListIterator" it (.listIterator init, (.size init))]
            (loop-when-recur [#_"IPersistentList" ret PersistentList'EMPTY] (.hasPrevious it) [(cast' IPersistentList (.cons ret, (.previous it)))] => ret)
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"PersistentList" this]
        (:_first this)
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"PersistentList" this]
        (when-not (= (:_count this) 1)
            (cast' ISeq (:_rest this))
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"PersistentList" this]
        (.first this)
    )

    #_method
    (§ defn #_"IPersistentList" (§ method pop) [#_"PersistentList" this]
        (or (:_rest this) (.withMeta PersistentList'EMPTY, (:_meta this)))
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"PersistentList" this]
        (:_count this)
    )

    #_method
    (§ defn #_"PersistentList" (§ method cons) [#_"PersistentList" this, #_"Object" o]
        (PersistentList'new-4 (.meta this), o, this, (inc (:_count this)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentList" this]
        (.withMeta PersistentList'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentList" (§ method withMeta) [#_"PersistentList" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (PersistentList'new-4 meta, (:_first this), (:_rest this), (:_count this))
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentList" this, #_"IFn" f]
        (loop-when [#_"Object" r (.first this) #_"ISeq" s (.next this)] (some? s) => r
            (let [r (.invoke f, r, (.first s))]
                (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (.next s)))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentList" this, #_"IFn" f, #_"Object" r]
        (loop-when [r (.invoke f, r, (.first this)) #_"ISeq" s (.next this)] (some? s) => (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
            (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur (.invoke f, r, (.first s)) (.next s)))
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns QSeq (§ extends ASeq)
    (defn- #_"QSeq" QSeq'init []
        (hash-map
            #_"ISeq" :f nil
            #_"ISeq" :rseq nil
        )
    )

    (defn #_"QSeq" QSeq'new-2 [#_"ISeq" f, #_"ISeq" rseq]
        (let [this (merge (ASeq'new) (QSeq'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :rseq rseq))
            this
        )
    )

    (defn #_"QSeq" QSeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" f, #_"ISeq" rseq]
        (let [this (merge (ASeq'new meta) (QSeq'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :rseq rseq))
            this
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"QSeq" this]
        (.first (:f this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"QSeq" this]
        (let [#_"ISeq" f (.next (:f this)) #_"ISeq" r (:rseq this)]
            (cond
                (some? f) (QSeq'new-2 f, r)
                (some? r) (QSeq'new-2 r, nil)
            )
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"QSeq" this]
        (+ (RT'count (:f this)) (RT'count (:rseq this)))
    )

    #_method
    (§ defn #_"QSeq" (§ method withMeta) [#_"QSeq" this, #_"IPersistentMap" meta]
        (QSeq'new-3 meta, (:f this), (:rseq this))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" PersistentQueue'EMPTY (PersistentQueue'new nil, 0, nil, nil))

    (defn- #_"PersistentQueue" PersistentQueue'init []
        (hash-map
            #_"int" :cnt 0
            #_"ISeq" :f nil
            #_"PersistentVector" :r nil
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"PersistentQueue" PersistentQueue'new [#_"IPersistentMap" meta, #_"int" cnt, #_"ISeq" f, #_"PersistentVector" r]
        (let [this (merge (Obj'new meta) (PersistentQueue'init))]
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :r r))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentQueue" this, #_"Object" obj]
        (and (§ instance? Sequential obj)
            (loop-when [#_"ISeq" s (.seq this) #_"ISeq" ms (RT'seq obj)] (some? s) => (nil? ms)
                (and (some? ms) (Util'equiv-2oo (.first s), (.first ms))
                    (recur (.next s) (.next ms))
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentQueue" this, #_"Object" obj]
        (and (§ instance? Sequential obj)
            (loop-when [#_"ISeq" s (.seq this) #_"ISeq" ms (RT'seq obj)] (some? s) => (nil? ms)
                (and (some? ms) (Util'equals (.first s), (.first ms))
                    (recur (.next s) (.next ms))
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"PersistentQueue" this]
        (let [#_"int" hash (:_hash this)]
            (when (zero? hash)
                (§ ass hash 1)
                (loop-when-recur [#_"ISeq" s (.seq this)] (some? s) [(.next s)]
                    (§ ass hash (+ (* 31 hash) (if (nil? (.first s)) 0 (.hashCode (.first s)))))
                )
                (§ ass this (assoc this :_hash hash))
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"PersistentQueue" this]
        (let [#_"int" cached (:_hasheq this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hasheq (§ ass cached (Murmur3'hashOrdered this))))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"PersistentQueue" this]
        (RT'first (:f this))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method pop) [#_"PersistentQueue" this]
        (when (some? (:f this)) => this ;; hmmm... pop of empty queue -> empty queue?
            (let [#_"ISeq" f (.next (:f this)) #_"PersistentVector" r (:r this)
                  [f r]
                    (when (nil? f) => [f r]
                        [(RT'seq r) nil]
                    )]
                (PersistentQueue'new (.meta this), (dec (:cnt this)), f, r)
            )
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"PersistentQueue" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentQueue" this]
        (when (some? (:f this))
            (QSeq'new-2 (:f this), (RT'seq (:r this)))
        )
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method cons) [#_"PersistentQueue" this, #_"Object" o]
        (let [[#_"ISeq" f #_"PersistentVector" r]
                (if (nil? (:f this)) ;; empty
                    [(RT'list-1 o) nil]
                    [(:f this) (.cons (or (:r this) PersistentVector'EMPTY), o)]
                )]
            (PersistentQueue'new (.meta this), (inc (:cnt this)), f, r)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentQueue" this]
        (.withMeta PersistentQueue'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method withMeta) [#_"PersistentQueue" this, #_"IPersistentMap" meta]
        (PersistentQueue'new meta, (:cnt this), (:f this), (:r this))
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"PersistentQueue" this]
        (RT'seqToArray (.seq this))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"PersistentQueue" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"PersistentQueue" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"PersistentQueue" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (.contains this, o)
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"PersistentQueue" this, #_"Object[]" a]
        (RT'seqToPassedArray (.seq this), a)
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"PersistentQueue" this]
        (.count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"PersistentQueue" this]
        (zero? (.count this))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"PersistentQueue" this, #_"Object" o]
        (loop-when [#_"ISeq" s (.seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"ISeq" :fseq (:f this)
                    #_"Iterator" :riter (when (some? (:r this)) (.iterator (:r this)))
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (or (and (some? (:fseq this)) (some? (.seq (:fseq this)))) (and (some? (:riter this)) (.hasNext (:riter this))))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (cond (some? (:fseq this))
                    (let [#_"Object" ret (.first (:fseq this))]
                        (§ ass this (assoc this :fseq (.next (:fseq this))))
                        ret
                    )
                    (and (some? (:riter this)) (.hasNext (:riter this)))
                    (do
                        (.next (:riter this))
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

#_abstract
(class-ns TNode (§ extends AMapEntry)
    (defn- #_"TNode" TNode'init []
        (hash-map
            #_"Object" :key nil
        )
    )

    (defn #_"TNode" TNode'new [#_"Object" key]
        (let [this (merge (AMapEntry'new) (TNode'init))]
            (§ ass this (assoc this :key key))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method key) [#_"TNode" this]
        (:key this)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method getKey) [#_"TNode" this]
        (.key this)
    )

    #_method
    (§ defn #_"Object" (§ method getValue) [#_"TNode" this]
        (.val this)
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"TNode" this]
        nil
    )

    #_abstract
    (§ defn #_"TNode" (§ method addLeft) [#_"TNode" this, #_"TNode" ins])
    #_abstract
    (§ defn #_"TNode" (§ method addRight) [#_"TNode" this, #_"TNode" ins])
    #_abstract
    (§ defn #_"TNode" (§ method removeLeft) [#_"TNode" this, #_"TNode" del])
    #_abstract
    (§ defn #_"TNode" (§ method removeRight) [#_"TNode" this, #_"TNode" del])
    #_abstract
    (§ defn #_"TNode" (§ method blacken) [#_"TNode" this])
    #_abstract
    (§ defn #_"TNode" (§ method redden) [#_"TNode" this])

    #_method
    (§ defn #_"TNode" (§ method balanceLeft) [#_"TNode" this, #_"TNode" parent]
        (PersistentTreeMap'black (:key parent), (.val parent), this, (.right parent))
    )

    #_method
    (§ defn #_"TNode" (§ method balanceRight) [#_"TNode" this, #_"TNode" parent]
        (PersistentTreeMap'black (:key parent), (.val parent), (.left parent), this)
    )

    #_abstract
    (§ defn #_"TNode" (§ method replace) [#_"TNode" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right])

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"TNode" this, #_"IFn" f, #_"Object" r]
        (when (some? (.left this))
            (§ ass r (.kvreduce (.left this), f, r))
            (when (RT'isReduced r)
                (§ return r)
            )
        )
        (let [r (.invoke f, r, (.key this), (.val this))]
            (cond
                (RT'isReduced r)      r
                (some? (.right this)) (.kvreduce (.right this), f, r)
                :else                 r
            )
        )
    )
)

#_stateless
(class-ns Black (§ extends TNode)
    (defn #_"Black" Black'new [#_"Object" key]
        (TNode'new key)
    )

    #_method
    (§ defn #_"TNode" (§ method addLeft) [#_"Black" this, #_"TNode" ins]
        (.balanceLeft ins, this)
    )

    #_method
    (§ defn #_"TNode" (§ method addRight) [#_"Black" this, #_"TNode" ins]
        (.balanceRight ins, this)
    )

    #_method
    (§ defn #_"TNode" (§ method removeLeft) [#_"Black" this, #_"TNode" del]
        (PersistentTreeMap'balanceLeftDel (:key this), (.val this), del, (.right this))
    )

    #_method
    (§ defn #_"TNode" (§ method removeRight) [#_"Black" this, #_"TNode" del]
        (PersistentTreeMap'balanceRightDel (:key this), (.val this), (.left this), del)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"Black" this]
        this
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"Black" this]
        (Red'new (:key this))
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"Black" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (PersistentTreeMap'black key, val, left, right)
    )
)

(class-ns BlackVal (§ extends Black)
    (defn- #_"BlackVal" BlackVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackVal" BlackVal'new [#_"Object" key, #_"Object" val]
        (let [this (merge (Black'new key) (BlackVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BlackVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackVal" this]
        (RedVal'new (:key this), (:val this))
    )
)

(class-ns BlackBranch (§ extends Black)
    (defn- #_"BlackBranch" BlackBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"BlackBranch" BlackBranch'new [#_"Object" key, #_"TNode" left, #_"TNode" right]
        (let [this (merge (Black'new key) (BlackBranch'init))]
            (§ ass this (assoc this :left left))
            (§ ass this (assoc this :right right))
            this
        )
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"BlackBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"BlackBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackBranch" this]
        (RedBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns BlackBranchVal (§ extends BlackBranch)
    (defn- #_"BlackBranchVal" BlackBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackBranchVal" BlackBranchVal'new [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (let [this (merge (BlackBranch'new key, left, right) (BlackBranchVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BlackBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackBranchVal" this]
        (RedBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

#_stateless
(class-ns Red (§ extends TNode)
    (defn #_"Red" Red'new [#_"Object" key]
        (TNode'new key)
    )

    #_method
    (§ defn #_"TNode" (§ method addLeft) [#_"Red" this, #_"TNode" ins]
        (PersistentTreeMap'red (:key this), (.val this), ins, (.right this))
    )

    #_method
    (§ defn #_"TNode" (§ method addRight) [#_"Red" this, #_"TNode" ins]
        (PersistentTreeMap'red (:key this), (.val this), (.left this), ins)
    )

    #_method
    (§ defn #_"TNode" (§ method removeLeft) [#_"Red" this, #_"TNode" del]
        (PersistentTreeMap'red (:key this), (.val this), del, (.right this))
    )

    #_method
    (§ defn #_"TNode" (§ method removeRight) [#_"Red" this, #_"TNode" del]
        (PersistentTreeMap'red (:key this), (.val this), (.left this), del)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"Red" this]
        (Black'new (:key this))
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"Red" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (PersistentTreeMap'red key, val, left, right)
    )
)

(class-ns RedVal (§ extends Red)
    (defn- #_"RedVal" RedVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedVal" RedVal'new [#_"Object" key, #_"Object" val]
        (let [this (merge (Red'new key) (RedVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"RedVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedVal" this]
        (BlackVal'new (:key this), (:val this))
    )
)

(class-ns RedBranch (§ extends Red)
    (defn- #_"RedBranch" RedBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"RedBranch" RedBranch'new [#_"Object" key, #_"TNode" left, #_"TNode" right]
        (let [this (merge (Red'new key) (RedBranch'init))]
            (§ ass this (assoc this :left left))
            (§ ass this (assoc this :right right))
            this
        )
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"RedBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"RedBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" (§ method balanceLeft) [#_"RedBranch" this, #_"TNode" parent]
        (cond (§ instance? Red (:left this))
            (do
                (PersistentTreeMap'red (:key this), (.val this), (.blacken (:left this)), (PersistentTreeMap'black (:key parent), (.val parent), (:right this), (.right parent)))
            )
            (§ instance? Red (:right this))
            (do
                (PersistentTreeMap'red (:key (:right this)), (.val (:right this)), (PersistentTreeMap'black (:key this), (.val this), (:left this), (.left (:right this))), (PersistentTreeMap'black (:key parent), (.val parent), (.right (:right this)), (.right parent)))
            )
            :else
            (do
                (.balanceLeft (§ super ), parent)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method balanceRight) [#_"RedBranch" this, #_"TNode" parent]
        (cond (§ instance? Red (:right this))
            (do
                (PersistentTreeMap'red (:key this), (.val this), (PersistentTreeMap'black (:key parent), (.val parent), (.left parent), (:left this)), (.blacken (:right this)))
            )
            (§ instance? Red (:left this))
            (do
                (PersistentTreeMap'red (:key (:left this)), (.val (:left this)), (PersistentTreeMap'black (:key parent), (.val parent), (.left parent), (.left (:left this))), (PersistentTreeMap'black (:key this), (.val this), (.right (:left this)), (:right this)))
            )
            :else
            (do
                (.balanceRight (§ super ), parent)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedBranch" this]
        (BlackBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns RedBranchVal (§ extends RedBranch)
    (defn- #_"RedBranchVal" RedBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedBranchVal" RedBranchVal'new [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (let [this (merge (RedBranch'new key, left, right) (RedBranchVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"RedBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedBranchVal" this]
        (BlackBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns TSeq (§ extends ASeq)
    (defn- #_"TSeq" TSeq'init []
        (hash-map
            #_"ISeq" :stack nil
            #_"boolean" :asc false
            #_"int" :cnt 0
        )
    )

    (defn #_"TSeq" TSeq'new-2 [#_"ISeq" stack, #_"boolean" asc]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass this (assoc this :stack stack))
            (§ ass this (assoc this :asc asc))
            (§ ass this (assoc this :cnt -1))
            this
        )
    )

    (defn #_"TSeq" TSeq'new-3 [#_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass this (assoc this :stack stack))
            (§ ass this (assoc this :asc asc))
            (§ ass this (assoc this :cnt cnt))
            this
        )
    )

    (defn #_"TSeq" TSeq'new-4 [#_"IPersistentMap" meta, #_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
        (let [this (merge (ASeq'new meta) (TSeq'init))]
            (§ ass this (assoc this :stack stack))
            (§ ass this (assoc this :asc asc))
            (§ ass this (assoc this :cnt cnt))
            this
        )
    )

    (defn #_"TSeq" TSeq'create [#_"TNode" t, #_"boolean" asc, #_"int" cnt]
        (TSeq'new-3 (TSeq'push t, nil, asc), asc, cnt)
    )

    (defn #_"ISeq" TSeq'push [#_"TNode" t, #_"ISeq" stack, #_"boolean" asc]
        (while (some? t)
            (§ ass stack (RT'cons t, stack))
            (§ ass t (if asc (.left t) (.right t)))
        )
        stack
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"TSeq" this]
        (.first (:stack this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"TSeq" this]
        (let [#_"TNode" t (cast' TNode (.first (:stack this)))
              #_"ISeq" nextstack (TSeq'push (if (:asc this) (.right t) (.left t)), (.next (:stack this)), (:asc this))]
            (when (some? nextstack)
                (TSeq'new-3 nextstack, (:asc this), (dec (:cnt this)))
            )
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"TSeq" this]
        (when (neg? (:cnt this)) => (:cnt this)
            (.count (§ super ))
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"TSeq" this, #_"IPersistentMap" meta]
        (TSeq'new-4 meta, (:stack this), (:asc this), (:cnt this))
    )
)

(class-ns NodeIterator (§ implements Iterator)
    (defn- #_"NodeIterator" NodeIterator'init []
        (hash-map
            #_"Stack" :stack (Stack.)
            #_"boolean" :asc false
        )
    )

    (defn #_"NodeIterator" NodeIterator'new [#_"TNode" t, #_"boolean" asc]
        (let [this (NodeIterator'init)]
            (§ ass this (assoc this :asc asc))
            (.push this, t)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method push) [#_"NodeIterator" this, #_"TNode" t]
        (while (some? t)
            (.push (:stack this), t)
            (§ ass t (if (:asc this) (.left t) (.right t)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"NodeIterator" this]
        (not (.isEmpty (:stack this)))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"NodeIterator" this]
        (try
            (let [#_"TNode" t (cast' TNode (.pop (:stack this)))]
                (.push this, (if (:asc this) (.right t) (.left t)))
                t
            )
            (catch EmptyStackException e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"NodeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns KeyIterator (§ implements Iterator)
    (defn- #_"KeyIterator" KeyIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"KeyIterator" KeyIterator'new [#_"NodeIterator" it]
        (let [this (KeyIterator'init)]
            (§ ass this (assoc this :it it))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"KeyIterator" this]
        (.hasNext (:it this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"KeyIterator" this]
        (:key (cast' TNode (.next (:it this))))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"KeyIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ValIterator (§ implements Iterator)
    (defn- #_"ValIterator" ValIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"ValIterator" ValIterator'new [#_"NodeIterator" it]
        (let [this (ValIterator'init)]
            (§ ass this (assoc this :it it))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ValIterator" this]
        (.hasNext (:it this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"ValIterator" this]
        (.val (cast' TNode (.next (:it this))))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ValIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap'new-0))

    (defn #_"IPersistentMap" PersistentTreeMap'create-1m [#_"Map" other]
        (let [#_"IPersistentMap" ret PersistentTreeMap'EMPTY]
            (doseq [#_"Object" o (.entrySet other)]
                (let [#_"Map$Entry" e (cast' Entry o)]
                    (§ ass ret (.assoc ret, (.getKey e), (.getValue e)))
                )
            )
            ret
        )
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'init []
        (hash-map
            #_"Comparator" :comp nil
            #_"TNode" :tree nil
            #_"int" :_count 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-0 []
        (PersistentTreeMap'new-1 RT'DEFAULT_COMPARATOR)
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'new-1 [#_"Comparator" comp]
        (PersistentTreeMap'new-2 nil, comp)
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-2 [#_"IPersistentMap" meta, #_"Comparator" comp]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass this (assoc this :comp comp))
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :tree nil))
            (§ ass this (assoc this :_count 0))
            this
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4m [#_"IPersistentMap" meta, #_"Comparator" comp, #_"TNode" tree, #_"int" _count]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :comp comp))
            (§ ass this (assoc this :tree tree))
            (§ ass this (assoc this :_count _count))
            this
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method withMeta) [#_"PersistentTreeMap" this, #_"IPersistentMap" meta]
        (PersistentTreeMap'new-4m meta, (:comp this), (:tree this), (:_count this))
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-1s [#_"ISeq" items]
        (let [#_"IPersistentMap" ret PersistentTreeMap'EMPTY]
            (loop-when-recur [items items] (some? items) [(.next (.next items))]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (.assoc ret, (.first items), (RT'second items)))
            )
            (cast' PersistentTreeMap ret)
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-2 [#_"Comparator" comp, #_"ISeq" items]
        (let [#_"IPersistentMap" ret (PersistentTreeMap'new-1 comp)]
            (loop-when-recur [items items] (some? items) [(.next (.next items))]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (.assoc ret, (.first items), (RT'second items)))
            )
            (cast' PersistentTreeMap ret)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentTreeMap" this, #_"Object" key]
        (some? (.entryAt this, key))
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (.equals (§ super ), obj)
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (.equiv (§ super ), obj)
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method assocEx) [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (.add this, (:tree this), key, val, found)]
            (when (nil? t) ;; nil == already contains key
                (throw (RuntimeException. "Key already present"))
            )
            (PersistentTreeMap'new-4c (:comp this), (.blacken t), (inc (:_count this)), (.meta this))
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method assoc) [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (.add this, (:tree this), key, val, found)]
            (if (nil? t) ;; nil == already contains key
                (if (= (.val (cast' TNode (:val found))) val) ;; note only get same collection on identity of val, not equals()
                    this
                    (PersistentTreeMap'new-4c (:comp this), (.replace this, (:tree this), key, val), (:_count this), (.meta this))
                )
                (PersistentTreeMap'new-4c (:comp this), (.blacken t), (inc (:_count this)), (.meta this))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method without) [#_"PersistentTreeMap" this, #_"Object" key]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (.remove this, (:tree this), key, found)]
            (if (nil? t)
                (if (nil? (:val found)) ;; nil == doesn't contain key
                    this
                    (PersistentTreeMap'new-2 (.meta this), (:comp this)) ;; empty
                )
                (PersistentTreeMap'new-4c (:comp this), (.blacken t), (dec (:_count this)), (.meta this))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeMap" this]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), true, (:_count this))
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentTreeMap" this]
        (PersistentTreeMap'new-2 (.meta this), (:comp this))
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"PersistentTreeMap" this]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), false, (:_count this))
        )
    )

    #_method
    (§ defn #_"Comparator" (§ method comparator) [#_"PersistentTreeMap" this]
        (:comp this)
    )

    #_method
    (§ defn #_"Object" (§ method entryKey) [#_"PersistentTreeMap" this, #_"Object" entry]
        (.key (cast' IMapEntry entry))
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeMap" this, #_"boolean" ascending]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), ascending, (:_count this))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seqFrom) [#_"PersistentTreeMap" this, #_"Object" key, #_"boolean" ascending]
        (when (pos? (:_count this))
            (loop-when [#_"ISeq" s nil #_"TNode" t (:tree this)] (some? t) => (when (some? s) (TSeq'new-2 s, ascending))
                (let [#_"int" cmp (.doCompare this, key, (:key t))]
                    (cond
                        (zero? cmp) (TSeq'new-2 (RT'cons t, s), ascending)
                        ascending   (if (neg? cmp) (recur (RT'cons t, s) (.left t)) (recur s (.right t)))
                        :else       (if (pos? cmp) (recur (RT'cons t, s) (.right t)) (recur s (.left t)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"NodeIterator" (§ method iterator) [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), true)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentTreeMap" this, #_"IFn" f, #_"Object" r]
        (let [r (if (some? (:tree this)) (.kvreduce (:tree this), f, r) r)]
            (if (RT'isReduced r) (.deref (cast' IDeref r)) r)
        )
    )

    #_method
    (§ defn #_"NodeIterator" (§ method reverseIterator) [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), false)
    )

    #_method
    (§ defn #_"Iterator" (§ method keys) [#_"PersistentTreeMap" this]
        (.keys this, (.iterator this))
    )

    #_method
    (§ defn #_"Iterator" (§ method vals) [#_"PersistentTreeMap" this]
        (.vals this, (.iterator this))
    )

    #_method
    (§ defn #_"Iterator" (§ method keys) [#_"PersistentTreeMap" this, #_"NodeIterator" it]
        (KeyIterator'new it)
    )

    #_method
    (§ defn #_"Iterator" (§ method vals) [#_"PersistentTreeMap" this, #_"NodeIterator" it]
        (ValIterator'new it)
    )

    #_method
    (§ defn #_"Object" (§ method minKey) [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (.min this)]
            (when (some? t) (:key t))
        )
    )

    #_method
    (§ defn #_"TNode" (§ method min) [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (:tree this)]
            (when (some? t)
                (while (some? (.left t))
                    (§ ass t (.left t))
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"Object" (§ method maxKey) [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (.max this)]
            (when (some? t) (:key t))
        )
    )

    #_method
    (§ defn #_"TNode" (§ method max) [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (:tree this)]
            (when (some? t)
                (while (some? (.right t))
                    (§ ass t (.right t))
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" (§ method depth) [#_"PersistentTreeMap" this]
        (.depth this, (:tree this))
    )

    #_method
    (§ defn #_"int" (§ method depth) [#_"PersistentTreeMap" this, #_"TNode" t]
        (when (some? t) => 0
            (inc (Math/max (.depth this, (.left t)), (.depth this, (.right t))))
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"TNode" n (.entryAt this, key)]
            (if (some? n) (.val n) notFound)
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentTreeMap" this, #_"Object" key]
        (.valAt this, key, nil)
    )

    #_method
    (§ defn #_"int" (§ method capacity) [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"TNode" (§ method entryAt) [#_"PersistentTreeMap" this, #_"Object" key]
        (loop-when [#_"TNode" t (:tree this)] (some? t) => t
            (let [#_"int" cmp (.doCompare this, key, (:key t))]
                (cond
                    (neg? cmp) (recur (.left t))
                    (pos? cmp) (recur (.right t))
                    :else      t
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method doCompare) [#_"PersistentTreeMap" this, #_"Object" k1, #_"Object" k2]
        (.compare (:comp this), k1, k2)
    )

    #_method
    (§ defn #_"TNode" (§ method add) [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Object" val, #_"Box" found]
        (if (nil? t)
            (if (nil? val)
                (Red'new key)
                (RedVal'new key, val)
            )
            (let [#_"int" cmp (.doCompare this, key, (:key t))]
                (if (zero? cmp)
                    (do
                        (§ ass (:val found) t)
                        nil
                    )
                    (let [#_"TNode" ins (if (neg? cmp) (.add this, (.left t), key, val, found) (.add this, (.right t), key, val, found))]
                        (cond
                            (nil? ins) nil ;; found below
                            (neg? cmp) (.addLeft t, ins)
                            :else      (.addRight t, ins)
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method remove) [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Box" found]
        (when (some? t) => nil ;; not found indicator
            (let [#_"int" cmp (.doCompare this, key, (:key t))]
                (if (zero? cmp)
                    (do
                        (§ ass (:val found) t)
                        (PersistentTreeMap'append (.left t), (.right t))
                    )
                    (let [#_"TNode" del (if (neg? cmp) (.remove this, (.left t), key, found) (.remove this, (.right t), key, found))]
                        (when (or (some? del) (some? (:val found))) => nil ;; not found below
                            (if (neg? cmp)
                                (if (§ instance? Black (.left t))
                                    (PersistentTreeMap'balanceLeftDel (:key t), (.val t), del, (.right t))
                                    (PersistentTreeMap'red (:key t), (.val t), del, (.right t))
                                )
                                (if (§ instance? Black (.right t))
                                    (PersistentTreeMap'balanceRightDel (:key t), (.val t), (.left t), del)
                                    (PersistentTreeMap'red (:key t), (.val t), (.left t), del)
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'append [#_"TNode" left, #_"TNode" right]
        (cond
            (nil? left)
                right
            (nil? right)
                left
            (§ instance? Red left)
                (if (§ instance? Red right)
                    (let [#_"TNode" app (PersistentTreeMap'append (.right left), (.left right))]
                        (if (§ instance? Red app)
                            (PersistentTreeMap'red (:key app), (.val app), (PersistentTreeMap'red (:key left), (.val left), (.left left), (.left app)), (PersistentTreeMap'red (:key right), (.val right), (.right app), (.right right)))
                            (PersistentTreeMap'red (:key left), (.val left), (.left left), (PersistentTreeMap'red (:key right), (.val right), app, (.right right)))
                        )
                    )
                    (PersistentTreeMap'red (:key left), (.val left), (.left left), (PersistentTreeMap'append (.right left), right))
                )
            (§ instance? Red right)
                (PersistentTreeMap'red (:key right), (.val right), (PersistentTreeMap'append left, (.left right)), (.right right))
            :else ;; black/black
                (let [#_"TNode" app (PersistentTreeMap'append (.right left), (.left right))]
                    (if (§ instance? Red app)
                        (PersistentTreeMap'red (:key app), (.val app), (PersistentTreeMap'black (:key left), (.val left), (.left left), (.left app)), (PersistentTreeMap'black (:key right), (.val right), (.right app), (.right right)))
                        (PersistentTreeMap'balanceLeftDel (:key left), (.val left), (.left left), (PersistentTreeMap'black (:key right), (.val right), app, (.right right)))
                    )
                )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" key, #_"Object" val, #_"TNode" del, #_"TNode" right]
        (cond
            (§ instance? Red del)
                (PersistentTreeMap'red key, val, (.blacken del), right)
            (§ instance? Black right)
                (PersistentTreeMap'rightBalance key, val, del, (.redden right))
            (and (§ instance? Red right) (§ instance? Black (.left right)))
                (PersistentTreeMap'red (:key (.left right)), (.val (.left right)), (PersistentTreeMap'black key, val, del, (.left (.left right))), (PersistentTreeMap'rightBalance (:key right), (.val right), (.right (.left right)), (.redden (.right right))))
            :else
                (throw (UnsupportedOperationException. "Invariant violation"))
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" del]
        (cond
            (§ instance? Red del)
                (PersistentTreeMap'red key, val, left, (.blacken del))
            (§ instance? Black left)
                (PersistentTreeMap'leftBalance key, val, (.redden left), del)
            (and (§ instance? Red left) (§ instance? Black (.right left)))
                (PersistentTreeMap'red (:key (.right left)), (.val (.right left)), (PersistentTreeMap'leftBalance (:key left), (.val left), (.redden (.left left)), (.left (.right left))), (PersistentTreeMap'black key, val, (.right (.right left)), del))
            :else
                (throw (UnsupportedOperationException. "Invariant violation"))
        )
    )

    (defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" key, #_"Object" val, #_"TNode" ins, #_"TNode" right]
        (cond
            (and (§ instance? Red ins) (§ instance? Red (.left ins)))
                (PersistentTreeMap'red (:key ins), (.val ins), (.blacken (.left ins)), (PersistentTreeMap'black key, val, (.right ins), right))
            (and (§ instance? Red ins) (§ instance? Red (.right ins)))
                (PersistentTreeMap'red (:key (.right ins)), (.val (.right ins)), (PersistentTreeMap'black (:key ins), (.val ins), (.left ins), (.left (.right ins))), (PersistentTreeMap'black key, val, (.right (.right ins)), right))
            :else
                (PersistentTreeMap'black key, val, ins, right)
        )
    )

    (defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" ins]
        (cond
            (and (§ instance? Red ins) (§ instance? Red (.right ins)))
                (PersistentTreeMap'red (:key ins), (.val ins), (PersistentTreeMap'black key, val, left, (.left ins)), (.blacken (.right ins)))
            (and (§ instance? Red ins) (§ instance? Red (.left ins)))
                (PersistentTreeMap'red (:key (.left ins)), (.val (.left ins)), (PersistentTreeMap'black key, val, left, (.left (.left ins))), (PersistentTreeMap'black (:key ins), (.val ins), (.right (.left ins)), (.right ins)))
            :else
                (PersistentTreeMap'black key, val, left, ins)
        )
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Object" val]
        (let [#_"int" cmp (.doCompare this, key, (:key t))]
            (.replace t, (:key t), (if (zero? cmp) val (.val t)), (if (neg? cmp) (.replace this, (.left t), key, val) (.left t)), (if (pos? cmp) (.replace this, (.right t), key, val) (.right t)))
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4c [#_"Comparator" comp, #_"TNode" tree, #_"int" count, #_"IPersistentMap" meta]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :comp comp))
            (§ ass this (assoc this :tree tree))
            (§ ass this (assoc this :_count count))
            this
        )
    )

    (defn #_"Red" PersistentTreeMap'red [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (if (and (nil? left) (nil? right))
            (if (nil? val)
                (Red'new key)
                (RedVal'new key, val)
            )
            (if (nil? val)
                (RedBranch'new key, left, right)
                (RedBranchVal'new key, val, left, right)
            )
        )
    )

    (defn #_"Black" PersistentTreeMap'black [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (if (and (nil? left) (nil? right))
            (if (nil? val)
                (Black'new key)
                (BlackVal'new key, val)
            )
            (if (nil? val)
                (BlackBranch'new key, left, right)
                (BlackBranchVal'new key, val, left, right)
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentTreeMap" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (PersistentTreeSet'new nil, PersistentTreeMap'EMPTY))

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-1 [#_"ISeq" s]
        (loop-when-recur [#_"PersistentTreeSet" t PersistentTreeSet'EMPTY s s]
                         (some? s)
                         [(cast' PersistentTreeSet (.cons t, (.first s))) (.next s)]
                      => t
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-2 [#_"Comparator" comp, #_"ISeq" s]
        (loop-when-recur [#_"PersistentTreeSet" t (PersistentTreeSet'new nil, (PersistentTreeMap'new-2 nil, comp)) s s]
                         (some? s)
                         [(cast' PersistentTreeSet (.cons t, (.first s))) (.next s)]
                      => t
        )
    )

    (defn- #_"PersistentTreeSet" PersistentTreeSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'new [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (merge (APersistentSet'new impl) (PersistentTreeSet'init))]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (.equals (§ super ), obj)
            (catch ClassCastException _
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (.equiv (§ super ), obj)
            (catch ClassCastException _
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method disjoin) [#_"PersistentTreeSet" this, #_"Object" key]
        (if (.contains this, key)
            (PersistentTreeSet'new (.meta this), (.without (:impl this), key))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method cons) [#_"PersistentTreeSet" this, #_"Object" o]
        (if (.contains this, o)
            this
            (PersistentTreeSet'new (.meta this), (.assoc (:impl this), o, o))
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentTreeSet" this]
        (PersistentTreeSet'new (.meta this), (cast' PersistentTreeMap (.empty (:impl this))))
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"PersistentTreeSet" this]
        (KeySeq'create (.rseq (cast' Reversible (:impl this))))
    )

    #_method
    (§ defn #_"PersistentTreeSet" (§ method withMeta) [#_"PersistentTreeSet" this, #_"IPersistentMap" meta]
        (PersistentTreeSet'new meta, (:impl this))
    )

    #_method
    (§ defn #_"Comparator" (§ method comparator) [#_"PersistentTreeSet" this]
        (.comparator (cast' Sorted (:impl this)))
    )

    #_method
    (§ defn #_"Object" (§ method entryKey) [#_"PersistentTreeSet" this, #_"Object" entry]
        entry
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeSet" this, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (cast' PersistentTreeMap (:impl this))]
            (RT'keys (.seq m, ascending))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seqFrom) [#_"PersistentTreeSet" this, #_"Object" key, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (cast' PersistentTreeMap (:impl this))]
            (RT'keys (.seqFrom m, key, ascending))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentTreeSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns VNode
    (defn- #_"VNode" VNode'init []
        (hash-map
            #_transient
            #_"AtomicReference<Thread>" :edit nil
            #_"Object[]" :array nil
        )
    )

    (defn #_"VNode" VNode'new-2 [#_"AtomicReference<Thread>" edit, #_"Object[]" array]
        (let [this (VNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :array array))
            this
        )
    )

    (defn #_"VNode" VNode'new-1 [#_"AtomicReference<Thread>" edit]
        (let [this (VNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :array (make-array Object 32)))
            this
        )
    )
)

(class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
    (defn- #_"ChunkedSeq" ChunkedSeq'init []
        (hash-map
            #_"PersistentVector" :vec nil
            #_"Object[]" :node nil
            #_"int" :i 0
            #_"int" :offset 0
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-3 [#_"PersistentVector" vec, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass this (assoc this :vec vec))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :offset offset))
            (§ ass this (assoc this :node (.arrayFor vec, i)))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-5 [#_"IPersistentMap" meta, #_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new meta) (ChunkedSeq'init))]
            (§ ass this (assoc this :vec vec))
            (§ ass this (assoc this :node node))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :offset offset))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-4 [#_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass this (assoc this :vec vec))
            (§ ass this (assoc this :node node))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :offset offset))
            this
        )
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"ChunkedSeq" this]
        (ArrayChunk'new-2 (:node this), (:offset this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"ChunkedSeq" this]
        (when (< (+ (:i this) (alength (:node this))) (:cnt (:vec this)))
            (ChunkedSeq'new-3 (:vec this), (+ (:i this) (alength (:node this))), 0)
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"ChunkedSeq" this]
        (or (.chunkedNext this) PersistentList'EMPTY)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"ChunkedSeq" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (ChunkedSeq'new-5 meta, (:vec this), (:node this), (:i this), (:offset this))
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"ChunkedSeq" this]
        (aget (:node this) (:offset this))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"ChunkedSeq" this]
        (if (< (inc (:offset this)) (alength (:node this)))
            (ChunkedSeq'new-4 (:vec this), (:node this), (:i this), (inc (:offset this)))
            (.chunkedNext this)
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"ChunkedSeq" this]
        (- (:cnt (:vec this)) (+ (:i this) (:offset this)))
    )
)

(class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
    (defn- #_"TransientVector" TransientVector'init []
        (hash-map
            #_volatile
            #_"int" :cnt 0
            #_volatile
            #_"int" :shift 0
            #_volatile
            #_"VNode" :root nil
            #_volatile
            #_"Object[]" :tail nil
        )
    )

    (defn #_"TransientVector" TransientVector'new-4 [#_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (AFn'new) (TransientVector'init))]
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :tail tail))
            this
        )
    )

    (defn #_"TransientVector" TransientVector'new-1 [#_"PersistentVector" v]
        (TransientVector'new-4 (:cnt v), (:shift v), (.editableRoot (:root v)), (.editableTail (:tail v)))
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"TransientVector" this]
        (.ensureEditable this)
        (:cnt this)
    )

    #_method
    (§ defn #_"VNode" (§ method ensureEditable) [#_"TransientVector" this, #_"VNode" node]
        (if (= (:edit node) (:edit (:root this)))
            node
            (VNode'new-2 (:edit (:root this)), (.clone (:array node)))
        )
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientVector" this]
        (when (nil? (.get (:edit (:root this))))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (defn #_"VNode" TransientVector'editableRoot [#_"VNode" node]
        (VNode'new-2 (AtomicReference. (Thread/currentThread)), (.clone (:array node)))
    )

    #_method
    (§ defn #_"PersistentVector" (§ method persistent) [#_"TransientVector" this]
        (.ensureEditable this)
        (.set (:edit (:root this)), nil)
        (let [#_"Object[]" trimmedTail (make-array Object (- (:cnt this) (.tailoff this)))]
            (System/arraycopy (:tail this), 0, trimmedTail, 0, (alength trimmedTail))
            (PersistentVector'new-4 (:cnt this), (:shift this), (:root this), trimmedTail)
        )
    )

    (defn #_"Object[]" TransientVector'editableTail [#_"Object[]" tl]
        (let [#_"Object[]" ret (make-array Object 32)]
            (System/arraycopy tl, 0, ret, 0, (alength tl))
            ret
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method conj) [#_"TransientVector" this, #_"Object" val]
        (.ensureEditable this)
        (let [#_"int" n (:cnt this)]
            (if (< (- n (.tailoff this)) 32) ;; room in tail?
                (do
                    (aset (:tail this) (& n 0x01f) val)
                    (§ ass this (assoc this :cnt (inc (:cnt this))))
                    this
                )
                ;; full tail, push into tree
                (let [#_"VNode" tailnode (VNode'new-2 (:edit (:root this)), (:tail this))]
                    (§ ass this (assoc this :tail (make-array Object 32)))
                    (aset (:tail this) 0 val)
                    (let [#_"int" shift (:shift this)
                          [#_"VNode" root shift]
                            (if (< (<< 1 shift) (>>> n 5)) ;; overflow root?
                                (let [root (VNode'new-1 (:edit (:root this)))]
                                    (aset (:array root) 0 (:root this))
                                    (aset (:array root) 1 (PersistentVector'newPath (:edit (:root this)), shift, tailnode))
                                    [root (+ shift 5)]
                                )
                                [(.pushTail this, shift, (:root this), tailnode) shift]
                            )]
                        (§ ass this (assoc this :root root))
                        (§ ass this (assoc this :shift shift))
                        (§ ass this (assoc this :cnt (inc (:cnt this))))
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method pushTail) [#_"TransientVector" this, #_"int" level, #_"VNode" parent, #_"VNode" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (let [parent (.ensureEditable this, parent)
              #_"int" i (& (>>> (dec (:cnt this)) level) 0x01f)
              #_"VNode" nodeToInsert
                (when-not (= level 5) => tailnode
                    (let [#_"VNode" child (cast' VNode (aget (:array parent) i))]
                        (if (some? child)
                            (.pushTail this, (- level 5), child, tailnode)
                            (PersistentVector'newPath (:edit (:root this)), (- level 5), tailnode)
                        )
                    )
                )]
            (aset (:array parent) i nodeToInsert)
            parent
        )
    )

    #_method
    (§ defn- #_"int" (§ method tailoff) [#_"TransientVector" this]
        (if (< (:cnt this) 32) 0 (<< (>>> (dec (:cnt this)) 5) 5))
    )

    #_method
    (§ defn- #_"Object[]" (§ method arrayFor) [#_"TransientVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (.tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(cast' VNode (aget (:array node) (& (>>> i level) 0x01f))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object[]" (§ method editableArrayFor) [#_"TransientVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (.tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(.ensureEditable this, (cast' VNode (aget (:array node) (& (>>> i level) 0x01f)))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TransientVector" this, #_"Object" key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (.valAt this, key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TransientVector" this, #_"Object" key, #_"Object" notFound]
        (.ensureEditable this)
        (when (Util'isInteger key) => notFound
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (:cnt this)) => notFound
                (.nth this, i)
            )
        )
    )

    (def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"TransientVector" this, #_"Object" key]
        (not= (.valAt this, key, TransientVector'NOT_FOUND) TransientVector'NOT_FOUND)
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"TransientVector" this, #_"Object" key]
        (let [#_"Object" v (.valAt this, key, TransientVector'NOT_FOUND)]
            (when-not (= v TransientVector'NOT_FOUND)
                (MapEntry'create key, v)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"TransientVector" this, #_"Object" arg1]
        ;; note - relies on ensureEditable in nth
        (when (Util'isInteger arg1) => (throw (IllegalArgumentException. "Key must be integer"))
            (.nth this, (.intValue (cast Number arg1)))
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"TransientVector" this, #_"int" i]
        (.ensureEditable this)
        (let [#_"Object[]" node (.arrayFor this, i)]
            (aget node (& i 0x01f))
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"TransientVector" this, #_"int" i, #_"Object" notFound]
        (when (< -1 i (.count this)) => notFound
            (.nth this, i)
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method assocN) [#_"TransientVector" this, #_"int" i, #_"Object" val]
        (.ensureEditable this)
        (if (< -1 i (:cnt this))
            (if (<= (.tailoff this) i)
                (do
                    (aset (:tail this) (& i 0x01f) val)
                    this
                )
                (do
                    (§ ass this (assoc this :root (.doAssoc this, (:shift this), (:root this), i, val)))
                    this
                )
            )
            (when (= i (:cnt this)) => (throw (IndexOutOfBoundsException.))
                (.conj this, val)
            )
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method assoc) [#_"TransientVector" this, #_"Object" key, #_"Object" val]
        ;; note - relies on ensureEditable in assocN
        (when (Util'isInteger key) => (throw (IllegalArgumentException. "Key must be integer"))
            (.assocN this, (.intValue (cast Number key)), val)
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method doAssoc) [#_"TransientVector" this, #_"int" level, #_"VNode" node, #_"int" i, #_"Object" val]
        (let [node (.ensureEditable this, node)]
            (if (zero? level)
                (aset (:array node) (& i 0x01f) val)
                (let [#_"int" si (& (>>> i level) 0x01f)]
                    (aset (:array node) si (.doAssoc this, (- level 5), (cast' VNode (aget (:array node) si)), i, val))
                )
            )
            node
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method pop) [#_"TransientVector" this]
        (.ensureEditable this)
        (let [#_"int" n (:cnt this)]
            (when-not (zero? n) => (throw (IllegalStateException. "Can't pop empty vector"))
                (when (and (not= n 1) (zero? (& (dec n) 0x01f))) => (assoc this :cnt (dec n))
                    (let [#_"Object[]" tail (.editableArrayFor this, (- n 2))
                          #_"int" shift (:shift this) #_"VNode" root (:root this)
                          root (or (.popTail this, shift, root) (VNode'new-1 (:edit root)))
                          [shift root]
                            (when (and (< 5 shift) (nil? (aget (:array root) 1))) => [shift root]
                                [(- shift 5) (.ensureEditable this, (cast' VNode (aget (:array root) 0)))]
                            )]
                        (assoc this :cnt (dec n), :shift shift, :root root, :tail tail)
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method popTail) [#_"TransientVector" this, #_"int" level, #_"VNode" node]
        (let [node (.ensureEditable this, node)
              #_"int" i (& (>>> (- (:cnt this) 2) level) 0x01f)]
            (cond
                (< 5 level)
                    (let [#_"VNode" child (.popTail this, (- level 5), (cast' VNode (aget (:array node) i)))]
                        (when-not (and (nil? child) (zero? i))
                            (aset (:array node) i child)
                            node
                        )
                    )
                (pos? i)
                    (do
                        (aset (:array node) i nil)
                        node
                    )
            )
        )
    )
)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (AtomicReference. nil))
    (def #_"VNode" PersistentVector'EMPTY_NODE (VNode'new-2 PersistentVector'NOEDIT, (object-array 32)))

    (§ def #_"PersistentVector" PersistentVector'EMPTY (PersistentVector'new-4 0, 5, PersistentVector'EMPTY_NODE, (object-array 0)))

    (def- #_"IFn" PersistentVector'TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" coll, #_"Object" val]
                (.conj (cast' ITransientVector coll), val)
            )
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" coll]
                coll
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" items]
        (PersistentVector'new-4 (alength items), 5, PersistentVector'EMPTY_NODE, items)
    )

    (defn #_"PersistentVector" PersistentVector'create-1r [#_"IReduceInit" items]
        (let [#_"TransientVector" ret (.asTransient PersistentVector'EMPTY)]
            (.reduce items, PersistentVector'TRANSIENT_VECTOR_CONJ, ret)
            (.persistent ret)
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1s [#_"ISeq" items]
        (let [#_"Object[]" a (make-array Object 32)
              #_"int" i
                (loop-when-recur [items items i 0] (and (some? items) (< i 32)) [(.next items) (inc i)] => i
                    (aset a i (.first items))
                )]
            (cond
                (some? items) ;; >32, construct with array directly
                    (let [#_"PersistentVector" v0 (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, a)]
                        (loop-when-recur [#_"TransientVector" v (.asTransient v0) items items]
                                         (some? items)
                                         [(.conj v, (.first items)) (.next items)]
                                      => (.persistent v)
                        )
                    )
                (= i 32) ;; exactly 32, skip copy
                    (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, a)
                :else ;; <32, copy to minimum array and construct
                    (let [#_"Object[]" b (make-array Object i)]
                        (System/arraycopy a, 0, b, 0, i)
                        (PersistentVector'new-4 i, 5, PersistentVector'EMPTY_NODE, b)
                    )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1l [#_"List" items]
        (let-when [#_"int" n (.size items)] (< 32 n) => (PersistentVector'new-4 n, 5, PersistentVector'EMPTY_NODE, (.toArray items))
            (loop-when-recur [#_"TransientVector" v (.asTransient PersistentVector'EMPTY) #_"int" i 0]
                             (< i n)
                             [(.conj v, (.get items, i)) (inc i)]
                          => (.persistent v)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1i [#_"Iterable" items]
        (when-not (instance? ArrayList items) => (PersistentVector'create-1l (cast ArrayList items)) ;; optimize common case
            (let [#_"Iterator" it (.iterator items)]
                (loop-when-recur [#_"TransientVector" v (.asTransient PersistentVector'EMPTY)]
                                 (.hasNext it)
                                 [(.conj v, (.next it))]
                              => (.persistent v)
                )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1a [& #_"Object..." items]
        (let [#_"TransientVector" v (.asTransient PersistentVector'EMPTY)]
            (doseq [#_"Object" item items]
                (§ ass v (.conj v, item))
            )
            (.persistent v)
        )
    )

    (defn- #_"PersistentVector" PersistentVector'init []
        (hash-map
            #_"int" :cnt 0
            #_"int" :shift 0
            #_"VNode" :root nil
            #_"Object[]" :tail nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-4 [#_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass this (assoc this :_meta nil))
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :tail tail))
            this
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-5 [#_"IPersistentMap" meta, #_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :tail tail))
            this
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method asTransient) [#_"PersistentVector" this]
        (TransientVector'new-1 this)
    )

    #_method
    (§ defn #_"int" (§ method tailoff) [#_"PersistentVector" this]
        (if (< (:cnt this) 32) 0 (<< (>>> (dec (:cnt this)) 5) 5))
    )

    #_method
    (§ defn #_"Object[]" (§ method arrayFor) [#_"PersistentVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (.tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(cast' VNode (aget (:array node) (& (>>> i level) 0x01f))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"PersistentVector" this, #_"int" i]
        (aget (.arrayFor this, i) (& i 0x01f))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"PersistentVector" this, #_"int" i, #_"Object" notFound]
        (when (< -1 i (:cnt this)) => notFound
            (.nth this, i)
        )
    )

    #_method
    (§ defn #_"PersistentVector" (§ method assocN) [#_"PersistentVector" this, #_"int" i, #_"Object" val]
        (if (< -1 i (:cnt this))
            (if (<= (.tailoff this) i)
                (let [#_"Object[]" tail (make-array Object (alength (:tail this)))]
                    (System/arraycopy (:tail this), 0, tail, 0, (alength (:tail this)))
                    (aset tail (& i 0x01f) val)
                    (PersistentVector'new-5 (.meta this), (:cnt this), (:shift this), (:root this), tail)
                )
                (PersistentVector'new-5 (.meta this), (:cnt this), (:shift this), (PersistentVector'doAssoc (:shift this), (:root this), i, val), (:tail this))
            )
            (when (= i (:cnt this)) => (throw (IndexOutOfBoundsException.))
                (.cons this, val)
            )
        )
    )

    (defn- #_"VNode" PersistentVector'doAssoc [#_"int" level, #_"VNode" node, #_"int" i, #_"Object" val]
        (let [#_"VNode" ret (VNode'new-2 (:edit node), (.clone (:array node)))]
            (if (zero? level)
                (aset (:array ret) (& i 0x01f) val)
                (let [#_"int" si (& (>>> i level) 0x01f)]
                    (aset (:array ret) si (PersistentVector'doAssoc (- level 5), (cast' VNode (aget (:array node) si)), i, val))
                )
            )
            ret
        )
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"PersistentVector" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method withMeta) [#_"PersistentVector" this, #_"IPersistentMap" meta]
        (PersistentVector'new-5 meta, (:cnt this), (:shift this), (:root this), (:tail this))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentVector" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method cons) [#_"PersistentVector" this, #_"Object" val]
        (let [#_"int" n (:cnt this)]
            (if (< (- n (.tailoff this)) 32) ;; room in tail?
                (let [#_"int" e (alength (:tail this))  #_"Object[]" tail (make-array Object (inc e))]
                    (System/arraycopy (:tail this), 0, tail, 0, e)
                    (aset tail e val)
                    (PersistentVector'new-5 (.meta this), (inc n), (:shift this), (:root this), tail)
                )
                ;; full tail, push into tree
                (let [#_"VNode" tailnode (VNode'new-2 (:edit (:root this)), (:tail this))
                      #_"int" shift (:shift this)
                      [#_"VNode" root shift]
                        (if (< (<< 1 shift) (>>> n 5)) ;; overflow root?
                            (let [root (VNode'new-1 (:edit (:root this)))]
                                (aset (:array root) 0 (:root this))
                                (aset (:array root) 1 (PersistentVector'newPath (:edit (:root this)), shift, tailnode))
                                [root (+ shift 5)]
                            )
                            [(.pushTail this, shift, (:root this), tailnode) shift]
                        )]
                    (PersistentVector'new-5 (.meta this), (inc n), shift, root, (object-array [ val ]))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method pushTail) [#_"PersistentVector" this, #_"int" level, #_"VNode" parent, #_"VNode" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" i (& (>>> (dec (:cnt this)) level) 0x01f)
              #_"VNode" ret (VNode'new-2 (:edit parent), (.clone (:array parent)))
              #_"VNode" nodeToInsert
                (when-not (= level 5) => tailnode
                    (let [#_"VNode" child (cast' VNode (aget (:array parent) i))]
                        (if (some? child)
                            (.pushTail this, (- level 5), child, tailnode)
                            (PersistentVector'newPath (:edit (:root this)), (- level 5), tailnode)
                        )
                    )
                )]
            (aset (:array ret) i nodeToInsert)
            ret
        )
    )

    (defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" edit, #_"int" level, #_"VNode" node]
        (when-not (zero? level) => node
            (let [#_"VNode" ret (VNode'new-1 edit)]
                (aset (:array ret) 0 (PersistentVector'newPath edit, (- level 5), node))
                ret
            )
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" (§ method chunkedSeq) [#_"PersistentVector" this]
        (when (pos? (.count this))
            (ChunkedSeq'new-3 this, 0, 0)
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentVector" this]
        (.chunkedSeq this)
    )

    #_override
    #_method
    (§ defn #_"Iterator" (§ method rangedIterator) [#_"PersistentVector" this, #_"int" start, #_"int" end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i start
                    #_"int" :base (- (:i this) (% (:i this) 32))
                    #_"Object[]" :array (when (< start (.count this)) (.arrayFor this, (:i this)))
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (< (:i this) end)
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (if (< (:i this) end)
                    (do
                        (when (= (- (:i this) (:base this)) 32)
                            (§ ass this (assoc this :array (.arrayFor this, (:i this))))
                            (§ ass this (assoc this :base (+ (:base this) 32)))
                        )
                        (let [_ (aget (:array this) (& (:i this) 0x01f))]
                            (§ ass this (assoc this :i (inc (:i this))))
                            _
                        )
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentVector" this]
        (.rangedIterator this, 0, (.count this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentVector" this, #_"IFn" f]
        (when (pos? (:cnt this)) => (.invoke f)
            (loop-when [#_"Object" r (aget (.arrayFor this, 0) 0) #_"int" i 0] (< i (:cnt this)) => r
                (let [#_"Object[]" a (.arrayFor this, i)
                      r (loop-when [r r #_"int" j (if (zero? i) 1 0)] (< j (alength a)) => r
                            (let [r (.invoke f, r, (aget a j))]
                                (when-not (RT'isReduced r) => (§ return (.deref (cast' IDeref r)))
                                    (recur r (inc j))
                                )
                            )
                        )]
                    (recur r (+ i (alength a)))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentVector" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (:cnt this)) => r
            (let [#_"Object[]" a (.arrayFor this, i)
                  r (loop-when [r r #_"int" j 0] (< j (alength a)) => r
                        (let [r (.invoke f, r, (aget a j))]
                            (when-not (RT'isReduced r) => (§ return (.deref (cast' IDeref r)))
                                (recur r (inc j))
                            )
                        )
                    )]
                (recur r (+ i (alength a)))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentVector" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (:cnt this)) => r
            (let [#_"Object[]" a (.arrayFor this, i)
                  r (loop-when [r r #_"int" j 0] (< j (alength a)) => r
                        (let [r (.invoke f, r, (+ j i), (aget a j))]
                            (when-not (RT'isReduced r) => (§ return (.deref (cast' IDeref r)))
                                (recur r (inc j))
                            )
                        )
                    )]
                (recur r (+ i (alength a)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentVector" this]
        (.withMeta PersistentVector'EMPTY, (.meta this))
    )

    #_method
    (§ defn #_"PersistentVector" (§ method pop) [#_"PersistentVector" this]
        (cond
            (zero? (:cnt this))
                (throw (IllegalStateException. "Can't pop empty vector"))
            (= (:cnt this) 1)
                (.withMeta PersistentVector'EMPTY, (.meta this))
            (< 1 (- (:cnt this) (.tailoff this)))
                (let [#_"Object[]" tail (make-array Object (dec (alength (:tail this))))]
                    (System/arraycopy (:tail this), 0, tail, 0, (alength tail))
                    (PersistentVector'new-5 (.meta this), (dec (:cnt this)), (:shift this), (:root this), tail)
                )
            :else
                (let [#_"Object[]" tail (.arrayFor this, (- (:cnt this) 2))
                      #_"int" shift (:shift this)
                      #_"VNode" root (or (.popTail this, shift, (:root this)) PersistentVector'EMPTY_NODE)
                      [shift root]
                        (when (and (< 5 shift) (nil? (aget (:array root) 1))) => [shift root]
                            [(- shift 5) (cast' VNode (aget (:array root) 0))]
                        )]
                    (PersistentVector'new-5 (.meta this), (dec (:cnt this)), shift, root, tail)
                )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method popTail) [#_"PersistentVector" this, #_"int" level, #_"VNode" node]
        (let [#_"int" i (& (>>> (- (:cnt this) 2) level) 0x01f)]
            (cond
                (< 5 level)
                    (let [#_"VNode" child (.popTail this, (- level 5), (cast' VNode (aget (:array node) i)))]
                        (when-not (and (nil? child) (zero? i))
                            (let [#_"VNode" ret (VNode'new-2 (:edit (:root this)), (.clone (:array node)))]
                                (aset (:array ret) i child)
                                ret
                            )
                        )
                    )
                (pos? i)
                    (let [#_"VNode" ret (VNode'new-2 (:edit (:root this)), (.clone (:array node)))]
                        (aset (:array ret) i nil)
                        ret
                    )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (defn- #_"ProxyHandler" ProxyHandler'init []
        (hash-map
            ;; method-name-string->fn
            #_"IPersistentMap" :fns nil
        )
    )

    (defn #_"ProxyHandler" ProxyHandler'new [#_"IPersistentMap" fns]
        (let [this (ProxyHandler'init)]
            (§ ass this (assoc this :fns fns))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ProxyHandler" this, #_"Object" proxy, #_"java.lang.reflect.Method" method, #_"Object[]" args] #_(§ throws Throwable)
        (let [#_"IFn" fn (cast' IFn (.valAt (:fns this), (.getName method))) #_"Class" rt (.getReturnType method)]
            (if (nil? fn)
                (cond
                    (= rt Void/TYPE)                 nil
                    (= (.getName method) "equals")   (= proxy (aget args 0))
                    (= (.getName method) "hashCode") (System/identityHashCode proxy)
                    (= (.getName method) "toString") (str "Proxy: " (System/identityHashCode proxy))
                    :else                            (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ret (.applyTo fn, (ArraySeq'create-1 args))]
                    (cond
                        (= rt Void/TYPE) nil
                        (.isPrimitive rt)
                            (cond
                                (= rt Character/TYPE) ret
                                (= rt Integer/TYPE)   (.intValue (cast Number ret))
                                (= rt Long/TYPE)      (.longValue (cast Number ret))
                                (= rt Float/TYPE)     (.floatValue (cast Number ret))
                                (= rt Double/TYPE)    (.doubleValue (cast Number ret))
                                (and (= rt Boolean/TYPE) (not (instance? Boolean ret))) (if (nil? ret) Boolean/FALSE Boolean/TRUE)
                                (= rt Byte/TYPE)      (byte (.intValue (cast Number ret)))
                                (= rt Short/TYPE)     (short (.intValue (cast Number ret)))
                                :else ret
                            )
                        :else ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

#_private
(§ defprotocol RangeBoundsCheck
    #_abstract
    (#_"boolean" RangeBoundsCheck'''(§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" val])
)

#_private
#_non-static
(class-ns RangeIterator (§ implements Iterator)
    (defn- #_"RangeIterator" RangeIterator'init []
        (hash-map
            #_"Object" :next nil
        )
    )

    (defn #_"RangeIterator" RangeIterator'new []
        (let [this (RangeIterator'init)]
            (§ ass this (assoc this :next (:start this)))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"RangeIterator" this]
        (not (.exceededBounds (:boundsCheck this), (:next this)))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"RangeIterator" this]
        (when (.hasNext this) => (throw (NoSuchElementException.))
            (let [#_"Object" ret (:next this)]
                (§ ass this (assoc this :next (Numbers'addP-2oo (:next this), (:step this))))
                ret
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"RangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (def- #_"int" Range'CHUNK_SIZE 32)

    (defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" val]
                (Numbers'gte-2oo val, end)
            )
        )
    )

    (defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" val]
                (Numbers'lte-2oo val, end)
            )
        )
    )

    (defn- #_"Range" Range'init []
        (hash-map
            ;; Invariants guarantee this is never an "empty" seq
            #_"Object" :end nil
            #_"Object" :start nil
            #_"Object" :step nil
            #_"RangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"IChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Range" Range'new-4 [#_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            this
        )
    )

    (defn- #_"Range" Range'new-6 [#_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn- #_"Range" Range'new-7 [#_"IPersistentMap" meta, #_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new meta) (Range'init))]
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn #_"ISeq" Range'create-1 [#_"Object" end]
        (if (Numbers'isPos-1o end)
            (Range'new-4 0, end, 1, (Range'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" Range'create-2 [#_"Object" start, #_"Object" end]
        (Range'create-3 start, end, 1)
    )

    (defn #_"ISeq" Range'create-3 [#_"Object" start, #_"Object" end, #_"Object" step]
        (cond
            (or (and (Numbers'isPos-1o step) (Numbers'gt-2oo start, end))
                (and (Numbers'isNeg-1o step) (Numbers'gt-2oo end, start))
                (Numbers'equiv-2oo start, end)
            )
                PersistentList'EMPTY
            (Numbers'isZero-1o step)
                (Repeat'create-1 start)
            :else
                (Range'new-4 start, end, step, (if (Numbers'isPos-1o step) (Range'positiveStep end) (Range'negativeStep end)))
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"Range" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (Range'new-7 meta, (:end this), (:start this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"Range" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" (§ method forceChunk) [#_"Range" this]
        (when (nil? (:_chunk this))
            (let [#_"Object[]" a (make-array Object Range'CHUNK_SIZE)]
                (loop [#_"Object" n (:start this) #_"int" i 0]
                    (if (< i Range'CHUNK_SIZE)
                        (do
                            (aset a i n)
                            (let-when [n (Numbers'addP-2oo n, (:step this))] (.exceededBounds (:boundsCheck this), n) => (recur n (inc i))
                                ;; partial last chunk
                                (§ ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, (inc i))))
                            )
                        )
                        (if (.exceededBounds (:boundsCheck this), n)
                            (do
                                ;; full last chunk
                                (§ ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, Range'CHUNK_SIZE)))
                            )
                            (do
                                ;; full intermediate chunk
                                (§ ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, Range'CHUNK_SIZE)))
                                (§ ass this (assoc this :_chunkNext (Range'new-4 n, (:end this), (:step this), (:boundsCheck this))))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"Range" this]
        (let-when [#_"Range" _next (:_next this)] (nil? _next) => _next
            (.forceChunk this)
            (when (< 1 (.count (:_chunk this))) => (.chunkedNext this)
                (let [#_"IChunk" _rest (.dropFirst (:_chunk this))
                      _next (Range'new-6 (.nth _rest, 0), (:end this), (:step this), (:boundsCheck this), _rest, (:_chunkNext this))]
                    (§ ass this (assoc this :_next _next))
                    _next
                )
            )
        )
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"Range" this]
        (.forceChunk this)
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"Range" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"Range" this]
        (.forceChunk this)
        (or (:_chunkNext this) PersistentList'EMPTY)
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Range" this, #_"IFn" f]
        (loop [#_"Object" r (:start this) #_"Number" n r]
            (let-when-not [n (Numbers'addP-2oo n, (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast' Reduced r))
                    (recur r n)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Range" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"Object" n (:start this)]
            (let-when-not [r (.invoke f, r, n)] (RT'isReduced r) => (.deref (cast' Reduced r))
                (let-when-not [n (Numbers'addP-2oo n, (:step this))] (.exceededBounds (:boundsCheck this), n) => r
                    (recur r n)
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"Range" this]
        (RangeIterator'new)
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (defn- #_"Ratio" Ratio'init []
        (hash-map
            #_"BigInteger" :numerator nil
            #_"BigInteger" :denominator nil
        )
    )

    (defn #_"Ratio" Ratio'new [#_"BigInteger" numerator, #_"BigInteger" denominator]
        (let [this (merge (Number'new) (Ratio'init))]
            (§ ass this (assoc this :numerator numerator))
            (§ ass this (assoc this :denominator denominator))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"Ratio" this, #_"Object" arg0]
        (and (some? arg0) (§ instance? Ratio arg0) (.equals (:numerator (cast' Ratio arg0)), (:numerator this)) (.equals (:denominator (cast' Ratio arg0)), (:denominator this)))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Ratio" this]
        (bit-xor (.hashCode (:numerator this)) (.hashCode (:denominator this)))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Ratio" this]
        (str (.toString (:numerator this)) "/" (.toString (:denominator this)))
    )

    #_method
    (§ defn #_"int" (§ method intValue) [#_"Ratio" this]
        (int (.doubleValue this))
    )

    #_method
    (§ defn #_"long" (§ method longValue) [#_"Ratio" this]
        (.longValue (.bigIntegerValue this))
    )

    #_method
    (§ defn #_"float" (§ method floatValue) [#_"Ratio" this]
        (float (.doubleValue this))
    )

    #_method
    (§ defn #_"double" (§ method doubleValue) [#_"Ratio" this]
        (.doubleValue (.decimalValue this, MathContext/DECIMAL64))
    )

    #_method
    (§ defn #_"BigDecimal" (§ method decimalValue) [#_"Ratio" this]
        (.decimalValue this, MathContext/UNLIMITED)
    )

    #_method
    (§ defn #_"BigDecimal" (§ method decimalValue) [#_"Ratio" this, #_"MathContext" mc]
        (let [#_"BigDecimal" numerator (§ unsure BigDecimal. (:numerator this))]
            (let [#_"BigDecimal" denominator (§ unsure BigDecimal. (:denominator this))]
                (.divide numerator, denominator, mc)
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" (§ method bigIntegerValue) [#_"Ratio" this]
        (.divide (:numerator this), (:denominator this))
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Ratio" this, #_"Object" o]
        (let [#_"Number" other (cast Number o)]
            (Numbers'compare this, other)
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (defn- #_"RecordIterator" RecordIterator'init []
        (hash-map
            #_"int" :i 0
            #_"int" :basecnt 0
            #_"ILookup" :rec nil
            #_"IPersistentVector" :basefields nil
            #_"Iterator" :extmap nil
        )
    )

    (defn #_"RecordIterator" RecordIterator'new [#_"ILookup" rec, #_"IPersistentVector" basefields, #_"Iterator" extmap]
        (let [this (RecordIterator'init)]
            (§ ass this (assoc this :rec rec))
            (§ ass this (assoc this :basefields basefields))
            (§ ass this (assoc this :basecnt (.count basefields)))
            (§ ass this (assoc this :extmap extmap))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                true
            )
            (do
                (.hasNext (:extmap this))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                (let [#_"Object" k (.nth (:basefields this), (:i this))]
                    (§ ass this (assoc this :i (inc (:i this))))
                    (MapEntry'create k, (.valAt (:rec this), k))
                )
            )
            (do
                (.next (:extmap this))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (defn- #_"Reduced" Reduced'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Reduced" Reduced'new [#_"Object" val]
        (let [this (Reduced'init)]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Reduced" this]
        (:val this)
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns RefTVal
    (defn- #_"RefTVal" RefTVal'init []
        (hash-map
            #_"Object" :val nil
            #_"long" :point 0
            #_"RefTVal" :prior nil
            #_"RefTVal" :next nil
        )
    )

    (defn #_"RefTVal" RefTVal'new-3 [#_"Object" val, #_"long" point, #_"RefTVal" prior]
        (let [this (RefTVal'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :point point))
            (§ ass this (assoc this :prior prior))
            (§ ass this (assoc this :next (:next prior)))
            (§ ass (:next (:prior this)) this)
            (§ ass (:prior (:next this)) this)
            this
        )
    )

    (defn #_"RefTVal" RefTVal'new-2 [#_"Object" val, #_"long" point]
        (let [this (RefTVal'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :point point))
            (§ ass this (assoc this :next this))
            (§ ass this (assoc this :prior this))
            this
        )
    )
)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (def #_"AtomicLong" Ref'ids (AtomicLong.))

    (defn- #_"Ref" Ref'init []
        (hash-map
            #_"RefTVal" :tvals nil
            #_"AtomicInteger" :faults nil
            #_"ReentrantReadWriteLock" :lock nil
            #_"LockingTransactionInfo" :tinfo nil
            #_"long" :id 0

            #_volatile
            #_"int" :minHistory 0
            #_volatile
            #_"int" :maxHistory 10
        )
    )

    (defn #_"Ref" Ref'new-1 [#_"Object" initVal]
        (Ref'new-2 initVal, nil)
    )

    (defn #_"Ref" Ref'new-2 [#_"Object" initVal, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Ref'init))]
            (§ ass this (assoc this :id (.getAndIncrement Ref'ids)))
            (§ ass this (assoc this :faults (AtomicInteger.)))
            (§ ass this (assoc this :lock (ReentrantReadWriteLock.)))
            (§ ass this (assoc this :tvals (RefTVal'new-2 initVal, 0)))
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Ref" this, #_"Ref" ref]
        (let [a (:id this) b (:id ref)]
            (cond (< a b) -1 (> a b) 1 :else 0)
        )
    )

    #_method
    (§ defn #_"int" (§ method getMinHistory) [#_"Ref" this]
        (:minHistory this)
    )

    #_method
    (§ defn #_"Ref" (§ method setMinHistory) [#_"Ref" this, #_"int" minHistory]
        (§ ass this (assoc this :minHistory minHistory))
        this
    )

    #_method
    (§ defn #_"int" (§ method getMaxHistory) [#_"Ref" this]
        (:maxHistory this)
    )

    #_method
    (§ defn #_"Ref" (§ method setMaxHistory) [#_"Ref" this, #_"int" maxHistory]
        (§ ass this (assoc this :maxHistory maxHistory))
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" (§ method currentVal) [#_"Ref" this]
        (try
            (.lock (.readLock (:lock this)))
            (when (some? (:tvals this)) => (throw (IllegalStateException. (str (.toString this) " is unbound.")))
                (:val (:tvals this))
            )
            (finally
                (.unlock (.readLock (:lock this)))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Ref" this]
        (let [#_"LockingTransaction" t (LockingTransaction'getRunning)]
            (if (some? t) (.doGet t, this) (.currentVal this))
        )
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"Ref" this, #_"Object" val]
        (.doSet (LockingTransaction'getEx), this, val)
    )

    #_method
    (§ defn #_"Object" (§ method commute) [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (.doCommute (LockingTransaction'getEx), this, fn, args)
    )

    #_method
    (§ defn #_"Object" (§ method alter) [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (let [#_"LockingTransaction" t (LockingTransaction'getEx)]
            (.doSet t, this, (.applyTo fn, (RT'cons (.doGet t, this), args)))
        )
    )

    #_method
    (§ defn #_"void" (§ method touch) [#_"Ref" this]
        (.doEnsure (LockingTransaction'getEx), this)
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isBound) [#_"Ref" this]
        (try
            (.lock (.readLock (:lock this)))
            (some? (:tvals this))
            (finally
                (.unlock (.readLock (:lock this)))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method trimHistory) [#_"Ref" this]
        (try
            (.lock (.writeLock (:lock this)))
            (when (some? (:tvals this))
                (§ ass (:next (:tvals this)) (:tvals this))
                (§ ass (:prior (:tvals this)) (:tvals this))
            )
            (finally
                (.unlock (.writeLock (:lock this)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getHistoryCount) [#_"Ref" this]
        (try
            (.lock (.writeLock (:lock this)))
            (.histCount this)
            (finally
                (.unlock (.writeLock (:lock this)))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method histCount) [#_"Ref" this]
        (if (nil? (:tvals this))
            (do
                0
            )
            (do
                (let [#_"int" count 0]
                    (loop-when-recur [#_"RefTVal" tv (:next (:tvals this))] (not= tv (:tvals this)) [(:next tv)]
                        (§ ass count (inc count))
                    )
                    count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fn) [#_"Ref" this]
        (cast' IFn (.deref this))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Ref" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Ref" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this]
        (.invoke (.fn this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1]
        (.invoke (.fn this), arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2]
        (.invoke (.fn this), arg1, arg2)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.invoke (.fn this), arg1, arg2, arg3)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.invoke (.fn this), arg1, arg2, arg3, arg4)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.invoke (.fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Ref" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" target, #_"String" methodName, #_"Object[]" args]
        (let [#_"List" methods (Reflector'getMethods (.getClass target), (alength args), methodName, false)]
            (Reflector'invokeMatchingMethod methodName, methods, target, args)
        )
    )

    (defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" e]
        (or (.getCause e) e)
    )

    (defn- #_"RuntimeException" Reflector'throwCauseOrElseException [#_"Exception" e]
        (throw (Util'sneakyThrow (or (.getCause e) e)))
    )

    (defn- #_"String" Reflector'noMethodReport [#_"String" methodName, #_"Object" target]
        (str "No matching method found: " methodName (when (some? target) (str " for " (.getClass target))))
    )

    (defn #_"Object" Reflector'invokeMatchingMethod [#_"String" methodName, #_"List" methods, #_"Object" target, #_"Object[]" args]
        (let [#_"java.lang.reflect.Method" m nil]
            (let [#_"Object[]" boxedArgs nil]
                (cond (.isEmpty methods)
                    (do
                        (throw (§ unsure IllegalArgumentException. (Reflector'noMethodReport methodName, target)))
                    )
                    (= (.size methods) 1)
                    (do
                        (§ ass m (cast java.lang.reflect.Method (.get methods, 0)))
                        (§ ass boxedArgs (Reflector'boxArgs (.getParameterTypes m), args))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"java.lang.reflect.Method" foundm nil]
                            (loop-when-recur [#_"Iterator" i (.iterator methods)] (.hasNext i) [i]
                                (§ ass m (cast java.lang.reflect.Method (.next i)))

                                (let [#_"Class[]" params (.getParameterTypes m)]
                                    (when (Reflector'isCongruent params, args)
                                        (when (or (nil? foundm) (Compiler'subsumes params, (.getParameterTypes foundm)))
                                            (§ ass foundm m)
                                            (§ ass boxedArgs (Reflector'boxArgs params, args))
                                        )
                                    )
                                )
                            )
                            (§ ass m foundm)
                        )
                    )
                )
                (when (nil? m)
                    (throw (§ unsure IllegalArgumentException. (Reflector'noMethodReport methodName, target)))
                )

                (when (not (Modifier/isPublic (.getModifiers (.getDeclaringClass m))))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"java.lang.reflect.Method" oldm m]
                        (§ ass m (Reflector'getAsMethodOfPublicBase (.getClass target), m))
                        (when (nil? m)
                            (throw (IllegalArgumentException. (str "Can't call public method of non-public class: " (.toString oldm))))
                        )
                    )
                )
                (try
                    (Reflector'prepRet (.getReturnType m), (.invoke m, target, boxedArgs))
                    (catch Exception e
                        (throw (Util'sneakyThrow (Reflector'getCauseOrElse e)))
                    )
                )
            )
        )
    )

    (defn #_"java.lang.reflect.Method" Reflector'getAsMethodOfPublicBase [#_"Class" c, #_"java.lang.reflect.Method" m]
        (doseq [#_"Class" iface (.getInterfaces c)]
            (doseq [#_"java.lang.reflect.Method" im (.getMethods iface)]
                (when (Reflector'isMatch im, m)
                    (§ return im)
                )
            )
        )
        (when-let [#_"Class" sc (.getSuperclass c)]
            (doseq [#_"java.lang.reflect.Method" scm (.getMethods sc)]
                (when (Reflector'isMatch scm, m)
                    (§ return scm)
                )
            )
            (Reflector'getAsMethodOfPublicBase sc, m)
        )
    )

    (defn #_"boolean" Reflector'isMatch [#_"java.lang.reflect.Method" lhs, #_"java.lang.reflect.Method" rhs]
        (and (.equals (.getName lhs), (.getName rhs)) (Modifier/isPublic (.getModifiers (.getDeclaringClass lhs)))
            (let [#_"Class[]" types1 (.getParameterTypes lhs) #_"Class[]" types2 (.getParameterTypes rhs)]
                (and (= (alength types1) (alength types2))
                    (loop-when [#_"int" i 0] (< i (alength types1)) => true
                        (and (.isAssignableFrom (aget types1 i), (aget types2 i))
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeConstructor [#_"Class" c, #_"Object[]" args]
        (try
            (let [#_"Constructor[]" allctors (.getConstructors c) #_"ArrayList" ctors (ArrayList.)]
                (dotimes [#_"int" i (alength allctors)]
                    (let-when [#_"Constructor" ctor (aget allctors i)] (= (alength (.getParameterTypes ctor)) (alength args))
                        (.add ctors, ctor)
                    )
                )
                (condp = (.size ctors)
                    0   (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    1   (let [#_"Constructor" ctor (cast Constructor (.get ctors, 0))]
                            (.newInstance ctor, (Reflector'boxArgs (.getParameterTypes ctor), args))
                        )
                    (or ;; overloaded w/same arity
                        (loop-when-recur [#_"Iterator" it (.iterator ctors)] (.hasNext it) [it]
                            (let [#_"Constructor" ctor (cast Constructor (.next it))]
                                (let-when [#_"Class[]" params (.getParameterTypes ctor)] (Reflector'isCongruent params, args)
                                    (.newInstance ctor, (Reflector'boxArgs params, args))
                                )
                            )
                        )
                        (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    )
                )
            )
            (catch Exception e
                (throw (Util'sneakyThrow (Reflector'getCauseOrElse e)))
            )
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" className, #_"String" methodName & #_"Object..." args]
        (Reflector'invokeStaticMethod-3s className, methodName, args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3s [#_"String" className, #_"String" methodName, #_"Object[]" args]
        (Reflector'invokeStaticMethod-3c (RT'classForName-1 className), methodName, args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3c [#_"Class" c, #_"String" methodName, #_"Object[]" args]
        (if (= methodName "new")
            (Reflector'invokeConstructor c, args)
            (let [#_"List" methods (Reflector'getMethods c, (alength args), methodName, true)]
                (Reflector'invokeMatchingMethod methodName, methods, nil, args)
            )
        )
    )

    (defn #_"Object" Reflector'getStaticField-2s [#_"String" className, #_"String" fieldName]
        (let [#_"Class" c (RT'classForName-1 className)]
            (Reflector'getStaticField-2c c, fieldName)
        )
    )

    (defn #_"Object" Reflector'getStaticField-2c [#_"Class" c, #_"String" fieldName]
        (let [#_"Field" f (Reflector'getField c, fieldName, true)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (try
                    (Reflector'prepRet (.getType f), (.get f, nil))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'setStaticField-3s [#_"String" className, #_"String" fieldName, #_"Object" val]
        (Reflector'setStaticField-3c (RT'classForName-1 className), fieldName, val)
    )

    (defn #_"Object" Reflector'setStaticField-3c [#_"Class" c, #_"String" fieldName, #_"Object" val]
        (let [#_"Field" f (Reflector'getField c, fieldName, true)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (try
                    (.set f, nil, (Reflector'boxArg (.getType f), val))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                val
            )
        )
    )

    (defn #_"Object" Reflector'getInstanceField [#_"Object" target, #_"String" fieldName]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, fieldName, false)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (try
                    (Reflector'prepRet (.getType f), (.get f, target))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'setInstanceField [#_"Object" target, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, fieldName, false)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " (.getClass target))))
                (try
                    (.set f, target, (Reflector'boxArg (.getType f), val))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                val
            )
        )
    )

    (defn #_"Object" Reflector'invokeNoArgInstanceMember [#_"Object" target, #_"String" name, #_"boolean" requireField]
        (let [#_"Class" c (.getClass target)]
            (if requireField
                (let [#_"Field" f (Reflector'getField c, name, false)]
                    (if (some? f)
                        (Reflector'getInstanceField target, name)
                        (throw (IllegalArgumentException. (str "No matching field found: " name " for " (.getClass target))))
                    )
                )
                (let [#_"List" meths (Reflector'getMethods c, 0, name, false)]
                    (if (pos? (.size meths))
                        (Reflector'invokeMatchingMethod name, meths, target, RT'EMPTY_ARRAY)
                        (Reflector'getInstanceField target, name)
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-2 [#_"Object" target, #_"String" name]
        ;; check for field first
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, name, false)]
            (when (some? f) => (Reflector'invokeInstanceMethod target, name, RT'EMPTY_ARRAY)
                (try ;; field get
                    (Reflector'prepRet (.getType f), (.get f, target))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3o [#_"String" name, #_"Object" target, #_"Object" arg1]
        ;; check for field first
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, name, false)]
            (when (some? f) => (Reflector'invokeInstanceMethod target, name, (object-array [ arg1 ]))
                (try ;; field set
                    (.set f, target, (Reflector'boxArg (.getType f), arg1))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                arg1
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3a [#_"String" name, #_"Object" target & #_"Object..." args]
        (Reflector'invokeInstanceMethod target, name, args)
    )

    (defn #_"Field" Reflector'getField [#_"Class" c, #_"String" name, #_"boolean" getStatics]
        (let [#_"Field[]" allfields (.getFields c)]
            (loop-when [#_"int" i 0] (< i (alength allfields))
                (let [#_"Field" f (aget allfields i)]
                    (if (and (.equals name, (.getName f)) (= (Modifier/isStatic (.getModifiers f)) getStatics))
                        f
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (defn #_"List" Reflector'getMethods [#_"Class" c, #_"int" arity, #_"String" name, #_"boolean" getStatics]
        (let [#_"java.lang.reflect.Method[]" allmethods (.getMethods c)
              #_"ArrayList" methods (ArrayList.) #_"ArrayList" bridgeMethods (ArrayList.)]
            (dotimes [#_"int" i (alength allmethods)]
                (let [#_"java.lang.reflect.Method" m (aget allmethods i)]
                    (when (and (.equals name, (.getName m)) (= (Modifier/isStatic (.getModifiers m)) getStatics) (= (alength (.getParameterTypes m)) arity))
                        (try
                            (if (and (.isBridge m) (.equals (.getMethod c, (.getName m), (.getParameterTypes m)), m))
                                (.add bridgeMethods, m)
                                (.add methods, m)
                            )
                            (catch NoSuchMethodException _
                            )
                        )
                    )
                )
            )
            (when (.isEmpty methods)
                (.addAll methods, bridgeMethods)
            )
            (when (and (not getStatics) (.isInterface c))
                (let [allmethods (.getMethods Object)]
                    (dotimes [#_"int" i (alength allmethods)]
                        (let [#_"java.lang.reflect.Method" m (aget allmethods i)]
                            (when (and (.equals name, (.getName m)) (= (Modifier/isStatic (.getModifiers m)) getStatics) (= (alength (.getParameterTypes m)) arity))
                                (.add methods, m)
                            )
                        )
                    )
                )
            )
            methods
        )
    )

    (defn #_"Object" Reflector'boxArg [#_"Class" paramType, #_"Object" arg]
        (let [unexpected! #(throw (IllegalArgumentException. (str "Unexpected param type, expected: " paramType ", given: " (.getName (.getClass arg)))))]
            (cond
                (not (.isPrimitive paramType)) (.cast paramType, arg)
                (= paramType Boolean/TYPE)     (.cast Boolean, arg)
                (= paramType Character/TYPE)   (.cast Character, arg)
                (instance? Number arg)
                    (let [#_"Number" n (cast Number arg)]
                        (condp = paramType
                            Integer/TYPE (.intValue n)
                            Float/TYPE   (.floatValue n)
                            Double/TYPE  (.doubleValue n)
                            Long/TYPE    (.longValue n)
                            Short/TYPE   (.shortValue n)
                            Byte/TYPE    (.byteValue n)
                                         (unexpected!)
                        )
                    )
                :else
                    (unexpected!)
            )
        )
    )

    (defn #_"Object[]" Reflector'boxArgs [#_"Class[]" params, #_"Object[]" args]
        (when (pos? (alength params))
            (let [#_"Object[]" a (make-array Object (alength params))]
                (dotimes [#_"int" i (alength params)]
                    (aset a i (Reflector'boxArg (aget params i), (aget args i)))
                )
                a
            )
        )
    )

    (defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" paramType, #_"Class" argType]
        (cond
            (nil? argType)
                (not (.isPrimitive paramType))
            (or (= paramType argType) (.isAssignableFrom paramType, argType))
                true
            :else
                (condp = paramType
                    Integer/TYPE   (any = argType Integer Long/TYPE Long Short/TYPE Byte/TYPE)
                    Float/TYPE     (any = argType Float Double/TYPE)
                    Double/TYPE    (any = argType Double Float/TYPE)
                    Long/TYPE      (any = argType Long Integer/TYPE Short/TYPE Byte/TYPE)
                    Character/TYPE (= argType Character)
                    Short/TYPE     (= argType Short)
                    Byte/TYPE      (= argType Byte)
                    Boolean/TYPE   (= argType Boolean)
                                   false
                )
        )
    )

    (defn #_"boolean" Reflector'isCongruent [#_"Class[]" params, #_"Object[]" args]
        (when (some? args) => (zero? (alength params))
            (and (= (alength params) (alength args))
                (loop-when [#_"boolean" ? true #_"int" i 0] (and ? (< i (alength params)))
                    (let [#_"Object" arg (aget args i)]
                        (recur (Reflector'paramArgTypeMatch (aget params i), (when (some? arg) (.getClass arg))) (inc i))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'prepRet [#_"Class" c, #_"Object" x]
        (cond
            (not (or (.isPrimitive c) (= c Boolean))) x
            (instance? Boolean x)                     (if (cast Boolean x) Boolean/TRUE Boolean/FALSE)
            :else                                     x
        )
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (def- #_"long" Repeat'INFINITE -1)

    (defn- #_"Repeat" Repeat'init []
        (hash-map
            #_"long" :count 0 ;; always INFINITE or >0
            #_"Object" :val nil
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Repeat" Repeat'new-2 [#_"long" count, #_"Object" val]
        (let [this (merge (ASeq'new) (Repeat'init))]
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :val val))
            this
        )
    )

    (defn- #_"Repeat" Repeat'new-3 [#_"IPersistentMap" meta, #_"long" count, #_"Object" val]
        (let [this (merge (ASeq'new meta) (Repeat'init))]
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :val val))
            this
        )
    )

    (defn #_"Repeat" Repeat'create-1 [#_"Object" val]
        (Repeat'new-2 Repeat'INFINITE, val)
    )

    (defn #_"ISeq" Repeat'create-2 [#_"long" count, #_"Object" val]
        (if (pos? count) (Repeat'new-2 count, val) PersistentList'EMPTY)
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"Repeat" this]
        (:val this)
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"Repeat" this]
        (when (nil? (:_next this))
            (cond (< 1 (:count this))
                (do
                    (§ ass this (assoc this :_next (Repeat'new-2 (dec (:count this)), (:val this))))
                )
                (= (:count this) Repeat'INFINITE)
                (do
                    (§ ass this (assoc this :_next this))
                )
            )
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Repeat" (§ method withMeta) [#_"Repeat" this, #_"IPersistentMap" meta]
        (Repeat'new-3 meta, (:count this), (:val this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Repeat" this, #_"IFn" f]
        (let [#_"Object" r (:val this)]
            (if (= (:count this) Repeat'INFINITE)
                (loop [r r]
                    (let [r (.invoke f, r, (:val this))]
                        (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r))
                    )
                )
                (loop-when [r r #_"long" i 1] (< i (:count this)) => r
                    (let [r (.invoke f, r, (:val this))]
                        (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Repeat" this, #_"IFn" f, #_"Object" r]
        (if (= (:count this) Repeat'INFINITE)
            (loop [r r]
                (let [r (.invoke f, r, (:val this))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r))
                )
            )
            (loop-when [r r #_"long" i 0] (< i (:count this)) => r
                (let [r (.invoke f, r, (:val this))]
                    (if (RT'isReduced r) (.deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_protected
    (defn #_"RestFn" RestFn'new []
        (AFunction'new)
    )

    #_abstract
    (§ defn #_"int" (§ method getRequiredArity) [#_"RestFn" this])

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object" args]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"RestFn" this, #_"ISeq" args]
        (when (<= (RT'boundedLength args, (.getRequiredArity this)) (.getRequiredArity this))
            (§ return (AFn'applyToHelper this, (Util'ret1 args, (§ ass args nil))))
        )
        (case (.getRequiredArity this)
            0
                (.doInvoke this, (Util'ret1 args, (§ ass args nil)))
            1
                (.doInvoke this, (.first args),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            2
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            3
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            4
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            5
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            6
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            7
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            8
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            9
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            10
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            11
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            12
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            13
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            14
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            15
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            16
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            17
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            18
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            19
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            20
                (.doInvoke this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            (.throwArity this, -1)
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this]
        (case (.getRequiredArity this)
            0
                (.doInvoke this, nil)
            (do
                (.throwArity this, 0)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1]
        (case (.getRequiredArity this)
            0
                (.doInvoke this, (ArraySeq'create-1 (Util'ret1 arg1, (§ ass arg1 nil))))
            1
                (.doInvoke this, (Util'ret1 arg1, (§ ass arg1 nil)), nil)
            (do
                (.throwArity this, 1)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)), nil)
            (do
                (.throwArity this, 2)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg3, (§ ass arg3 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)), nil)
            (do
                (.throwArity this, 3)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)), nil)
            (do
                (.throwArity this, 4)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)), nil)
            (do
                (.throwArity this, 5)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)), nil)
            (do
                (.throwArity this, 6)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)), nil)
            (do
                (.throwArity this, 7)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)), nil)
            (do
                (.throwArity this, 8)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)), nil)
            (do
                (.throwArity this, 9)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)), nil)
            (do
                (.throwArity this, 10)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)), nil)
            (do
                (.throwArity this, 11)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)), nil)
            (do
                (.throwArity this, 12)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)), nil)
            (do
                (.throwArity this, 13)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)), nil)
            (do
                (.throwArity this, 14)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)), nil)
            (do
                (.throwArity this, 15)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            16
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)), nil)
            (do
                (.throwArity this, 16)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            16
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            17
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)), nil)
            (do
                (.throwArity this, 17)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            16
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            17
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            18
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)), nil)
            (do
                (.throwArity this, 18)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil)),
                        (Util'ret1 arg19, (§ ass arg19 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            16
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            17
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            18
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            19
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)), nil)
            (do
                (.throwArity this, 19)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil)),
                        (Util'ret1 arg19, (§ ass arg19 nil)),
                        (Util'ret1 arg20, (§ ass arg20 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            16
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            17
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            18
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            19
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            20
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                    (Util'ret1 arg20, (§ ass arg20 nil)), nil)
            (do
                (.throwArity this, 20)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (case (.getRequiredArity this)
            0
                (.doInvoke this,
                    (RestFn'ontoArrayPrepend args,
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil)),
                        (Util'ret1 arg19, (§ ass arg19 nil)),
                        (Util'ret1 arg20, (§ ass arg20 nil))))
            1
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            2
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            3
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            4
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            5
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            6
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            7
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            8
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            9
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            10
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            11
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            12
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            13
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            14
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            15
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            16
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            17
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            18
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            19
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            20
                (.doInvoke this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                    (Util'ret1 arg20, (§ ass arg20 nil)),
                        (ArraySeq'create-1 args))
            (do
                (.throwArity this, 21)
            )
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" array & #_"Object..." args]
        (loop-when-recur [#_"ISeq" s (ArraySeq'create-1 array) #_"int" i (dec (alength args))] (<= 0 i) [(RT'cons (aget args i), s) (dec i)] => s)
    )

    #_protected
    (defn #_"ISeq" RestFn'findKey [#_"Object" key, #_"ISeq" args]
        (loop-when args (some? args)
            (if (= key (.first args)) (.next args) (recur (RT'next (RT'next args))))
        )
    )
)
)

(java-ns cloiure.lang.Reversible

(§ defprotocol Reversible
    #_abstract
    (#_"ISeq" Reversible'''(§ method rseq) [#_"Reversible" this])
)
)

(java-ns cloiure.lang.RT

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_private
#_closure
(class-ns DefaultComparator (§ implements Comparator)
    (defn #_"DefaultComparator" DefaultComparator'new []
        (hash-map)
    )

    #_method
    (§ defn #_"int" (§ method compare) [#_"DefaultComparator" this, #_"Object" o1, #_"Object" o2]
        (Util'compare o1, o2)
    )
)

#_stateless
(class-ns RT
    (def #_"Boolean" RT'T Boolean/TRUE)
    (def #_"Boolean" RT'F Boolean/FALSE)
    (def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (§ def #_"IPersistentMap" RT'DEFAULT_IMPORTS (RT'map
        (object-array [
            (Symbol'intern "Boolean")                         Boolean
            (Symbol'intern "Byte")                            Byte
            (Symbol'intern "Character")                       Character
            (Symbol'intern "Class")                           Class
            (Symbol'intern "ClassLoader")                     ClassLoader
            (Symbol'intern "Compiler")                        Compiler
            (Symbol'intern "Double")                          Double
            (Symbol'intern "Enum")                            Enum
            (Symbol'intern "Float")                           Float
            (Symbol'intern "InheritableThreadLocal")          InheritableThreadLocal
            (Symbol'intern "Integer")                         Integer
            (Symbol'intern "Long")                            Long
            (Symbol'intern "Math")                            Math
            (Symbol'intern "Number")                          Number
            (Symbol'intern "Object")                          Object
            (Symbol'intern "Package")                         Package
            (Symbol'intern "Process")                         Process
            (Symbol'intern "ProcessBuilder")                  ProcessBuilder
            (Symbol'intern "Runtime")                         Runtime
            (Symbol'intern "RuntimePermission")               RuntimePermission
            (Symbol'intern "SecurityManager")                 SecurityManager
            (Symbol'intern "Short")                           Short
            (Symbol'intern "StackTraceElement")               StackTraceElement
            (Symbol'intern "StrictMath")                      StrictMath
            (Symbol'intern "String")                          String
            (Symbol'intern "StringBuffer")                    StringBuffer
            (Symbol'intern "StringBuilder")                   StringBuilder
            (Symbol'intern "System")                          System
            (Symbol'intern "Thread")                          Thread
            (Symbol'intern "ThreadGroup")                     ThreadGroup
            (Symbol'intern "ThreadLocal")                     ThreadLocal
            (Symbol'intern "Throwable")                       Throwable
            (Symbol'intern "Void")                            Void
            (Symbol'intern "Appendable")                      Appendable
            (Symbol'intern "CharSequence")                    CharSequence
            (Symbol'intern "Cloneable")                       Cloneable
            (Symbol'intern "Comparable")                      Comparable
            (Symbol'intern "Iterable")                        Iterable
            (Symbol'intern "Readable")                        Readable
            (Symbol'intern "Runnable")                        Runnable
            (Symbol'intern "Callable")                        Callable
            (Symbol'intern "BigInteger")                      BigInteger
            (Symbol'intern "BigDecimal")                      BigDecimal
            (Symbol'intern "ArithmeticException")             ArithmeticException
            (Symbol'intern "ArrayIndexOutOfBoundsException")  ArrayIndexOutOfBoundsException
            (Symbol'intern "ArrayStoreException")             ArrayStoreException
            (Symbol'intern "ClassCastException")              ClassCastException
            (Symbol'intern "ClassNotFoundException")          ClassNotFoundException
            (Symbol'intern "CloneNotSupportedException")      CloneNotSupportedException
            (Symbol'intern "EnumConstantNotPresentException") EnumConstantNotPresentException
            (Symbol'intern "Exception")                       Exception
            (Symbol'intern "IllegalAccessException")          IllegalAccessException
            (Symbol'intern "IllegalArgumentException")        IllegalArgumentException
            (Symbol'intern "IllegalMonitorStateException")    IllegalMonitorStateException
            (Symbol'intern "IllegalStateException")           IllegalStateException
            (Symbol'intern "IllegalThreadStateException")     IllegalThreadStateException
            (Symbol'intern "IndexOutOfBoundsException")       IndexOutOfBoundsException
            (Symbol'intern "InstantiationException")          InstantiationException
            (Symbol'intern "InterruptedException")            InterruptedException
            (Symbol'intern "NegativeArraySizeException")      NegativeArraySizeException
            (Symbol'intern "NoSuchFieldException")            NoSuchFieldException
            (Symbol'intern "NoSuchMethodException")           NoSuchMethodException
            (Symbol'intern "NullPointerException")            NullPointerException
            (Symbol'intern "NumberFormatException")           NumberFormatException
            (Symbol'intern "RuntimeException")                RuntimeException
            (Symbol'intern "SecurityException")               SecurityException
            (Symbol'intern "StringIndexOutOfBoundsException") StringIndexOutOfBoundsException
            (Symbol'intern "TypeNotPresentException")         TypeNotPresentException
            (Symbol'intern "UnsupportedOperationException")   UnsupportedOperationException
            (Symbol'intern "AbstractMethodError")             AbstractMethodError
            (Symbol'intern "AssertionError")                  AssertionError
            (Symbol'intern "ClassCircularityError")           ClassCircularityError
            (Symbol'intern "ClassFormatError")                ClassFormatError
            (Symbol'intern "Error")                           Error
            (Symbol'intern "ExceptionInInitializerError")     ExceptionInInitializerError
            (Symbol'intern "IllegalAccessError")              IllegalAccessError
            (Symbol'intern "IncompatibleClassChangeError")    IncompatibleClassChangeError
            (Symbol'intern "InstantiationError")              InstantiationError
            (Symbol'intern "InternalError")                   InternalError
            (Symbol'intern "LinkageError")                    LinkageError
            (Symbol'intern "NoClassDefFoundError")            NoClassDefFoundError
            (Symbol'intern "NoSuchFieldError")                NoSuchFieldError
            (Symbol'intern "NoSuchMethodError")               NoSuchMethodError
            (Symbol'intern "OutOfMemoryError")                OutOfMemoryError
            (Symbol'intern "StackOverflowError")              StackOverflowError
            (Symbol'intern "ThreadDeath")                     ThreadDeath
            (Symbol'intern "UnknownError")                    UnknownError
            (Symbol'intern "UnsatisfiedLinkError")            UnsatisfiedLinkError
            (Symbol'intern "UnsupportedClassVersionError")    UnsupportedClassVersionError
            (Symbol'intern "VerifyError")                     VerifyError
            (Symbol'intern "VirtualMachineError")             VirtualMachineError
            (Symbol'intern "Thread$UncaughtExceptionHandler") Thread$UncaughtExceptionHandler
            (Symbol'intern "Thread$State")                    Thread$State
            (Symbol'intern "Deprecated")                      Deprecated
            (Symbol'intern "Override")                        Override
            (Symbol'intern "SuppressWarnings")                SuppressWarnings
        ])
    ))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (def #_"Charset" RT'UTF8 (Charset/forName "UTF-8"))

    (§ def #_"Namespace" RT'CLOIURE_NS (Namespace'findOrCreate (Symbol'intern "cloiure.core")))

    (§ def #_"Var" RT'IN (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*in*"), (LineNumberingPushbackReader'new-1 (InputStreamReader. System/in)))))
    (§ def #_"Var" RT'OUT (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*out*"), (OutputStreamWriter. System/out))))
    (§ def #_"Var" RT'ERR (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*err*"), (PrintWriter. (OutputStreamWriter. System/err), true))))

    (§ def #_"Keyword" RT'TAG_KEY (Keyword'intern (Symbol'intern nil, "tag")))
    (§ def #_"Keyword" RT'CONST_KEY (Keyword'intern (Symbol'intern nil, "const")))

    (§ def #_"Var" RT'AGENT (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*agent*"), nil)))

    (§ def #_"Var" RT'READEVAL (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*read-eval*"), RT'T)))
    (§ def #_"Var" RT'ASSERT (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*assert*"), RT'T)))
    (§ def #_"Var" RT'MATH_CONTEXT (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*math-context*"), nil)))

    (§ def #_"Keyword" RT'LINE_KEY (Keyword'intern (Symbol'intern nil, "line")))
    (§ def #_"Keyword" RT'COLUMN_KEY (Keyword'intern (Symbol'intern nil, "column")))
    (§ def #_"Keyword" RT'DECLARED_KEY (Keyword'intern (Symbol'intern nil, "declared")))
    (§ def #_"Keyword" RT'DOC_KEY (Keyword'intern (Symbol'intern nil, "doc")))

    (§ def #_"Symbol" RT'IN_NAMESPACE (Symbol'intern "in-ns"))
    (§ def #_"Symbol" RT'NAMESPACE (Symbol'intern "ns"))
    (§ def #_"Symbol" RT'IDENTICAL (Symbol'intern "identical?"))

    (§ def #_"Var" RT'CURRENT_NS (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*ns*"), RT'CLOIURE_NS)))

    (§ def #_"Var" RT'FLUSH_ON_NEWLINE (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*flush-on-newline*"), RT'T)))
    (§ def #_"Var" RT'PRINT_READABLY (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*print-readably*"), RT'T)))
    (§ def #_"Var" RT'WARN_ON_REFLECTION (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*warn-on-reflection*"), RT'F)))
    (§ def #_"Var" RT'ALLOW_UNRESOLVED_VARS (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*allow-unresolved-vars*"), RT'F)))
    (§ def #_"Var" RT'READER_RESOLVER (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*reader-resolver*"), nil)))

    (§ def #_"Var" RT'IN_NS_VAR (Var'intern RT'CLOIURE_NS, (Symbol'intern "in-ns"), RT'F))
    (§ def #_"Var" RT'NS_VAR (Var'intern RT'CLOIURE_NS, (Symbol'intern "ns"), RT'F))
    (§ def #_"Var" RT'FN_LOADER_VAR (.setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*fn-loader*"), nil)))
    (§ def #_"Var" RT'PRINT_INITIALIZED (Var'intern RT'CLOIURE_NS, (Symbol'intern "print-initialized")))
    (§ def #_"Var" RT'PR_ON (Var'intern RT'CLOIURE_NS, (Symbol'intern "pr-on")))

    (def #_"IFn" RT'inNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" arg1]
                (let [#_"Namespace" ns (Namespace'findOrCreate (cast' Symbol arg1))]
                    (.set RT'CURRENT_NS, ns)
                    ns
                )
            )
        )
    )

    (def #_"IFn" RT'bootNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" __form, #_"Object" __env, #_"Object" arg1]
                (let [#_"Namespace" ns (Namespace'findOrCreate (cast' Symbol arg1))]
                    (.set RT'CURRENT_NS, ns)
                    ns
                )
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" w (cast Writer (.deref RT'ERR))]
            (if (instance? PrintWriter w) (cast PrintWriter w) (PrintWriter. w))
        )
    )

    (def #_"Object[]" RT'EMPTY_ARRAY (make-array Object 0))
    (§ def #_"Comparator" RT'DEFAULT_COMPARATOR (DefaultComparator'new))

    (def #_"AtomicInteger" RT'ID (AtomicInteger. 1))

    (def #_"boolean" RT'CHECK_SPEC_ASSERTS false #_"cloiure.spec.check-asserts")
    (def #_"boolean" RT'INSTRUMENT_MACROS true #_"cloiure.spec.skip-macros")
    #_volatile
    (def #_"boolean" RT'CHECK_SPECS false)

    (§ static
        (.setTag RT'OUT, (Symbol'intern "java.io.Writer"))
        (.setTag RT'CURRENT_NS, (Symbol'intern "cloiure.lang.Namespace"))
        (.setMeta RT'AGENT, (RT'map RT'DOC_KEY, "The agent currently running an action on this thread, else nil."))
        (.setTag RT'AGENT, (Symbol'intern "cloiure.lang.Agent"))
        (.setTag RT'MATH_CONTEXT, (Symbol'intern "java.math.MathContext"))
        (let [#_"Var" v (Var'intern RT'CLOIURE_NS, RT'NAMESPACE, bootNamespace)
              _ (.setMacro v)
              v (Var'intern RT'CLOIURE_NS, RT'IN_NAMESPACE, inNamespace)
              _ (.setMeta v, (RT'map RT'DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed."))]
            (try
                (RT'load-1 "cloiure/core")
                (catch Exception e
                    (throw (Util'sneakyThrow e))
                )
            )
            (§ ass RT'CHECK_SPECS RT'INSTRUMENT_MACROS)
        )
    )

    (defn #_"Keyword" RT'keyword [#_"String" ns, #_"String" name]
        (Keyword'intern (Symbol'intern ns, name))
    )

    (defn #_"Var" RT'var
        ([#_"String" ns, #_"String" name]
            (Var'intern (Namespace'findOrCreate (Symbol'intern nil, ns)), (Symbol'intern nil, name))
        )
        ([#_"String" ns, #_"String" name, #_"Object" init]
            (Var'intern (Namespace'findOrCreate (Symbol'intern nil, ns)), (Symbol'intern nil, name), init)
        )
    )

    (defn #_"void" RT'loadResourceScript [#_"String" name, #_"boolean" failIfNotFound] #_(§ throws IOException)
        (let [#_"InputStream" ins (RT'resourceAsStream (RT'baseLoader), name)]
            (cond (some? ins)
                (try
                    (Compiler'load (InputStreamReader. ins, RT'UTF8))
                    (finally
                        (.close ins)
                    )
                )
                failIfNotFound
                    (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " name)))
            )
        )
        nil
    )

    (defn #_"long" RT'lastModified [#_"URL" url, #_"String" libfile] #_(§ throws IOException)
        (let [#_"URLConnection" connection (.openConnection url)]
            (try
                (if (= (.getProtocol url) "jar")
                    (.getTime (.getEntry (.getJarFile (cast JarURLConnection connection)), libfile))
                    (.getLastModified connection)
                )
                (finally
                    (let [#_"InputStream" ins (.getInputStream connection)]
                        (when (some? ins)
                            (.close ins)
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'load-1 [#_"String" scriptbase] #_(§ throws IOException, ClassNotFoundException)
        (RT'load-2 scriptbase, true)
        nil
    )

    (defn #_"void" RT'load-2 [#_"String" scriptbase, #_"boolean" failIfNotFound] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"String" classfile (str scriptbase RT'LOADER_SUFFIX ".class") #_"String" cljfile (str scriptbase ".cli")
              #_"URL" classURL (RT'getResource (RT'baseLoader), classfile) #_"URL" cljURL (RT'getResource (RT'baseLoader), cljfile)
              #_"boolean" loaded false]
            (when (or (and (some? classURL) (or (nil? cljURL) (< (RT'lastModified cljURL, cljfile) (RT'lastModified classURL, classfile)))) (nil? classURL))
                (try
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            RT'CURRENT_NS         (.deref RT'CURRENT_NS)
                            RT'WARN_ON_REFLECTION (.deref RT'WARN_ON_REFLECTION)
                        ])
                    ))
                    (§ ass loaded (some? (RT'loadClassForName (str (.replace scriptbase, \/, \.) RT'LOADER_SUFFIX))))
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
            (cond (and (not loaded) (some? cljURL))
                (RT'loadResourceScript cljfile, true)
                (and (not loaded) failIfNotFound)
                    (throw (FileNotFoundException. (str "Could not locate " classfile " or " cljfile " on classpath." (when (.contains scriptbase, "_") " Please check that namespaces with dashes use underscores in the Cloiure file name."))))
            )
        )
        nil
    )

    (defn #_"int" RT'nextID []
        (.getAndIncrement RT'ID)
    )

    (def- #_"int" RT'CHUNK_SIZE 32)

    (defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" iter]
        (when (.hasNext iter)
            (LazySeq'new-1
                (§ reify AFn()
                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
                        (let [#_"Object[]" arr (make-array Object RT'CHUNK_SIZE)]
                            (let [#_"int" n 0]
                                (while (and (.hasNext iter) (< n RT'CHUNK_SIZE))
                                    (aset arr n (.next iter))
                                    (§ ass n (inc n))
                                )
                                (ChunkedCons'new-2 (ArrayChunk'new-3 arr, 0, n), (RT'chunkIteratorSeq iter))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"ISeq" RT'seq [#_"Object" coll]
        (cond
            (§ instance? ASeq coll)    (cast' ASeq coll)
            (§ instance? LazySeq coll) (.seq (cast' LazySeq coll))
            :else                      (RT'seqFrom coll)
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (defn #_"ISeq" RT'seqFrom [#_"Object" coll]
        (cond
            (§ instance? Seqable coll)    (.seq (cast' Seqable coll))
            (nil? coll)                   nil
            (instance? Iterable coll)     (RT'chunkIteratorSeq (.iterator (cast Iterable coll)))
            (.isArray (.getClass coll))   (ArraySeq'createFromObject coll)
            (instance? CharSequence coll) (StringSeq'create (cast CharSequence coll))
            (instance? Map coll)          (RT'seq (.entrySet (cast Map coll)))
            :else (throw (IllegalArgumentException. (str "Don't know how to create ISeq from: " (.getName (.getClass coll)))))
        )
    )

    (defn #_"boolean" RT'canSeq [#_"Object" coll]
        (or
            (§ instance? ISeq coll)
            (§ instance? Seqable coll)
            (nil? coll)
            (instance? Iterable coll)
            (.isArray (.getClass coll))
            (instance? CharSequence coll)
            (instance? Map coll)
        )
    )

    (defn #_"Iterator" RT'iter [#_"Object" coll]
        (cond
            (instance? Iterable coll)
                (.iterator (cast Iterable coll))
            (nil? coll)
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_method
                    (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            (instance? Map coll)
                (.iterator (.entrySet (cast Map coll)))
            (instance? String coll)
                (let [#_"String" s (cast String coll)]
                    (§ reify Iterator()
                        (§ init
                            (hash-map
                                #_"int" :i 0
                            )
                        )

                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (< (:i this) (.length s))
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [_ (.charAt s, (:i this))]
                                (§ ass (:i this) (inc (:i this)))
                                _
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            (.isArray (.getClass coll))
                (ArrayIter'createFromObject coll)
            :else
                (RT'iter (RT'seq coll))
        )
    )

    (defn #_"Object" RT'seqOrElse [#_"Object" o]
        (when (some? (RT'seq o))
            o
        )
    )

    (defn #_"ISeq" RT'keys [#_"Object" coll]
        (if (§ instance? IPersistentMap coll)
            (KeySeq'createFromMap (cast' IPersistentMap coll))
            (KeySeq'create (RT'seq coll))
        )
    )

    (defn #_"ISeq" RT'vals [#_"Object" coll]
        (if (§ instance? IPersistentMap coll)
            (ValSeq'createFromMap (cast' IPersistentMap coll))
            (ValSeq'create (RT'seq coll))
        )
    )

    (defn #_"IPersistentMap" RT'meta [#_"Object" x]
        (when (§ instance? IMeta x)
            (.meta (cast' IMeta x))
        )
    )

    (defn #_"int" RT'count [#_"Object" o]
        (if (§ instance? Counted o)
            (.count (cast' Counted o))
            (RT'countFrom (Util'ret1 o, (§ ass o nil)))
        )
    )

    (defn #_"int" RT'countFrom [#_"Object" o]
        (cond
            (nil? o)
                0
            (§ instance? IPersistentCollection o)
                (let [#_"ISeq" s (RT'seq o) _ (§ ass o nil)]
                    (loop-when [#_"int" i 0 s s] (some? s) => i
                        (if (§ instance? Counted s)
                            (+ i (.count s))
                            (recur (inc i) (.next s))
                        )
                    )
                )
            (instance? CharSequence o)
                (.length (cast CharSequence o))
            (instance? Collection o)
                (.size (cast Collection o))
            (instance? Map o)
                (.size (cast Map o))
            (instance? Map$Entry o)
                2
            (.isArray (.getClass o))
                (Array/getLength o)
            :else
                (throw (UnsupportedOperationException. (str "count not supported on this type: " (.getSimpleName (.getClass o)))))
        )
    )

    (defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" coll, #_"Object" x]
        (if (some? coll) (.cons coll, x) (PersistentList'new-1 x))
    )

    (defn #_"ISeq" RT'cons [#_"Object" x, #_"Object" coll]
        (cond
            (nil? coll)             (PersistentList'new-1 x)
            (§ instance? ISeq coll) (Cons'new-2 x, (cast' ISeq coll))
            :else                   (Cons'new-2 x, (RT'seq coll))
        )
    )

    (defn #_"Object" RT'first [#_"Object" x]
        (if (§ instance? ISeq x)
            (.first (cast' ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (when (some? s)
                    (.first s)
                )
            )
        )
    )

    (defn #_"Object" RT'second [#_"Object" x]
        (RT'first (RT'next x))
    )

    (defn #_"Object" RT'third [#_"Object" x]
        (RT'first (RT'next (RT'next x)))
    )

    (defn #_"Object" RT'fourth [#_"Object" x]
        (RT'first (RT'next (RT'next (RT'next x))))
    )

    (defn #_"ISeq" RT'next [#_"Object" x]
        (if (§ instance? ISeq x)
            (.next (cast' ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (when (some? s)
                    (.next s)
                )
            )
        )
    )

    (defn #_"ISeq" RT'more [#_"Object" x]
        (if (§ instance? ISeq x)
            (.more (cast' ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (if (some? s) (.more s) PersistentList'EMPTY)
            )
        )
    )

    (defn #_"Object" RT'peek [#_"Object" x]
        (when (some? x)
            (.peek (cast' IPersistentStack x))
        )
    )

    (defn #_"Object" RT'pop [#_"Object" x]
        (when (some? x)
            (.pop (cast' IPersistentStack x))
        )
    )

    (defn #_"Object" RT'get-2 [#_"Object" coll, #_"Object" key]
        (if (§ instance? ILookup coll)
            (.valAt (cast' ILookup coll), key)
            (RT'getFrom-2 coll, key)
        )
    )

    (defn #_"Object" RT'getFrom-2 [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                nil
            (instance? Map coll)
                (let [#_"Map" m (cast Map coll)]
                    (.get m, key)
                )
            (§ instance? IPersistentSet coll)
                (let [#_"IPersistentSet" set (cast' IPersistentSet coll)]
                    (.get set, key)
                )
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (when (< -1 n (RT'count coll))
                        (RT'nth-2 coll, n)
                    )
                )
            (§ instance? ITransientSet coll)
                (let [#_"ITransientSet" set (cast' ITransientSet coll)]
                    (.get set, key)
                )
        )
    )

    (defn #_"Object" RT'get-3 [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (if (§ instance? ILookup coll)
            (.valAt (cast' ILookup coll), key, notFound)
            (RT'getFrom-3 coll, key, notFound)
        )
    )

    (defn #_"Object" RT'getFrom-3 [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (cond
            (nil? coll)
                notFound
            (instance? Map coll)
                (let [#_"Map" m (cast Map coll)]
                    (if (.containsKey m, key) (.get m, key) notFound)
                )
            (§ instance? IPersistentSet coll)
                (let [#_"IPersistentSet" set (cast' IPersistentSet coll)]
                    (if (.contains set, key) (.get set, key) notFound)
                )
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (if (< -1 n (RT'count coll)) (RT'nth-2 coll, n) notFound)
                )
            (§ instance? ITransientSet coll)
                (let [#_"ITransientSet" set (cast' ITransientSet coll)]
                    (if (.contains set, key) (.get set, key) notFound)
                )
            :else
                notFound
        )
    )

    (defn #_"Associative" RT'assoc [#_"Object" coll, #_"Object" key, #_"Object" val]
        (if (some? coll)
            (.assoc (cast' Associative coll), key, val)
            (PersistentArrayMap'new-1 (object-array [ key, val ]))
        )
    )

    (defn #_"Object" RT'contains [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                RT'F
            (§ instance? Associative coll)
                (if (.containsKey (cast' Associative coll), key) RT'T RT'F)
            (§ instance? IPersistentSet coll)
                (if (.contains (cast' IPersistentSet coll), key) RT'T RT'F)
            (instance? Map coll)
                (if (.containsKey (cast Map coll), key) RT'T RT'F)
            (instance? Set coll)
                (if (.contains (cast Set coll), key) RT'T RT'F)
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (if (< -1 n (RT'count coll)) RT'T RT'F)
                )
            (§ instance? ITransientSet coll)
                (if (.contains (cast' ITransientSet coll), key) RT'T RT'F)
            (§ instance? ITransientAssociative2 coll)
                (if (.containsKey (cast' ITransientAssociative2 coll), key) RT'T RT'F)
            :else
                (throw (IllegalArgumentException. (str "contains? not supported on type: " (.getName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'find [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                nil
            (§ instance? Associative coll)
                (.entryAt (cast' Associative coll), key)
            (instance? Map coll)
                (let [#_"Map" m (cast Map coll)]
                    (when (.containsKey m, key)
                        (MapEntry'create key, (.get m, key))
                    )
                )
            (§ instance? ITransientAssociative2 coll)
                (.entryAt (cast' ITransientAssociative2 coll), key)
            :else
                (throw (IllegalArgumentException. (str "find not supported on type: " (.getName (.getClass coll)))))
        )
    )

    ;; takes a seq of key, val, key, val
    ;; returns tail starting at val of matching key if found, else nil

    (defn #_"ISeq" RT'findKey [#_"Keyword" key, #_"ISeq" keyvals]
        (loop-when keyvals (some? keyvals)
            (let-when [#_"ISeq" r (.next keyvals)] (some? r) => (throw (RuntimeException. "Malformed keyword argslist"))
                (when-not (= (.first keyvals) key) => r
                    (recur (.next r))
                )
            )
        )
    )

    (defn #_"Object" RT'dissoc [#_"Object" coll, #_"Object" key]
        (when (some? coll)
            (.without (cast' IPersistentMap coll), key)
        )
    )

    (defn #_"Object" RT'nth-2 [#_"Object" coll, #_"int" n]
        (if (§ instance? Indexed coll)
            (.nth (cast' Indexed coll), n)
            (RT'nthFrom-2 (Util'ret1 coll, (§ ass coll nil)), n)
        )
    )

    (defn #_"Object" RT'nthFrom-2 [#_"Object" coll, #_"int" n]
        (cond
            (nil? coll)
                nil
            (instance? CharSequence coll)
                (Character/valueOf (.charAt (cast CharSequence coll), n))
            (.isArray (.getClass coll))
                (Reflector'prepRet (.getComponentType (.getClass coll)), (Array/get coll, n))
            (instance? RandomAccess coll)
                (.get (cast List coll), n)
            (instance? Matcher coll)
                (.group (cast Matcher coll), n)
            (instance? Map$Entry coll)
                (let [#_"Map$Entry" e (cast Map$Entry coll)]
                    (cond
                        (zero? n) (.getKey e)
                        (= n 1)   (.getValue e)
                        :else     (throw (IndexOutOfBoundsException.))
                    )
                )
            (§ instance? Sequential coll)
                (let [#_"ISeq" s (RT'seq coll) _ (§ ass coll nil)]
                    (loop-when [#_"int" i 0 s s] (and (<= i n) (some? s)) => (throw (IndexOutOfBoundsException.))
                        (if (= i n)
                            (.first s)
                            (recur (inc i) (.next s))
                        )
                    )
                )
            :else
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'nth-3 [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (if (§ instance? Indexed coll)
            (.nth (cast' Indexed coll), n, notFound)
            (RT'nthFrom-3 coll, n, notFound)
        )
    )

    (defn #_"Object" RT'nthFrom-3 [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (cond
            (nil? coll)
                notFound
            (neg? n)
                notFound
            (instance? CharSequence coll)
                (let [#_"CharSequence" s (cast CharSequence coll)]
                    (if (< n (.length s)) (Character/valueOf (.charAt s, n)) notFound)
                )
            (.isArray (.getClass coll))
                (if (< n (Array/getLength coll))
                    (Reflector'prepRet (.getComponentType (.getClass coll)), (Array/get coll, n))
                    notFound
                )
            (instance? RandomAccess coll)
                (let [#_"List" list (cast List coll)]
                    (if (< n (.size list)) (.get list, n) notFound)
                )
            (instance? Matcher coll)
                (let [#_"Matcher" m (cast Matcher coll)]
                    (if (< n (.groupCount m)) (.group m, n) notFound)
                )
            (instance? Map$Entry coll)
                (let [#_"Map$Entry" e (cast Map$Entry coll)]
                    (cond
                        (zero? n) (.getKey e)
                        (= n 1)   (.getValue e)
                        :else     notFound
                    )
                )
            (§ instance? Sequential coll)
                (let [#_"ISeq" s (RT'seq coll) _ (§ ass coll nil)]
                    (loop-when [#_"int" i 0 s s] (and (<= i n) (some? s)) => notFound
                        (if (= i n)
                            (.first s)
                            (recur (inc i) (.next s))
                        )
                    )
                )
            :else
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'assocN [#_"int" n, #_"Object" val, #_"Object" coll]
        (cond
            (nil? coll)
                nil
            (§ instance? IPersistentVector coll)
                (.assocN (cast' IPersistentVector coll), n, val)
            (§ instance? Object[] coll)
                ;; hmm... this is not persistent
                (let [#_"Object[]" array (§ cast Object[] coll)]
                    (aset array n val)
                    array
                )
        )
    )

    (defn #_"boolean" RT'hasTag [#_"Object" o, #_"Object" tag]
        (Util'equals tag, (RT'get-2 (RT'meta o), RT'TAG_KEY))
    )

    (defn #_"Object"    RT'box-1o [#_"Object"  x] x)
    (defn #_"Character" RT'box-1c [#_"char"    x] (Character/valueOf x))
    (defn #_"Object"    RT'box-1z [#_"boolean" x] (if x RT'T RT'F))
    (defn #_"Object"    RT'box-1Z [#_"Boolean" x] x)
    (defn #_"Number"    RT'box-1b [#_"byte"    x] x)
    (defn #_"Number"    RT'box-1s [#_"short"   x] x)
    (defn #_"Number"    RT'box-1i [#_"int"     x] x)
    (defn #_"Number"    RT'box-1l [#_"long"    x] x)
    (defn #_"Number"    RT'box-1f [#_"float"   x] x)
    (defn #_"Number"    RT'box-1d [#_"double"  x] x)

    (defn #_"char" RT'charCast-1o [#_"Object" x]
        (if (instance? Character x)
            (.charValue (cast Character x))
            (let [#_"long" n (.longValue (cast Number x))]
                (when (<= Character/MIN_VALUE n Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                    (char n)
                )
            )
        )
    )

    (defn #_"char" RT'charCast-1b [#_"byte" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1s [#_"short" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1c [#_"char" x]
        x
    )

    (defn #_"char" RT'charCast-1i [#_"int" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1l [#_"long" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1f [#_"float" x]
        (when (<= Character/MIN_VALUE x Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
            (char x)
        )
    )

    (defn #_"char" RT'charCast-1d [#_"double" x]
        (when (<= Character/MIN_VALUE x Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
            (char x)
        )
    )

    (defn #_"boolean" RT'booleanCast-1o [#_"Object" x]
        (if (instance? Boolean x) (.booleanValue (cast Boolean x)) (some? x))
    )

    (defn #_"boolean" RT'booleanCast-1b [#_"boolean" x]
        x
    )

    (defn #_"byte" RT'byteCast-1o [#_"Object" x]
        (if (instance? Byte x)
            (.byteValue (cast Byte x))
            (let [#_"long" n (RT'longCast-1o x)]
                (when (<= Byte/MIN_VALUE n Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                    (byte n)
                )
            )
        )
    )

    (defn #_"byte" RT'byteCast-1b [#_"byte" x]
        x
    )

    (defn #_"byte" RT'byteCast-1s [#_"short" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1i [#_"int" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1l [#_"long" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1f [#_"float" x]
        (when (<= Byte/MIN_VALUE x Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
            (byte x)
        )
    )

    (defn #_"byte" RT'byteCast-1d [#_"double" x]
        (when (<= Byte/MIN_VALUE x Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
            (byte x)
        )
    )

    (defn #_"short" RT'shortCast-1o [#_"Object" x]
        (if (instance? Short x)
            (.shortValue (cast Short x))
            (let [#_"long" n (RT'longCast-1o x)]
                (when (<= Short/MIN_VALUE n Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                    (short n)
                )
            )
        )
    )

    (defn #_"short" RT'shortCast-1b [#_"byte"  x] x)
    (defn #_"short" RT'shortCast-1s [#_"short" x] x)

    (defn #_"short" RT'shortCast-1i [#_"int" x]
        (let [#_"short" i (short x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                i
            )
        )
    )

    (defn #_"short" RT'shortCast-1l [#_"long" x]
        (let [#_"short" i (short x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                i
            )
        )
    )

    (defn #_"short" RT'shortCast-1f [#_"float" x]
        (when (<= Short/MIN_VALUE x Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
            (short x)
        )
    )

    (defn #_"short" RT'shortCast-1d [#_"double" x]
        (when (<= Short/MIN_VALUE x Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
            (short x)
        )
    )

    (defn #_"int" RT'intCast-1o [#_"Object" x]
        (cond
            (instance? Integer x) (.intValue (cast Integer x))
            (instance? Number x)  (RT'intCast-1l (RT'longCast-1o x))
            :else                 (.charValue (cast Character x))
        )
    )

    (defn #_"int" RT'intCast-1b [#_"byte"  x] x)
    (defn #_"int" RT'intCast-1s [#_"short" x] x)
    (defn #_"int" RT'intCast-1c [#_"char"  x] x)
    (defn #_"int" RT'intCast-1i [#_"int"   x] x)

    (defn #_"int" RT'intCast-1l [#_"long" x]
        (let [#_"int" i (int x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
                i
            )
        )
    )

    (defn #_"int" RT'intCast-1f [#_"float" x]
        (when (<= Integer/MIN_VALUE x Integer/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
            (int x)
        )
    )

    (defn #_"int" RT'intCast-1d [#_"double" x]
        (when (<= Integer/MIN_VALUE x Integer/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
            (int x)
        )
    )

    (defn #_"long" RT'longCast-1o [#_"Object" x]
        (cond
            (or (instance? Integer x) (instance? Long x))
                (.longValue (cast Number x))
            (§ instance? BigInt x)
                (let [#_"BigInt" bi (cast' BigInt x)]
                    (when (nil? (:bipart bi)) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
                        (:lpart bi)
                    )
                )
            (instance? BigInteger x)
                (let [#_"BigInteger" bi (cast BigInteger x)]
                    (when (< (.bitLength bi) 64) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
                        (.longValue bi)
                    )
                )
            (or (instance? Byte x) (instance? Short x))
                (.longValue (cast Number x))
            (§ instance? Ratio x)
                (RT'longCast-1o (.bigIntegerValue (cast' Ratio x)))
            (instance? Character x)
                (RT'longCast-1l (.charValue (cast Character x)))
            :else
                (RT'longCast-1d (.doubleValue (cast Number x)))
        )
    )

    (defn #_"long" RT'longCast-1b [#_"byte"  x] x)
    (defn #_"long" RT'longCast-1s [#_"short" x] x)
    (defn #_"long" RT'longCast-1i [#_"int"   x] x)
    (defn #_"long" RT'longCast-1l [#_"long"  x] x)

    (defn #_"long" RT'longCast-1f [#_"float" x]
        (when (<= Long/MIN_VALUE x Long/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
            (long x)
        )
    )

    (defn #_"long" RT'longCast-1d [#_"double" x]
        (when (<= Long/MIN_VALUE x Long/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
            (long x)
        )
    )

    (defn #_"float" RT'floatCast-1o [#_"Object" x]
        (if (instance? Float x)
            (.floatValue (cast Float x))
            (let [#_"double" n (.doubleValue (cast Number x))]
                (when (<= (- Float/MAX_VALUE) n Float/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for float: " x)))
                    (float n)
                )
            )
        )
    )

    (defn #_"float" RT'floatCast-1b [#_"byte"  x] x)
    (defn #_"float" RT'floatCast-1s [#_"short" x] x)
    (defn #_"float" RT'floatCast-1i [#_"int"   x] x)
    (defn #_"float" RT'floatCast-1l [#_"long"  x] x)
    (defn #_"float" RT'floatCast-1f [#_"float" x] x)

    (defn #_"float" RT'floatCast-1d [#_"double" x]
        (when (<= (- Float/MAX_VALUE) x Float/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for float: " x)))
            (float x)
        )
    )

    (defn #_"double" RT'doubleCast-1o [#_"Object" x]
        (.doubleValue (cast Number x))
    )

    (defn #_"double" RT'doubleCast-1b [#_"byte"   x] x)
    (defn #_"double" RT'doubleCast-1s [#_"short"  x] x)
    (defn #_"double" RT'doubleCast-1i [#_"int"    x] x)
    (defn #_"double" RT'doubleCast-1l [#_"long"   x] x)
    (defn #_"double" RT'doubleCast-1f [#_"float"  x] x)
    (defn #_"double" RT'doubleCast-1d [#_"double" x] x)

    (defn #_"byte" RT'uncheckedByteCast-1o [#_"Object" x]
        (.byteValue (cast Number x))
    )

    (defn #_"byte" RT'uncheckedByteCast-1b [#_"byte"   x]       x )
    (defn #_"byte" RT'uncheckedByteCast-1s [#_"short"  x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1i [#_"int"    x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1l [#_"long"   x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1f [#_"float"  x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1d [#_"double" x] (byte x))

    (defn #_"short" RT'uncheckedShortCast-1o [#_"Object" x]
        (.shortValue (cast Number x))
    )

    (defn #_"short" RT'uncheckedShortCast-1b [#_"byte"   x]        x )
    (defn #_"short" RT'uncheckedShortCast-1s [#_"short"  x]        x )
    (defn #_"short" RT'uncheckedShortCast-1i [#_"int"    x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1l [#_"long"   x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1f [#_"float"  x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1d [#_"double" x] (short x))

    (defn #_"char" RT'uncheckedCharCast-1o [#_"Object" x]
        (if (instance? Character x) (.charValue (cast Character x)) (char (.longValue (cast Number x))))
    )

    (defn #_"char" RT'uncheckedCharCast-1b [#_"byte"   x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1s [#_"short"  x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1c [#_"char"   x]       x )
    (defn #_"char" RT'uncheckedCharCast-1i [#_"int"    x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1l [#_"long"   x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1f [#_"float"  x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1d [#_"double" x] (char x))

    (defn #_"int" RT'uncheckedIntCast-1o [#_"Object" x]
        (if (instance? Number x) (.intValue (cast Number x)) (.charValue (cast Character x)))
    )

    (defn #_"int" RT'uncheckedIntCast-1b [#_"byte"   x]      x )
    (defn #_"int" RT'uncheckedIntCast-1s [#_"short"  x]      x )
    (defn #_"int" RT'uncheckedIntCast-1c [#_"char"   x]      x )
    (defn #_"int" RT'uncheckedIntCast-1i [#_"int"    x]      x )
    (defn #_"int" RT'uncheckedIntCast-1l [#_"long"   x] (int x))
    (defn #_"int" RT'uncheckedIntCast-1f [#_"float"  x] (int x))
    (defn #_"int" RT'uncheckedIntCast-1d [#_"double" x] (int x))

    (defn #_"long" RT'uncheckedLongCast-1o [#_"Object" x]
        (.longValue (cast Number x))
    )

    (defn #_"long" RT'uncheckedLongCast-1b [#_"byte"   x]       x )
    (defn #_"long" RT'uncheckedLongCast-1s [#_"short"  x]       x )
    (defn #_"long" RT'uncheckedLongCast-1i [#_"int"    x]       x )
    (defn #_"long" RT'uncheckedLongCast-1l [#_"long"   x]       x )
    (defn #_"long" RT'uncheckedLongCast-1f [#_"float"  x] (long x))
    (defn #_"long" RT'uncheckedLongCast-1d [#_"double" x] (long x))

    (defn #_"float" RT'uncheckedFloatCast-1o [#_"Object" x]
        (.floatValue (cast Number x))
    )

    (defn #_"float" RT'uncheckedFloatCast-1b [#_"byte"   x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1s [#_"short"  x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1i [#_"int"    x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1l [#_"long"   x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1f [#_"float"  x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1d [#_"double" x] (float x))

    (defn #_"double" RT'uncheckedDoubleCast-1o [#_"Object" x]
        (.doubleValue (cast Number x))
    )

    (defn #_"double" RT'uncheckedDoubleCast-1b [#_"byte"   x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1s [#_"short"  x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1i [#_"int"    x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1l [#_"long"   x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1f [#_"float"  x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1d [#_"double" x] x)

    (defn #_"IPersistentMap" RT'map [& #_"Object..." init]
        (cond
            (nil? init)
                PersistentArrayMap'EMPTY
            (<= (alength init) PersistentArrayMap'HASHTABLE_THRESHOLD)
                (PersistentArrayMap'createWithCheck init)
            :else
                (PersistentHashMap'createWithCheck-1a init)
        )
    )

    (defn #_"IPersistentMap" RT'mapUniqueKeys [& #_"Object..." init]
        (cond
            (nil? init)
                PersistentArrayMap'EMPTY
            (<= (alength init) PersistentArrayMap'HASHTABLE_THRESHOLD)
                (PersistentArrayMap'new-1 init)
            :else
                (PersistentHashMap'create-1a init)
        )
    )

    (defn #_"IPersistentSet" RT'set [& #_"Object..." init]
        (PersistentHashSet'createWithCheck-1a init)
    )

    (defn #_"IPersistentVector" RT'vector [& #_"Object..." init]
        (LazilyPersistentVector'createOwning init)
    )

    (defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" v, #_"int" start, #_"int" end]
        (when (<= 0 start end (.count v)) => (throw (IndexOutOfBoundsException.))
            (if (= start end)
                PersistentVector'EMPTY
                (SubVector'new nil, v, start, end)
            )
        )
    )

    (defn #_"ISeq" RT'list-0 []
        nil
    )

    (defn #_"ISeq" RT'list-1 [#_"Object" arg1]
        (PersistentList'new-1 arg1)
    )

    (defn #_"ISeq" RT'list-2 [#_"Object" arg1, #_"Object" arg2]
        (RT'listStar-3 arg1, arg2, nil)
    )

    (defn #_"ISeq" RT'list-3 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (RT'listStar-4 arg1, arg2, arg3, nil)
    )

    (defn #_"ISeq" RT'list-4 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (RT'listStar-5 arg1, arg2, arg3, arg4, nil)
    )

    (defn #_"ISeq" RT'list-5 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (RT'listStar-6 arg1, arg2, arg3, arg4, arg5, nil)
    )

    (defn #_"ISeq" RT'listStar-2 [#_"Object" arg1, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, rest))
    )

    (defn #_"ISeq" RT'listStar-3 [#_"Object" arg1, #_"Object" arg2, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, rest)))
    )

    (defn #_"ISeq" RT'listStar-4 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, rest))))
    )

    (defn #_"ISeq" RT'listStar-5 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, (RT'cons arg4, rest)))))
    )

    (defn #_"ISeq" RT'listStar-6 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, (RT'cons arg4, (RT'cons arg5, rest))))))
    )

    (defn #_"ISeq" RT'arrayToList [#_"Object[]" a]
        (let [#_"ISeq" s nil]
            (loop-when-recur [#_"int" i (dec (alength a))] (<= 0 i) [(dec i)]
                (§ ass s (cast' ISeq (RT'cons (aget a i), s)))
            )
            s
        )
    )

    (defn #_"Object[]" RT'object_array [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (make-array Object (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq) #_"int" size (RT'count s) #_"Object[]" a (make-array Object size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset a i (.first s))
                )
                a
            )
        )
    )

    (defn #_"Object[]" RT'toArray [#_"Object" coll]
        (cond
            (nil? coll)
                RT'EMPTY_ARRAY
            (§ instance? Object[] coll)
                (§ cast Object[] coll)
            (instance? Collection coll)
                (.toArray (cast Collection coll))
            (instance? Iterable coll)
                (let [#_"ArrayList" ret (ArrayList.)]
                    (doseq [#_"Object" o (cast Iterable coll)]
                        (.add ret, o)
                    )
                    (.toArray ret)
                )
            (instance? Map coll)
                (.toArray (.entrySet (cast Map coll)))
            (instance? String coll)
                (let [#_"char[]" chars (.toCharArray (cast String coll))
                      #_"Object[]" a (make-array Object (alength chars))]
                    (loop-when-recur [#_"int" i 0] (< i (alength chars)) [(inc i)]
                        (aset a i (aget chars i))
                    )
                    a
                )
            (.isArray (.getClass coll))
                (let [#_"ISeq" s (RT'seq coll)
                      #_"Object[]" a (make-array Object (RT'count s))]
                    (loop-when-recur [#_"int" i 0 s s] (< i (alength a)) [(inc i) (.next s)]
                        (aset a i (.first s))
                    )
                    a
                )
            :else
                (throw (RuntimeException. (str "Unable to convert: " (.getClass coll) " to Object[]")))
        )
    )

    (defn #_"Object[]" RT'seqToArray [#_"ISeq" s]
        (let [#_"Object[]" a (make-array Object (RT'length s))]
            (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                (aset a i (.first s))
            )
            a
        )
    )

    (defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" s, #_"Object[]" passed]
        (let [#_"Object[]" dest passed #_"int" len (RT'count s)]
            (when (< (alength dest) len)
                (§ ass dest (§ cast Object[] (Array/newInstance (.getComponentType (.getClass passed)), len)))
            )
            (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                (aset dest i (.first s))
            )
            (when (< len (alength passed))
                (aset dest len nil)
            )
            dest
        )
    )

    (defn #_"Object" RT'seqToTypedArray-1 [#_"ISeq" s]
        (let [#_"Class" type (if (and (some? s) (some? (.first s))) (.getClass (.first s)) Object)]
            (RT'seqToTypedArray-2 type, s)
        )
    )

    (defn #_"Object" RT'seqToTypedArray-2 [#_"Class" type, #_"ISeq" s]
        (let [#_"Object" a (Array/newInstance type, (RT'length s))]
            (condp = type
                Integer/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'intCast-1o (.first s)))
                    )
                Byte/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'byteCast-1o (.first s)))
                    )
                Float/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'floatCast-1o (.first s)))
                    )
                Short/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'shortCast-1o (.first s)))
                    )
                Character/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'charCast-1o (.first s)))
                    )
                #_else
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (.first s))
                    )
            )
            a
        )
    )

    (defn #_"int" RT'length [#_"ISeq" s]
        (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)] => i)
    )

    (defn #_"int" RT'boundedLength [#_"ISeq" s, #_"int" limit]
        (loop-when-recur [#_"int" i 0 s s] (and (some? s) (<= i limit)) [(inc i) (.next s)] => i)
    )

    (defn #_"Character" RT'readRet [#_"int" ret]
        (when-not (= ret -1)
            (RT'box-1c (char ret))
        )
    )

    (defn #_"Character" RT'readChar [#_"Reader" r] #_(§ throws IOException)
        (let [#_"int" ret (.read r)]
            (RT'readRet ret)
        )
    )

    (defn #_"Character" RT'peekChar [#_"Reader" r] #_(§ throws IOException)
        (let [#_"int" ret
                (if (instance? PushbackReader r)
                    (let [ret (.read r) _ (.unread (cast PushbackReader r), ret)]
                        ret
                    )
                    (let [_ (.mark r, 1) ret (.read r) _ (.reset r)]
                        ret
                    )
                )]
            (RT'readRet ret)
        )
    )

    (defn #_"int" RT'getLineNumber [#_"Reader" r]
        (if (§ instance? LineNumberingPushbackReader r)
            (.getLineNumber (cast' LineNumberingPushbackReader r))
            0
        )
    )

    (defn #_"int" RT'getColumnNumber [#_"Reader" r]
        (if (§ instance? LineNumberingPushbackReader r)
            (.getColumnNumber (cast' LineNumberingPushbackReader r))
            0
        )
    )

    (defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" r]
        (if (RT'isLineNumberingReader r)
            (cast' LineNumberingPushbackReader r)
            (LineNumberingPushbackReader'new-1 r)
        )
    )

    (defn #_"boolean" RT'isLineNumberingReader [#_"Reader" r] (§ instance? LineNumberingPushbackReader r))

    (defn #_"boolean" RT'isReduced [#_"Object" r] (§ instance? Reduced r))

    (defn #_"String" RT'printString [#_"Object" x]
        (try
            (let [#_"StringWriter" sw (StringWriter.)]
                (RT'print x, sw)
                (.toString sw)
            )
            (catch Exception e
                (throw (Util'sneakyThrow e))
            )
        )
    )

    (defn #_"Object" RT'readString [#_"String" s]
        (let [#_"PushbackReader" r (PushbackReader. (java.io.StringReader. s))]
            (LispReader'read-1 r)
        )
    )

    (defn #_"void" RT'print [#_"Object" x, #_"Writer" w] #_(§ throws IOException)
        (if (and (.isBound RT'PRINT_INITIALIZED) (RT'booleanCast-1o (.deref RT'PRINT_INITIALIZED)))
            (.invoke RT'PR_ON, x, w) ;; call multimethod
            (let [#_"boolean" readably (RT'booleanCast-1o (.deref RT'PRINT_READABLY))]
                (cond (nil? x)
                    (do
                        (.write w, "nil")
                    )
                    (or (§ instance? ISeq x) (§ instance? IPersistentList x))
                    (do
                        (.write w, \()
                        (RT'printInnerSeq (RT'seq x), w)
                        (.write w, \))
                    )
                    (instance? String x)
                        (let [#_"String" s (cast String x)]
                            (when readably => (.write w, s)
                                (.write w, \") ;; oops! "
                                (dotimes [#_"int" i (.length s)]
                                    (let [#_"char" c (.charAt s, i)]
                                        (case c
                                            \newline   (.write w, "\\n")
                                            \tab       (.write w, "\\t")
                                            \"         (.write w, "\\\"")
                                            \\         (.write w, "\\\\")
                                            \return    (.write w, "\\r")
                                            \formfeed  (.write w, "\\f")
                                            \backspace (.write w, "\\b")
                                                       (.write w, c)
                                        )
                                    )
                                )
                                (.write w, \") ;; oops! "
                            )
                        )
                    (§ instance? IPersistentMap x)
                    (do
                        (.write w, \{)
                        (loop-when-recur [#_"ISeq" s (RT'seq x)] (some? s) [(.next s)]
                            (let [#_"IMapEntry" e (cast' IMapEntry (.first s))]
                                (RT'print (.key e), w)
                                (.write w, \space)
                                (RT'print (.val e), w)
                                (when (some? (.next s))
                                    (.write w, ", ")
                                )
                            )
                        )
                        (.write w, \})
                    )
                    (§ instance? IPersistentVector x)
                        (let [#_"IPersistentVector" a (cast' IPersistentVector x)]
                            (.write w, \[)
                            (loop-when-recur [#_"int" i 0] (< i (.count a)) [(inc i)]
                                (RT'print (.nth a, i), w)
                                (when (< i (dec (.count a)))
                                    (.write w, \space)
                                )
                            )
                            (.write w, \])
                        )
                    (§ instance? IPersistentSet x)
                    (do
                        (.write w, "#{")
                        (loop-when-recur [#_"ISeq" s (RT'seq x)] (some? s) [(.next s)]
                            (RT'print (.first s), w)
                            (when (some? (.next s))
                                (.write w, \space)
                            )
                        )
                        (.write w, \})
                    )
                    (instance? Character x)
                        (let [#_"char" c (.charValue (cast Character x))]
                            (when readably => (.write w, c)
                                (.write w, \\)
                                (case c
                                    \newline   (.write w, "newline")
                                    \tab       (.write w, "tab")
                                    \space     (.write w, "space")
                                    \return    (.write w, "return")
                                    \formfeed  (.write w, "formfeed")
                                    \backspace (.write w, "backspace")
                                               (.write w, c)
                                )
                            )
                        )
                    (instance? Class x)
                    (do
                        (.write w, "#=")
                        (.write w, (.getName (cast Class x)))
                    )
                    (and (instance? BigDecimal x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, \M)
                    )
                    (and (§ instance? BigInt x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, \N)
                    )
                    (and (instance? BigInteger x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, "BIGINT")
                    )
                    (§ instance? Var x)
                        (let [#_"Var" v (cast' Var x)]
                            (.write w, (str "#=(var " (:name (:ns v)) "/" (:sym v) ")"))
                        )
                    (instance? Pattern x)
                        (let [#_"Pattern" p (cast Pattern x)]
                            (.write w, (str "#\"" (.pattern p) "\""))
                        )
                    :else
                    (do
                        (.write w, (.toString x))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" RT'printInnerSeq [#_"ISeq" x, #_"Writer" w] #_(§ throws IOException)
        (loop-when-recur [#_"ISeq" s x] (some? s) [(.next s)]
            (RT'print (.first s), w)
            (when (some? (.next s))
                (.write w, \space)
            )
        )
        nil
    )

    (defn #_"ClassLoader" RT'makeClassLoader []
        (cast ClassLoader
            (§ unsure AccessController/doPrivileged
                (§ reify PrivilegedAction()
                    #_method
                    (§ defn #_"Object" (§ method run) [#_"PrivilegedAction" _this]
                        (DynamicClassLoader'new (RT'baseLoader))
                    )
                )
            )
        )
    )

    (defn #_"ClassLoader" RT'baseLoader []
        (if (.isBound Compiler'LOADER)
            (cast ClassLoader (.deref Compiler'LOADER))
            (.getContextClassLoader (Thread/currentThread))
        )
    )

    (defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (ClassLoader/getSystemResourceAsStream name)
            (.getResourceAsStream loader, name)
        )
    )

    (defn #_"URL" RT'getResource [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (ClassLoader/getSystemResource name)
            (.getResource loader, name)
        )
    )

    (defn #_"Class" RT'classForName-3 [#_"String" name, #_"boolean" load, #_"ClassLoader" loader]
        (try
            (let [#_"Class" c
                    (when-not (§ instance? DynamicClassLoader loader)
                        (DynamicClassLoader'findInMemoryClass name)
                    )]
                (or c (Class/forName name, load, loader))
            )
            (catch ClassNotFoundException e
                (throw (Util'sneakyThrow e))
            )
        )
    )

    (defn #_"Class" RT'classForName-1 [#_"String" name]
        (RT'classForName-3 name, true, (RT'baseLoader))
    )

    (defn #_"Class" RT'classForNameNonLoading [#_"String" name]
        (RT'classForName-3 name, false, (RT'baseLoader))
    )

    (defn #_"Class" RT'loadClassForName [#_"String" name]
        (try
            (RT'classForNameNonLoading name)
            (catch ClassNotFoundException _
                (§ return nil)
            )
            (catch Exception e
                (throw (Util'sneakyThrow e))
            )
        )
        (RT'classForName-1 name)
    )

    (defn #_"boolean" RT'aget_boolean [#_"boolean[]" xs, #_"int" i] (aget xs i))
    (defn #_"byte"    RT'aget_byte    [#_"byte[]"    xs, #_"int" i] (aget xs i))
    (defn #_"short"   RT'aget_short   [#_"short[]"   xs, #_"int" i] (aget xs i))
    (defn #_"char"    RT'aget_char    [#_"char[]"    xs, #_"int" i] (aget xs i))
    (defn #_"int"     RT'aget_int     [#_"int[]"     xs, #_"int" i] (aget xs i))
    (defn #_"long"    RT'aget_long    [#_"long[]"    xs, #_"int" i] (aget xs i))
    (defn #_"float"   RT'aget_float   [#_"float[]"   xs, #_"int" i] (aget xs i))
    (defn #_"double"  RT'aget_double  [#_"double[]"  xs, #_"int" i] (aget xs i))
    (defn #_"Object"  RT'aget_object  [#_"Object[]"  xs, #_"int" i] (aget xs i))

    (defn #_"boolean" RT'aset_boolean [#_"boolean[]" xs, #_"int" i, #_"boolean" v] (aset xs i v) v)
    (defn #_"byte"    RT'aset_byte    [#_"byte[]"    xs, #_"int" i, #_"byte"    v] (aset xs i v) v)
    (defn #_"short"   RT'aset_short   [#_"short[]"   xs, #_"int" i, #_"short"   v] (aset xs i v) v)
    (defn #_"char"    RT'aset_char    [#_"char[]"    xs, #_"int" i, #_"char"    v] (aset xs i v) v)
    (defn #_"int"     RT'aset_int     [#_"int[]"     xs, #_"int" i, #_"int"     v] (aset xs i v) v)
    (defn #_"long"    RT'aset_long    [#_"long[]"    xs, #_"int" i, #_"long"    v] (aset xs i v) v)
    (defn #_"float"   RT'aset_float   [#_"float[]"   xs, #_"int" i, #_"float"   v] (aset xs i v) v)
    (defn #_"double"  RT'aset_double  [#_"double[]"  xs, #_"int" i, #_"double"  v] (aset xs i v) v)
    (defn #_"Object"  RT'aset_object  [#_"Object[]"  xs, #_"int" i, #_"Object"  v] (aset xs i v) v)

    (defn #_"int" RT'alength_boolean [#_"boolean[]" xs] (alength xs))
    (defn #_"int" RT'alength_byte    [#_"byte[]"    xs] (alength xs))
    (defn #_"int" RT'alength_short   [#_"short[]"   xs] (alength xs))
    (defn #_"int" RT'alength_char    [#_"char[]"    xs] (alength xs))
    (defn #_"int" RT'alength_int     [#_"int[]"     xs] (alength xs))
    (defn #_"int" RT'alength_long    [#_"long[]"    xs] (alength xs))
    (defn #_"int" RT'alength_float   [#_"float[]"   xs] (alength xs))
    (defn #_"int" RT'alength_double  [#_"double[]"  xs] (alength xs))
    (defn #_"int" RT'alength_object  [#_"Object[]"  xs] (alength xs))

    (defn #_"boolean[]" RT'aclone_boolean [#_"boolean[]" xs] (.clone xs))
    (defn #_"byte[]"    RT'aclone_byte    [#_"byte[]"    xs] (.clone xs))
    (defn #_"short[]"   RT'aclone_short   [#_"short[]"   xs] (.clone xs))
    (defn #_"char[]"    RT'aclone_char    [#_"char[]"    xs] (.clone xs))
    (defn #_"int[]"     RT'aclone_int     [#_"int[]"     xs] (.clone xs))
    (defn #_"long[]"    RT'aclone_long    [#_"long[]"    xs] (.clone xs))
    (defn #_"float[]"   RT'aclone_float   [#_"float[]"   xs] (.clone xs))
    (defn #_"double[]"  RT'aclone_double  [#_"double[]"  xs] (.clone xs))
    (defn #_"Object[]"  RT'aclone_object  [#_"Object[]"  xs] (.clone xs))
)
)

(java-ns cloiure.lang.Seqable

(§ defprotocol Seqable
    #_abstract
    (#_"ISeq" Seqable'''(§ method seq) [#_"Seqable" this])
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (def #_"Object" SeqIterator'START (Object.))

    (defn- #_"SeqIterator" SeqIterator'init []
        (hash-map
            #_"Object" :seq nil
            #_"Object" :next nil
        )
    )

    (defn #_"SeqIterator" SeqIterator'new [#_"Object" o]
        (let [this (SeqIterator'init)]
            (§ ass this (assoc this :seq SeqIterator'START))
            (§ ass this (assoc this :next o))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"SeqIterator" this]
        (cond (= (:seq this) SeqIterator'START)
            (do
                (§ ass this (assoc this :seq nil))
                (§ ass this (assoc this :next (RT'seq (:next this))))
            )
            (= (:seq this) (:next this))
            (do
                (§ ass this (assoc this :next (RT'next (:seq this))))
            )
        )
        (some? (:next this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"SeqIterator" this] #_(§ throws NoSuchElementException)
        (when (not (.hasNext this))
            (throw (NoSuchElementException.))
        )
        (§ ass this (assoc this :seq (:next this)))
        (RT'first (:next this))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Sequential

(§ defprotocol Sequential
)
)

(java-ns cloiure.lang.Settable

(§ defprotocol Settable
    #_abstract
    (#_"Object" Settable'''(§ method doSet) [#_"Settable" this, #_"Object" val])
    #_abstract
    (#_"Object" Settable'''(§ method doReset) [#_"Settable" this, #_"Object" val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ defprotocol Sorted
    #_abstract
    (#_"Comparator" Sorted'''(§ method comparator) [#_"Sorted" this])
    #_abstract
    (#_"Object" Sorted'''(§ method entryKey) [#_"Sorted" this, #_"Object" entry])
    #_abstract
    (#_"ISeq" Sorted'''(§ method seq) [#_"Sorted" this, #_"boolean" ascending])
    #_abstract
    (#_"ISeq" Sorted'''(§ method seqFrom) [#_"Sorted" this, #_"Object" key, #_"boolean" ascending])
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (defn #_"StringSeq" StringSeq'create [#_"CharSequence" s]
        (when (pos? (.length s))
            (StringSeq'new nil, s, 0)
        )
    )

    (defn- #_"StringSeq" StringSeq'init []
        (hash-map
            #_"CharSequence" :s nil
            #_"int" :i 0
        )
    )

    (defn #_"StringSeq" StringSeq'new [#_"IPersistentMap" meta, #_"CharSequence" s, #_"int" i]
        (let [this (merge (ASeq'new meta) (StringSeq'init))]
            (§ ass this (assoc this :s s))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"StringSeq" this, #_"IPersistentMap" meta]
        (if (= meta (.meta this))
            this
            (StringSeq'new meta, (:s this), (:i this))
        )
    )

    #_override
    (§ defn #_"Object" ISeq'''first [#_"StringSeq" this]
        (Character/valueOf (.charAt (:s this), (:i this)))
    )

    #_override
    (§ defn #_"ISeq" ISeq'''next [#_"StringSeq" this]
        (when (< (inc (:i this)) (.length (:s this)))
            (StringSeq'new (:_meta this), (:s this), (inc (:i this)))
        )
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"StringSeq" this]
        (:i this)
    )

    #_override
    (§ defn #_"int" Counted'''count [#_"StringSeq" this]
        (- (.length (:s this)) (:i this))
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (defn #_"Symbol" Symbol'create-2 [#_"String" ns, #_"String" name]
        (Symbol'intern ns, name)
    )

    (defn #_"Symbol" Symbol'create-1 [#_"String" nsname]
        (Symbol'intern nsname)
    )

    (defn #_"Symbol" Symbol'intern
        ([#_"String" nsname]
            (let [#_"int" i (.indexOf nsname, \/)]
                (if (or (= i -1) (= nsname "/"))
                    (Symbol'new-2 nil, nsname)
                    (Symbol'new-2 (.substring nsname, 0, i), (.substring nsname, (inc i)))
                )
            )
        )
        ([#_"String" ns, #_"String" name]
            (Symbol'new-2 ns, name)
        )
    )

    (defn- #_"Symbol" Symbol'init []
        (hash-map
            #_"String" :ns nil
            #_"String" :name nil
            #_"int" :_hasheq 0
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Symbol" Symbol'new-2 [#_"String" ns_interned, #_"String" name_interned]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass this (assoc this :name name_interned))
            (§ ass this (assoc this :ns ns_interned))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Symbol" this]
        (when (nil? (:_str this))
            (if (some? (:ns this))
                (do
                    (§ ass this (assoc this :_str (str (:ns this) "/" (:name this))))
                )
                (do
                    (§ ass this (assoc this :_str (:name this)))
                )
            )
        )
        (:_str this)
    )

    #_method
    (§ defn #_"String" (§ method getNamespace) [#_"Symbol" this]
        (:ns this)
    )

    #_method
    (§ defn #_"String" (§ method getName) [#_"Symbol" this]
        (:name this)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"Symbol" this, #_"Object" o]
        (cond
            (= this o)
                true
            (§ instance? Symbol o)
                (let [#_"Symbol" symbol (cast' Symbol o)]
                    (and (Util'equals (:ns this), (:ns symbol)) (.equals (:name this), (:name symbol)))
                )
            :else
                false
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Symbol" this]
        (Util'hashCombine (.hashCode (:name this)), (Util'hash (:ns this)))
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"Symbol" this]
        (when (zero? (:_hasheq this))
            (§ ass this (assoc this :_hasheq (Util'hashCombine (Murmur3'hashUnencodedChars (:name this)), (Util'hash (:ns this)))))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"Symbol" this, #_"IPersistentMap" meta]
        (Symbol'new-3 meta, (:ns this), (:name this))
    )

    (defn- #_"Symbol" Symbol'new-3 [#_"IPersistentMap" meta, #_"String" ns, #_"String" name]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass this (assoc this :name name))
            (§ ass this (assoc this :ns ns))
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Symbol" this, #_"Object" o]
        (let [#_"Symbol" s (cast' Symbol o)]
            (cond
                (.equals this, o)                       0
                (and (nil? (:ns this)) (some? (:ns s))) -1
                (nil? (:ns this))                       (.compareTo (:name this), (:name s))
                (nil? (:ns s))                          1
                :else
                    (let-when [#_"int" nsc (.compareTo (:ns this), (:ns s))] (zero? nsc) => nsc
                        (.compareTo (:name this), (:name s))
                    )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Symbol" this, #_"Object" obj]
        (RT'get-2 obj, this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Symbol" this, #_"Object" obj, #_"Object" notFound]
        (RT'get-3 obj, this, notFound)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Symbol" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (defn- #_"TransactionalHashMap" TransactionalHashMap'init []
        (hash-map
            #_"Ref[]" :bins nil
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-0 []
        (TransactionalHashMap'new-1i 421)
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1i [#_"int" nBins]
        (let [this (merge (AbstractMap'new) (TransactionalHashMap'init))]
            (§ ass this (assoc this :bins (make-array #_"Ref" Object nBins)))
            (loop-when-recur [#_"int" i 0] (< i nBins) [(inc i)]
                (aset (:bins this) i (Ref'new-1 PersistentHashMap'EMPTY))
            )
            this
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1m [#_"Map<? extends K, ? extends V>" m]
        (let [this (TransactionalHashMap'new-1i (.size m))]
            (.putAll this, m)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method mapAt) [#_"TransactionalHashMap" this, #_"int" bin]
        (cast' IPersistentMap (.deref (aget (:bins this) bin)))
    )

    #_method
    (§ defn #_"int" (§ method binFor) [#_"TransactionalHashMap" this, #_"Object" k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" h (.hashCode k)]
            (§ ass h (bit-xor h (bit-xor (>>> h 20) (>>> h 12))))
            (§ ass h (bit-xor h (bit-xor (>>> h 7) (>>> h 4))))
            (% h (alength (:bins this)))
        )
    )

    #_method
    (§ defn #_"Entry" (§ method entryAt) [#_"TransactionalHashMap" this, #_"Object" k]
        (.entryAt (.mapAt this, (.binFor this, k)), k)
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"TransactionalHashMap" this]
        (let [#_"int" n 0]
            (loop-when-recur [#_"int" i 0] (< i (alength (:bins this))) [(inc i)]
                (§ ass n (+ n (.count (.mapAt this, i))))
            )
            n
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"TransactionalHashMap" this]
        (zero? (.size this))
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"TransactionalHashMap" this, #_"Object" k]
        (some? (.entryAt this, k))
    )

    #_method
    (§ defn #_"V" (§ method get) [#_"TransactionalHashMap" this, #_"Object" k]
        (when-let [#_"Entry" e (.entryAt this, k)]
            (cast' V (.getValue e))
        )
    )

    #_method
    (§ defn #_"V" (§ method put) [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (aget (:bins this) (.binFor this, k))]
            (let [#_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
                (let [#_"Object" ret (.valAt m, k)]
                    (.set r, (.assoc m, k, v))
                    (cast' V ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method remove) [#_"TransactionalHashMap" this, #_"Object" k]
        (let [#_"Ref" r (aget (:bins this) (.binFor this, k))]
            (let [#_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
                (let [#_"Object" ret (.valAt m, k)]
                    (.set r, (.without m, k))
                    (cast' V ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method putAll) [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" m]
        (loop-when-recur [#_"Iterator" i (.iterator (.entrySet m))] (.hasNext i) [i]
            (let [#_"Entry<K, V>" e (cast' Entry (.next i))]
                (.put this, (.getKey e), (.getValue e))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"TransactionalHashMap" this]
        (loop-when-recur [#_"int" i 0] (< i (alength (:bins this))) [(inc i)]
            (let [#_"Ref" r (aget (:bins this) i)]
                (let [#_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
                    (when (pos? (.count m))
                        (.set r, PersistentHashMap'EMPTY)
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" (§ method entrySet) [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map$Entry<K, V>>" entries (ArrayList. (alength (:bins this)))]
            (loop-when-recur [#_"int" i 0] (< i (alength (:bins this))) [(inc i)]
                (let [#_"IPersistentMap" m (.mapAt this, i)]
                    (when (pos? (.count m))
                        (.addAll entries, (cast Collection (RT'seq m)))
                    )
                )
            )
            (§ reify AbstractSet<Entry<K, V>>()
                #_method
                (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet<Entry<K, V>>" this]
                    (.iterator (Collections/unmodifiableList entries))
                )

                #_method
                (§ defn #_"int" (§ method size) [#_"AbstractSet<Entry<K, V>>" this]
                    (.size entries)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method putIfAbsent) [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (aget (:bins this) (.binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
            (let-when [#_"Entry" e (.entryAt m, k)] (nil? e) => (cast' V (.getValue e))
                (.set r, (.assoc m, k, v))
                nil
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"TransactionalHashMap" this, #_"Object" k, #_"Object" v]
        (let [#_"Ref" r (aget (:bins this) (.binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
            (let-when [#_"Entry" e (.entryAt m, k)] (and (some? e) (.equals (.getValue e), v)) => false
                (.set r, (.without m, k))
                true
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method replace) [#_"TransactionalHashMap" this, #_"K" k, #_"V" oldv, #_"V" newv]
        (let [#_"Ref" r (aget (:bins this) (.binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
            (let-when [#_"Entry" e (.entryAt m, k)] (and (some? e) (.equals (.getValue e), oldv)) => false
                (.set r, (.assoc m, k, newv))
                true
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method replace) [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (aget (:bins this) (.binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (.deref r))]
            (when-let [#_"Entry" e (.entryAt m, k)]
                (.set r, (.assoc m, k, v))
                (cast' V (.getValue e))
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_private
(§ defprotocol Buffer
    #_abstract
    (#_"Buffer" Buffer'''(§ method add) [#_"Buffer" this, #_"Object" o])
    #_abstract
    (#_"Object" Buffer'''(§ method remove) [#_"Buffer" this])
    #_abstract
    (#_"boolean" Buffer'''(§ method isEmpty) [#_"Buffer" this])
)

#_private
(class-ns EmptyBuffer (§ implements Buffer)
    (defn #_"EmptyBuffer" EmptyBuffer'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"EmptyBuffer" this, #_"Object" o]
        (SingleBuffer'new o)
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"EmptyBuffer" this]
        (throw (IllegalStateException. "Removing object from empty buffer"))
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"EmptyBuffer" this]
        true
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"EmptyBuffer" this]
        "EmptyBuffer"
    )
)

#_private
(class-ns SingleBuffer (§ implements Buffer)
    (defn- #_"SingleBuffer" SingleBuffer'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"SingleBuffer" SingleBuffer'new [#_"Object" o]
        (let [this (SingleBuffer'init)]
            (§ ass this (assoc this :val o))
            this
        )
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"SingleBuffer" this, #_"Object" o]
        (if (= (:val this) TransformerIterator'NONE)
            (assoc this :val o)
            (ManyBuffer'new (:val this), o)
        )
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"SingleBuffer" this]
        (when (= (:val this) TransformerIterator'NONE)
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )
        (let [#_"Object" ret (:val this)]
            (§ ass this (assoc this :val TransformerIterator'NONE))
            ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"SingleBuffer" this]
        (= (:val this) TransformerIterator'NONE)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"SingleBuffer" this]
        (str "SingleBuffer: " (:val this))
    )
)

#_private
(class-ns ManyBuffer (§ implements Buffer)
    (defn- #_"ManyBuffer" ManyBuffer'init []
        (hash-map
            #_"Queue" :vals (LinkedList.)
        )
    )

    (defn #_"ManyBuffer" ManyBuffer'new [#_"Object" o1, #_"Object" o2]
        (let [this (ManyBuffer'init)]
            (.add (:vals this), o1)
            (.add (:vals this), o2)
            this
        )
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"ManyBuffer" this, #_"Object" o]
        (.add (:vals this), o)
        this
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"ManyBuffer" this]
        (.remove (:vals this))
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"ManyBuffer" this]
        (.isEmpty (:vals this))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ManyBuffer" this]
        (str "ManyBuffer: " (.toString (:vals this)))
    )
)

#_private
(class-ns MultiIterator (§ implements Iterator)
    (defn- #_"MultiIterator" MultiIterator'init []
        (hash-map
            #_"Iterator[]" :iters nil
        )
    )

    (defn #_"MultiIterator" MultiIterator'new [#_"Iterator[]" iters]
        (let [this (MultiIterator'init)]
            (§ ass this (assoc this :iters iters))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"MultiIterator" this]
        (doseq [#_"Iterator" iter (:iters this)]
            (when (not (.hasNext iter))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"MultiIterator" this]
        (let [#_"Object[]" nexts (make-array Object (alength (:iters this)))]
            (loop-when-recur [#_"int" i 0] (< i (alength (:iters this))) [(inc i)]
                (aset nexts i (.next (aget (:iters this) i)))
            )
            (ArraySeq'new-2 nexts, 0)
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"MultiIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransformerIterator (§ implements Iterator)
    (def- #_"Buffer" TransformerIterator'EMPTY (EmptyBuffer'new))
    (def- #_"Object" TransformerIterator'NONE (Object.))

    (defn- #_"TransformerIterator" TransformerIterator'init []
        (hash-map
            ;; Source
            #_"Iterator" :sourceIter nil
            #_"IFn" :xf nil
            #_"boolean" :multi false

            ;; Iteration state
            #_volatile
            #_"Buffer" :buffer TransformerIterator'EMPTY
            #_volatile
            #_"Object" :next TransformerIterator'NONE
            #_volatile
            #_"boolean" :completed false
        )
    )

    (defn- #_"TransformerIterator" TransformerIterator'new [#_"IFn" xform, #_"Iterator" sourceIter, #_"boolean" multi]
        (let [this (TransformerIterator'init)]
            (§ ass this (assoc this :sourceIter sourceIter))
            (§ ass this (assoc this :xf (cast' IFn (.invoke xform,
                (§ reify AFn()
                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
                        nil
                    )

                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" acc]
                        acc
                    )

                    #_method
                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" acc, #_"Object" o]
                        (§ ass this (assoc this :buffer (.add (:buffer this), o)))
                        acc
                    )
                )
            ))))
            (§ ass this (assoc this :multi multi))
            this
        )
    )

    (defn #_"Iterator" TransformerIterator'create [#_"IFn" xform, #_"Iterator" source]
        (TransformerIterator'new xform, source, false)
    )

    (defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" xform, #_"List" sources]
        (let [#_"Iterator[]" iters (make-array Iterator (.size sources))]
            (loop-when-recur [#_"int" i 0] (< i (.size sources)) [(inc i)]
                (aset iters i (cast Iterator (.get sources, i)))
            )
            (TransformerIterator'new xform, (MultiIterator'new iters), true)
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method step) [#_"TransformerIterator" this]
        (loop-when-recur [] (= (:next this) TransformerIterator'NONE) [] => true
            (if (.isEmpty (:buffer this))
                (cond
                    (:completed this)
                        (§ return false)
                    (.hasNext (:sourceIter this))
                        (let [#_"Object" it
                                (if (:multi this)
                                    (.applyTo (:xf this), (RT'cons nil, (.next (:sourceIter this))))
                                    (.invoke (:xf this), nil, (.next (:sourceIter this)))
                                )]
                            (when (RT'isReduced it)
                                (.invoke (:xf this), nil)
                                (§ ass this (assoc this :completed true))
                            )
                        )
                    :else
                    (do
                        (.invoke (:xf this), nil)
                        (§ ass this (assoc this :completed true))
                    )
                )
                (§ ass this (assoc this :next (.remove (:buffer this))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"TransformerIterator" this]
        (.step this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"TransformerIterator" this]
        (when (.hasNext this) => (throw (NoSuchElementException.))
            (let [#_"Object" ret (:next this)]
                (§ ass this (assoc this :next TransformerIterator'NONE))
                ret
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Tuple

#_stateless
(class-ns Tuple
    (def #_"int" Tuple'MAX_SIZE 6)

    (defn #_"IPersistentVector" Tuple'create
        ([] PersistentVector'EMPTY)
        ([#_"Object" v0] (RT'vector v0))
        ([#_"Object" v0, #_"Object" v1] (RT'vector v0, v1))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2] (RT'vector v0, v1, v2))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3] (RT'vector v0, v1, v2, v3))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4] (RT'vector v0, v1, v2, v3, v4))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4, #_"Object" v5] (RT'vector v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(§ defprotocol EquivPred
    #_abstract
    (#_"boolean" EquivPred'''(§ method equiv) [#_"EquivPred" this, #_"Object" k1, #_"Object" k2])
)

#_stateless
(class-ns Util
    (defn #_"boolean" Util'equiv-2oo [#_"Object" k1, #_"Object" k2]
        (cond
            (= k1 k2) true
            (nil? k1) false
            (and (instance? Number k1) (instance? Number k2)) (Numbers'equal (cast Number k1), (cast Number k2))
            (or (§ instance? IPersistentCollection k1) (§ instance? IPersistentCollection k2)) (Util'pcequiv k1, k2)
            :else (.equals k1, k2)
        )
    )

    (def #_"EquivPred" Util'equivNull
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (nil? k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivEquals
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (.equals k1, k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivNumber
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (and (instance? Number k2) (Numbers'equal (cast Number k1), (cast Number k2)))
            )
        )
    )

    (def #_"EquivPred" Util'equivColl
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (if (or (§ instance? IPersistentCollection k1) (§ instance? IPersistentCollection k2)) (Util'pcequiv k1, k2) (.equals k1, k2))
            )
        )
    )

    (defn #_"EquivPred" Util'equivPred [#_"Object" k1]
        (cond
            (nil? k1)                                          Util'equivNull
            (instance? Number k1)                              Util'equivNumber
            (or (instance? String k1) (§ instance? Symbol k1)) Util'equivEquals
            (or (instance? Collection k1) (instance? Map k1))  Util'equivColl
            :else                                              Util'equivEquals
        )
    )

    (defn #_"boolean" Util'equiv-2ll [#_"long" k1, #_"long" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2ol [#_"Object" k1, #_"long" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2lo [#_"long" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2dd [#_"double" k1, #_"double" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2od [#_"Object" k1, #_"double" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2do [#_"double" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2bb [#_"boolean" k1, #_"boolean" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2ob [#_"Object" k1, #_"boolean" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2bo [#_"boolean" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2cc [#_"char" c1, #_"char" c2]
        (= c1 c2)
    )

    (defn #_"boolean" Util'pcequiv [#_"Object" k1, #_"Object" k2]
        (if (§ instance? IPersistentCollection k1)
            (.equiv (cast' IPersistentCollection k1), k2)
            (.equiv (cast' IPersistentCollection k2), k1)
        )
    )

    (defn #_"boolean" Util'equals [#_"Object" k1, #_"Object" k2]
        (or (= k1 k2) (and (some? k1) (.equals k1, k2)))
    )

    (defn #_"boolean" Util'identical [#_"Object" k1, #_"Object" k2]
        (= k1 k2)
    )

    (defn #_"Class" Util'classOf [#_"Object" x]
        (when (some? x)
            (.getClass x)
        )
    )

    (defn #_"int" Util'compare [#_"Object" k1, #_"Object" k2]
        (cond
            (= k1 k2)             0
            (nil? k1)             -1
            (nil? k2)             1
            (instance? Number k1) (Numbers'compare (cast Number k1), (cast Number k2))
            :else                 (.compareTo (cast Comparable k1), k2)
        )
    )

    (defn #_"int" Util'hash [#_"Object" o]
        (cond
            (nil? o) 0
            :else    (.hashCode o)
        )
    )

    (defn #_"int" Util'hasheq [#_"Object" o]
        (cond
            (nil? o)                0
            (§ instance? IHashEq o) (.hasheq (cast' IHashEq o))
            (instance? Number o)    (Numbers'hasheq (cast Number o))
            (instance? String o)    (Murmur3'hashInt (.hashCode o))
            :else                   (.hashCode o)
        )
    )

    (defn #_"int" Util'hashCombine [#_"int" seed, #_"int" hash]
        ;; a la boost
        (bit-xor seed (+ hash 0x9e3779b9 (<< seed 6) (>> seed 2)))
    )

    (defn #_"boolean" Util'isPrimitive [#_"Class" c]
        (and (some? c) (.isPrimitive c) (not (= c Void/TYPE)))
    )

    (defn #_"boolean" Util'isInteger [#_"Object" x]
        (or (instance? Integer x) (instance? Long x) (§ instance? BigInt x) (instance? BigInteger x))
    )

    (defn #_"Object" Util'ret1 [#_"Object" ret, #_"Object" _nil]
        ret
    )

    (defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" rq, #_"ConcurrentHashMap<K, Reference<V>>" cache]
        ;; cleanup any dead entries
        (when (some? (.poll rq))
            (while (some? (.poll rq))
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" e (.entrySet cache)]
                (let [#_"Reference<V>" val (.getValue e)]
                    (when (and (some? val) (nil? (.get val)))
                        (.remove cache, (.getKey e), val)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (defn #_"RuntimeException" Util'sneakyThrow [#_"Throwable" t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (nil? t)
            (throw (NullPointerException.))
        )
        (Util'sneakyThrow0 #_"<RuntimeException>" t)
        nil
    )

    (defn- #_"<T extends Throwable> void" Util'sneakyThrow0 [#_"Throwable" t] #_(§ throws T)
        (throw (cast' T t))
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns TBox
    (defn- #_"TBox" TBox'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_"Thread" :thread nil
        )
    )

    (defn #_"TBox" TBox'new [#_"Thread" t, #_"Object" val]
        (let [this (TBox'init)]
            (§ ass this (assoc this :thread t))
            (§ ass this (assoc this :val val))
            this
        )
    )
)

(class-ns Unbound (§ extends AFn)
    (defn- #_"Unbound" Unbound'init []
        (hash-map
            #_"Var" :v nil
        )
    )

    (defn #_"Unbound" Unbound'new [#_"Var" v]
        (let [this (merge (AFn'new) (Unbound'init))]
            (§ ass this (assoc this :v v))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Unbound" this]
        (str "Unbound: " (:v this))
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"Unbound" this, #_"int" n]
        (throw (IllegalStateException. (str "Attempting to call unbound fn: " (:v this))))
    )
)

(class-ns Frame
    (§ def #_"Frame" Frame'TOP (Frame'new PersistentHashMap'EMPTY, nil))

    (defn- #_"Frame" Frame'init []
        (hash-map
            ;; Var->TBox
            #_"Associative" :bindings nil
            ;; Var->val
            #_"Frame" :prev nil
        )
    )

    (defn #_"Frame" Frame'new [#_"Associative" bindings, #_"Frame" prev]
        (let [this (Frame'init)]
            (§ ass this (assoc this :bindings bindings))
            (§ ass this (assoc this :prev prev))
            this
        )
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method clone) [#_"Frame" this]
        (Frame'new (:bindings this), nil)
    )
)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (def #_"ThreadLocal<Frame>" Var'dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_method
            (§ defn #_"Frame" (§ method initialValue) [#_"ThreadLocal<Frame>" this]
                Frame'TOP
            )
        )
    )

    #_volatile
    (def #_"int" Var'rev 0)

    (§ def #_"Keyword" Var'privateKey (Keyword'intern (Symbol'intern nil, "private")))
    (§ def #_"IPersistentMap" Var'privateMeta (PersistentArrayMap'new-1 (object-array [ privateKey, Boolean/TRUE ])))
    (§ def #_"Keyword" Var'macroKey (Keyword'intern (Symbol'intern nil, "macro")))
    (§ def #_"Keyword" Var'nameKey (Keyword'intern (Symbol'intern nil, "name")))
    (§ def #_"Keyword" Var'nsKey (Keyword'intern (Symbol'intern nil, "ns")))

    (defn #_"Object" Var'getThreadBindingFrame []
        (.get Var'dvals)
    )

    (defn #_"Object" Var'cloneThreadBindingFrame []
        (.clone (.get Var'dvals))
    )

    (defn #_"void" Var'resetThreadBindingFrame [#_"Object" frame]
        (.set Var'dvals, (cast' Frame frame))
        nil
    )

    (defn #_"Var" Var'intern
        ([#_"Namespace" ns, #_"Symbol" sym]
            (.intern ns, sym)
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
            (Var'intern ns, sym, root, true)
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root, #_"boolean" replaceRoot]
            (let [#_"Var" v (.intern ns, sym)]
                (when (or (not (.hasRoot v)) replaceRoot)
                    (.bindRoot v, root)
                )
                v
            )
        )
    )

    (defn #_"Var" Var'internPrivate [#_"String" nsName, #_"String" sym]
        (let [#_"Namespace" ns (Namespace'findOrCreate (Symbol'intern nsName)) #_"Var" v (Var'intern ns, (Symbol'intern sym))]
            (.setMeta v, Var'privateMeta)
            v
        )
    )

    (defn #_"Var" Var'find [#_"Symbol" nsQualifiedSym]
        (when (some? (:ns nsQualifiedSym)) => (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
            (let [#_"Namespace" ns (Namespace'find (Symbol'intern (:ns nsQualifiedSym)))]
                (when (some? ns) => (throw (IllegalArgumentException. (str "No such namespace: " (:ns nsQualifiedSym))))
                    (.findInternedVar ns, (Symbol'intern (:name nsQualifiedSym)))
                )
            )
        )
    )

    (defn #_"Var" Var'create
        ([               ] (Var'new nil, nil      ))
        ([#_"Object" root] (Var'new nil, nil, root))
    )

    (defn- #_"Var" Var'init []
        (hash-map
            #_"Namespace" :ns nil
            #_"Symbol" :sym nil
            #_volatile
            #_"Object" :root nil
            #_volatile
            #_"boolean" :dynamic false
            #_transient
            #_"AtomicBoolean" :threadBound nil
        )
    )

    (defn #_"Var" Var'new
        ([#_"Namespace" ns, #_"Symbol" sym]
            (let [this (merge (ARef'new-0) (Var'init))]
                (§ ass this (assoc this :ns ns))
                (§ ass this (assoc this :sym sym))
                (§ ass this (assoc this :threadBound (AtomicBoolean. false)))
                (§ ass this (assoc this :root (Unbound'new this)))
                (.setMeta this, PersistentHashMap'EMPTY)
                this
            )
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
            (let [this (Var'new ns, sym)]
                (§ ass this (assoc this :root root))
                (§ ass Var'rev (inc Var'rev))
                this
            )
        )
    )

    #_method
    (§ defn #_"Var" (§ method setDynamic) [#_"Var" this]
        (assoc this :dynamic true)
    )

    #_method
    (§ defn #_"Var" (§ method setDynamic) [#_"Var" this, #_"boolean" b]
        (assoc this :dynamic b)
    )

    #_method
    (§ defn #_"boolean" (§ method isDynamic) [#_"Var" this]
        (:dynamic this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Var" this]
        (if (some? (:ns this))
            (str "#'" (:name (:ns this)) "/" (:sym this))
            (str "#<Var: " (if (some? (:sym this)) (.toString (:sym this)) "--unnamed--") ">")
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isBound) [#_"Var" this]
        (or (.hasRoot this) (and (.get (:threadBound this)) (.containsKey (:bindings (.get Var'dvals)), this)))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"Var" this]
        (if (.get (:threadBound this)) (.deref this) (:root this))
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Var" this]
        (let [#_"TBox" b (.getThreadBinding this)]
            (if (some? b) (:val b) (:root this))
        )
    )

    #_method
    (§ defn #_"void" (§ method setValidator) [#_"Var" this, #_"IFn" vf]
        (when (.hasRoot this)
            (.validate this, vf, (:root this))
        )
        (§ ass this (assoc this :validator vf))
        nil
    )

    #_method
    (§ defn #_"Object" (§ method alter) [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (.set this, (.applyTo fn, (RT'cons (.deref this), args)))
        this
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"Var" this, #_"Object" val]
        (.validate this, (.getValidator this), val)
        (let [#_"TBox" b (.getThreadBinding this)]
            (when (some? b) => (throw (IllegalStateException. (str "Can't change/establish root binding of: " (:sym this) " with set")))
                (when (= (Thread/currentThread) (:thread b)) => (throw (IllegalStateException. (str "Can't set!: " (:sym this) " from non-binding thread")))
                    (§ ass b (assoc b :val val))
                    val
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method doSet) [#_"Var" this, #_"Object" val]
        (.set this, val)
    )

    #_method
    (§ defn #_"Object" (§ method doReset) [#_"Var" this, #_"Object" val]
        (.bindRoot this, val)
        val
    )

    #_method
    (§ defn #_"void" (§ method setMeta) [#_"Var" this, #_"IPersistentMap" m]
        ;; ensure these basis keys
        (.resetMeta this, (-> m (.assoc nameKey, (:sym this)) (.assoc nsKey, (:ns this))))
        nil
    )

    #_method
    (§ defn #_"void" (§ method setMacro) [#_"Var" this]
        (.alterMeta this, Var'assoc, (RT'list-2 macroKey, RT'T))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isMacro) [#_"Var" this]
        (RT'booleanCast-1o (.valAt (.meta this), macroKey))
    )

    #_method
    (§ defn #_"boolean" (§ method isPublic) [#_"Var" this]
        (not (RT'booleanCast-1o (.valAt (.meta this), privateKey)))
    )

    #_method
    (§ defn #_"Object" (§ method getRawRoot) [#_"Var" this]
        (:root this)
    )

    #_method
    (§ defn #_"Object" (§ method getTag) [#_"Var" this]
        (.valAt (.meta this), RT'TAG_KEY)
    )

    #_method
    (§ defn #_"void" (§ method setTag) [#_"Var" this, #_"Symbol" tag]
        (.alterMeta this, Var'assoc, (RT'list-2 RT'TAG_KEY, tag))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasRoot) [#_"Var" this]
        (not (§ instance? Unbound (:root this)))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" (§ method bindRoot) [#_"Var" this, #_"Object" root]
        (§ sync this
            (.validate this, (.getValidator this), root)
            (let [#_"Object" oldroot (:root this)]
                (§ ass this (assoc this :root root))
                (§ ass Var'rev (inc Var'rev))
                (.alterMeta this, Var'dissoc, (RT'list-1 macroKey))
                (.notifyWatches this, oldroot, (:root this))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method swapRoot) [#_"Var" this, #_"Object" root]
        (§ sync this
            (.validate this, (.getValidator this), root)
            (let [#_"Object" oldroot (:root this)]
                (§ ass this (assoc this :root root))
                (§ ass Var'rev (inc Var'rev))
                (.notifyWatches this, oldroot, root)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method unbindRoot) [#_"Var" this]
        (§ sync this
            (§ ass this (assoc this :root (Unbound'new this)))
            (§ ass Var'rev (inc Var'rev))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method commuteRoot) [#_"Var" this, #_"IFn" fn]
        (§ sync this
            (let [#_"Object" newRoot (.invoke fn, (:root this))]
                (.validate this, (.getValidator this), newRoot)
                (let [#_"Object" oldroot (:root this)]
                    (§ ass this (assoc this :root newRoot))
                    (§ ass Var'rev (inc Var'rev))
                    (.notifyWatches this, oldroot, newRoot)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method alterRoot) [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (§ sync this
            (let [#_"Object" newRoot (.applyTo fn, (RT'cons (:root this), args))]
                (.validate this, (.getValidator this), newRoot)
                (let [#_"Object" oldroot (:root this)]
                    (§ ass this (assoc this :root newRoot))
                    (§ ass Var'rev (inc Var'rev))
                    (.notifyWatches this, oldroot, newRoot)
                    newRoot
                )
            )
        )
    )

    (defn #_"void" Var'pushThreadBindings [#_"Associative" bindings]
        (let [#_"Frame" f (.get Var'dvals)]
            (loop-when [#_"Associative" m (:bindings f) #_"ISeq" s (.seq bindings)] (some? s) => (.set Var'dvals, (Frame'new m, f))
                (let [#_"IMapEntry" e (cast' IMapEntry (.first s)) #_"Var" v (cast' Var (.key e))]
                    (when-not (:dynamic v)
                        (throw (IllegalStateException. (str "Can't dynamically bind non-dynamic var: " (:ns v) "/" (:sym v))))
                    )
                    (.validate v, (.getValidator v), (.val e))
                    (.set (:threadBound v), true)
                    (recur (.assoc m, v, (TBox'new (Thread/currentThread), (.val e))) (.next s))
                )
            )
        )
        nil
    )

    (defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" f (:prev (.get Var'dvals))]
            (cond
                (nil? f)        (throw (IllegalStateException. "Pop without matching push"))
                (= f Frame'TOP) (.remove Var'dvals)
                :else           (.set Var'dvals, f)
            )
        )
        nil
    )

    (defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" f (.get Var'dvals)]
            (loop-when [#_"IPersistentMap" m PersistentHashMap'EMPTY #_"ISeq" s (.seq (:bindings f))] (some? s) => m
                (let [#_"IMapEntry" e (cast' IMapEntry (.first s)) #_"Var" v (cast' Var (.key e)) #_"TBox" b (cast' TBox (.val e))]
                    (recur (.assoc m, v, (:val b)) (.next s))
                )
            )
        )
    )

    #_method
    (§ defn #_"TBox" (§ method getThreadBinding) [#_"Var" this]
        (when (.get (:threadBound this))
            (when-let [#_"IMapEntry" e (.entryAt (:bindings (.get Var'dvals)), this)]
                (cast' TBox (.val e))
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fn) [#_"Var" this]
        (cast' IFn (.deref this))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Var" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Var" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this]
        (.invoke (.fn this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1]
        (.invoke (.fn this), (Util'ret1 arg1, (§ ass arg1 nil)))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (.invoke (.fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil)),
            (§ cast Object[] (Util'ret1 args, (§ ass args nil)))
        )
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Var" this, #_"ISeq" args]
        (.applyTo (.fn this), args)
    )

    (def #_"IFn" Var'assoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" m, #_"Object" k, #_"Object" v]
                (RT'assoc m, k, v)
            )
        )
    )

    (def #_"IFn" Var'dissoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" c, #_"Object" k]
                (RT'dissoc c, k)
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (defn- #_"Volatile" Volatile'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"Volatile" Volatile'new [#_"Object" val]
        (let [this (Volatile'init)]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Volatile" this]
        (:val this)
    )

    #_method
    (§ defn #_"Object" (§ method reset) [#_"Volatile" this, #_"Object" newval]
        (§ ass this (assoc this :val newval))
        newval
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" main'CLOIURE_MAIN (Symbol'intern "cloiure.main"))
    (§ def- #_"Var" main'REQUIRE (RT'var "cloiure.core", "require"))
    (§ def- #_"Var" main'MAIN (RT'var "cloiure.main", "main"))

    (defn #_"void" -main [#_"String[]" args]
        (.invoke main'REQUIRE, main'CLOIURE_MAIN)
        (.applyTo main'MAIN, (RT'seq args))
        nil
    )
)
)
