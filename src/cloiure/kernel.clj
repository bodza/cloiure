(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(§ java cloiure.lang.AFn

public abstract class AFn implements IFn
(§
    public Object call()
    (§
        return invoke()
    )

    public void run()
    (§
        invoke()
    )

    public Object invoke()
    (§
        return throwArity(0)
    )

    public Object invoke(Object arg1)
    (§
        return throwArity(1)
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        return throwArity(2)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        return throwArity(3)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        return throwArity(4)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        return throwArity(5)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        return throwArity(6)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        return throwArity(7)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        return throwArity(8)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        return throwArity(9)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        return throwArity(10)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        return throwArity(11)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        return throwArity(12)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        return throwArity(13)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        return throwArity(14)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        return throwArity(15)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        return throwArity(16)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        return throwArity(17)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        return throwArity(18)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        return throwArity(19)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        return throwArity(20)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        return throwArity(21)
    )

    public Object applyTo(ISeq arglist)
    (§
        return applyToHelper(this, Util.ret1(arglist, arglist = null))
    )

    static public Object applyToHelper(IFn ifn, ISeq arglist)
    (§
        switch (RT.boundedLength(arglist, 20))
        (§
            (§ case 0)
                arglist = null
                return ifn.invoke()
            (§ case 1)
                return ifn.invoke(Util.ret1(arglist.first(), arglist = null))
            (§ case 2)
                return ifn.invoke(arglist.first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 3)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 4)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 5)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 6)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 7)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 8)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 9)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 10)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 11)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 12)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 13)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 14)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 15)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 16)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 17)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 18)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 19)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ case 20)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = null))
            (§ default)
                return ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        RT.seqToArray(Util.ret1(arglist.next(), arglist = null)))
        )
    )

    public Object throwArity(int n)
    (§
        String name = getClass().getSimpleName()
        throw new ArityException(n, Compiler.demunge(name))
    )
)
)

(§ java cloiure.lang.AFunction

import java.io.Serializable
import java.util.Comparator

public abstract class AFunction extends AFn implements IObj, Comparator, Fn, Serializable
(§
    public volatile MethodImplCache __methodImplCache

    public IPersistentMap meta()
    (§
        return null
    )

    public IObj withMeta(final IPersistentMap meta)
    (§
        return new RestFn()
        (§
            protected Object doInvoke(Object args)
            (§
                return AFunction.this.applyTo((ISeq) args)
            )

            public IPersistentMap meta()
            (§
                return meta
            )

            public IObj withMeta(IPersistentMap meta)
            (§
                return AFunction.this.withMeta(meta)
            )

            public int getRequiredArity()
            (§
                return 0
            )
        )
    )

    public int compare(Object o1, Object o2)
    (§
        Object o = invoke(o1, o2)

        if (o instanceof Boolean)
        (§
            if (RT.booleanCast(o))
            (§
                return -1
            )
            return RT.booleanCast(invoke(o2, o1)) ? 1 :or 0
        )

        Number n = (Number) o
        return n.intValue()
    )
)
)

(§ java cloiure.lang.Agent

import java.util.concurrent.Executor
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.ThreadFactory
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.atomic.AtomicReference

public class Agent extends ARef
(§
    static class ActionQueue
    (§
        public final IPersistentStack q
        public final Throwable error ;; non-null indicates fail state
        static final ActionQueue EMPTY = new ActionQueue(PersistentQueue.EMPTY, null)

        public ActionQueue(IPersistentStack q, Throwable error)
        (§
            this.q = q
            this.error = error
        )
    )

    static final Keyword CONTINUE = Keyword.intern(null, "continue")
    static final Keyword FAIL = Keyword.intern(null, "fail")

    volatile Object state
    AtomicReference<ActionQueue> aq = new AtomicReference<ActionQueue>(ActionQueue.EMPTY)

    volatile Keyword errorMode = CONTINUE
    volatile IFn errorHandler = null

    final private static AtomicLong sendThreadPoolCounter = new AtomicLong(0)

    final private static AtomicLong sendOffThreadPoolCounter = new AtomicLong(0)

    volatile public static ExecutorService pooledExecutor = Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))

    volatile public static ExecutorService soloExecutor = Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))

    final static ThreadLocal<IPersistentVector> nested = new ThreadLocal<IPersistentVector>()

    private static ThreadFactory createThreadFactory(final String format, final AtomicLong threadPoolCounter)
    (§
        return new ThreadFactory()
        (§
            public Thread newThread(Runnable runnable)
            (§
                Thread thread = new Thread(runnable)
                thread.setName(String.format(format, threadPoolCounter.getAndIncrement()))
                return thread
            )
        )
    )

    public static void shutdown()
    (§
        soloExecutor.shutdown()
        pooledExecutor.shutdown()
    )

    static class Action implements Runnable
    (§
        final Agent agent
        final IFn fn
        final ISeq args
        final Executor exec

        public Action(Agent agent, IFn fn, ISeq args, Executor exec)
        (§
            this.agent = agent
            this.args = args
            this.fn = fn
            this.exec = exec
        )

        void execute()
        (§
            try
            (§
                exec.execute(this)
            )
            catch (Throwable error)
            (§
                if (agent.errorHandler != null)
                (§
                    try
                    (§
                        agent.errorHandler.invoke(agent, error)
                    )
                    catch (Throwable e) ;; ignore errorHandler errors
                    (§
                    )
                )
            )
        )

        static void doRun(Action action)
        (§
            try
            (§
                nested.set(PersistentVector.EMPTY)

                Throwable error = null
                try
                (§
                    Object oldval = action.agent.state
                    Object newval =  action.fn.applyTo(RT.cons(action.agent.state, action.args))
                    action.agent.setState(newval)
                    action.agent.notifyWatches(oldval, newval)
                )
                catch (Throwable e)
                (§
                    error = e
                )

                if (error == null)
                (§
                    releasePendingSends()
                )
                else
                (§
                    nested.set(null) ;; allow errorHandler to send
                    if (action.agent.errorHandler != null)
                    (§
                        try
                        (§
                            action.agent.errorHandler.invoke(action.agent, error)
                        )
                        catch (Throwable e) ;; ignore errorHandler errors
                        (§
                        )
                    )
                    if (action.agent.errorMode == CONTINUE)
                    (§
                        error = null
                    )
                )

                boolean popped = false
                ActionQueue next = null
                while (!popped)
                (§
                    ActionQueue prior = action.agent.aq.get()
                    next = new ActionQueue(prior.q.pop(), error)
                    popped = action.agent.aq.compareAndSet(prior, next)
                )

                if (error == null && next.q.count() > 0)
                (§
                    ((Action) next.q.peek()).execute()
                )
            )
            finally
            (§
                nested.set(null)
            )
        )

        public void run()
        (§
            doRun(this)
        )
    )

    public Agent(Object state)
    (§
        this(state, null)
    )

    public Agent(Object state, IPersistentMap meta)
    (§
        super(meta)
        setState(state)
    )

    boolean setState(Object newState)
    (§
        validate(newState)
        boolean ret = (state != newState)
        state = newState
        return ret
    )

    public Object deref()
    (§
        return state
    )

    public Throwable getError()
    (§
        return aq.get().error
    )

    public void setErrorMode(Keyword k)
    (§
        errorMode = k
    )

    public Keyword getErrorMode()
    (§
        return errorMode
    )

    public void setErrorHandler(IFn f)
    (§
        errorHandler = f
    )

    public IFn getErrorHandler()
    (§
        return errorHandler
    )

    synchronized public Object restart(Object newState, boolean clearActions)
    (§
        if (getError() == null)
        (§
            throw Util.runtimeException("Agent does not need a restart")
        )
        validate(newState)
        state = newState

        if (clearActions)
        (§
            aq.set(ActionQueue.EMPTY)
        )
        else
        (§
            boolean restarted = false
            ActionQueue prior = null
            while (!restarted)
            (§
                prior = aq.get()
                restarted = aq.compareAndSet(prior, new ActionQueue(prior.q, null))
            )

            if (prior.q.count() > 0)
            (§
                ((Action) prior.q.peek()).execute()
            )
        )

        return newState
    )

    public Object dispatch(IFn fn, ISeq args, Executor exec)
    (§
        Throwable error = getError()
        if (error != null)
        (§
            throw Util.runtimeException("Agent is failed, needs restart", error)
        )
        Action action = new Action(this, fn, args, exec)
        dispatchAction(action)

        return this
    )

    static void dispatchAction(Action action)
    (§
        LockingTransaction trans = LockingTransaction.getRunning()
        if (trans != null)
        (§
            trans.enqueue(action)
        )
        else if (nested.get() != null)
        (§
            nested.set(nested.get().cons(action))
        )
        else
        (§
            action.agent.enqueue(action)
        )
    )

    void enqueue(Action action)
    (§
        boolean queued = false
        ActionQueue prior = null
        while (!queued)
        (§
            prior = aq.get()
            queued = aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error))
        )

        if (prior.q.count() == 0 && prior.error == null)
        (§
            action.execute()
        )
    )

    public int getQueueCount()
    (§
        return aq.get().q.count()
    )

    static public int releasePendingSends()
    (§
        IPersistentVector sends = nested.get()
        if (sends == null)
        (§
            return 0
        )
        for (int i = 0 i < sends.count() i++)
        (§
            Action a = (Action) sends.valAt(i)
            a.agent.enqueue(a)
        )
        nested.set(PersistentVector.EMPTY)
        return sends.count()
    )
)
)

(§ java cloiure.lang.AMapEntry

import java.io.StringWriter

public abstract class AMapEntry extends APersistentVector implements IMapEntry
(§
    public Object nth(int i)
    (§
        if (i == 0)
        (§
            return key()
        )
        else if (i == 1)
        (§
            return val()
        )
        else
        (§
            throw new IndexOutOfBoundsException()
        )
    )

    private IPersistentVector asVector()
    (§
        return LazilyPersistentVector.createOwning(key(), val())
    )

    public IPersistentVector assocN(int i, Object val)
    (§
        return asVector().assocN(i, val)
    )

    public int count()
    (§
        return 2
    )

    public ISeq seq()
    (§
        return asVector().seq()
    )

    public IPersistentVector cons(Object o)
    (§
        return asVector().cons(o)
    )

    public IPersistentCollection empty()
    (§
        return null
    )

    public IPersistentStack pop()
    (§
        return LazilyPersistentVector.createOwning(key())
    )

    public Object setValue(Object value)
    (§
        throw new UnsupportedOperationException()
    )
)
)

(§ java cloiure.lang.APersistentMap

import java.io.Serializable
import java.util.*

public abstract class APersistentMap extends AFn implements IPersistentMap, Map, Iterable, Serializable, MapEquivalence, IHashEq
(§
    int _hash
    int _hasheq

    public String toString()
    (§
        return RT.printString(this)
    )

    public IPersistentCollection cons(Object o)
    (§
        if (o instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) o

            return assoc(e.getKey(), e.getValue())
        )
        else if (o instanceof IPersistentVector)
        (§
            IPersistentVector v = (IPersistentVector) o
            if (v.count() != 2)
            (§
                throw new IllegalArgumentException("Vector arg to map conj must be a pair")
            )
            return assoc(v.nth(0), v.nth(1))
        )

        IPersistentMap ret = this
        for (ISeq es = RT.seq(o) es != null es = es.next())
        (§
            Map.Entry e = (Map.Entry) es.first()
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        return ret
    )

    public boolean equals(Object obj)
    (§
        return mapEquals(this, obj)
    )

    static public boolean mapEquals(IPersistentMap m1, Object obj)
    (§
        if (m1 == obj)
        (§
            return true
        )
        if (!(obj instanceof Map))
        (§
            return false
        )
        Map m = (Map) obj

        if (m.size() != m1.count())
        (§
            return false
        )

        for (ISeq s = m1.seq() s != null s = s.next())
        (§
            Map.Entry e = (Map.Entry) s.first()
            boolean found = m.containsKey(e.getKey())

            if (!found || !Util.equals(e.getValue(), m.get(e.getKey())))
            (§
                return false
            )
        )

        return true
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Map))
        (§
            return false
        )
        if (obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
        (§
            return false
        )

        Map m = (Map) obj

        if (m.size() != size())
        (§
            return false
        )

        for (ISeq s = seq() s != null s = s.next())
        (§
            Map.Entry e = (Map.Entry) s.first()
            boolean found = m.containsKey(e.getKey())

            if (!found || !Util.equiv(e.getValue(), m.get(e.getKey())))
            (§
                return false
            )
        )

        return true
    )

    public int hashCode()
    (§
        int cached = this._hash
        if (cached == 0)
        (§
            this._hash = cached = mapHash(this)
        )
        return cached
    )

    static public int mapHash(IPersistentMap m)
    (§
        int hash = 0
        for (ISeq s = m.seq() s != null s = s.next())
        (§
            Map.Entry e = (Map.Entry) s.first()
            hash += ((e.getKey() == null) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == null) ? 0 :or e.getValue().hashCode())
        )
        return hash
    )

    public int hasheq()
    (§
        int cached = this._hasheq
        if (cached == 0)
        (§
            this._hasheq = cached = Murmur3.hashUnordered(this)
        )
        return cached
    )

    static public int mapHasheq(IPersistentMap m)
    (§
        return Murmur3.hashUnordered(m)
    )

    static public class KeySeq extends ASeq
    (§
        final ISeq seq
        final Iterable iterable

        static public KeySeq create(ISeq seq)
        (§
            if (seq == null)
            (§
                return null
            )
            return new KeySeq(seq, null)
        )

        static public KeySeq createFromMap(IPersistentMap map)
        (§
            if (map == null)
            (§
                return null
            )
            ISeq seq = map.seq()
            if (seq == null)
            (§
                return null
            )
            return new KeySeq(seq, map)
        )

        private KeySeq(ISeq seq, Iterable iterable)
        (§
            this.seq = seq
            this.iterable = iterable
        )

        private KeySeq(IPersistentMap meta, ISeq seq, Iterable iterable)
        (§
            super(meta)
            this.seq = seq
            this.iterable = iterable
        )

        public Object first()
        (§
            return ((Map.Entry) seq.first()).getKey()
        )

        public ISeq next()
        (§
            return create(seq.next())
        )

        public KeySeq withMeta(IPersistentMap meta)
        (§
            return new KeySeq(meta, seq, iterable)
        )

        public Iterator iterator()
        (§
            if (iterable == null)
            (§
                return super.iterator()
            )

            if (iterable instanceof IMapIterable)
            (§
                return ((IMapIterable)iterable).keyIterator()
            )

            final Iterator mapIter = iterable.iterator()
            return new Iterator()
            (§
                public boolean hasNext()
                (§
                    return mapIter.hasNext()
                )

                public Object next()
                (§
                    return ((Map.Entry)mapIter.next()).getKey()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )
    )

    static public class ValSeq extends ASeq
    (§
        final ISeq seq
        final Iterable iterable

        static public ValSeq create(ISeq seq)
        (§
            if (seq == null)
            (§
                return null
            )
            return new ValSeq(seq, null)
        )

        static public ValSeq createFromMap(IPersistentMap map)
        (§
            if (map == null)
            (§
                return null
            )
            ISeq seq = map.seq()
            if (seq == null)
            (§
                return null
            )
            return new ValSeq(seq, map)
        )

        private ValSeq(ISeq seq, Iterable iterable)
        (§
            this.seq = seq
            this.iterable = iterable
        )

        private ValSeq(IPersistentMap meta, ISeq seq, Iterable iterable)
        (§
            super(meta)
            this.seq = seq
            this.iterable = iterable
        )

        public Object first()
        (§
            return ((Map.Entry) seq.first()).getValue()
        )

        public ISeq next()
        (§
            return create(seq.next())
        )

        public ValSeq withMeta(IPersistentMap meta)
        (§
            return new ValSeq(meta, seq, iterable)
        )

        public Iterator iterator()
        (§
            if (iterable == null)
            (§
                return super.iterator()
            )

            if (iterable instanceof IMapIterable)
            (§
                return ((IMapIterable)iterable).valIterator()
            )

            final Iterator mapIter = iterable.iterator()
            return new Iterator()
            (§
                public boolean hasNext()
                (§
                    return mapIter.hasNext()
                )

                public Object next()
                (§
                    return ((Map.Entry)mapIter.next()).getValue()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )
    )

    static final IFn MAKE_ENTRY = new AFn()
    (§
        public Object invoke(Object key, Object val)
        (§
            return MapEntry.create(key, val)
        )
    )

    static final IFn MAKE_KEY = new AFn()
    (§
        public Object invoke(Object key, Object val)
        (§
            return key
        )
    )

    static final IFn MAKE_VAL = new AFn()
    (§
        public Object invoke(Object key, Object val)
        (§
            return val
        )
    )

    public Object invoke(Object arg1)
    (§
        return valAt(arg1)
    )

    public Object invoke(Object arg1, Object notFound)
    (§
        return valAt(arg1, notFound)
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsValue(Object value)
    (§
        return values().contains(value)
    )

    public Set entrySet()
    (§
        return new AbstractSet()
        (§
            public Iterator iterator()
            (§
                return APersistentMap.this.iterator()
            )

            public int size()
            (§
                return count()
            )

            public int hashCode()
            (§
                return APersistentMap.this.hashCode()
            )

            public boolean contains(Object o)
            (§
                if (o instanceof Entry)
                (§
                    Entry e = (Entry) o
                    Entry found = entryAt(e.getKey())
                    if (found != null && Util.equals(found.getValue(), e.getValue()))
                    (§
                        return true
                    )
                )
                return false
            )
        )
    )

    public Object get(Object key)
    (§
        return valAt(key)
    )

    public boolean isEmpty()
    (§
        return (count() == 0)
    )

    public Set keySet()
    (§
        return new AbstractSet()
        (§
            public Iterator iterator()
            (§
                final Iterator mi = APersistentMap.this.iterator()

                return new Iterator()
                (§
                    public boolean hasNext()
                    (§
                        return mi.hasNext()
                    )

                    public Object next()
                    (§
                        Entry e = (Entry) mi.next()
                        return e.getKey()
                    )

                    public void remove()
                    (§
                        throw new UnsupportedOperationException()
                    )
                )
            )

            public int size()
            (§
                return count()
            )

            public boolean contains(Object o)
            (§
                return APersistentMap.this.containsKey(o)
            )
        )
    )

    public Object put(Object key, Object value)
    (§
        throw new UnsupportedOperationException()
    )

    public void putAll(Map t)
    (§
        throw new UnsupportedOperationException()
    )

    public Object remove(Object key)
    (§
        throw new UnsupportedOperationException()
    )

    public int size()
    (§
        return count()
    )

    public Collection values()
    (§
        return new AbstractCollection()
        (§
            public Iterator iterator()
            (§
                final Iterator mi = APersistentMap.this.iterator()

                return new Iterator()
                (§
                    public boolean hasNext()
                    (§
                        return mi.hasNext()
                    )

                    public Object next()
                    (§
                        Entry e = (Entry) mi.next()
                        return e.getValue()
                    )

                    public void remove()
                    (§
                        throw new UnsupportedOperationException()
                    )
                )
            )

            public int size()
            (§
                return count()
            )
        )
    )
)
)

(§ java cloiure.lang.APersistentSet

import java.io.Serializable
import java.util.Collection
import java.util.Iterator
import java.util.Set

public abstract class APersistentSet extends AFn implements IPersistentSet, Collection, Set, Serializable, IHashEq
(§
    int _hash
    int _hasheq
    final IPersistentMap impl

    protected APersistentSet(IPersistentMap impl)
    (§
        this.impl = impl
    )

    public String toString()
    (§
        return RT.printString(this)
    )

    public boolean contains(Object key)
    (§
        return impl.containsKey(key)
    )

    public Object get(Object key)
    (§
        return impl.valAt(key)
    )

    public int count()
    (§
        return impl.count()
    )

    public ISeq seq()
    (§
        return RT.keys(impl)
    )

    public Object invoke(Object arg1)
    (§
        return get(arg1)
    )

    public boolean equals(Object obj)
    (§
        return setEquals(this, obj)
    )

    static public boolean setEquals(IPersistentSet s1, Object obj)
    (§
        if (s1 == obj)
        (§
            return true
        )
        if (!(obj instanceof Set))
        (§
            return false
        )
        Set m = (Set) obj

        if (m.size() != s1.count())
        (§
            return false
        )

        for (Object aM :in m)
        (§
            if (!s1.contains(aM))
            (§
                return false
            )
        )

        return true
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Set))
        (§
            return false
        )

        Set m = (Set) obj

        if (m.size() != size())
        (§
            return false
        )

        for (Object aM :in m)
        (§
            if (!contains(aM))
            (§
                return false
            )
        )

        return true
    )

    public int hashCode()
    (§
        int hash = this._hash
        if (hash == 0)
        (§
            for (ISeq s = seq() s != null s = s.next())
            (§
                Object e = s.first()
                hash +=  Util.hash(e)
            )
            this._hash = hash
        )
        return hash
    )

    public int hasheq()
    (§
        int cached = this._hasheq
        if (cached == 0)
        (§
            this._hasheq = cached = Murmur3.hashUnordered(this)
        )
        return cached
    )

    public Object[] toArray()
    (§
        return RT.seqToArray(seq())
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                return false
            )
        )
        return true
    )

    public Object[] toArray(Object[] a)
    (§
        return RT.seqToPassedArray(seq(), a)
    )

    public int size()
    (§
        return count()
    )

    public boolean isEmpty()
    (§
        return (count() == 0)
    )

    public Iterator iterator()
    (§
        if (impl instanceof IMapIterable)
        (§
            return ((IMapIterable)impl).keyIterator()
        )
        else
        (§
            return new Iterator()
            (§
                private final Iterator iter = impl.iterator()

                public boolean hasNext()
                (§
                    return iter.hasNext()
                )

                public Object next()
                (§
                    return ((IMapEntry)iter.next()).key()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )
    )
)
)

(§ java cloiure.lang.APersistentVector

import java.io.Serializable
import java.util.*

public abstract class APersistentVector extends AFn implements IPersistentVector, Iterable, List, RandomAccess, Comparable, Serializable, IHashEq
(§
    int _hash
    int _hasheq

    public String toString()
    (§
        return RT.printString(this)
    )

    public ISeq seq()
    (§
        if (count() > 0)
        (§
            return new Seq(this, 0)
        )
        return null
    )

    public ISeq rseq()
    (§
        if (count() > 0)
        (§
            return new RSeq(this, count() - 1)
        )
        return null
    )

    static boolean doEquals(IPersistentVector v, Object obj)
    (§
        if (obj instanceof IPersistentVector)
        (§
            IPersistentVector ov = (IPersistentVector) obj
            if (ov.count() != v.count())
            (§
                return false
            )
            for (int i = 0 i < v.count() i++)
            (§
                if (!Util.equals(v.nth(i), ov.nth(i)))
                (§
                    return false
                )
            )
            return true
        )
        else if (obj instanceof List)
        (§
            Collection ma = (Collection) obj
            if (ma.size() != v.count() || ma.hashCode() != v.hashCode())
            (§
                return false
            )
            for (Iterator i1 = ((List) v).iterator(), i2 = ma.iterator() i1.hasNext() )
            (§
                if (!Util.equals(i1.next(), i2.next()))
                (§
                    return false
                )
            )
            return true
        )
        else
        (§
            if (!(obj instanceof Sequential))
            (§
                return false
            )
            ISeq ms = RT.seq(obj)
            for (int i = 0 i < v.count() i++, ms = ms.next())
            (§
                if (ms == null || !Util.equals(v.nth(i), ms.first()))
                (§
                    return false
                )
            )
            if (ms != null)
            (§
                return false
            )
        )

        return true
    )

    static boolean doEquiv(IPersistentVector v, Object obj)
    (§
        if (obj instanceof IPersistentVector)
        (§
            IPersistentVector ov = (IPersistentVector) obj
            if (ov.count() != v.count())
            (§
                return false
            )
            for (int i = 0 i < v.count() i++)
            (§
                if (!Util.equiv(v.nth(i), ov.nth(i)))
                (§
                    return false
                )
            )
            return true
        )
        else if (obj instanceof List)
        (§
            Collection ma = (Collection) obj
            if (ma.size() != v.count())
            (§
                return false
            )
            for (Iterator i1 = ((List) v).iterator(), i2 = ma.iterator() i1.hasNext() )
            (§
                if (!Util.equiv(i1.next(), i2.next()))
                (§
                    return false
                )
            )
            return true
        )
        else
        (§
            if (!(obj instanceof Sequential))
            (§
                return false
            )
            ISeq ms = RT.seq(obj)
            for (int i = 0 i < v.count() i++, ms = ms.next())
            (§
                if (ms == null || !Util.equiv(v.nth(i), ms.first()))
                (§
                    return false
                )
            )
            if (ms != null)
            (§
                return false
            )
        )

        return true
    )

    public boolean equals(Object obj)
    (§
        if (obj == this)
        (§
            return true
        )
        return doEquals(this, obj)
    )

    public boolean equiv(Object obj)
    (§
        if (obj == this)
        (§
            return true
        )
        return doEquiv(this, obj)
    )

    public int hashCode()
    (§
        int hash = this._hash
        if (hash == 0)
        (§
            hash = 1
            for (int i = 0 i < count() i++)
            (§
                Object obj = nth(i)
                hash = 31 * hash + ((obj == null) ? 0 :or obj.hashCode())
            )
            this._hash = hash
        )
        return hash
    )

    public int hasheq()
    (§
        int hash = this._hasheq
        if (hash == 0)
        (§
            int n
            hash = 1

            for (n = 0 n < count() ++n)
            (§
                hash = 31 * hash + Util.hasheq(nth(n))
            )

            this._hasheq = hash = Murmur3.mixCollHash(hash, n)
        )
        return hash
    )

    public Object get(int index)
    (§
        return nth(index)
    )

    public Object nth(int i, Object notFound)
    (§
        if (i >= 0 && i < count())
        (§
            return nth(i)
        )
        return notFound
    )

    public Object remove(int i)
    (§
        throw new UnsupportedOperationException()
    )

    public int indexOf(Object o)
    (§
        for (int i = 0 i < count() i++)
        (§
            if (Util.equiv(nth(i), o))
            (§
                return i
            )
        )
        return -1
    )

    public int lastIndexOf(Object o)
    (§
        for (int i = count() - 1 i >= 0 i--)
        (§
            if (Util.equiv(nth(i), o))
            (§
                return i
            )
        )
        return -1
    )

    public ListIterator listIterator()
    (§
        return listIterator(0)
    )

    public ListIterator listIterator(final int index)
    (§
        return new ListIterator()
        (§
            int nexti = index

            public boolean hasNext()
            (§
                return (nexti < count())
            )

            public Object next()
            (§
                if (nexti < count())
                (§
                    return nth(nexti++)
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public boolean hasPrevious()
            (§
                return (nexti > 0)
            )

            public Object previous()
            (§
                if (nexti > 0)
                (§
                    return nth(--nexti)
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public int nextIndex()
            (§
                return nexti
            )

            public int previousIndex()
            (§
                return nexti - 1
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )

            public void set(Object o)
            (§
                throw new UnsupportedOperationException()
            )

            public void add(Object o)
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    Iterator rangedIterator(final int start, final int end)
    (§
        return new Iterator()
        (§
            int i = start

            public boolean hasNext()
            (§
                return (i < end)
            )

            public Object next()
            (§
                if (i < end)
                (§
                    return nth(i++)
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    public List subList(int fromIndex, int toIndex)
    (§
        return (List) RT.subvec(this, fromIndex, toIndex)
    )

    public Object set(int i, Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public void add(int i, Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(int i, Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public Object invoke(Object arg1)
    (§
        if (Util.isInteger(arg1))
        (§
            return nth(((Number) arg1).intValue())
        )
        throw new IllegalArgumentException("Key must be integer")
    )

    public Iterator iterator()
    (§
        ;; todo - something more efficient
        return new Iterator()
        (§
            int i = 0

            public boolean hasNext()
            (§
                return (i < count())
            )

            public Object next()
            (§
                if (i < count())
                (§
                    return nth(i++)
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    public Object peek()
    (§
        if (count() > 0)
        (§
            return nth(count() - 1)
        )
        return null
    )

    public boolean containsKey(Object key)
    (§
        if (!(Util.isInteger(key)))
        (§
            return false
        )
        int i = ((Number) key).intValue()
        return (i >= 0 && i < count())
    )

    public IMapEntry entryAt(Object key)
    (§
        if (Util.isInteger(key))
        (§
            int i = ((Number) key).intValue()
            if (i >= 0 && i < count())
            (§
                return (IMapEntry) MapEntry.create(key, nth(i))
            )
        )
        return null
    )

    public IPersistentVector assoc(Object key, Object val)
    (§
        if (Util.isInteger(key))
        (§
            int i = ((Number) key).intValue()
            return assocN(i, val)
        )
        throw new IllegalArgumentException("Key must be integer")
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (Util.isInteger(key))
        (§
            int i = ((Number) key).intValue()
            if (i >= 0 && i < count())
            (§
                return nth(i)
            )
        )
        return notFound
    )

    public Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public Object[] toArray()
    (§
        Object[] ret = new Object[count()]
        for (int i = 0 i < count() i++)
        (§
            ret[i] = nth(i)
        )
        return ret
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                return false
            )
        )
        return true
    )

    public Object[] toArray(Object[] a)
    (§
        return RT.seqToPassedArray(seq(), a)
    )

    public int size()
    (§
        return count()
    )

    public boolean isEmpty()
    (§
        return (count() == 0)
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != null s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                return true
            )
        )
        return false
    )

    public int length()
    (§
        return count()
    )

    public int compareTo(Object o)
    (§
        IPersistentVector v = (IPersistentVector) o
        if (count() < v.count())
        (§
            return -1
        )
        else if (count() > v.count())
        (§
            return 1
        )
        for (int i = 0 i < count() i++)
        (§
            int c = Util.compare(nth(i), v.nth(i))
            if (c != 0)
            (§
                return c
            )
        )
        return 0
    )

    static class Seq extends ASeq implements IndexedSeq, IReduce
    (§
        ;; todo - something more efficient
        final IPersistentVector v
        final int i

        public Seq(IPersistentVector v, int i)
        (§
            this.v = v
            this.i = i
        )

        Seq(IPersistentMap meta, IPersistentVector v, int i)
        (§
            super(meta)
            this.v = v
            this.i = i
        )

        public Object first()
        (§
            return v.nth(i)
        )

        public ISeq next()
        (§
            if (i + 1 < v.count())
            (§
                return new APersistentVector.Seq(v, i + 1)
            )
            return null
        )

        public int index()
        (§
            return i
        )

        public int count()
        (§
            return v.count() - i
        )

        public APersistentVector.Seq withMeta(IPersistentMap meta)
        (§
            return new APersistentVector.Seq(meta, v, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = v.nth(i)
            for (int x = i + 1 x < v.count() x++)
            (§
                ret = f.invoke(ret, v.nth(x))
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, v.nth(i))
            for (int x = i + 1 x < v.count() x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, v.nth(x))
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )
    )

    public static class RSeq extends ASeq implements IndexedSeq, Counted
    (§
        final IPersistentVector v
        final int i

        public RSeq(IPersistentVector vector, int i)
        (§
            this.v = vector
            this.i = i
        )

        RSeq(IPersistentMap meta, IPersistentVector v, int i)
        (§
            super(meta)
            this.v = v
            this.i = i
        )

        public Object first()
        (§
            return v.nth(i)
        )

        public ISeq next()
        (§
            if (i > 0)
            (§
                return new APersistentVector.RSeq(v, i - 1)
            )
            return null
        )

        public int index()
        (§
            return i
        )

        public int count()
        (§
            return i + 1
        )

        public APersistentVector.RSeq withMeta(IPersistentMap meta)
        (§
            return new APersistentVector.RSeq(meta, v, i)
        )
    )

    public static class SubVector extends APersistentVector implements IObj
    (§
        public final IPersistentVector v
        public final int start
        public final int end
        final IPersistentMap _meta

        public SubVector(IPersistentMap meta, IPersistentVector v, int start, int end)
        (§
            this._meta = meta

            if (v instanceof APersistentVector.SubVector)
            (§
                APersistentVector.SubVector sv = (APersistentVector.SubVector) v
                start += sv.start
                end += sv.start
                v = sv.v
            )
            this.v = v
            this.start = start
            this.end = end
        )

        public Iterator iterator()
        (§
            if (v instanceof APersistentVector)
            (§
                return ((APersistentVector)v).rangedIterator(start, end)
            )
            return super.iterator()
        )

        public Object nth(int i)
        (§
            if ((start + i >= end) || (i < 0))
            (§
                throw new IndexOutOfBoundsException()
            )
            return v.nth(start + i)
        )

        public IPersistentVector assocN(int i, Object val)
        (§
            if (start + i > end)
            (§
                throw new IndexOutOfBoundsException()
            )
            else if (start + i == end)
            (§
                return cons(val)
            )
            return new SubVector(_meta, v.assocN(start + i, val), start, end)
        )

        public int count()
        (§
            return end - start
        )

        public IPersistentVector cons(Object o)
        (§
            return new SubVector(_meta, v.assocN(end, o), start, end + 1)
        )

        public IPersistentCollection empty()
        (§
            return PersistentVector.EMPTY.withMeta(meta())
        )

        public IPersistentStack pop()
        (§
            if (end - 1 == start)
            (§
                return PersistentVector.EMPTY
            )
            return new SubVector(_meta, v, start, end - 1)
        )

        public SubVector withMeta(IPersistentMap meta)
        (§
            if (meta == _meta)
            (§
                return this
            )
            return new SubVector(meta, v, start, end)
        )

        public IPersistentMap meta()
        (§
            return _meta
        )
    )
)
)

(§ java cloiure.lang.ARef

import java.util.Map

public abstract class ARef extends AReference implements IRef
(§
    protected volatile IFn validator = null
    private volatile IPersistentMap watches = PersistentHashMap.EMPTY

    public ARef()
    (§
        super()
    )

    public ARef(IPersistentMap meta)
    (§
        super(meta)
    )

    void validate(IFn vf, Object val)
    (§
        try
        (§
            if (vf != null && !RT.booleanCast(vf.invoke(val)))
            (§
                throw new IllegalStateException("Invalid reference state")
            )
        )
        catch (RuntimeException re)
        (§
            throw re
        )
        catch (Exception e)
        (§
            throw new IllegalStateException("Invalid reference state", e)
        )
    )

    void validate(Object val)
    (§
        validate(validator, val)
    )

    public void setValidator(IFn vf)
    (§
        validate(vf, deref())
        validator = vf
    )

    public IFn getValidator()
    (§
        return validator
    )

    public IPersistentMap getWatches()
    (§
        return watches
    )

    synchronized public IRef addWatch(Object key, IFn callback)
    (§
        watches = watches.assoc(key, callback)
        return this
    )

    synchronized public IRef removeWatch(Object key)
    (§
        watches = watches.without(key)
        return this
    )

    public void notifyWatches(Object oldval, Object newval)
    (§
        IPersistentMap ws = watches
        if (ws.count() > 0)
        (§
            for (ISeq s = ws.seq() s != null s = s.next())
            (§
                Map.Entry e = (Map.Entry) s.first()
                IFn fn = (IFn) e.getValue()
                if (fn != null)
                (§
                    fn.invoke(e.getKey(), this, oldval, newval)
                )
            )
        )
    )
)
)

(§ java cloiure.lang.AReference

public class AReference implements IReference
(§
    private IPersistentMap _meta

    public AReference()
    (§
        this(null)
    )

    public AReference(IPersistentMap meta)
    (§
        _meta = meta
    )

    synchronized public IPersistentMap meta()
    (§
        return _meta
    )

    synchronized public IPersistentMap alterMeta(IFn alter, ISeq args)
    (§
        _meta = (IPersistentMap) alter.applyTo(new Cons(_meta, args))
        return _meta
    )

    synchronized public IPersistentMap resetMeta(IPersistentMap m)
    (§
        _meta = m
        return m
    )
)
)

(§ java cloiure.lang.ArityException

public class ArityException extends IllegalArgumentException
(§
    final public int actual

    final public String name

    public ArityException(int actual, String name)
    (§
        this(actual, name, null)
    )

    public ArityException(int actual, String name, Throwable cause)
    (§
        super("Wrong number of args (" + actual + ") passed to: " + name, cause)
        this.actual = actual
        this.name = name
    )
)
)

(§ java cloiure.lang.ArrayChunk

import java.io.Serializable

public final class ArrayChunk implements IChunk, Serializable
(§
    final Object[] array
    final int off
    final int end

    public ArrayChunk(Object[] array)
    (§
        this(array, 0, array.length)
    )

    public ArrayChunk(Object[] array, int off)
    (§
        this(array, off, array.length)
    )

    public ArrayChunk(Object[] array, int off, int end)
    (§
        this.array = array
        this.off = off
        this.end = end
    )

    public Object nth(int i)
    (§
        return array[off + i]
    )

    public Object nth(int i, Object notFound)
    (§
        if (i >= 0 && i < count())
        (§
            return nth(i)
        )
        return notFound
    )

    public int count()
    (§
        return end - off
    )

    public IChunk dropFirst()
    (§
        if (off == end)
        (§
            throw new IllegalStateException("dropFirst of empty chunk")
        )
        return new ArrayChunk(array, off + 1, end)
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = f.invoke(start, array[off])
        if (RT.isReduced(ret))
        (§
            return ret
        )
        for (int x = off + 1 x < end x++)
        (§
            ret = f.invoke(ret, array[x])
            if (RT.isReduced(ret))
            (§
                return ret
            )
        )
        return ret
    )
)
)

(§ java cloiure.lang.ArrayIter

import java.lang.reflect.Array
import java.util.Iterator

public class ArrayIter implements Iterator
(§
    final Object[] array
    int i

    static public Iterator EMPTY_ITERATOR = new Iterator()
    (§
        public boolean hasNext() (§ return false )
        public Object next() (§ throw new java.util.NoSuchElementException() )
        public void remove() (§ throw new UnsupportedOperationException("remove() not supported") )
    )

    static public Iterator create()
    (§
        return EMPTY_ITERATOR
    )

    static public Iterator create(Object... array)
    (§
        if (array == null || array.length == 0)
        (§
            return EMPTY_ITERATOR
        )
        return new ArrayIter(array, 0)
    )

    static public Iterator createFromObject(Object array)
    (§
        if (array == null || Array.getLength(array) == 0)
        (§
            return EMPTY_ITERATOR
        )
        Class aclass = array.getClass()
        if (aclass == int[].class)
        (§
            return new ArrayIter_int((int[]) array, 0)
        )
        if (aclass == float[].class)
        (§
            return new ArrayIter_float((float[]) array, 0)
        )
        if (aclass == double[].class)
        (§
            return new ArrayIter_double((double[]) array, 0)
        )
        if (aclass == long[].class)
        (§
            return new ArrayIter_long((long[]) array, 0)
        )
        if (aclass == byte[].class)
        (§
            return new ArrayIter_byte((byte[]) array, 0)
        )
        if (aclass == char[].class)
        (§
            return new ArrayIter_char((char[]) array, 0)
        )
        if (aclass == short[].class)
        (§
            return new ArrayIter_short((short[]) array, 0)
        )
        if (aclass == boolean[].class)
        (§
            return new ArrayIter_boolean((boolean[]) array, 0)
        )
        return new ArrayIter(array, 0)
    )

    ArrayIter(Object array, int i)
    (§
        this.i = i
        this.array = (Object[]) array
    )

    public boolean hasNext()
    (§
        return (array != null && i < array.length)
    )

    public Object next()
    (§
        if (array != null && i < array.length)
        (§
            return array[i++]
        )
        throw new java.util.NoSuchElementException()
    )

    public void remove()
    (§
        throw new UnsupportedOperationException("remove() not supported")
    )

    static public class ArrayIter_int implements Iterator<Long>
    (§
        final int[] array
        int i

        ArrayIter_int(int[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Long next()
        (§
            if (array != null && i < array.length)
            (§
                return Long.valueOf(array[i++])
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_float implements Iterator<Double>
    (§
        final float[] array
        int i

        ArrayIter_float(float[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Double next()
        (§
            if (array != null && i < array.length)
            (§
                return Double.valueOf(array[i++])
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_double implements Iterator<Double>
    (§
        final double[] array
        int i

        ArrayIter_double(double[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Double next()
        (§
            if (array != null && i < array.length)
            (§
                return array[i++]
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_long implements Iterator<Long>
    (§
        final long[] array
        int i

        ArrayIter_long(long[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Long next()
        (§
            if (array != null && i < array.length)
            (§
                return Long.valueOf(array[i++])
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_byte implements Iterator<Byte>
    (§
        final byte[] array
        int i

        ArrayIter_byte(byte[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Byte next()
        (§
            if (array != null && i < array.length)
            (§
                return array[i++]
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_char implements Iterator<Character>
    (§
        final char[] array
        int i

        ArrayIter_char(char[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Character next()
        (§
            if (array != null && i < array.length)
            (§
                return array[i++]
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_short implements Iterator<Long>
    (§
        final short[] array
        int i

        ArrayIter_short(short[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Long next()
        (§
            if (array != null && i < array.length)
            (§
                return Long.valueOf(array[i++])
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_boolean implements Iterator<Boolean>
    (§
        final boolean[] array
        int i

        ArrayIter_boolean(boolean[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            return (array != null && i < array.length)
        )

        public Boolean next()
        (§
            if (array != null && i < array.length)
            (§
                return Boolean.valueOf(array[i++])
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )
)
)

(§ java cloiure.lang.ArraySeq

import java.lang.reflect.Array

public class ArraySeq extends ASeq implements IndexedSeq, IReduce
(§
    public final Object[] array
    final int i

    static public ArraySeq create()
    (§
        return null
    )

    static public ArraySeq create(Object... array)
    (§
        if (array == null || array.length == 0)
        (§
            return null
        )
        return new ArraySeq(array, 0)
    )

    static ISeq createFromObject(Object array)
    (§
        if (array == null || Array.getLength(array) == 0)
        (§
            return null
        )
        Class aclass = array.getClass()
        if (aclass == int[].class)
        (§
            return new ArraySeq_int(null, (int[]) array, 0)
        )
        if (aclass == float[].class)
        (§
            return new ArraySeq_float(null, (float[]) array, 0)
        )
        if (aclass == double[].class)
        (§
            return new ArraySeq_double(null, (double[]) array, 0)
        )
        if (aclass == long[].class)
        (§
            return new ArraySeq_long(null, (long[]) array, 0)
        )
        if (aclass == byte[].class)
        (§
            return new ArraySeq_byte(null, (byte[]) array, 0)
        )
        if (aclass == char[].class)
        (§
            return new ArraySeq_char(null, (char[]) array, 0)
        )
        if (aclass == short[].class)
        (§
            return new ArraySeq_short(null, (short[]) array, 0)
        )
        if (aclass == boolean[].class)
        (§
            return new ArraySeq_boolean(null, (boolean[]) array, 0)
        )
        return new ArraySeq(array, 0)
    )

    ArraySeq(Object array, int i)
    (§
        this.i = i
        this.array = (Object[]) array
    )

    ArraySeq(IPersistentMap meta, Object array, int i)
    (§
        super(meta)
        this.i = i
        this.array = (Object[]) array
    )

    public Object first()
    (§
        if (array != null)
        (§
            return array[i]
        )
        return null
    )

    public ISeq next()
    (§
        if (array != null && i + 1 < array.length)
        (§
            return new ArraySeq(array, i + 1)
        )
        return null
    )

    public int count()
    (§
        if (array != null)
        (§
            return array.length - i
        )
        return 0
    )

    public int index()
    (§
        return i
    )

    public ArraySeq withMeta(IPersistentMap meta)
    (§
        return new ArraySeq(meta, array, i)
    )

    public Object reduce(IFn f)
    (§
        if (array != null)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )
        return null
    )

    public Object reduce(IFn f, Object start)
    (§
        if (array != null)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )
        return null
    )

    public int indexOf(Object o)
    (§
        if (array != null)
        (§
            for (int j = i j < array.length j++)
            (§
                if (Util.equals(o, array[j]))
                (§
                    return j - i
                )
            )
        )
        return -1
    )

    public int lastIndexOf(Object o)
    (§
        if (array != null)
        (§
            if (o == null)
            (§
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (array[j] == null)
                    (§
                        return j - i
                    )
                )
            )
            else
            (§
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (o.equals(array[j]))
                    (§
                        return j - i
                    )
                )
            )
        )
        return -1
    )

    static public class ArraySeq_int extends ASeq implements IndexedSeq, IReduce
    (§
        public final int[] array
        final int i

        ArraySeq_int(IPersistentMap meta, int[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return array[i]
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_int(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_int withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_int(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                int k = ((Number) o).intValue()
                for (int j = i j < array.length j++)
                (§
                    if (k == array[j])
                    (§
                        return j - i
                    )
                )
            )

            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                int k = ((Number) o).intValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (k == array[j])
                    (§
                        return j - i
                    )
                )
            )

            return -1
        )
    )

    static public class ArraySeq_float extends ASeq implements IndexedSeq, IReduce
    (§
        public final float[] array
        final int i

        ArraySeq_float(IPersistentMap meta, float[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return Numbers.num(array[i])
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_float(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_float withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_float(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = Numbers.num(array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, Numbers.num(array[x]))
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, Numbers.num(array[i]))
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, Numbers.num(array[x]))
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                float f = ((Number) o).floatValue()
                for (int j = i j < array.length j++)
                (§
                    if (f == array[j])
                    (§
                        return j - i
                    )
                )
            )
            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                float f = ((Number) o).floatValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (f == array[j])
                    (§
                        return j - i
                    )
                )
            )
            return -1
        )
    )

    static public class ArraySeq_double extends ASeq implements IndexedSeq, IReduce
    (§
        public final double[] array
        final int i

        ArraySeq_double(IPersistentMap meta, double[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return array[i]
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_double(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_double withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_double(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                double d = ((Number) o).doubleValue()
                for (int j = i j < array.length j++)
                (§
                    if (d == array[j])
                    (§
                        return j - i
                    )
                )
            )

            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                double d = ((Number) o).doubleValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (d == array[j])
                    (§
                        return j - i
                    )
                )
            )

            return -1
        )
    )

    static public class ArraySeq_long extends ASeq implements IndexedSeq, IReduce
    (§
        public final long[] array
        final int i

        ArraySeq_long(IPersistentMap meta, long[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return Numbers.num(array[i])
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_long(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_long withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_long(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = Numbers.num(array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, Numbers.num(array[x]))
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, Numbers.num(array[i]))
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, Numbers.num(array[x]))
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                long l = ((Number) o).longValue()
                for (int j = i j < array.length j++)
                (§
                    if (l == array[j])
                    (§
                        return j - i
                    )
                )
            )

            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                long l = ((Number) o).longValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (l == array[j])
                    (§
                        return j - i
                    )
                )
            )

            return -1
        )
    )

    static public class ArraySeq_byte extends ASeq implements IndexedSeq, IReduce
    (§
        public final byte[] array
        final int i

        ArraySeq_byte(IPersistentMap meta, byte[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return array[i]
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_byte(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_byte withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_byte(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Byte)
            (§
                byte b = ((Byte) o).byteValue()
                for (int j = i j < array.length j++)
                (§
                    if (b == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Byte)
            (§
                byte b = ((Byte) o).byteValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (b == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )
    )

    static public class ArraySeq_char extends ASeq implements IndexedSeq, IReduce
    (§
        public final char[] array
        final int i

        ArraySeq_char(IPersistentMap meta, char[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return array[i]
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_char(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_char withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_char(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Character)
            (§
                char c = ((Character) o).charValue()
                for (int j = i j < array.length j++)
                (§
                    if (c == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Character)
            (§
                char c = ((Character) o).charValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (c == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )
    )

    static public class ArraySeq_short extends ASeq implements IndexedSeq, IReduce
    (§
        public final short[] array
        final int i

        ArraySeq_short(IPersistentMap meta, short[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return array[i]
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_short(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_short withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_short(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Short)
            (§
                short s = ((Short) o).shortValue()
                for (int j = i j < array.length j++)
                (§
                    if (s == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Short)
            (§
                short s = ((Short) o).shortValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (s == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )
    )

    static public class ArraySeq_boolean extends ASeq implements IndexedSeq, IReduce
    (§
        public final boolean[] array
        final int i

        ArraySeq_boolean(IPersistentMap meta, boolean[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return array[i]
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                return new ArraySeq_boolean(meta(), array, i + 1)
            )
            return null
        )

        public int count()
        (§
            return array.length - i
        )

        public int index()
        (§
            return i
        )

        public ArraySeq_boolean withMeta(IPersistentMap meta)
        (§
            return new ArraySeq_boolean(meta, array, i)
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            return ret
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Boolean)
            (§
                boolean b = ((Boolean) o).booleanValue()
                for (int j = i j < array.length j++)
                (§
                    if (b == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Boolean)
            (§
                boolean b = ((Boolean) o).booleanValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (b == array[j])
                    (§
                        return j - i
                    )
                )
            )
            if (o == null)
            (§
                return -1
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    return j - i
                )
            )
            return -1
        )
    )
)
)

(§ java cloiure.lang.ASeq

import java.io.Serializable
import java.util.*

public abstract class ASeq extends Obj implements ISeq, Sequential, List, Serializable, IHashEq
(§
    transient int _hash
    transient int _hasheq

    public String toString()
    (§
        return RT.printString(this)
    )

    public IPersistentCollection empty()
    (§
        return PersistentList.EMPTY
    )

    protected ASeq(IPersistentMap meta)
    (§
        super(meta)
    )

    protected ASeq()
    (§
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Sequential || obj instanceof List))
        (§
            return false
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != null s = s.next(), ms = ms.next())
        (§
            if (ms == null || !Util.equiv(s.first(), ms.first()))
            (§
                return false
            )
        )
        return (ms == null)
    )

    public boolean equals(Object obj)
    (§
        if (this == obj)
        (§
            return true
        )
        if (!(obj instanceof Sequential || obj instanceof List))
        (§
            return false
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != null s = s.next(), ms = ms.next())
        (§
            if (ms == null || !Util.equals(s.first(), ms.first()))
            (§
                return false
            )
        )
        return (ms == null)
    )

    public int hashCode()
    (§
        if (_hash == 0)
        (§
            int hash = 1
            for (ISeq s = seq() s != null s = s.next())
            (§
                hash = 31 * hash + ((s.first() == null) ? 0 :or s.first().hashCode())
            )
            this._hash = hash
        )
        return _hash
    )

    public int hasheq()
    (§
        if (_hasheq == 0)
        (§
            _hasheq  = Murmur3.hashOrdered(this)
        )
        return _hasheq
    )

    public int count()
    (§
        int i = 1
        for (ISeq s = next() s != null s = s.next(), i++)
        (§
            if (s instanceof Counted)
            (§
                return i + s.count()
            )
        )
        return i
    )

    final public ISeq seq()
    (§
        return this
    )

    public ISeq cons(Object o)
    (§
        return new Cons(o, this)
    )

    public ISeq more()
    (§
        ISeq s = next()
        if (s == null)
        (§
            return PersistentList.EMPTY
        )
        return s
    )

    public Object[] toArray()
    (§
        return RT.seqToArray(seq())
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                return false
            )
        )
        return true
    )

    public Object[] toArray(Object[] a)
    (§
        return RT.seqToPassedArray(seq(), a)
    )

    public int size()
    (§
        return count()
    )

    public boolean isEmpty()
    (§
        return (seq() == null)
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != null s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                return true
            )
        )
        return false
    )

    public Iterator iterator()
    (§
        return new SeqIterator(this)
    )

    private List reify()
    (§
        return Collections.unmodifiableList(new ArrayList(this))
    )

    public List subList(int fromIndex, int toIndex)
    (§
        return reify().subList(fromIndex, toIndex)
    )

    public Object set(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public Object remove(int index)
    (§
        throw new UnsupportedOperationException()
    )

    public int indexOf(Object o)
    (§
        ISeq s = seq()
        for (int i = 0 s != null s = s.next(), i++)
        (§
            if (Util.equiv(s.first(), o))
            (§
                return i
            )
        )
        return -1
    )

    public int lastIndexOf(Object o)
    (§
        return reify().lastIndexOf(o)
    )

    public ListIterator listIterator()
    (§
        return reify().listIterator()
    )

    public ListIterator listIterator(int index)
    (§
        return reify().listIterator(index)
    )

    public Object get(int index)
    (§
        return RT.nth(this, index)
    )

    public void add(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(int index, Collection c)
    (§
        throw new UnsupportedOperationException()
    )
)
)

(§ java cloiure.lang.Associative

public interface Associative extends IPersistentCollection, ILookup
(§
    boolean containsKey(Object key)

    IMapEntry entryAt(Object key)

    Associative assoc(Object key, Object val)
)
)

(§ java cloiure.lang.Atom

import java.util.concurrent.atomic.AtomicReference

final public class Atom extends ARef implements IAtom2
(§
    final AtomicReference state

    public Atom(Object state)
    (§
        this.state = new AtomicReference(state)
    )

    public Atom(Object state, IPersistentMap meta)
    (§
        super(meta)
        this.state = new AtomicReference(state)
    )

    public Object deref()
    (§
        return state.get()
    )

    public Object swap(IFn f)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.invoke(v)
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                return newv
            )
        )
    )

    public Object swap(IFn f, Object arg)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.invoke(v, arg)
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                return newv
            )
        )
    )

    public Object swap(IFn f, Object arg1, Object arg2)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.invoke(v, arg1, arg2)
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                return newv
            )
        )
    )

    public Object swap(IFn f, Object x, Object y, ISeq args)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.applyTo(RT.listStar(v, x, y, args))
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                return newv
            )
        )
    )

    public IPersistentVector swapVals(IFn f)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.invoke(oldv)
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                return LazilyPersistentVector.createOwning(oldv, newv)
            )
        )
    )

    public IPersistentVector swapVals(IFn f, Object arg)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.invoke(oldv, arg)
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                return LazilyPersistentVector.createOwning(oldv, newv)
            )
        )
    )

    public IPersistentVector swapVals(IFn f, Object arg1, Object arg2)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.invoke(oldv, arg1, arg2)
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                return LazilyPersistentVector.createOwning(oldv, newv)
            )
        )
    )

    public IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.applyTo(RT.listStar(oldv, x, y, args))
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                return LazilyPersistentVector.createOwning(oldv, newv)
            )
        )
    )

    public boolean compareAndSet(Object oldv, Object newv)
    (§
        validate(newv)
        boolean ret = state.compareAndSet(oldv, newv)
        if (ret)
        (§
            notifyWatches(oldv, newv)
        )
        return ret
    )

    public Object reset(Object newval)
    (§
        Object oldval = state.get()
        validate(newval)
        state.set(newval)
        notifyWatches(oldval, newval)
        return newval
    )

    public IPersistentVector resetVals(Object newv)
    (§
        validate(newv)
        while (true)
        (§
            Object oldv = deref()
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                return LazilyPersistentVector.createOwning(oldv, newv)
            )
        )
    )
)
)

(§ java cloiure.lang.ATransientMap

import java.util.Map

import cloiure.lang.PersistentHashMap.INode

public abstract class ATransientMap extends AFn implements ITransientMap, ITransientAssociative2
(§
    abstract void ensureEditable()
    abstract ITransientMap doAssoc(Object key, Object val)
    abstract ITransientMap doWithout(Object key)
    abstract Object doValAt(Object key, Object notFound)
    abstract int doCount()
    abstract IPersistentMap doPersistent()

    public ITransientMap conj(Object o)
    (§
        ensureEditable()
        if (o instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) o

            return assoc(e.getKey(), e.getValue())
        )
        else if (o instanceof IPersistentVector)
        (§
            IPersistentVector v = (IPersistentVector) o
            if (v.count() != 2)
            (§
                throw new IllegalArgumentException("Vector arg to map conj must be a pair")
            )
            return assoc(v.nth(0), v.nth(1))
        )

        ITransientMap ret = this
        for (ISeq es = RT.seq(o) es != null es = es.next())
        (§
            Map.Entry e = (Map.Entry) es.first()
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        return ret
    )

    public final Object invoke(Object arg1)
    (§
        return valAt(arg1)
    )

    public final Object invoke(Object arg1, Object notFound)
    (§
        return valAt(arg1, notFound)
    )

    public final Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public final ITransientMap assoc(Object key, Object val)
    (§
        ensureEditable()
        return doAssoc(key, val)
    )

    public final ITransientMap without(Object key)
    (§
        ensureEditable()
        return doWithout(key)
    )

    public final IPersistentMap persistent()
    (§
        ensureEditable()
        return doPersistent()
    )

    public final Object valAt(Object key, Object notFound)
    (§
        ensureEditable()
        return doValAt(key, notFound)
    )

    private static final Object NOT_FOUND = new Object()
    public final boolean containsKey(Object key)
    (§
        return (valAt(key, NOT_FOUND) != NOT_FOUND)
    )
    public final IMapEntry entryAt(Object key)
    (§
        Object v = valAt(key, NOT_FOUND)
        if (v != NOT_FOUND)
        (§
            return MapEntry.create(key, v)
        )
        return null
    )

    public final int count()
    (§
        ensureEditable()
        return doCount()
    )
)
)

(§ java cloiure.lang.ATransientSet

public abstract class ATransientSet extends AFn implements ITransientSet
(§
    volatile ITransientMap impl

    ATransientSet(ITransientMap impl)
    (§
        this.impl = impl
    )

    public int count()
    (§
        return impl.count()
    )

    public ITransientSet conj(Object val)
    (§
        ITransientMap m = impl.assoc(val, val)
        if (m != impl)
        (§
            this.impl = m
        )
        return this
    )

    public boolean contains(Object key)
    (§
        return (this != impl.valAt(key, this))
    )

    public ITransientSet disjoin(Object key)
    (§
        ITransientMap m = impl.without(key)
        if (m != impl)
        (§
            this.impl = m
        )
        return this
    )

    public Object get(Object key)
    (§
        return impl.valAt(key)
    )

    public Object invoke(Object key, Object notFound)
    (§
        return impl.valAt(key, notFound)
    )

    public Object invoke(Object key)
    (§
        return impl.valAt(key)
    )
)
)

(§ java cloiure.lang.BigInt

import java.math.BigInteger
import java.math.BigDecimal

public final class BigInt extends Number implements IHashEq
(§
    final public long lpart
    final public BigInteger bipart

    final public static BigInt ZERO = new BigInt(0, null)
    final public static BigInt ONE = new BigInt(1, null)

    ;; must follow Long
    public int hashCode()
    (§
        if (bipart == null)
        (§
            return (int) (this.lpart :xor (this.lpart >>> 32))
        )
        return bipart.hashCode()
    )

    public int hasheq()
    (§
        if (bipart == null)
        (§
            return Murmur3.hashLong(lpart)
        )
        return bipart.hashCode()
    )

    public boolean equals(Object obj)
    (§
        if (this == obj)
        (§
            return true
        )
        if (obj instanceof BigInt)
        (§
            BigInt o = (BigInt) obj
            if (bipart == null)
            (§
                return (o.bipart == null && this.lpart == o.lpart)
            )
            return (o.bipart != null && this.bipart.equals(o.bipart))
        )
        return false
    )

    private BigInt(long lpart, BigInteger bipart)
    (§
        this.lpart = lpart
        this.bipart = bipart
    )

    public static BigInt fromBigInteger(BigInteger val)
    (§
        if (val.bitLength() < 64)
        (§
            return new BigInt(val.longValue(), null)
        )
        else
        (§
            return new BigInt(0, val)
        )
    )

    public static BigInt fromLong(long val)
    (§
        return new BigInt(val, null)
    )

    public BigInteger toBigInteger()
    (§
        if (bipart == null)
        (§
            return BigInteger.valueOf(lpart)
        )
        else
        (§
            return bipart
        )
    )

    public BigDecimal toBigDecimal()
    (§
        if (bipart == null)
        (§
            return BigDecimal.valueOf(lpart)
        )
        else
        (§
            return new BigDecimal(bipart)
        )
    )

    public int intValue()
    (§
        if (bipart == null)
        (§
            return (int) lpart
        )
        else
        (§
            return bipart.intValue()
        )
    )

    public long longValue()
    (§
        if (bipart == null)
        (§
            return lpart
        )
        else
        (§
            return bipart.longValue()
        )
    )

    public float floatValue()
    (§
        if (bipart == null)
        (§
            return lpart
        )
        else
        (§
            return bipart.floatValue()
        )
    )

    public double doubleValue()
    (§
        if (bipart == null)
        (§
            return lpart
        )
        else
        (§
            return bipart.doubleValue()
        )
    )

    public byte byteValue()
    (§
        if (bipart == null)
        (§
            return (byte) lpart
        )
        else
        (§
            return bipart.byteValue()
        )
    )

    public short shortValue()
    (§
        if (bipart == null)
        (§
            return (short) lpart
        )
        else
        (§
            return bipart.shortValue()
        )
    )

    public static BigInt valueOf(long val)
    (§
        return new BigInt(val, null)
    )

    public String toString()
    (§
        if (bipart == null)
        (§
            return String.valueOf(lpart)
        )
        return bipart.toString()
    )

    public int bitLength()
    (§
        return toBigInteger().bitLength()
    )

    public BigInt add(BigInt y)
    (§
        if ((bipart == null) && (y.bipart == null))
        (§
            long ret = lpart + y.lpart
            if ((ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0)
            (§
                return BigInt.valueOf(ret)
            )
        )
        return BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger()))
    )

    public BigInt multiply(BigInt y)
    (§
        if ((bipart == null) && (y.bipart == null))
        (§
            long ret = lpart * y.lpart
            if (y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE))
            (§
                return BigInt.valueOf(ret)
            )
        )
        return BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger()))
    )

    public BigInt quotient(BigInt y)
    (§
        if ((bipart == null) && (y.bipart == null))
        (§
            if (lpart == Long.MIN_VALUE && y.lpart == -1)
            (§
                return BigInt.fromBigInteger(this.toBigInteger().negate())
            )
            return BigInt.valueOf(lpart / y.lpart)
        )
        return BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger()))
    )

    public BigInt remainder(BigInt y)
    (§
        if ((bipart == null) && (y.bipart == null))
        (§
            return BigInt.valueOf(lpart % y.lpart)
        )
        return BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger()))
    )

    public boolean lt(BigInt y)
    (§
        if ((bipart == null) && (y.bipart == null))
        (§
            return (lpart < y.lpart)
        )
        return (this.toBigInteger().compareTo(y.toBigInteger()) < 0)
    )
)
)

(§ java cloiure.lang.Binding

public class Binding<T>
(§
    public T val
    public final Binding rest

    public Binding(T val)
    (§
        this.val = val
        this.rest = null
    )

    public Binding(T val, Binding rest)
    (§
        this.val = val
        this.rest = rest
    )
)
)

(§ java cloiure.lang.Box

public class Box
(§
    public Object val

    public Box(Object val)
    (§
        this.val = val
    )
)
)

(§ java cloiure.lang.ChunkBuffer

final public class ChunkBuffer implements Counted
(§
    Object[] buffer
    int end

    public ChunkBuffer(int capacity)
    (§
        buffer = new Object[capacity]
        end = 0
    )

    public void add(Object o)
    (§
        buffer[end++] = o
    )

    public IChunk chunk()
    (§
        ArrayChunk ret = new ArrayChunk(buffer, 0, end)
        buffer = null
        return ret
    )

    public int count()
    (§
        return end
    )
)
)

(§ java cloiure.lang.ChunkedCons

final public class ChunkedCons extends ASeq implements IChunkedSeq
(§
    final IChunk chunk
    final ISeq _more

    ChunkedCons(IPersistentMap meta, IChunk chunk, ISeq more)
    (§
        super(meta)
        this.chunk = chunk
        this._more = more
    )

    public ChunkedCons(IChunk chunk, ISeq more)
    (§
        this(null, chunk, more)
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta != _meta)
        (§
            return new ChunkedCons(meta, chunk, _more)
        )
        return this
    )

    public Object first()
    (§
        return chunk.nth(0)
    )

    public ISeq next()
    (§
        if (chunk.count() > 1)
        (§
            return new ChunkedCons(chunk.dropFirst(), _more)
        )
        return chunkedNext()
    )

    public ISeq more()
    (§
        if (chunk.count() > 1)
        (§
            return new ChunkedCons(chunk.dropFirst(), _more)
        )
        if (_more == null)
        (§
            return PersistentList.EMPTY
        )
        return _more
    )

    public IChunk chunkedFirst()
    (§
        return chunk
    )

    public ISeq chunkedNext()
    (§
        return chunkedMore().seq()
    )

    public ISeq chunkedMore()
    (§
        if (_more == null)
        (§
            return PersistentList.EMPTY
        )
        return _more
    )
)
)

(§ java cloiure.lang.Compile

import java.io.OutputStreamWriter
import java.io.PrintWriter
import java.io.IOException

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

public class Compile
(§
    private static final String PATH_PROP = "cloiure.compile.path"
    private static final String REFLECTION_WARNING_PROP = "cloiure.compile.warn-on-reflection"
    private static final String UNCHECKED_MATH_PROP = "cloiure.compile.unchecked-math"

    private static final Var compile_path = RT.var("cloiure.core", "*compile-path*")
    private static final Var compile = RT.var("cloiure.core", "compile")
    private static final Var warn_on_reflection = RT.var("cloiure.core", "*warn-on-reflection*")
    private static final Var unchecked_math = RT.var("cloiure.core", "*unchecked-math*")

    public static void main(String[] args) throws IOException, ClassNotFoundException
    (§
        OutputStreamWriter out = (OutputStreamWriter) RT.OUT.deref()
        PrintWriter err = RT.errPrintWriter()
        String path = System.getProperty(PATH_PROP)
        int count = args.length

        if (path == null)
        (§
            err.println("ERROR: Must set system property " + PATH_PROP +
                    "\nto the location for compiled .class files." +
                    "\nThis directory must also be on your CLASSPATH.")
            System.exit(1)
        )

        boolean warnOnReflection = System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true")
        String uncheckedMathProp = System.getProperty(UNCHECKED_MATH_PROP)
        Object uncheckedMath = Boolean.FALSE
        if ("true".equals(uncheckedMathProp))
        (§
            uncheckedMath = Boolean.TRUE
        )
        else if ("warn-on-boxed".equals(uncheckedMathProp))
        (§
            uncheckedMath = Keyword.intern("warn-on-boxed")
        )

        ;; force load to avoid transitive compilation during lazy load
        RT.load("cloiure/core/specs/alpha")

        try
        (§
            Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath))

            for (String lib :in args)
            (§
                out.write("Compiling " + lib + " to " + path + "\n")
                out.flush()
                compile.invoke(Symbol.intern(lib))
            )
        )
        finally
        (§
            Var.popThreadBindings()
            try
            (§
                out.flush()
            )
            catch (IOException e)
            (§
                e.printStackTrace(err)
            )
        )
    )
)
)

(§ java cloiure.lang.Compiler

import cloiure.asm.*
import cloiure.asm.commons.GeneratorAdapter
import cloiure.asm.commons.Method

import java.io.*
import java.lang.reflect.Constructor
import java.lang.reflect.Modifier
import java.util.*
import java.util.regex.Pattern
import java.util.regex.Matcher

public class Compiler implements Opcodes
(§
    static final Symbol DEF = Symbol.intern("def")
    static final Symbol LOOP = Symbol.intern("loop*")
    static final Symbol RECUR = Symbol.intern("recur")
    static final Symbol IF = Symbol.intern("if")
    static final Symbol LET = Symbol.intern("let*")
    static final Symbol LETFN = Symbol.intern("letfn*")
    static final Symbol DO = Symbol.intern("do")
    static final Symbol FN = Symbol.intern("fn*")
    static final Symbol FNONCE = (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(null, "once"), RT.T))
    static final Symbol QUOTE = Symbol.intern("quote")
    static final Symbol THE_VAR = Symbol.intern("var")
    static final Symbol DOT = Symbol.intern(".")
    static final Symbol ASSIGN = Symbol.intern("set!")
    static final Symbol TRY = Symbol.intern("try")
    static final Symbol CATCH = Symbol.intern("catch")
    static final Symbol FINALLY = Symbol.intern("finally")
    static final Symbol THROW = Symbol.intern("throw")
    static final Symbol MONITOR_ENTER = Symbol.intern("monitor-enter")
    static final Symbol MONITOR_EXIT = Symbol.intern("monitor-exit")
    static final Symbol IMPORT = Symbol.intern("cloiure.core", "import*")
    static final Symbol DEFTYPE = Symbol.intern("deftype*")
    static final Symbol CASE = Symbol.intern("case*")

    static final Symbol CLASS = Symbol.intern("Class")
    static final Symbol NEW = Symbol.intern("new")
    static final Symbol THIS = Symbol.intern("this")
    static final Symbol REIFY = Symbol.intern("reify*")
    static final Symbol LIST = Symbol.intern("cloiure.core", "list")
    static final Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map")
    static final Symbol VECTOR = Symbol.intern("cloiure.core", "vector")
    static final Symbol IDENTITY = Symbol.intern("cloiure.core", "identity")

    static final Symbol _AMP_ = Symbol.intern("&")
    static final Symbol ISEQ = Symbol.intern("cloiure.lang.ISeq")

    static final Keyword loadNs = Keyword.intern(null, "load-ns")
    static final Keyword inlineKey = Keyword.intern(null, "inline")
    static final Keyword inlineAritiesKey = Keyword.intern(null, "inline-arities")
    static final Keyword staticKey = Keyword.intern(null, "static")
    static final Keyword arglistsKey = Keyword.intern(null, "arglists")
    static final Symbol INVOKE_STATIC = Symbol.intern("invokeStatic")

    static final Keyword volatileKey = Keyword.intern(null, "volatile")
    static final Keyword implementsKey = Keyword.intern(null, "implements")
    static final String COMPILE_STUB_PREFIX = "compile__stub"

    static final Keyword protocolKey = Keyword.intern(null, "protocol")
    static final Keyword onKey = Keyword.intern(null, "on")
    static Keyword dynamicKey = Keyword.intern("dynamic")
    static final Keyword redefKey = Keyword.intern(null, "redef")

    static final Symbol NS = Symbol.intern("ns")
    static final Symbol IN_NS = Symbol.intern("in-ns")

    static final public IPersistentMap specials = PersistentHashMap.create(
        DEF, new DefExpr.Parser(),
        LOOP, new LetExpr.Parser(),
        RECUR, new RecurExpr.Parser(),
        IF, new IfExpr.Parser(),
        CASE, new CaseExpr.Parser(),
        LET, new LetExpr.Parser(),
        LETFN, new LetFnExpr.Parser(),
        DO, new BodyExpr.Parser(),
        FN, null,
        QUOTE, new ConstantExpr.Parser(),
        THE_VAR, new TheVarExpr.Parser(),
        IMPORT, new ImportExpr.Parser(),
        DOT, new HostExpr.Parser(),
        ASSIGN, new AssignExpr.Parser(),
        DEFTYPE, new NewInstanceExpr.DeftypeParser(),
        REIFY, new NewInstanceExpr.ReifyParser(),
        TRY, new TryExpr.Parser(),
        THROW, new ThrowExpr.Parser(),
        MONITOR_ENTER, new MonitorEnterExpr.Parser(),
        MONITOR_EXIT, new MonitorExitExpr.Parser(),
        CATCH, null,
        FINALLY, null,
        NEW, new NewExpr.Parser(),
        _AMP_, null
    )

    private static final int MAX_POSITIONAL_ARITY = 20
    private static final Type OBJECT_TYPE
    private static final Type KEYWORD_TYPE = Type.getType(Keyword.class)
    private static final Type VAR_TYPE = Type.getType(Var.class)
    private static final Type SYMBOL_TYPE = Type.getType(Symbol.class)
    private static final Type IFN_TYPE = Type.getType(IFn.class)
    private static final Type AFUNCTION_TYPE = Type.getType(AFunction.class)
    private static final Type RT_TYPE = Type.getType(RT.class)
    private static final Type NUMBERS_TYPE = Type.getType(Numbers.class)

    final static Type CLASS_TYPE = Type.getType(Class.class)
    final static Type NS_TYPE = Type.getType(Namespace.class)
    final static Type UTIL_TYPE = Type.getType(Util.class)
    final static Type REFLECTOR_TYPE = Type.getType(Reflector.class)
    final static Type THROWABLE_TYPE = Type.getType(Throwable.class)
    final static Type BOOLEAN_OBJECT_TYPE = Type.getType(Boolean.class)
    final static Type IPERSISTENTMAP_TYPE = Type.getType(IPersistentMap.class)
    final static Type IOBJ_TYPE = Type.getType(IObj.class)
    final static Type TUPLE_TYPE = Type.getType(Tuple.class)

    final static Method createTupleMethods[] =
    (§
        Method.getMethod("cloiure.lang.IPersistentVector create()"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)")
    )

    private static final Type[][] ARG_TYPES
    private static final Type[] EXCEPTION_TYPES = (§)

    static
    (§
        OBJECT_TYPE = Type.getType(Object.class)
        ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][]
        for (int i = 0 i <= MAX_POSITIONAL_ARITY ++i)
        (§
            Type[] a = new Type[i]
            for (int j = 0 j < i j++)
            (§
                a[j] = OBJECT_TYPE
            )
            ARG_TYPES[i] = a
        )
        Type[] a = new Type[MAX_POSITIONAL_ARITY + 1]
        for (int j = 0 j < MAX_POSITIONAL_ARITY j++)
        (§
            a[j] = OBJECT_TYPE
        )
        a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/Object;")
        ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a
    )

    ;; symbol->localbinding
    static final public Var LOCAL_ENV = Var.create(null).setDynamic()

    ;; vector<localbinding>
    static final public Var LOOP_LOCALS = Var.create().setDynamic()

    ;; Label
    static final public Var LOOP_LABEL = Var.create().setDynamic()

    ;; vector<object>
    static final public Var CONSTANTS = Var.create().setDynamic()

    ;; IdentityHashMap
    static final public Var CONSTANT_IDS = Var.create().setDynamic()

    ;; vector<keyword>
    static final public Var KEYWORD_CALLSITES = Var.create().setDynamic()

    ;; vector<var>
    static final public Var PROTOCOL_CALLSITES = Var.create().setDynamic()

    ;; set<var>
    static final public Var VAR_CALLSITES = Var.create().setDynamic()

    ;; keyword->constid
    static final public Var KEYWORDS = Var.create().setDynamic()

    ;; var->constid
    static final public Var VARS = Var.create().setDynamic()

    ;; FnFrame
    static final public Var METHOD = Var.create(null).setDynamic()

    ;; null or not
    static final public Var IN_CATCH_FINALLY = Var.create(null).setDynamic()

    static final public Var METHOD_RETURN_CONTEXT = Var.create(null).setDynamic()

    static final public Var NO_RECUR = Var.create(null).setDynamic()

    ;; DynamicClassLoader
    static final public Var LOADER = Var.create().setDynamic()

    ;; String
    static final public Var SOURCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic()

    ;; String
    static final public Var SOURCE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic()

    ;; String
    static final public Var COMPILE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), null).setDynamic()
    ;; boolean
    static final public Var COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic()

    static final public Var INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?"))

    static final public Var ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations"))

    static final public Keyword disableLocalsClearingKey = Keyword.intern("disable-locals-clearing")
    static final public Keyword directLinkingKey = Keyword.intern("direct-linking")
    static final public Keyword elideMetaKey = Keyword.intern("elide-meta")

    static final public Var COMPILER_OPTIONS

    static public Object getCompilerOption(Keyword k)
    (§
        return RT.get(COMPILER_OPTIONS.deref(), k)
    )

    static
    (§
        Object compilerOptions = null

        for (Map.Entry e :in System.getProperties().entrySet())
        (§
            String name = (String) e.getKey()
            String v = (String) e.getValue()
            if (name.startsWith("cloiure.compiler."))
            (§
                compilerOptions = RT.assoc(compilerOptions, RT.keyword(null, name.substring(1 + name.lastIndexOf((§ char \.)))), RT.readString(v))
            )
        )

        COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic()
    )

    static Object elideMeta(Object m)
    (§
        Collection<Object> elides = (Collection<Object>) getCompilerOption(elideMetaKey)
        if (elides != null)
        (§
            for (Object k :in elides)
            (§
                m = RT.dissoc(m, k)
            )
        )
        return m
    )

    ;; Integer
    static final public Var LINE = Var.create(0).setDynamic()
    static final public Var COLUMN = Var.create(0).setDynamic()

    static int lineDeref()
    (§
        return ((Number)LINE.deref()).intValue()
    )

    static int columnDeref()
    (§
        return ((Number)COLUMN.deref()).intValue()
    )

    ;; Integer
    static final public Var LINE_BEFORE = Var.create(0).setDynamic()
    static final public Var COLUMN_BEFORE = Var.create(0).setDynamic()
    static final public Var LINE_AFTER = Var.create(0).setDynamic()
    static final public Var COLUMN_AFTER = Var.create(0).setDynamic()

    ;; Integer
    static final public Var NEXT_LOCAL_NUM = Var.create(0).setDynamic()

    ;; Integer
    static final public Var RET_LOCAL_NUM = Var.create().setDynamic()

    static final public Var COMPILE_STUB_SYM = Var.create(null).setDynamic()
    static final public Var COMPILE_STUB_CLASS = Var.create(null).setDynamic()

    ;; PathNode chain
    static final public Var CLEAR_PATH = Var.create(null).setDynamic()

    ;; tail of PathNode chain
    static final public Var CLEAR_ROOT = Var.create(null).setDynamic()

    ;; LocalBinding -> Set<LocalBindingExpr>
    static final public Var CLEAR_SITES = Var.create(null).setDynamic()

    public enum C
    (§
        STATEMENT, ;; value ignored
        EXPRESSION, ;; value required
        RETURN, ;; tail position relative to enclosing recur frame
        EVAL
    )

    private class Recur (§)
    static final public Class RECUR_CLASS = Recur.class

    interface Expr
    (§
        Object eval()

        void emit(C context, ObjExpr objx, GeneratorAdapter gen)

        boolean hasJavaClass()

        Class getJavaClass()
    )

    public static abstract class UntypedExpr implements Expr
    (§
        public Class getJavaClass()
        (§
            throw new IllegalArgumentException("Has no Java class")
        )

        public boolean hasJavaClass()
        (§
            return false
        )
    )

    interface IParser
    (§
        Expr parse(C context, Object form)
    )

    static boolean isSpecial(Object sym)
    (§
        return specials.containsKey(sym)
    )

    static boolean inTailCall(C context)
    (§
        return (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != null) && (IN_CATCH_FINALLY.deref() == null)
    )

    static Symbol resolveSymbol(Symbol sym)
    (§
        ;; already qualified or classname?
        if (sym.name.indexOf((§ char \.)) > 0)
        (§
            return sym
        )
        if (sym.ns != null)
        (§
            Namespace ns = namespaceFor(sym)
            if (ns == null || ((ns.name.name == null) ? (sym.ns == null) :or ns.name.name.equals(sym.ns)))
            (§
                return sym
            )
            return Symbol.intern(ns.name.name, sym.name)
        )
        Object o = currentNS().getMapping(sym)
        if (o == null)
        (§
            return Symbol.intern(currentNS().name.name, sym.name)
        )
        else if (o instanceof Class)
        (§
            return Symbol.intern(null, ((Class) o).getName())
        )
        else if (o instanceof Var)
        (§
            Var v = (Var) o
            return Symbol.intern(v.ns.name.name, v.sym.name)
        )
        return null
    )

    static class DefExpr implements Expr
    (§
        public final Var var
        public final Expr init
        public final Expr meta
        public final boolean initProvided
        public final boolean isDynamic
        public final boolean shadowsCoreMapping
        public final String source
        public final int line
        public final int column

        final static Method bindRootMethod = Method.getMethod("void bindRoot(Object)")
        final static Method setTagMethod = Method.getMethod("void setTag(cloiure.lang.Symbol)")
        final static Method setMetaMethod = Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)")
        final static Method setDynamicMethod = Method.getMethod("cloiure.lang.Var setDynamic(boolean)")
        final static Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String, String)")
        final static Method internVar = Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)")

        public DefExpr(String source, int line, int column, Var var, Expr init, Expr meta, boolean initProvided, boolean isDynamic, boolean shadowsCoreMapping)
        (§
            this.source = source
            this.line = line
            this.column = column
            this.var = var
            this.init = init
            this.meta = meta
            this.isDynamic = isDynamic
            this.shadowsCoreMapping = shadowsCoreMapping
            this.initProvided = initProvided
        )

        private boolean includesExplicitMetadata(MapExpr expr)
        (§
            for (int i = 0 i < expr.keyvals.count() i += 2)
            (§
                Keyword k  = ((KeywordExpr) expr.keyvals.nth(i)).k
                if ((k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY))
                (§
                    return true
                )
            )
            return false
        )

        public Object eval()
        (§
            try
            (§
                if (initProvided)
                (§
                    var.bindRoot(init.eval())
                )
                if (meta != null)
                (§
                    IPersistentMap metaMap = (IPersistentMap) meta.eval()
                    if (initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                    (§
                        var.setMeta(metaMap)
                    )
                )
                return var.setDynamic(isDynamic)
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitVar(gen, var)

            if (shadowsCoreMapping)
            (§
                gen.dup()
                gen.getField(VAR_TYPE, "ns", NS_TYPE)
                gen.swap()
                gen.dup()
                gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE)
                gen.swap()
                gen.invokeVirtual(NS_TYPE, internVar)
            )

            if (isDynamic)
            (§
                gen.push(isDynamic)
                gen.invokeVirtual(VAR_TYPE, setDynamicMethod)
            )
            if (meta != null)
            (§
                if (initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                (§
                    gen.dup()
                    meta.emit(C.EXPRESSION, objx, gen)
                    gen.checkCast(IPERSISTENTMAP_TYPE)
                    gen.invokeVirtual(VAR_TYPE, setMetaMethod)
                )
            )
            if (initProvided)
            (§
                gen.dup()
                if (init instanceof FnExpr)
                (§
                    ((FnExpr)init).emitForDefn(objx, gen)
                )
                else
                (§
                    init.emit(C.EXPRESSION, objx, gen)
                )
                gen.invokeVirtual(VAR_TYPE, bindRootMethod)
            )

            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return Var.class
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                String docstring = null
                if (RT.count(form) == 4 && (RT.third(form) instanceof String))
                (§
                    docstring = (String) RT.third(form)
                    form = RT.list(RT.first(form), RT.second(form), RT.fourth(form))
                )
                if (RT.count(form) > 3)
                (§
                    throw Util.runtimeException("Too many arguments to def")
                )
                else if (RT.count(form) < 2)
                (§
                    throw Util.runtimeException("Too few arguments to def")
                )
                else if (!(RT.second(form) instanceof Symbol))
                (§
                    throw Util.runtimeException("First argument to def must be a Symbol")
                )
                Symbol sym = (Symbol) RT.second(form)
                Var v = lookupVar(sym, true)
                if (v == null)
                (§
                    throw Util.runtimeException("Can't refer to qualified var that doesn't exist")
                )
                boolean shadowsCoreMapping = false
                if (!v.ns.equals(currentNS()))
                (§
                    if (sym.ns == null)
                    (§
                        v = currentNS().intern(sym)
                        shadowsCoreMapping = true
                        registerVar(v)
                    )
                    else
                    (§
                        throw Util.runtimeException("Can't create defs outside of current ns")
                    )
                )
                IPersistentMap mm = sym.meta()
                boolean isDynamic = RT.booleanCast(RT.get(mm, dynamicKey))
                if (isDynamic)
                (§
                    v.setDynamic()
                )
                if (!isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2)
                (§
                    RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, "
                            + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n",
                            sym, SOURCE_PATH.get(), LINE.get())
                )
                if (RT.booleanCast(RT.get(mm, arglistsKey)))
                (§
                    IPersistentMap vm = v.meta()
                    ;; drop quote
                    vm = (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey)))
                    v.setMeta(vm)
                )
                Object source_path = SOURCE_PATH.get()
                source_path = (source_path == null) ? "NO_SOURCE_FILE" :or source_path
                mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path)
                if (docstring != null)
                (§
                    mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring)
                )
                mm = (IPersistentMap) elideMeta(mm)
                Expr meta = (mm.count() == 0) ? null :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm)
                return new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(),
                        v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name),
                        meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping)
            )
        )
    )

    public static class AssignExpr implements Expr
    (§
        public final AssignableExpr target
        public final Expr val

        public AssignExpr(AssignableExpr target, Expr val)
        (§
            this.target = target
            this.val = val
        )

        public Object eval()
        (§
            return target.evalAssign(val)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            target.emitAssign(context, objx, gen, val)
        )

        public boolean hasJavaClass()
        (§
            return val.hasJavaClass()
        )

        public Class getJavaClass()
        (§
            return val.getJavaClass()
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                if (RT.length(form) != 3)
                (§
                    throw new IllegalArgumentException("Malformed assignment, expecting (set! target val)")
                )
                Expr target = analyze(C.EXPRESSION, RT.second(form))
                if (!(target instanceof AssignableExpr))
                (§
                    throw new IllegalArgumentException("Invalid assignment target")
                )
                return new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form)))
            )
        )
    )

    public static class VarExpr implements Expr, AssignableExpr
    (§
        public final Var var
        public final Object tag
        final static Method getMethod = Method.getMethod("Object get()")
        final static Method setMethod = Method.getMethod("Object set(Object)")

        Class jc

        public VarExpr(Var var, Symbol tag)
        (§
            this.var = var
            this.tag = (tag != null) ? tag :or var.getTag()
        )

        public Object eval()
        (§
            return var.deref()
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitVarValue(gen, var)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return (tag != null)
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = HostExpr.tagToClass(tag)
            )
            return jc
        )

        public Object evalAssign(Expr val)
        (§
            return var.set(val.eval())
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            objx.emitVar(gen, var)
            val.emit(C.EXPRESSION, objx, gen)
            gen.invokeVirtual(VAR_TYPE, setMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )
    )

    public static class TheVarExpr implements Expr
    (§
        public final Var var

        public TheVarExpr(Var var)
        (§
            this.var = var
        )

        public Object eval()
        (§
            return var
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitVar(gen, var)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return Var.class
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                Symbol sym = (Symbol) RT.second(form)
                Var v = lookupVar(sym, false)
                if (v != null)
                (§
                    return new TheVarExpr(v)
                )
                throw Util.runtimeException("Unable to resolve var: " + sym + " in this context")
            )
        )
    )

    public static class KeywordExpr extends LiteralExpr
    (§
        public final Keyword k

        public KeywordExpr(Keyword k)
        (§
            this.k = k
        )

        Object val()
        (§
            return k
        )

        public Object eval()
        (§
            return k
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitKeyword(gen, k)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return Keyword.class
        )
    )

    public static class ImportExpr implements Expr
    (§
        public final String c

        final static Method forNameMethod = Method.getMethod("Class classForNameNonLoading(String)")
        final static Method importClassMethod = Method.getMethod("Class importClass(Class)")
        final static Method derefMethod = Method.getMethod("Object deref()")

        public ImportExpr(String c)
        (§
            this.c = c
        )

        public Object eval()
        (§
            Namespace ns = (Namespace) RT.CURRENT_NS.deref()
            ns.importClass(RT.classForNameNonLoading(c))
            return null
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE)
            gen.invokeVirtual(VAR_TYPE, derefMethod)
            gen.checkCast(NS_TYPE)
            gen.push(c)
            gen.invokeStatic(RT_TYPE, forNameMethod)
            gen.invokeVirtual(NS_TYPE, importClassMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return false
        )

        public Class getJavaClass()
        (§
            throw new IllegalArgumentException("ImportExpr has no Java class")
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                return new ImportExpr((String) RT.second(form))
            )
        )
    )

    public static abstract class LiteralExpr implements Expr
    (§
        abstract Object val()

        public Object eval()
        (§
            return val()
        )
    )

    static interface AssignableExpr
    (§
        Object evalAssign(Expr val)

        void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
    )

    static public interface MaybePrimitiveExpr extends Expr
    (§
        public boolean canEmitPrimitive()
        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
    )

    static public abstract class HostExpr implements Expr, MaybePrimitiveExpr
    (§
        final static Type BOOLEAN_TYPE = Type.getType(Boolean.class)
        final static Type CHAR_TYPE = Type.getType(Character.class)
        final static Type INTEGER_TYPE = Type.getType(Integer.class)
        final static Type LONG_TYPE = Type.getType(Long.class)
        final static Type FLOAT_TYPE = Type.getType(Float.class)
        final static Type DOUBLE_TYPE = Type.getType(Double.class)
        final static Type SHORT_TYPE = Type.getType(Short.class)
        final static Type BYTE_TYPE = Type.getType(Byte.class)
        final static Type NUMBER_TYPE = Type.getType(Number.class)

        final static Method charValueMethod = Method.getMethod("char charValue()")
        final static Method booleanValueMethod = Method.getMethod("boolean booleanValue()")

        final static Method charValueOfMethod = Method.getMethod("Character valueOf(char)")
        final static Method intValueOfMethod = Method.getMethod("Integer valueOf(int)")
        final static Method longValueOfMethod = Method.getMethod("Long valueOf(long)")
        final static Method floatValueOfMethod = Method.getMethod("Float valueOf(float)")
        final static Method doubleValueOfMethod = Method.getMethod("Double valueOf(double)")
        final static Method shortValueOfMethod = Method.getMethod("Short valueOf(short)")
        final static Method byteValueOfMethod = Method.getMethod("Byte valueOf(byte)")

        final static Method intValueMethod = Method.getMethod("int intValue()")
        final static Method longValueMethod = Method.getMethod("long longValue()")
        final static Method floatValueMethod = Method.getMethod("float floatValue()")
        final static Method doubleValueMethod = Method.getMethod("double doubleValue()")
        final static Method byteValueMethod = Method.getMethod("byte byteValue()")
        final static Method shortValueMethod = Method.getMethod("short shortValue()")

        final static Method fromIntMethod = Method.getMethod("cloiure.lang.Num from(int)")
        final static Method fromLongMethod = Method.getMethod("cloiure.lang.Num from(long)")
        final static Method fromDoubleMethod = Method.getMethod("cloiure.lang.Num from(double)")

        public static void emitBoxReturn(ObjExpr objx, GeneratorAdapter gen, Class returnType)
        (§
            if (returnType.isPrimitive())
            (§
                if (returnType == boolean.class)
                (§
                    Label falseLabel = gen.newLabel()
                    Label endLabel = gen.newLabel()
                    gen.ifZCmp(GeneratorAdapter.EQ, falseLabel)
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE)
                    gen.goTo(endLabel)
                    gen.mark(falseLabel)
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
                    gen.mark(endLabel)
                )
                else if (returnType == void.class)
                (§
                    NIL_EXPR.emit(C.EXPRESSION, objx, gen)
                )
                else if (returnType == char.class)
                (§
                    gen.invokeStatic(CHAR_TYPE, charValueOfMethod)
                )
                else
                (§
                    if (returnType == int.class)
                    (§
                        gen.invokeStatic(INTEGER_TYPE, intValueOfMethod)
                    )
                    else if (returnType == float.class)
                    (§
                        gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod)
                    )
                    else if (returnType == double.class)
                    (§
                        gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod)
                    )
                    else if (returnType == long.class)
                    (§
                        gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)"))
                    )
                    else if (returnType == byte.class)
                    (§
                        gen.invokeStatic(BYTE_TYPE, byteValueOfMethod)
                    )
                    else if (returnType == short.class)
                    (§
                        gen.invokeStatic(SHORT_TYPE, shortValueOfMethod)
                    )
                )
            )
        )

        public static void emitUnboxArg(ObjExpr objx, GeneratorAdapter gen, Class paramType)
        (§
            if (paramType.isPrimitive())
            (§
                if (paramType == boolean.class)
                (§
                    gen.checkCast(BOOLEAN_TYPE)
                    gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod)
                )
                else if (paramType == char.class)
                (§
                    gen.checkCast(CHAR_TYPE)
                    gen.invokeVirtual(CHAR_TYPE, charValueMethod)
                )
                else
                (§
                    Method m = null
                    gen.checkCast(NUMBER_TYPE)
                    if (RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                    (§
                        if (paramType == int.class)
                        (§
                            m = Method.getMethod("int uncheckedIntCast(Object)")
                        )
                        else if (paramType == float.class)
                        (§
                            m = Method.getMethod("float uncheckedFloatCast(Object)")
                        )
                        else if (paramType == double.class)
                        (§
                            m = Method.getMethod("double uncheckedDoubleCast(Object)")
                        )
                        else if (paramType == long.class)
                        (§
                            m = Method.getMethod("long uncheckedLongCast(Object)")
                        )
                        else if (paramType == byte.class)
                        (§
                            m = Method.getMethod("byte uncheckedByteCast(Object)")
                        )
                        else if (paramType == short.class)
                        (§
                            m = Method.getMethod("short uncheckedShortCast(Object)")
                        )
                    )
                    else
                    (§
                        if (paramType == int.class)
                        (§
                            m = Method.getMethod("int intCast(Object)")
                        )
                        else if (paramType == float.class)
                        (§
                            m = Method.getMethod("float floatCast(Object)")
                        )
                        else if (paramType == double.class)
                        (§
                            m = Method.getMethod("double doubleCast(Object)")
                        )
                        else if (paramType == long.class)
                        (§
                            m = Method.getMethod("long longCast(Object)")
                        )
                        else if (paramType == byte.class)
                        (§
                            m = Method.getMethod("byte byteCast(Object)")
                        )
                        else if (paramType == short.class)
                        (§
                            m = Method.getMethod("short shortCast(Object)")
                        )
                    )
                    gen.invokeStatic(RT_TYPE, m)
                )
            )
            else
            (§
                gen.checkCast(Type.getType(paramType))
            )
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (. x fieldname-sym) or
                ;; (. x 0-ary-method)
                ;; (. x methodname-sym args+)
                ;; (. x (methodname-sym args?))
                if (RT.length(form) < 3)
                (§
                    throw new IllegalArgumentException("Malformed member expression, expecting (. target member ...)")
                )
                ;; determine static or instance
                ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                int line = lineDeref()
                int column = columnDeref()
                String source = (String) SOURCE.deref()
                Class c = maybeClass(RT.second(form), false)
                ;; at this point c will be non-null if static
                Expr instance = null
                if (c == null)
                (§
                    instance = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form))
                )

                boolean maybeField = (RT.length(form) == 3) && (RT.third(form) instanceof Symbol)

                if (maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == (§ char \-)))
                (§
                    Symbol sym = (Symbol) RT.third(form)
                    if (c != null)
                    (§
                        maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0
                    )
                    else if (instance != null && instance.hasJavaClass() && instance.getJavaClass() != null)
                    (§
                        maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0
                    )
                )

                if (maybeField) ;; field
                (§
                    Symbol sym = (((Symbol)RT.third(form)).name.charAt(0) == (§ char \-)) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form)
                    Symbol tag = tagOf(form)
                    if (c != null)
                    (§
                        return new StaticFieldExpr(line, column, c, munge(sym.name), tag)
                    )
                    else
                    (§
                        return new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == (§ char \-)))
                    )
                )
                else
                (§
                    ISeq call = (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form)))
                    if (!(RT.first(call) instanceof Symbol))
                    (§
                        throw new IllegalArgumentException("Malformed member expression")
                    )
                    Symbol sym = (Symbol) RT.first(call)
                    Symbol tag = tagOf(form)
                    PersistentVector args = PersistentVector.EMPTY
                    boolean tailPosition = inTailCall(context)
                    for (ISeq s = RT.next(call) s != null s = s.next())
                    (§
                        args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first()))
                    )
                    if (c != null)
                    (§
                        return new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition)
                    )
                    else
                    (§
                        return new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition)
                    )
                )
            )
        )

        public static Class maybeClass(Object form, boolean stringOk)
        (§
            if (form instanceof Class)
            (§
                return (Class) form
            )
            Class c = null
            if (form instanceof Symbol)
            (§
                Symbol sym = (Symbol) form
                if (sym.ns == null) ;; if ns-qualified can't be classname
                (§
                    if (Util.equals(sym, COMPILE_STUB_SYM.get()))
                    (§
                        return (Class) COMPILE_STUB_CLASS.get()
                    )
                    if (sym.name.indexOf((§ char \.)) > 0 || sym.name.charAt(0) == (§ char \[))
                    (§
                        c = RT.classForNameNonLoading(sym.name)
                    )
                    else
                    (§
                        Object o = currentNS().getMapping(sym)
                        if (o instanceof Class)
                        (§
                            c = (Class) o
                        )
                        else if (LOCAL_ENV.deref() != null && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form))
                        (§
                            return null
                        )
                        else
                        (§
                            try
                            (§
                                c = RT.classForNameNonLoading(sym.name)
                            )
                            catch (Exception e)
                            (§
                                ;; aargh
                                ;; leave c set to null -> return null
                            )
                        )
                    )
                )
            )
            else if (stringOk && form instanceof String)
            (§
                c = RT.classForNameNonLoading((String) form)
            )
            return c
        )

        public static Class maybeSpecialTag(Symbol sym)
        (§
            Class c = primClass(sym)
            if (c != null)
            (§
                return c
            )
            else if (sym.name.equals("objects"))
            (§
                c = Object[].class
            )
            else if (sym.name.equals("ints"))
            (§
                c = int[].class
            )
            else if (sym.name.equals("longs"))
            (§
                c = long[].class
            )
            else if (sym.name.equals("floats"))
            (§
                c = float[].class
            )
            else if (sym.name.equals("doubles"))
            (§
                c = double[].class
            )
            else if (sym.name.equals("chars"))
            (§
                c = char[].class
            )
            else if (sym.name.equals("shorts"))
            (§
                c = short[].class
            )
            else if (sym.name.equals("bytes"))
            (§
                c = byte[].class
            )
            else if (sym.name.equals("booleans"))
            (§
                c = boolean[].class
            )
            return c
        )

        static Class tagToClass(Object tag)
        (§
            Class c = null
            if (tag instanceof Symbol)
            (§
                Symbol sym = (Symbol) tag
                if (sym.ns == null) ;; if ns-qualified can't be classname
                (§
                    c = maybeSpecialTag(sym)
                )
            )
            if (c == null)
            (§
                c = maybeClass(tag, true)
            )
            if (c != null)
            (§
                return c
            )
            throw new IllegalArgumentException("Unable to resolve classname: " + tag)
        )
    )

    static abstract class FieldExpr extends HostExpr
    (§
    )

    static class InstanceFieldExpr extends FieldExpr implements AssignableExpr
    (§
        public final Expr target
        public final Class targetClass
        public final java.lang.reflect.Field field
        public final String fieldName
        public final int line
        public final int column
        public final Symbol tag
        public final boolean requireField

        final static Method invokeNoArgInstanceMember = Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)")
        final static Method setInstanceFieldMethod = Method.getMethod("Object setInstanceField(Object,String,Object)")

        Class jc

        public InstanceFieldExpr(int line, int column, Expr target, String fieldName, Symbol tag, boolean requireField)
        (§
            this.target = target
            this.targetClass = target.hasJavaClass() ? target.getJavaClass() :or null
            this.field = (targetClass != null) ? Reflector.getField(targetClass, fieldName, false) :or null
            this.fieldName = fieldName
            this.line = line
            this.column = column
            this.tag = tag
            this.requireField = requireField

            if (field == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                if (targetClass == null)
                (§
                    RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName)
                )
                else
                (§
                    RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName())
                )
            )
        )

        public Object eval()
        (§
            return Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField)
        )

        public boolean canEmitPrimitive()
        (§
            return (targetClass != null && field != null && Util.isPrimitive(field.getType()))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (targetClass != null && field != null)
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.checkCast(getType(targetClass))
                gen.getField(getType(targetClass), fieldName, Type.getType(field.getType()))
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (targetClass != null && field != null)
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.checkCast(getType(targetClass))
                gen.getField(getType(targetClass), fieldName, Type.getType(field.getType()))
                HostExpr.emitBoxReturn(objx, gen, field.getType())
                if (context == C.STATEMENT)
                (§
                    gen.pop()
                )
            )
            else
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.push(fieldName)
                gen.push(requireField)
                gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember)
                if (context == C.STATEMENT)
                (§
                    gen.pop()
                )
            )
        )

        public boolean hasJavaClass()
        (§
            return (field != null || tag != null)
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = (tag != null) ? HostExpr.tagToClass(tag) :or field.getType()
            )
            return jc
        )

        public Object evalAssign(Expr val)
        (§
            return Reflector.setInstanceField(target.eval(), fieldName, val.eval())
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            if (targetClass != null && field != null)
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(getType(targetClass))
                val.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.dupX1()
                HostExpr.emitUnboxArg(objx, gen, field.getType())
                gen.putField(getType(targetClass), fieldName, Type.getType(field.getType()))
            )
            else
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.push(fieldName)
                val.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )
    )

    static class StaticFieldExpr extends FieldExpr implements AssignableExpr
    (§
        public final String fieldName
        public final Class c
        public final java.lang.reflect.Field field
        public final Symbol tag

        final int line
        final int column

        Class jc

        public StaticFieldExpr(int line, int column, Class c, String fieldName, Symbol tag)
        (§
            this.fieldName = fieldName
            this.line = line
            this.column = column
            this.c = c
            try
            (§
                field = c.getField(fieldName)
            )
            catch (NoSuchFieldException e)
            (§
                throw Util.sneakyThrow(e)
            )
            this.tag = tag
        )

        public Object eval()
        (§
            return Reflector.getStaticField(c, fieldName)
        )

        public boolean canEmitPrimitive()
        (§
            return Util.isPrimitive(field.getType())
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.visitLineNumber(line, gen.mark())
            gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType()))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.visitLineNumber(line, gen.mark())

            gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType()))
            HostExpr.emitBoxReturn(objx, gen, field.getType())
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = (tag != null) ? HostExpr.tagToClass(tag) :or field.getType()
            )
            return jc
        )

        public Object evalAssign(Expr val)
        (§
            return Reflector.setStaticField(c, fieldName, val.eval())
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            val.emit(C.EXPRESSION, objx, gen)
            gen.visitLineNumber(line, gen.mark())
            gen.dup()
            HostExpr.emitUnboxArg(objx, gen, field.getType())
            gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType()))
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )
    )

    static Class maybePrimitiveType(Expr e)
    (§
        if (e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
        (§
            Class c = e.getJavaClass()
            if (Util.isPrimitive(c))
            (§
                return c
            )
        )
        return null
    )

    static Class maybeJavaClass(Collection<Expr> exprs)
    (§
        Class match = null
        try
        (§
            for (Expr e :in exprs)
            (§
                if (e instanceof ThrowExpr)
                (§
                    continue
                )
                if (!e.hasJavaClass())
                (§
                    return null
                )
                Class c = e.getJavaClass()
                if (match == null)
                (§
                    match = c
                )
                else if (match != c)
                (§
                    return null
                )
            )
        )
        catch (Exception e)
        (§
            return null
        )
        return match
    )

    static abstract class MethodExpr extends HostExpr
    (§
        static void emitArgsAsArray(IPersistentVector args, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.push(args.count())
            gen.newArray(OBJECT_TYPE)
            for (int i = 0 i < args.count() i++)
            (§
                gen.dup()
                gen.push(i)
                ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen)
                gen.arrayStore(OBJECT_TYPE)
            )
        )

        public static void emitTypedArgs(ObjExpr objx, GeneratorAdapter gen, Class[] parameterTypes, IPersistentVector args)
        (§
            for (int i = 0 i < parameterTypes.length i++)
            (§
                Expr e = (Expr) args.nth(i)
                try
                (§
                    final Class primc = maybePrimitiveType(e)
                    if (primc == parameterTypes[i])
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    else if (primc == int.class && parameterTypes[i] == long.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(I2L)
                    )
                    else if (primc == long.class && parameterTypes[i] == int.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        if (RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                        (§
                            gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)"))
                        )
                        else
                        (§
                            gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)"))
                        )
                    )
                    else if (primc == float.class && parameterTypes[i] == double.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(F2D)
                    )
                    else if (primc == double.class && parameterTypes[i] == float.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(D2F)
                    )
                    else
                    (§
                        e.emit(C.EXPRESSION, objx, gen)
                        HostExpr.emitUnboxArg(objx, gen, parameterTypes[i])
                    )
                )
                catch (Exception e1)
                (§
                    throw Util.sneakyThrow(e1)
                )
            )
        )
    )

    static class InstanceMethodExpr extends MethodExpr
    (§
        public final Expr target
        public final String methodName
        public final IPersistentVector args
        public final String source
        public final int line
        public final int column
        public final Symbol tag
        public final boolean tailPosition
        public final java.lang.reflect.Method method

        Class jc

        final static Method invokeInstanceMethodMethod = Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])")

        public InstanceMethodExpr(String source, int line, int column, Symbol tag, Expr target, String methodName, IPersistentVector args, boolean tailPosition)
        (§
            this.source = source
            this.line = line
            this.column = column
            this.args = args
            this.methodName = methodName
            this.target = target
            this.tag = tag
            this.tailPosition = tailPosition
            if (target.hasJavaClass() && target.getJavaClass() != null)
            (§
                List methods = Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false)
                if (methods.isEmpty())
                (§
                    method = null
                    if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (§
                        RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n",
                                    SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName())
                    )
                )
                else
                (§
                    int methodidx = 0
                    if (methods.size() > 1)
                    (§
                        ArrayList<Class[]> params = new ArrayList()
                        ArrayList<Class> rets = new ArrayList()
                        for (int i = 0 i < methods.size() i++)
                        (§
                            java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i)
                            params.add(m.getParameterTypes())
                            rets.add(m.getReturnType())
                        )
                        methodidx = getMatchingParams(methodName, params, args, rets)
                    )
                    java.lang.reflect.Method m = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or null)
                    if (m != null && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                    (§
                        ;; public method of non-public class, try to find it in hierarchy
                        m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m)
                    )
                    method = m
                    if (method == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (§
                        RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n",
                                    SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args))
                    )
                )
            )
            else
            (§
                method = null
                if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (§
                    RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n",
                                SOURCE_PATH.deref(), line, column, methodName)
                )
            )
        )

        public Object eval()
        (§
            try
            (§
                Object targetval = target.eval()
                Object[] argvals = new Object[args.count()]
                for (int i = 0 i < args.count() i++)
                (§
                    argvals[i] = ((Expr) args.nth(i)).eval()
                )
                if (method != null)
                (§
                    LinkedList ms = new LinkedList()
                    ms.add(method)
                    return Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)
                )
                return Reflector.invokeInstanceMethod(targetval, methodName, argvals)
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public boolean canEmitPrimitive()
        (§
            return (method != null && Util.isPrimitive(method.getReturnType()))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != null)
            (§
                Type type = Type.getType(method.getDeclaringClass())
                target.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(type)
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (tailPosition && !objx.canBeDirect)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearThis(gen)
                )
                Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                if (method.getDeclaringClass().isInterface())
                (§
                    gen.invokeInterface(type, m)
                )
                else
                (§
                    gen.invokeVirtual(type, m)
                )
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != null)
            (§
                Type type = Type.getType(method.getDeclaringClass())
                target.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(type)
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                if (method.getDeclaringClass().isInterface())
                (§
                    gen.invokeInterface(type, m)
                )
                else
                (§
                    gen.invokeVirtual(type, m)
                )
                HostExpr.emitBoxReturn(objx, gen, method.getReturnType())
            )
            else
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.push(methodName)
                emitArgsAsArray(args, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return (method != null || tag != null)
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = retType((tag != null) ? HostExpr.tagToClass(tag) :or null, (method != null) ? method.getReturnType() :or null)
            )
            return jc
        )
    )

    static class StaticMethodExpr extends MethodExpr
    (§
        public final Class c
        public final String methodName
        public final IPersistentVector args
        public final String source
        public final int line
        public final int column
        public final java.lang.reflect.Method method
        public final Symbol tag
        public final boolean tailPosition

        final static Method forNameMethod = Method.getMethod("Class classForName(String)")
        final static Method invokeStaticMethodMethod = Method.getMethod("Object invokeStaticMethod(Class,String,Object[])")
        final static Keyword warnOnBoxedKeyword = Keyword.intern("warn-on-boxed")

        Class jc

        public StaticMethodExpr(String source, int line, int column, Symbol tag, Class c, String methodName, IPersistentVector args, boolean tailPosition)
        (§
            this.c = c
            this.methodName = methodName
            this.args = args
            this.source = source
            this.line = line
            this.column = column
            this.tag = tag
            this.tailPosition = tailPosition

            List methods = Reflector.getMethods(c, args.count(), methodName, true)
            if (methods.isEmpty())
            (§
                throw new IllegalArgumentException("No matching method: " + methodName)
            )

            int methodidx = 0
            if (methods.size() > 1)
            (§
                ArrayList<Class[]> params = new ArrayList()
                ArrayList<Class> rets = new ArrayList()
                for (int i = 0 i < methods.size() i++)
                (§
                    java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i)
                    params.add(m.getParameterTypes())
                    rets.add(m.getReturnType())
                )
                methodidx = getMatchingParams(methodName, params, args, rets)
            )
            method = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or null)
            if (method == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n",
                            SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args))
            )
            if (method != null && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method))
            (§
                RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n",
                            SOURCE_PATH.deref(), line, column, method.toString())
            )
        )

        public static boolean isBoxedMath(java.lang.reflect.Method m)
        (§
            Class c = m.getDeclaringClass()
            if (c.equals(Numbers.class))
            (§
                WarnBoxedMath boxedMath = m.getAnnotation(WarnBoxedMath.class)
                if (boxedMath != null)
                (§
                    return boxedMath.value()
                )

                Class[] argTypes = m.getParameterTypes()
                for (Class argType :in argTypes)
                (§
                    if (argType.equals(Object.class) || argType.equals(Number.class))
                    (§
                        return true
                    )
                )
            )
            return false
        )

        public Object eval()
        (§
            try
            (§
                Object[] argvals = new Object[args.count()]
                for (int i = 0 i < args.count() i++)
                (§
                    argvals[i] = ((Expr) args.nth(i)).eval()
                )
                if (method != null)
                (§
                    LinkedList ms = new LinkedList()
                    ms.add(method)
                    return Reflector.invokeMatchingMethod(methodName, ms, null, argvals)
                )
                return Reflector.invokeStaticMethod(c, methodName, argvals)
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public boolean canEmitPrimitive()
        (§
            return (method != null && Util.isPrimitive(method.getReturnType()))
        )

        public boolean canEmitIntrinsicPredicate()
        (§
            return (method != null && RT.get(Intrinsics.preds, method.toString()) != null)
        )

        public void emitIntrinsicPredicate(C context, ObjExpr objx, GeneratorAdapter gen, Label falseLabel)
        (§
            gen.visitLineNumber(line, gen.mark())
            if (method != null)
            (§
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Object[] predOps = (Object[]) RT.get(Intrinsics.preds, method.toString())
                for (int i = 0 i < predOps.length - 1 i++)
                (§
                    gen.visitInsn((Integer)predOps[i])
                )
                gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel)
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != null)
            (§
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Object ops = RT.get(Intrinsics.ops, method.toString())
                if (ops != null)
                (§
                    if (ops instanceof Object[])
                    (§
                        for (Object op :in (Object[])ops)
                        (§
                            gen.visitInsn((Integer) op)
                        )
                    )
                    else
                    (§
                        gen.visitInsn((Integer) ops)
                    )
                )
                else
                (§
                    Type type = Type.getType(c)
                    Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                    gen.invokeStatic(type, m)
                )
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != null)
            (§
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (tailPosition && !objx.canBeDirect)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearThis(gen)
                )
                Type type = Type.getType(c)
                Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                gen.invokeStatic(type, m)
                Class retClass = method.getReturnType()
                if (context == C.STATEMENT)
                (§
                    if (retClass == long.class || retClass == double.class)
                    (§
                        gen.pop2()
                    )
                    else if (retClass != void.class)
                    (§
                        gen.pop()
                    )
                )
                else
                (§
                    HostExpr.emitBoxReturn(objx, gen, method.getReturnType())
                )
            )
            else
            (§
                gen.visitLineNumber(line, gen.mark())
                gen.push(c.getName())
                gen.invokeStatic(RT_TYPE, forNameMethod)
                gen.push(methodName)
                emitArgsAsArray(args, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod)
                if (context == C.STATEMENT)
                (§
                    gen.pop()
                )
            )
        )

        public boolean hasJavaClass()
        (§
            return (method != null || tag != null)
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = retType((tag != null) ? HostExpr.tagToClass(tag) :or null, (method != null) ? method.getReturnType() :or null)
            )
            return jc
        )
    )

    static class UnresolvedVarExpr implements Expr
    (§
        public final Symbol symbol

        public UnresolvedVarExpr(Symbol symbol)
        (§
            this.symbol = symbol
        )

        public boolean hasJavaClass()
        (§
            return false
        )

        public Class getJavaClass()
        (§
            throw new IllegalArgumentException("UnresolvedVarExpr has no Java class")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
        )

        public Object eval()
        (§
            throw new IllegalArgumentException("UnresolvedVarExpr cannot be evalled")
        )
    )

    static class NumberExpr extends LiteralExpr implements MaybePrimitiveExpr
    (§
        final Number n
        public final int id

        public NumberExpr(Number n)
        (§
            this.n = n
            this.id = registerConstant(n)
        )

        Object val()
        (§
            return n
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (context != C.STATEMENT)
            (§
                objx.emitConstant(gen, id)
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            if (n instanceof Integer)
            (§
                return long.class
            )
            else if (n instanceof Double)
            (§
                return double.class
            )
            else if (n instanceof Long)
            (§
                return long.class
            )
            else
            (§
                throw new IllegalStateException("Unsupported Number type: " + n.getClass().getName())
            )
        )

        public boolean canEmitPrimitive()
        (§
            return true
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (n instanceof Integer)
            (§
                gen.push(n.longValue())
            )
            else if (n instanceof Double)
            (§
                gen.push(n.doubleValue())
            )
            else if (n instanceof Long)
            (§
                gen.push(n.longValue())
            )
        )

        static public Expr parse(Number form)
        (§
            if (form instanceof Integer || form instanceof Double || form instanceof Long)
            (§
                return new NumberExpr(form)
            )
            else
            (§
                return new ConstantExpr(form)
            )
        )
    )

    static class ConstantExpr extends LiteralExpr
    (§
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        public final Object v
        public final int id

        public ConstantExpr(Object v)
        (§
            this.v = v
            this.id = registerConstant(v)
        )

        Object val()
        (§
            return v
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitConstant(gen, id)

            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return Modifier.isPublic(v.getClass().getModifiers())
        )

        public Class getJavaClass()
        (§
            if (v instanceof APersistentMap)
            (§
                return APersistentMap.class
            )
            else if (v instanceof APersistentSet)
            (§
                return APersistentSet.class
            )
            else if (v instanceof APersistentVector)
            (§
                return APersistentVector.class
            )
            else
            (§
                return v.getClass()
            )
        )

        static class Parser implements IParser
        (§
            static Keyword formKey = Keyword.intern("form")

            public Expr parse(C context, Object form)
            (§
                int argCount = RT.count(form) - 1
                if (argCount != 1)
                (§
                    IPersistentMap exData = new PersistentArrayMap(new Object[] (§ formKey, form ))
                    throw new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData)
                )
                Object v = RT.second(form)

                if (v == null)
                (§
                    return NIL_EXPR
                )
                else if (v == Boolean.TRUE)
                (§
                    return TRUE_EXPR
                )
                else if (v == Boolean.FALSE)
                (§
                    return FALSE_EXPR
                )
                if (v instanceof Number)
                (§
                    return NumberExpr.parse((Number)v)
                )
                else if (v instanceof String)
                (§
                    return new StringExpr((String) v)
                )
                else if (v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0)
                (§
                    return new EmptyExpr(v)
                )
                else
                (§
                    return new ConstantExpr(v)
                )
            )
        )
    )

    static class NilExpr extends LiteralExpr
    (§
        Object val()
        (§
            return null
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.visitInsn(Opcodes.ACONST_NULL)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return null
        )
    )

    final static NilExpr NIL_EXPR = new NilExpr()

    static class BooleanExpr extends LiteralExpr
    (§
        public final boolean val

        public BooleanExpr(boolean val)
        (§
            this.val = val
        )

        Object val()
        (§
            return val ? RT.T :or RT.F
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (val)
            (§
                gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE)
            )
            else
            (§
                gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return Boolean.class
        )
    )

    final static BooleanExpr TRUE_EXPR = new BooleanExpr(true)
    final static BooleanExpr FALSE_EXPR = new BooleanExpr(false)

    static class StringExpr extends LiteralExpr
    (§
        public final String str

        public StringExpr(String str)
        (§
            this.str = str
        )

        Object val()
        (§
            return str
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (context != C.STATEMENT)
            (§
                gen.push(str)
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return String.class
        )
    )

    static class MonitorEnterExpr extends UntypedExpr
    (§
        final Expr target

        public MonitorEnterExpr(Expr target)
        (§
            this.target = target
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval monitor-enter")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            target.emit(C.EXPRESSION, objx, gen)
            gen.monitorEnter()
            NIL_EXPR.emit(context, objx, gen)
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                return new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form)))
            )
        )
    )

    static class MonitorExitExpr extends UntypedExpr
    (§
        final Expr target

        public MonitorExitExpr(Expr target)
        (§
            this.target = target
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval monitor-exit")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            target.emit(C.EXPRESSION, objx, gen)
            gen.monitorExit()
            NIL_EXPR.emit(context, objx, gen)
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                return new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form)))
            )
        )
    )

    public static class TryExpr implements Expr
    (§
        public final Expr tryExpr
        public final Expr finallyExpr
        public final PersistentVector catchExprs
        public final int retLocal
        public final int finallyLocal

        public static class CatchClause
        (§
            public final Class c
            public final LocalBinding lb
            public final Expr handler
            Label label
            Label endLabel

            public CatchClause(Class c, LocalBinding lb, Expr handler)
            (§
                this.c = c
                this.lb = lb
                this.handler = handler
            )
        )

        public TryExpr(Expr tryExpr, PersistentVector catchExprs, Expr finallyExpr, int retLocal, int finallyLocal)
        (§
            this.tryExpr = tryExpr
            this.catchExprs = catchExprs
            this.finallyExpr = finallyExpr
            this.retLocal = retLocal
            this.finallyLocal = finallyLocal
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval try")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label startTry = gen.newLabel()
            Label endTry = gen.newLabel()
            Label end = gen.newLabel()
            Label ret = gen.newLabel()
            Label finallyLabel = gen.newLabel()
            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                clause.label = gen.newLabel()
                clause.endLabel = gen.newLabel()
            )

            gen.mark(startTry)
            tryExpr.emit(context, objx, gen)
            if (context != C.STATEMENT)
            (§
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal)
            )
            gen.mark(endTry)
            if (finallyExpr != null)
            (§
                finallyExpr.emit(C.STATEMENT, objx, gen)
            )
            gen.goTo(ret)

            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                gen.mark(clause.label)
                ;; exception should be on stack
                ;; put in clause local
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx)
                clause.handler.emit(context, objx, gen)
                if (context != C.STATEMENT)
                (§
                    gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal)
                )
                gen.mark(clause.endLabel)

                if (finallyExpr != null)
                (§
                    finallyExpr.emit(C.STATEMENT, objx, gen)
                )
                gen.goTo(ret)
            )
            if (finallyExpr != null)
            (§
                gen.mark(finallyLabel)
                ;; exception should be on stack
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal)
                finallyExpr.emit(C.STATEMENT, objx, gen)
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal)
                gen.throwException()
            )
            gen.mark(ret)
            if (context != C.STATEMENT)
            (§
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal)
            )
            gen.mark(end)
            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace((§ char \.), (§ char \/)))
            )
            if (finallyExpr != null)
            (§
                gen.visitTryCatchBlock(startTry, endTry, finallyLabel, null)
                for (int i = 0 i < catchExprs.count() i++)
                (§
                    CatchClause clause = (CatchClause) catchExprs.nth(i)
                    gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, null)
                )
            )
            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", null, clause.label, clause.endLabel, clause.lb.idx)
            )
        )

        public boolean hasJavaClass()
        (§
            return tryExpr.hasJavaClass()
        )

        public Class getJavaClass()
        (§
            return tryExpr.getJavaClass()
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                if (context != C.RETURN)
                (§
                    return analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))
                )

                ;; (try try-expr* catch-expr* finally-expr?)
                ;; catch-expr: (catch class sym expr*)
                ;; finally-expr: (finally expr*)

                PersistentVector body = PersistentVector.EMPTY
                PersistentVector catches = PersistentVector.EMPTY
                Expr bodyExpr = null
                Expr finallyExpr = null
                boolean caught = false

                int retLocal = getAndIncLocalNum()
                int finallyLocal = getAndIncLocalNum()
                for (ISeq fs = form.next() fs != null fs = fs.next())
                (§
                    Object f = fs.first()
                    Object op = (f instanceof ISeq) ? ((ISeq) f).first() :or null
                    if (!Util.equals(op, CATCH) && !Util.equals(op, FINALLY))
                    (§
                        if (caught)
                        (§
                            throw Util.runtimeException("Only catch or finally clause can follow catch in try expression")
                        )
                        body = body.cons(f)
                    )
                    else
                    (§
                        if (bodyExpr == null)
                        (§
                            try
                            (§
                                Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, null))
                                bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body))
                            )
                            finally
                            (§
                                Var.popThreadBindings()
                            )
                        )

                        if (Util.equals(op, CATCH))
                        (§
                            Class c = HostExpr.maybeClass(RT.second(f), false)
                            if (c == null)
                            (§
                                throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(f))
                            )
                            if (!(RT.third(f) instanceof Symbol))
                            (§
                                throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f))
                            )
                            Symbol sym = (Symbol) RT.third(f)
                            if (sym.getNamespace() != null)
                            (§
                                throw Util.runtimeException("Can't bind qualified name:" + sym)
                            )

                            IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T)
                            try
                            (§
                                Var.pushThreadBindings(dynamicBindings)
                                LocalBinding lb = registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or null), null, false)
                                Expr handler = (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f))))
                                catches = catches.cons(new CatchClause(c, lb, handler))
                            )
                            finally
                            (§
                                Var.popThreadBindings()
                            )
                            caught = true
                        )
                        else ;; finally
                        (§
                            if (fs.next() != null)
                            (§
                                throw Util.runtimeException("finally clause must be last in try expression")
                            )
                            try
                            (§
                                Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T))
                                finallyExpr = (new BodyExpr.Parser()).parse(C.STATEMENT, RT.next(f))
                            )
                            finally
                            (§
                                Var.popThreadBindings()
                            )
                        )
                    )
                )
                if (bodyExpr == null)
                (§
                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                    ;; return a body expr directly
                    try
                    (§
                        Var.pushThreadBindings(RT.map(NO_RECUR, true))
                        bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body))
                    )
                    finally
                    (§
                        Var.popThreadBindings()
                    )
                    return bodyExpr
                )

                return new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal)
            )
        )
    )

    static class ThrowExpr extends UntypedExpr
    (§
        public final Expr excExpr

        public ThrowExpr(Expr excExpr)
        (§
            this.excExpr = excExpr
        )

        public Object eval()
        (§
            throw Util.runtimeException("Can't eval throw")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            excExpr.emit(C.EXPRESSION, objx, gen)
            gen.checkCast(THROWABLE_TYPE)
            gen.throwException()
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                if (context == C.EVAL)
                (§
                    return analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))
                )
                else if (RT.count(form) == 1)
                (§
                    throw Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance")
                )
                else if (RT.count(form) > 2)
                (§
                    throw Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance")
                )
                return new ThrowExpr(analyze(C.EXPRESSION, RT.second(form)))
            )
        )
    )

    static public boolean subsumes(Class[] c1, Class[] c2)
    (§
        ;; presumes matching lengths
        Boolean better = false
        for (int i = 0 i < c1.length i++)
        (§
            if (c1[i] != c2[i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
            (§
                if (!c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i]))
                (§
                    better = true
                )
                else
                (§
                    return false
                )
            )
        )
        return better
    )

    static String getTypeStringForArgs(IPersistentVector args)
    (§
        StringBuilder sb = new StringBuilder()
        for (int i = 0 i < args.count() i++)
        (§
            Expr arg = (Expr) args.nth(i)
            if (i > 0)
            (§
                sb.append(", ")
            )
            sb.append((arg.hasJavaClass() && arg.getJavaClass() != null) ? arg.getJavaClass().getName() :or "unknown")
        )
        return sb.toString()
    )

    static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs, List<Class> rets)
    (§
        ;; presumes matching lengths
        int matchIdx = -1
        boolean tied = false
        boolean foundExact = false
        for (int i = 0 i < paramlists.size() i++)
        (§
            boolean match = true
            ISeq aseq = argexprs.seq()
            int exact = 0
            for (int p = 0 match && p < argexprs.count() && aseq != null ++p, aseq = aseq.next())
            (§
                Expr arg = (Expr) aseq.first()
                Class aclass = arg.hasJavaClass() ? arg.getJavaClass() :or Object.class
                Class pclass = paramlists.get(i)[p]
                if (arg.hasJavaClass() && aclass == pclass)
                (§
                    exact++
                )
                else
                (§
                    match = Reflector.paramArgTypeMatch(pclass, aclass)
                )
            )
            if (exact == argexprs.count())
            (§
                if (!foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                (§
                    matchIdx = i
                )
                tied = false
                foundExact = true
            )
            else if (match && !foundExact)
            (§
                if (matchIdx == -1)
                (§
                    matchIdx = i
                )
                else
                (§
                    if (subsumes(paramlists.get(i), paramlists.get(matchIdx)))
                    (§
                        matchIdx = i
                        tied = false
                    )
                    else if (Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
                    (§
                        if (rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                        (§
                            matchIdx = i
                        )
                    )
                    else if (!(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
                    (§
                        tied = true
                    )
                )
            )
        )
        if (tied)
        (§
            throw new IllegalArgumentException("More than one matching method found: " + methodName)
        )

        return matchIdx
    )

    public static class NewExpr implements Expr
    (§
        public final IPersistentVector args
        public final Constructor ctor
        public final Class c

        final static Method invokeConstructorMethod = Method.getMethod("Object invokeConstructor(Class,Object[])")
        final static Method forNameMethod = Method.getMethod("Class classForName(String)")

        public NewExpr(Class c, IPersistentVector args, int line, int column)
        (§
            this.args = args
            this.c = c
            Constructor[] allctors = c.getConstructors()
            ArrayList ctors = new ArrayList()
            ArrayList<Class[]> params = new ArrayList()
            ArrayList<Class> rets = new ArrayList()
            for (int i = 0 i < allctors.length i++)
            (§
                Constructor ctor = allctors[i]
                if (ctor.getParameterTypes().length == args.count())
                (§
                    ctors.add(ctor)
                    params.add(ctor.getParameterTypes())
                    rets.add(c)
                )
            )
            if (ctors.isEmpty())
            (§
                throw new IllegalArgumentException("No matching ctor found for " + c)
            )

            int ctoridx = 0
            if (ctors.size() > 1)
            (§
                ctoridx = getMatchingParams(c.getName(), params, args, rets)
            )

            this.ctor = (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or null
            if (ctor == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n",
                            SOURCE_PATH.deref(), line, column, c.getName())
            )
        )

        public Object eval()
        (§
            Object[] argvals = new Object[args.count()]
            for (int i = 0 i < args.count() i++)
            (§
                argvals[i] = ((Expr) args.nth(i)).eval()
            )
            if (this.ctor != null)
            (§
                try
                (§
                    return ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))
                )
                catch (Exception e)
                (§
                    throw Util.sneakyThrow(e)
                )
            )
            return Reflector.invokeConstructor(c, argvals)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (this.ctor != null)
            (§
                Type type = getType(c)
                gen.newInstance(type)
                gen.dup()
                MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args)
                gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor)))
            )
            else
            (§
                gen.push(destubClassName(c.getName()))
                gen.invokeStatic(RT_TYPE, forNameMethod)
                MethodExpr.emitArgsAsArray(args, objx, gen)
                gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return c
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                int line = lineDeref()
                int column = columnDeref()
                ISeq form = (ISeq) frm
                ;; (new Classname args...)
                if (form.count() < 2)
                (§
                    throw Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)")
                )
                Class c = HostExpr.maybeClass(RT.second(form), false)
                if (c == null)
                (§
                    throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(form))
                )
                PersistentVector args = PersistentVector.EMPTY
                for (ISeq s = RT.next(RT.next(form)) s != null s = s.next())
                (§
                    args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first()))
                )
                return new NewExpr(c, args, line, column)
            )
        )
    )

    public static class MetaExpr implements Expr
    (§
        public final Expr expr
        public final Expr meta

        final static Type IOBJ_TYPE = Type.getType(IObj.class)
        final static Method withMetaMethod = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")

        public MetaExpr(Expr expr, Expr meta)
        (§
            this.expr = expr
            this.meta = meta
        )

        public Object eval()
        (§
            return ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval())
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            gen.checkCast(IOBJ_TYPE)
            meta.emit(C.EXPRESSION, objx, gen)
            gen.checkCast(IPERSISTENTMAP_TYPE)
            gen.invokeInterface(IOBJ_TYPE, withMetaMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return expr.hasJavaClass()
        )

        public Class getJavaClass()
        (§
            return expr.getJavaClass()
        )
    )

    public static class IfExpr implements Expr, MaybePrimitiveExpr
    (§
        public final Expr testExpr
        public final Expr thenExpr
        public final Expr elseExpr
        public final int line
        public final int column

        public IfExpr(int line, int column, Expr testExpr, Expr thenExpr, Expr elseExpr)
        (§
            this.testExpr = testExpr
            this.thenExpr = thenExpr
            this.elseExpr = elseExpr
            this.line = line
            this.column = column
        )

        public Object eval()
        (§
            Object t = testExpr.eval()
            if (t != null && t != Boolean.FALSE)
            (§
                return thenExpr.eval()
            )
            return elseExpr.eval()
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, false)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, true)
        )

        public void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
        (§
            Label nullLabel = gen.newLabel()
            Label falseLabel = gen.newLabel()
            Label endLabel = gen.newLabel()

            gen.visitLineNumber(line, gen.mark())

            if (testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
            (§
                ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel)
            )
            else if (maybePrimitiveType(testExpr) == boolean.class)
            (§
                ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen)
                gen.ifZCmp(gen.EQ, falseLabel)
            )
            else
            (§
                testExpr.emit(C.EXPRESSION, objx, gen)
                gen.dup()
                gen.ifNull(nullLabel)
                gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
                gen.visitJumpInsn(IF_ACMPEQ, falseLabel)
            )
            if (emitUnboxed)
            (§
                ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen)
            )
            else
            (§
                thenExpr.emit(context, objx, gen)
            )
            gen.goTo(endLabel)
            gen.mark(nullLabel)
            gen.pop()
            gen.mark(falseLabel)
            if (emitUnboxed)
            (§
                ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen)
            )
            else
            (§
                elseExpr.emit(context, objx, gen)
            )
            gen.mark(endLabel)
        )

        public boolean hasJavaClass()
        (§
            return thenExpr.hasJavaClass()
                && elseExpr.hasJavaClass()
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                    || thenExpr.getJavaClass() == RECUR_CLASS
                    || elseExpr.getJavaClass() == RECUR_CLASS
                    || (thenExpr.getJavaClass() == null && !elseExpr.getJavaClass().isPrimitive())
                    || (elseExpr.getJavaClass() == null && !thenExpr.getJavaClass().isPrimitive()))
        )

        public boolean canEmitPrimitive()
        (§
            try
            (§
                return thenExpr instanceof MaybePrimitiveExpr
                    && elseExpr instanceof MaybePrimitiveExpr
                    && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                            || thenExpr.getJavaClass() == RECUR_CLASS
                            || elseExpr.getJavaClass() == RECUR_CLASS)
                    && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                    && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive()
            )
            catch (Exception e)
            (§
                return false
            )
        )

        public Class getJavaClass()
        (§
            Class thenClass = thenExpr.getJavaClass()
            if (thenClass != null && thenClass != RECUR_CLASS)
            (§
                return thenClass
            )
            return elseExpr.getJavaClass()
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (if test then) or (if test then else)
                if (form.count() > 4)
                (§
                    throw Util.runtimeException("Too many arguments to if")
                )
                else if (form.count() < 3)
                (§
                    throw Util.runtimeException("Too few arguments to if")
                )
                PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get())
                Expr testexpr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form))
                Expr thenexpr, elseexpr
                try
                (§
                    Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                    thenexpr = analyze(context, RT.third(form))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
                try
                (§
                    Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                    elseexpr = analyze(context, RT.fourth(form))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
                return new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr)
            )
        )
    )

    static final public IPersistentMap CHAR_MAP =
        PersistentHashMap.create(
            (§ char \-), "_",
            (§ char \:), "_COLON_",
            (§ char \+), "_PLUS_",
            (§ char \>), "_GT_",
            (§ char \<), "_LT_",
            (§ char \=), "_EQ_",
            (§ char \~), "_TILDE_",
            (§ char \!), "_BANG_",
            (§ char \@), "_CIRCA_",
            (§ char \#), "_SHARP_",
            (§ char \'), "_SINGLEQUOTE_",
            (§ char \"), "_DOUBLEQUOTE_", ;; oops! "
            (§ char \%), "_PERCENT_",
            (§ char \^), "_CARET_",
            (§ char \&), "_AMPERSAND_",
            (§ char \*), "_STAR_",
            (§ char \|), "_BAR_",
            (§ char \{), "_LBRACE_",
            (§ char \}), "_RBRACE_",
            (§ char \[), "_LBRACK_",
            (§ char \]), "_RBRACK_",
            (§ char \/), "_SLASH_",
            (§ char \\), "_BSLASH_",
            (§ char \?), "_QMARK_"
        )

    static final public IPersistentMap DEMUNGE_MAP
    static final public Pattern DEMUNGE_PATTERN

    static
    (§
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        IPersistentMap m = RT.map("$", (§ char \/))
        for (ISeq s = RT.seq(CHAR_MAP) s != null s = s.next())
        (§
            IMapEntry e = (IMapEntry) s.first()
            Character origCh = (Character) e.key()
            String escapeStr = (String) e.val()
            m = m.assoc(escapeStr, origCh)
        )
        DEMUNGE_MAP = m

        ;; DEMUNGE_PATTERN searches for the first of any occurrence of
        ;; the strings that are keys of DEMUNGE_MAP.
        ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
        ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
        ;; as desired.  Sorting string keys of DEMUNGE_MAP from longest to
        ;; shortest ensures correct matching behavior, even if some strings are
        ;; prefixes of others.
        Object[] mungeStrs = RT.toArray(RT.keys(m))
        Arrays.sort(mungeStrs, new Comparator()
        (§
            public int compare(Object s1, Object s2)
            (§
                return ((String) s2).length() - ((String) s1).length()
            )
        ))
        StringBuilder sb = new StringBuilder()
        boolean first = true
        for (Object s :in mungeStrs)
        (§
            String escapeStr = (String) s
            if (!first)
            (§
                sb.append("|")
            )
            first = false
            sb.append("\\Q")
            sb.append(escapeStr)
            sb.append("\\E")
        )
        DEMUNGE_PATTERN = Pattern.compile(sb.toString())
    )

    static public String munge(String name)
    (§
        StringBuilder sb = new StringBuilder()
        for (char c :in name.toCharArray())
        (§
            String sub = (String) CHAR_MAP.valAt(c)
            if (sub != null)
            (§
                sb.append(sub)
            )
            else
            (§
                sb.append(c)
            )
        )
        return sb.toString()
    )

    static public String demunge(String mungedName)
    (§
        StringBuilder sb = new StringBuilder()
        Matcher m = DEMUNGE_PATTERN.matcher(mungedName)
        int lastMatchEnd = 0
        while (m.find())
        (§
            int start = m.start()
            int end = m.end()
            ;; Keep everything before the match
            sb.append(mungedName.substring(lastMatchEnd, start))
            lastMatchEnd = end
            ;; Replace the match with DEMUNGE_MAP result
            Character origCh = (Character) DEMUNGE_MAP.valAt(m.group())
            sb.append(origCh)
        )
        ;; Keep everything after the last match
        sb.append(mungedName.substring(lastMatchEnd))
        return sb.toString()
    )

    public static class EmptyExpr implements Expr
    (§
        public final Object coll

        final static Type HASHMAP_TYPE = Type.getType(PersistentArrayMap.class)
        final static Type HASHSET_TYPE = Type.getType(PersistentHashSet.class)
        final static Type VECTOR_TYPE = Type.getType(PersistentVector.class)
        final static Type IVECTOR_TYPE = Type.getType(IPersistentVector.class)
        final static Type TUPLE_TYPE = Type.getType(Tuple.class)
        final static Type LIST_TYPE = Type.getType(PersistentList.class)
        final static Type EMPTY_LIST_TYPE = Type.getType(PersistentList.EmptyList.class)

        public EmptyExpr(Object coll)
        (§
            this.coll = coll
        )

        public Object eval()
        (§
            return coll
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (coll instanceof IPersistentList)
            (§
                gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE)
            )
            else if (coll instanceof IPersistentVector)
            (§
                gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE)
            )
            else if (coll instanceof IPersistentMap)
            (§
                gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE)
            )
            else if (coll instanceof IPersistentSet)
            (§
                gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE)
            )
            else
            (§
                throw new UnsupportedOperationException("Unknown Collection type")
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            if (coll instanceof IPersistentList)
            (§
                return IPersistentList.class
            )
            else if (coll instanceof IPersistentVector)
            (§
                return IPersistentVector.class
            )
            else if (coll instanceof IPersistentMap)
            (§
                return IPersistentMap.class
            )
            else if (coll instanceof IPersistentSet)
            (§
                return IPersistentSet.class
            )
            else
            (§
                throw new UnsupportedOperationException("Unknown Collection type")
            )
        )
    )

    public static class ListExpr implements Expr
    (§
        public final IPersistentVector args

        final static Method arrayToListMethod = Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])")

        public ListExpr(IPersistentVector args)
        (§
            this.args = args
        )

        public Object eval()
        (§
            IPersistentVector ret = PersistentVector.EMPTY
            for (int i = 0 i < args.count() i++)
            (§
                ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval())
            )
            return ret.seq()
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            MethodExpr.emitArgsAsArray(args, objx, gen)
            gen.invokeStatic(RT_TYPE, arrayToListMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return IPersistentList.class
        )
    )

    public static class MapExpr implements Expr
    (§
        public final IPersistentVector keyvals

        final static Method mapMethod = Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")
        final static Method mapUniqueKeysMethod = Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])")

        public MapExpr(IPersistentVector keyvals)
        (§
            this.keyvals = keyvals
        )

        public Object eval()
        (§
            Object[] ret = new Object[keyvals.count()]
            for (int i = 0 i < keyvals.count() i++)
            (§
                ret[i] = ((Expr) keyvals.nth(i)).eval()
            )
            return RT.map(ret)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            boolean allKeysConstant = true
            boolean allConstantKeysUnique = true
            IPersistentSet constantKeys = PersistentHashSet.EMPTY
            for (int i = 0 i < keyvals.count() i+=2)
            (§
                Expr k = (Expr) keyvals.nth(i)
                if (k instanceof LiteralExpr)
                (§
                    Object kval = k.eval()
                    if (constantKeys.contains(kval))
                    (§
                        allConstantKeysUnique = false
                    )
                    else
                    (§
                        constantKeys = (IPersistentSet)constantKeys.cons(kval)
                    )
                )
                else
                (§
                    allKeysConstant = false
                )
            )
            MethodExpr.emitArgsAsArray(keyvals, objx, gen)
            if ((allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2))
            (§
                gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod)
            )
            else
            (§
                gen.invokeStatic(RT_TYPE, mapMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return IPersistentMap.class
        )

        static public Expr parse(C context, IPersistentMap form)
        (§
            IPersistentVector keyvals = PersistentVector.EMPTY
            boolean keysConstant = true
            boolean valsConstant = true
            boolean allConstantKeysUnique = true
            IPersistentSet constantKeys = PersistentHashSet.EMPTY
            for (ISeq s = RT.seq(form) s != null s = s.next())
            (§
                IMapEntry e = (IMapEntry) s.first()
                Expr k = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key())
                Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val())
                keyvals = (IPersistentVector) keyvals.cons(k)
                keyvals = (IPersistentVector) keyvals.cons(v)
                if (k instanceof LiteralExpr)
                (§
                    Object kval = k.eval()
                    if (constantKeys.contains(kval))
                    (§
                        allConstantKeysUnique = false
                    )
                    else
                    (§
                        constantKeys = (IPersistentSet)constantKeys.cons(kval)
                    )
                )
                else
                (§
                    keysConstant = false
                )
                if (!(v instanceof LiteralExpr))
                (§
                    valsConstant = false
                )
            )

            Expr ret = new MapExpr(keyvals)
            if (form instanceof IObj && ((IObj) form).meta() != null)
            (§
                return new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))
            )
            else if (keysConstant)
            (§
                ;; TBD: Add more detail to exception thrown below.
                if (!allConstantKeysUnique)
                (§
                    throw new IllegalArgumentException("Duplicate constant keys in map")
                )
                if (valsConstant)
                (§
                    IPersistentMap m = PersistentArrayMap.EMPTY
                    for (int i = 0 i < keyvals.length() i += 2)
                    (§
                        m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val())
                    )
                    return new ConstantExpr(m)
                )
                else
                (§
                    return ret
                )
            )
            else
            (§
                return ret
            )
        )
    )

    public static class SetExpr implements Expr
    (§
        public final IPersistentVector keys

        final static Method setMethod = Method.getMethod("cloiure.lang.IPersistentSet set(Object[])")

        public SetExpr(IPersistentVector keys)
        (§
            this.keys = keys
        )

        public Object eval()
        (§
            Object[] ret = new Object[keys.count()]
            for (int i = 0 i < keys.count() i++)
            (§
                ret[i] = ((Expr) keys.nth(i)).eval()
            )
            return RT.set(ret)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            MethodExpr.emitArgsAsArray(keys, objx, gen)
            gen.invokeStatic(RT_TYPE, setMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return IPersistentSet.class
        )

        static public Expr parse(C context, IPersistentSet form)
        (§
            IPersistentVector keys = PersistentVector.EMPTY
            boolean constant = true

            for (ISeq s = RT.seq(form) s != null s = s.next())
            (§
                Object e = s.first()
                Expr expr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e)
                keys = (IPersistentVector) keys.cons(expr)
                if (!(expr instanceof LiteralExpr))
                (§
                    constant = false
                )
            )
            Expr ret = new SetExpr(keys)
            if (form instanceof IObj && ((IObj) form).meta() != null)
            (§
                return new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))
            )
            else if (constant)
            (§
                IPersistentSet set = PersistentHashSet.EMPTY
                for (int i = 0 i < keys.count() i++)
                (§
                    LiteralExpr ve = (LiteralExpr)keys.nth(i)
                    set = (IPersistentSet)set.cons(ve.val())
                )
                return new ConstantExpr(set)
            )
            else
            (§
                return ret
            )
        )
    )

    public static class VectorExpr implements Expr
    (§
        public final IPersistentVector args

        final static Method vectorMethod = Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")

        public VectorExpr(IPersistentVector args)
        (§
            this.args = args
        )

        public Object eval()
        (§
            IPersistentVector ret = PersistentVector.EMPTY
            for (int i = 0 i < args.count() i++)
            (§
                ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval())
            )
            return ret
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (args.count() <= Tuple.MAX_SIZE)
            (§
                for (int i = 0 i < args.count() i++)
                (§
                    ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen)
                )
                gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()])
            )
            else
            (§
                MethodExpr.emitArgsAsArray(args, objx, gen)
                gen.invokeStatic(RT_TYPE, vectorMethod)
            )

            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return IPersistentVector.class
        )

        static public Expr parse(C context, IPersistentVector form)
        (§
            boolean constant = true

            IPersistentVector args = PersistentVector.EMPTY
            for (int i = 0 i < form.count() i++)
            (§
                Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i))
                args = (IPersistentVector) args.cons(v)
                if (!(v instanceof LiteralExpr))
                (§
                    constant = false
                )
            )
            Expr ret = new VectorExpr(args)
            if (form instanceof IObj && ((IObj) form).meta() != null)
            (§
                return new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))
            )
            else if (constant)
            (§
                IPersistentVector rv = PersistentVector.EMPTY
                for (int i = 0 i < args.count() i++)
                (§
                    LiteralExpr ve = (LiteralExpr)args.nth(i)
                    rv = rv.cons(ve.val())
                )
                return new ConstantExpr(rv)
            )
            else
            (§
                return ret
            )
        )
    )

    static class KeywordInvokeExpr implements Expr
    (§
        public final KeywordExpr kw
        public final Object tag
        public final Expr target
        public final int line
        public final int column
        public final int siteIndex
        public final String source

        static Type ILOOKUP_TYPE = Type.getType(ILookup.class)

        Class jc

        public KeywordInvokeExpr(String source, int line, int column, Symbol tag, KeywordExpr kw, Expr target)
        (§
            this.source = source
            this.kw = kw
            this.target = target
            this.line = line
            this.column = column
            this.tag = tag
            this.siteIndex = registerKeywordCallsite(kw.k)
        )

        public Object eval()
        (§
            try
            (§
                return kw.k.invoke(target.eval())
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label endLabel = gen.newLabel()
            Label faultLabel = gen.newLabel()

            gen.visitLineNumber(line, gen.mark())
            gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)
            gen.dup() ;; thunk, thunk
            target.emit(C.EXPRESSION, objx, gen) ;; thunk, thunk, target
            gen.visitLineNumber(line, gen.mark())
            gen.dupX2() ;; target, thunk, thunk, target
            gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)")) ;; target, thunk, result
            gen.dupX2() ;; result, target, thunk, result
            gen.visitJumpInsn(IF_ACMPEQ, faultLabel) ;; result, target
            gen.pop() ;; result
            gen.goTo(endLabel)

            gen.mark(faultLabel) ;; result, target
            gen.swap() ;; target, result
            gen.pop() ;; target
            gen.dup() ;; target, target
            gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE) ;; target, target, site
            gen.swap() ;; target, site, target
            gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)")) ;; target, new-thunk
            gen.dup() ;; target, new-thunk, new-thunk
            gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE) ;; target, new-thunk
            gen.swap() ;; new-thunk, target
            gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)")) ;; result

            gen.mark(endLabel)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return (tag != null)
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = HostExpr.tagToClass(tag)
            )
            return jc
        )
    )

    public static class InstanceOfExpr implements Expr, MaybePrimitiveExpr
    (§
        Expr expr
        Class c

        public InstanceOfExpr(Class c, Expr expr)
        (§
            this.expr = expr
            this.c = c
        )

        public Object eval()
        (§
            if (c.isInstance(expr.eval()))
            (§
                return RT.T
            )
            return RT.F
        )

        public boolean canEmitPrimitive()
        (§
            return true
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            gen.instanceOf(getType(c))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            emitUnboxed(context, objx, gen)
            HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return Boolean.TYPE
        )
    )

    static class StaticInvokeExpr implements Expr, MaybePrimitiveExpr
    (§
        public final Type target
        public final Class retClass
        public final Class[] paramclasses
        public final Type[] paramtypes
        public final IPersistentVector args
        public final boolean variadic
        public final boolean tailPosition
        public final Object tag

        Class jc

        StaticInvokeExpr(Type target, Class retClass, Class[] paramclasses, Type[] paramtypes, boolean variadic, IPersistentVector args, Object tag, boolean tailPosition)
        (§
            this.target = target
            this.retClass = retClass
            this.paramclasses = paramclasses
            this.paramtypes = paramtypes
            this.args = args
            this.variadic = variadic
            this.tailPosition = tailPosition
            this.tag = tag
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval StaticInvokeExpr")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            emitUnboxed(context, objx, gen)
            if (context != C.STATEMENT)
            (§
                HostExpr.emitBoxReturn(objx, gen, retClass)
            )
            if (context == C.STATEMENT)
            (§
                if (retClass == long.class || retClass == double.class)
                (§
                    gen.pop2()
                )
                else
                (§
                    gen.pop()
                )
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = retType((tag != null) ? HostExpr.tagToClass(tag) :or null, retClass)
            )
            return jc
        )

        public boolean canEmitPrimitive()
        (§
            return retClass.isPrimitive()
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Method ms = new Method("invokeStatic", getReturnType(), paramtypes)
            if (variadic)
            (§
                for (int i = 0 i < paramclasses.length - 1 i++)
                (§
                    Expr e = (Expr) args.nth(i)
                    if (maybePrimitiveType(e) == paramclasses[i])
                    (§
                        ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    else
                    (§
                        e.emit(C.EXPRESSION, objx, gen)
                        HostExpr.emitUnboxArg(objx, gen, paramclasses[i])
                    )
                )
                IPersistentVector restArgs = RT.subvec(args, paramclasses.length - 1, args.count())
                MethodExpr.emitArgsAsArray(restArgs, objx, gen)
                gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])"))
            )
            else
            (§
                MethodExpr.emitTypedArgs(objx, gen, paramclasses, args)
            )

            if (tailPosition && !objx.canBeDirect)
            (§
                ObjMethod method = (ObjMethod) METHOD.deref()
                method.emitClearThis(gen)
            )

            gen.invokeStatic(target, ms)
        )

        private Type getReturnType()
        (§
            return Type.getType(retClass)
        )

        public static Expr parse(Var v, ISeq args, Object tag, boolean tailPosition)
        (§
            if (!v.isBound() || v.get() == null)
            (§
                return null
            )
            Class c = v.get().getClass()
            String cname = c.getName()

            java.lang.reflect.Method[] allmethods = c.getMethods()

            boolean variadic = false
            int argcount = RT.count(args)
            java.lang.reflect.Method method = null
            for (java.lang.reflect.Method m :in allmethods)
            (§
                if (Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic"))
                (§
                    Class[] params = m.getParameterTypes()
                    if (argcount == params.length)
                    (§
                        method = m
                        variadic = (argcount > 0 && params[params.length - 1] == ISeq.class)
                        break
                    )
                    else if (argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class)
                    (§
                        method = m
                        variadic = true
                        break
                    )
                )
            )
            if (method == null)
            (§
                return null
            )

            Class retClass = method.getReturnType()

            Class[] paramClasses = method.getParameterTypes()
            Type[] paramTypes = new Type[paramClasses.length]

            for (int i = 0 i < paramClasses.length i++)
            (§
                paramTypes[i] = Type.getType(paramClasses[i])
            )

            Type target = Type.getType(c)

            PersistentVector argv = PersistentVector.EMPTY
            for (ISeq s = RT.seq(args) s != null s = s.next())
            (§
                argv = argv.cons(analyze(C.EXPRESSION, s.first()))
            )

            return new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition)
        )
    )

    static class InvokeExpr implements Expr
    (§
        public final Expr fexpr
        public final Object tag
        public final IPersistentVector args
        public final int line
        public final int column
        public final boolean tailPosition
        public final String source

        public boolean isProtocol = false
        public boolean isDirect = false
        public int siteIndex = -1
        public Class protocolOn
        public java.lang.reflect.Method onMethod

        static Keyword onKey = Keyword.intern("on")
        static Keyword methodMapKey = Keyword.intern("method-map")

        Class jc

        static Object sigTag(int argcount, Var v)
        (§
            Object arglists = RT.get(RT.meta(v), arglistsKey)
            Object sigTag = null
            for (ISeq s = RT.seq(arglists) s != null s = s.next())
            (§
                APersistentVector sig = (APersistentVector) s.first()
                int restOffset = sig.indexOf(_AMP_)
                if (argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))
                (§
                    return tagOf(sig)
                )
            )
            return null
        )

        public InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition)
        (§
            this.source = source
            this.fexpr = fexpr
            this.args = args
            this.line = line
            this.column = column
            this.tailPosition = tailPosition

            if (fexpr instanceof VarExpr)
            (§
                Var fvar = ((VarExpr)fexpr).var
                Var pvar =  (Var)RT.get(fvar.meta(), protocolKey)
                if (pvar != null && PROTOCOL_CALLSITES.isBound())
                (§
                    this.isProtocol = true
                    this.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var)
                    Object pon = RT.get(pvar.get(), onKey)
                    this.protocolOn = HostExpr.maybeClass(pon, false)
                    if (this.protocolOn != null)
                    (§
                        IPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey)
                        Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym))
                        if (mmapVal == null)
                        (§
                            throw new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)")
                        )
                        String mname = munge(mmapVal.sym.toString())
                        List methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false)
                        if (methods.size() != 1)
                        (§
                            throw new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym)
                        )
                        this.onMethod = (java.lang.reflect.Method) methods.get(0)
                    )
                )
            )

            if (tag != null)
            (§
                this.tag = tag
            )
            else if (fexpr instanceof VarExpr)
            (§
                Var v = ((VarExpr) fexpr).var
                Object arglists = RT.get(RT.meta(v), arglistsKey)
                Object sigTag = sigTag(args.count(), v)
                this.tag = (sigTag == null) ? ((VarExpr) fexpr).tag :or sigTag
            )
            else
            (§
                this.tag = null
            )
        )

        public Object eval()
        (§
            try
            (§
                IFn fn = (IFn) fexpr.eval()
                PersistentVector argvs = PersistentVector.EMPTY
                for (int i = 0 i < args.count() i++)
                (§
                    argvs = argvs.cons(((Expr) args.nth(i)).eval())
                )
                return fn.applyTo(RT.seq(Util.ret1(argvs, argvs = null)))
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (isProtocol)
            (§
                gen.visitLineNumber(line, gen.mark())
                emitProto(context, objx, gen)
            )

            else
            (§
                fexpr.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.checkCast(IFN_TYPE)
                emitArgsAndCall(0, context, objx, gen)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public void emitProto(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label onLabel = gen.newLabel()
            Label callLabel = gen.newLabel()
            Label endLabel = gen.newLabel()

            Var v = ((VarExpr)fexpr).var

            Expr e = (Expr) args.nth(0)
            e.emit(C.EXPRESSION, objx, gen)
            gen.dup() ;; target, target
            gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)")) ;; target, class
            gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE) ;; target, class, cached-class
            gen.visitJumpInsn(IF_ACMPEQ, callLabel) ;; target
            if (protocolOn != null)
            (§
                gen.dup() ;; target, target
                gen.instanceOf(Type.getType(protocolOn))
                gen.ifZCmp(GeneratorAdapter.NE, onLabel)
            )

            gen.dup() ;; target, target
            gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)")) ;; target, class
            gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE) ;; target

            gen.mark(callLabel) ;; target
            objx.emitVar(gen, v)
            gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")) ;; target, proto-fn
            gen.swap()
            emitArgsAndCall(1, context, objx, gen)
            gen.goTo(endLabel)

            gen.mark(onLabel) ;; target
            if (protocolOn != null)
            (§
                gen.checkCast(Type.getType(protocolOn))
                MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count()))
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Method m = new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod))
                gen.invokeInterface(Type.getType(protocolOn), m)
                HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType())
            )
            gen.mark(endLabel)
        )

        void emitArgsAndCall(int firstArgToEmit, C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = firstArgToEmit i < Math.min(MAX_POSITIONAL_ARITY, args.count()) i++)
            (§
                Expr e = (Expr) args.nth(i)
                e.emit(C.EXPRESSION, objx, gen)
            )
            if (args.count() > MAX_POSITIONAL_ARITY)
            (§
                PersistentVector restArgs = PersistentVector.EMPTY
                for (int i = MAX_POSITIONAL_ARITY i < args.count() i++)
                (§
                    restArgs = restArgs.cons(args.nth(i))
                )
                MethodExpr.emitArgsAsArray(restArgs, objx, gen)
            )
            gen.visitLineNumber(line, gen.mark())

            if (tailPosition && !objx.canBeDirect)
            (§
                ObjMethod method = (ObjMethod) METHOD.deref()
                method.emitClearThis(gen)
            )

            gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())]))
        )

        public boolean hasJavaClass()
        (§
            return (tag != null)
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = HostExpr.tagToClass(tag)
            )
            return jc
        )

        static public Expr parse(C context, ISeq form)
        (§
            boolean tailPosition = inTailCall(context)
            if (context != C.EVAL)
            (§
                context = C.EXPRESSION
            )
            Expr fexpr = analyze(context, form.first())
            if (fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3)
            (§
                Expr sexpr = analyze(C.EXPRESSION, RT.second(form))
                if (sexpr instanceof ConstantExpr)
                (§
                    Object val = ((ConstantExpr) sexpr).val()
                    if (val instanceof Class)
                    (§
                        return new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))
                    )
                )
            )

            if (RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL)
            (§
                Var v = ((VarExpr)fexpr).var
                if (!v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false)))
                (§
                    Symbol formtag = tagOf(form)
                    Object arglists = RT.get(RT.meta(v), arglistsKey)
                    int arity = RT.count(form.next())
                    Object sigtag = sigTag(arity, v)
                    Object vtag = RT.get(RT.meta(v), RT.TAG_KEY)
                    Expr ret = StaticInvokeExpr.parse(v, RT.next(form), (formtag != null) ? formtag :or (sigtag != null) ? sigtag :or vtag, tailPosition)
                    if (ret != null)
                    (§
                        return ret
                    )
                )
            )

            if (fexpr instanceof VarExpr && context != C.EVAL)
            (§
                Var v = ((VarExpr)fexpr).var
                Object arglists = RT.get(RT.meta(v), arglistsKey)
                int arity = RT.count(form.next())
                for (ISeq s = RT.seq(arglists) s != null s = s.next())
                (§
                    IPersistentVector args = (IPersistentVector) s.first()
                    if (args.count() == arity)
                    (§
                        String primc = FnMethod.primInterface(args)
                        if (primc != null)
                        (§
                            return analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"),
                                    ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))),
                                    form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))
                        )
                        break
                    )
                )
            )

            if (fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound())
            (§
                Expr target = analyze(context, RT.second(form))
                return new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)
            )
            PersistentVector args = PersistentVector.EMPTY
            for (ISeq s = RT.seq(form.next()) s != null s = s.next())
            (§
                args = args.cons(analyze(context, s.first()))
            )

            return new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition)
        )
    )

    static class SourceDebugExtensionAttribute extends Attribute
    (§
        public SourceDebugExtensionAttribute()
        (§
            super("SourceDebugExtension")
        )

        void writeSMAP(ClassWriter cw, String smap)
        (§
            ByteVector bv = write(cw, null, -1, -1, -1)
            bv.putUTF8(smap)
        )
    )

    static public class FnExpr extends ObjExpr
    (§
        final static Type aFnType = Type.getType(AFunction.class)
        final static Type restFnType = Type.getType(RestFn.class)

        ;; if there is a variadic overload (there can only be one) it is stored here
        FnMethod variadicMethod = null
        IPersistentCollection methods
        private boolean hasPrimSigs
        private boolean hasMeta
        private boolean hasEnclosingMethod

        Class jc

        public FnExpr(Object tag)
        (§
            super(tag)
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        boolean supportsMeta()
        (§
            return hasMeta
        )

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = (tag != null) ? HostExpr.tagToClass(tag) :or AFunction.class
            )
            return jc
        )

        protected void emitMethods(ClassVisitor cv)
        (§
            ;; override of invoke/doInvoke for each method
            for (ISeq s = RT.seq(methods) s != null s = s.next())
            (§
                ObjMethod method = (ObjMethod) s.first()
                method.emit(this, cv)
            )

            if (isVariadic())
            (§
                GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), null, null, cv)
                gen.visitCode()
                gen.push(variadicMethod.reqParms.count())
                gen.returnValue()
                gen.endMethod()
            )
        )

        static Expr parse(C context, ISeq form, String name)
        (§
            ISeq origForm = form
            FnExpr fn = new FnExpr(tagOf(form))
            Keyword retkey = Keyword.intern(null, "rettag")
            Object rettag = RT.get(RT.meta(form), retkey)
            fn.src = form
            ObjMethod enclosingMethod = (ObjMethod) METHOD.deref()
            fn.hasEnclosingMethod = enclosingMethod != null
            if (((IMeta) form.first()).meta() != null)
            (§
                fn.onceOnly = RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(null, "once")))
            )

            String basename = ((enclosingMethod != null) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$"

            Symbol nm = null

            if (RT.second(form) instanceof Symbol)
            (§
                nm = (Symbol) RT.second(form)
                name = nm.name + "__" + RT.nextID()
            )
            else
            (§
                if (name == null)
                (§
                    name = "fn__" + RT.nextID()
                )
                else if (enclosingMethod != null)
                (§
                    name += "__" + RT.nextID()
                )
            )

            String simpleName = munge(name).replace(".", "_DOT_")

            fn.name = basename + simpleName
            fn.internalName = fn.name.replace((§ char \.), (§ char \/))
            fn.objtype = Type.getObjectType(fn.internalName)
            ArrayList<String> prims = new ArrayList()
            try
            (§
                Var.pushThreadBindings(RT.mapUniqueKeys(CONSTANTS, PersistentVector.EMPTY,
                            CONSTANT_IDS, new IdentityHashMap(),
                            KEYWORDS, PersistentHashMap.EMPTY,
                            VARS, PersistentHashMap.EMPTY,
                            KEYWORD_CALLSITES, PersistentVector.EMPTY,
                            PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                            VAR_CALLSITES, emptyVarCallSites(),
                            NO_RECUR, null
                ))

                ;; arglist might be preceded by symbol naming this fn
                if (nm != null)
                (§
                    fn.thisName = nm.name
                    form = RT.cons(FN, RT.next(RT.next(form)))
                )

                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                ;; turn former into latter
                if (RT.second(form) instanceof IPersistentVector)
                (§
                    form = RT.list(FN, RT.next(form))
                )
                fn.line = lineDeref()
                fn.column = columnDeref()
                FnMethod[] methodArray = new FnMethod[MAX_POSITIONAL_ARITY + 1]
                FnMethod variadicMethod = null
                boolean usesThis = false
                for (ISeq s = RT.next(form) s != null s = RT.next(s))
                (§
                    FnMethod f = FnMethod.parse(fn, (ISeq) RT.first(s), rettag)
                    if (f.usesThis)
                    (§
                        usesThis = true
                    )
                    if (f.isVariadic())
                    (§
                        if (variadicMethod == null)
                        (§
                            variadicMethod = f
                        )
                        else
                        (§
                            throw Util.runtimeException("Can't have more than 1 variadic overload")
                        )
                    )
                    else if (methodArray[f.reqParms.count()] == null)
                    (§
                        methodArray[f.reqParms.count()] = f
                    )
                    else
                    (§
                        throw Util.runtimeException("Can't have 2 overloads with same arity")
                    )
                    if (f.prim != null)
                    (§
                        prims.add(f.prim)
                    )
                )
                if (variadicMethod != null)
                (§
                    for (int i = variadicMethod.reqParms.count() + 1 i <= MAX_POSITIONAL_ARITY i++)
                    (§
                        if (methodArray[i] != null)
                        (§
                            throw Util.runtimeException("Can't have fixed arity function with more params than variadic function")
                        )
                    )
                )

                fn.canBeDirect = (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis)

                IPersistentCollection methods = null
                for (int i = 0 i < methodArray.length i++)
                (§
                    if (methodArray[i] != null)
                    (§
                        methods = RT.conj(methods, methodArray[i])
                    )
                )
                if (variadicMethod != null)
                (§
                    methods = RT.conj(methods, variadicMethod)
                )

                if (fn.canBeDirect)
                (§
                    for (FnMethod fm :in (Collection<FnMethod>)methods)
                    (§
                        if (fm.locals != null)
                        (§
                            for (LocalBinding lb :in (Collection<LocalBinding>)RT.keys(fm.locals))
                            (§
                                if (lb.isArg)
                                (§
                                    lb.idx -= 1
                                )
                            )
                        )
                    )
                )

                fn.methods = methods
                fn.variadicMethod = variadicMethod
                fn.keywords = (IPersistentMap) KEYWORDS.deref()
                fn.vars = (IPersistentMap) VARS.deref()
                fn.constants = (PersistentVector) CONSTANTS.deref()
                fn.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref()
                fn.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref()
                fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref()

                fn.constantsID = RT.nextID()
            )
            finally
            (§
                Var.popThreadBindings()
            )
            fn.hasPrimSigs = prims.size() > 0
            IPersistentMap fmeta = RT.meta(origForm)
            if (fmeta != null)
            (§
                fmeta = fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey)
            )

            fn.hasMeta = RT.count(fmeta) > 0

            try
            (§
                fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? null :or prims.toArray(new String[prims.size()]), fn.onceOnly)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
            fn.getCompiledClass()

            if (fn.supportsMeta())
            (§
                return new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta))
            )
            else
            (§
                return fn
            )
        )

        public final ObjMethod variadicMethod()
        (§
            return variadicMethod
        )

        boolean isVariadic()
        (§
            return (variadicMethod != null)
        )

        public final IPersistentCollection methods()
        (§
            return methods
        )

        public void emitForDefn(ObjExpr objx, GeneratorAdapter gen)
        (§
            emit(C.EXPRESSION, objx, gen)
        )
    )

    static public class ObjExpr implements Expr
    (§
        static final String CONST_PREFIX = "const__"

        String name
        String internalName
        String thisName
        Type objtype
        public final Object tag
        ;; localbinding->itself
        IPersistentMap closes = PersistentHashMap.EMPTY
        ;; localbndingexprs
        IPersistentVector closesExprs = PersistentVector.EMPTY
        ;; symbols
        IPersistentSet volatiles = PersistentHashSet.EMPTY

        ;; symbol->lb
        IPersistentMap fields = null

        ;; hinted fields
        IPersistentVector hintedFields = PersistentVector.EMPTY

        ;; Keyword->KeywordExpr
        IPersistentMap keywords = PersistentHashMap.EMPTY
        IPersistentMap vars = PersistentHashMap.EMPTY
        Class compiledClass
        int line
        int column
        PersistentVector constants
        IPersistentSet usedConstants = PersistentHashSet.EMPTY

        int constantsID
        int altCtorDrops = 0

        IPersistentVector keywordCallsites
        IPersistentVector protocolCallsites
        IPersistentSet varCallsites
        boolean onceOnly = false

        Object src

        IPersistentMap opts = PersistentHashMap.EMPTY

        final static Method voidctor = Method.getMethod("void <init>()")
        protected IPersistentMap classMeta
        protected boolean canBeDirect

        public final String name()
        (§
            return name
        )

        public final String internalName()
        (§
            return internalName
        )

        public final String thisName()
        (§
            return thisName
        )

        public final Type objtype()
        (§
            return objtype
        )

        public final IPersistentMap closes()
        (§
            return closes
        )

        public final IPersistentMap keywords()
        (§
            return keywords
        )

        public final IPersistentMap vars()
        (§
            return vars
        )

        public final Class compiledClass()
        (§
            return compiledClass
        )

        public final int line()
        (§
            return line
        )

        public final int column()
        (§
            return column
        )

        public final PersistentVector constants()
        (§
            return constants
        )

        public final int constantsID()
        (§
            return constantsID
        )

        final static Method kwintern = Method.getMethod("cloiure.lang.Keyword intern(String, String)")
        final static Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String)")
        final static Method varintern = Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)")

        final static Type DYNAMIC_CLASSLOADER_TYPE = Type.getType(DynamicClassLoader.class)
        final static Method getClassMethod = Method.getMethod("Class getClass()")
        final static Method getClassLoaderMethod = Method.getMethod("ClassLoader getClassLoader()")
        final static Method getConstantsMethod = Method.getMethod("Object[] getConstants(int)")
        final static Method readStringMethod = Method.getMethod("Object readString(String)")

        final static Type ILOOKUP_SITE_TYPE = Type.getType(ILookupSite.class)
        final static Type ILOOKUP_THUNK_TYPE = Type.getType(ILookupThunk.class)
        final static Type KEYWORD_LOOKUPSITE_TYPE = Type.getType(KeywordLookupSite.class)

        private DynamicClassLoader loader
        private byte[] bytecode

        public ObjExpr(Object tag)
        (§
            this.tag = tag
        )

        static String trimGenID(String name)
        (§
            int i = name.lastIndexOf("__")
            return (i == -1) ? name :or name.substring(0, i)
        )

        Type[] ctorTypes()
        (§
            IPersistentVector tv = !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE)
            for (ISeq s = RT.keys(closes) s != null s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                if (lb.getPrimitiveType() != null)
                (§
                    tv = tv.cons(Type.getType(lb.getPrimitiveType()))
                )
                else
                (§
                    tv = tv.cons(OBJECT_TYPE)
                )
            )
            Type[] ret = new Type[tv.count()]
            for (int i = 0 i < tv.count() i++)
            (§
                ret[i] = (Type) tv.nth(i)
            )
            return ret
        )

        void compile(String superName, String[] interfaceNames, boolean oneTimeUse) throws IOException
        (§
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS)
            ClassVisitor cv = cw
            cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, null, superName, interfaceNames)
            String source = (String) SOURCE.deref()
            int lineBefore = (Integer) LINE_BEFORE.deref()
            int lineAfter = (Integer) LINE_AFTER.deref() + 1
            int columnBefore = (Integer) COLUMN_BEFORE.deref()
            int columnAfter = (Integer) COLUMN_AFTER.deref() + 1

            if (source != null && SOURCE_PATH.deref() != null)
            (§
                String smap = "SMAP\n"
                    + ((source.lastIndexOf((§ char \.)) > 0) ? source.substring(0, source.lastIndexOf((§ char \.))) :or source) ;; :or simpleName
                    + ".java\n"
                    + "Cloiure\n"
                    + "*S Cloiure\n"
                    + "*F\n"
                    + "+ 1 " + source + "\n"
                    + (String) SOURCE_PATH.deref() + "\n"
                    + "*L\n"
                    + String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore)
                    + "*E"
                cv.visitSource(source, smap)
            )
            addAnnotation(cv, classMeta)

            if (supportsMeta())
            (§
                cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), null, null)
            )
            ;; instance fields for closed-overs
            for (ISeq s = RT.keys(closes) s != null s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                if (isDeftype())
                (§
                    int access = isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL)
                    FieldVisitor fv
                    if (lb.getPrimitiveType() != null)
                    (§
                        fv = cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), null, null)
                    )
                    else
                    (§
                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                        fv = cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), null, null)
                    )
                    addAnnotation(fv, RT.meta(lb.sym))
                )
                else
                (§
                    ;; todo - only enable this non-private+writability for letfns where we need it
                    if (lb.getPrimitiveType() != null)
                    (§
                        cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), null, null)
                    )
                    else
                    (§
                        cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), null, null)
                    )
                )
            )

            ;; static fields for callsites and thunks
            for (int i = 0 i < protocolCallsites.count() i++)
            (§
                cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), null, null)
            )

            ;; ctor that takes closed-overs and inits base + fields
            Method m = new Method("<init>", Type.VOID_TYPE, ctorTypes())
            GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cv)
            Label start = ctorgen.newLabel()
            Label end = ctorgen.newLabel()
            ctorgen.visitCode()
            ctorgen.visitLineNumber(line, ctorgen.mark())
            ctorgen.visitLabel(start)
            ctorgen.loadThis()
            ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor)

            if (supportsMeta())
            (§
                ctorgen.loadThis()
                ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1)
                ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE)
            )

            int a = supportsMeta() ? 2 :or 1
            for (ISeq s = RT.keys(closes) s != null s = s.next(), ++a)
            (§
                LocalBinding lb = (LocalBinding) s.first()
                ctorgen.loadThis()
                Class primc = lb.getPrimitiveType()
                if (primc != null)
                (§
                    ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a)
                    ctorgen.putField(objtype, lb.name, Type.getType(primc))
                    if (primc == Long.TYPE || primc == Double.TYPE)
                    (§
                        ++a
                    )
                )
                else
                (§
                    ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a)
                    ctorgen.putField(objtype, lb.name, OBJECT_TYPE)
                )
                closesExprs = closesExprs.cons(new LocalBindingExpr(lb, null))
            )

            ctorgen.visitLabel(end)

            ctorgen.returnValue()

            ctorgen.endMethod()

            if (altCtorDrops > 0)
            (§
                ;; ctor that takes closed-overs and inits base + fields
                Type[] ctorTypes = ctorTypes()
                Type[] altCtorTypes = new Type[ctorTypes.length-altCtorDrops]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )
                Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, null, null, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __meta
                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __extmap
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()

                ;; alt ctor no __hash, __hasheq
                altCtorTypes = new Type[ctorTypes.length-2]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )

                alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, null, null, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()
            )

            if (supportsMeta())
            (§
                ;; ctor that takes closed-overs but not meta
                Type[] ctorTypes = ctorTypes()
                Type[] noMetaCtorTypes = new Type[ctorTypes.length-1]
                for (int i = 1 i < ctorTypes.length i++)
                (§
                    noMetaCtorTypes[i-1] = ctorTypes[i]
                )
                Method alt = new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, null, null, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; null meta
                ctorgen.loadArgs()
                ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()

                ;; meta()
                Method meth = Method.getMethod("cloiure.lang.IPersistentMap meta()")

                GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, meth, null, null, cv)
                gen.visitCode()
                gen.loadThis()
                gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE)

                gen.returnValue()
                gen.endMethod()

                ;; withMeta()
                meth = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")

                gen = new GeneratorAdapter(ACC_PUBLIC, meth, null, null, cv)
                gen.visitCode()
                gen.newInstance(objtype)
                gen.dup()
                gen.loadArg(0)

                for (ISeq s = RT.keys(closes) s != null s = s.next(), ++a)
                (§
                    LocalBinding lb = (LocalBinding) s.first()
                    gen.loadThis()
                    Class primc = lb.getPrimitiveType()
                    if (primc != null)
                    (§
                        gen.getField(objtype, lb.name, Type.getType(primc))
                    )
                    else
                    (§
                        gen.getField(objtype, lb.name, OBJECT_TYPE)
                    )
                )

                gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))
                gen.returnValue()
                gen.endMethod()
            )

            emitStatics(cv)
            emitMethods(cv)

            ;; static fields for constants
            for (int i = 0 i < constants.count() i++)
            (§
                if (usedConstants.contains(i))
                (§
                    cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), null, null)
                )
            )

            ;; static fields for lookup sites
            for (int i = 0 i < keywordCallsites.count() i++)
            (§
                cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), null, null)
                cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), null, null)
            )

            ;; static init for constants, keywords and vars
            GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), null, null, cv)
            clinitgen.visitCode()
            clinitgen.visitLineNumber(line, clinitgen.mark())

            if (constants.count() > 0)
            (§
                emitConstants(clinitgen)
            )

            if (keywordCallsites.count() > 0)
            (§
                emitKeywordCallsites(clinitgen)
            )

            if (isDeftype() && RT.booleanCast(RT.get(opts, loadNs)))
            (§
                String nsname = ((Symbol)RT.second(src)).getNamespace()
                if (!nsname.equals("cloiure.core"))
                (§
                    clinitgen.push("cloiure.core")
                    clinitgen.push("require")
                    clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)"))
                    clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))
                    clinitgen.checkCast(IFN_TYPE)
                    clinitgen.push(nsname)
                    clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)"))
                    clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)"))
                    clinitgen.pop()
                )
            )

            clinitgen.returnValue()

            clinitgen.endMethod()

            ;; end of class
            cv.visitEnd()

            bytecode = cw.toByteArray()
            if (RT.booleanCast(COMPILE_FILES.deref()))
            (§
                writeClassFile(internalName, bytecode)
            )
        )

        private void emitKeywordCallsites(GeneratorAdapter clinitgen)
        (§
            for (int i = 0 i < keywordCallsites.count() i++)
            (§
                Keyword k = (Keyword) keywordCallsites.nth(i)
                clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE)
                clinitgen.dup()
                emitValue(k, clinitgen)
                clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)"))
                clinitgen.dup()
                clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE)
                clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE)
            )
        )

        protected void emitStatics(ClassVisitor gen)
        (§
        )

        protected void emitMethods(ClassVisitor gen)
        (§
        )

        void emitListAsObjectArray(Object value, GeneratorAdapter gen)
        (§
            gen.push(((List) value).size())
            gen.newArray(OBJECT_TYPE)
            int i = 0
            for (Iterator it = ((List) value).iterator() it.hasNext() i++)
            (§
                gen.dup()
                gen.push(i)
                emitValue(it.next(), gen)
                gen.arrayStore(OBJECT_TYPE)
            )
        )

        void emitValue(Object value, GeneratorAdapter gen)
        (§
            boolean partial = true

            if (value == null)
            (§
                gen.visitInsn(Opcodes.ACONST_NULL)
            )
            else if (value instanceof String)
            (§
                gen.push((String) value)
            )
            else if (value instanceof Boolean)
            (§
                if (((Boolean) value).booleanValue())
                (§
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE)
                )
                else
                (§
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
                )
            )
            else if (value instanceof Integer)
            (§
                gen.push(((Integer) value).intValue())
                gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)"))
            )
            else if (value instanceof Long)
            (§
                gen.push(((Long) value).longValue())
                gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)"))
            )
            else if (value instanceof Double)
            (§
                gen.push(((Double) value).doubleValue())
                gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)"))
            )
            else if (value instanceof Character)
            (§
                gen.push(((Character) value).charValue())
                gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)"))
            )
            else if (value instanceof Class)
            (§
                Class cc = (Class)value
                if (cc.isPrimitive())
                (§
                    Type bt
                    if (cc == boolean.class)
                    (§
                        bt = Type.getType(Boolean.class)
                    )
                    else if (cc == byte.class)
                    (§
                        bt = Type.getType(Byte.class)
                    )
                    else if (cc == char.class)
                    (§
                        bt = Type.getType(Character.class)
                    )
                    else if (cc == double.class)
                    (§
                        bt = Type.getType(Double.class)
                    )
                    else if (cc == float.class)
                    (§
                        bt = Type.getType(Float.class)
                    )
                    else if (cc == int.class)
                    (§
                        bt = Type.getType(Integer.class)
                    )
                    else if (cc == long.class)
                    (§
                        bt = Type.getType(Long.class)
                    )
                    else if (cc == short.class)
                    (§
                        bt = Type.getType(Short.class)
                    )
                    else
                    (§
                        throw Util.runtimeException("Can't embed unknown primitive in code: " + value)
                    )
                    gen.getStatic(bt, "TYPE", Type.getType(Class.class))
                )
                else
                (§
                    gen.push(destubClassName(cc.getName()))
                    gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)"))
                )
            )
            else if (value instanceof Symbol)
            (§
                gen.push(((Symbol) value).ns)
                gen.push(((Symbol) value).name)
                gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)"))
            )
            else if (value instanceof Keyword)
            (§
                gen.push(((Keyword) value).sym.ns)
                gen.push(((Keyword) value).sym.name)
                gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)"))
            )
            else if (value instanceof Var)
            (§
                Var var = (Var) value
                gen.push(var.ns.name.toString())
                gen.push(var.sym.toString())
                gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)"))
            )
            else if (value instanceof IType)
            (§
                Method ctor = new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0]))
                gen.newInstance(Type.getType(value.getClass()))
                gen.dup()
                IPersistentVector fields = (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§))
                for (ISeq s = RT.seq(fields) s != null s = s.next())
                (§
                    Symbol field = (Symbol) s.first()
                    Class k = tagClass(tagOf(field))
                    Object val = Reflector.getInstanceField(value, munge(field.name))
                    emitValue(val, gen)

                    if (k.isPrimitive())
                    (§
                        Type b = Type.getType(boxClass(k))
                        String p = Type.getType(k).getDescriptor()
                        String n = k.getName()

                        gen.invokeVirtual(b, new Method(n+"Value", "()"+p))
                    )
                )
                gen.invokeConstructor(Type.getType(value.getClass()), ctor)
            )
            else if (value instanceof IRecord)
            (§
                Method createMethod = Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)")
                emitValue(PersistentArrayMap.create((java.util.Map) value), gen)
                gen.invokeStatic(getType(value.getClass()), createMethod)
            )
            else if (value instanceof IPersistentMap)
            (§
                List entries = new ArrayList()
                for (Map.Entry entry :in (Set<Map.Entry>) ((Map) value).entrySet())
                (§
                    entries.add(entry.getKey())
                    entries.add(entry.getValue())
                )
                emitListAsObjectArray(entries, gen)
                gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])"))
            )
            else if (value instanceof IPersistentVector)
            (§
                IPersistentVector args = (IPersistentVector) value
                if (args.count() <= Tuple.MAX_SIZE)
                (§
                    for (int i = 0 i < args.count() i++)
                    (§
                        emitValue(args.nth(i), gen)
                    )
                    gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()])
                )
                else
                (§
                    emitListAsObjectArray(value, gen)
                    gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])"))
                )
            )
            else if (value instanceof PersistentHashSet)
            (§
                ISeq vs = RT.seq(value)
                if (vs == null)
                (§
                    gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class))
                )
                else
                (§
                    emitListAsObjectArray(vs, gen)
                    gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])"))
                )
            )
            else if (value instanceof ISeq || value instanceof IPersistentList)
            (§
                emitListAsObjectArray(value, gen)
                gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])"))
                gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)"))
            )
            else if (value instanceof Pattern)
            (§
                emitValue(value.toString(), gen)
                gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)"))
            )
            else
            (§
                String cs = null
                try
                (§
                    cs = RT.printString(value)
                )
                catch (Exception e)
                (§
                    throw Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value)
                )
                if (cs.length() == 0)
                (§
                    throw Util.runtimeException("Can't embed unreadable object in code: " + value)
                )

                if (cs.startsWith("#<"))
                (§
                    throw Util.runtimeException("Can't embed unreadable object in code: " + cs)
                )

                gen.push(cs)
                gen.invokeStatic(RT_TYPE, readStringMethod)
                partial = false
            )

            if (partial)
            (§
                if (value instanceof IObj && RT.count(((IObj) value).meta()) > 0)
                (§
                    gen.checkCast(IOBJ_TYPE)
                    Object m = ((IObj) value).meta()
                    emitValue(elideMeta(m), gen)
                    gen.checkCast(IPERSISTENTMAP_TYPE)
                    gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))
                )
            )
        )

        void emitConstants(GeneratorAdapter clinitgen)
        (§
            try
            (§
                Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T))

                for (int i = 0 i < constants.count() i++)
                (§
                    if (usedConstants.contains(i))
                    (§
                        emitValue(constants.nth(i), clinitgen)
                        clinitgen.checkCast(constantType(i))
                        clinitgen.putStatic(objtype, constantName(i), constantType(i))
                    )
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        boolean isMutable(LocalBinding lb)
        (§
            return isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable")))
        )

        boolean isVolatile(LocalBinding lb)
        (§
            return RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable")))
        )

        boolean isDeftype()
        (§
            return (fields != null)
        )

        boolean supportsMeta()
        (§
            return !isDeftype()
        )

        void emitClearCloses(GeneratorAdapter gen)
        (§
        )

        synchronized Class getCompiledClass()
        (§
            if (compiledClass == null)
            (§
                loader = (DynamicClassLoader) LOADER.deref()
                compiledClass = loader.defineClass(name, bytecode, src)
            )
            return compiledClass
        )

        public Object eval()
        (§
            if (isDeftype())
            (§
                return null
            )
            try
            (§
                return getCompiledClass().newInstance()
            )
            catch (Exception e)
            (§
                throw Util.sneakyThrow(e)
            )
        )

        public void emitLetFnInits(GeneratorAdapter gen, ObjExpr objx, IPersistentSet letFnLocals)
        (§
            ;; objx arg is enclosing objx, not this
            gen.checkCast(objtype)

            for (ISeq s = RT.keys(closes) s != null s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                if (letFnLocals.contains(lb))
                (§
                    Class primc = lb.getPrimitiveType()
                    gen.dup()
                    if (primc != null)
                    (§
                        objx.emitUnboxedLocal(gen, lb)
                        gen.putField(objtype, lb.name, Type.getType(primc))
                    )
                    else
                    (§
                        objx.emitLocal(gen, lb, false)
                        gen.putField(objtype, lb.name, OBJECT_TYPE)
                    )
                )
            )
            gen.pop()
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            if (isDeftype())
            (§
                gen.visitInsn(Opcodes.ACONST_NULL)
            )
            else
            (§
                gen.newInstance(objtype)
                gen.dup()
                if (supportsMeta())
                (§
                    gen.visitInsn(Opcodes.ACONST_NULL)
                )
                for (ISeq s = RT.seq(closesExprs) s != null s = s.next())
                (§
                    LocalBindingExpr lbe = (LocalBindingExpr) s.first()
                    LocalBinding lb = lbe.b
                    if (lb.getPrimitiveType() != null)
                    (§
                        objx.emitUnboxedLocal(gen, lb)
                    )
                    else
                    (§
                        objx.emitLocal(gen, lb, lbe.shouldClear)
                    )
                )
                gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes()))
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        Class jc

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = (compiledClass != null) ? compiledClass :or (tag != null) ? HostExpr.tagToClass(tag) :or IFn.class
            )
            return jc
        )

        public void emitAssignLocal(GeneratorAdapter gen, LocalBinding lb, Expr val)
        (§
            if (!isMutable(lb))
            (§
                throw new IllegalArgumentException("Cannot assign to non-mutable: " + lb.name)
            )
            Class primc = lb.getPrimitiveType()
            gen.loadThis()
            if (primc != null)
            (§
                if (!(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive()))
                (§
                    throw new IllegalArgumentException("Must assign primitive to primitive mutable: " + lb.name)
                )
                MaybePrimitiveExpr me = (MaybePrimitiveExpr) val
                me.emitUnboxed(C.EXPRESSION, this, gen)
                gen.putField(objtype, lb.name, Type.getType(primc))
            )
            else
            (§
                val.emit(C.EXPRESSION, this, gen)
                gen.putField(objtype, lb.name, OBJECT_TYPE)
            )
        )

        private void emitLocal(GeneratorAdapter gen, LocalBinding lb, boolean clear)
        (§
            if (closes.containsKey(lb))
            (§
                Class primc = lb.getPrimitiveType()
                gen.loadThis()
                if (primc != null)
                (§
                    gen.getField(objtype, lb.name, Type.getType(primc))
                    HostExpr.emitBoxReturn(this, gen, primc)
                )
                else
                (§
                    gen.getField(objtype, lb.name, OBJECT_TYPE)
                    if (onceOnly && clear && lb.canBeCleared)
                    (§
                        gen.loadThis()
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.putField(objtype, lb.name, OBJECT_TYPE)
                    )
                )
            )
            else
            (§
                int argoff = canBeDirect ? 0 :or 1
                Class primc = lb.getPrimitiveType()
                if (lb.isArg)
                (§
                    gen.loadArg(lb.idx-argoff)
                    if (primc != null)
                    (§
                        HostExpr.emitBoxReturn(this, gen, primc)
                    )
                    else if (clear && lb.canBeCleared)
                    (§
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.storeArg(lb.idx - argoff)
                    )
                )
                else
                (§
                    if (primc != null)
                    (§
                        gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx)
                        HostExpr.emitBoxReturn(this, gen, primc)
                    )
                    else
                    (§
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx)
                        if (clear && lb.canBeCleared)
                        (§
                            gen.visitInsn(Opcodes.ACONST_NULL)
                            gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx)
                        )
                    )
                )
            )
        )

        private void emitUnboxedLocal(GeneratorAdapter gen, LocalBinding lb)
        (§
            int argoff = canBeDirect ? 0 :or 1
            Class primc = lb.getPrimitiveType()
            if (closes.containsKey(lb))
            (§
                gen.loadThis()
                gen.getField(objtype, lb.name, Type.getType(primc))
            )
            else if (lb.isArg)
            (§
                gen.loadArg(lb.idx-argoff)
            )
            else
            (§
                gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx)
            )
        )

        public void emitVar(GeneratorAdapter gen, Var var)
        (§
            Integer i = (Integer) vars.valAt(var)
            emitConstant(gen, i)
        )

        final static Method varGetMethod = Method.getMethod("Object get()")
        final static Method varGetRawMethod = Method.getMethod("Object getRawRoot()")

        public void emitVarValue(GeneratorAdapter gen, Var v)
        (§
            Integer i = (Integer) vars.valAt(v)
            if (!v.isDynamic())
            (§
                emitConstant(gen, i)
                gen.invokeVirtual(VAR_TYPE, varGetRawMethod)
            )
            else
            (§
                emitConstant(gen, i)
                gen.invokeVirtual(VAR_TYPE, varGetMethod)
            )
        )

        public void emitKeyword(GeneratorAdapter gen, Keyword k)
        (§
            Integer i = (Integer) keywords.valAt(k)
            emitConstant(gen, i)
        )

        public void emitConstant(GeneratorAdapter gen, int id)
        (§
            usedConstants = (IPersistentSet) usedConstants.cons(id)
            gen.getStatic(objtype, constantName(id), constantType(id))
        )

        String constantName(int id)
        (§
            return CONST_PREFIX + id
        )

        String siteName(int n)
        (§
            return "__site__" + n
        )

        String siteNameStatic(int n)
        (§
            return siteName(n) + "__"
        )

        String thunkName(int n)
        (§
            return "__thunk__" + n
        )

        String cachedClassName(int n)
        (§
            return "__cached_class__" + n
        )

        String cachedVarName(int n)
        (§
            return "__cached_var__" + n
        )

        String varCallsiteName(int n)
        (§
            return "__var__callsite__" + n
        )

        String thunkNameStatic(int n)
        (§
            return thunkName(n) + "__"
        )

        Type constantType(int id)
        (§
            Object o = constants.nth(id)
            Class c = cloiure.lang.Util.classOf(o)
            if (c!= null && Modifier.isPublic(c.getModifiers()))
            (§
                ;; can't emit derived fn types due to visibility
                if (LazySeq.class.isAssignableFrom(c))
                (§
                    return Type.getType(ISeq.class)
                )
                else if (c == Keyword.class)
                (§
                    return Type.getType(Keyword.class)
                )
                else if (RestFn.class.isAssignableFrom(c))
                (§
                    return Type.getType(RestFn.class)
                )
                else if (AFn.class.isAssignableFrom(c))
                (§
                    return Type.getType(AFn.class)
                )
                else if (c == Var.class)
                (§
                    return Type.getType(Var.class)
                )
                else if (c == String.class)
                (§
                    return Type.getType(String.class)
                )
            )
            return OBJECT_TYPE
        )
    )

    enum PATHTYPE
    (§
        PATH, BRANCH
    )

    static class PathNode
    (§
        final PATHTYPE type
        final PathNode parent

        PathNode(PATHTYPE type, PathNode parent)
        (§
            this.type = type
            this.parent = parent
        )
    )

    static PathNode clearPathRoot()
    (§
        return (PathNode) CLEAR_ROOT.get()
    )

    enum PSTATE
    (§
        REQ, REST, DONE
    )

    public static class FnMethod extends ObjMethod
    (§
        ;; localbinding->localbinding
        PersistentVector reqParms = PersistentVector.EMPTY
        LocalBinding restParm = null
        Type[] argtypes
        Class[] argclasses
        Class retClass
        String prim

        public FnMethod(ObjExpr objx, ObjMethod parent)
        (§
            super(objx, parent)
        )

        static public char classChar(Object x)
        (§
            Class c = null
            if (x instanceof Class)
            (§
                c = (Class) x
            )
            else if (x instanceof Symbol)
            (§
                c = primClass((Symbol) x)
            )
            if (c == null || !c.isPrimitive())
            (§
                return (§ char \O)
            )
            if (c == long.class)
            (§
                return (§ char \L)
            )
            if (c == double.class)
            (§
                return (§ char \D)
            )
            throw new IllegalArgumentException("Only long and double primitives are supported")
        )

        static public String primInterface(IPersistentVector arglist)
        (§
            StringBuilder sb = new StringBuilder()
            for (int i = 0 i < arglist.count() i++)
            (§
                sb.append(classChar(tagOf(arglist.nth(i))))
            )
            sb.append(classChar(tagOf(arglist)))
            String ret = sb.toString()
            boolean prim = ret.contains("L") || ret.contains("D")
            if (prim && arglist.count() > 4)
            (§
                throw new IllegalArgumentException("fns taking primitives support only 4 or fewer args")
            )
            if (prim)
            (§
                return "cloiure.lang.IFn$" + ret
            )
            return null
        )

        static FnMethod parse(ObjExpr objx, ISeq form, Object rettag)
        (§
            ;; ([args] body...)
            IPersistentVector parms = (IPersistentVector) RT.first(form)
            ISeq body = RT.next(form)
            try
            (§
                FnMethod method = new FnMethod(objx, (ObjMethod) METHOD.deref())
                method.line = lineDeref()
                method.column = columnDeref()
                ;; register as the current method and set up a new env frame
                PathNode pnode =  (PathNode) CLEAR_PATH.get()
                if (pnode == null)
                (§
                    pnode = new PathNode(PATHTYPE.PATH, null)
                )
                Var.pushThreadBindings(RT.mapUniqueKeys(
                            METHOD, method,
                            LOCAL_ENV, LOCAL_ENV.deref(),
                            LOOP_LOCALS, null,
                            NEXT_LOCAL_NUM, 0,
                            CLEAR_PATH, pnode,
                            CLEAR_ROOT, pnode,
                            CLEAR_SITES, PersistentHashMap.EMPTY,
                            METHOD_RETURN_CONTEXT, RT.T
                ))

                method.prim = primInterface(parms)
                if (method.prim != null)
                (§
                    method.prim = method.prim.replace((§ char \.), (§ char \/))
                )

                if (rettag instanceof String)
                (§
                    rettag = Symbol.intern(null, (String) rettag)
                )
                if (!(rettag instanceof Symbol))
                (§
                    rettag = null
                )
                if (rettag != null)
                (§
                    String retstr = ((Symbol)rettag).getName()
                    if (!(retstr.equals("long") || retstr.equals("double")))
                    (§
                        rettag = null
                    )
                )
                method.retClass = tagClass((tagOf(parms) != null) ? tagOf(parms) :or rettag)
                if (method.retClass.isPrimitive())
                (§
                    if (!(method.retClass == double.class || method.retClass == long.class))
                    (§
                        throw new IllegalArgumentException("Only long and double primitives are supported")
                    )
                )
                else
                (§
                    method.retClass = Object.class
                )
                ;; register 'this' as local 0
                if (objx.thisName != null)
                (§
                    registerLocal(Symbol.intern(objx.thisName), null, null, false)
                )
                else
                (§
                    getAndIncLocalNum()
                )
                PSTATE state = PSTATE.REQ
                PersistentVector argLocals = PersistentVector.EMPTY
                ArrayList<Type> argtypes = new ArrayList()
                ArrayList<Class> argclasses = new ArrayList()
                for (int i = 0 i < parms.count() i++)
                (§
                    if (!(parms.nth(i) instanceof Symbol))
                    (§
                        throw new IllegalArgumentException("fn params must be Symbols")
                    )
                    Symbol p = (Symbol) parms.nth(i)
                    if (p.getNamespace() != null)
                    (§
                        throw Util.runtimeException("Can't use qualified name as parameter: " + p)
                    )
                    if (p.equals(_AMP_))
                    (§
                        if (state == PSTATE.REQ)
                        (§
                            state = PSTATE.REST
                        )
                        else
                        (§
                            throw Util.runtimeException("Invalid parameter list")
                        )
                    )

                    else
                    (§
                        Class pc = primClass(tagClass(tagOf(p)))
                        if (pc.isPrimitive() && !(pc == double.class || pc == long.class))
                        (§
                            throw new IllegalArgumentException("Only long and double primitives are supported: " + p)
                        )

                        if (state == PSTATE.REST && tagOf(p) != null)
                        (§
                            throw Util.runtimeException("& arg cannot have type hint")
                        )
                        if (state == PSTATE.REST && method.prim != null)
                        (§
                            throw Util.runtimeException("fns taking primitives cannot be variadic")
                        )

                        if (state == PSTATE.REST)
                        (§
                            pc = ISeq.class
                        )
                        argtypes.add(Type.getType(pc))
                        argclasses.add(pc)
                        LocalBinding lb = pc.isPrimitive() ? registerLocal(p, null, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), null, true)
                        argLocals = argLocals.cons(lb)
                        switch (state)
                        (§
                            (§ case REQ)
                                method.reqParms = method.reqParms.cons(lb)
                                break
                            (§ case REST)
                                method.restParm = lb
                                state = PSTATE.DONE
                                break
                            (§ default)
                                throw Util.runtimeException("Unexpected parameter")
                        )
                    )
                )
                if (method.reqParms.count() > MAX_POSITIONAL_ARITY)
                (§
                    throw Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params")
                )
                LOOP_LOCALS.set(argLocals)
                method.argLocals = argLocals
                method.argtypes = argtypes.toArray(new Type[argtypes.size()])
                method.argclasses = argclasses.toArray(new Class[argtypes.size()])
                if (method.prim != null)
                (§
                    for (int i = 0 i < method.argclasses.length i++)
                    (§
                        if (method.argclasses[i] == long.class || method.argclasses[i] == double.class)
                        (§
                            getAndIncLocalNum()
                        )
                    )
                )
                method.body = (new BodyExpr.Parser()).parse(C.RETURN, body)
                return method
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        public void emit(ObjExpr fn, ClassVisitor cv)
        (§
            if (fn.canBeDirect)
            (§
                doEmitStatic(fn, cv)
            )
            else if (prim != null)
            (§
                doEmitPrim(fn, cv)
            )
            else
            (§
                doEmit(fn, cv)
            )
        )

        public void doEmitStatic(ObjExpr fn, ClassVisitor cv)
        (§
            Type returnType = Type.getType(retClass)

            Method ms = new Method("invokeStatic", returnType, argtypes)

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
                    ms,
                    null,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()
            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))
                emitBody(objx, gen, retClass, body)

                Label end = gen.mark()
                for (ISeq lbs = argLocals.seq() lbs != null lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), null, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()

            ;; generate the regular invoke, calling the static method
            Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes())

            gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    null,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()
            for (int i = 0 i < argtypes.length i++)
            (§
                gen.loadArg(i)
                HostExpr.emitUnboxArg(fn, gen, argclasses[i])
                if (!argclasses[i].isPrimitive())
                (§
                    gen.visitInsn(Opcodes.ACONST_NULL)
                    gen.storeArg(i)
                )
            )
            Label callLabel = gen.mark()
            gen.visitLineNumber(line, callLabel)
            gen.invokeStatic(objx.objtype, ms)
            gen.box(returnType)

            gen.returnValue()
            gen.endMethod()

            ;; generate primInvoke if prim
            if (prim != null)
            (§
                if (retClass == double.class || retClass == long.class)
                (§
                    returnType = getReturnType()
                )
                else returnType = OBJECT_TYPE

                Method pm = new Method("invokePrim", returnType, argtypes)

                gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                        pm,
                        null,
                        ;; todo don't hardwire this
                        EXCEPTION_TYPES,
                        cv)
                gen.visitCode()
                for (int i = 0 i < argtypes.length i++)
                (§
                    gen.loadArg(i)
                    if (!argclasses[i].isPrimitive())
                    (§
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.storeArg(i)
                    )
                )
                gen.invokeStatic(objx.objtype, ms)

                gen.returnValue()
                gen.endMethod()
            )
        )

        public void doEmitPrim(ObjExpr fn, ClassVisitor cv)
        (§
            Type returnType
            if (retClass == double.class || retClass == long.class)
            (§
                returnType = getReturnType()
            )
            else
            (§
                returnType = OBJECT_TYPE
            )
            Method ms = new Method("invokePrim", returnType, argtypes)

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                    ms,
                    null,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()

            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))
                emitBody(objx, gen, retClass, body)

                Label end = gen.mark()
                gen.visitLocalVariable("this", "Ljava/lang/Object;", null, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != null lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), null, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()

            ;; generate the regular invoke, calling the prim method
            Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes())

            gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    null,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()
            gen.loadThis()
            for (int i = 0 i < argtypes.length i++)
            (§
                gen.loadArg(i)
                HostExpr.emitUnboxArg(fn, gen, argclasses[i])
            )
            gen.invokeInterface(Type.getType("L"+prim+";"), ms)
            gen.box(getReturnType())

            gen.returnValue()
            gen.endMethod()
        )

        public void doEmit(ObjExpr fn, ClassVisitor cv)
        (§
            Method m = new Method(getMethodName(), getReturnType(), getArgTypes())

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    null,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()

            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))

                body.emit(C.RETURN, fn, gen)
                Label end = gen.mark()

                gen.visitLocalVariable("this", "Ljava/lang/Object;", null, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != null lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", null, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()
        )

        public final PersistentVector reqParms()
        (§
            return reqParms
        )

        public final LocalBinding restParm()
        (§
            return restParm
        )

        boolean isVariadic()
        (§
            return (restParm != null)
        )

        int numParams()
        (§
            return reqParms.count() + (isVariadic() ? 1 :or 0)
        )

        String getMethodName()
        (§
            return isVariadic() ? "doInvoke" :or "invoke"
        )

        Type getReturnType()
        (§
            if (prim != null) ;; objx.isStatic
            (§
                return Type.getType(retClass)
            )
            return OBJECT_TYPE
        )

        Type[] getArgTypes()
        (§
            if (isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
            (§
                Type[] ret = new Type[MAX_POSITIONAL_ARITY + 1]
                for (int i = 0 i < MAX_POSITIONAL_ARITY + 1 i++)
                (§
                    ret[i] = OBJECT_TYPE
                )
                return ret
            )
            return  ARG_TYPES[numParams()]
        )

        void emitClearLocals(GeneratorAdapter gen)
        (§
        )
    )

    abstract public static class ObjMethod
    (§
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        public final ObjMethod parent
        ;; localbinding->localbinding
        IPersistentMap locals = null
        ;; num->localbinding
        IPersistentMap indexlocals = null
        Expr body = null
        ObjExpr objx
        PersistentVector argLocals
        int maxLocal = 0
        int line
        int column
        boolean usesThis = false
        PersistentHashSet localsUsedInCatchFinally = PersistentHashSet.EMPTY
        protected IPersistentMap methodMeta

        public final IPersistentMap locals()
        (§
            return locals
        )

        public final Expr body()
        (§
            return body
        )

        public final ObjExpr objx()
        (§
            return objx
        )

        public final PersistentVector argLocals()
        (§
            return argLocals
        )

        public final int maxLocal()
        (§
            return maxLocal
        )

        public final int line()
        (§
            return line
        )

        public final int column()
        (§
            return column
        )

        public ObjMethod(ObjExpr objx, ObjMethod parent)
        (§
            this.parent = parent
            this.objx = objx
        )

        static void emitBody(ObjExpr objx, GeneratorAdapter gen, Class retClass, Expr body)
        (§
            MaybePrimitiveExpr be = (MaybePrimitiveExpr) body
            if (Util.isPrimitive(retClass) && be.canEmitPrimitive())
            (§
                Class bc = maybePrimitiveType(be)
                if (bc == retClass)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                )
                else if (retClass == long.class && bc == int.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.visitInsn(I2L)
                )
                else if (retClass == double.class && bc == float.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.visitInsn(F2D)
                )
                else if (retClass == int.class && bc == long.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)"))
                )
                else if (retClass == float.class && bc == double.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.visitInsn(D2F)
                )
                else
                (§
                    throw new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass())
                )
            )
            else
            (§
                body.emit(C.RETURN, objx, gen)
                if (retClass == void.class)
                (§
                    gen.pop()
                )
                else
                (§
                    gen.unbox(Type.getType(retClass))
                )
            )
        )

        abstract int numParams()
        abstract String getMethodName()
        abstract Type getReturnType()
        abstract Type[] getArgTypes()

        public void emit(ObjExpr fn, ClassVisitor cv)
        (§
            Method m = new Method(getMethodName(), getReturnType(), getArgTypes())

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    null,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()

            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))

                body.emit(C.RETURN, fn, gen)
                Label end = gen.mark()
                gen.visitLocalVariable("this", "Ljava/lang/Object;", null, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != null lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", null, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()
        )

        void emitClearLocals(GeneratorAdapter gen)
        (§
        )

        void emitClearLocalsOld(GeneratorAdapter gen)
        (§
            for (int i = 0 i < argLocals.count() i++)
            (§
                LocalBinding lb = (LocalBinding) argLocals.nth(i)
                if (!localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == null)
                (§
                    gen.visitInsn(Opcodes.ACONST_NULL)
                    gen.storeArg(lb.idx - 1)
                )
            )
            for (int i = numParams() + 1 i < maxLocal + 1 i++)
            (§
                if (!localsUsedInCatchFinally.contains(i))
                (§
                    LocalBinding b = (LocalBinding) RT.get(indexlocals, i)
                    if (b == null || maybePrimitiveType(b.init) == null)
                    (§
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i)
                    )
                )
            )
        )

        void emitClearThis(GeneratorAdapter gen)
        (§
            gen.visitInsn(Opcodes.ACONST_NULL)
            gen.visitVarInsn(Opcodes.ASTORE, 0)
        )
    )

    public static class LocalBinding
    (§
        public final Symbol sym
        public final Symbol tag
        public Expr init
        int idx
        public final String name
        public final boolean isArg
        public final PathNode clearPathRoot
        public boolean canBeCleared = !RT.booleanCast(getCompilerOption(disableLocalsClearingKey))
        public boolean recurMistmatch = false
        public boolean used = false

        public LocalBinding(int num, Symbol sym, Symbol tag, Expr init, boolean isArg, PathNode clearPathRoot)
        (§
            if (maybePrimitiveType(init) != null && tag != null)
            (§
                throw new UnsupportedOperationException("Can't type hint a local with a primitive initializer")
            )
            this.idx = num
            this.sym = sym
            this.tag = tag
            this.init = init
            this.isArg = isArg
            this.clearPathRoot = clearPathRoot
            name = munge(sym.name)
        )

        Boolean hjc

        public boolean hasJavaClass()
        (§
            if (hjc == null)
            (§
                if (init != null && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                (§
                    hjc =  false
                )
                else
                (§
                    hjc = (tag != null || (init != null && init.hasJavaClass()))
                )
            )
            return hjc
        )

        Class jc

        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                jc = (tag != null) ? HostExpr.tagToClass(tag) :or init.getJavaClass()
            )
            return jc
        )

        public Class getPrimitiveType()
        (§
            return maybePrimitiveType(init)
        )
    )

    public static class LocalBindingExpr implements Expr, MaybePrimitiveExpr, AssignableExpr
    (§
        public final LocalBinding b
        public final Symbol tag

        public final PathNode clearPath
        public final PathNode clearRoot
        public boolean shouldClear = false

        public LocalBindingExpr(LocalBinding b, Symbol tag)
        (§
            if (b.getPrimitiveType() != null && tag != null)
            (§
                throw new UnsupportedOperationException("Can't type hint a primitive local")
            )
            this.b = b
            this.tag = tag

            this.clearPath = (PathNode)CLEAR_PATH.get()
            this.clearRoot = (PathNode)CLEAR_ROOT.get()
            IPersistentCollection sites = (IPersistentCollection) RT.get(CLEAR_SITES.get(), b)
            b.used = true

            if (b.idx > 0)
            (§
                if (sites != null)
                (§
                    for (ISeq s = sites.seq() s != null s = s.next())
                    (§
                        LocalBindingExpr o = (LocalBindingExpr) s.first()
                        PathNode common = commonPath(clearPath, o.clearPath)
                        if (common != null && common.type == PATHTYPE.PATH)
                        (§
                            o.shouldClear = false
                        )
                    )
                )

                if (clearRoot == b.clearPathRoot)
                (§
                    this.shouldClear = true
                    sites = RT.conj(sites, this)
                    CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites))
                )
            )
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval locals")
        )

        public boolean canEmitPrimitive()
        (§
            return (b.getPrimitiveType() != null)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitUnboxedLocal(gen, b)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (context != C.STATEMENT)
            (§
                objx.emitLocal(gen, b, shouldClear)
            )
        )

        public Object evalAssign(Expr val)
        (§
            throw new UnsupportedOperationException("Can't eval locals")
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            objx.emitAssignLocal(gen, b, val)
            if (context != C.STATEMENT)
            (§
                objx.emitLocal(gen, b, false)
            )
        )

        public boolean hasJavaClass()
        (§
            return (tag != null || b.hasJavaClass())
        )

        Class jc
        public Class getJavaClass()
        (§
            if (jc == null)
            (§
                if (tag != null)
                (§
                    jc = HostExpr.tagToClass(tag)
                )
                else
                (§
                    jc = b.getJavaClass()
                )
            )
            return jc
        )
    )

    public static class BodyExpr implements Expr, MaybePrimitiveExpr
    (§
        PersistentVector exprs

        public final PersistentVector exprs()
        (§
            return exprs
        )

        public BodyExpr(PersistentVector exprs)
        (§
            this.exprs = exprs
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frms)
            (§
                ISeq forms = (ISeq) frms
                if (Util.equals(RT.first(forms), DO))
                (§
                    forms = RT.next(forms)
                )
                PersistentVector exprs = PersistentVector.EMPTY
                for (  forms != null forms = forms.next())
                (§
                    Expr e = (context != C.EVAL && (context == C.STATEMENT || forms.next() != null)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first())
                    exprs = exprs.cons(e)
                )
                if (exprs.count() == 0)
                (§
                    exprs = exprs.cons(NIL_EXPR)
                )
                return new BodyExpr(exprs)
            )
        )

        public Object eval()
        (§
            Object ret = null
            for (Object o :in exprs)
            (§
                Expr e = (Expr) o
                ret = e.eval()
            )
            return ret
        )

        public boolean canEmitPrimitive()
        (§
            return (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive())
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = 0 i < exprs.count() - 1 i++)
            (§
                Expr e = (Expr) exprs.nth(i)
                e.emit(C.STATEMENT, objx, gen)
            )
            MaybePrimitiveExpr last = (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1)
            last.emitUnboxed(context, objx, gen)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = 0 i < exprs.count() - 1 i++)
            (§
                Expr e = (Expr) exprs.nth(i)
                e.emit(C.STATEMENT, objx, gen)
            )
            Expr last = (Expr) exprs.nth(exprs.count() - 1)
            last.emit(context, objx, gen)
        )

        public boolean hasJavaClass()
        (§
            return lastExpr().hasJavaClass()
        )

        public Class getJavaClass()
        (§
            return lastExpr().getJavaClass()
        )

        private Expr lastExpr()
        (§
            return (Expr) exprs.nth(exprs.count() - 1)
        )
    )

    public static class BindingInit
    (§
        LocalBinding binding
        Expr init

        public final LocalBinding binding()
        (§
            return binding
        )

        public final Expr init()
        (§
            return init
        )

        public BindingInit(LocalBinding binding, Expr init)
        (§
            this.binding = binding
            this.init = init
        )
    )

    public static class LetFnExpr implements Expr
    (§
        public final PersistentVector bindingInits
        public final Expr body

        public LetFnExpr(PersistentVector bindingInits, Expr body)
        (§
            this.bindingInits = bindingInits
            this.body = body
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (letfns* [var (fn [args] body) ...] body...)
                if (!(RT.second(form) instanceof IPersistentVector))
                (§
                    throw new IllegalArgumentException("Bad binding form, expected vector")
                )

                IPersistentVector bindings = (IPersistentVector) RT.second(form)
                if ((bindings.count() % 2) != 0)
                (§
                    throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")
                )

                ISeq body = RT.next(RT.next(form))

                if (context == C.EVAL)
                (§
                    return analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))
                )

                IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref())

                try
                (§
                    Var.pushThreadBindings(dynamicBindings)

                    ;; pre-seed env (like Lisp labels)
                    PersistentVector lbs = PersistentVector.EMPTY
                    for (int i = 0 i < bindings.count() i += 2)
                    (§
                        if (!(bindings.nth(i) instanceof Symbol))
                        (§
                            throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))
                        )
                        Symbol sym = (Symbol) bindings.nth(i)
                        if (sym.getNamespace() != null)
                        (§
                            throw Util.runtimeException("Can't let qualified name: " + sym)
                        )
                        LocalBinding lb = registerLocal(sym, tagOf(sym), null, false)
                        lb.canBeCleared = false
                        lbs = lbs.cons(lb)
                    )
                    PersistentVector bindingInits = PersistentVector.EMPTY
                    for (int i = 0 i < bindings.count() i += 2)
                    (§
                        Symbol sym = (Symbol) bindings.nth(i)
                        Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name)
                        LocalBinding lb = (LocalBinding) lbs.nth(i / 2)
                        lb.init = init
                        BindingInit bi = new BindingInit(lb, init)
                        bindingInits = bindingInits.cons(bi)
                    )
                    return new LetFnExpr(bindingInits, (new BodyExpr.Parser()).parse(context, body))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval letfns")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                gen.visitInsn(Opcodes.ACONST_NULL)
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx)
            )

            IPersistentSet lbset = PersistentHashSet.EMPTY

            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                lbset = (IPersistentSet) lbset.cons(bi.binding)
                bi.init.emit(C.EXPRESSION, objx, gen)
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx)
            )

            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                ObjExpr fe = (ObjExpr) bi.init
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx)
                fe.emitLetFnInits(gen, objx, lbset)
            )

            Label loopLabel = gen.mark()

            body.emit(context, objx, gen)

            Label end = gen.mark()
            for (ISeq bis = bindingInits.seq() bis != null bis = bis.next())
            (§
                BindingInit bi = (BindingInit) bis.first()
                String lname = bi.binding.name
                if (lname.endsWith("__auto__"))
                (§
                    lname += RT.nextID()
                )
                Class primc = maybePrimitiveType(bi.init)
                if (primc != null)
                (§
                    gen.visitLocalVariable(lname, Type.getDescriptor(primc), null, loopLabel, end, bi.binding.idx)
                )
                else
                (§
                    gen.visitLocalVariable(lname, "Ljava/lang/Object;", null, loopLabel, end, bi.binding.idx)
                )
            )
        )

        public boolean hasJavaClass()
        (§
            return body.hasJavaClass()
        )

        public Class getJavaClass()
        (§
            return body.getJavaClass()
        )
    )

    public static class LetExpr implements Expr, MaybePrimitiveExpr
    (§
        public final PersistentVector bindingInits
        public final Expr body
        public final boolean isLoop

        public LetExpr(PersistentVector bindingInits, Expr body, boolean isLoop)
        (§
            this.bindingInits = bindingInits
            this.body = body
            this.isLoop = isLoop
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (let [var val var2 val2 ...] body...)
                boolean isLoop = RT.first(form).equals(LOOP)
                if (!(RT.second(form) instanceof IPersistentVector))
                (§
                    throw new IllegalArgumentException("Bad binding form, expected vector")
                )

                IPersistentVector bindings = (IPersistentVector) RT.second(form)
                if ((bindings.count() % 2) != 0)
                (§
                    throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")
                )

                ISeq body = RT.next(RT.next(form))

                if (context == C.EVAL || (context == C.EXPRESSION && isLoop))
                (§
                    return analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))
                )

                ObjMethod method = (ObjMethod) METHOD.deref()
                IPersistentMap backupMethodLocals = method.locals
                IPersistentMap backupMethodIndexLocals = method.indexlocals
                IPersistentVector recurMismatches = PersistentVector.EMPTY
                for (int i = 0 i < bindings.count() / 2 i++)
                (§
                    recurMismatches = recurMismatches.cons(RT.F)
                )

                ;; may repeat once for each binding with a mismatch, return breaks
                while (true)
                (§
                    IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref())
                    method.locals = backupMethodLocals
                    method.indexlocals = backupMethodIndexLocals

                    PathNode looproot = new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get())
                    PathNode clearroot = new PathNode(PATHTYPE.PATH, looproot)
                    PathNode clearpath = new PathNode(PATHTYPE.PATH, looproot)
                    if (isLoop)
                    (§
                        dynamicBindings = dynamicBindings.assoc(LOOP_LOCALS, null)
                    )

                    try
                    (§
                        Var.pushThreadBindings(dynamicBindings)

                        PersistentVector bindingInits = PersistentVector.EMPTY
                        PersistentVector loopLocals = PersistentVector.EMPTY
                        for (int i = 0 i < bindings.count() i += 2)
                        (§
                            if (!(bindings.nth(i) instanceof Symbol))
                            (§
                                throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))
                            )
                            Symbol sym = (Symbol) bindings.nth(i)
                            if (sym.getNamespace() != null)
                            (§
                                throw Util.runtimeException("Can't let qualified name: " + sym)
                            )
                            Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name)
                            if (isLoop)
                            (§
                                if (recurMismatches != null && RT.booleanCast(recurMismatches.nth(i / 2)))
                                (§
                                    init = new StaticMethodExpr("", 0, 0, null, RT.class, "box", RT.vector(init), false)
                                    if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                    (§
                                        RT.errPrintWriter().println("Auto-boxing loop arg: " + sym)
                                    )
                                )
                                else if (maybePrimitiveType(init) == int.class)
                                (§
                                    init = new StaticMethodExpr("", 0, 0, null, RT.class, "longCast", RT.vector(init), false)
                                )
                                else if (maybePrimitiveType(init) == float.class)
                                (§
                                    init = new StaticMethodExpr("", 0, 0, null, RT.class, "doubleCast", RT.vector(init), false)
                                )
                            )
                            ;; sequential enhancement of env (like Lisp let*)
                            try
                            (§
                                if (isLoop)
                                (§
                                    Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, null))
                                )
                                LocalBinding lb = registerLocal(sym, tagOf(sym), init, false)
                                BindingInit bi = new BindingInit(lb, init)
                                bindingInits = bindingInits.cons(bi)
                                if (isLoop)
                                (§
                                    loopLocals = loopLocals.cons(lb)
                                )
                            )
                            finally
                            (§
                                if (isLoop)
                                (§
                                    Var.popThreadBindings()
                                )
                            )
                        )
                        if (isLoop)
                        (§
                            LOOP_LOCALS.set(loopLocals)
                        )
                        Expr bodyExpr
                        boolean moreMismatches = false
                        try
                        (§
                            if (isLoop)
                            (§
                                Object methodReturnContext = (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or null
                                Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath,
                                            CLEAR_ROOT, clearroot,
                                            NO_RECUR, null,
                                            METHOD_RETURN_CONTEXT, methodReturnContext
                                ))
                            )
                            bodyExpr = (new BodyExpr.Parser()).parse(isLoop ? C.RETURN :or context, body)
                        )
                        finally
                        (§
                            if (isLoop)
                            (§
                                Var.popThreadBindings()
                                for (int i = 0 i < loopLocals.count() i++)
                                (§
                                    LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                                    if (lb.recurMistmatch)
                                    (§
                                        recurMismatches = (IPersistentVector)recurMismatches.assoc(i, RT.T)
                                        moreMismatches = true
                                    )
                                )
                            )
                        )
                        if (!moreMismatches)
                        (§
                            return new LetExpr(bindingInits, bodyExpr, isLoop)
                        )
                    )
                    finally
                    (§
                        Var.popThreadBindings()
                    )
                )
            )
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval let/loop")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, false)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, true)
        )

        public void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
        (§
            HashMap<BindingInit, Label> bindingLabels = new HashMap()
            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                Class primc = maybePrimitiveType(bi.init)
                if (primc != null)
                (§
                    ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen)
                    gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx)
                )
                else
                (§
                    bi.init.emit(C.EXPRESSION, objx, gen)
                    if (!bi.binding.used && bi.binding.canBeCleared)
                    (§
                        gen.pop()
                    )
                    else
                    (§
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx)
                    )
                )
                bindingLabels.put(bi, gen.mark())
            )
            Label loopLabel = gen.mark()
            if (isLoop)
            (§
                try
                (§
                    Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel))
                    if (emitUnboxed)
                    (§
                        ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen)
                    )
                    else
                    (§
                        body.emit(context, objx, gen)
                    )
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )
            else
            (§
                if (emitUnboxed)
                (§
                    ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen)
                )
                else
                (§
                    body.emit(context, objx, gen)
                )
            )
            Label end = gen.mark()
            for (ISeq bis = bindingInits.seq() bis != null bis = bis.next())
            (§
                BindingInit bi = (BindingInit) bis.first()
                String lname = bi.binding.name
                if (lname.endsWith("__auto__"))
                (§
                    lname += RT.nextID()
                )
                Class primc = maybePrimitiveType(bi.init)
                if (primc != null)
                (§
                    gen.visitLocalVariable(lname, Type.getDescriptor(primc), null, bindingLabels.get(bi), end, bi.binding.idx)
                )
                else
                (§
                    gen.visitLocalVariable(lname, "Ljava/lang/Object;", null, bindingLabels.get(bi), end, bi.binding.idx)
                )
            )
        )

        public boolean hasJavaClass()
        (§
            return body.hasJavaClass()
        )

        public Class getJavaClass()
        (§
            return body.getJavaClass()
        )

        public boolean canEmitPrimitive()
        (§
            return (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive())
        )
    )

    public static class RecurExpr implements Expr, MaybePrimitiveExpr
    (§
        public final IPersistentVector args
        public final IPersistentVector loopLocals

        final int line
        final int column
        final String source

        public RecurExpr(IPersistentVector loopLocals, IPersistentVector args, int line, int column, String source)
        (§
            this.loopLocals = loopLocals
            this.args = args
            this.line = line
            this.column = column
            this.source = source
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval recur")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label loopLabel = (Label) LOOP_LABEL.deref()
            if (loopLabel == null)
            (§
                throw new IllegalStateException()
            )
            for (int i = 0 i < loopLocals.count() i++)
            (§
                LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                Expr arg = (Expr) args.nth(i)
                if (lb.getPrimitiveType() != null)
                (§
                    Class primc = lb.getPrimitiveType()
                    final Class pc = maybePrimitiveType(arg)
                    if (pc == primc)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    else if (primc == long.class && pc == int.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(I2L)
                    )
                    else if (primc == double.class && pc == float.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(F2D)
                    )
                    else if (primc == int.class && pc == long.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)"))
                    )
                    else if (primc == float.class && pc == double.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(D2F)
                    )
                    else
                    (§
                        throw new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName())
                    )
                )
                else
                (§
                    arg.emit(C.EXPRESSION, objx, gen)
                )
            )

            for (int i = loopLocals.count() - 1 i >= 0 i--)
            (§
                LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                Class primc = lb.getPrimitiveType()
                if (lb.isArg)
                (§
                    gen.storeArg(lb.idx-(objx.canBeDirect ? 0 :or 1))
                )
                else
                (§
                    if (primc != null)
                    (§
                        gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx)
                    )
                    else
                    (§
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx)
                    )
                )
            )

            gen.goTo(loopLabel)
        )

        public boolean hasJavaClass()
        (§
            return true
        )

        public Class getJavaClass()
        (§
            return RECUR_CLASS
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                int line = lineDeref()
                int column = columnDeref()
                String source = (String) SOURCE.deref()

                ISeq form = (ISeq) frm
                IPersistentVector loopLocals = (IPersistentVector) LOOP_LOCALS.deref()
                if (context != C.RETURN || loopLocals == null)
                (§
                    throw new UnsupportedOperationException("Can only recur from tail position")
                )
                if (NO_RECUR.deref() != null)
                (§
                    throw new UnsupportedOperationException("Cannot recur across try")
                )
                PersistentVector args = PersistentVector.EMPTY
                for (ISeq s = RT.seq(form.next()) s != null s = s.next())
                (§
                    args = args.cons(analyze(C.EXPRESSION, s.first()))
                )
                if (args.count() != loopLocals.count())
                (§
                    throw new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count()))
                )
                for (int i = 0 i < loopLocals.count() i++)
                (§
                    LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                    Class primc = lb.getPrimitiveType()
                    if (primc != null)
                    (§
                        boolean mismatch = false
                        final Class pc = maybePrimitiveType((Expr) args.nth(i))
                        if (primc == long.class)
                        (§
                            if (!(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class))
                            (§
                                mismatch = true
                            )
                        )
                        else if (primc == double.class)
                        (§
                            if (!(pc == double.class || pc == float.class))
                            (§
                                mismatch = true
                            )
                        )
                        if (mismatch)
                        (§
                            lb.recurMistmatch = true
                            if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                            (§
                                RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " +
                                     ((pc != null) ? pc.getName() :or "Object") + ", needed: " + primc.getName())
                            )
                        )
                    )
                )
                return new RecurExpr(loopLocals, args, line, column, source)
            )
        )

        public boolean canEmitPrimitive()
        (§
            return true
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            emit(context, objx, gen)
        )
    )

    private static LocalBinding registerLocal(Symbol sym, Symbol tag, Expr init, boolean isArg)
    (§
        int num = getAndIncLocalNum()
        LocalBinding b = new LocalBinding(num, sym, tag, init, isArg, clearPathRoot())
        IPersistentMap localsMap = (IPersistentMap) LOCAL_ENV.deref()
        LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b))
        ObjMethod method = (ObjMethod) METHOD.deref()
        method.locals = (IPersistentMap) RT.assoc(method.locals, b, b)
        method.indexlocals = (IPersistentMap) RT.assoc(method.indexlocals, num, b)
        return b
    )

    private static int getAndIncLocalNum()
    (§
        int num = ((Number) NEXT_LOCAL_NUM.deref()).intValue()
        ObjMethod m = (ObjMethod) METHOD.deref()
        if (num > m.maxLocal)
        (§
            m.maxLocal = num
        )
        NEXT_LOCAL_NUM.set(num + 1)
        return num
    )

    public static Expr analyze(C context, Object form)
    (§
        return analyze(context, form, null)
    )

    private static Expr analyze(C context, Object form, String name)
    (§
        ;; todo symbol macro expansion?
        try
        (§
            if (form instanceof LazySeq)
            (§
                Object mform = form
                form = RT.seq(form)
                if (form == null)
                (§
                    form = PersistentList.EMPTY
                )
                form = ((IObj)form).withMeta(RT.meta(mform))
            )
            if (form == null)
            (§
                return NIL_EXPR
            )
            else if (form == Boolean.TRUE)
            (§
                return TRUE_EXPR
            )
            else if (form == Boolean.FALSE)
            (§
                return FALSE_EXPR
            )
            Class fclass = form.getClass()
            if (fclass == Symbol.class)
            (§
                return analyzeSymbol((Symbol) form)
            )
            else if (fclass == Keyword.class)
            (§
                return registerKeyword((Keyword) form)
            )
            else if (form instanceof Number)
            (§
                return NumberExpr.parse((Number) form)
            )
            else if (fclass == String.class)
            (§
                return new StringExpr(((String) form).intern())
            )
            else if (form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0)
            (§
                Expr ret = new EmptyExpr(form)
                if (RT.meta(form) != null)
                (§
                    ret = new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))
                )
                return ret
            )
            else if (form instanceof ISeq)
            (§
                return analyzeSeq(context, (ISeq) form, name)
            )
            else if (form instanceof IPersistentVector)
            (§
                return VectorExpr.parse(context, (IPersistentVector) form)
            )
            else if (form instanceof IRecord)
            (§
                return new ConstantExpr(form)
            )
            else if (form instanceof IType)
            (§
                return new ConstantExpr(form)
            )
            else if (form instanceof IPersistentMap)
            (§
                return MapExpr.parse(context, (IPersistentMap) form)
            )
            else if (form instanceof IPersistentSet)
            (§
                return SetExpr.parse(context, (IPersistentSet) form)
            )

            return new ConstantExpr(form)
        )
        catch (Throwable e)
        (§
            if (!(e instanceof CompilerException))
            (§
                throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)
            )
            else
            (§
                throw (CompilerException) e
            )
        )
    )

    static public class CompilerException extends RuntimeException
    (§
        final public String source

        final public int line

        public CompilerException(String source, int line, int column, Throwable cause)
        (§
            super(errorMsg(source, line, column, cause.toString()), cause)
            this.source = source
            this.line = line
        )

        public String toString()
        (§
            return getMessage()
        )
    )

    static public Var isMacro(Object op)
    (§
        ;; no local macros for now
        if (op instanceof Symbol && referenceLocal((Symbol) op) != null)
        (§
            return null
        )
        if (op instanceof Symbol || op instanceof Var)
        (§
            Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false)
            if (v != null && v.isMacro())
            (§
                if (v.ns != currentNS() && !v.isPublic())
                (§
                    throw new IllegalStateException("var: " + v + " is not public")
                )
                return v
            )
        )
        return null
    )

    static public IFn isInline(Object op, int arity)
    (§
        ;; no local inlines for now
        if (op instanceof Symbol && referenceLocal((Symbol) op) != null)
        (§
            return null
        )
        if (op instanceof Symbol || op instanceof Var)
        (§
            Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false)
            if (v != null)
            (§
                if (v.ns != currentNS() && !v.isPublic())
                (§
                    throw new IllegalStateException("var: " + v + " is not public")
                )
                IFn ret = (IFn) RT.get(v.meta(), inlineKey)
                if (ret != null)
                (§
                    IFn arityPred = (IFn) RT.get(v.meta(), inlineAritiesKey)
                    if (arityPred == null || RT.booleanCast(arityPred.invoke(arity)))
                    (§
                        return ret
                    )
                )
            )
        )
        return null
    )

    public static boolean namesStaticMember(Symbol sym)
    (§
        return (sym.ns != null && namespaceFor(sym) == null)
    )

    public static Object preserveTag(ISeq src, Object dst)
    (§
        Symbol tag = tagOf(src)
        if (tag != null && dst instanceof IObj)
        (§
            IPersistentMap meta = RT.meta(dst)
            return ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))
        )
        return dst
    )

    private static volatile Var MACRO_CHECK = null
    private static volatile boolean MACRO_CHECK_LOADING = false
    private static final Object MACRO_CHECK_LOCK = new Object()

    private static Var ensureMacroCheck() throws ClassNotFoundException, IOException
    (§
        if (MACRO_CHECK == null)
        (§
            synchronized (MACRO_CHECK_LOCK)
            (§
                if (MACRO_CHECK == null)
                (§
                    MACRO_CHECK_LOADING = true
                    RT.load("cloiure/spec/alpha")
                    RT.load("cloiure/core/specs/alpha")
                    MACRO_CHECK = Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check"))
                    MACRO_CHECK_LOADING = false
                )
            )
        )
        return MACRO_CHECK
    )

    public static void checkSpecs(Var v, ISeq form)
    (§
        if (RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
        (§
            try
            (§
                ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next())))
            )
            catch (Exception e)
            (§
                throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)
            )
        )
    )

    public static Object macroexpand1(Object x)
    (§
        if (x instanceof ISeq)
        (§
            ISeq form = (ISeq) x
            Object op = RT.first(form)
            if (isSpecial(op))
            (§
                return x
            )
            ;; macro expansion
            Var v = isMacro(op)
            if (v != null)
            (§
                checkSpecs(v, form)

                try
                (§
                    ISeq args = RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next()))
                    return v.applyTo(args)
                )
                catch (ArityException e)
                (§
                    ;; hide the 2 extra params for a macro
                    throw new ArityException(e.actual - 2, e.name)
                )
            )
            else
            (§
                if (op instanceof Symbol)
                (§
                    Symbol sym = (Symbol) op
                    String sname = sym.name
                    ;; (.substring s 2 5) => (. s substring 2 5)
                    if (sym.name.charAt(0) == (§ char \.))
                    (§
                        if (RT.length(form) < 2)
                        (§
                            throw new IllegalArgumentException("Malformed member expression, expecting (.member target ...)")
                        )
                        Symbol meth = Symbol.intern(sname.substring(1))
                        Object target = RT.second(form)
                        if (HostExpr.maybeClass(target, false) != null)
                        (§
                            target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS))
                        )
                        return preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))
                    )
                    else if (namesStaticMember(sym))
                    (§
                        Symbol target = Symbol.intern(sym.ns)
                        Class c = HostExpr.maybeClass(target, false)
                        if (c != null)
                        (§
                            Symbol meth = Symbol.intern(sym.name)
                            return preserveTag(form, RT.listStar(DOT, target, meth, form.next()))
                        )
                    )
                    else
                    (§
                        ;; (s.substring 2 5) => (. s substring 2 5)
                        ;; also (package.class.name ...) (. package.class name ...)
                        int idx = sname.lastIndexOf((§ char \.))
                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                        if (idx == sname.length() - 1)
                        (§
                            return RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())
                        )
                    )
                )
            )
        )
        return x
    )

    static Object macroexpand(Object form)
    (§
        Object exf = macroexpand1(form)
        if (exf != form)
        (§
            return macroexpand(exf)
        )
        return form
    )

    private static Expr analyzeSeq(C context, ISeq form, String name)
    (§
        Object line = lineDeref()
        Object column = columnDeref()
        if (RT.meta(form) != null && RT.meta(form).containsKey(RT.LINE_KEY))
        (§
            line = RT.meta(form).valAt(RT.LINE_KEY)
        )
        if (RT.meta(form) != null && RT.meta(form).containsKey(RT.COLUMN_KEY))
        (§
            column = RT.meta(form).valAt(RT.COLUMN_KEY)
        )
        Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column))
        try
        (§
            Object me = macroexpand1(form)
            if (me != form)
            (§
                return analyze(context, me, name)
            )

            Object op = RT.first(form)
            if (op == null)
            (§
                throw new IllegalArgumentException("Can't call nil, form: " + form)
            )
            IFn inline = isInline(op, RT.count(RT.next(form)))
            if (inline != null)
            (§
                return analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))
            )
            IParser p
            if (op.equals(FN))
            (§
                return FnExpr.parse(context, form, name)
            )
            else if ((p = (IParser) specials.valAt(op)) != null)
            (§
                return p.parse(context, form)
            )
            else
            (§
                return InvokeExpr.parse(context, form)
            )
        )
        catch (Throwable e)
        (§
            if (!(e instanceof CompilerException))
            (§
                throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)
            )
            else
            (§
                throw (CompilerException) e
            )
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )

    static String errorMsg(String source, int line, int column, String s)
    (§
        return String.format("%s, compiling:(%s:%d:%d)", s, source, line, column)
    )

    public static Object eval(Object form)
    (§
        return eval(form, true)
    )

    public static Object eval(Object form, boolean freshLoader)
    (§
        boolean createdLoader = false
        if (true) ;; !LOADER.isBound()
        (§
            Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader()))
            createdLoader = true
        )
        try
        (§
            Object line = lineDeref()
            Object column = columnDeref()
            if (RT.meta(form) != null && RT.meta(form).containsKey(RT.LINE_KEY))
            (§
                line = RT.meta(form).valAt(RT.LINE_KEY)
            )
            if (RT.meta(form) != null && RT.meta(form).containsKey(RT.COLUMN_KEY))
            (§
                column = RT.meta(form).valAt(RT.COLUMN_KEY)
            )
            Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column))
            try
            (§
                form = macroexpand(form)
                if (form instanceof ISeq && Util.equals(RT.first(form), DO))
                (§
                    ISeq s = RT.next(form)
                    for (  RT.next(s) != null s = RT.next(s))
                    (§
                        eval(RT.first(s), false)
                    )
                    return eval(RT.first(s), false)
                )
                else if ((form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def"))))
                (§
                    ObjExpr fexpr = (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID())
                    IFn fn = (IFn) fexpr.eval()
                    return fn.invoke()
                )
                else
                (§
                    Expr expr = analyze(C.EVAL, form)
                    return expr.eval()
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
        finally
        (§
            if (createdLoader)
            (§
                Var.popThreadBindings()
            )
        )
    )

    private static int registerConstant(Object o)
    (§
        if (!CONSTANTS.isBound())
        (§
            return -1
        )
        PersistentVector v = (PersistentVector) CONSTANTS.deref()
        IdentityHashMap<Object, Integer> ids = (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref()
        Integer i = ids.get(o)
        if (i != null)
        (§
            return i
        )
        CONSTANTS.set(RT.conj(v, o))
        ids.put(o, v.count())
        return v.count()
    )

    private static KeywordExpr registerKeyword(Keyword keyword)
    (§
        if (!KEYWORDS.isBound())
        (§
            return new KeywordExpr(keyword)
        )

        IPersistentMap keywordsMap = (IPersistentMap) KEYWORDS.deref()
        Object id = RT.get(keywordsMap, keyword)
        if (id == null)
        (§
            KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword)))
        )
        return new KeywordExpr(keyword)
    )

    private static int registerKeywordCallsite(Keyword keyword)
    (§
        if (!KEYWORD_CALLSITES.isBound())
        (§
            throw new IllegalAccessError("KEYWORD_CALLSITES is not bound")
        )

        IPersistentVector keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref()

        keywordCallsites = keywordCallsites.cons(keyword)
        KEYWORD_CALLSITES.set(keywordCallsites)
        return keywordCallsites.count() - 1
    )

    private static int registerProtocolCallsite(Var v)
    (§
        if (!PROTOCOL_CALLSITES.isBound())
        (§
            throw new IllegalAccessError("PROTOCOL_CALLSITES is not bound")
        )

        IPersistentVector protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref()

        protocolCallsites = protocolCallsites.cons(v)
        PROTOCOL_CALLSITES.set(protocolCallsites)
        return protocolCallsites.count() - 1
    )

    private static void registerVarCallsite(Var v)
    (§
        if (!VAR_CALLSITES.isBound())
        (§
            throw new IllegalAccessError("VAR_CALLSITES is not bound")
        )

        IPersistentCollection varCallsites = (IPersistentCollection) VAR_CALLSITES.deref()

        varCallsites = varCallsites.cons(v)
        VAR_CALLSITES.set(varCallsites)
    )

    static ISeq fwdPath(PathNode p1)
    (§
        ISeq ret = null
        for (  p1 != null p1 = p1.parent)
        (§
            ret = RT.cons(p1, ret)
        )
        return ret
    )

    static PathNode commonPath(PathNode n1, PathNode n2)
    (§
        ISeq xp = fwdPath(n1)
        ISeq yp = fwdPath(n2)
        if (RT.first(xp) != RT.first(yp))
        (§
            return null
        )
        while (RT.second(xp) != null && RT.second(xp) == RT.second(yp))
        (§
            xp = xp.next()
            yp = yp.next()
        )
        return (PathNode) RT.first(xp)
    )

    static void addAnnotation(Object visitor, IPersistentMap meta)
    (§
        if (meta != null && ADD_ANNOTATIONS.isBound())
        (§
            ADD_ANNOTATIONS.invoke(visitor, meta)
        )
    )

    static void addParameterAnnotation(Object visitor, IPersistentMap meta, int i)
    (§
        if (meta != null && ADD_ANNOTATIONS.isBound())
        (§
            ADD_ANNOTATIONS.invoke(visitor, meta, i)
        )
    )

    private static Expr analyzeSymbol(Symbol sym)
    (§
        Symbol tag = tagOf(sym)
        if (sym.ns == null) ;; ns-qualified syms are always Vars
        (§
            LocalBinding b = referenceLocal(sym)
            if (b != null)
            (§
                return new LocalBindingExpr(b, tag)
            )
        )
        else if (namespaceFor(sym) == null)
        (§
            Symbol nsSym = Symbol.intern(sym.ns)
            Class c = HostExpr.maybeClass(nsSym, false)
            if (c != null)
            (§
                if (Reflector.getField(c, sym.name, true) != null)
                (§
                    return new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)
                )
                throw Util.runtimeException("Unable to find static field: " + sym.name + " in " + c)
            )
        )
        Object o = resolve(sym)
        if (o instanceof Var)
        (§
            Var v = (Var) o
            if (isMacro(v) != null)
            (§
                throw Util.runtimeException("Can't take value of a macro: " + v)
            )
            if (RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
            (§
                return analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))
            )
            registerVar(v)
            return new VarExpr(v, tag)
        )
        else if (o instanceof Class)
        (§
            return new ConstantExpr(o)
        )
        else if (o instanceof Symbol)
        (§
            return new UnresolvedVarExpr((Symbol) o)
        )

        throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")
    )

    static String destubClassName(String className)
    (§
        ;; skip over prefix + '.' or '/'
        if (className.startsWith(COMPILE_STUB_PREFIX))
        (§
            return className.substring(COMPILE_STUB_PREFIX.length() + 1)
        )
        return className
    )

    static Type getType(Class c)
    (§
        String descriptor = Type.getType(c).getDescriptor()
        if (descriptor.startsWith("L"))
        (§
            descriptor = "L" + destubClassName(descriptor.substring(1))
        )
        return Type.getType(descriptor)
    )

    static Object resolve(Symbol sym, boolean allowPrivate)
    (§
        return resolveIn(currentNS(), sym, allowPrivate)
    )

    static Object resolve(Symbol sym)
    (§
        return resolveIn(currentNS(), sym, false)
    )

    static Namespace namespaceFor(Symbol sym)
    (§
        return namespaceFor(currentNS(), sym)
    )

    static Namespace namespaceFor(Namespace inns, Symbol sym)
    (§
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        Symbol nsSym = Symbol.intern(sym.ns)
        Namespace ns = inns.lookupAlias(nsSym)
        if (ns == null)
        (§
            ;; ...otherwise check the Namespaces map.
            ns = Namespace.find(nsSym)
        )
        return ns
    )

    static public Object resolveIn(Namespace n, Symbol sym, boolean allowPrivate)
    (§
        ;; note - ns-qualified vars must already exist
        if (sym.ns != null)
        (§
            Namespace ns = namespaceFor(n, sym)
            if (ns == null)
            (§
                throw Util.runtimeException("No such namespace: " + sym.ns)
            )

            Var v = ns.findInternedVar(Symbol.intern(sym.name))
            if (v == null)
            (§
                throw Util.runtimeException("No such var: " + sym)
            )
            else if (v.ns != currentNS() && !v.isPublic() && !allowPrivate)
            (§
                throw new IllegalStateException("var: " + sym + " is not public")
            )
            return v
        )
        else if (sym.name.indexOf((§ char \.)) > 0 || sym.name.charAt(0) == (§ char \[))
        (§
            return RT.classForName(sym.name)
        )
        else if (sym.equals(NS))
        (§
            return RT.NS_VAR
        )
        else if (sym.equals(IN_NS))
        (§
            return RT.IN_NS_VAR
        )
        else
        (§
            if (Util.equals(sym, COMPILE_STUB_SYM.get()))
            (§
                return COMPILE_STUB_CLASS.get()
            )
            Object o = n.getMapping(sym)
            if (o == null)
            (§
                if (RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
                (§
                    return sym
                )
                else
                (§
                    throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")
                )
            )
            return o
        )
    )

    static public Object maybeResolveIn(Namespace n, Symbol sym)
    (§
        ;; note - ns-qualified vars must already exist
        if (sym.ns != null)
        (§
            Namespace ns = namespaceFor(n, sym)
            if (ns == null)
            (§
                return null
            )
            Var v = ns.findInternedVar(Symbol.intern(sym.name))
            if (v == null)
            (§
                return null
            )
            return v
        )
        else if (sym.name.indexOf((§ char \.)) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == (§ char \[))
        (§
            return RT.classForName(sym.name)
        )
        else if (sym.equals(NS))
        (§
            return RT.NS_VAR
        )
        else if (sym.equals(IN_NS))
        (§
            return RT.IN_NS_VAR
        )
        else
        (§
            Object o = n.getMapping(sym)
            return o
        )
    )

    static Var lookupVar(Symbol sym, boolean internNew, boolean registerMacro)
    (§
        Var var = null

        ;; note - ns-qualified vars in other namespaces must already exist
        if (sym.ns != null)
        (§
            Namespace ns = namespaceFor(sym)
            if (ns == null)
            (§
                return null
            )
            Symbol name = Symbol.intern(sym.name)
            if (internNew && ns == currentNS())
            (§
                var = currentNS().intern(name)
            )
            else
            (§
                var = ns.findInternedVar(name)
            )
        )
        else if (sym.equals(NS))
        (§
            var = RT.NS_VAR
        )
        else if (sym.equals(IN_NS))
        (§
            var = RT.IN_NS_VAR
        )
        else
        (§
            ;; is it mapped?
            Object o = currentNS().getMapping(sym)
            if (o == null)
            (§
                ;; introduce a new var in the current ns
                if (internNew)
                (§
                    var = currentNS().intern(Symbol.intern(sym.name))
                )
            )
            else if (o instanceof Var)
            (§
                var = (Var) o
            )
            else
            (§
                throw Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o)
            )
        )
        if (var != null && (!var.isMacro() || registerMacro))
        (§
            registerVar(var)
        )
        return var
    )

    static Var lookupVar(Symbol sym, boolean internNew)
    (§
        return lookupVar(sym, internNew, true)
    )

    private static void registerVar(Var var)
    (§
        if (!VARS.isBound())
        (§
            return
        )
        IPersistentMap varsMap = (IPersistentMap) VARS.deref()
        Object id = RT.get(varsMap, var)
        if (id == null)
        (§
            VARS.set(RT.assoc(varsMap, var, registerConstant(var)))
        )
    )

    static Namespace currentNS()
    (§
        return (Namespace) RT.CURRENT_NS.deref()
    )

    static void closeOver(LocalBinding b, ObjMethod method)
    (§
        if (b != null && method != null)
        (§
            LocalBinding lb = (LocalBinding) RT.get(method.locals, b)
            if (lb == null)
            (§
                method.objx.closes = (IPersistentMap) RT.assoc(method.objx.closes, b, b)
                closeOver(b, method.parent)
            )
            else
            (§
                if (lb.idx == 0)
                (§
                    method.usesThis = true
                )
                if (IN_CATCH_FINALLY.deref() != null)
                (§
                    method.localsUsedInCatchFinally = (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx)
                )
            )
        )
    )

    static LocalBinding referenceLocal(Symbol sym)
    (§
        if (!LOCAL_ENV.isBound())
        (§
            return null
        )
        LocalBinding b = (LocalBinding) RT.get(LOCAL_ENV.deref(), sym)
        if (b != null)
        (§
            ObjMethod method = (ObjMethod) METHOD.deref()
            if (b.idx == 0)
            (§
                method.usesThis = true
            )
            closeOver(b, method)
        )
        return b
    )

    private static Symbol tagOf(Object o)
    (§
        Object tag = RT.get(RT.meta(o), RT.TAG_KEY)
        if (tag instanceof Symbol)
        (§
            return (Symbol) tag
        )
        else if (tag instanceof String)
        (§
            return Symbol.intern(null, (String) tag)
        )
        return null
    )

    public static Object loadFile(String file) throws IOException
    (§
        FileInputStream f = new FileInputStream(file)
        try
        (§
            return load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName())
        )
        finally
        (§
            f.close()
        )
    )

    public static Object load(Reader rdr)
    (§
        return load(rdr, null, "NO_SOURCE_FILE")
    )

    static void consumeWhitespaces(LineNumberingPushbackReader pushbackReader)
    (§
        int ch = LispReader.read1(pushbackReader)
        while (LispReader.isWhitespace(ch))
            ch = LispReader.read1(pushbackReader)
        LispReader.unread(pushbackReader, ch)
    )

    private static final Object OPTS_COND_ALLOWED = RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW)

    private static Object readerOpts(String sourceName)
    (§
        if (sourceName != null && sourceName.endsWith(".clic"))
        (§
            return OPTS_COND_ALLOWED
        )
        else
        (§
            return null
        )
    )

    public static Object load(Reader rdr, String sourcePath, String sourceName)
    (§
        Object EOF = new Object()
        Object ret = null
        LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr)
        consumeWhitespaces(pushbackReader)
        Var.pushThreadBindings(RT.mapUniqueKeys(LOADER, RT.makeClassLoader(),
                    SOURCE_PATH, sourcePath,
                    SOURCE, sourceName,
                    METHOD, null,
                    LOCAL_ENV, null,
                    LOOP_LOCALS, null,
                    NEXT_LOCAL_NUM, 0,
                    RT.READEVAL, RT.T,
                    RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                    LINE_BEFORE, pushbackReader.getLineNumber(),
                    COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                    LINE_AFTER, pushbackReader.getLineNumber(),
                    COLUMN_AFTER, pushbackReader.getColumnNumber(),
                    RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                    RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                    RT.DATA_READERS, RT.DATA_READERS.deref()
        ))

        Object readerOpts = readerOpts(sourceName)
        try
        (§
            for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts) r != EOF r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))
            (§
                consumeWhitespaces(pushbackReader)
                LINE_AFTER.set(pushbackReader.getLineNumber())
                COLUMN_AFTER.set(pushbackReader.getColumnNumber())
                ret = eval(r, false)
                LINE_BEFORE.set(pushbackReader.getLineNumber())
                COLUMN_BEFORE.set(pushbackReader.getColumnNumber())
            )
        )
        catch (LispReader.ReaderException e)
        (§
            throw new CompilerException(sourcePath, e.line, e.column, e.getCause())
        )
        catch (Throwable e)
        (§
            if (!(e instanceof CompilerException))
            (§
                throw new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e)
            )
            else
            (§
                throw (CompilerException) e
            )
        )
        finally
        (§
            Var.popThreadBindings()
        )
        return ret
    )

    static public void writeClassFile(String internalName, byte[] bytecode)
        throws IOException
    (§
        String genPath = (String) COMPILE_PATH.deref()
        if (genPath == null)
        (§
            throw Util.runtimeException("*compile-path* not set")
        )
        String[] dirs = internalName.split("/")
        String p = genPath
        for (int i = 0 i < dirs.length - 1 i++)
        (§
            p += File.separator + dirs[i]
            (new File(p)).mkdir()
        )
        String path = genPath + File.separator + internalName + ".class"
        File cf = new File(path)
        cf.createNewFile()
        FileOutputStream cfs = new FileOutputStream(cf)
        try
        (§
            cfs.write(bytecode)
            cfs.flush()
        )
        finally
        (§
            cfs.close()
        )
    )

    public static void pushNS()
    (§
        Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), null))
    )

    public static void pushNSandLoader(ClassLoader loader)
    (§
        Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), null, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T))
    )

    public static ILookupThunk getLookupThunk(Object target, Keyword k)
    (§
        return null
    )

    static void compile1(GeneratorAdapter gen, ObjExpr objx, Object form)
    (§
        Object line = lineDeref()
        Object column = columnDeref()
        if (RT.meta(form) != null && RT.meta(form).containsKey(RT.LINE_KEY))
        (§
            line = RT.meta(form).valAt(RT.LINE_KEY)
        )
        if (RT.meta(form) != null && RT.meta(form).containsKey(RT.COLUMN_KEY))
        (§
            column = RT.meta(form).valAt(RT.COLUMN_KEY)
        )
        Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column,
                    LOADER, RT.makeClassLoader()
        ))
        try
        (§
            form = macroexpand(form)
            if (form instanceof ISeq && Util.equals(RT.first(form), DO))
            (§
                for (ISeq s = RT.next(form) s != null s = RT.next(s))
                (§
                    compile1(gen, objx, RT.first(s))
                )
            )
            else
            (§
                Expr expr = analyze(C.EVAL, form)
                objx.keywords = (IPersistentMap) KEYWORDS.deref()
                objx.vars = (IPersistentMap) VARS.deref()
                objx.constants = (PersistentVector) CONSTANTS.deref()
                expr.emit(C.EXPRESSION, objx, gen)
                expr.eval()
            )
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )

    public static Object compile(Reader rdr, String sourcePath, String sourceName)
        throws IOException
    (§
        if (COMPILE_PATH.deref() == null)
        (§
            throw Util.runtimeException("*compile-path* not set")
        )

        Object EOF = new Object()
        Object ret = null
        LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr)
        Var.pushThreadBindings(RT.mapUniqueKeys(SOURCE_PATH, sourcePath,
                    SOURCE, sourceName,
                    METHOD, null,
                    LOCAL_ENV, null,
                    LOOP_LOCALS, null,
                    NEXT_LOCAL_NUM, 0,
                    RT.READEVAL, RT.T,
                    RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                    LINE_BEFORE, pushbackReader.getLineNumber(),
                    COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                    LINE_AFTER, pushbackReader.getLineNumber(),
                    COLUMN_AFTER, pushbackReader.getColumnNumber(),
                    CONSTANTS, PersistentVector.EMPTY,
                    CONSTANT_IDS, new IdentityHashMap(),
                    KEYWORDS, PersistentHashMap.EMPTY,
                    VARS, PersistentHashMap.EMPTY,
                    RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                    RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                    RT.DATA_READERS, RT.DATA_READERS.deref()
        ))

        try
        (§
            ;; generate loader class
            ObjExpr objx = new ObjExpr(null)
            objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf((§ char \.))) + RT.LOADER_SUFFIX

            objx.objtype = Type.getObjectType(objx.internalName)
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS)
            ClassVisitor cv = cw
            cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, null, "java/lang/Object", null)

            ;; static load method
            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), null, null, cv)
            gen.visitCode()

            Object readerOpts = readerOpts(sourceName)
            for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts) r != EOF r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))
            (§
                LINE_AFTER.set(pushbackReader.getLineNumber())
                COLUMN_AFTER.set(pushbackReader.getColumnNumber())
                compile1(gen, objx, r)
                LINE_BEFORE.set(pushbackReader.getLineNumber())
                COLUMN_BEFORE.set(pushbackReader.getColumnNumber())
            )
            ;; end of load
            gen.returnValue()
            gen.endMethod()

            ;; static fields for constants
            for (int i = 0 i < objx.constants.count() i++)
            (§
                if (objx.usedConstants.contains(i))
                (§
                    cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), null, null)
                )
            )

            final int INITS_PER = 100
            int numInits =  objx.constants.count() / INITS_PER
            if (objx.constants.count() % INITS_PER != 0)
            (§
                ++numInits
            )

            for (int n = 0 n < numInits n++)
            (§
                GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), null, null, cv)
                clinitgen.visitCode()
                try
                (§
                    Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T))

                    for (int i = n * INITS_PER i < objx.constants.count() && i < (n + 1) * INITS_PER i++)
                    (§
                        if (objx.usedConstants.contains(i))
                        (§
                            objx.emitValue(objx.constants.nth(i), clinitgen)
                            clinitgen.checkCast(objx.constantType(i))
                            clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i))
                        )
                    )
                )
                finally
                (§
                    Var.popThreadBindings()
                )
                clinitgen.returnValue()
                clinitgen.endMethod()
            )

            ;; static init for constants, keywords and vars
            GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), null, null, cv)
            clinitgen.visitCode()
            Label startTry = clinitgen.newLabel()
            Label endTry = clinitgen.newLabel()
            Label end = clinitgen.newLabel()
            Label finallyLabel = clinitgen.newLabel()

            for (int n = 0 n < numInits n++)
            (§
                clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()"))
            )

            clinitgen.push(objx.internalName.replace((§ char \/), (§ char \.)))
            clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)"))
            clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()"))
            clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)"))
            clinitgen.mark(startTry)
            clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()"))
            clinitgen.mark(endTry)
            clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()"))
            clinitgen.goTo(end)

            clinitgen.mark(finallyLabel)
            ;; exception should be on stack
            clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()"))
            clinitgen.throwException()
            clinitgen.mark(end)
            clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, null)

            ;; end of static init
            clinitgen.returnValue()
            clinitgen.endMethod()

            ;; end of class
            cv.visitEnd()

            writeClassFile(objx.internalName, cw.toByteArray())
        )
        catch (LispReader.ReaderException e)
        (§
            throw new CompilerException(sourcePath, e.line, e.column, e.getCause())
        )
        finally
        (§
            Var.popThreadBindings()
        )
        return ret
    )

    static public class NewInstanceExpr extends ObjExpr
    (§
        IPersistentCollection methods

        Map<IPersistentVector, java.lang.reflect.Method> mmap
        Map<IPersistentVector, Set<Class>> covariants

        public NewInstanceExpr(Object tag)
        (§
            super(tag)
        )

        static class DeftypeParser implements IParser
        (§
            public Expr parse(C context, final Object frm)
            (§
                ISeq rform = (ISeq) frm
                ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                rform = RT.next(rform)
                String tagname = ((Symbol) rform.first()).getName()
                rform = rform.next()
                Symbol classname = (Symbol) rform.first()
                rform = rform.next()
                IPersistentVector fields = (IPersistentVector) rform.first()
                rform = rform.next()
                IPersistentMap opts = PersistentHashMap.EMPTY
                while (rform != null && rform.first() instanceof Keyword)
                (§
                    opts = opts.assoc(rform.first(), RT.second(rform))
                    rform = rform.next().next()
                )

                ObjExpr ret = build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, null, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts)
                return ret
            )
        )

        static class ReifyParser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                ISeq form = (ISeq) frm
                ObjMethod enclosingMethod = (ObjMethod) METHOD.deref()
                String basename = (enclosingMethod != null) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$")
                String simpleName = "reify__" + RT.nextID()
                String classname = basename + simpleName

                ISeq rform = RT.next(form)

                IPersistentVector interfaces = ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj"))

                rform = RT.next(rform)

                ObjExpr ret = build(interfaces, null, null, classname, Symbol.intern(classname), null, rform, frm, null)
                if (frm instanceof IObj && ((IObj) frm).meta() != null)
                (§
                    return new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta()))
                )
                else
                (§
                    return ret
                )
            )
        )

        static ObjExpr build(IPersistentVector interfaceSyms, IPersistentVector fieldSyms, Symbol thisSym, String tagName, Symbol className, Symbol typeTag, ISeq methodForms, Object frm, IPersistentMap opts)
        (§
            NewInstanceExpr ret = new NewInstanceExpr(null)

            ret.src = frm
            ret.name = className.toString()
            ret.classMeta = RT.meta(className)
            ret.internalName = ret.name.replace((§ char \.), (§ char \/))
            ret.objtype = Type.getObjectType(ret.internalName)
            ret.opts = opts

            if (thisSym != null)
            (§
                ret.thisName = thisSym.name
            )

            if (fieldSyms != null)
            (§
                IPersistentMap fmap = PersistentHashMap.EMPTY
                Object[] closesvec = new Object[2 * fieldSyms.count()]
                for (int i = 0 i < fieldSyms.count() i++)
                (§
                    Symbol sym = (Symbol) fieldSyms.nth(i)
                    LocalBinding lb = new LocalBinding(-1, sym, null, new MethodParamExpr(tagClass(tagOf(sym))), false, null)
                    fmap = fmap.assoc(sym, lb)
                    closesvec[i * 2] = lb
                    closesvec[i * 2 + 1] = lb
                )

                ;; todo - inject __meta et al into closes - when?
                ;; use array map to preserve ctor order
                ret.closes = new PersistentArrayMap(closesvec)
                ret.fields = fmap
                for (int i = fieldSyms.count() - 1 i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq")) --i)
                (§
                    ret.altCtorDrops++
                )
            )

            PersistentVector interfaces = PersistentVector.EMPTY
            for (ISeq s = RT.seq(interfaceSyms) s != null s = s.next())
            (§
                Class c = (Class) resolve((Symbol) s.first())
                if (!c.isInterface())
                (§
                    throw new IllegalArgumentException("only interfaces are supported, had: " + c.getName())
                )
                interfaces = interfaces.cons(c)
            )
            Class superClass = Object.class
            Map[] mc = gatherMethods(superClass, RT.seq(interfaces))
            Map overrideables = mc[0]
            Map covariants = mc[1]
            ret.mmap = overrideables
            ret.covariants = covariants

            String[] inames = interfaceNames(interfaces)

            Class stub = compileStub(slashname(superClass), ret, inames, frm)
            Symbol thistag = Symbol.intern(null, stub.getName())

            try
            (§
                Var.pushThreadBindings(RT.mapUniqueKeys(CONSTANTS, PersistentVector.EMPTY,
                            CONSTANT_IDS, new IdentityHashMap(),
                            KEYWORDS, PersistentHashMap.EMPTY,
                            VARS, PersistentHashMap.EMPTY,
                            KEYWORD_CALLSITES, PersistentVector.EMPTY,
                            PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                            VAR_CALLSITES, emptyVarCallSites(),
                            NO_RECUR, null
                ))
                if (ret.isDeftype())
                (§
                    Var.pushThreadBindings(RT.mapUniqueKeys(METHOD, null,
                                LOCAL_ENV, ret.fields,
                                COMPILE_STUB_SYM, Symbol.intern(null, tagName),
                                COMPILE_STUB_CLASS, stub
                    ))

                    ret.hintedFields = RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops)
                )

                ;; now (methodname [args] body)*
                ret.line = lineDeref()
                ret.column = columnDeref()
                IPersistentCollection methods = null
                for (ISeq s = methodForms s != null s = RT.next(s))
                (§
                    NewInstanceMethod m = NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables)
                    methods = RT.conj(methods, m)
                )

                ret.methods = methods
                ret.keywords = (IPersistentMap) KEYWORDS.deref()
                ret.vars = (IPersistentMap) VARS.deref()
                ret.constants = (PersistentVector) CONSTANTS.deref()
                ret.constantsID = RT.nextID()
                ret.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref()
                ret.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref()
                ret.varCallsites = (IPersistentSet) VAR_CALLSITES.deref()
            )
            finally
            (§
                if (ret.isDeftype())
                (§
                    Var.popThreadBindings()
                )
                Var.popThreadBindings()
            )

            try
            (§
                ret.compile(slashname(superClass), inames, false)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
            ret.getCompiledClass()
            return ret
        )

        ;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;
        static Class compileStub(String superName, NewInstanceExpr ret, String[] interfaceNames, Object frm)
        (§
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS)
            ClassVisitor cv = cw
            cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, null, superName, interfaceNames)

            ;; instance fields for closed-overs
            for (ISeq s = RT.keys(ret.closes) s != null s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                int access = ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL)
                if (lb.getPrimitiveType() != null)
                (§
                    cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), null, null)
                )
                else
                (§
                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                    cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), null, null)
                )
            )

            ;; ctor that takes closed-overs and does nothing
            Method m = new Method("<init>", Type.VOID_TYPE, ret.ctorTypes())
            GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cv)
            ctorgen.visitCode()
            ctorgen.loadThis()
            ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor)
            ctorgen.returnValue()
            ctorgen.endMethod()

            if (ret.altCtorDrops > 0)
            (§
                Type[] ctorTypes = ret.ctorTypes()
                Type[] altCtorTypes = new Type[ctorTypes.length-ret.altCtorDrops]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )
                Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, null, null, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __meta
                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __extmap
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()

                ;; alt ctor no __hash, __hasheq
                altCtorTypes = new Type[ctorTypes.length-2]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )

                alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, null, null, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()
            )
            ;; end of class
            cv.visitEnd()

            byte[] bytecode = cw.toByteArray()
            DynamicClassLoader loader = (DynamicClassLoader) LOADER.deref()
            return loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm)
        )

        static String[] interfaceNames(IPersistentVector interfaces)
        (§
            int icnt = interfaces.count()
            String[] inames = (icnt > 0) ? new String[icnt] :or null
            for (int i = 0 i < icnt i++)
            (§
                inames[i] = slashname((Class) interfaces.nth(i))
            )
            return inames
        )

        static String slashname(Class c)
        (§
            return c.getName().replace((§ char \.), (§ char \/))
        )

        protected void emitStatics(ClassVisitor cv)
        (§
            if (this.isDeftype())
            (§
                ;; getBasis()
                Method meth = Method.getMethod("cloiure.lang.IPersistentVector getBasis()")
                GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, null, null, cv)
                emitValue(hintedFields, gen)
                gen.returnValue()
                gen.endMethod()

                if (this.isDeftype() && this.fields.count() > this.hintedFields.count())
                (§
                    ;; create(IPersistentMap)
                    String className = name.replace((§ char \.), (§ char \/))
                    int i = 1
                    int fieldCount = hintedFields.count()

                    MethodVisitor mv = cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", null, null)
                    mv.visitCode()

                    for (ISeq s = RT.seq(hintedFields) s != null s = s.next(), i++)
                    (§
                        String bName = ((Symbol)s.first()).name
                        Class k = tagClass(tagOf(s.first()))

                        mv.visitVarInsn(ALOAD, 0)
                        mv.visitLdcInsn(bName)
                        mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                        mv.visitInsn(ACONST_NULL)
                        mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                        if (k.isPrimitive())
                        (§
                            mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName())
                        )
                        mv.visitVarInsn(ASTORE, i)
                        mv.visitVarInsn(ALOAD, 0)
                        mv.visitLdcInsn(bName)
                        mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                        mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                        mv.visitVarInsn(ASTORE, 0)
                    )

                    mv.visitTypeInsn(Opcodes.NEW, className)
                    mv.visitInsn(DUP)

                    Method ctor = new Method("<init>", Type.VOID_TYPE, ctorTypes())

                    if (hintedFields.count() > 0)
                    (§
                        for (i = 1 i <= fieldCount i++)
                        (§
                            mv.visitVarInsn(ALOAD, i)
                            Class k = tagClass(tagOf(hintedFields.nth(i - 1)))
                            if (k.isPrimitive())
                            (§
                                String b = Type.getType(boxClass(k)).getInternalName()
                                String p = Type.getType(k).getDescriptor()
                                String n = k.getName()

                                mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p)
                            )
                        )
                    )

                    mv.visitInsn(ACONST_NULL) ;; __meta
                    mv.visitVarInsn(ALOAD, 0) ;; __extmap
                    mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                    mv.visitInsn(ICONST_0) ;; __hash
                    mv.visitInsn(ICONST_0) ;; __hasheq
                    mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor())
                    mv.visitInsn(ARETURN)
                    mv.visitMaxs(4 + fieldCount, 1 + fieldCount)
                    mv.visitEnd()
                )
            )
        )

        protected void emitMethods(ClassVisitor cv)
        (§
            for (ISeq s = RT.seq(methods) s != null s = s.next())
            (§
                ObjMethod method = (ObjMethod) s.first()
                method.emit(this, cv)
            )
            ;; emit bridge methods
            for (Map.Entry<IPersistentVector, Set<Class>> e :in covariants.entrySet())
            (§
                java.lang.reflect.Method m = mmap.get(e.getKey())
                Class[] params = m.getParameterTypes()
                Type[] argTypes = new Type[params.length]

                for (int i = 0 i < params.length i++)
                (§
                    argTypes[i] = Type.getType(params[i])
                )

                Method target = new Method(m.getName(), Type.getType(m.getReturnType()), argTypes)

                for (Class retType :in e.getValue())
                (§
                    Method meth = new Method(m.getName(), Type.getType(retType), argTypes)

                    GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE,
                            meth,
                            null,
                            ;; todo don't hardwire this
                            EXCEPTION_TYPES,
                            cv)
                    gen.visitCode()
                    gen.loadThis()
                    gen.loadArgs()
                    gen.invokeInterface(Type.getType(m.getDeclaringClass()), target)
                    gen.returnValue()
                    gen.endMethod()
                )
            )
        )

        static public IPersistentVector msig(java.lang.reflect.Method m)
        (§
            return RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType())
        )

        static void considerMethod(java.lang.reflect.Method m, Map mm)
        (§
            IPersistentVector mk = msig(m)
            int mods = m.getModifiers()

            if (!(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods)))
            (§
                mm.put(mk, m)
            )
        )

        static void gatherMethods(Class c, Map mm)
        (§
            for (  c != null c = c.getSuperclass())
            (§
                for (java.lang.reflect.Method m :in c.getDeclaredMethods())
                (§
                    considerMethod(m, mm)
                )
                for (java.lang.reflect.Method m :in c.getMethods())
                (§
                    considerMethod(m, mm)
                )
            )
        )

        static public Map[] gatherMethods(Class sc, ISeq interfaces)
        (§
            Map allm = new HashMap()
            gatherMethods(sc, allm)
            for (  interfaces != null interfaces = interfaces.next())
            (§
                gatherMethods((Class) interfaces.first(), allm)
            )

            Map<IPersistentVector, java.lang.reflect.Method> mm = new HashMap<IPersistentVector, java.lang.reflect.Method>()
            Map<IPersistentVector, Set<Class>> covariants = new HashMap<IPersistentVector, Set<Class>>()
            for (Object o :in allm.entrySet())
            (§
                Map.Entry e = (Map.Entry) o
                IPersistentVector mk = (IPersistentVector) e.getKey()
                mk = (IPersistentVector) mk.pop()
                java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue()
                if (mm.containsKey(mk)) ;; covariant return
                (§
                    Set<Class> cvs = covariants.get(mk)
                    if (cvs == null)
                    (§
                        cvs = new HashSet<Class>()
                        covariants.put(mk, cvs)
                    )
                    java.lang.reflect.Method om = mm.get(mk)
                    if (om.getReturnType().isAssignableFrom(m.getReturnType()))
                    (§
                        cvs.add(om.getReturnType())
                        mm.put(mk, m)
                    )
                    else
                    (§
                        cvs.add(m.getReturnType())
                    )
                )
                else
                (§
                    mm.put(mk, m)
                )
            )
            return new Map[] (§ mm, covariants )
        )
    )

    public static class NewInstanceMethod extends ObjMethod
    (§
        String name
        Type[] argTypes
        Type retType
        Class retClass
        Class[] exclasses

        static Symbol dummyThis = Symbol.intern(null, "dummy_this_dlskjsdfower")
        private IPersistentVector parms

        public NewInstanceMethod(ObjExpr objx, ObjMethod parent)
        (§
            super(objx, parent)
        )

        int numParams()
        (§
            return argLocals.count()
        )

        String getMethodName()
        (§
            return name
        )

        Type getReturnType()
        (§
            return retType
        )

        Type[] getArgTypes()
        (§
            return argTypes
        )

        static public IPersistentVector msig(String name, Class[] paramTypes)
        (§
            return RT.vector(name, RT.seq(paramTypes))
        )

        static NewInstanceMethod parse(ObjExpr objx, ISeq form, Symbol thistag, Map overrideables)
        (§
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            NewInstanceMethod method = new NewInstanceMethod(objx, (ObjMethod) METHOD.deref())
            Symbol dotname = (Symbol)RT.first(form)
            Symbol name = (Symbol) Symbol.intern(null, munge(dotname.name)).withMeta(RT.meta(dotname))
            IPersistentVector parms = (IPersistentVector) RT.second(form)
            if (parms.count() == 0)
            (§
                throw new IllegalArgumentException("Must supply at least one argument for 'this' in: " + dotname)
            )
            Symbol thisName = (Symbol) parms.nth(0)
            parms = RT.subvec(parms, 1, parms.count())
            ISeq body = RT.next(RT.next(form))
            try
            (§
                method.line = lineDeref()
                method.column = columnDeref()
                ;; register as the current method and set up a new env frame
                PathNode pnode =  new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get())
                Var.pushThreadBindings(RT.mapUniqueKeys(
                            METHOD, method,
                            LOCAL_ENV, LOCAL_ENV.deref(),
                            LOOP_LOCALS, null,
                            NEXT_LOCAL_NUM, 0,
                            CLEAR_PATH, pnode,
                            CLEAR_ROOT, pnode,
                            CLEAR_SITES, PersistentHashMap.EMPTY,
                            METHOD_RETURN_CONTEXT, RT.T
                ))

                ;; register 'this' as local 0
                if (thisName != null)
                (§
                    registerLocal((thisName == null) ? dummyThis:thisName, thistag, null, false)
                )
                else
                (§
                    getAndIncLocalNum()
                )

                PersistentVector argLocals = PersistentVector.EMPTY
                method.retClass = tagClass(tagOf(name))
                method.argTypes = new Type[parms.count()]
                boolean hinted = tagOf(name) != null
                Class[] pclasses = new Class[parms.count()]
                Symbol[] psyms = new Symbol[parms.count()]

                for (int i = 0 i < parms.count() i++)
                (§
                    if (!(parms.nth(i) instanceof Symbol))
                    (§
                        throw new IllegalArgumentException("params must be Symbols")
                    )
                    Symbol p = (Symbol) parms.nth(i)
                    Object tag = tagOf(p)
                    if (tag != null)
                    (§
                        hinted = true
                    )
                    if (p.getNamespace() != null)
                    (§
                        p = Symbol.intern(p.name)
                    )
                    Class pclass = tagClass(tag)
                    pclasses[i] = pclass
                    psyms[i] = p
                )
                Map matches = findMethodsWithNameAndArity(name.name, parms.count(), overrideables)
                Object mk = msig(name.name, pclasses)
                java.lang.reflect.Method m = null
                if (matches.size() > 0)
                (§
                    ;; multiple methods
                    if (matches.size() > 1)
                    (§
                        ;; must be hinted and match one method
                        if (!hinted)
                        (§
                            throw new IllegalArgumentException("Must hint overloaded method: " + name.name)
                        )
                        m = (java.lang.reflect.Method) matches.get(mk)
                        if (m == null)
                        (§
                            throw new IllegalArgumentException("Can't find matching overloaded method: " + name.name)
                        )
                        if (m.getReturnType() != method.retClass)
                        (§
                            throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())
                        )
                    )
                    else ;; one match
                    (§
                        ;; if hinted, validate match,
                        if (hinted)
                        (§
                            m = (java.lang.reflect.Method) matches.get(mk)
                            if (m == null)
                            (§
                                throw new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match.")
                            )
                            if (m.getReturnType() != method.retClass)
                            (§
                                throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())
                            )
                        )
                        else ;; adopt found method sig
                        (§
                            m = (java.lang.reflect.Method) matches.values().iterator().next()
                            method.retClass = m.getReturnType()
                            pclasses = m.getParameterTypes()
                        )
                    )
                )
                else
                (§
                    throw new IllegalArgumentException("Can't define method not in interfaces: " + name.name)
                )

                ;; validate unque name+arity among additional methods

                method.retType = Type.getType(method.retClass)
                method.exclasses = m.getExceptionTypes()

                for (int i = 0 i < parms.count() i++)
                (§
                    LocalBinding lb = registerLocal(psyms[i], null, new MethodParamExpr(pclasses[i]), true)
                    argLocals = argLocals.assocN(i, lb)
                    method.argTypes[i] = Type.getType(pclasses[i])
                )
                for (int i = 0 i < parms.count() i++)
                (§
                    if (pclasses[i] == long.class || pclasses[i] == double.class)
                    (§
                        getAndIncLocalNum()
                    )
                )
                LOOP_LOCALS.set(argLocals)
                method.name = name.name
                method.methodMeta = RT.meta(name)
                method.parms = parms
                method.argLocals = argLocals
                method.body = (new BodyExpr.Parser()).parse(C.RETURN, body)
                return method
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        private static Map findMethodsWithNameAndArity(String name, int arity, Map mm)
        (§
            Map ret = new HashMap()
            for (Object o :in mm.entrySet())
            (§
                Map.Entry e = (Map.Entry) o
                java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue()
                if (name.equals(m.getName()) && m.getParameterTypes().length == arity)
                (§
                    ret.put(e.getKey(), e.getValue())
                )
            )
            return ret
        )

        private static Map findMethodsWithName(String name, Map mm)
        (§
            Map ret = new HashMap()
            for (Object o :in mm.entrySet())
            (§
                Map.Entry e = (Map.Entry) o
                java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue()
                if (name.equals(m.getName()))
                (§
                    ret.put(e.getKey(), e.getValue())
                )
            )
            return ret
        )

        public void emit(ObjExpr obj, ClassVisitor cv)
        (§
            Method m = new Method(getMethodName(), getReturnType(), getArgTypes())

            Type[] extypes = null
            if (exclasses.length > 0)
            (§
                extypes = new Type[exclasses.length]
                for (int i = 0 i < exclasses.length i++)
                (§
                    extypes[i] = Type.getType(exclasses[i])
                )
            )
            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, m, null, extypes, cv)
            addAnnotation(gen, methodMeta)
            for (int i = 0 i < parms.count() i++)
            (§
                IPersistentMap meta = RT.meta(parms.nth(i))
                addParameterAnnotation(gen, meta, i)
            )
            gen.visitCode()

            Label loopLabel = gen.mark()

            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))

                emitBody(objx, gen, retClass, body)
                Label end = gen.mark()
                gen.visitLocalVariable("this", obj.objtype.getDescriptor(), null, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != null lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), null, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()
        )
    )

    static boolean inty(Class c)
    (§
        return (c == int.class || c == short.class || c == byte.class || c == char.class)
    )

    static Class retType(Class tc, Class ret)
    (§
        if (tc == null)
        (§
            return ret
        )
        if (ret == null)
        (§
            return tc
        )
        if (ret.isPrimitive() && tc.isPrimitive())
        (§
            if ((inty(ret) && inty(tc)) || (ret == tc))
            (§
                return tc
            )
            throw new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead")
        )
        return tc
    )

    static Class primClass(Symbol sym)
    (§
        if (sym == null)
        (§
            return null
        )
        Class c = null
        if (sym.name.equals("int"))
        (§
            c = int.class
        )
        else if (sym.name.equals("long"))
        (§
            c = long.class
        )
        else if (sym.name.equals("float"))
        (§
            c = float.class
        )
        else if (sym.name.equals("double"))
        (§
            c = double.class
        )
        else if (sym.name.equals("char"))
        (§
            c = char.class
        )
        else if (sym.name.equals("short"))
        (§
            c = short.class
        )
        else if (sym.name.equals("byte"))
        (§
            c = byte.class
        )
        else if (sym.name.equals("boolean"))
        (§
            c = boolean.class
        )
        else if (sym.name.equals("void"))
        (§
            c = void.class
        )
        return c
    )

    static Class tagClass(Object tag)
    (§
        if (tag == null)
        (§
            return Object.class
        )
        Class c = null
        if (tag instanceof Symbol)
        (§
            c = primClass((Symbol) tag)
        )
        if (c == null)
        (§
            c = HostExpr.tagToClass(tag)
        )
        return c
    )

    static Class primClass(Class c)
    (§
        return c.isPrimitive() ? c :or Object.class
    )

    static Class boxClass(Class p)
    (§
        if (!p.isPrimitive())
        (§
            return p
        )

        Class c = null

        if (p == Integer.TYPE)
        (§
            c = Integer.class
        )
        else if (p == Long.TYPE)
        (§
            c = Long.class
        )
        else if (p == Float.TYPE)
        (§
            c = Float.class
        )
        else if (p == Double.TYPE)
        (§
            c = Double.class
        )
        else if (p == Character.TYPE)
        (§
            c = Character.class
        )
        else if (p == Short.TYPE)
        (§
            c = Short.class
        )
        else if (p == Byte.TYPE)
        (§
            c = Byte.class
        )
        else if (p == Boolean.TYPE)
        (§
            c = Boolean.class
        )

        return c
    )

    static public class MethodParamExpr implements Expr, MaybePrimitiveExpr
    (§
        final Class c

        public MethodParamExpr(Class c)
        (§
            this.c = c
        )

        public Object eval()
        (§
            throw Util.runtimeException("Can't eval")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            throw Util.runtimeException("Can't emit")
        )

        public boolean hasJavaClass()
        (§
            return (c != null)
        )

        public Class getJavaClass()
        (§
            return c
        )

        public boolean canEmitPrimitive()
        (§
            return Util.isPrimitive(c)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            throw Util.runtimeException("Can't emit")
        )
    )

    public static class CaseExpr implements Expr, MaybePrimitiveExpr
    (§
        public final LocalBindingExpr expr
        public final int shift, mask, low, high
        public final Expr defaultExpr
        public final SortedMap<Integer, Expr> tests
        public final HashMap<Integer, Expr> thens
        public final Keyword switchType
        public final Keyword testType
        public final Set<Integer> skipCheck
        public final Class returnType
        public final int line
        public final int column

        final static Type NUMBER_TYPE = Type.getType(Number.class)
        final static Method intValueMethod = Method.getMethod("int intValue()")

        final static Method hashMethod = Method.getMethod("int hash(Object)")
        final static Method hashCodeMethod = Method.getMethod("int hashCode()")
        final static Method equivMethod = Method.getMethod("boolean equiv(Object, Object)")
        final static Keyword compactKey = Keyword.intern(null, "compact")
        final static Keyword sparseKey = Keyword.intern(null, "sparse")
        final static Keyword hashIdentityKey = Keyword.intern(null, "hash-identity")
        final static Keyword hashEquivKey = Keyword.intern(null, "hash-equiv")
        final static Keyword intKey = Keyword.intern(null, "int")

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        public CaseExpr(int line, int column, LocalBindingExpr expr, int shift, int mask, int low, int high, Expr defaultExpr,
                SortedMap<Integer, Expr> tests, HashMap<Integer, Expr> thens, Keyword switchType, Keyword testType, Set<Integer> skipCheck)
        (§
            this.expr = expr
            this.shift = shift
            this.mask = mask
            this.low = low
            this.high = high
            this.defaultExpr = defaultExpr
            this.tests = tests
            this.thens = thens
            this.line = line
            this.column = column
            if (switchType != compactKey && switchType != sparseKey)
            (§
                throw new IllegalArgumentException("Unexpected switch type: "+switchType)
            )
            this.switchType = switchType
            if (testType != intKey && testType != hashEquivKey && testType != hashIdentityKey)
            (§
                throw new IllegalArgumentException("Unexpected test type: "+switchType)
            )
            this.testType = testType
            this.skipCheck = skipCheck
            Collection<Expr> returns = new ArrayList(thens.values())
            returns.add(defaultExpr)
            this.returnType = maybeJavaClass(returns)
            if (RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n",
                            SOURCE_PATH.deref(), line, column)
            )
        )

        public boolean hasJavaClass()
        (§
            return (returnType != null)
        )

        public boolean canEmitPrimitive()
        (§
            return Util.isPrimitive(returnType)
        )

        public Class getJavaClass()
        (§
            return returnType
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval case")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, false)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, true)
        )

        public void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
        (§
            Label defaultLabel = gen.newLabel()
            Label endLabel = gen.newLabel()
            SortedMap<Integer, Label> labels = new TreeMap()

            for (Integer i :in tests.keySet())
            (§
                labels.put(i, gen.newLabel())
            )

            gen.visitLineNumber(line, gen.mark())

            Class primExprClass = maybePrimitiveType(expr)
            Type primExprType = (primExprClass == null) ? null :or Type.getType(primExprClass)

            if (testType == intKey)
            (§
                emitExprForInts(objx, gen, primExprType, defaultLabel)
            )
            else
            (§
                emitExprForHashes(objx, gen)
            )

            if (switchType == sparseKey)
            (§
                Label[] la = new Label[labels.size()]
                la = labels.values().toArray(la)
                int[] ints = Numbers.int_array(tests.keySet())
                gen.visitLookupSwitchInsn(defaultLabel, ints, la)
            )
            else
            (§
                Label[] la = new Label[(high - low) + 1]
                for (int i = low i <= high i++)
                (§
                    la[i-low] = labels.containsKey(i) ? labels.get(i) :or defaultLabel
                )
                gen.visitTableSwitchInsn(low, high, defaultLabel, la)
            )

            for (Integer i :in labels.keySet())
            (§
                gen.mark(labels.get(i))
                if (testType == intKey)
                (§
                    emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed)
                )
                else if (RT.contains(skipCheck, i) == RT.T)
                (§
                    emitExpr(objx, gen, thens.get(i), emitUnboxed)
                )
                else
                (§
                    emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed)
                )
                gen.goTo(endLabel)
            )

            gen.mark(defaultLabel)
            emitExpr(objx, gen, defaultExpr, emitUnboxed)
            gen.mark(endLabel)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        private boolean isShiftMasked()
        (§
            return (mask != 0)
        )

        private void emitShiftMask(GeneratorAdapter gen)
        (§
            if (isShiftMasked())
            (§
                gen.push(shift)
                gen.visitInsn(ISHR)
                gen.push(mask)
                gen.visitInsn(IAND)
            )
        )

        private void emitExprForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Label defaultLabel)
        (§
            if (exprType == null)
            (§
                if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (§
                    RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n",
                                SOURCE_PATH.deref(), line, column)
                )
                expr.emit(C.EXPRESSION, objx, gen)
                gen.instanceOf(NUMBER_TYPE)
                gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel)
                expr.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(NUMBER_TYPE)
                gen.invokeVirtual(NUMBER_TYPE, intValueMethod)
                emitShiftMask(gen)
            )
            else if (exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
            (§
                expr.emitUnboxed(C.EXPRESSION, objx, gen)
                gen.cast(exprType, Type.INT_TYPE)
                emitShiftMask(gen)
            )
            else
            (§
                gen.goTo(defaultLabel)
            )
        )

        private void emitThenForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
        (§
            if (exprType == null)
            (§
                expr.emit(C.EXPRESSION, objx, gen)
                test.emit(C.EXPRESSION, objx, gen)
                gen.invokeStatic(UTIL_TYPE, equivMethod)
                gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel)
                emitExpr(objx, gen, then, emitUnboxed)
            )
            else if (exprType == Type.LONG_TYPE)
            (§
                ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen)
                expr.emitUnboxed(C.EXPRESSION, objx, gen)
                gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel)
                emitExpr(objx, gen, then, emitUnboxed)
            )
            else if (exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
            (§
                if (isShiftMasked())
                (§
                    ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen)
                    expr.emitUnboxed(C.EXPRESSION, objx, gen)
                    gen.cast(exprType, Type.LONG_TYPE)
                    gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel)
                )
                ;; else direct match
                emitExpr(objx, gen, then, emitUnboxed)
            )
            else
            (§
                gen.goTo(defaultLabel)
            )
        )

        private void emitExprForHashes(ObjExpr objx, GeneratorAdapter gen)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            gen.invokeStatic(UTIL_TYPE, hashMethod)
            emitShiftMask(gen)
        )

        private void emitThenForHashes(ObjExpr objx, GeneratorAdapter gen, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            test.emit(C.EXPRESSION, objx, gen)
            if (testType == hashIdentityKey)
            (§
                gen.visitJumpInsn(IF_ACMPNE, defaultLabel)
            )
            else
            (§
                gen.invokeStatic(UTIL_TYPE, equivMethod)
                gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel)
            )
            emitExpr(objx, gen, then, emitUnboxed)
        )

        private static void emitExpr(ObjExpr objx, GeneratorAdapter gen, Expr expr, boolean emitUnboxed)
        (§
            if (emitUnboxed && expr instanceof MaybePrimitiveExpr)
            (§
                ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen)
            )
            else
            (§
                expr.emit(C.EXPRESSION, objx, gen)
            )
        )

        static class Parser implements IParser
        (§
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                if (context == C.EVAL)
                (§
                    return analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))
                )
                IPersistentVector args = LazilyPersistentVector.create(form.next())

                Object exprForm = args.nth(0)
                int shift = ((Number)args.nth(1)).intValue()
                int mask = ((Number)args.nth(2)).intValue()
                Object defaultForm = args.nth(3)
                Map caseMap = (Map)args.nth(4)
                Keyword switchType = ((Keyword)args.nth(5))
                Keyword testType = ((Keyword)args.nth(6))
                Set skipCheck = (RT.count(args) < 8) ? null :or (Set)args.nth(7)

                ISeq keys = RT.keys(caseMap)
                int low = ((Number)RT.first(keys)).intValue()
                int high = ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue()

                LocalBindingExpr testexpr = (LocalBindingExpr) analyze(C.EXPRESSION, exprForm)
                testexpr.shouldClear = false

                SortedMap<Integer, Expr> tests = new TreeMap()
                HashMap<Integer, Expr> thens = new HashMap()

                PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get())

                for (Object o :in caseMap.entrySet())
                (§
                    Map.Entry e = (Map.Entry) o
                    Integer minhash = ((Number)e.getKey()).intValue()
                    Object pair = e.getValue() ;; [test-val then-expr]
                    Expr testExpr = (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair))
                    tests.put(minhash, testExpr)

                    Expr thenExpr
                    try
                    (§
                        Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                        thenExpr = analyze(context, RT.second(pair))
                    )
                    finally
                    (§
                        Var.popThreadBindings()
                    )
                    thens.put(minhash, thenExpr)
                )

                Expr defaultExpr
                try
                (§
                    Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                    defaultExpr = analyze(context, args.nth(3))
                )
                finally
                (§
                    Var.popThreadBindings()
                )

                int line = ((Number)LINE.deref()).intValue()
                int column = ((Number)COLUMN.deref()).intValue()
                return new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck)
            )
        )
    )

    static IPersistentCollection emptyVarCallSites()
    (§
        return PersistentHashSet.EMPTY
    )
)
)

(§ java cloiure.lang.Cons

import java.io.Serializable

final public class Cons extends ASeq implements Serializable
(§
    private final Object _first
    private final ISeq _more

    public Cons(Object first, ISeq _more)
    (§
        this._first = first
        this._more = _more
    )

    public Cons(IPersistentMap meta, Object _first, ISeq _more)
    (§
        super(meta)
        this._first = _first
        this._more = _more
    )

    public Object first()
    (§
        return _first
    )

    public ISeq next()
    (§
        return more().seq()
    )

    public ISeq more()
    (§
        if (_more == null)
        (§
            return PersistentList.EMPTY
        )
        return _more
    )

    public int count()
    (§
        return 1 + RT.count(_more)
    )

    public Cons withMeta(IPersistentMap meta)
    (§
        return new Cons(meta, _first, _more)
    )
)
)

(§ java cloiure.lang.Counted

;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;
public interface Counted
(§
    int count()
)
)

(§ java cloiure.lang.Cycle

public class Cycle extends ASeq implements IReduce, IPending
(§
    private final ISeq all ;; never null
    private final ISeq prev
    private volatile ISeq _current ;; lazily realized
    private volatile ISeq _next ;; cached

    private Cycle(ISeq all, ISeq prev, ISeq current)
    (§
        this.all = all
        this.prev = prev
        this._current = current
    )

    private Cycle(IPersistentMap meta, ISeq all, ISeq prev, ISeq current, ISeq next)
    (§
        super(meta)
        this.all = all
        this.prev = prev
        this._current = current
        this._next = next
    )

    public static ISeq create(ISeq vals)
    (§
        if (vals == null)
        (§
            return PersistentList.EMPTY
        )
        return new Cycle(vals, null, vals)
    )

    ;; realization for use of current
    private ISeq current()
    (§
        if (_current == null)
        (§
            ISeq current = prev.next()
            _current = (current == null) ? all :or current
        )
        return _current
    )

    public boolean isRealized()
    (§
        return (_current != null)
    )

    public Object first()
    (§
        return current().first()
    )

    public ISeq next()
    (§
        if (_next == null)
        (§
            _next = new Cycle(all, current(), null)
        )
        return _next
    )

    public Cycle withMeta(IPersistentMap meta)
    (§
        return new Cycle(meta, all, prev, _current, _next)
    )

    public Object reduce(IFn f)
    (§
        ISeq s = current()
        Object ret = s.first()
        while (true)
        (§
            s = s.next()
            if (s == null)
            (§
                s = all
            )
            ret = f.invoke(ret, s.first())
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
        )
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = start
        ISeq s = current()
        while (true)
        (§
            ret = f.invoke(ret, s.first())
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            s = s.next()
            if (s == null)
            (§
                s = all
            )
        )
    )
)
)

(§ java cloiure.lang.Delay

public class Delay implements IDeref, IPending
(§
    volatile Object val
    volatile Throwable exception
    volatile IFn fn

    public Delay(IFn fn)
    (§
        this.fn = fn
        this.val = null
        this.exception = null
    )

    static public Object force(Object x)
    (§
        return (x instanceof Delay) ? ((Delay) x).deref() :or x
    )

    public Object deref()
    (§
        if (fn != null)
        (§
            synchronized (this)
            (§
                ;; double check
                if (fn != null)
                (§
                    try
                    (§
                        val = fn.invoke()
                    )
                    catch (Throwable t)
                    (§
                        exception = t
                    )
                    fn = null
                )
            )
        )
        if (exception != null)
        (§
            throw Util.sneakyThrow(exception)
        )
        return val
    )

    synchronized public boolean isRealized()
    (§
        return (fn == null)
    )
)
)

(§ java cloiure.lang.DynamicClassLoader

import java.lang.ref.Reference
import java.util.HashMap
import java.util.Map
import java.util.concurrent.ConcurrentHashMap
import java.net.URLClassLoader
import java.net.URL
import java.lang.ref.ReferenceQueue
import java.lang.ref.SoftReference

public class DynamicClassLoader extends URLClassLoader
(§
    HashMap<Integer, Object[]> constantVals = new HashMap<Integer, Object[]>()
    static ConcurrentHashMap<String, Reference<Class>>classCache = new ConcurrentHashMap<String, Reference<Class> >()

    static final URL[] EMPTY_URLS = new URL[] (§)

    static final ReferenceQueue rq = new ReferenceQueue()

    public DynamicClassLoader()
    (§
        ;; pseudo test in lieu of hasContextClassLoader()
        super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == null || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader())
    )

    public DynamicClassLoader(ClassLoader parent)
    (§
        super(EMPTY_URLS, parent)
    )

    public Class defineClass(String name, byte[] bytes, Object srcForm)
    (§
        Util.clearCache(rq, classCache)
        Class c = defineClass(name, bytes, 0, bytes.length)
        classCache.put(name, new SoftReference(c, rq))
        return c
    )

    static Class<?> findInMemoryClass(String name)
    (§
        Reference<Class> cr = classCache.get(name)
        if (cr != null)
        (§
            Class c = cr.get()
            if (c != null)
            (§
                return c
            )
            else
            (§
                classCache.remove(name, cr)
            )
        )
        return null
    )

    protected Class<?>findClass(String name) throws ClassNotFoundException
    (§
        Class c = findInMemoryClass(name)
        if (c != null)
        (§
            return c
        )
        else
        (§
            return super.findClass(name)
        )
    )

    protected synchronized Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    (§
        Class c = findLoadedClass(name)
        if (c == null)
        (§
            c = findInMemoryClass(name)
            if (c == null)
            (§
                c = super.loadClass(name, false)
            )
        )
        if (resolve)
        (§
            resolveClass(c)
        )
        return c
    )

    public void registerConstants(int id, Object[] val)
    (§
        constantVals.put(id, val)
    )

    public Object[] getConstants(int id)
    (§
        return constantVals.get(id)
    )

    public void addURL(URL url)
    (§
        super.addURL(url)
    )
)
)

(§ java cloiure.lang.EdnReader

import java.io.IOException
import java.io.PushbackReader
import java.io.Reader
import java.math.BigDecimal
import java.math.BigInteger
import java.util.ArrayList
import java.util.Iterator
import java.util.List
import java.util.regex.Matcher
import java.util.regex.Pattern

public class EdnReader
(§
    static IFn[] macros = new IFn[256]
    static IFn[] dispatchMacros = new IFn[256]
    static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")
    static Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")
    static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)")
    static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")

    static IFn taggedReader = new TaggedReader()

    static
    (§
        macros[(§ char \")] = new StringReader() ;; oops! "
        macros[(§ char \;)] = new CommentReader()
        macros[(§ char \^)] = new MetaReader()
        macros[(§ char \()] = new ListReader()
        macros[(§ char \))] = new UnmatchedDelimiterReader()
        macros[(§ char \[)] = new VectorReader()
        macros[(§ char \])] = new UnmatchedDelimiterReader()
        macros[(§ char \{)] = new MapReader()
        macros[(§ char \})] = new UnmatchedDelimiterReader()
        macros[(§ char \\)] = new CharacterReader()
        macros[(§ char \#)] = new DispatchReader()

        dispatchMacros[(§ char \#)] = new SymbolicValueReader()
        dispatchMacros[(§ char \^)] = new MetaReader()
        dispatchMacros[(§ char \{)] = new SetReader()
        dispatchMacros[(§ char \<)] = new UnreadableReader()
        dispatchMacros[(§ char \_)] = new DiscardReader()
        dispatchMacros[(§ char \:)] = new NamespaceMapReader()
    )

    static boolean nonConstituent(int ch)
    (§
        return (ch == (§ char \@) || ch == (§ char \`) || ch == (§ char \~))
    )

    static public Object readString(String s, IPersistentMap opts)
    (§
        PushbackReader r = new PushbackReader(new java.io.StringReader(s))
        return read(r, opts)
    )

    static boolean isWhitespace(int ch)
    (§
        return (Character.isWhitespace(ch) || ch == (§ char \,))
    )

    static void unread(PushbackReader r, int ch)
    (§
        if (ch != -1)
        (§
            try
            (§
                r.unread(ch)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
    )

    public static class ReaderException extends RuntimeException
    (§
        final int line
        final int column

        public ReaderException(int line, int column, Throwable cause)
        (§
            super(cause)
            this.line = line
            this.column = column
        )
    )

    static public int read1(Reader r)
    (§
        try
        (§
            return r.read()
        )
        catch (IOException e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    static final Keyword EOF = Keyword.intern(null, "eof")

    static public Object read(PushbackReader r, IPersistentMap opts)
    (§
        return read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts)
    )

    static public Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
    (§
        try
        (§
            while (true)
            (§
                int ch = read1(r)

                while (isWhitespace(ch))
                    ch = read1(r)

                if (ch == -1)
                (§
                    if (eofIsError)
                    (§
                        throw Util.runtimeException("EOF while reading")
                    )
                    return eofValue
                )

                if (Character.isDigit(ch))
                (§
                    Object n = readNumber(r, (char) ch)
                    if (RT.suppressRead())
                    (§
                        return null
                    )
                    return n
                )

                IFn macroFn = getMacro(ch)
                if (macroFn != null)
                (§
                    Object ret = macroFn.invoke(r, (char) ch, opts)
                    if (RT.suppressRead())
                    (§
                        return null
                    )
                    ;; no op macros return the reader
                    if (ret == r)
                    (§
                        continue
                    )
                    return ret
                )

                if (ch == (§ char \+) || ch == (§ char \-))
                (§
                    int ch2 = read1(r)
                    if (Character.isDigit(ch2))
                    (§
                        unread(r, ch2)
                        Object n = readNumber(r, (char) ch)
                        if (RT.suppressRead())
                        (§
                            return null
                        )
                        return n
                    )
                    unread(r, ch2)
                )

                String token = readToken(r, (char) ch, true)
                if (RT.suppressRead())
                (§
                    return null
                )
                return interpretToken(token)
            )
        )
        catch (Exception e)
        (§
            if (isRecursive || !(r instanceof LineNumberingPushbackReader))
            (§
                throw Util.sneakyThrow(e)
            )
            LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r
            throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)
        )
    )

    static private String readToken(PushbackReader r, char initch, boolean leadConstituent)
    (§
        StringBuilder sb = new StringBuilder()
        if (leadConstituent && nonConstituent(initch))
        (§
            throw Util.runtimeException("Invalid leading character: " + (char)initch)
        )

        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)

            if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
            (§
                unread(r, ch)
                return sb.toString()
            )
            else if (nonConstituent(ch))
            (§
                throw Util.runtimeException("Invalid constituent character: " + (char)ch)
            )
            sb.append((char) ch)
        )
    )

    static private Object readNumber(PushbackReader r, char initch)
    (§
        StringBuilder sb = new StringBuilder()
        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            sb.append((char) ch)
        )

        String s = sb.toString()
        Object n = matchNumber(s)
        if (n == null)
        (§
            throw new NumberFormatException("Invalid number: " + s)
        )
        return n
    )

    static private int readUnicodeChar(String token, int offset, int length, int base)
    (§
        if (token.length() != offset + length)
        (§
            throw new IllegalArgumentException("Invalid unicode character: \\" + token)
        )
        int uc = 0
        for (int i = offset i < offset + length ++i)
        (§
            int d = Character.digit(token.charAt(i), base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + token.charAt(i))
            )
            uc = uc * base + d
        )
        return (char) uc
    )

    static private int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
    (§
        int uc = Character.digit(initch, base)
        if (uc == -1)
        (§
            throw new IllegalArgumentException("Invalid digit: " + (char) initch)
        )
        int i = 1
        for (  i < length ++i)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            int d = Character.digit(ch, base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + (char) ch)
            )
            uc = uc * base + d
        )
        if (i != length && exact)
        (§
            throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)
        )
        return uc
    )

    static private Object interpretToken(String s)
    (§
        if (s.equals("nil"))
        (§
            return null
        )
        else if (s.equals("true"))
        (§
            return RT.T
        )
        else if (s.equals("false"))
        (§
            return RT.F
        )

        Object ret = null

        ret = matchSymbol(s)
        if (ret != null)
        (§
            return ret
        )

        throw Util.runtimeException("Invalid token: " + s)
    )

    private static Object matchSymbol(String s)
    (§
        Matcher m = symbolPat.matcher(s)
        if (m.matches())
        (§
            int gc = m.groupCount()
            String ns = m.group(1)
            String name = m.group(2)
            if (ns != null && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
            (§
                return null
            )
            if (s.startsWith("::"))
            (§
                return null
            )
            boolean isKeyword = s.charAt(0) == (§ char \:)
            Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0))
            if (isKeyword)
            (§
                return Keyword.intern(sym)
            )
            return sym
        )
        return null
    )

    private static Object matchNumber(String s)
    (§
        Matcher m = intPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(2) != null)
            (§
                if (m.group(8) != null)
                (§
                    return BigInt.ZERO
                )
                return Numbers.num(0)
            )
            boolean negate = m.group(1).equals("-")
            String n
            int radix = 10
            if ((n = m.group(3)) != null)
            (§
                radix = 10
            )
            else if ((n = m.group(4)) != null)
            (§
                radix = 16
            )
            else if ((n = m.group(5)) != null)
            (§
                radix = 8
            )
            else if ((n = m.group(7)) != null)
            (§
                radix = Integer.parseInt(m.group(6))
            )
            if (n == null)
            (§
                return null
            )
            BigInteger bn = new BigInteger(n, radix)
            if (negate)
            (§
                bn = bn.negate()
            )
            if (m.group(8) != null)
            (§
                return BigInt.fromBigInteger(bn)
            )
            return (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)
        )
        m = floatPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(4) != null)
            (§
                return new BigDecimal(m.group(1))
            )
            return Double.parseDouble(s)
        )
        m = ratioPat.matcher(s)
        if (m.matches())
        (§
            String numerator = m.group(1)
            if (numerator.startsWith("+"))
            (§
                numerator = numerator.substring(1)
            )

            return Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))
        )
        return null
    )

    static private IFn getMacro(int ch)
    (§
        if (ch < macros.length)
        (§
            return macros[ch]
        )
        return null
    )

    static private boolean isMacro(int ch)
    (§
        return (ch < macros.length && macros[ch] != null)
    )

    static private boolean isTerminatingMacro(int ch)
    (§
        return (ch != (§ char \#) && ch != (§ char \') && isMacro(ch))
    )

    public static class StringReader extends AFn
    (§
        public Object invoke(Object reader, Object doublequote, Object opts)
        (§
            StringBuilder sb = new StringBuilder()
            Reader r = (Reader) reader

            for (int ch = read1(r) ch != (§ char \") ch = read1(r)) ;; oops! "
            (§
                if (ch == -1)
                (§
                    throw Util.runtimeException("EOF while reading string")
                )
                if (ch == (§ char \\)) ;; escape
                (§
                    ch = read1(r)
                    if (ch == -1)
                    (§
                        throw Util.runtimeException("EOF while reading string")
                    )
                    switch (ch)
                    (§
                        (§ case (§ char \t))
                            ch = (§ char "\t")
                            break
                        (§ case (§ char \r))
                            ch = (§ char "\r")
                            break
                        (§ case (§ char \n))
                            ch = (§ char "\n")
                            break
                        (§ case (§ char \\))
                            break
                        (§ case (§ char \")) ;; oops! "
                            break
                        (§ case (§ char \b))
                            ch = (§ char "\b")
                            break
                        (§ case (§ char \f))
                            ch = (§ char "\f")
                            break
                        (§ case (§ char \u))
                        (§
                            ch = read1(r)
                            if (Character.digit(ch, 16) == -1)
                            (§
                                throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)
                            )
                            ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true)
                            break
                        )
                        (§ default)
                        (§
                            if (Character.isDigit(ch))
                            (§
                                ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false)
                                if (ch > 0377)
                                (§
                                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                                )
                            )
                            else
                            (§
                                throw Util.runtimeException("Unsupported escape character: \\" + (char) ch)
                            )
                            break
                        )
                    )
                )
                sb.append((char) ch)
            )
            return sb.toString()
        )
    )

    public static class CommentReader extends AFn
    (§
        public Object invoke(Object reader, Object semicolon, Object opts)
        (§
            Reader r = (Reader) reader
            int ch
            do
            (§
                ch = read1(r)
            ) while (ch != -1 && ch != (§ char "\n") && ch != (§ char "\r"))
            return r
        )
    )

    public static class DiscardReader extends AFn
    (§
        public Object invoke(Object reader, Object underscore, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            read(r, true, null, true, opts)
            return r
        )
    )

    public static class NamespaceMapReader extends AFn
    (§
        public Object invoke(Object reader, Object colon, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader

            ;; Read ns symbol
            Object sym = read(r, true, null, false, opts)
            if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != null)
            (§
                throw new RuntimeException("Namespaced map must specify a valid namespace: " + sym)
            )
            String ns = ((Symbol)sym).getName()

            ;; Read map
            int nextChar = read1(r)
            while (isWhitespace(nextChar))
                nextChar = read1(r)
            if ((§ char \{) != nextChar)
            (§
                throw new RuntimeException("Namespaced map must specify a map")
            )
            List kvs = readDelimitedList((§ char \}), r, true, opts)
            if ((kvs.size() & 1) == 1)
            (§
                throw Util.runtimeException("Namespaced map literal must contain an even number of forms")
            )

            ;; Construct output map
            Object[] a = new Object[kvs.size()]
            Iterator iter = kvs.iterator()
            for (int i = 0 iter.hasNext() i += 2)
            (§
                Object key = iter.next()
                Object val = iter.next()

                if (key instanceof Keyword)
                (§
                    Keyword kw = (Keyword) key
                    if (kw.getNamespace() == null)
                    (§
                        key = Keyword.intern(ns, kw.getName())
                    )
                    else if (kw.getNamespace().equals("_"))
                    (§
                        key = Keyword.intern(null, kw.getName())
                    )
                )
                else if (key instanceof Symbol)
                (§
                    Symbol s = (Symbol) key
                    if (s.getNamespace() == null)
                    (§
                        key = Symbol.intern(ns, s.getName())
                    )
                    else if (s.getNamespace().equals("_"))
                    (§
                        key = Symbol.intern(null, s.getName())
                    )
                )
                a[i] = key
                a[i + 1] = val
            )
            return RT.map(a)
        )
    )

    public static class DispatchReader extends AFn
    (§
        public Object invoke(Object reader, Object hash, Object opts)
        (§
            int ch = read1((Reader) reader)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            IFn fn = dispatchMacros[ch]

            if (fn == null)
            (§
                ;; try tagged reader
                if (Character.isLetter(ch))
                (§
                    unread((PushbackReader) reader, ch)
                    return taggedReader.invoke(reader, ch, opts)
                )

                throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))
            )
            return fn.invoke(reader, ch, opts)
        )
    )

    public static class MetaReader extends AFn
    (§
        public Object invoke(Object reader, Object caret, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            Object meta = read(r, true, null, true, opts)
            if (meta instanceof Symbol || meta instanceof String)
            (§
                meta = RT.map(RT.TAG_KEY, meta)
            )
            else if (meta instanceof Keyword)
            (§
                meta = RT.map(meta, RT.T)
            )
            else if (!(meta instanceof IPersistentMap))
            (§
                throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")
            )

            Object o = read(r, true, null, true, opts)
            if (o instanceof IMeta)
            (§
                if (line != -1 && o instanceof ISeq)
                (§
                    meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column)
                )
                if (o instanceof IReference)
                (§
                    ((IReference)o).resetMeta((IPersistentMap) meta)
                    return o
                )
                Object ometa = RT.meta(o)
                for (ISeq s = RT.seq(meta) s != null s = s.next())
                (§
                    IMapEntry kv = (IMapEntry) s.first()
                    ometa = RT.assoc(ometa, kv.getKey(), kv.getValue())
                )
                return ((IObj) o).withMeta((IPersistentMap) ometa)
            )
            else
            (§
                throw new IllegalArgumentException("Metadata can only be applied to IMetas")
            )
        )
    )

    public static class CharacterReader extends AFn
    (§
        public Object invoke(Object reader, Object backslash, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            String token = readToken(r, (char) ch, false)
            if (token.length() == 1)
            (§
                return Character.valueOf(token.charAt(0))
            )
            else if (token.equals("newline"))
            (§
                return (§ char "\n")
            )
            else if (token.equals("space"))
            (§
                return (§ char \space)
            )
            else if (token.equals("tab"))
            (§
                return (§ char "\t")
            )
            else if (token.equals("backspace"))
            (§
                return (§ char "\b")
            )
            else if (token.equals("formfeed"))
            (§
                return (§ char "\f")
            )
            else if (token.equals("return"))
            (§
                return (§ char "\r")
            )
            else if (token.startsWith("u"))
            (§
                char c = (char) readUnicodeChar(token, 1, 4, 16)
                if (c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                (§
                    throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))
                )
                return c
            )
            else if (token.startsWith("o"))
            (§
                int len = token.length() - 1
                if (len > 3)
                (§
                    throw Util.runtimeException("Invalid octal escape sequence length: " + len)
                )
                int uc = readUnicodeChar(token, 1, len, 8)
                if (uc > 0377)
                (§
                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                )
                return (char) uc
            )
            throw Util.runtimeException("Unsupported character: \\" + token)
        )
    )

    public static class ListReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            List list = readDelimitedList((§ char \)), r, true, opts)
            if (list.isEmpty())
            (§
                return PersistentList.EMPTY
            )
            IObj s = (IObj) PersistentList.create(list)
            return s
        )
    )

    public static class VectorReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            return LazilyPersistentVector.create(readDelimitedList((§ char \]), r, true, opts))
        )
    )

    public static class MapReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            Object[] a = readDelimitedList((§ char \}), r, true, opts).toArray()
            if ((a.length & 1) == 1)
            (§
                throw Util.runtimeException("Map literal must contain an even number of forms")
            )
            return RT.map(a)
        )
    )

    public static class SetReader extends AFn
    (§
        public Object invoke(Object reader, Object leftbracket, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            return PersistentHashSet.createWithCheck(readDelimitedList((§ char \}), r, true, opts))
        )
    )

    public static class UnmatchedDelimiterReader extends AFn
    (§
        public Object invoke(Object reader, Object rightdelim, Object opts)
        (§
            throw Util.runtimeException("Unmatched delimiter: " + rightdelim)
        )
    )

    public static class UnreadableReader extends AFn
    (§
        public Object invoke(Object reader, Object leftangle, Object opts)
        (§
            throw Util.runtimeException("Unreadable form")
        )
    )

    public static class SymbolicValueReader extends AFn
    (§
        static IPersistentMap specials = PersistentHashMap.create(
            Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
            Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
            Symbol.intern("NaN"), Double.NaN
        )

        public Object invoke(Object reader, Object quote, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, null, true, opts)

            if (!(o instanceof Symbol))
            (§
                throw Util.runtimeException("Invalid token: ##" + o)
            )
            if (!(specials.containsKey(o)))
            (§
                throw Util.runtimeException("Unknown symbolic value: ##" + o)
            )

            return specials.valAt(o)
        )
    )

    public static List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts)
    (§
        final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1

        ArrayList a = new ArrayList()

        while (true)
        (§
            int ch = read1(r)

            while (isWhitespace(ch))
                ch = read1(r)

            if (ch == -1)
            (§
                if (firstline < 0)
                (§
                    throw Util.runtimeException("EOF while reading")
                )
                else
                (§
                    throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                )
            )

            if (ch == delim)
            (§
                break
            )

            IFn macroFn = getMacro(ch)
            if (macroFn != null)
            (§
                Object mret = macroFn.invoke(r, (char) ch, opts)
                ;; no op macros return the reader
                if (mret != r)
                (§
                    a.add(mret)
                )
            )
            else
            (§
                unread(r, ch)

                Object o = read(r, true, null, isRecursive, opts)
                if (o != r)
                (§
                    a.add(o)
                )
            )
        )

        return a
    )

    public static class TaggedReader extends AFn
    (§
        public Object invoke(Object reader, Object firstChar, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            Object name = read(r, true, null, false, opts)
            if (!(name instanceof Symbol))
            (§
                throw new RuntimeException("Reader tag must be a symbol")
            )
            Symbol sym = (Symbol)name
            return readTagged(r, sym, (IPersistentMap) opts)
        )

        static Keyword READERS = Keyword.intern(null, "readers")
        static Keyword DEFAULT = Keyword.intern(null, "default")

        private Object readTagged(PushbackReader reader, Symbol tag, IPersistentMap opts)
        (§
            Object o = read(reader, true, null, true, opts)

            ILookup readers = (ILookup)RT.get(opts, READERS)
            IFn dataReader = (IFn)RT.get(readers, tag)
            if (dataReader == null)
            (§
                dataReader = (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag)
            )
            if (dataReader == null)
            (§
                IFn defaultReader = (IFn)RT.get(opts, DEFAULT)
                if (defaultReader != null)
                (§
                    return defaultReader.invoke(tag, o)
                )
                else
                (§
                    throw new RuntimeException("No reader function for tag " + tag.toString())
                )
            )
            else
            (§
                return dataReader.invoke(o)
            )
        )
    )
)
)

(§ java cloiure.lang.EnumerationSeq

import java.io.IOException
import java.io.NotSerializableException
import java.util.Enumeration

public class EnumerationSeq extends ASeq
(§
    final Enumeration iter
    final State state

    static class State
    (§
        volatile Object val
        volatile Object _rest
    )

    public static EnumerationSeq create(Enumeration iter)
    (§
        if (iter.hasMoreElements())
        (§
            return new EnumerationSeq(iter)
        )
        return null
    )

    EnumerationSeq(Enumeration iter)
    (§
        this.iter = iter
        state = new State()
        this.state.val = state
        this.state._rest = state
    )

    EnumerationSeq(IPersistentMap meta, Enumeration iter, State state)
    (§
        super(meta)
        this.iter = iter
        this.state = state
    )

    public Object first()
    (§
        if (state.val == state)
        (§
            synchronized (state)
            (§
                if (state.val == state)
                (§
                    state.val = iter.nextElement()
                )
            )
        )
        return state.val
    )

    public ISeq next()
    (§
        if (state._rest == state)
        (§
            synchronized (state)
            (§
                if (state._rest == state)
                (§
                    first()
                    state._rest = create(iter)
                )
            )
        )
        return (ISeq) state._rest
    )

    public EnumerationSeq withMeta(IPersistentMap meta)
    (§
        return new EnumerationSeq(meta, iter, state)
    )

    private void writeObject (java.io.ObjectOutputStream out) throws IOException
    (§
        throw new NotSerializableException(getClass().getName())
    )
)
)

(§ java cloiure.lang.ExceptionInfo

;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;
public class ExceptionInfo extends RuntimeException implements IExceptionInfo
(§
    public final IPersistentMap data

    public ExceptionInfo(String s, IPersistentMap data)
    (§
        this(s, data, null)
    )

    public ExceptionInfo(String s, IPersistentMap data, Throwable throwable)
    (§
        ;; null cause is equivalent to not passing a cause
        super(s, throwable)
        if (data != null)
        (§
            this.data = data
        )
        else
        (§
            throw new IllegalArgumentException("Additional data must be non-nil.")
        )
    )

    public IPersistentMap getData()
    (§
        return data
    )

    public String toString()
    (§
        return "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString()
    )
)
)

(§ java cloiure.lang.Fn

public interface Fn
(§
)
)

(§ java cloiure.lang.FnLoaderThunk

public class FnLoaderThunk extends RestFn
(§
    final Var v
    final ClassLoader loader
    final String fnClassName
    IFn fn

    public FnLoaderThunk(Var v, String fnClassName)
    (§
        this.v = v
        this.loader = (ClassLoader) RT.FN_LOADER_VAR.get()
        this.fnClassName = fnClassName
        fn = null
    )

    public Object invoke(Object arg1)
    (§
        load()
        return fn.invoke(arg1)
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        load()
        return fn.invoke(arg1, arg2)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        load()
        return fn.invoke(arg1, arg2, arg3)
    )

    protected Object doInvoke(Object args)
    (§
        load()
        return fn.applyTo((ISeq) args)
    )

    private void load()
    (§
        if (fn == null)
        (§
            try
            (§
                fn = (IFn) Class.forName(fnClassName, true, loader).newInstance()
            )
            catch (Exception e)
            (§
                throw Util.sneakyThrow(e)
            )
            v.root = fn
        )
    )

    public int getRequiredArity()
    (§
        return 0
    )

    public IObj withMeta(IPersistentMap meta)
    (§
        return this
    )

    public IPersistentMap meta()
    (§
        return null
    )
)
)

(§ java cloiure.lang.IAtom

public interface IAtom
(§
    Object swap(IFn f)

    Object swap(IFn f, Object arg)

    Object swap(IFn f, Object arg1, Object arg2)

    Object swap(IFn f, Object x, Object y, ISeq args)

    boolean compareAndSet(Object oldv, Object newv)

    Object reset(Object newval)
)
)

(§ java cloiure.lang.IAtom2

public interface IAtom2 extends IAtom
(§
    IPersistentVector swapVals(IFn f)

    IPersistentVector swapVals(IFn f, Object arg)

    IPersistentVector swapVals(IFn f, Object arg1, Object arg2)

    IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)

    IPersistentVector resetVals(Object newv)
)
)

(§ java cloiure.lang.IBlockingDeref

public interface IBlockingDeref
(§
    Object deref(long ms, Object timeoutValue)
)
)

(§ java cloiure.lang.IChunk

public interface IChunk extends Indexed
(§
    IChunk dropFirst()

    Object reduce(IFn f, Object start)
)
)

(§ java cloiure.lang.IChunkedSeq

public interface IChunkedSeq extends ISeq, Sequential
(§
    IChunk chunkedFirst()

    ISeq chunkedNext()

    ISeq chunkedMore()
)
)

(§ java cloiure.lang.IDeref

public interface IDeref
(§
    Object deref()
)
)

(§ java cloiure.lang.IEditableCollection

public interface IEditableCollection
(§
    ITransientCollection asTransient()
)
)

(§ java cloiure.lang.IExceptionInfo

;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;
public interface IExceptionInfo
(§
    public IPersistentMap getData()
)
)

(§ java cloiure.lang.IFn

import java.util.concurrent.Callable

;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;
public interface IFn extends Callable, Runnable
(§
    public Object invoke()

    public Object invoke(Object arg1)

    public Object invoke(Object arg1, Object arg2)

    public Object invoke(Object arg1, Object arg2, Object arg3)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)

    public Object applyTo(ISeq arglist)

    static public interface L (§ long invokePrim() )
    static public interface D (§ double invokePrim() )
    static public interface OL (§ long invokePrim(Object arg0) )
    static public interface OD (§ double invokePrim(Object arg0) )
    static public interface LO (§ Object invokePrim(long arg0) )
    static public interface LL (§ long invokePrim(long arg0) )
    static public interface LD (§ double invokePrim(long arg0) )
    static public interface DO (§ Object invokePrim(double arg0) )
    static public interface DL (§ long invokePrim(double arg0) )
    static public interface DD (§ double invokePrim(double arg0) )
    static public interface OOL (§ long invokePrim(Object arg0, Object arg1) )
    static public interface OOD (§ double invokePrim(Object arg0, Object arg1) )
    static public interface OLO (§ Object invokePrim(Object arg0, long arg1) )
    static public interface OLL (§ long invokePrim(Object arg0, long arg1) )
    static public interface OLD (§ double invokePrim(Object arg0, long arg1) )
    static public interface ODO (§ Object invokePrim(Object arg0, double arg1) )
    static public interface ODL (§ long invokePrim(Object arg0, double arg1) )
    static public interface ODD (§ double invokePrim(Object arg0, double arg1) )
    static public interface LOO (§ Object invokePrim(long arg0, Object arg1) )
    static public interface LOL (§ long invokePrim(long arg0, Object arg1) )
    static public interface LOD (§ double invokePrim(long arg0, Object arg1) )
    static public interface LLO (§ Object invokePrim(long arg0, long arg1) )
    static public interface LLL (§ long invokePrim(long arg0, long arg1) )
    static public interface LLD (§ double invokePrim(long arg0, long arg1) )
    static public interface LDO (§ Object invokePrim(long arg0, double arg1) )
    static public interface LDL (§ long invokePrim(long arg0, double arg1) )
    static public interface LDD (§ double invokePrim(long arg0, double arg1) )
    static public interface DOO (§ Object invokePrim(double arg0, Object arg1) )
    static public interface DOL (§ long invokePrim(double arg0, Object arg1) )
    static public interface DOD (§ double invokePrim(double arg0, Object arg1) )
    static public interface DLO (§ Object invokePrim(double arg0, long arg1) )
    static public interface DLL (§ long invokePrim(double arg0, long arg1) )
    static public interface DLD (§ double invokePrim(double arg0, long arg1) )
    static public interface DDO (§ Object invokePrim(double arg0, double arg1) )
    static public interface DDL (§ long invokePrim(double arg0, double arg1) )
    static public interface DDD (§ double invokePrim(double arg0, double arg1) )
    static public interface OOOL (§ long invokePrim(Object arg0, Object arg1, Object arg2) )
    static public interface OOOD (§ double invokePrim(Object arg0, Object arg1, Object arg2) )
    static public interface OOLO (§ Object invokePrim(Object arg0, Object arg1, long arg2) )
    static public interface OOLL (§ long invokePrim(Object arg0, Object arg1, long arg2) )
    static public interface OOLD (§ double invokePrim(Object arg0, Object arg1, long arg2) )
    static public interface OODO (§ Object invokePrim(Object arg0, Object arg1, double arg2) )
    static public interface OODL (§ long invokePrim(Object arg0, Object arg1, double arg2) )
    static public interface OODD (§ double invokePrim(Object arg0, Object arg1, double arg2) )
    static public interface OLOO (§ Object invokePrim(Object arg0, long arg1, Object arg2) )
    static public interface OLOL (§ long invokePrim(Object arg0, long arg1, Object arg2) )
    static public interface OLOD (§ double invokePrim(Object arg0, long arg1, Object arg2) )
    static public interface OLLO (§ Object invokePrim(Object arg0, long arg1, long arg2) )
    static public interface OLLL (§ long invokePrim(Object arg0, long arg1, long arg2) )
    static public interface OLLD (§ double invokePrim(Object arg0, long arg1, long arg2) )
    static public interface OLDO (§ Object invokePrim(Object arg0, long arg1, double arg2) )
    static public interface OLDL (§ long invokePrim(Object arg0, long arg1, double arg2) )
    static public interface OLDD (§ double invokePrim(Object arg0, long arg1, double arg2) )
    static public interface ODOO (§ Object invokePrim(Object arg0, double arg1, Object arg2) )
    static public interface ODOL (§ long invokePrim(Object arg0, double arg1, Object arg2) )
    static public interface ODOD (§ double invokePrim(Object arg0, double arg1, Object arg2) )
    static public interface ODLO (§ Object invokePrim(Object arg0, double arg1, long arg2) )
    static public interface ODLL (§ long invokePrim(Object arg0, double arg1, long arg2) )
    static public interface ODLD (§ double invokePrim(Object arg0, double arg1, long arg2) )
    static public interface ODDO (§ Object invokePrim(Object arg0, double arg1, double arg2) )
    static public interface ODDL (§ long invokePrim(Object arg0, double arg1, double arg2) )
    static public interface ODDD (§ double invokePrim(Object arg0, double arg1, double arg2) )
    static public interface LOOO (§ Object invokePrim(long arg0, Object arg1, Object arg2) )
    static public interface LOOL (§ long invokePrim(long arg0, Object arg1, Object arg2) )
    static public interface LOOD (§ double invokePrim(long arg0, Object arg1, Object arg2) )
    static public interface LOLO (§ Object invokePrim(long arg0, Object arg1, long arg2) )
    static public interface LOLL (§ long invokePrim(long arg0, Object arg1, long arg2) )
    static public interface LOLD (§ double invokePrim(long arg0, Object arg1, long arg2) )
    static public interface LODO (§ Object invokePrim(long arg0, Object arg1, double arg2) )
    static public interface LODL (§ long invokePrim(long arg0, Object arg1, double arg2) )
    static public interface LODD (§ double invokePrim(long arg0, Object arg1, double arg2) )
    static public interface LLOO (§ Object invokePrim(long arg0, long arg1, Object arg2) )
    static public interface LLOL (§ long invokePrim(long arg0, long arg1, Object arg2) )
    static public interface LLOD (§ double invokePrim(long arg0, long arg1, Object arg2) )
    static public interface LLLO (§ Object invokePrim(long arg0, long arg1, long arg2) )
    static public interface LLLL (§ long invokePrim(long arg0, long arg1, long arg2) )
    static public interface LLLD (§ double invokePrim(long arg0, long arg1, long arg2) )
    static public interface LLDO (§ Object invokePrim(long arg0, long arg1, double arg2) )
    static public interface LLDL (§ long invokePrim(long arg0, long arg1, double arg2) )
    static public interface LLDD (§ double invokePrim(long arg0, long arg1, double arg2) )
    static public interface LDOO (§ Object invokePrim(long arg0, double arg1, Object arg2) )
    static public interface LDOL (§ long invokePrim(long arg0, double arg1, Object arg2) )
    static public interface LDOD (§ double invokePrim(long arg0, double arg1, Object arg2) )
    static public interface LDLO (§ Object invokePrim(long arg0, double arg1, long arg2) )
    static public interface LDLL (§ long invokePrim(long arg0, double arg1, long arg2) )
    static public interface LDLD (§ double invokePrim(long arg0, double arg1, long arg2) )
    static public interface LDDO (§ Object invokePrim(long arg0, double arg1, double arg2) )
    static public interface LDDL (§ long invokePrim(long arg0, double arg1, double arg2) )
    static public interface LDDD (§ double invokePrim(long arg0, double arg1, double arg2) )
    static public interface DOOO (§ Object invokePrim(double arg0, Object arg1, Object arg2) )
    static public interface DOOL (§ long invokePrim(double arg0, Object arg1, Object arg2) )
    static public interface DOOD (§ double invokePrim(double arg0, Object arg1, Object arg2) )
    static public interface DOLO (§ Object invokePrim(double arg0, Object arg1, long arg2) )
    static public interface DOLL (§ long invokePrim(double arg0, Object arg1, long arg2) )
    static public interface DOLD (§ double invokePrim(double arg0, Object arg1, long arg2) )
    static public interface DODO (§ Object invokePrim(double arg0, Object arg1, double arg2) )
    static public interface DODL (§ long invokePrim(double arg0, Object arg1, double arg2) )
    static public interface DODD (§ double invokePrim(double arg0, Object arg1, double arg2) )
    static public interface DLOO (§ Object invokePrim(double arg0, long arg1, Object arg2) )
    static public interface DLOL (§ long invokePrim(double arg0, long arg1, Object arg2) )
    static public interface DLOD (§ double invokePrim(double arg0, long arg1, Object arg2) )
    static public interface DLLO (§ Object invokePrim(double arg0, long arg1, long arg2) )
    static public interface DLLL (§ long invokePrim(double arg0, long arg1, long arg2) )
    static public interface DLLD (§ double invokePrim(double arg0, long arg1, long arg2) )
    static public interface DLDO (§ Object invokePrim(double arg0, long arg1, double arg2) )
    static public interface DLDL (§ long invokePrim(double arg0, long arg1, double arg2) )
    static public interface DLDD (§ double invokePrim(double arg0, long arg1, double arg2) )
    static public interface DDOO (§ Object invokePrim(double arg0, double arg1, Object arg2) )
    static public interface DDOL (§ long invokePrim(double arg0, double arg1, Object arg2) )
    static public interface DDOD (§ double invokePrim(double arg0, double arg1, Object arg2) )
    static public interface DDLO (§ Object invokePrim(double arg0, double arg1, long arg2) )
    static public interface DDLL (§ long invokePrim(double arg0, double arg1, long arg2) )
    static public interface DDLD (§ double invokePrim(double arg0, double arg1, long arg2) )
    static public interface DDDO (§ Object invokePrim(double arg0, double arg1, double arg2) )
    static public interface DDDL (§ long invokePrim(double arg0, double arg1, double arg2) )
    static public interface DDDD (§ double invokePrim(double arg0, double arg1, double arg2) )
    static public interface OOOOL (§ long invokePrim(Object arg0, Object arg1, Object arg2, Object arg3) )
    static public interface OOOOD (§ double invokePrim(Object arg0, Object arg1, Object arg2, Object arg3) )
    static public interface OOOLO (§ Object invokePrim(Object arg0, Object arg1, Object arg2, long arg3) )
    static public interface OOOLL (§ long invokePrim(Object arg0, Object arg1, Object arg2, long arg3) )
    static public interface OOOLD (§ double invokePrim(Object arg0, Object arg1, Object arg2, long arg3) )
    static public interface OOODO (§ Object invokePrim(Object arg0, Object arg1, Object arg2, double arg3) )
    static public interface OOODL (§ long invokePrim(Object arg0, Object arg1, Object arg2, double arg3) )
    static public interface OOODD (§ double invokePrim(Object arg0, Object arg1, Object arg2, double arg3) )
    static public interface OOLOO (§ Object invokePrim(Object arg0, Object arg1, long arg2, Object arg3) )
    static public interface OOLOL (§ long invokePrim(Object arg0, Object arg1, long arg2, Object arg3) )
    static public interface OOLOD (§ double invokePrim(Object arg0, Object arg1, long arg2, Object arg3) )
    static public interface OOLLO (§ Object invokePrim(Object arg0, Object arg1, long arg2, long arg3) )
    static public interface OOLLL (§ long invokePrim(Object arg0, Object arg1, long arg2, long arg3) )
    static public interface OOLLD (§ double invokePrim(Object arg0, Object arg1, long arg2, long arg3) )
    static public interface OOLDO (§ Object invokePrim(Object arg0, Object arg1, long arg2, double arg3) )
    static public interface OOLDL (§ long invokePrim(Object arg0, Object arg1, long arg2, double arg3) )
    static public interface OOLDD (§ double invokePrim(Object arg0, Object arg1, long arg2, double arg3) )
    static public interface OODOO (§ Object invokePrim(Object arg0, Object arg1, double arg2, Object arg3) )
    static public interface OODOL (§ long invokePrim(Object arg0, Object arg1, double arg2, Object arg3) )
    static public interface OODOD (§ double invokePrim(Object arg0, Object arg1, double arg2, Object arg3) )
    static public interface OODLO (§ Object invokePrim(Object arg0, Object arg1, double arg2, long arg3) )
    static public interface OODLL (§ long invokePrim(Object arg0, Object arg1, double arg2, long arg3) )
    static public interface OODLD (§ double invokePrim(Object arg0, Object arg1, double arg2, long arg3) )
    static public interface OODDO (§ Object invokePrim(Object arg0, Object arg1, double arg2, double arg3) )
    static public interface OODDL (§ long invokePrim(Object arg0, Object arg1, double arg2, double arg3) )
    static public interface OODDD (§ double invokePrim(Object arg0, Object arg1, double arg2, double arg3) )
    static public interface OLOOO (§ Object invokePrim(Object arg0, long arg1, Object arg2, Object arg3) )
    static public interface OLOOL (§ long invokePrim(Object arg0, long arg1, Object arg2, Object arg3) )
    static public interface OLOOD (§ double invokePrim(Object arg0, long arg1, Object arg2, Object arg3) )
    static public interface OLOLO (§ Object invokePrim(Object arg0, long arg1, Object arg2, long arg3) )
    static public interface OLOLL (§ long invokePrim(Object arg0, long arg1, Object arg2, long arg3) )
    static public interface OLOLD (§ double invokePrim(Object arg0, long arg1, Object arg2, long arg3) )
    static public interface OLODO (§ Object invokePrim(Object arg0, long arg1, Object arg2, double arg3) )
    static public interface OLODL (§ long invokePrim(Object arg0, long arg1, Object arg2, double arg3) )
    static public interface OLODD (§ double invokePrim(Object arg0, long arg1, Object arg2, double arg3) )
    static public interface OLLOO (§ Object invokePrim(Object arg0, long arg1, long arg2, Object arg3) )
    static public interface OLLOL (§ long invokePrim(Object arg0, long arg1, long arg2, Object arg3) )
    static public interface OLLOD (§ double invokePrim(Object arg0, long arg1, long arg2, Object arg3) )
    static public interface OLLLO (§ Object invokePrim(Object arg0, long arg1, long arg2, long arg3) )
    static public interface OLLLL (§ long invokePrim(Object arg0, long arg1, long arg2, long arg3) )
    static public interface OLLLD (§ double invokePrim(Object arg0, long arg1, long arg2, long arg3) )
    static public interface OLLDO (§ Object invokePrim(Object arg0, long arg1, long arg2, double arg3) )
    static public interface OLLDL (§ long invokePrim(Object arg0, long arg1, long arg2, double arg3) )
    static public interface OLLDD (§ double invokePrim(Object arg0, long arg1, long arg2, double arg3) )
    static public interface OLDOO (§ Object invokePrim(Object arg0, long arg1, double arg2, Object arg3) )
    static public interface OLDOL (§ long invokePrim(Object arg0, long arg1, double arg2, Object arg3) )
    static public interface OLDOD (§ double invokePrim(Object arg0, long arg1, double arg2, Object arg3) )
    static public interface OLDLO (§ Object invokePrim(Object arg0, long arg1, double arg2, long arg3) )
    static public interface OLDLL (§ long invokePrim(Object arg0, long arg1, double arg2, long arg3) )
    static public interface OLDLD (§ double invokePrim(Object arg0, long arg1, double arg2, long arg3) )
    static public interface OLDDO (§ Object invokePrim(Object arg0, long arg1, double arg2, double arg3) )
    static public interface OLDDL (§ long invokePrim(Object arg0, long arg1, double arg2, double arg3) )
    static public interface OLDDD (§ double invokePrim(Object arg0, long arg1, double arg2, double arg3) )
    static public interface ODOOO (§ Object invokePrim(Object arg0, double arg1, Object arg2, Object arg3) )
    static public interface ODOOL (§ long invokePrim(Object arg0, double arg1, Object arg2, Object arg3) )
    static public interface ODOOD (§ double invokePrim(Object arg0, double arg1, Object arg2, Object arg3) )
    static public interface ODOLO (§ Object invokePrim(Object arg0, double arg1, Object arg2, long arg3) )
    static public interface ODOLL (§ long invokePrim(Object arg0, double arg1, Object arg2, long arg3) )
    static public interface ODOLD (§ double invokePrim(Object arg0, double arg1, Object arg2, long arg3) )
    static public interface ODODO (§ Object invokePrim(Object arg0, double arg1, Object arg2, double arg3) )
    static public interface ODODL (§ long invokePrim(Object arg0, double arg1, Object arg2, double arg3) )
    static public interface ODODD (§ double invokePrim(Object arg0, double arg1, Object arg2, double arg3) )
    static public interface ODLOO (§ Object invokePrim(Object arg0, double arg1, long arg2, Object arg3) )
    static public interface ODLOL (§ long invokePrim(Object arg0, double arg1, long arg2, Object arg3) )
    static public interface ODLOD (§ double invokePrim(Object arg0, double arg1, long arg2, Object arg3) )
    static public interface ODLLO (§ Object invokePrim(Object arg0, double arg1, long arg2, long arg3) )
    static public interface ODLLL (§ long invokePrim(Object arg0, double arg1, long arg2, long arg3) )
    static public interface ODLLD (§ double invokePrim(Object arg0, double arg1, long arg2, long arg3) )
    static public interface ODLDO (§ Object invokePrim(Object arg0, double arg1, long arg2, double arg3) )
    static public interface ODLDL (§ long invokePrim(Object arg0, double arg1, long arg2, double arg3) )
    static public interface ODLDD (§ double invokePrim(Object arg0, double arg1, long arg2, double arg3) )
    static public interface ODDOO (§ Object invokePrim(Object arg0, double arg1, double arg2, Object arg3) )
    static public interface ODDOL (§ long invokePrim(Object arg0, double arg1, double arg2, Object arg3) )
    static public interface ODDOD (§ double invokePrim(Object arg0, double arg1, double arg2, Object arg3) )
    static public interface ODDLO (§ Object invokePrim(Object arg0, double arg1, double arg2, long arg3) )
    static public interface ODDLL (§ long invokePrim(Object arg0, double arg1, double arg2, long arg3) )
    static public interface ODDLD (§ double invokePrim(Object arg0, double arg1, double arg2, long arg3) )
    static public interface ODDDO (§ Object invokePrim(Object arg0, double arg1, double arg2, double arg3) )
    static public interface ODDDL (§ long invokePrim(Object arg0, double arg1, double arg2, double arg3) )
    static public interface ODDDD (§ double invokePrim(Object arg0, double arg1, double arg2, double arg3) )
    static public interface LOOOO (§ Object invokePrim(long arg0, Object arg1, Object arg2, Object arg3) )
    static public interface LOOOL (§ long invokePrim(long arg0, Object arg1, Object arg2, Object arg3) )
    static public interface LOOOD (§ double invokePrim(long arg0, Object arg1, Object arg2, Object arg3) )
    static public interface LOOLO (§ Object invokePrim(long arg0, Object arg1, Object arg2, long arg3) )
    static public interface LOOLL (§ long invokePrim(long arg0, Object arg1, Object arg2, long arg3) )
    static public interface LOOLD (§ double invokePrim(long arg0, Object arg1, Object arg2, long arg3) )
    static public interface LOODO (§ Object invokePrim(long arg0, Object arg1, Object arg2, double arg3) )
    static public interface LOODL (§ long invokePrim(long arg0, Object arg1, Object arg2, double arg3) )
    static public interface LOODD (§ double invokePrim(long arg0, Object arg1, Object arg2, double arg3) )
    static public interface LOLOO (§ Object invokePrim(long arg0, Object arg1, long arg2, Object arg3) )
    static public interface LOLOL (§ long invokePrim(long arg0, Object arg1, long arg2, Object arg3) )
    static public interface LOLOD (§ double invokePrim(long arg0, Object arg1, long arg2, Object arg3) )
    static public interface LOLLO (§ Object invokePrim(long arg0, Object arg1, long arg2, long arg3) )
    static public interface LOLLL (§ long invokePrim(long arg0, Object arg1, long arg2, long arg3) )
    static public interface LOLLD (§ double invokePrim(long arg0, Object arg1, long arg2, long arg3) )
    static public interface LOLDO (§ Object invokePrim(long arg0, Object arg1, long arg2, double arg3) )
    static public interface LOLDL (§ long invokePrim(long arg0, Object arg1, long arg2, double arg3) )
    static public interface LOLDD (§ double invokePrim(long arg0, Object arg1, long arg2, double arg3) )
    static public interface LODOO (§ Object invokePrim(long arg0, Object arg1, double arg2, Object arg3) )
    static public interface LODOL (§ long invokePrim(long arg0, Object arg1, double arg2, Object arg3) )
    static public interface LODOD (§ double invokePrim(long arg0, Object arg1, double arg2, Object arg3) )
    static public interface LODLO (§ Object invokePrim(long arg0, Object arg1, double arg2, long arg3) )
    static public interface LODLL (§ long invokePrim(long arg0, Object arg1, double arg2, long arg3) )
    static public interface LODLD (§ double invokePrim(long arg0, Object arg1, double arg2, long arg3) )
    static public interface LODDO (§ Object invokePrim(long arg0, Object arg1, double arg2, double arg3) )
    static public interface LODDL (§ long invokePrim(long arg0, Object arg1, double arg2, double arg3) )
    static public interface LODDD (§ double invokePrim(long arg0, Object arg1, double arg2, double arg3) )
    static public interface LLOOO (§ Object invokePrim(long arg0, long arg1, Object arg2, Object arg3) )
    static public interface LLOOL (§ long invokePrim(long arg0, long arg1, Object arg2, Object arg3) )
    static public interface LLOOD (§ double invokePrim(long arg0, long arg1, Object arg2, Object arg3) )
    static public interface LLOLO (§ Object invokePrim(long arg0, long arg1, Object arg2, long arg3) )
    static public interface LLOLL (§ long invokePrim(long arg0, long arg1, Object arg2, long arg3) )
    static public interface LLOLD (§ double invokePrim(long arg0, long arg1, Object arg2, long arg3) )
    static public interface LLODO (§ Object invokePrim(long arg0, long arg1, Object arg2, double arg3) )
    static public interface LLODL (§ long invokePrim(long arg0, long arg1, Object arg2, double arg3) )
    static public interface LLODD (§ double invokePrim(long arg0, long arg1, Object arg2, double arg3) )
    static public interface LLLOO (§ Object invokePrim(long arg0, long arg1, long arg2, Object arg3) )
    static public interface LLLOL (§ long invokePrim(long arg0, long arg1, long arg2, Object arg3) )
    static public interface LLLOD (§ double invokePrim(long arg0, long arg1, long arg2, Object arg3) )
    static public interface LLLLO (§ Object invokePrim(long arg0, long arg1, long arg2, long arg3) )
    static public interface LLLLL (§ long invokePrim(long arg0, long arg1, long arg2, long arg3) )
    static public interface LLLLD (§ double invokePrim(long arg0, long arg1, long arg2, long arg3) )
    static public interface LLLDO (§ Object invokePrim(long arg0, long arg1, long arg2, double arg3) )
    static public interface LLLDL (§ long invokePrim(long arg0, long arg1, long arg2, double arg3) )
    static public interface LLLDD (§ double invokePrim(long arg0, long arg1, long arg2, double arg3) )
    static public interface LLDOO (§ Object invokePrim(long arg0, long arg1, double arg2, Object arg3) )
    static public interface LLDOL (§ long invokePrim(long arg0, long arg1, double arg2, Object arg3) )
    static public interface LLDOD (§ double invokePrim(long arg0, long arg1, double arg2, Object arg3) )
    static public interface LLDLO (§ Object invokePrim(long arg0, long arg1, double arg2, long arg3) )
    static public interface LLDLL (§ long invokePrim(long arg0, long arg1, double arg2, long arg3) )
    static public interface LLDLD (§ double invokePrim(long arg0, long arg1, double arg2, long arg3) )
    static public interface LLDDO (§ Object invokePrim(long arg0, long arg1, double arg2, double arg3) )
    static public interface LLDDL (§ long invokePrim(long arg0, long arg1, double arg2, double arg3) )
    static public interface LLDDD (§ double invokePrim(long arg0, long arg1, double arg2, double arg3) )
    static public interface LDOOO (§ Object invokePrim(long arg0, double arg1, Object arg2, Object arg3) )
    static public interface LDOOL (§ long invokePrim(long arg0, double arg1, Object arg2, Object arg3) )
    static public interface LDOOD (§ double invokePrim(long arg0, double arg1, Object arg2, Object arg3) )
    static public interface LDOLO (§ Object invokePrim(long arg0, double arg1, Object arg2, long arg3) )
    static public interface LDOLL (§ long invokePrim(long arg0, double arg1, Object arg2, long arg3) )
    static public interface LDOLD (§ double invokePrim(long arg0, double arg1, Object arg2, long arg3) )
    static public interface LDODO (§ Object invokePrim(long arg0, double arg1, Object arg2, double arg3) )
    static public interface LDODL (§ long invokePrim(long arg0, double arg1, Object arg2, double arg3) )
    static public interface LDODD (§ double invokePrim(long arg0, double arg1, Object arg2, double arg3) )
    static public interface LDLOO (§ Object invokePrim(long arg0, double arg1, long arg2, Object arg3) )
    static public interface LDLOL (§ long invokePrim(long arg0, double arg1, long arg2, Object arg3) )
    static public interface LDLOD (§ double invokePrim(long arg0, double arg1, long arg2, Object arg3) )
    static public interface LDLLO (§ Object invokePrim(long arg0, double arg1, long arg2, long arg3) )
    static public interface LDLLL (§ long invokePrim(long arg0, double arg1, long arg2, long arg3) )
    static public interface LDLLD (§ double invokePrim(long arg0, double arg1, long arg2, long arg3) )
    static public interface LDLDO (§ Object invokePrim(long arg0, double arg1, long arg2, double arg3) )
    static public interface LDLDL (§ long invokePrim(long arg0, double arg1, long arg2, double arg3) )
    static public interface LDLDD (§ double invokePrim(long arg0, double arg1, long arg2, double arg3) )
    static public interface LDDOO (§ Object invokePrim(long arg0, double arg1, double arg2, Object arg3) )
    static public interface LDDOL (§ long invokePrim(long arg0, double arg1, double arg2, Object arg3) )
    static public interface LDDOD (§ double invokePrim(long arg0, double arg1, double arg2, Object arg3) )
    static public interface LDDLO (§ Object invokePrim(long arg0, double arg1, double arg2, long arg3) )
    static public interface LDDLL (§ long invokePrim(long arg0, double arg1, double arg2, long arg3) )
    static public interface LDDLD (§ double invokePrim(long arg0, double arg1, double arg2, long arg3) )
    static public interface LDDDO (§ Object invokePrim(long arg0, double arg1, double arg2, double arg3) )
    static public interface LDDDL (§ long invokePrim(long arg0, double arg1, double arg2, double arg3) )
    static public interface LDDDD (§ double invokePrim(long arg0, double arg1, double arg2, double arg3) )
    static public interface DOOOO (§ Object invokePrim(double arg0, Object arg1, Object arg2, Object arg3) )
    static public interface DOOOL (§ long invokePrim(double arg0, Object arg1, Object arg2, Object arg3) )
    static public interface DOOOD (§ double invokePrim(double arg0, Object arg1, Object arg2, Object arg3) )
    static public interface DOOLO (§ Object invokePrim(double arg0, Object arg1, Object arg2, long arg3) )
    static public interface DOOLL (§ long invokePrim(double arg0, Object arg1, Object arg2, long arg3) )
    static public interface DOOLD (§ double invokePrim(double arg0, Object arg1, Object arg2, long arg3) )
    static public interface DOODO (§ Object invokePrim(double arg0, Object arg1, Object arg2, double arg3) )
    static public interface DOODL (§ long invokePrim(double arg0, Object arg1, Object arg2, double arg3) )
    static public interface DOODD (§ double invokePrim(double arg0, Object arg1, Object arg2, double arg3) )
    static public interface DOLOO (§ Object invokePrim(double arg0, Object arg1, long arg2, Object arg3) )
    static public interface DOLOL (§ long invokePrim(double arg0, Object arg1, long arg2, Object arg3) )
    static public interface DOLOD (§ double invokePrim(double arg0, Object arg1, long arg2, Object arg3) )
    static public interface DOLLO (§ Object invokePrim(double arg0, Object arg1, long arg2, long arg3) )
    static public interface DOLLL (§ long invokePrim(double arg0, Object arg1, long arg2, long arg3) )
    static public interface DOLLD (§ double invokePrim(double arg0, Object arg1, long arg2, long arg3) )
    static public interface DOLDO (§ Object invokePrim(double arg0, Object arg1, long arg2, double arg3) )
    static public interface DOLDL (§ long invokePrim(double arg0, Object arg1, long arg2, double arg3) )
    static public interface DOLDD (§ double invokePrim(double arg0, Object arg1, long arg2, double arg3) )
    static public interface DODOO (§ Object invokePrim(double arg0, Object arg1, double arg2, Object arg3) )
    static public interface DODOL (§ long invokePrim(double arg0, Object arg1, double arg2, Object arg3) )
    static public interface DODOD (§ double invokePrim(double arg0, Object arg1, double arg2, Object arg3) )
    static public interface DODLO (§ Object invokePrim(double arg0, Object arg1, double arg2, long arg3) )
    static public interface DODLL (§ long invokePrim(double arg0, Object arg1, double arg2, long arg3) )
    static public interface DODLD (§ double invokePrim(double arg0, Object arg1, double arg2, long arg3) )
    static public interface DODDO (§ Object invokePrim(double arg0, Object arg1, double arg2, double arg3) )
    static public interface DODDL (§ long invokePrim(double arg0, Object arg1, double arg2, double arg3) )
    static public interface DODDD (§ double invokePrim(double arg0, Object arg1, double arg2, double arg3) )
    static public interface DLOOO (§ Object invokePrim(double arg0, long arg1, Object arg2, Object arg3) )
    static public interface DLOOL (§ long invokePrim(double arg0, long arg1, Object arg2, Object arg3) )
    static public interface DLOOD (§ double invokePrim(double arg0, long arg1, Object arg2, Object arg3) )
    static public interface DLOLO (§ Object invokePrim(double arg0, long arg1, Object arg2, long arg3) )
    static public interface DLOLL (§ long invokePrim(double arg0, long arg1, Object arg2, long arg3) )
    static public interface DLOLD (§ double invokePrim(double arg0, long arg1, Object arg2, long arg3) )
    static public interface DLODO (§ Object invokePrim(double arg0, long arg1, Object arg2, double arg3) )
    static public interface DLODL (§ long invokePrim(double arg0, long arg1, Object arg2, double arg3) )
    static public interface DLODD (§ double invokePrim(double arg0, long arg1, Object arg2, double arg3) )
    static public interface DLLOO (§ Object invokePrim(double arg0, long arg1, long arg2, Object arg3) )
    static public interface DLLOL (§ long invokePrim(double arg0, long arg1, long arg2, Object arg3) )
    static public interface DLLOD (§ double invokePrim(double arg0, long arg1, long arg2, Object arg3) )
    static public interface DLLLO (§ Object invokePrim(double arg0, long arg1, long arg2, long arg3) )
    static public interface DLLLL (§ long invokePrim(double arg0, long arg1, long arg2, long arg3) )
    static public interface DLLLD (§ double invokePrim(double arg0, long arg1, long arg2, long arg3) )
    static public interface DLLDO (§ Object invokePrim(double arg0, long arg1, long arg2, double arg3) )
    static public interface DLLDL (§ long invokePrim(double arg0, long arg1, long arg2, double arg3) )
    static public interface DLLDD (§ double invokePrim(double arg0, long arg1, long arg2, double arg3) )
    static public interface DLDOO (§ Object invokePrim(double arg0, long arg1, double arg2, Object arg3) )
    static public interface DLDOL (§ long invokePrim(double arg0, long arg1, double arg2, Object arg3) )
    static public interface DLDOD (§ double invokePrim(double arg0, long arg1, double arg2, Object arg3) )
    static public interface DLDLO (§ Object invokePrim(double arg0, long arg1, double arg2, long arg3) )
    static public interface DLDLL (§ long invokePrim(double arg0, long arg1, double arg2, long arg3) )
    static public interface DLDLD (§ double invokePrim(double arg0, long arg1, double arg2, long arg3) )
    static public interface DLDDO (§ Object invokePrim(double arg0, long arg1, double arg2, double arg3) )
    static public interface DLDDL (§ long invokePrim(double arg0, long arg1, double arg2, double arg3) )
    static public interface DLDDD (§ double invokePrim(double arg0, long arg1, double arg2, double arg3) )
    static public interface DDOOO (§ Object invokePrim(double arg0, double arg1, Object arg2, Object arg3) )
    static public interface DDOOL (§ long invokePrim(double arg0, double arg1, Object arg2, Object arg3) )
    static public interface DDOOD (§ double invokePrim(double arg0, double arg1, Object arg2, Object arg3) )
    static public interface DDOLO (§ Object invokePrim(double arg0, double arg1, Object arg2, long arg3) )
    static public interface DDOLL (§ long invokePrim(double arg0, double arg1, Object arg2, long arg3) )
    static public interface DDOLD (§ double invokePrim(double arg0, double arg1, Object arg2, long arg3) )
    static public interface DDODO (§ Object invokePrim(double arg0, double arg1, Object arg2, double arg3) )
    static public interface DDODL (§ long invokePrim(double arg0, double arg1, Object arg2, double arg3) )
    static public interface DDODD (§ double invokePrim(double arg0, double arg1, Object arg2, double arg3) )
    static public interface DDLOO (§ Object invokePrim(double arg0, double arg1, long arg2, Object arg3) )
    static public interface DDLOL (§ long invokePrim(double arg0, double arg1, long arg2, Object arg3) )
    static public interface DDLOD (§ double invokePrim(double arg0, double arg1, long arg2, Object arg3) )
    static public interface DDLLO (§ Object invokePrim(double arg0, double arg1, long arg2, long arg3) )
    static public interface DDLLL (§ long invokePrim(double arg0, double arg1, long arg2, long arg3) )
    static public interface DDLLD (§ double invokePrim(double arg0, double arg1, long arg2, long arg3) )
    static public interface DDLDO (§ Object invokePrim(double arg0, double arg1, long arg2, double arg3) )
    static public interface DDLDL (§ long invokePrim(double arg0, double arg1, long arg2, double arg3) )
    static public interface DDLDD (§ double invokePrim(double arg0, double arg1, long arg2, double arg3) )
    static public interface DDDOO (§ Object invokePrim(double arg0, double arg1, double arg2, Object arg3) )
    static public interface DDDOL (§ long invokePrim(double arg0, double arg1, double arg2, Object arg3) )
    static public interface DDDOD (§ double invokePrim(double arg0, double arg1, double arg2, Object arg3) )
    static public interface DDDLO (§ Object invokePrim(double arg0, double arg1, double arg2, long arg3) )
    static public interface DDDLL (§ long invokePrim(double arg0, double arg1, double arg2, long arg3) )
    static public interface DDDLD (§ double invokePrim(double arg0, double arg1, double arg2, long arg3) )
    static public interface DDDDO (§ Object invokePrim(double arg0, double arg1, double arg2, double arg3) )
    static public interface DDDDL (§ long invokePrim(double arg0, double arg1, double arg2, double arg3) )
    static public interface DDDDD (§ double invokePrim(double arg0, double arg1, double arg2, double arg3) )
)
)

(§ java cloiure.lang.IHashEq

public interface IHashEq
(§
    int hasheq()
)
)

(§ java cloiure.lang.IKeywordLookup

public interface IKeywordLookup
(§
    ILookupThunk getLookupThunk(Keyword k)
)
)

(§ java cloiure.lang.IKVReduce

public interface IKVReduce
(§
    Object kvreduce(IFn f, Object init)
)
)

(§ java cloiure.lang.ILookup

public interface ILookup
(§
    Object valAt(Object key)

    Object valAt(Object key, Object notFound)
)
)

(§ java cloiure.lang.ILookupSite

public interface ILookupSite
(§
    ILookupThunk fault(Object target)
)
)

(§ java cloiure.lang.ILookupThunk

public interface ILookupThunk
(§
    Object get(Object target)
)
)

(§ java cloiure.lang.IMapEntry

import java.util.Map

public interface IMapEntry extends Map.Entry
(§
    Object key()

    Object val()
)
)

(§ java cloiure.lang.IMapIterable

import java.util.Iterator

;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;
public interface IMapIterable
(§
    Iterator keyIterator()

    Iterator valIterator()
)
)

(§ java cloiure.lang.IMeta

public interface IMeta
(§
    IPersistentMap meta()
)
)

(§ java cloiure.lang.Indexed

public interface Indexed extends Counted
(§
    Object nth(int i)

    Object nth(int i, Object notFound)
)
)

(§ java cloiure.lang.IndexedSeq

public interface IndexedSeq extends ISeq, Sequential, Counted
(§
    public int index()
)
)

(§ java cloiure.lang.Intrinsics

import cloiure.asm.Opcodes

public class Intrinsics implements Opcodes
(§
    private static Object[] oa(Object... arr)
    (§
        return arr
    )

    static IPersistentMap ops = RT.map(
            "public static double cloiure.lang.Numbers.add(double,double)", DADD,
            "public static long cloiure.lang.Numbers.and(long,long)", LAND,
            "public static long cloiure.lang.Numbers.or(long,long)", LOR,
            "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
            "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
            "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
            "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
            "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
            "public static double cloiure.lang.Numbers.minus(double)", DNEG,
            "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
            "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
            "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
            "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
            "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
            "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
            "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
            "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
            "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
            "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

            "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
            "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
            "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
            "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
            "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
            "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
            "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
            "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
            "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

            "public static double cloiure.lang.RT.doubleCast(long)", L2D,
            "public static double cloiure.lang.RT.doubleCast(double)", NOP,
            "public static double cloiure.lang.RT.doubleCast(float)", F2D,
            "public static double cloiure.lang.RT.doubleCast(int)", I2D,
            "public static double cloiure.lang.RT.doubleCast(short)", I2D,
            "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
            "public static long cloiure.lang.RT.longCast(long)", NOP,
            "public static long cloiure.lang.RT.longCast(short)", I2L,
            "public static long cloiure.lang.RT.longCast(byte)", I2L,
            "public static long cloiure.lang.RT.longCast(int)", I2L,
            "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
            "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
            "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
            "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    )

    ;; map to instructions terminated with comparator for branch to false
    static IPersistentMap preds = RT.map(
            "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
            "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
            "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
            "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
            "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
            "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
            "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
            "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
            "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
            "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
            "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
            "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

            "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
            "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
            "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
            "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
            "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
            "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    )
)
)

(§ java cloiure.lang.IObj

public interface IObj extends IMeta
(§
    public IObj withMeta(IPersistentMap meta)
)
)

(§ java cloiure.lang.IPending

public interface IPending
(§
    boolean isRealized()
)
)

(§ java cloiure.lang.IPersistentCollection

public interface IPersistentCollection extends Seqable
(§
    int count()

    IPersistentCollection cons(Object o)

    IPersistentCollection empty()

    boolean equiv(Object o)
)
)

(§ java cloiure.lang.IPersistentList

public interface IPersistentList extends Sequential, IPersistentStack
(§
)
)

(§ java cloiure.lang.IPersistentMap

public interface IPersistentMap extends Iterable, Associative, Counted
(§
    IPersistentMap assoc(Object key, Object val)

    IPersistentMap assocEx(Object key, Object val)

    IPersistentMap without(Object key)
)
)

(§ java cloiure.lang.IPersistentSet

public interface IPersistentSet extends IPersistentCollection, Counted
(§
    public IPersistentSet disjoin(Object key)
    public boolean contains(Object key)
    public Object get(Object key)
)
)

(§ java cloiure.lang.IPersistentStack

public interface IPersistentStack extends IPersistentCollection
(§
    Object peek()

    IPersistentStack pop()
)
)

(§ java cloiure.lang.IPersistentVector

public interface IPersistentVector extends Associative, Sequential, IPersistentStack, Reversible, Indexed
(§
    int length()

    IPersistentVector assocN(int i, Object val)

    IPersistentVector cons(Object o)
)
)

(§ java cloiure.lang.IProxy

public interface IProxy
(§
    public void __initCloiureFnMappings(IPersistentMap m)
    public void __updateCloiureFnMappings(IPersistentMap m)
    public IPersistentMap __getCloiureFnMappings()
)
)

(§ java cloiure.lang.IRecord

public interface IRecord
(§
)
)

(§ java cloiure.lang.IReduce

public interface IReduce extends IReduceInit
(§
    Object reduce(IFn f)
)
)

(§ java cloiure.lang.IReduceInit

public interface IReduceInit
(§
    Object reduce(IFn f, Object start)
)
)

(§ java cloiure.lang.IRef

public interface IRef extends IDeref
(§
    void setValidator(IFn vf)

    IFn getValidator()

    IPersistentMap getWatches()

    IRef addWatch(Object key, IFn callback)

    IRef removeWatch(Object key)
)
)

(§ java cloiure.lang.IReference

public interface IReference extends IMeta
(§
    IPersistentMap alterMeta(IFn alter, ISeq args)
    IPersistentMap resetMeta(IPersistentMap m)
)
)

(§ java cloiure.lang.ISeq

;;
 ; A persistent, functional, sequence interface
 
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;
public interface ISeq extends IPersistentCollection
(§
    Object first()

    ISeq next()

    ISeq more()

    ISeq cons(Object o)
)
)

(§ java cloiure.lang.Iterate

public class Iterate extends ASeq implements IReduce, IPending
(§
    private static final Object UNREALIZED_SEED = new Object()
    private final IFn f ;; never null
    private final Object prevSeed
    private volatile Object _seed ;; lazily realized
    private volatile ISeq _next ;; cached

    private Iterate(IFn f, Object prevSeed, Object seed)
    (§
        this.f = f
        this.prevSeed = prevSeed
        this._seed = seed
    )

    private Iterate(IPersistentMap meta, IFn f, Object prevSeed, Object seed, ISeq next)
    (§
        super(meta)
        this.f = f
        this.prevSeed = prevSeed
        this._seed = seed
        this._next = next
    )

    public static ISeq create(IFn f, Object seed)
    (§
        return new Iterate(f, null, seed)
    )

    public boolean isRealized()
    (§
        return (_seed != UNREALIZED_SEED)
    )

    public Object first()
    (§
        if (_seed == UNREALIZED_SEED)
        (§
            _seed = f.invoke(prevSeed)
        )
        return _seed
    )

    public ISeq next()
    (§
        if (_next == null)
        (§
            _next = new Iterate(f, first(), UNREALIZED_SEED)
        )
        return _next
    )

    public Iterate withMeta(IPersistentMap meta)
    (§
        return new Iterate(meta, f, prevSeed, _seed, _next)
    )

    public Object reduce(IFn rf)
    (§
        Object first = first()
        Object ret = first
        Object v = f.invoke(first)
        while (true)
        (§
            ret = rf.invoke(ret, v)
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            v = f.invoke(v)
        )
    )

    public Object reduce(IFn rf, Object start)
    (§
        Object ret = start
        Object v = first()
        while (true)
        (§
            ret = rf.invoke(ret, v)
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            v = f.invoke(v)
        )
    )
)
)

(§ java cloiure.lang.IteratorSeq

import java.io.IOException
import java.io.NotSerializableException
import java.util.Iterator

public class IteratorSeq extends ASeq
(§
    final Iterator iter
    final State state

    static class State
    (§
        volatile Object val
        volatile Object _rest
    )

    public static IteratorSeq create(Iterator iter)
    (§
        if (iter.hasNext())
        (§
            return new IteratorSeq(iter)
        )
        return null
    )

    IteratorSeq(Iterator iter)
    (§
        this.iter = iter
        state = new State()
        this.state.val = state
        this.state._rest = state
    )

    IteratorSeq(IPersistentMap meta, Iterator iter, State state)
    (§
        super(meta)
        this.iter = iter
        this.state = state
    )

    public Object first()
    (§
        if (state.val == state)
        (§
            synchronized (state)
            (§
                if (state.val == state)
                (§
                    state.val = iter.next()
                )
            )
        )
        return state.val
    )

    public ISeq next()
    (§
        if (state._rest == state)
        (§
            synchronized (state)
            (§
                if (state._rest == state)
                (§
                    first()
                    state._rest = create(iter)
                )
            )
        )
        return (ISeq) state._rest
    )

    public IteratorSeq withMeta(IPersistentMap meta)
    (§
        return new IteratorSeq(meta, iter, state)
    )

    private void writeObject (java.io.ObjectOutputStream out) throws IOException
    (§
        throw new NotSerializableException(getClass().getName())
    )
)
)

(§ java cloiure.lang.ITransientAssociative

public interface ITransientAssociative extends ITransientCollection, ILookup
(§
    ITransientAssociative assoc(Object key, Object val)
)
)

(§ java cloiure.lang.ITransientAssociative2

public interface ITransientAssociative2 extends ITransientAssociative
(§
    boolean containsKey(Object key)
    IMapEntry entryAt(Object key)
)
)

(§ java cloiure.lang.ITransientCollection

public interface ITransientCollection
(§
    ITransientCollection conj(Object val)

    IPersistentCollection persistent()
)
)

(§ java cloiure.lang.ITransientMap

public interface ITransientMap extends ITransientAssociative, Counted
(§
    ITransientMap assoc(Object key, Object val)

    ITransientMap without(Object key)

    IPersistentMap persistent()
)
)

(§ java cloiure.lang.ITransientSet

public interface ITransientSet extends ITransientCollection, Counted
(§
    public ITransientSet disjoin(Object key)
    public boolean contains(Object key)
    public Object get(Object key)
)
)

(§ java cloiure.lang.ITransientVector

public interface ITransientVector extends ITransientAssociative, Indexed
(§
    ITransientVector assocN(int i, Object val)

    ITransientVector pop()
)
)

(§ java cloiure.lang.IType

public interface IType
(§
)
)

(§ java cloiure.lang.Keyword

import java.io.ObjectStreamException
import java.io.Serializable
import java.lang.ref.Reference
import java.lang.ref.WeakReference
import java.util.concurrent.ConcurrentHashMap
import java.lang.ref.ReferenceQueue
import java.lang.ref.SoftReference

public class Keyword implements IFn, Comparable, Named, Serializable, IHashEq
(§
    private static ConcurrentHashMap<Symbol, Reference<Keyword>> table = new ConcurrentHashMap()

    static final ReferenceQueue rq = new ReferenceQueue()

    public final Symbol sym
    final int hasheq
    transient String _str

    public static Keyword intern(Symbol sym)
    (§
        Keyword k = null
        Reference<Keyword> existingRef = table.get(sym)
        if (existingRef == null)
        (§
            Util.clearCache(rq, table)
            if (sym.meta() != null)
            (§
                sym = (Symbol) sym.withMeta(null)
            )
            k = new Keyword(sym)
            existingRef = table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq))
        )
        if (existingRef == null)
        (§
            return k
        )
        Keyword existingk = existingRef.get()
        if (existingk != null)
        (§
            return existingk
        )
        ;; entry died in the interim, do over
        table.remove(sym, existingRef)
        return intern(sym)
    )

    public static Keyword intern(String ns, String name)
    (§
        return intern(Symbol.intern(ns, name))
    )

    public static Keyword intern(String nsname)
    (§
        return intern(Symbol.intern(nsname))
    )

    private Keyword(Symbol sym)
    (§
        this.sym = sym
        hasheq = sym.hasheq() + 0x9e3779b9
    )

    public static Keyword find(Symbol sym)
    (§
        Reference<Keyword> ref = table.get(sym)
        if (ref != null)
        (§
            return ref.get()
        )
        else
        (§
            return null
        )
    )

    public static Keyword find(String ns, String name)
    (§
        return find(Symbol.intern(ns, name))
    )

    public static Keyword find(String nsname)
    (§
        return find(Symbol.intern(nsname))
    )

    public final int hashCode()
    (§
        return sym.hashCode() + 0x9e3779b9
    )

    public int hasheq()
    (§
        return hasheq
    )

    public String toString()
    (§
        if (_str == null)
        (§
            _str = (":" + sym)
        )
        return _str
    )

    public Object throwArity()
    (§
        throw new IllegalArgumentException("Wrong number of args passed to keyword: " + toString())
    )

    public Object call()
    (§
        return throwArity()
    )

    public void run()
    (§
        throw new UnsupportedOperationException()
    )

    public Object invoke()
    (§
        return throwArity()
    )

    public int compareTo(Object o)
    (§
        return sym.compareTo(((Keyword) o).sym)
    )

    public String getNamespace()
    (§
        return sym.getNamespace()
    )

    public String getName()
    (§
        return sym.getName()
    )

    private Object readResolve() throws ObjectStreamException
    (§
        return intern(sym)
    )

    ;;
     ; Indexer implements IFn for attr access
     
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;
    final public Object invoke(Object obj)
    (§
        if (obj instanceof ILookup)
        (§
            return ((ILookup)obj).valAt(this)
        )
        return RT.get(obj, this)
    )

    final public Object invoke(Object obj, Object notFound)
    (§
        if (obj instanceof ILookup)
        (§
            return ((ILookup)obj).valAt(this, notFound)
        )
        return RT.get(obj, this, notFound)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        return throwArity()
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        return throwArity()
    )

    public Object applyTo(ISeq arglist)
    (§
        return AFn.applyToHelper(this, arglist)
    )
)
)

(§ java cloiure.lang.KeywordLookupSite

public final class KeywordLookupSite implements ILookupSite, ILookupThunk
(§
    final Keyword k

    public KeywordLookupSite(Keyword k)
    (§
        this.k = k
    )

    public ILookupThunk fault(Object target)
    (§
        if (target instanceof IKeywordLookup)
        (§
            return install(target)
        )
        else if (target instanceof ILookup)
        (§
            return ilookupThunk(target.getClass())
        )
        return this
    )

    public Object get(Object target)
    (§
        if (target instanceof IKeywordLookup || target instanceof ILookup)
        (§
            return this
        )
        return RT.get(target, k)
    )

    private ILookupThunk ilookupThunk(final Class c)
    (§
        return new ILookupThunk()
        (§
            public Object get(Object target)
            (§
                if (target != null && target.getClass() == c)
                (§
                    return ((ILookup) target).valAt(k)
                )
                return this
            )
        )
    )

    private ILookupThunk install(Object target)
    (§
        ILookupThunk t = ((IKeywordLookup)target).getLookupThunk(k)
        if (t != null)
        (§
            return t
        )
        return ilookupThunk(target.getClass())
    )
)
)

(§ java cloiure.lang.LazilyPersistentVector

import java.util.Collection
import java.util.RandomAccess

public class LazilyPersistentVector
(§
    static public IPersistentVector createOwning(Object... items)
    (§
        if (items.length <= 32)
        (§
            return new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)
        )
        return PersistentVector.create(items)
    )

    static int fcount(Object c)
    (§
        if (c instanceof Counted)
        (§
            return ((Counted) c).count()
        )
        return ((Collection)c).size()
    )

    static public IPersistentVector create(Object obj)
    (§
        if (obj instanceof IReduceInit)
        (§
            return PersistentVector.create((IReduceInit) obj)
        )
        else if (obj instanceof ISeq)
        (§
            return PersistentVector.create(RT.seq(obj))
        )
        else if (obj instanceof Iterable)
        (§
            return PersistentVector.create((Iterable)obj)
        )
        else
        (§
            return createOwning(RT.toArray(obj))
        )
    )
)
)

(§ java cloiure.lang.LazySeq

import java.util.*

public final class LazySeq extends Obj implements ISeq, Sequential, List, IPending, IHashEq
(§
    private IFn fn
    private Object sv
    private ISeq s

    public LazySeq(IFn fn)
    (§
        this.fn = fn
    )

    private LazySeq(IPersistentMap meta, ISeq s)
    (§
        super(meta)
        this.fn = null
        this.s = s
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        return new LazySeq(meta, seq())
    )

    final synchronized Object sval()
    (§
        if (fn != null)
        (§
            sv = fn.invoke()
            fn = null
        )
        if (sv != null)
        (§
            return sv
        )
        return s
    )

    final synchronized public ISeq seq()
    (§
        sval()
        if (sv != null)
        (§
            Object ls = sv
            sv = null
            while (ls instanceof LazySeq)
            (§
                ls = ((LazySeq)ls).sval()
            )
            s = RT.seq(ls)
        )
        return s
    )

    public int count()
    (§
        int c = 0
        for (ISeq s = seq() s != null s = s.next())
        (§
            ++c
        )
        return c
    )

    public Object first()
    (§
        seq()
        if (s == null)
        (§
            return null
        )
        return s.first()
    )

    public ISeq next()
    (§
        seq()
        if (s == null)
        (§
            return null
        )
        return s.next()
    )

    public ISeq more()
    (§
        seq()
        if (s == null)
        (§
            return PersistentList.EMPTY
        )
        return s.more()
    )

    public ISeq cons(Object o)
    (§
        return RT.cons(o, seq())
    )

    public IPersistentCollection empty()
    (§
        return PersistentList.EMPTY
    )

    public boolean equiv(Object o)
    (§
        ISeq s = seq()
        if (s != null)
        (§
            return s.equiv(o)
        )
        else
        (§
            return (o instanceof Sequential || o instanceof List) && RT.seq(o) == null
        )
    )

    public int hashCode()
    (§
        ISeq s = seq()
        if (s == null)
        (§
            return 1
        )
        return Util.hash(s)
    )

    public int hasheq()
    (§
        return Murmur3.hashOrdered(this)
    )

    public boolean equals(Object o)
    (§
        ISeq s = seq()
        if (s != null)
        (§
            return s.equals(o)
        )
        else
        (§
            return (o instanceof Sequential || o instanceof List) && RT.seq(o) == null
        )
    )

    public Object[] toArray()
    (§
        return RT.seqToArray(seq())
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                return false
            )
        )
        return true
    )

    public Object[] toArray(Object[] a)
    (§
        return RT.seqToPassedArray(seq(), a)
    )

    public int size()
    (§
        return count()
    )

    public boolean isEmpty()
    (§
        return (seq() == null)
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != null s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                return true
            )
        )
        return false
    )

    public Iterator iterator()
    (§
        return new SeqIterator(this)
    )

    private List reify()
    (§
        return new ArrayList(this)
    )

    public List subList(int fromIndex, int toIndex)
    (§
        return reify().subList(fromIndex, toIndex)
    )

    public Object set(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public Object remove(int index)
    (§
        throw new UnsupportedOperationException()
    )

    public int indexOf(Object o)
    (§
        ISeq s = seq()
        for (int i = 0 s != null s = s.next(), i++)
        (§
            if (Util.equiv(s.first(), o))
            (§
                return i
            )
        )
        return -1
    )

    public int lastIndexOf(Object o)
    (§
        return reify().lastIndexOf(o)
    )

    public ListIterator listIterator()
    (§
        return reify().listIterator()
    )

    public ListIterator listIterator(int index)
    (§
        return reify().listIterator(index)
    )

    public Object get(int index)
    (§
        return RT.nth(this, index)
    )

    public void add(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(int index, Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    synchronized public boolean isRealized()
    (§
        return (fn == null)
    )
)
)

(§ java cloiure.lang.LineNumberingPushbackReader

import java.io.PushbackReader
import java.io.Reader
import java.io.LineNumberReader
import java.io.IOException

public class LineNumberingPushbackReader extends PushbackReader
(§
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.

    private static final int newline = (int) (§ char "\n")

    private boolean _atLineStart = true
    private boolean _prev
    private int _columnNumber = 1

    public LineNumberingPushbackReader(Reader r)
    (§
        super(new LineNumberReader(r))
    )

    public LineNumberingPushbackReader(Reader r, int size)
    (§
        super(new LineNumberReader(r, size))
    )

    public int getLineNumber()
    (§
        return ((LineNumberReader) in).getLineNumber() + 1
    )

    public void setLineNumber(int line) (§ ((LineNumberReader) in).setLineNumber(line - 1) )

    public int getColumnNumber()
    (§
        return _columnNumber
    )

    public int read() throws IOException
    (§
        int c = super.read()
        _prev = _atLineStart
        if ((c == newline) || (c == -1))
        (§
            _atLineStart = true
            _columnNumber = 1
        )
        else
        (§
            _atLineStart = false
            _columnNumber++
        )
        return c
    )

    public void unread(int c) throws IOException
    (§
        super.unread(c)
        _atLineStart = _prev
        _columnNumber--
    )

    public String readLine()
        throws IOException
    (§
        int c = read()
        String line
        switch (c)
        (§
            (§ case -1)
                line = null
                break
            (§ case newline)
                line = ""
                break
            (§ default)
                String first = String.valueOf((char) c)
                String rest = ((LineNumberReader)in).readLine()
                line = (rest == null) ? first :or first + rest
                _prev = false
                _atLineStart = true
                _columnNumber = 1
                break
        )
        return line
    )

    public boolean atLineStart()
    (§
        return _atLineStart
    )
)
)

(§ java cloiure.lang.LispReader

import java.io.IOException
import java.io.PushbackReader
import java.io.Reader
import java.lang.Character
import java.lang.Class
import java.lang.Exception
import java.lang.IllegalArgumentException
import java.lang.IllegalStateException
import java.lang.Integer
import java.lang.Number
import java.lang.NumberFormatException
import java.lang.Object
import java.lang.RuntimeException
import java.lang.String
import java.lang.StringBuilder
import java.lang.Throwable
import java.lang.UnsupportedOperationException
import java.lang.reflect.Constructor
import java.math.BigDecimal
import java.math.BigInteger
import java.util.ArrayList
import java.util.Iterator
import java.util.LinkedList
import java.util.List
import java.util.Map
import java.util.regex.Matcher
import java.util.regex.Pattern

public class LispReader
(§
    static final Symbol QUOTE = Symbol.intern("quote")
    static final Symbol THE_VAR = Symbol.intern("var")

    static Symbol UNQUOTE = Symbol.intern("cloiure.core", "unquote")
    static Symbol UNQUOTE_SPLICING = Symbol.intern("cloiure.core", "unquote-splicing")
    static Symbol CONCAT = Symbol.intern("cloiure.core", "concat")
    static Symbol SEQ = Symbol.intern("cloiure.core", "seq")
    static Symbol LIST = Symbol.intern("cloiure.core", "list")
    static Symbol APPLY = Symbol.intern("cloiure.core", "apply")
    static Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map")
    static Symbol HASHSET = Symbol.intern("cloiure.core", "hash-set")
    static Symbol VECTOR = Symbol.intern("cloiure.core", "vector")
    static Symbol WITH_META = Symbol.intern("cloiure.core", "with-meta")
    static Symbol META = Symbol.intern("cloiure.core", "meta")
    static Symbol DEREF = Symbol.intern("cloiure.core", "deref")
    static Symbol READ_COND = Symbol.intern("cloiure.core", "read-cond")
    static Symbol READ_COND_SPLICING = Symbol.intern("cloiure.core", "read-cond-splicing")
    static Keyword UNKNOWN = Keyword.intern(null, "unknown")

    static IFn[] macros = new IFn[256]
    static IFn[] dispatchMacros = new IFn[256]

    static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")
    static Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")
    static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)")
    static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")

    ;; symbol->gensymbol
    static Var GENSYM_ENV = Var.create(null).setDynamic()
    ;; sorted-map num->gensymbol
    static Var ARG_ENV = Var.create(null).setDynamic()
    static IFn ctorReader = new CtorReader()

    ;; Dynamic var set to true in a read-cond context
    static Var READ_COND_ENV = Var.create(null).setDynamic()

    static
    (§
        macros[(§ char \")] = new StringReader()
        macros[(§ char \;)] = new CommentReader()
        macros[(§ char \')] = new WrappingReader(QUOTE)
        macros[(§ char \@)] = new WrappingReader(DEREF)
        macros[(§ char \^)] = new MetaReader()
        macros[(§ char \`)] = new SyntaxQuoteReader()
        macros[(§ char \~)] = new UnquoteReader()
        macros[(§ char \()] = new ListReader()
        macros[(§ char \))] = new UnmatchedDelimiterReader()
        macros[(§ char \[)] = new VectorReader()
        macros[(§ char \])] = new UnmatchedDelimiterReader()
        macros[(§ char \{)] = new MapReader()
        macros[(§ char \})] = new UnmatchedDelimiterReader()
        macros[(§ char \\)] = new CharacterReader()
        macros[(§ char \%)] = new ArgReader()
        macros[(§ char \#)] = new DispatchReader()

        dispatchMacros[(§ char \^)] = new MetaReader()
        dispatchMacros[(§ char \#)] = new SymbolicValueReader()
        dispatchMacros[(§ char \')] = new VarReader()
        dispatchMacros[(§ char \")] = new RegexReader()
        dispatchMacros[(§ char \()] = new FnReader()
        dispatchMacros[(§ char \{)] = new SetReader()
        dispatchMacros[(§ char \=)] = new EvalReader()
        dispatchMacros[(§ char \!)] = new CommentReader()
        dispatchMacros[(§ char \<)] = new UnreadableReader()
        dispatchMacros[(§ char \_)] = new DiscardReader()
        dispatchMacros[(§ char \?)] = new ConditionalReader()
        dispatchMacros[(§ char \:)] = new NamespaceMapReader()
    )

    public static interface Resolver
    (§
        Symbol currentNS()
        Symbol resolveClass(Symbol sym)
        Symbol resolveAlias(Symbol sym)
        Symbol resolveVar(Symbol sym)
    )

    static boolean isWhitespace(int ch)
    (§
        return (Character.isWhitespace(ch) || ch == (§ char \,))
    )

    static void unread(PushbackReader r, int ch)
    (§
        if (ch != -1)
        (§
            try
            (§
                r.unread(ch)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
    )

    public static class ReaderException extends RuntimeException
    (§
        final int line
        final int column

        public ReaderException(int line, int column, Throwable cause)
        (§
            super(cause)
            this.line = line
            this.column = column
        )
    )

    static public int read1(Reader r)
    (§
        try
        (§
            return r.read()
        )
        catch (IOException e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    ;; Reader opts
    static public final Keyword OPT_EOF = Keyword.intern(null, "eof")
    static public final Keyword OPT_FEATURES = Keyword.intern(null, "features")
    static public final Keyword OPT_READ_COND = Keyword.intern(null, "read-cond")

    ;; EOF special value to throw on eof
    static public final Keyword EOFTHROW = Keyword.intern(null, "eofthrow")

    ;; Platform features - always installed
    static private final Keyword PLATFORM_KEY = Keyword.intern(null, "cli")
    static private final Object PLATFORM_FEATURES = PersistentHashSet.create(PLATFORM_KEY)

    ;; Reader conditional options - use with :read-cond
    static public final Keyword COND_ALLOW = Keyword.intern(null, "allow")
    static public final Keyword COND_PRESERVE = Keyword.intern(null, "preserve")

    static public Object read(PushbackReader r, Object opts)
    (§
        boolean eofIsError = true
        Object eofValue = null
        if (opts != null && opts instanceof IPersistentMap)
        (§
            Object eof = ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW)
            if (!EOFTHROW.equals(eof))
            (§
                eofIsError = false
                eofValue = eof
            )
        )
        return read(r, eofIsError, eofValue, false, opts)
    )

    static public Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive)
    (§
        return read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY)
    )

    static public Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
    (§
        ;; start with pendingForms null as reader conditional splicing is not allowed at top level
        return read(r, eofIsError, eofValue, null, null, isRecursive, opts, null, (Resolver) RT.READER_RESOLVER.deref())
    )

    static private Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts, Object pendingForms)
    (§
        return read(r, eofIsError, eofValue, null, null, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref())
    )

    static private Object ensurePending(Object pendingForms)
    (§
        if (pendingForms == null)
        (§
            return new LinkedList()
        )
        else
        (§
            return pendingForms
        )
    )

    static private Object installPlatformFeature(Object opts)
    (§
        if (opts == null)
        (§
            return RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES)
        )
        else
        (§
            IPersistentMap mopts = (IPersistentMap) opts
            Object features = mopts.valAt(OPT_FEATURES)
            if (features == null)
            (§
                return mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES)
            )
            else
            (§
                return mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY))
            )
        )
    )

    static private Object read(PushbackReader r, boolean eofIsError, Object eofValue, Character returnOn, Object returnOnValue, boolean isRecursive, Object opts, Object pendingForms, Resolver resolver)
    (§
        if (RT.READEVAL.deref() == UNKNOWN)
        (§
            throw Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown")
        )

        opts = installPlatformFeature(opts)

        try
        (§
            while (true)
            (§
                if (pendingForms instanceof List && !((List)pendingForms).isEmpty())
                (§
                    return ((List)pendingForms).remove(0)
                )

                int ch = read1(r)

                while (isWhitespace(ch))
                    ch = read1(r)

                if (ch == -1)
                (§
                    if (eofIsError)
                    (§
                        throw Util.runtimeException("EOF while reading")
                    )
                    return eofValue
                )

                if (returnOn != null && (returnOn.charValue() == ch))
                (§
                    return returnOnValue
                )

                if (Character.isDigit(ch))
                (§
                    Object n = readNumber(r, (char) ch)
                    return n
                )

                IFn macroFn = getMacro(ch)
                if (macroFn != null)
                (§
                    Object ret = macroFn.invoke(r, (char) ch, opts, pendingForms)
                    ;; no op macros return the reader
                    if (ret == r)
                    (§
                        continue
                    )
                    return ret
                )

                if (ch == (§ char \+) || ch == (§ char \-))
                (§
                    int ch2 = read1(r)
                    if (Character.isDigit(ch2))
                    (§
                        unread(r, ch2)
                        Object n = readNumber(r, (char) ch)
                        return n
                    )
                    unread(r, ch2)
                )

                String token = readToken(r, (char) ch)
                return interpretToken(token, resolver)
            )
        )
        catch (Exception e)
        (§
            if (isRecursive || !(r instanceof LineNumberingPushbackReader))
            (§
                throw Util.sneakyThrow(e)
            )
            LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r
            throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)
        )
    )

    static private String readToken(PushbackReader r, char initch)
    (§
        StringBuilder sb = new StringBuilder()
        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
            (§
                unread(r, ch)
                return sb.toString()
            )
            sb.append((char) ch)
        )
    )

    static private Object readNumber(PushbackReader r, char initch)
    (§
        StringBuilder sb = new StringBuilder()
        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            sb.append((char) ch)
        )

        String s = sb.toString()
        Object n = matchNumber(s)
        if (n == null)
        (§
            throw new NumberFormatException("Invalid number: " + s)
        )
        return n
    )

    static private int readUnicodeChar(String token, int offset, int length, int base)
    (§
        if (token.length() != offset + length)
        (§
            throw new IllegalArgumentException("Invalid unicode character: \\" + token)
        )
        int uc = 0
        for (int i = offset i < offset + length ++i)
        (§
            int d = Character.digit(token.charAt(i), base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + token.charAt(i))
            )
            uc = uc * base + d
        )
        return (char) uc
    )

    static private int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
    (§
        int uc = Character.digit(initch, base)
        if (uc == -1)
        (§
            throw new IllegalArgumentException("Invalid digit: " + (char) initch)
        )
        int i = 1
        for (  i < length ++i)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            int d = Character.digit(ch, base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + (char) ch)
            )
            uc = uc * base + d
        )
        if (i != length && exact)
        (§
            throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)
        )
        return uc
    )

    static private Object interpretToken(String s, Resolver resolver)
    (§
        if (s.equals("nil"))
        (§
            return null
        )
        else if (s.equals("true"))
        (§
            return RT.T
        )
        else if (s.equals("false"))
        (§
            return RT.F
        )
        Object ret = null

        ret = matchSymbol(s, resolver)
        if (ret != null)
        (§
            return ret
        )

        throw Util.runtimeException("Invalid token: " + s)
    )

    private static Object matchSymbol(String s, Resolver resolver)
    (§
        Matcher m = symbolPat.matcher(s)
        if (m.matches())
        (§
            int gc = m.groupCount()
            String ns = m.group(1)
            String name = m.group(2)
            if (ns != null && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
            (§
                return null
            )
            if (s.startsWith("::"))
            (§
                Symbol ks = Symbol.intern(s.substring(2))
                if (resolver != null)
                (§
                    Symbol nsym
                    if (ks.ns != null)
                    (§
                        nsym = resolver.resolveAlias(Symbol.intern(ks.ns))
                    )
                    else
                    (§
                        nsym = resolver.currentNS()
                    )
                    ;; auto-resolving keyword
                    if (nsym != null)
                    (§
                        return Keyword.intern(nsym.name, ks.name)
                    )
                    else
                    (§
                        return null
                    )
                )
                else
                (§
                    Namespace kns
                    if (ks.ns != null)
                    (§
                        kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns))
                    )
                    else
                    (§
                        kns = Compiler.currentNS()
                    )
                    ;; auto-resolving keyword
                    if (kns != null)
                    (§
                        return Keyword.intern(kns.name.name, ks.name)
                    )
                    else
                    (§
                        return null
                    )
                )
            )
            boolean isKeyword = (s.charAt(0) == (§ char \:))
            Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0))
            if (isKeyword)
            (§
                return Keyword.intern(sym)
            )
            return sym
        )
        return null
    )

    private static Object matchNumber(String s)
    (§
        Matcher m = intPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(2) != null)
            (§
                if (m.group(8) != null)
                (§
                    return BigInt.ZERO
                )
                return Numbers.num(0)
            )
            boolean negate = m.group(1).equals("-")
            String n
            int radix = 10
            if ((n = m.group(3)) != null)
            (§
                radix = 10
            )
            else if ((n = m.group(4)) != null)
            (§
                radix = 16
            )
            else if ((n = m.group(5)) != null)
            (§
                radix = 8
            )
            else if ((n = m.group(7)) != null)
            (§
                radix = Integer.parseInt(m.group(6))
            )
            if (n == null)
            (§
                return null
            )
            BigInteger bn = new BigInteger(n, radix)
            if (negate)
            (§
                bn = bn.negate()
            )
            if (m.group(8) != null)
            (§
                return BigInt.fromBigInteger(bn)
            )
            return (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)
        )
        m = floatPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(4) != null)
            (§
                return new BigDecimal(m.group(1))
            )
            return Double.parseDouble(s)
        )
        m = ratioPat.matcher(s)
        if (m.matches())
        (§
            String numerator = m.group(1)
            if (numerator.startsWith("+"))
            (§
                numerator = numerator.substring(1)
            )
            return Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))
        )
        return null
    )

    static private IFn getMacro(int ch)
    (§
        if (ch < macros.length)
        (§
            return macros[ch]
        )
        return null
    )

    static private boolean isMacro(int ch)
    (§
        return (ch < macros.length && macros[ch] != null)
    )

    static private boolean isTerminatingMacro(int ch)
    (§
        return (ch != (§ char \#) && ch != (§ char \') && ch != (§ char \%) && isMacro(ch))
    )

    public static class RegexReader extends AFn
    (§
        static StringReader stringrdr = new StringReader()

        public Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
        (§
            StringBuilder sb = new StringBuilder()
            Reader r = (Reader) reader
            for (int ch = read1(r) ch != (§ char \") ch = read1(r)) ;; oops! "
            (§
                if (ch == -1)
                (§
                    throw Util.runtimeException("EOF while reading regex")
                )
                sb.append((char) ch)
                if (ch == (§ char \\)) ;; escape
                (§
                    ch = read1(r)
                    if (ch == -1)
                    (§
                        throw Util.runtimeException("EOF while reading regex")
                    )
                    sb.append((char) ch)
                )
            )
            return Pattern.compile(sb.toString())
        )
    )

    public static class StringReader extends AFn
    (§
        public Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
        (§
            StringBuilder sb = new StringBuilder()
            Reader r = (Reader) reader

            for (int ch = read1(r) ch != (§ char \") ch = read1(r)) ;; oops! "
            (§
                if (ch == -1)
                (§
                    throw Util.runtimeException("EOF while reading string")
                )
                if (ch == (§ char \\)) ;; escape
                (§
                    ch = read1(r)
                    if (ch == -1)
                    (§
                        throw Util.runtimeException("EOF while reading string")
                    )
                    switch (ch)
                    (§
                        (§ case (§ char \t))
                            ch = (§ char "\t")
                            break
                        (§ case (§ char \r))
                            ch = (§ char "\r")
                            break
                        (§ case (§ char \n))
                            ch = (§ char "\n")
                            break
                        (§ case (§ char \\))
                            break
                        (§ case (§ char \")) ;; oops! "
                            break
                        (§ case (§ char \b))
                            ch = (§ char "\b")
                            break
                        (§ case (§ char \f))
                            ch = (§ char "\f")
                            break
                        (§ case (§ char \u))
                        (§
                            ch = read1(r)
                            if (Character.digit(ch, 16) == -1)
                            (§
                                throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)
                            )
                            ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true)
                            break
                        )
                        (§ default)
                        (§
                            if (Character.isDigit(ch))
                            (§
                                ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false)
                                if (ch > 0377)
                                (§
                                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                                )
                            )
                            else
                            (§
                                throw Util.runtimeException("Unsupported escape character: \\" + (char) ch)
                            )
                            break
                        )
                    )
                )
                sb.append((char) ch)
            )
            return sb.toString()
        )
    )

    public static class CommentReader extends AFn
    (§
        public Object invoke(Object reader, Object semicolon, Object opts, Object pendingForms)
        (§
            Reader r = (Reader) reader
            int ch
            do
            (§
                ch = read1(r)
            ) while (ch != -1 && ch != (§ char "\n") && ch != (§ char "\r"))
            return r
        )
    )

    public static class DiscardReader extends AFn
    (§
        public Object invoke(Object reader, Object underscore, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            read(r, true, null, true, opts, ensurePending(pendingForms))
            return r
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    public static class NamespaceMapReader extends AFn
    (§
        public Object invoke(Object reader, Object colon, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader

            boolean auto = false
            int autoChar = read1(r)
            if (autoChar == (§ char \:))
            (§
                auto = true
            )
            else
            (§
                unread(r, autoChar)
            )

            Object sym = null
            int nextChar = read1(r)
            if (isWhitespace(nextChar)) ;; the #:: { } case or an error
            (§
                if (auto)
                (§
                    while (isWhitespace(nextChar))
                        nextChar = read1(r)
                    if (nextChar != (§ char \{))
                    (§
                        unread(r, nextChar)
                        throw Util.runtimeException("Namespaced map must specify a namespace")
                    )
                )
                else
                (§
                    unread(r, nextChar)
                    throw Util.runtimeException("Namespaced map must specify a namespace")
                )
            )
            else if (nextChar != (§ char \{)) ;; #:foo { } or #::foo { }
            (§
                unread(r, nextChar)
                sym = read(r, true, null, false, opts, pendingForms)
                nextChar = read1(r)
                while (isWhitespace(nextChar))
                    nextChar = read1(r)
            )
            if (nextChar != (§ char \{))
            (§
                throw Util.runtimeException("Namespaced map must specify a map")
            )

            ;; Resolve autoresolved ns
            String ns
            if (auto)
            (§
                Resolver resolver = (Resolver) RT.READER_RESOLVER.deref()
                if (sym == null)
                (§
                    if (resolver != null)
                    (§
                        ns = resolver.currentNS().name
                    )
                    else
                    (§
                        ns = Compiler.currentNS().getName().getName()
                    )
                )
                else if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != null)
                (§
                    throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)
                )
                else
                (§
                    Symbol resolvedNS
                    if (resolver != null)
                    (§
                        resolvedNS = resolver.resolveAlias((Symbol) sym)
                    )
                    else
                    (§
                        Namespace rns = Compiler.currentNS().lookupAlias((Symbol)sym)
                        resolvedNS = (rns != null) ? rns.getName() :or null
                    )

                    if (resolvedNS == null)
                    (§
                        throw Util.runtimeException("Unknown auto-resolved namespace alias: " + sym)
                    )
                    else
                    (§
                        ns = resolvedNS.getName()
                    )
                )
            )
            else if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != null)
            (§
                throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)
            )
            else
            (§
                ns = ((Symbol)sym).getName()
            )

            ;; Read map
            List kvs = readDelimitedList((§ char \}), r, true, opts, ensurePending(pendingForms))
            if ((kvs.size() & 1) == 1)
            (§
                throw Util.runtimeException("Namespaced map literal must contain an even number of forms")
            )

            ;; Construct output map
            Object[] a = new Object[kvs.size()]
            Iterator iter = kvs.iterator()
            for (int i = 0 iter.hasNext() i += 2)
            (§
                Object key = iter.next()
                Object val = iter.next()

                if (key instanceof Keyword)
                (§
                    Keyword kw = (Keyword) key
                    if (kw.getNamespace() == null)
                    (§
                        key = Keyword.intern(ns, kw.getName())
                    )
                    else if (kw.getNamespace().equals("_"))
                    (§
                        key = Keyword.intern(null, kw.getName())
                    )
                )
                else if (key instanceof Symbol)
                (§
                    Symbol s = (Symbol) key
                    if (s.getNamespace() == null)
                    (§
                        key = Symbol.intern(ns, s.getName())
                    )
                    else if (s.getNamespace().equals("_"))
                    (§
                        key = Symbol.intern(null, s.getName())
                    )
                )
                a[i] = key
                a[i + 1] = val
            )
            return RT.map(a)
        )
    )

    public static class SymbolicValueReader extends AFn
    (§
        static IPersistentMap  specials = PersistentHashMap.create(
            Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
            Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
            Symbol.intern("NaN"), Double.NaN
        )

        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, null, true, opts, ensurePending(pendingForms))

            if (!(o instanceof Symbol))
            (§
                throw Util.runtimeException("Invalid token: ##" + o)
            )
            if (!(specials.containsKey(o)))
            (§
                throw Util.runtimeException("Unknown symbolic value: ##" + o)
            )

            return specials.valAt(o)
        )
    )

    public static class WrappingReader extends AFn
    (§
        final Symbol sym

        public WrappingReader(Symbol sym)
        (§
            this.sym = sym
        )

        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, null, true, opts, ensurePending(pendingForms))
            return RT.list(sym, o)
        )
    )

    public static class DeprecatedWrappingReader extends AFn
    (§
        final Symbol sym
        final String macro

        public DeprecatedWrappingReader(Symbol sym, String macro)
        (§
            this.sym = sym
            this.macro = macro
        )

        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead")
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, null, true, opts, ensurePending(pendingForms))
            return RT.list(sym, o)
        )
    )

    public static class VarReader extends AFn
    (§
        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, null, true, opts, ensurePending(pendingForms))
            return RT.list(THE_VAR, o)
        )
    )

    public static class DispatchReader extends AFn
    (§
        public Object invoke(Object reader, Object hash, Object opts, Object pendingForms)
        (§
            int ch = read1((Reader) reader)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            IFn fn = dispatchMacros[ch]

            ;; Try the ctor reader first
            if (fn == null)
            (§
                unread((PushbackReader) reader, ch)
                pendingForms = ensurePending(pendingForms)
                Object result = ctorReader.invoke(reader, ch, opts, pendingForms)

                if (result != null)
                (§
                    return result
                )
                else
                (§
                    throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))
                )
            )
            return fn.invoke(reader, ch, opts, pendingForms)
        )
    )

    static Symbol garg(int n)
    (§
        return Symbol.intern(null, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#")
    )

    public static class FnReader extends AFn
    (§
        public Object invoke(Object reader, Object lparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            if (ARG_ENV.deref() != null)
            (§
                throw new IllegalStateException("Nested #()s are not allowed")
            )
            try
            (§
                Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY))
                unread(r, (§ char \())
                Object form = read(r, true, null, true, opts, ensurePending(pendingForms))

                PersistentVector args = PersistentVector.EMPTY
                PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref()
                ISeq rargs = argsyms.rseq()
                if (rargs != null)
                (§
                    int higharg = (Integer) ((Map.Entry) rargs.first()).getKey()
                    if (higharg > 0)
                    (§
                        for (int i = 1 i <= higharg ++i)
                        (§
                            Object sym = argsyms.valAt(i)
                            if (sym == null)
                            (§
                                sym = garg(i)
                            )
                            args = args.cons(sym)
                        )
                    )
                    Object restsym = argsyms.valAt(-1)
                    if (restsym != null)
                    (§
                        args = args.cons(Compiler._AMP_)
                        args = args.cons(restsym)
                    )
                )
                return RT.list(Compiler.FN, args, form)
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
    )

    static Symbol registerArg(int n)
    (§
        PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref()
        if (argsyms == null)
        (§
            throw new IllegalStateException("arg literal not in #()")
        )
        Symbol ret = (Symbol) argsyms.valAt(n)
        if (ret == null)
        (§
            ret = garg(n)
            ARG_ENV.set(argsyms.assoc(n, ret))
        )
        return ret
    )

    static class ArgReader extends AFn
    (§
        public Object invoke(Object reader, Object pct, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            if (ARG_ENV.deref() == null)
            (§
                return interpretToken(readToken(r, (§ char \%)), null)
            )
            int ch = read1(r)
            unread(r, ch)
            ;; % alone is first arg
            if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
            (§
                return registerArg(1)
            )
            Object n = read(r, true, null, true, opts, ensurePending(pendingForms))
            if (n.equals(Compiler._AMP_))
            (§
                return registerArg(-1)
            )
            if (!(n instanceof Number))
            (§
                throw new IllegalStateException("arg literal must be %, %& or %integer")
            )
            return registerArg(((Number) n).intValue())
        )
    )

    public static class MetaReader extends AFn
    (§
        public Object invoke(Object reader, Object caret, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            pendingForms = ensurePending(pendingForms)
            Object meta = read(r, true, null, true, opts, pendingForms)
            if (meta instanceof Symbol || meta instanceof String)
            (§
                meta = RT.map(RT.TAG_KEY, meta)
            )
            else if (meta instanceof Keyword)
            (§
                meta = RT.map(meta, RT.T)
            )
            else if (!(meta instanceof IPersistentMap))
            (§
                throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")
            )

            Object o = read(r, true, null, true, opts, pendingForms)
            if (o instanceof IMeta)
            (§
                if (line != -1 && o instanceof ISeq)
                (§
                    meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column)
                )
                if (o instanceof IReference)
                (§
                    ((IReference)o).resetMeta((IPersistentMap) meta)
                    return o
                )
                Object ometa = RT.meta(o)
                for (ISeq s = RT.seq(meta) s != null s = s.next())
                (§
                    IMapEntry kv = (IMapEntry) s.first()
                    ometa = RT.assoc(ometa, kv.getKey(), kv.getValue())
                )
                return ((IObj) o).withMeta((IPersistentMap) ometa)
            )
            else
            (§
                throw new IllegalArgumentException("Metadata can only be applied to IMetas")
            )
        )
    )

    public static class SyntaxQuoteReader extends AFn
    (§
        public Object invoke(Object reader, Object backquote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            try
            (§
                Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY))

                Object form = read(r, true, null, true, opts, ensurePending(pendingForms))
                return syntaxQuote(form)
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        static Object syntaxQuote(Object form)
        (§
            Object ret
            if (Compiler.isSpecial(form))
            (§
                ret = RT.list(Compiler.QUOTE, form)
            )
            else if (form instanceof Symbol)
            (§
                Resolver resolver = (Resolver) RT.READER_RESOLVER.deref()
                Symbol sym = (Symbol) form
                if (sym.ns == null && sym.name.endsWith("#"))
                (§
                    IPersistentMap gmap = (IPersistentMap) GENSYM_ENV.deref()
                    if (gmap == null)
                    (§
                        throw new IllegalStateException("Gensym literal not in syntax-quote")
                    )
                    Symbol gs = (Symbol) gmap.valAt(sym)
                    if (gs == null)
                    (§
                        GENSYM_ENV.set(gmap.assoc(sym, gs = Symbol.intern(null, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__")))
                    )
                    sym = gs
                )
                else if (sym.ns == null && sym.name.endsWith("."))
                (§
                    Symbol csym = Symbol.intern(null, sym.name.substring(0, sym.name.length() - 1))
                    if (resolver != null)
                    (§
                        Symbol rc = resolver.resolveClass(csym)
                        if (rc != null)
                        (§
                            csym = rc
                        )
                    )
                    else
                    (§
                        csym = Compiler.resolveSymbol(csym)
                    )
                    sym = Symbol.intern(null, csym.name.concat("."))
                )
                else if (sym.ns == null && sym.name.startsWith("."))
                (§
                    ;; Simply quote method names.
                )
                else if (resolver != null)
                (§
                    Symbol nsym = null
                    if (sym.ns != null)
                    (§
                        Symbol alias = Symbol.intern(null, sym.ns)
                        nsym = resolver.resolveClass(alias)
                        if (nsym == null)
                        (§
                            nsym = resolver.resolveAlias(alias)
                        )
                    )
                    if (nsym != null)
                    (§
                        ;; Classname/foo -> package.qualified.Classname/foo
                        sym = Symbol.intern(nsym.name, sym.name)
                    )
                    else if (sym.ns == null)
                    (§
                        Symbol rsym = resolver.resolveClass(sym)
                        if (rsym == null)
                        (§
                            rsym = resolver.resolveVar(sym)
                        )
                        if (rsym != null)
                        (§
                            sym = rsym
                        )
                        else
                        (§
                            sym = Symbol.intern(resolver.currentNS().name, sym.name)
                        )
                    )
                    ;; leave alone if qualified
                )
                else
                (§
                    Object maybeClass = null
                    if (sym.ns != null)
                    (§
                        maybeClass = Compiler.currentNS().getMapping(Symbol.intern(null, sym.ns))
                    )
                    if (maybeClass instanceof Class)
                    (§
                        ;; Classname/foo -> package.qualified.Classname/foo
                        sym = Symbol.intern(((Class)maybeClass).getName(), sym.name)
                    )
                    else
                    (§
                        sym = Compiler.resolveSymbol(sym)
                    )
                )
                ret = RT.list(Compiler.QUOTE, sym)
            )
            else if (isUnquote(form))
            (§
                return RT.second(form)
            )
            else if (isUnquoteSplicing(form))
            (§
                throw new IllegalStateException("splice not in list")
            )
            else if (form instanceof IPersistentCollection)
            (§
                if (form instanceof IRecord)
                (§
                    ret = form
                )
                else if (form instanceof IPersistentMap)
                (§
                    IPersistentVector keyvals = flattenMap(form)
                    ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq()))))
                )
                else if (form instanceof IPersistentVector)
                (§
                    ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq()))))
                )
                else if (form instanceof IPersistentSet)
                (§
                    ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq()))))
                )
                else if (form instanceof ISeq || form instanceof IPersistentList)
                (§
                    ISeq seq = RT.seq(form)
                    if (seq == null)
                    (§
                        ret = RT.cons(LIST, null)
                    )
                    else
                    (§
                        ret = RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq)))
                    )
                )
                else
                (§
                    throw new UnsupportedOperationException("Unknown Collection type")
                )
            )
            else if (form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String)
            (§
                ret = form
            )
            else
            (§
                ret = RT.list(Compiler.QUOTE, form)
            )

            if (form instanceof IObj && RT.meta(form) != null)
            (§
                ;; filter line and column numbers
                IPersistentMap newMeta = ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY)
                if (newMeta.count() > 0)
                (§
                    return RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))
                )
            )
            return ret
        )

        private static ISeq sqExpandList(ISeq seq)
        (§
            PersistentVector ret = PersistentVector.EMPTY
            for (  seq != null seq = seq.next())
            (§
                Object item = seq.first()
                if (isUnquote(item))
                (§
                    ret = ret.cons(RT.list(LIST, RT.second(item)))
                )
                else if (isUnquoteSplicing(item))
                (§
                    ret = ret.cons(RT.second(item))
                )
                else
                (§
                    ret = ret.cons(RT.list(LIST, syntaxQuote(item)))
                )
            )
            return ret.seq()
        )

        private static IPersistentVector flattenMap(Object form)
        (§
            IPersistentVector keyvals = PersistentVector.EMPTY
            for (ISeq s = RT.seq(form) s != null s = s.next())
            (§
                IMapEntry e = (IMapEntry) s.first()
                keyvals = (IPersistentVector) keyvals.cons(e.key())
                keyvals = (IPersistentVector) keyvals.cons(e.val())
            )
            return keyvals
        )
    )

    static boolean isUnquoteSplicing(Object form)
    (§
        return form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING)
    )

    static boolean isUnquote(Object form)
    (§
        return form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE)
    )

    static class UnquoteReader extends AFn
    (§
        public Object invoke(Object reader, Object comma, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            pendingForms = ensurePending(pendingForms)
            if (ch == (§ char \@))
            (§
                Object o = read(r, true, null, true, opts, pendingForms)
                return RT.list(UNQUOTE_SPLICING, o)
            )
            else
            (§
                unread(r, ch)
                Object o = read(r, true, null, true, opts, pendingForms)
                return RT.list(UNQUOTE, o)
            )
        )
    )

    public static class CharacterReader extends AFn
    (§
        public Object invoke(Object reader, Object backslash, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            String token = readToken(r, (char) ch)
            if (token.length() == 1)
            (§
                return Character.valueOf(token.charAt(0))
            )
            else if (token.equals("newline"))
            (§
                return (§ char "\n")
            )
            else if (token.equals("space"))
            (§
                return (§ char \space)
            )
            else if (token.equals("tab"))
            (§
                return (§ char "\t")
            )
            else if (token.equals("backspace"))
            (§
                return (§ char "\b")
            )
            else if (token.equals("formfeed"))
            (§
                return (§ char "\f")
            )
            else if (token.equals("return"))
            (§
                return (§ char "\r")
            )
            else if (token.startsWith("u"))
            (§
                char c = (char) readUnicodeChar(token, 1, 4, 16)
                if (c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                (§
                    throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))
                )
                return c
            )
            else if (token.startsWith("o"))
            (§
                int len = token.length() - 1
                if (len > 3)
                (§
                    throw Util.runtimeException("Invalid octal escape sequence length: " + len)
                )
                int uc = readUnicodeChar(token, 1, len, 8)
                if (uc > 0377)
                (§
                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                )
                return (char) uc
            )
            throw Util.runtimeException("Unsupported character: \\" + token)
        )
    )

    public static class ListReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            List list = readDelimitedList((§ char \)), r, true, opts, ensurePending(pendingForms))
            if (list.isEmpty())
            (§
                return PersistentList.EMPTY
            )
            IObj s = (IObj) PersistentList.create(list)
            if (line != -1)
            (§
                return s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column))
            )
            else
            (§
                return s
            )
        )
    )

    public static class EvalReader extends AFn
    (§
        public Object invoke(Object reader, Object eq, Object opts, Object pendingForms)
        (§
            if (!RT.booleanCast(RT.READEVAL.deref()))
            (§
                throw Util.runtimeException("EvalReader not allowed when *read-eval* is false.")
            )

            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, null, true, opts, ensurePending(pendingForms))
            if (o instanceof Symbol)
            (§
                return RT.classForName(o.toString())
            )
            else if (o instanceof IPersistentList)
            (§
                Symbol fs = (Symbol) RT.first(o)
                if (fs.equals(THE_VAR))
                (§
                    Symbol vs = (Symbol) RT.second(o)
                    return RT.var(vs.ns, vs.name)
                )
                if (fs.name.endsWith("."))
                (§
                    Object[] args = RT.toArray(RT.next(o))
                    return Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)
                )
                if (Compiler.namesStaticMember(fs))
                (§
                    Object[] args = RT.toArray(RT.next(o))
                    return Reflector.invokeStaticMethod(fs.ns, fs.name, args)
                )
                Object v = Compiler.maybeResolveIn(Compiler.currentNS(), fs)
                if (v instanceof Var)
                (§
                    return ((IFn) v).applyTo(RT.next(o))
                )
                throw Util.runtimeException("Can't resolve " + fs)
            )
            else
            (§
                throw new IllegalArgumentException("Unsupported #= form")
            )
        )
    )

    public static class VectorReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            return LazilyPersistentVector.create(readDelimitedList((§ char \]), r, true, opts, ensurePending(pendingForms)))
        )
    )

    public static class MapReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object[] a = readDelimitedList((§ char \}), r, true, opts, ensurePending(pendingForms)).toArray()
            if ((a.length & 1) == 1)
            (§
                throw Util.runtimeException("Map literal must contain an even number of forms")
            )
            return RT.map(a)
        )
    )

    public static class SetReader extends AFn
    (§
        public Object invoke(Object reader, Object leftbracket, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            return PersistentHashSet.createWithCheck(readDelimitedList((§ char \}), r, true, opts, ensurePending(pendingForms)))
        )
    )

    public static class UnmatchedDelimiterReader extends AFn
    (§
        public Object invoke(Object reader, Object rightdelim, Object opts, Object pendingForms)
        (§
            throw Util.runtimeException("Unmatched delimiter: " + rightdelim)
        )
    )

    public static class UnreadableReader extends AFn
    (§
        public Object invoke(Object reader, Object leftangle, Object opts, Object pendingForms)
        (§
            throw Util.runtimeException("Unreadable form")
        )
    )

    ;; Sentinel values for reading lists
    private static final Object READ_EOF = new Object()
    private static final Object READ_FINISHED = new Object()

    public static List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts, Object pendingForms)
    (§
        final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1

        ArrayList a = new ArrayList()
        Resolver resolver = (Resolver) RT.READER_RESOLVER.deref()

        while (true)
        (§
            Object form = read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver)

            if (form == READ_EOF)
            (§
                if (firstline < 0)
                (§
                    throw Util.runtimeException("EOF while reading")
                )
                else
                (§
                    throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                )
            )
            else if (form == READ_FINISHED)
            (§
                return a
            )

            a.add(form)
        )
    )

    public static class CtorReader extends AFn
    (§
        public Object invoke(Object reader, Object firstChar, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            pendingForms = ensurePending(pendingForms)
            Object name = read(r, true, null, false, opts, pendingForms)
            if (!(name instanceof Symbol))
            (§
                throw new RuntimeException("Reader tag must be a symbol")
            )
            Symbol sym = (Symbol)name
            Object form = read(r, true, null, true, opts, pendingForms)

            if (isPreserveReadCond(opts) || RT.suppressRead())
            (§
                return TaggedLiteral.create(sym, form)
            )
            else
            (§
                return sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms)
            )
        )

        private Object readTagged(Object o, Symbol tag, Object opts, Object pendingForms)
        (§
            ILookup data_readers = (ILookup)RT.DATA_READERS.deref()
            IFn data_reader = (IFn)RT.get(data_readers, tag)
            if (data_reader == null)
            (§
                data_readers = (ILookup)RT.DEFAULT_DATA_READERS.deref()
                data_reader = (IFn)RT.get(data_readers, tag)
                if (data_reader == null)
                (§
                    IFn default_reader = (IFn)RT.DEFAULT_DATA_READER_FN.deref()
                    if (default_reader != null)
                    (§
                        return default_reader.invoke(tag, o)
                    )
                    else
                    (§
                        throw new RuntimeException("No reader function for tag " + tag.toString())
                    )
                )
            )

            return data_reader.invoke(o)
        )

        private Object readRecord(Object form, Symbol recordName, Object opts, Object pendingForms)
        (§
            boolean readeval = RT.booleanCast(RT.READEVAL.deref())

            if (!readeval)
            (§
                throw Util.runtimeException("Record construction syntax can only be used when *read-eval* == true")
            )

            Class recordClass = RT.classForNameNonLoading(recordName.toString())

            boolean shortForm = true

            if (form instanceof IPersistentMap)
            (§
                shortForm = false
            )
            else if (form instanceof IPersistentVector)
            (§
                shortForm = true
            )
            else
            (§
                throw Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\"")
            )

            Object ret = null
            Constructor[] allctors = ((Class)recordClass).getConstructors()

            if (shortForm)
            (§
                IPersistentVector recordEntries = (IPersistentVector)form
                boolean ctorFound = false
                for (Constructor ctor :in allctors)
                (§
                    if (ctor.getParameterTypes().length == recordEntries.count())
                    (§
                        ctorFound = true
                    )
                )

                if (!ctorFound)
                (§
                    throw Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count())
                )

                ret = Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries))
            )
            else
            (§
                IPersistentMap vals = (IPersistentMap)form
                for (ISeq s = RT.keys(vals) s != null s = s.next())
                (§
                    if (!(s.first() instanceof Keyword))
                    (§
                        throw Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString())
                    )
                )
                ret = Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ vals ))
            )

            return ret
        )
    )

    static boolean isPreserveReadCond(Object opts)
    (§
        if (RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap)
        (§
            Object readCond = ((IPersistentMap) opts).valAt(OPT_READ_COND)
            return COND_PRESERVE.equals(readCond)
        )
        else
        (§
            return false
        )
    )

    public static class ConditionalReader extends AFn
    (§
        final static private Object READ_STARTED = new Object()
        final static public Keyword DEFAULT_FEATURE = Keyword.intern(null, "default")
        final static public IPersistentSet RESERVED_FEATURES = RT.set(Keyword.intern(null, "else"), Keyword.intern(null, "none"))

        public static boolean hasFeature(Object feature, Object opts)
        (§
            if (!(feature instanceof Keyword))
            (§
                throw Util.runtimeException("Feature should be a keyword: " + feature)
            )

            if (DEFAULT_FEATURE.equals(feature))
            (§
                return true
            )

            IPersistentSet custom = (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES)
            return (custom != null && custom.contains(feature))
        )

        public static Object readCondDelimited(PushbackReader r, boolean splicing, Object opts, Object pendingForms)
        (§
            Object result = READ_STARTED
            Object form ;; The most recently ready form
            boolean toplevel = (pendingForms == null)
            pendingForms = ensurePending(pendingForms)

            final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1

            while (true)
            (§
                if (result == READ_STARTED)
                (§
                    ;; Read the next feature
                    form = read(r, false, READ_EOF, (§ char \)), READ_FINISHED, true, opts, pendingForms, null)

                    if (form == READ_EOF)
                    (§
                        if (firstline < 0)
                        (§
                            throw Util.runtimeException("EOF while reading")
                        )
                        else
                        (§
                            throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                        )
                    )
                    else if (form == READ_FINISHED)
                    (§
                        break ;; read-cond form is done
                    )

                    if (RESERVED_FEATURES.contains(form))
                    (§
                        throw Util.runtimeException("Feature name " + form + " is reserved.")
                    )

                    if (hasFeature(form, opts))
                    (§
                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                        form = read(r, false, READ_EOF, (§ char \)), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref())

                        if (form == READ_EOF)
                        (§
                            if (firstline < 0)
                            (§
                                throw Util.runtimeException("EOF while reading")
                            )
                            else
                            (§
                                throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                            )
                        )
                        else if (form == READ_FINISHED)
                        (§
                            if (firstline < 0)
                            (§
                                throw Util.runtimeException("read-cond requires an even number of forms.")
                            )
                            else
                            (§
                                throw Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms")
                            )
                        )
                        else
                        (§
                            result = form
                        )
                    )
                )

                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                try
                (§
                    Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T))
                    form = read(r, false, READ_EOF, (§ char \)), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref())

                    if (form == READ_EOF)
                    (§
                        if (firstline < 0)
                        (§
                            throw Util.runtimeException("EOF while reading")
                        )
                        else
                        (§
                            throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                        )
                    )
                    else if (form == READ_FINISHED)
                    (§
                        break
                    )
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )

            if (result == READ_STARTED) ;; no features matched
            (§
                return r
            )

            if (splicing)
            (§
                if (!(result instanceof List))
                (§
                    throw Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List")
                )

                if (toplevel)
                (§
                    throw Util.runtimeException("Reader conditional splicing not allowed at the top level.")
                )

                ((List)pendingForms).addAll(0, (List)result)

                return r
            )
            else
            (§
                return result
            )
        )

        private static void checkConditionalAllowed(Object opts)
        (§
            IPersistentMap mopts = (IPersistentMap)opts
            if (!(opts != null && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND)))))
            (§
                throw Util.runtimeException("Conditional read not allowed")
            )
        )

        public Object invoke(Object reader, Object mode, Object opts, Object pendingForms)
        (§
            checkConditionalAllowed(opts)

            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )

            boolean splicing = false

            if (ch == (§ char \@))
            (§
                splicing = true
                ch = read1(r)
            )

            while (isWhitespace(ch))
                ch = read1(r)

            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )

            if (ch != (§ char \())
            (§
                throw Util.runtimeException("read-cond body must be a list")
            )

            try
            (§
                Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T))

                if (isPreserveReadCond(opts))
                (§
                    IFn listReader = getMacro(ch) ;; should always be a list
                    Object form = listReader.invoke(r, ch, opts, ensurePending(pendingForms))

                    return ReaderConditional.create(form, splicing)
                )
                else
                (§
                    return readCondDelimited(r, splicing, opts, pendingForms)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
    )
)
)

(§ java cloiure.lang.LockingTransaction

import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.Callable
import java.util.concurrent.TimeUnit
import java.util.concurrent.CountDownLatch

@SuppressWarnings((§ "SynchronizeOnNonFinalField" ))
public class LockingTransaction
(§
    public static final int RETRY_LIMIT = 10000
    public static final int LOCK_WAIT_MSECS = 100
    public static final long BARGE_WAIT_NANOS = 10 * 1000000

    static final int RUNNING = 0
    static final int COMMITTING = 1
    static final int RETRY = 2
    static final int KILLED = 3
    static final int COMMITTED = 4

    final static ThreadLocal<LockingTransaction> transaction = new ThreadLocal<LockingTransaction>()

    static class RetryEx extends Error
    (§
    )

    static class AbortException extends Exception
    (§
    )

    public static class Info
    (§
        final AtomicInteger status
        final long startPoint
        final CountDownLatch latch

        public Info(int status, long startPoint)
        (§
            this.status = new AtomicInteger(status)
            this.startPoint = startPoint
            this.latch = new CountDownLatch(1)
        )

        public boolean running()
        (§
            int s = status.get()
            return (s == RUNNING || s == COMMITTING)
        )
    )

    static class CFn
    (§
        final IFn fn
        final ISeq args

        public CFn(IFn fn, ISeq args)
        (§
            this.fn = fn
            this.args = args
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    final private static AtomicLong lastPoint = new AtomicLong()

    void getReadPoint()
    (§
        readPoint = lastPoint.incrementAndGet()
    )

    long getCommitPoint()
    (§
        return lastPoint.incrementAndGet()
    )

    void stop(int status)
    (§
        if (info != null)
        (§
            synchronized (info)
            (§
                info.status.set(status)
                info.latch.countDown()
            )
            info = null
            vals.clear()
            sets.clear()
            commutes.clear()
        )
    )

    Info info
    long readPoint
    long startPoint
    long startTime

    final RetryEx retryex = new RetryEx()
    final ArrayList<Agent.Action> actions = new ArrayList<Agent.Action>()
    final HashMap<Ref, Object> vals = new HashMap<Ref, Object>()
    final HashSet<Ref> sets = new HashSet<Ref>()
    final TreeMap<Ref, ArrayList<CFn>> commutes = new TreeMap<Ref, ArrayList<CFn>>()

    final HashSet<Ref> ensures = new HashSet<Ref>() ;; all hold readLock

    void tryWriteLock(Ref ref)
    (§
        try
        (§
            if (!ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
            (§
                throw retryex
            )
        )
        catch (InterruptedException e)
        (§
            throw retryex
        )
    )

    ;; returns the most recent val
    Object lock(Ref ref)
    (§
        ;; can't upgrade readLock, so release it
        releaseIfEnsured(ref)

        boolean unlocked = true
        try
        (§
            tryWriteLock(ref)
            unlocked = false

            if (ref.tvals != null && ref.tvals.point > readPoint)
            (§
                throw retryex
            )
            Info refinfo = ref.tinfo

            ;; write lock conflict
            if (refinfo != null && refinfo != info && refinfo.running())
            (§
                if (!barge(refinfo))
                (§
                    ref.lock.writeLock().unlock()
                    unlocked = true
                    return blockAndBail(refinfo)
                )
            )
            ref.tinfo = info
            return (ref.tvals == null) ? null :or ref.tvals.val
        )
        finally
        (§
            if (!unlocked)
            (§
                ref.lock.writeLock().unlock()
            )
        )
    )

    private Object blockAndBail(Info refinfo)
    (§
        ;; stop prior to blocking
        stop(RETRY)
        try
        (§
            refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS)
        )
        catch (InterruptedException e)
        (§
            ;; ignore
        )
        throw retryex
    )

    private void releaseIfEnsured(Ref ref)
    (§
        if (ensures.contains(ref))
        (§
            ensures.remove(ref)
            ref.lock.readLock().unlock()
        )
    )

    void abort() throws AbortException
    (§
        stop(KILLED)
        throw new AbortException()
    )

    private boolean bargeTimeElapsed()
    (§
        return (System.nanoTime() - startTime > BARGE_WAIT_NANOS)
    )

    private boolean barge(Info refinfo)
    (§
        boolean barged = false
        ;; if this transaction is older, try to abort the other
        if (bargeTimeElapsed() && startPoint < refinfo.startPoint)
        (§
            barged = refinfo.status.compareAndSet(RUNNING, KILLED)
            if (barged)
            (§
                refinfo.latch.countDown()
            )
        )
        return barged
    )

    static LockingTransaction getEx()
    (§
        LockingTransaction t = transaction.get()
        if (t == null || t.info == null)
        (§
            throw new IllegalStateException("No transaction running")
        )
        return t
    )

    static public boolean isRunning()
    (§
        return (getRunning() != null)
    )

    static LockingTransaction getRunning()
    (§
        LockingTransaction t = transaction.get()
        if (t == null || t.info == null)
        (§
            return null
        )
        return t
    )

    static public Object runInTransaction(Callable fn) throws Exception
    (§
        LockingTransaction t = transaction.get()
        Object ret
        if (t == null)
        (§
            transaction.set(t = new LockingTransaction())
            try
            (§
                ret = t.run(fn)
            )
            finally
            (§
                transaction.remove()
            )
        )
        else
        (§
            if (t.info != null)
            (§
                ret = fn.call()
            )
            else
            (§
                ret = t.run(fn)
            )
        )

        return ret
    )

    static class Notify
    (§
        final public Ref ref
        final public Object oldval
        final public Object newval

        Notify(Ref ref, Object oldval, Object newval)
        (§
            this.ref = ref
            this.oldval = oldval
            this.newval = newval
        )
    )

    Object run(Callable fn) throws Exception
    (§
        boolean done = false
        Object ret = null
        ArrayList<Ref> locked = new ArrayList<Ref>()
        ArrayList<Notify> notify = new ArrayList<Notify>()

        for (int i = 0 !done && i < RETRY_LIMIT i++)
        (§
            try
            (§
                getReadPoint()
                if (i == 0)
                (§
                    startPoint = readPoint
                    startTime = System.nanoTime()
                )
                info = new Info(RUNNING, startPoint)
                ret = fn.call()
                ;; make sure no one has killed us before this point, and can't from now on
                if (info.status.compareAndSet(RUNNING, COMMITTING))
                (§
                    for (Map.Entry<Ref, ArrayList<CFn>> e :in commutes.entrySet())
                    (§
                        Ref ref = e.getKey()
                        if (sets.contains(ref))
                        (§
                            continue
                        )

                        boolean wasEnsured = ensures.contains(ref)
                        ;; can't upgrade readLock, so release it
                        releaseIfEnsured(ref)
                        tryWriteLock(ref)
                        locked.add(ref)
                        if (wasEnsured && ref.tvals != null && ref.tvals.point > readPoint)
                        (§
                            throw retryex
                        )

                        Info refinfo = ref.tinfo
                        if (refinfo != null && refinfo != info && refinfo.running())
                        (§
                            if (!barge(refinfo))
                            (§
                                throw retryex
                            )
                        )
                        Object val = (ref.tvals == null) ? null :or ref.tvals.val
                        vals.put(ref, val)
                        for (CFn f :in e.getValue())
                        (§
                            vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args)))
                        )
                    )
                    for (Ref ref :in sets)
                    (§
                        tryWriteLock(ref)
                        locked.add(ref)
                    )

                    ;; validate and enqueue notifications
                    for (Map.Entry<Ref, Object> e :in vals.entrySet())
                    (§
                        Ref ref = e.getKey()
                        ref.validate(ref.getValidator(), e.getValue())
                    )

                    ;; at this point, all values calced, all refs to be written locked
                    ;; no more client code to be called
                    long commitPoint = getCommitPoint()
                    for (Map.Entry<Ref, Object> e :in vals.entrySet())
                    (§
                        Ref ref = e.getKey()
                        Object oldval = (ref.tvals == null) ? null :or ref.tvals.val
                        Object newval = e.getValue()
                        int hcount = ref.histCount()

                        if (ref.tvals == null)
                        (§
                            ref.tvals = new Ref.TVal(newval, commitPoint)
                        )
                        else if ((ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory)
                        (§
                            ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals)
                            ref.faults.set(0)
                        )
                        else
                        (§
                            ref.tvals = ref.tvals.next
                            ref.tvals.val = newval
                            ref.tvals.point = commitPoint
                        )
                        if (ref.getWatches().count() > 0)
                        (§
                            notify.add(new Notify(ref, oldval, newval))
                        )
                    )

                    done = true
                    info.status.set(COMMITTED)
                )
            )
            catch (RetryEx retry)
            (§
                ;; eat this so we retry rather than fall out
            )
            finally
            (§
                for (int k = locked.size() - 1 k >= 0 --k)
                (§
                    locked.get(k).lock.writeLock().unlock()
                )
                locked.clear()
                for (Ref r :in ensures)
                (§
                    r.lock.readLock().unlock()
                )
                ensures.clear()
                stop(done ? COMMITTED :or RETRY)
                try
                (§
                    if (done) ;; re-dispatch out of transaction
                    (§
                        for (Notify n :in notify)
                        (§
                            n.ref.notifyWatches(n.oldval, n.newval)
                        )
                        for (Agent.Action action :in actions)
                        (§
                            Agent.dispatchAction(action)
                        )
                    )
                )
                finally
                (§
                    notify.clear()
                    actions.clear()
                )
            )
        )
        if (!done)
        (§
            throw Util.runtimeException("Transaction failed after reaching retry limit")
        )
        return ret
    )

    public void enqueue(Agent.Action action)
    (§
        actions.add(action)
    )

    Object doGet(Ref ref)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (vals.containsKey(ref))
        (§
            return vals.get(ref)
        )
        try
        (§
            ref.lock.readLock().lock()
            if (ref.tvals == null)
            (§
                throw new IllegalStateException(ref.toString() + " is unbound.")
            )
            Ref.TVal ver = ref.tvals
            do
            (§
                if (ver.point <= readPoint)
                (§
                    return ver.val
                )
            ) while ((ver = ver.prior) != ref.tvals)
        )
        finally
        (§
            ref.lock.readLock().unlock()
        )
        ;; no version of val precedes the read point
        ref.faults.incrementAndGet()
        throw retryex
    )

    Object doSet(Ref ref, Object val)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (commutes.containsKey(ref))
        (§
            throw new IllegalStateException("Can't set after commute")
        )
        if (!sets.contains(ref))
        (§
            sets.add(ref)
            lock(ref)
        )
        vals.put(ref, val)
        return val
    )

    void doEnsure(Ref ref)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (ensures.contains(ref))
        (§
            return
        )
        ref.lock.readLock().lock()

        ;; someone completed a write after our snapshot
        if (ref.tvals != null && ref.tvals.point > readPoint)
        (§
            ref.lock.readLock().unlock()
            throw retryex
        )

        Info refinfo = ref.tinfo

        ;; writer exists
        if (refinfo != null && refinfo.running())
        (§
            ref.lock.readLock().unlock()

            if (refinfo != info) ;; not us, ensure is doomed
            (§
                blockAndBail(refinfo)
            )
        )
        else
        (§
            ensures.add(ref)
        )
    )

    Object doCommute(Ref ref, IFn fn, ISeq args)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (!vals.containsKey(ref))
        (§
            Object val = null
            try
            (§
                ref.lock.readLock().lock()
                val = (ref.tvals == null) ? null :or ref.tvals.val
            )
            finally
            (§
                ref.lock.readLock().unlock()
            )
            vals.put(ref, val)
        )
        ArrayList<CFn> fns = commutes.get(ref)
        if (fns == null)
        (§
            commutes.put(ref, fns = new ArrayList<CFn>())
        )
        fns.add(new CFn(fn, args))
        Object ret = fn.applyTo(RT.cons(vals.get(ref), args))
        vals.put(ref, ret)
        return ret
    )
)
)

(§ java cloiure.lang.LongRange

import java.io.Serializable

import java.util.Iterator
import java.util.NoSuchElementException

;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;
public class LongRange extends ASeq implements Counted, IChunkedSeq, IReduce
(§
    private static final int CHUNK_SIZE = 32

    ;; Invariants guarantee this is never an empty or infinite seq
    final long start
    final long end
    final long step
    final BoundsCheck boundsCheck

    private volatile LongChunk _chunk ;; lazy
    private volatile ISeq _chunkNext ;; lazy
    private volatile ISeq _next ;; cached

    private static interface BoundsCheck extends Serializable
    (§
        boolean exceededBounds(long val)
    )

    private static BoundsCheck positiveStep(final long end)
    (§
        return new BoundsCheck()
        (§
            public boolean exceededBounds(long val)
            (§
                return (val >= end)
            )
        )
    )

    private static BoundsCheck negativeStep(final long end)
    (§
        return new BoundsCheck()
        (§
            public boolean exceededBounds(long val)
            (§
                return (val <= end)
            )
        )
    )

    private LongRange(long start, long end, long step, BoundsCheck boundsCheck)
    (§
        this.start = start
        this.end = end
        this.step = step
        this.boundsCheck = boundsCheck
    )

    private LongRange(long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
    (§
        this.start = start
        this.end = end
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    private LongRange(IPersistentMap meta, long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
    (§
        super(meta)
        this.start = start
        this.end = end
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    public static ISeq create(long end)
    (§
        if (end > 0)
        (§
            return new LongRange(0(§ L), end, 1(§ L), positiveStep(end))
        )
        return PersistentList.EMPTY
    )

    public static ISeq create(long start, long end)
    (§
        if (start >= end)
        (§
            return PersistentList.EMPTY
        )
        return new LongRange(start, end, 1(§ L), positiveStep(end))
    )

    public static ISeq create(final long start, long end, long step)
    (§
        if (step > 0)
        (§
            if (end <= start)
            (§
                return PersistentList.EMPTY
            )
            return new LongRange(start, end, step, positiveStep(end))
        )
        else if (step < 0)
        (§
            if (end >= start)
            (§
                return PersistentList.EMPTY
            )
            return new LongRange(start, end, step, negativeStep(end))
        )
        else
        (§
            if (end == start)
            (§
                return PersistentList.EMPTY
            )
            return Repeat.create(start)
        )
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta == _meta)
        (§
            return this
        )
        return new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext)
    )

    public Object first()
    (§
        return start
    )

    public void forceChunk()
    (§
        if (_chunk != null)
        (§
            return
        )

        long count
        try
        (§
            count = rangeCount(start, end, step)
        )
        catch (ArithmeticException e)
        (§
            ;; size of total range is > Long.MAX_VALUE so must step to count
            ;; this only happens in pathological range cases like:
            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
            count = steppingCount(start, end, step)
        )

        if (count > CHUNK_SIZE) ;; not last chunk
        (§
            long nextStart = start + (step * CHUNK_SIZE) ;; cannot overflow, must be < end
            _chunkNext = new LongRange(nextStart, end, step, boundsCheck)
            _chunk = new LongChunk(start, step, CHUNK_SIZE)
        )
        else ;; last chunk
        (§
            _chunk = new LongChunk(start, step, (int) count) ;; count must be <= CHUNK_SIZE
        )
    )

    public ISeq next()
    (§
        if (_next != null)
        (§
            return _next
        )

        forceChunk()
        if (_chunk.count() > 1)
        (§
            LongChunk smallerChunk = _chunk.dropFirst()
            _next = new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext)
            return _next
        )
        return chunkedNext()
    )

    public IChunk chunkedFirst()
    (§
        forceChunk()
        return _chunk
    )

    public ISeq chunkedNext()
    (§
        return chunkedMore().seq()
    )

    public ISeq chunkedMore()
    (§
        forceChunk()
        if (_chunkNext == null)
        (§
            return PersistentList.EMPTY
        )
        return _chunkNext
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    long steppingCount(long start, long end, long step)
    (§
        long count = 1
        long s = start
        while (count <= CHUNK_SIZE)
        (§
            try
            (§
                s = Numbers.add(s, step)
                if (boundsCheck.exceededBounds(s))
                (§
                    break
                )
                else
                (§
                    count++
                )
            )
            catch (ArithmeticException e)
            (§
                break
            )
        )
        return count
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    long rangeCount(long start, long end, long step)
    (§
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        return Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step
    )

    public int count()
    (§
        try
        (§
            long c = rangeCount(start, end, step)
            if (c > Integer.MAX_VALUE)
            (§
                return Numbers.throwIntOverflow()
            )
            else
            (§
                return (int) c
            )
        )
        catch (ArithmeticException e)
        (§
            ;; rare case from large range or step, fall back to iterating and counting
            Iterator iter = this.iterator()
            long count = 0
            while (iter.hasNext())
            (§
                iter.next()
                count++
            )

            if (count > Integer.MAX_VALUE)
            (§
                return Numbers.throwIntOverflow()
            )
            else
            (§
                return (int)count
            )
        )
    )

    public Object reduce(IFn f)
    (§
        Object acc = start
        long i = start + step
        while (!boundsCheck.exceededBounds(i))
        (§
            acc = f.invoke(acc, i)
            if (acc instanceof Reduced)
            (§
                return ((Reduced)acc).deref()
            )
            i += step
        )
        return acc
    )

    public Object reduce(IFn f, Object val)
    (§
        Object acc = val
        long i = start
        do
        (§
            acc = f.invoke(acc, i)
            if (RT.isReduced(acc))
            (§
                return ((Reduced)acc).deref()
            )
            i += step
        ) while (!boundsCheck.exceededBounds(i))
        return acc
    )

    public Iterator iterator()
    (§
        return new LongRangeIterator()
    )

    class LongRangeIterator implements Iterator
    (§
        private long next
        private boolean hasNext

        public LongRangeIterator()
        (§
            this.next = start
            this.hasNext = true
        )

        public boolean hasNext()
        (§
            return hasNext
        )

        public Object next()
        (§
            if (hasNext)
            (§
                long ret = next
                try
                (§
                    next = Numbers.add(next, step)
                    hasNext = !boundsCheck.exceededBounds(next)
                )
                catch (ArithmeticException e)
                (§
                    hasNext = false
                )
                return ret
            )
            else
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    private static class LongChunk implements IChunk, Serializable
    (§
        final long start
        final long step
        final int count

        public LongChunk(long start, long step, int count)
        (§
            this.start = start
            this.step = step
            this.count = count
        )

        public long first()
        (§
            return start
        )

        public Object nth(int i)
        (§
            return start + (i * step)
        )

        public Object nth(int i, Object notFound)
        (§
            if (i >= 0 && i < count)
            (§
                return start + (i * step)
            )
            return notFound
        )

        public int count()
        (§
            return count
        )

        public LongChunk dropFirst()
        (§
            if (count <= 1)
            (§
                throw new IllegalStateException("dropFirst of empty chunk")
            )
            return new LongChunk(start + step, step, count - 1)
        )

        public Object reduce(IFn f, Object init)
        (§
            long x = start
            Object ret = init
            for (int i = 0 i < count i++)
            (§
                ret = f.invoke(ret, x)
                if (RT.isReduced(ret))
                (§
                    return ret
                )
                x += step
            )
            return ret
        )
    )
)
)

(§ java cloiure.lang.MapEntry

import java.util.Iterator

public class MapEntry extends AMapEntry
(§
    final Object _key
    final Object _val

    static public MapEntry create(Object key, Object val)
    (§
        return new MapEntry(key, val)
    )

    public MapEntry(Object key, Object val)
    (§
        this._key = key
        this._val = val
    )

    public Object key()
    (§
        return _key
    )

    public Object val()
    (§
        return _val
    )

    public Object getKey()
    (§
        return key()
    )

    public Object getValue()
    (§
        return val()
    )
)
)

(§ java cloiure.lang.MapEquivalence

;; marker interface
public interface MapEquivalence
(§
)
)

(§ java cloiure.lang.MethodImplCache

import java.util.Map

public final class MethodImplCache
(§
    static public class Entry
    (§
        final public Class c
        final public IFn fn

        public Entry(Class c, IFn fn)
        (§
            this.c = c
            this.fn = fn
        )
    )

    public final IPersistentMap protocol
    public final Keyword methodk
    public final int shift
    public final int mask
    public final Object[] table ;; [class, entry. class, entry ...]
    public final Map map

    Entry mre = null

    public MethodImplCache(IPersistentMap protocol, Keyword methodk)
    (§
        this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY)
    )

    public MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table)
    (§
        this.protocol = protocol
        this.methodk = methodk
        this.shift = shift
        this.mask = mask
        this.table = table
        this.map = null
    )

    public MethodImplCache(IPersistentMap protocol, Keyword methodk, Map map)
    (§
        this.protocol = protocol
        this.methodk = methodk
        this.shift = 0
        this.mask = 0
        this.table = null
        this.map = map
    )

    public IFn fnFor(Class c)
    (§
        Entry last = mre
        if (last != null && last.c == c)
        (§
            return last.fn
        )
        return findFnFor(c)
    )

    IFn findFnFor(Class c)
    (§
        if (map != null)
        (§
            Entry e = (Entry) map.get(c)
            mre = e
            return (e != null) ? e.fn :or null
        )
        else
        (§
            int idx = ((Util.hash(c) >> shift) & mask) << 1
            if (idx < table.length && table[idx] == c)
            (§
                Entry e = ((Entry) table[idx + 1])
                mre = e
                return (e != null) ? e.fn :or null
            )
            return null
        )
    )
)
)

(§ java cloiure.lang.MultiFn

import java.util.Map
import java.util.concurrent.locks.ReentrantReadWriteLock

public class MultiFn extends AFn
(§
    final public IFn dispatchFn
    final public Object defaultDispatchVal
    final public IRef hierarchy
    final String name
    final ReentrantReadWriteLock rw

    volatile IPersistentMap methodTable
    volatile IPersistentMap preferTable
    volatile IPersistentMap methodCache
    volatile Object cachedHierarchy

    static final Var assoc = RT.var("cloiure.core", "assoc")
    static final Var dissoc = RT.var("cloiure.core", "dissoc")
    static final Var isa = RT.var("cloiure.core", "isa?")
    static final Var parents = RT.var("cloiure.core", "parents")

    public MultiFn(String name, IFn dispatchFn, Object defaultDispatchVal, IRef hierarchy)
    (§
        this.rw = new ReentrantReadWriteLock()
        this.name = name
        this.dispatchFn = dispatchFn
        this.defaultDispatchVal = defaultDispatchVal
        this.methodTable = PersistentHashMap.EMPTY
        this.methodCache = getMethodTable()
        this.preferTable = PersistentHashMap.EMPTY
        this.hierarchy = hierarchy
        cachedHierarchy = null
    )

    public MultiFn reset()
    (§
        rw.writeLock().lock()
        try
        (§
            methodTable = methodCache = preferTable = PersistentHashMap.EMPTY
            cachedHierarchy = null
            return this
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public MultiFn addMethod(Object dispatchVal, IFn method)
    (§
        rw.writeLock().lock()
        try
        (§
            methodTable = getMethodTable().assoc(dispatchVal, method)
            resetCache()
            return this
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public MultiFn removeMethod(Object dispatchVal)
    (§
        rw.writeLock().lock()
        try
        (§
            methodTable = getMethodTable().without(dispatchVal)
            resetCache()
            return this
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public MultiFn preferMethod(Object dispatchValX, Object dispatchValY)
    (§
        rw.writeLock().lock()
        try
        (§
            if (prefers(dispatchValY, dispatchValX))
            (§
                throw new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX))
            )
            preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY))
            resetCache()
            return this
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    private boolean prefers(Object x, Object y)
    (§
        IPersistentSet xprefs = (IPersistentSet) getPreferTable().valAt(x)
        if (xprefs != null && xprefs.contains(y))
        (§
            return true
        )
        for (ISeq ps = RT.seq(parents.invoke(y)) ps != null ps = ps.next())
        (§
            if (prefers(x, ps.first()))
            (§
                return true
            )
        )
        for (ISeq ps = RT.seq(parents.invoke(x)) ps != null ps = ps.next())
        (§
            if (prefers(ps.first(), y))
            (§
                return true
            )
        )
        return false
    )

    private boolean isA(Object x, Object y)
    (§
        return RT.booleanCast(isa.invoke(hierarchy.deref(), x, y))
    )

    private boolean dominates(Object x, Object y)
    (§
        return prefers(x, y) || isA(x, y)
    )

    private IPersistentMap resetCache()
    (§
        rw.writeLock().lock()
        try
        (§
            methodCache = getMethodTable()
            cachedHierarchy = hierarchy.deref()
            return methodCache
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public IFn getMethod(Object dispatchVal)
    (§
        if (cachedHierarchy != hierarchy.deref())
        (§
            resetCache()
        )
        IFn targetFn = (IFn) methodCache.valAt(dispatchVal)
        if (targetFn != null)
        (§
            return targetFn
        )
        return findAndCacheBestMethod(dispatchVal)
    )

    private IFn getFn(Object dispatchVal)
    (§
        IFn targetFn = getMethod(dispatchVal)
        if (targetFn == null)
        (§
            throw new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal))
        )
        return targetFn
    )

    private IFn findAndCacheBestMethod(Object dispatchVal)
    (§
        rw.readLock().lock()
        Object bestValue
        IPersistentMap mt = methodTable
        IPersistentMap pt = preferTable
        Object ch = cachedHierarchy
        try
        (§
            Map.Entry bestEntry = null
            for (Object o :in getMethodTable())
            (§
                Map.Entry e = (Map.Entry) o
                if (isA(dispatchVal, e.getKey()))
                (§
                    if (bestEntry == null || dominates(e.getKey(), bestEntry.getKey()))
                    (§
                        bestEntry = e
                    )
                    if (!dominates(bestEntry.getKey(), e.getKey()))
                    (§
                        throw new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey()))
                    )
                )
            )
            if (bestEntry == null)
            (§
                bestValue = methodTable.valAt(defaultDispatchVal)
                if (bestValue == null)
                (§
                    return null
                )
            )
            else
            (§
                bestValue = bestEntry.getValue()
            )
        )
        finally
        (§
            rw.readLock().unlock()
        )

        ;; ensure basis has stayed stable throughout, else redo
        rw.writeLock().lock()
        try
        (§
            if (mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
            (§
                ;; place in cache
                methodCache = methodCache.assoc(dispatchVal, bestValue)
                return (IFn) bestValue
            )
            else
            (§
                resetCache()
                return findAndCacheBestMethod(dispatchVal)
            )
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public Object invoke()
    (§
        return getFn(dispatchFn.invoke()).invoke()
    )

    public Object invoke(Object arg1)
    (§
        return getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, arg1 = null))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2)).
            invoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3)).
            invoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null),
                    Util.ret1(arg16, arg16 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null),
                    Util.ret1(arg16, arg16 = null),
                    Util.ret1(arg17, arg17 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null),
                    Util.ret1(arg16, arg16 = null),
                    Util.ret1(arg17, arg17 = null),
                    Util.ret1(arg18, arg18 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null),
                    Util.ret1(arg16, arg16 = null),
                    Util.ret1(arg17, arg17 = null),
                    Util.ret1(arg18, arg18 = null),
                    Util.ret1(arg19, arg19 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null),
                    Util.ret1(arg16, arg16 = null),
                    Util.ret1(arg17, arg17 = null),
                    Util.ret1(arg18, arg18 = null),
                    Util.ret1(arg19, arg19 = null),
                    Util.ret1(arg20, arg20 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
    (§
        return getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20, args)).
            invoke(Util.ret1(arg1, arg1 = null),
                    Util.ret1(arg2, arg2 = null),
                    Util.ret1(arg3, arg3 = null),
                    Util.ret1(arg4, arg4 = null),
                    Util.ret1(arg5, arg5 = null),
                    Util.ret1(arg6, arg6 = null),
                    Util.ret1(arg7, arg7 = null),
                    Util.ret1(arg8, arg8 = null),
                    Util.ret1(arg9, arg9 = null),
                    Util.ret1(arg10, arg10 = null),
                    Util.ret1(arg11, arg11 = null),
                    Util.ret1(arg12, arg12 = null),
                    Util.ret1(arg13, arg13 = null),
                    Util.ret1(arg14, arg14 = null),
                    Util.ret1(arg15, arg15 = null),
                    Util.ret1(arg16, arg16 = null),
                    Util.ret1(arg17, arg17 = null),
                    Util.ret1(arg18, arg18 = null),
                    Util.ret1(arg19, arg19 = null),
                    Util.ret1(arg20, arg20 = null),
                    args)
    )

    public IPersistentMap getMethodTable()
    (§
        return methodTable
    )

    public IPersistentMap getPreferTable()
    (§
        return preferTable
    )
)
)

(§ java cloiure.lang.Murmur3
;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;

;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;

;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;

import java.io.Serializable
import java.nio.ByteBuffer

;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;
public final class Murmur3
(§
    private static final int seed = 0
    private static final int C1 = 0xcc9e2d51
    private static final int C2 = 0x1b873593

    public static int hashInt(int input)
    (§
        if (input == 0)
        (§
            return 0
        )
        int k1 = mixK1(input)
        int h1 = mixH1(seed, k1)

        return fmix(h1, 4)
    )

    public static int hashLong(long input)
    (§
        if (input == 0)
        (§
            return 0
        )
        int low = (int) input
        int high = (int) (input >>> 32)

        int k1 = mixK1(low)
        int h1 = mixH1(seed, k1)

        k1 = mixK1(high)
        h1 = mixH1(h1, k1)

        return fmix(h1, 8)
    )

    public static int hashUnencodedChars(CharSequence input)
    (§
        int h1 = seed

        ;; step through the CharSequence 2 chars at a time
        for (int i = 1 i < input.length() i += 2)
        (§
            int k1 = input.charAt(i - 1) | (input.charAt(i) << 16)
            k1 = mixK1(k1)
            h1 = mixH1(h1, k1)
        )

        ;; deal with any remaining characters
        if ((input.length() & 1) == 1)
        (§
            int k1 = input.charAt(input.length() - 1)
            k1 = mixK1(k1)
            h1 ^= k1
        )

        return fmix(h1, 2 * input.length())
    )

    public static int mixCollHash(int hash, int count)
    (§
        int h1 = seed
        int k1 = mixK1(hash)
        h1 = mixH1(h1, k1)
        return fmix(h1, count)
    )

    public static int hashOrdered(Iterable xs)
    (§
        int n = 0
        int hash = 1

        for (Object x :in xs)
        (§
            hash = 31 * hash + Util.hasheq(x)
            ++n
        )

        return mixCollHash(hash, n)
    )

    public static int hashUnordered(Iterable xs)
    (§
        int hash = 0
        int n = 0
        for (Object x :in xs)
        (§
            hash += Util.hasheq(x)
            ++n
        )

        return mixCollHash(hash, n)
    )

    private static int mixK1(int k1)
    (§
        k1 *= C1
        k1 = Integer.rotateLeft(k1, 15)
        k1 *= C2
        return k1
    )

    private static int mixH1(int h1, int k1)
    (§
        h1 ^= k1
        h1 = Integer.rotateLeft(h1, 13)
        h1 = h1 * 5 + 0xe6546b64
        return h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    private static int fmix(int h1, int length)
    (§
        h1 ^= length
        h1 ^= h1 >>> 16
        h1 *= 0x85ebca6b
        h1 ^= h1 >>> 13
        h1 *= 0xc2b2ae35
        h1 ^= h1 >>> 16
        return h1
    )
)
)

(§ java cloiure.lang.Named

public interface Named
(§
    String getNamespace()

    String getName()
)
)

(§ java cloiure.lang.Namespace

import java.io.ObjectStreamException
import java.io.Serializable
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicReference

public class Namespace extends AReference implements Serializable
(§
    final public Symbol name

    transient final AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>()
    transient final AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>()

    final static ConcurrentHashMap<Symbol, Namespace> namespaces = new ConcurrentHashMap<Symbol, Namespace>()

    public String toString()
    (§
        return name.toString()
    )

    Namespace(Symbol name)
    (§
        super(name.meta())
        this.name = name
        mappings.set(RT.DEFAULT_IMPORTS)
        aliases.set(RT.map())
    )

    public static ISeq all()
    (§
        return RT.seq(namespaces.values())
    )

    public Symbol getName()
    (§
        return name
    )

    public IPersistentMap getMappings()
    (§
        return mappings.get()
    )

    public Var intern(Symbol sym)
    (§
        if (sym.ns != null)
        (§
            throw new IllegalArgumentException("Can't intern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        Object o
        Var v = null
        while ((o = map.valAt(sym)) == null)
        (§
            if (v == null)
            (§
                v = new Var(this, sym)
            )
            IPersistentMap newMap = map.assoc(sym, v)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
        )
        if (o instanceof Var && ((Var) o).ns == this)
        (§
            return (Var) o
        )

        if (v == null)
        (§
            v = new Var(this, sym)
        )

        warnOrFailOnReplace(sym, o, v)

        while (!mappings.compareAndSet(map, map.assoc(sym, v)))
            map = getMappings()

        return v
    )

    private void warnOrFailOnReplace(Symbol sym, Object o, Object v)
    (§
        if (o instanceof Var)
        (§
            Namespace ns = ((Var)o).ns
            if (ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOIURE_NS))
            (§
                return
            )
            if (ns != RT.CLOIURE_NS)
            (§
                throw new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name)
            )
        )
        RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v)
    )

    Object reference(Symbol sym, Object val)
    (§
        if (sym.ns != null)
        (§
            throw new IllegalArgumentException("Can't intern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        Object o
        while ((o = map.valAt(sym)) == null)
        (§
            IPersistentMap newMap = map.assoc(sym, val)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
        )
        if (o == val)
        (§
            return o
        )

        warnOrFailOnReplace(sym, o, val)

        while (!mappings.compareAndSet(map, map.assoc(sym, val)))
            map = getMappings()

        return val
    )

    public static boolean areDifferentInstancesOfSameClassName(Class cls1, Class cls2)
    (§
        return (cls1 != cls2) && (cls1.getName().equals(cls2.getName()))
    )

    Class referenceClass(Symbol sym, Class val)
    (§
        if (sym.ns != null)
        (§
            throw new IllegalArgumentException("Can't intern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        Class c = (Class) map.valAt(sym)
        while ((c == null) || (areDifferentInstancesOfSameClassName(c, val)))
        (§
            IPersistentMap newMap = map.assoc(sym, val)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
            c = (Class) map.valAt(sym)
        )
        if (c == val)
        (§
            return c
        )

        throw new IllegalStateException(sym + " already refers to: " + c + " in namespace: " + name)
    )

    public void unmap(Symbol sym)
    (§
        if (sym.ns != null)
        (§
            throw new IllegalArgumentException("Can't unintern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        while (map.containsKey(sym))
        (§
            IPersistentMap newMap = map.without(sym)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
        )
    )

    public Class importClass(Symbol sym, Class c)
    (§
        return referenceClass(sym, c)
    )

    public Class importClass(Class c)
    (§
        String n = c.getName()
        return importClass(Symbol.intern(n.substring(n.lastIndexOf((§ char \.)) + 1)), c)
    )

    public Var refer(Symbol sym, Var var)
    (§
        return (Var) reference(sym, var)
    )

    public static Namespace findOrCreate(Symbol name)
    (§
        Namespace ns = namespaces.get(name)
        if (ns != null)
        (§
            return ns
        )
        Namespace newns = new Namespace(name)
        ns = namespaces.putIfAbsent(name, newns)
        return (ns == null) ? newns :or ns
    )

    public static Namespace remove(Symbol name)
    (§
        if (name.equals(RT.CLOIURE_NS.name))
        (§
            throw new IllegalArgumentException("Cannot remove cloiure namespace")
        )
        return namespaces.remove(name)
    )

    public static Namespace find(Symbol name)
    (§
        return namespaces.get(name)
    )

    public Object getMapping(Symbol name)
    (§
        return mappings.get().valAt(name)
    )

    public Var findInternedVar(Symbol symbol)
    (§
        Object o = mappings.get().valAt(symbol)
        if (o != null && o instanceof Var && ((Var) o).ns == this)
        (§
            return (Var) o
        )
        return null
    )

    public IPersistentMap getAliases()
    (§
        return aliases.get()
    )

    public Namespace lookupAlias(Symbol alias)
    (§
        IPersistentMap map = getAliases()
        return (Namespace) map.valAt(alias)
    )

    public void addAlias(Symbol alias, Namespace ns)
    (§
        if (alias == null || ns == null)
        (§
            throw new NullPointerException("Expecting Symbol + Namespace")
        )
        IPersistentMap map = getAliases()
        while (!map.containsKey(alias))
        (§
            IPersistentMap newMap = map.assoc(alias, ns)
            aliases.compareAndSet(map, newMap)
            map = getAliases()
        )
        ;; you can rebind an alias, but only to the initially-aliased namespace.
        if (!map.valAt(alias).equals(ns))
        (§
            throw new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias))
        )
    )

    public void removeAlias(Symbol alias)
    (§
        IPersistentMap map = getAliases()
        while (map.containsKey(alias))
        (§
            IPersistentMap newMap = map.without(alias)
            aliases.compareAndSet(map, newMap)
            map = getAliases()
        )
    )

    private Object readResolve() throws ObjectStreamException
    (§
        ;; ensures that serialized namespaces are "deserialized" to the
        ;; namespace in the present runtime
        return findOrCreate(name)
    )
)
)

(§ java cloiure.lang.Numbers

import java.math.BigInteger
import java.math.BigDecimal
import java.math.MathContext

public class Numbers
(§
    static interface Ops
    (§
        Ops combine(Ops y)

        Ops opsWith(LongOps x)

        Ops opsWith(DoubleOps x)

        Ops opsWith(RatioOps x)

        Ops opsWith(BigIntOps x)

        Ops opsWith(BigDecimalOps x)

        public boolean isZero(Number x)

        public boolean isPos(Number x)

        public boolean isNeg(Number x)

        public Number add(Number x, Number y)
        public Number addP(Number x, Number y)

        public Number multiply(Number x, Number y)
        public Number multiplyP(Number x, Number y)

        public Number divide(Number x, Number y)

        public Number quotient(Number x, Number y)

        public Number remainder(Number x, Number y)

        public boolean equiv(Number x, Number y)

        public boolean lt(Number x, Number y)
        public boolean lte(Number x, Number y)
        public boolean gte(Number x, Number y)

        public Number negate(Number x)
        public Number negateP(Number x)

        public Number inc(Number x)
        public Number incP(Number x)

        public Number dec(Number x)
        public Number decP(Number x)
    )

    static abstract class OpsP implements Ops
    (§
        public Number addP(Number x, Number y)
        (§
            return add(x, y)
        )

        public Number multiplyP(Number x, Number y)
        (§
            return multiply(x, y)
        )

        public Number negateP(Number x)
        (§
            return negate(x)
        )

        public Number incP(Number x)
        (§
            return inc(x)
        )

        public Number decP(Number x)
        (§
            return dec(x)
        )
    )

    static public boolean isZero(Object x)
    (§
        return ops(x).isZero((Number)x)
    )

    static public boolean isPos(Object x)
    (§
        return ops(x).isPos((Number)x)
    )

    static public boolean isNeg(Object x)
    (§
        return ops(x).isNeg((Number)x)
    )

    static public Number minus(Object x)
    (§
        return ops(x).negate((Number)x)
    )

    static public Number minusP(Object x)
    (§
        return ops(x).negateP((Number)x)
    )

    static public Number inc(Object x)
    (§
        return ops(x).inc((Number)x)
    )

    static public Number incP(Object x)
    (§
        return ops(x).incP((Number)x)
    )

    static public Number dec(Object x)
    (§
        return ops(x).dec((Number)x)
    )

    static public Number decP(Object x)
    (§
        return ops(x).decP((Number)x)
    )

    static public Number add(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).add((Number)x, (Number)y)
    )

    static public Number addP(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).addP((Number)x, (Number)y)
    )

    static public Number minus(Object x, Object y)
    (§
        Ops yops = ops(y)
        return ops(x).combine(yops).add((Number)x, yops.negate((Number)y))
    )

    static public Number minusP(Object x, Object y)
    (§
        Ops yops = ops(y)
        Number negativeY = yops.negateP((Number) y)
        Ops negativeYOps = ops(negativeY)
        return ops(x).combine(negativeYOps).addP((Number)x, negativeY)
    )

    static public Number multiply(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).multiply((Number)x, (Number)y)
    )

    static public Number multiplyP(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y)
    )

    static public Number divide(Object x, Object y)
    (§
        if (isNaN(x))
        (§
            return (Number)x
        )
        else if (isNaN(y))
        (§
            return (Number)y
        )
        Ops yops = ops(y)
        if (yops.isZero((Number)y))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        return ops(x).combine(yops).divide((Number)x, (Number)y)
    )

    static public Number quotient(Object x, Object y)
    (§
        Ops yops = ops(y)
        if (yops.isZero((Number) y))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        return ops(x).combine(yops).quotient((Number)x, (Number)y)
    )

    static public Number remainder(Object x, Object y)
    (§
        Ops yops = ops(y)
        if (yops.isZero((Number) y))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        return ops(x).combine(yops).remainder((Number)x, (Number)y)
    )

    static public double quotient(double n, double d)
    (§
        if (d == 0)
        (§
            throw new ArithmeticException("Divide by zero")
        )

        double q = n / d
        if (q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
        (§
            return (double)(long) q
        )
        else ;; bigint quotient
        (§
            return new BigDecimal(q).toBigInteger().doubleValue()
        )
    )

    static public double remainder(double n, double d)
    (§
        if (d == 0)
        (§
            throw new ArithmeticException("Divide by zero")
        )

        double q = n / d
        if (q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
        (§
            return (n - ((long) q) * d)
        )
        else ;; bigint quotient
        (§
            Number bq = new BigDecimal(q).toBigInteger()
            return (n - bq.doubleValue() * d)
        )
    )

    static public boolean equiv(Object x, Object y)
    (§
        return equiv((Number) x, (Number) y)
    )

    static public boolean equiv(Number x, Number y)
    (§
        return ops(x).combine(ops(y)).equiv(x, y)
    )

    static public boolean equal(Number x, Number y)
    (§
        return (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y))
    )

    static public boolean lt(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).lt((Number)x, (Number)y)
    )

    static public boolean lte(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).lte((Number)x, (Number)y)
    )

    static public boolean gt(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).lt((Number)y, (Number)x)
    )

    static public boolean gte(Object x, Object y)
    (§
        return ops(x).combine(ops(y)).gte((Number)x, (Number)y)
    )

    static public int compare(Number x, Number y)
    (§
        Ops ops = ops(x).combine(ops(y))
        if (ops.lt(x, y))
        (§
            return -1
        )
        else if (ops.lt(y, x))
        (§
            return 1
        )
        return 0
    )

    @WarnBoxedMath(false)
    static BigInt toBigInt(Object x)
    (§
        if (x instanceof BigInt)
        (§
            return (BigInt) x
        )
        if (x instanceof BigInteger)
        (§
            return BigInt.fromBigInteger((BigInteger) x)
        )
        else
        (§
            return BigInt.fromLong(((Number) x).longValue())
        )
    )

    @WarnBoxedMath(false)
    static BigInteger toBigInteger(Object x)
    (§
        if (x instanceof BigInteger)
        (§
            return (BigInteger) x
        )
        else if (x instanceof BigInt)
        (§
            return ((BigInt) x).toBigInteger()
        )
        else
        (§
            return BigInteger.valueOf(((Number) x).longValue())
        )
    )

    @WarnBoxedMath(false)
    static BigDecimal toBigDecimal(Object x)
    (§
        if (x instanceof BigDecimal)
        (§
            return (BigDecimal) x
        )
        else if (x instanceof BigInt)
        (§
            BigInt bi = (BigInt) x
            if (bi.bipart == null)
            (§
                return BigDecimal.valueOf(bi.lpart)
            )
            else
            (§
                return new BigDecimal(bi.bipart)
            )
        )
        else if (x instanceof BigInteger)
        (§
            return new BigDecimal((BigInteger) x)
        )
        else if (x instanceof Double)
        (§
            return new BigDecimal(((Number) x).doubleValue())
        )
        else if (x instanceof Float)
        (§
            return new BigDecimal(((Number) x).doubleValue())
        )
        else if (x instanceof Ratio)
        (§
            Ratio r = (Ratio)x
            return (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator)
        )
        else
        (§
            return BigDecimal.valueOf(((Number) x).longValue())
        )
    )

    @WarnBoxedMath(false)
    static public Ratio toRatio(Object x)
    (§
        if (x instanceof Ratio)
        (§
            return (Ratio) x
        )
        else if (x instanceof BigDecimal)
        (§
            BigDecimal bx = (BigDecimal) x
            BigInteger bv = bx.unscaledValue()
            int scale = bx.scale()
            if (scale < 0)
            (§
                return new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)
            )
            else
            (§
                return new Ratio(bv, BigInteger.TEN.pow(scale))
            )
        )
        return new Ratio(toBigInteger(x), BigInteger.ONE)
    )

    @WarnBoxedMath(false)
    static public Number rationalize(Number x)
    (§
        if (x instanceof Float || x instanceof Double)
        (§
            return rationalize(BigDecimal.valueOf(x.doubleValue()))
        )
        else if (x instanceof BigDecimal)
        (§
            BigDecimal bx = (BigDecimal) x
            BigInteger bv = bx.unscaledValue()
            int scale = bx.scale()
            if (scale < 0)
            (§
                return BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))
            )
            else
            (§
                return divide(bv, BigInteger.TEN.pow(scale))
            )
        )
        return x
    )

    @WarnBoxedMath(false)
    static public Number reduceBigInt(BigInt val)
    (§
        if (val.bipart == null)
        (§
            return num(val.lpart)
        )
        else
        (§
            return val.bipart
        )
    )

    static public Number divide(BigInteger n, BigInteger d)
    (§
        if (d.equals(BigInteger.ZERO))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        BigInteger gcd = n.gcd(d)
        if (gcd.equals(BigInteger.ZERO))
        (§
            return BigInt.ZERO
        )
        n = n.divide(gcd)
        d = d.divide(gcd)
        if (d.equals(BigInteger.ONE))
        (§
            return BigInt.fromBigInteger(n)
        )
        else if (d.equals(BigInteger.ONE.negate()))
        (§
            return BigInt.fromBigInteger(n.negate())
        )
        return new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d))
    )

    static public int shiftLeftInt(int x, int n)
    (§
        return x << n
    )

    static public long shiftLeft(Object x, Object y)
    (§
        return shiftLeft(bitOpsCast(x), bitOpsCast(y))
    )
    static public long shiftLeft(Object x, long y)
    (§
        return shiftLeft(bitOpsCast(x), y)
    )
    static public long shiftLeft(long x, Object y)
    (§
        return shiftLeft(x, bitOpsCast(y))
    )
    static public long shiftLeft(long x, long n)
    (§
        return x << n
    )

    static public int shiftRightInt(int x, int n)
    (§
        return x >> n
    )

    static public long shiftRight(Object x, Object y)
    (§
        return shiftRight(bitOpsCast(x), bitOpsCast(y))
    )
    static public long shiftRight(Object x, long y)
    (§
        return shiftRight(bitOpsCast(x), y)
    )
    static public long shiftRight(long x, Object y)
    (§
        return shiftRight(x, bitOpsCast(y))
    )
    static public long shiftRight(long x, long n)
    (§
        return x >> n
    )

    static public int unsignedShiftRightInt(int x, int n)
    (§
        return x >>> n
    )

    static public long unsignedShiftRight(Object x, Object y)
    (§
        return unsignedShiftRight(bitOpsCast(x), bitOpsCast(y))
    )
    static public long unsignedShiftRight(Object x, long y)
    (§
        return unsignedShiftRight(bitOpsCast(x), y)
    )
    static public long unsignedShiftRight(long x, Object y)
    (§
        return unsignedShiftRight(x, bitOpsCast(y))
    )
    static public long unsignedShiftRight(long x, long n)
    (§
        return x >>> n
    )

    final static class LongOps implements Ops
    (§
        public Ops combine(Ops y)
        (§
            return y.opsWith(this)
        )

        final public Ops opsWith(LongOps x)
        (§
            return this
        )

        final public Ops opsWith(DoubleOps x)
        (§
            return DOUBLE_OPS
        )

        final public Ops opsWith(RatioOps x)
        (§
            return RATIO_OPS
        )

        final public Ops opsWith(BigIntOps x)
        (§
            return BIGINT_OPS
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            return BIGDECIMAL_OPS
        )

        public boolean isZero(Number x)
        (§
            return (x.longValue() == 0)
        )

        public boolean isPos(Number x)
        (§
            return (x.longValue() > 0)
        )

        public boolean isNeg(Number x)
        (§
            return (x.longValue() < 0)
        )

        final public Number add(Number x, Number y)
        (§
            return num(Numbers.add(x.longValue(), y.longValue()))
        )

        final public Number addP(Number x, Number y)
        (§
            long lx = x.longValue(), ly = y.longValue()
            long ret = lx + ly
            if ((ret :xor lx) < 0 && (ret :xor ly) < 0)
            (§
                return BIGINT_OPS.add(x, y)
            )
            return num(ret)
        )

        final public Number multiply(Number x, Number y)
        (§
            return num(Numbers.multiply(x.longValue(), y.longValue()))
        )

        final public Number multiplyP(Number x, Number y)
        (§
            long lx = x.longValue(), ly = y.longValue()
            if (lx == Long.MIN_VALUE && ly < 0)
            (§
                return BIGINT_OPS.multiply(x, y)
            )
            long ret = lx * ly
            if (ly != 0 && ret/ly != lx)
            (§
                return BIGINT_OPS.multiply(x, y)
            )
            return num(ret)
        )

        static long gcd(long u, long v)
        (§
            while (v != 0)
            (§
                long r = u % v
                u = v
                v = r
            )
            return u
        )

        public Number divide(Number x, Number y)
        (§
            long n = x.longValue()
            long val = y.longValue()
            long gcd = gcd(n, val)
            if (gcd == 0)
            (§
                return num(0)
            )

            n = n / gcd
            long d = val / gcd
            if (d == 1)
            (§
                return num(n)
            )
            if (d < 0)
            (§
                n = -n
                d = -d
            )
            return new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d))
        )

        public Number quotient(Number x, Number y)
        (§
            return num(x.longValue() / y.longValue())
        )

        public Number remainder(Number x, Number y)
        (§
            return num(x.longValue() % y.longValue())
        )

        public boolean equiv(Number x, Number y)
        (§
            return (x.longValue() == y.longValue())
        )

        public boolean lt(Number x, Number y)
        (§
            return (x.longValue() < y.longValue())
        )

        public boolean lte(Number x, Number y)
        (§
            return (x.longValue() <= y.longValue())
        )

        public boolean gte(Number x, Number y)
        (§
            return (x.longValue() >= y.longValue())
        )

        final public Number negate(Number x)
        (§
            long val = x.longValue()
            return num(Numbers.minus(val))
        )

        final public Number negateP(Number x)
        (§
            long val = x.longValue()
            if (val > Long.MIN_VALUE)
            (§
                return num(-val)
            )
            return BigInt.fromBigInteger(BigInteger.valueOf(val).negate())
        )

        public Number inc(Number x)
        (§
            long val = x.longValue()
            return num(Numbers.inc(val))
        )

        public Number incP(Number x)
        (§
            long val = x.longValue()
            if (val < Long.MAX_VALUE)
            (§
                return num(val + 1)
            )
            return BIGINT_OPS.inc(x)
        )

        public Number dec(Number x)
        (§
            long val = x.longValue()
            return num(Numbers.dec(val))
        )

        public Number decP(Number x)
        (§
            long val = x.longValue()
            if (val > Long.MIN_VALUE)
            (§
                return num(val - 1)
            )
            return BIGINT_OPS.dec(x)
        )
    )

    final static class DoubleOps extends OpsP
    (§
        public Ops combine(Ops y)
        (§
            return y.opsWith(this)
        )

        final public Ops opsWith(LongOps x)
        (§
            return this
        )

        final public Ops opsWith(DoubleOps x)
        (§
            return this
        )

        final public Ops opsWith(RatioOps x)
        (§
            return this
        )

        final public Ops opsWith(BigIntOps x)
        (§
            return this
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            return this
        )

        public boolean isZero(Number x)
        (§
            return (x.doubleValue() == 0)
        )

        public boolean isPos(Number x)
        (§
            return (x.doubleValue() > 0)
        )

        public boolean isNeg(Number x)
        (§
            return (x.doubleValue() < 0)
        )

        final public Number add(Number x, Number y)
        (§
            return Double.valueOf(x.doubleValue() + y.doubleValue())
        )

        final public Number multiply(Number x, Number y)
        (§
            return Double.valueOf(x.doubleValue() * y.doubleValue())
        )

        public Number divide(Number x, Number y)
        (§
            return Double.valueOf(x.doubleValue() / y.doubleValue())
        )

        public Number quotient(Number x, Number y)
        (§
            return Numbers.quotient(x.doubleValue(), y.doubleValue())
        )

        public Number remainder(Number x, Number y)
        (§
            return Numbers.remainder(x.doubleValue(), y.doubleValue())
        )

        public boolean equiv(Number x, Number y)
        (§
            return (x.doubleValue() == y.doubleValue())
        )

        public boolean lt(Number x, Number y)
        (§
            return (x.doubleValue() < y.doubleValue())
        )

        public boolean lte(Number x, Number y)
        (§
            return (x.doubleValue() <= y.doubleValue())
        )

        public boolean gte(Number x, Number y)
        (§
            return (x.doubleValue() >= y.doubleValue())
        )

        final public Number negate(Number x)
        (§
            return Double.valueOf(-x.doubleValue())
        )

        public Number inc(Number x)
        (§
            return Double.valueOf(x.doubleValue() + 1)
        )

        public Number dec(Number x)
        (§
            return Double.valueOf(x.doubleValue() - 1)
        )
    )

    final static class RatioOps extends OpsP
    (§
        public Ops combine(Ops y)
        (§
            return y.opsWith(this)
        )

        final public Ops opsWith(LongOps x)
        (§
            return this
        )

        final public Ops opsWith(DoubleOps x)
        (§
            return DOUBLE_OPS
        )

        final public Ops opsWith(RatioOps x)
        (§
            return this
        )

        final public Ops opsWith(BigIntOps x)
        (§
            return this
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            return BIGDECIMAL_OPS
        )

        public boolean isZero(Number x)
        (§
            Ratio r = (Ratio) x
            return (r.numerator.signum() == 0)
        )

        public boolean isPos(Number x)
        (§
            Ratio r = (Ratio) x
            return (r.numerator.signum() > 0)
        )

        public boolean isNeg(Number x)
        (§
            Ratio r = (Ratio) x
            return (r.numerator.signum() < 0)
        )

        static Number normalizeRet(Number ret, Number x, Number y)
        (§
            return ret
        )

        final public Number add(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            Number ret = divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator))
            return normalizeRet(ret, x, y)
        )

        final public Number multiply(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            Number ret = Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator))
            return normalizeRet(ret, x, y)
        )

        public Number divide(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            Number ret = Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator))
            return normalizeRet(ret, x, y)
        )

        public Number quotient(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator))
            return normalizeRet(BigInt.fromBigInteger(q), x, y)
        )

        public Number remainder(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator))
            Number ret = Numbers.minus(x, Numbers.multiply(q, y))
            return normalizeRet(ret, x, y)
        )

        public boolean equiv(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            return (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator))
        )

        public boolean lt(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            return Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))
        )

        public boolean lte(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            return Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))
        )

        public boolean gte(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            return Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))
        )

        final public Number negate(Number x)
        (§
            Ratio r = (Ratio) x
            return new Ratio(r.numerator.negate(), r.denominator)
        )

        public Number inc(Number x)
        (§
            return Numbers.add(x, 1)
        )

        public Number dec(Number x)
        (§
            return Numbers.add(x, -1)
        )
    )

    final static class BigIntOps extends OpsP
    (§
        public Ops combine(Ops y)
        (§
            return y.opsWith(this)
        )

        final public Ops opsWith(LongOps x)
        (§
            return this
        )

        final public Ops opsWith(DoubleOps x)
        (§
            return DOUBLE_OPS
        )

        final public Ops opsWith(RatioOps x)
        (§
            return RATIO_OPS
        )

        final public Ops opsWith(BigIntOps x)
        (§
            return this
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            return BIGDECIMAL_OPS
        )

        public boolean isZero(Number x)
        (§
            BigInt bx = toBigInt(x)
            if (bx.bipart == null)
            (§
                return (bx.lpart == 0)
            )
            return (bx.bipart.signum() == 0)
        )

        public boolean isPos(Number x)
        (§
            BigInt bx = toBigInt(x)
            if (bx.bipart == null)
            (§
                return (bx.lpart > 0)
            )
            return (bx.bipart.signum() > 0)
        )

        public boolean isNeg(Number x)
        (§
            BigInt bx = toBigInt(x)
            if (bx.bipart == null)
            (§
                return (bx.lpart < 0)
            )
            return (bx.bipart.signum() < 0)
        )

        final public Number add(Number x, Number y)
        (§
            return toBigInt(x).add(toBigInt(y))
        )

        final public Number multiply(Number x, Number y)
        (§
            return toBigInt(x).multiply(toBigInt(y))
        )

        public Number divide(Number x, Number y)
        (§
            return Numbers.divide(toBigInteger(x), toBigInteger(y))
        )

        public Number quotient(Number x, Number y)
        (§
            return toBigInt(x).quotient(toBigInt(y))
        )

        public Number remainder(Number x, Number y)
        (§
            return toBigInt(x).remainder(toBigInt(y))
        )

        public boolean equiv(Number x, Number y)
        (§
            return toBigInt(x).equals(toBigInt(y))
        )

        public boolean lt(Number x, Number y)
        (§
            return toBigInt(x).lt(toBigInt(y))
        )

        public boolean lte(Number x, Number y)
        (§
            return (toBigInteger(x).compareTo(toBigInteger(y)) <= 0)
        )

        public boolean gte(Number x, Number y)
        (§
            return (toBigInteger(x).compareTo(toBigInteger(y)) >= 0)
        )

        final public Number negate(Number x)
        (§
            return BigInt.fromBigInteger(toBigInteger(x).negate())
        )

        public Number inc(Number x)
        (§
            BigInteger bx = toBigInteger(x)
            return BigInt.fromBigInteger(bx.add(BigInteger.ONE))
        )

        public Number dec(Number x)
        (§
            BigInteger bx = toBigInteger(x)
            return BigInt.fromBigInteger(bx.subtract(BigInteger.ONE))
        )
    )

    final static class BigDecimalOps extends OpsP
    (§
        final static Var MATH_CONTEXT = RT.MATH_CONTEXT

        public Ops combine(Ops y)
        (§
            return y.opsWith(this)
        )

        final public Ops opsWith(LongOps x)
        (§
            return this
        )

        final public Ops opsWith(DoubleOps x)
        (§
            return DOUBLE_OPS
        )

        final public Ops opsWith(RatioOps x)
        (§
            return this
        )

        final public Ops opsWith(BigIntOps x)
        (§
            return this
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            return this
        )

        public boolean isZero(Number x)
        (§
            BigDecimal bx = (BigDecimal) x
            return (bx.signum() == 0)
        )

        public boolean isPos(Number x)
        (§
            BigDecimal bx = (BigDecimal) x
            return (bx.signum() > 0)
        )

        public boolean isNeg(Number x)
        (§
            BigDecimal bx = (BigDecimal) x
            return (bx.signum() < 0)
        )

        final public Number add(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            return (mc == null) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc)
        )

        final public Number multiply(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            return (mc == null) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc)
        )

        public Number divide(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            return (mc == null) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc)
        )

        public Number quotient(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            return (mc == null) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc)
        )

        public Number remainder(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            return (mc == null) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc)
        )

        public boolean equiv(Number x, Number y)
        (§
            return (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0)
        )

        public boolean lt(Number x, Number y)
        (§
            return (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0)
        )

        public boolean lte(Number x, Number y)
        (§
            return (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0)
        )

        public boolean gte(Number x, Number y)
        (§
            return (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0)
        )

        final public Number negate(Number x)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            return (mc == null) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc)
        )

        public Number inc(Number x)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            BigDecimal bx = (BigDecimal) x
            return (mc == null) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc)
        )

        public Number dec(Number x)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            BigDecimal bx = (BigDecimal) x
            return (mc == null) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc)
        )
    )

    static final LongOps LONG_OPS = new LongOps()
    static final DoubleOps DOUBLE_OPS = new DoubleOps()
    static final RatioOps RATIO_OPS = new RatioOps()
    static final BigIntOps BIGINT_OPS = new BigIntOps()
    static final BigDecimalOps BIGDECIMAL_OPS = new BigDecimalOps()

    static public enum Category
    (§
        INTEGER, FLOATING, DECIMAL, RATIO
    )

    static Ops ops(Object x)
    (§
        Class xc = x.getClass()

        if (xc == Long.class)
        (§
            return LONG_OPS
        )
        else if (xc == Double.class)
        (§
            return DOUBLE_OPS
        )
        else if (xc == Integer.class)
        (§
            return LONG_OPS
        )
        else if (xc == Float.class)
        (§
            return DOUBLE_OPS
        )
        else if (xc == BigInt.class)
        (§
            return BIGINT_OPS
        )
        else if (xc == BigInteger.class)
        (§
            return BIGINT_OPS
        )
        else if (xc == Ratio.class)
        (§
            return RATIO_OPS
        )
        else if (xc == BigDecimal.class)
        (§
            return BIGDECIMAL_OPS
        )
        else
        (§
            return LONG_OPS
        )
    )

    @WarnBoxedMath(false)
    static int hasheqFrom(Number x, Class xc)
    (§
        if (xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE)))
        (§
            long lpart = x.longValue()
            return Murmur3.hashLong(lpart)
        )
        if (xc == BigDecimal.class)
        (§
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode.  Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            if (isZero(x))
            (§
                return BigDecimal.ZERO.hashCode()
            )
            else
            (§
                return ((BigDecimal) x).stripTrailingZeros().hashCode()
            )
        )
        if (xc == Float.class && x.equals(-0.0(§ f)))
        (§
            return 0 ;; match 0.0f
        )
        return x.hashCode()
    )

    @WarnBoxedMath(false)
    static int hasheq(Number x)
    (§
        Class xc = x.getClass()

        if (xc == Long.class)
        (§
            long lpart = x.longValue()
            return Murmur3.hashLong(lpart)
        )
        if (xc == Double.class)
        (§
            if (x.equals(-0.0))
            (§
                return 0 ;; match 0.0
            )
            return x.hashCode()
        )
        return hasheqFrom(x, xc)
    )

    static Category category(Object x)
    (§
        Class xc = x.getClass()

        if (xc == Integer.class)
        (§
            return Category.INTEGER
        )
        else if (xc == Double.class)
        (§
            return Category.FLOATING
        )
        else if (xc == Long.class)
        (§
            return Category.INTEGER
        )
        else if (xc == Float.class)
        (§
            return Category.FLOATING
        )
        else if (xc == BigInt.class)
        (§
            return Category.INTEGER
        )
        else if (xc == Ratio.class)
        (§
            return Category.RATIO
        )
        else if (xc == BigDecimal.class)
        (§
            return Category.DECIMAL
        )
        else
        (§
            return Category.INTEGER
        )
    )

    static long bitOpsCast(Object x)
    (§
        Class xc = x.getClass()

        if (xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
        (§
            return RT.longCast(x)
        )
        ;; no bignums, no decimals
        throw new IllegalArgumentException("bit operation not supported for: " + xc)
    )

    @WarnBoxedMath(false)
    static public float[] float_array(int size, Object init)
    (§
        float[] ret = new float[size]
        if (init instanceof Number)
        (§
            float f = ((Number) init).floatValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).floatValue()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public float[] float_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new float[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            float[] ret = new float[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).floatValue()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public double[] double_array(int size, Object init)
    (§
        double[] ret = new double[size]
        if (init instanceof Number)
        (§
            double f = ((Number) init).doubleValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).doubleValue()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public double[] double_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new double[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            double[] ret = new double[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).doubleValue()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public int[] int_array(int size, Object init)
    (§
        int[] ret = new int[size]
        if (init instanceof Number)
        (§
            int f = ((Number) init).intValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).intValue()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public int[] int_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new int[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            int[] ret = new int[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).intValue()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public long[] long_array(int size, Object init)
    (§
        long[] ret = new long[size]
        if (init instanceof Number)
        (§
            long f = ((Number) init).longValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).longValue()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public long[] long_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new long[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            long[] ret = new long[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).longValue()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public short[] short_array(int size, Object init)
    (§
        short[] ret = new short[size]
        if (init instanceof Short)
        (§
            short s = (Short) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = s
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).shortValue()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public short[] short_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new short[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            short[] ret = new short[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).shortValue()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public char[] char_array(int size, Object init)
    (§
        char[] ret = new char[size]
        if (init instanceof Character)
        (§
            char c = (Character) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = c
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = (Character) s.first()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public char[] char_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new char[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            char[] ret = new char[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = (Character) s.first()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public byte[] byte_array(int size, Object init)
    (§
        byte[] ret = new byte[size]
        if (init instanceof Byte)
        (§
            byte b = (Byte) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = b
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).byteValue()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public byte[] byte_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new byte[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            byte[] ret = new byte[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).byteValue()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public boolean[] boolean_array(int size, Object init)
    (§
        boolean[] ret = new boolean[size]
        if (init instanceof Boolean)
        (§
            boolean b = (Boolean) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = b
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = (Boolean)s.first()
            )
        )
        return ret
    )

    @WarnBoxedMath(false)
    static public boolean[] boolean_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new boolean[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            boolean[] ret = new boolean[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = (Boolean)s.first()
            )
            return ret
        )
    )

    @WarnBoxedMath(false)
    static public boolean[] booleans(Object array)
    (§
        return (boolean[]) array
    )

    @WarnBoxedMath(false)
    static public byte[] bytes(Object array)
    (§
        return (byte[]) array
    )

    @WarnBoxedMath(false)
    static public char[] chars(Object array)
    (§
        return (char[]) array
    )

    @WarnBoxedMath(false)
    static public short[] shorts(Object array)
    (§
        return (short[]) array
    )

    @WarnBoxedMath(false)
    static public float[] floats(Object array)
    (§
        return (float[]) array
    )

    @WarnBoxedMath(false)
    static public double[] doubles(Object array)
    (§
        return (double[]) array
    )

    @WarnBoxedMath(false)
    static public int[] ints(Object array)
    (§
        return (int[]) array
    )

    @WarnBoxedMath(false)
    static public long[] longs(Object array)
    (§
        return (long[]) array
    )

    static public Number num(Object x)
    (§
        return (Number) x
    )

    static public Number num(float x)
    (§
        return Float.valueOf(x)
    )

    static public Number num(double x)
    (§
        return Double.valueOf(x)
    )

    static public double add(double x, double y)
    (§
        return x + y
    )

    static public double addP(double x, double y)
    (§
        return x + y
    )

    static public double minus(double x, double y)
    (§
        return x - y
    )

    static public double minusP(double x, double y)
    (§
        return x - y
    )

    static public double minus(double x)
    (§
        return -x
    )

    static public double minusP(double x)
    (§
        return -x
    )

    static public double inc(double x)
    (§
        return x + 1
    )

    static public double incP(double x)
    (§
        return x + 1
    )

    static public double dec(double x)
    (§
        return x - 1
    )

    static public double decP(double x)
    (§
        return x - 1
    )

    static public double multiply(double x, double y)
    (§
        return x * y
    )

    static public double multiplyP(double x, double y)
    (§
        return x * y
    )

    static public double divide(double x, double y)
    (§
        return x / y
    )

    static public boolean equiv(double x, double y)
    (§
        return (x == y)
    )

    static public boolean lt(double x, double y)
    (§
        return (x < y)
    )

    static public boolean lte(double x, double y)
    (§
        return (x <= y)
    )

    static public boolean gt(double x, double y)
    (§
        return (x > y)
    )

    static public boolean gte(double x, double y)
    (§
        return (x >= y)
    )

    static public boolean isPos(double x)
    (§
        return (x > 0)
    )

    static public boolean isNeg(double x)
    (§
        return (x < 0)
    )

    static public boolean isZero(double x)
    (§
        return (x == 0)
    )

    static int throwIntOverflow()
    (§
        throw new ArithmeticException("integer overflow")
    )

    static public int unchecked_int_add(int x, int y)
    (§
        return x + y
    )

    static public int unchecked_int_subtract(int x, int y)
    (§
        return x - y
    )

    static public int unchecked_int_negate(int x)
    (§
        return -x
    )

    static public int unchecked_int_inc(int x)
    (§
        return x + 1
    )

    static public int unchecked_int_dec(int x)
    (§
        return x - 1
    )

    static public int unchecked_int_multiply(int x, int y)
    (§
        return x * y
    )

    static public long not(Object x)
    (§
        return not(bitOpsCast(x))
    )

    static public long not(long x)
    (§
        return ~x
    )

    static public long and(Object x, Object y)
    (§
        return and(bitOpsCast(x), bitOpsCast(y))
    )

    static public long and(Object x, long y)
    (§
        return and(bitOpsCast(x), y)
    )

    static public long and(long x, Object y)
    (§
        return and(x, bitOpsCast(y))
    )

    static public long and(long x, long y)
    (§
        return x & y
    )

    static public long or(Object x, Object y)
    (§
        return or(bitOpsCast(x), bitOpsCast(y))
    )

    static public long or(Object x, long y)
    (§
        return or(bitOpsCast(x), y)
    )

    static public long or(long x, Object y)
    (§
        return or(x, bitOpsCast(y))
    )

    static public long or(long x, long y)
    (§
        return x | y
    )

    static public long xor(Object x, Object y)
    (§
        return xor(bitOpsCast(x), bitOpsCast(y))
    )

    static public long xor(Object x, long y)
    (§
        return xor(bitOpsCast(x), y)
    )

    static public long xor(long x, Object y)
    (§
        return xor(x, bitOpsCast(y))
    )

    static public long xor(long x, long y)
    (§
        return x :xor y
    )

    static public long andNot(Object x, Object y)
    (§
        return andNot(bitOpsCast(x), bitOpsCast(y))
    )

    static public long andNot(Object x, long y)
    (§
        return andNot(bitOpsCast(x), y)
    )

    static public long andNot(long x, Object y)
    (§
        return andNot(x, bitOpsCast(y))
    )

    static public long andNot(long x, long y)
    (§
        return x & ~y
    )

    static public long clearBit(Object x, Object y)
    (§
        return clearBit(bitOpsCast(x), bitOpsCast(y))
    )

    static public long clearBit(Object x, long y)
    (§
        return clearBit(bitOpsCast(x), y)
    )

    static public long clearBit(long x, Object y)
    (§
        return clearBit(x, bitOpsCast(y))
    )

    static public long clearBit(long x, long n)
    (§
        return x & ~(1(§ L) << n)
    )

    static public long setBit(Object x, Object y)
    (§
        return setBit(bitOpsCast(x), bitOpsCast(y))
    )

    static public long setBit(Object x, long y)
    (§
        return setBit(bitOpsCast(x), y)
    )

    static public long setBit(long x, Object y)
    (§
        return setBit(x, bitOpsCast(y))
    )

    static public long setBit(long x, long n)
    (§
        return x | (1(§ L) << n)
    )

    static public long flipBit(Object x, Object y)
    (§
        return flipBit(bitOpsCast(x), bitOpsCast(y))
    )

    static public long flipBit(Object x, long y)
    (§
        return flipBit(bitOpsCast(x), y)
    )

    static public long flipBit(long x, Object y)
    (§
        return flipBit(x, bitOpsCast(y))
    )

    static public long flipBit(long x, long n)
    (§
        return x :xor (1(§ L) << n)
    )

    static public boolean testBit(Object x, Object y)
    (§
        return testBit(bitOpsCast(x), bitOpsCast(y))
    )

    static public boolean testBit(Object x, long y)
    (§
        return testBit(bitOpsCast(x), y)
    )

    static public boolean testBit(long x, Object y)
    (§
        return testBit(x, bitOpsCast(y))
    )

    static public boolean testBit(long x, long n)
    (§
        return ((x & (1(§ L) << n)) != 0)
    )

    static public int unchecked_int_divide(int x, int y)
    (§
        return x / y
    )

    static public int unchecked_int_remainder(int x, int y)
    (§
        return x % y
    )

    static public Number num(long x)
    (§
        return Long.valueOf(x)
    )

    static public long unchecked_add(long x, long y) (§ return x + y )
    static public long unchecked_minus(long x, long y) (§ return x - y )
    static public long unchecked_multiply(long x, long y) (§ return x * y )
    static public long unchecked_minus(long x) (§ return -x )
    static public long unchecked_inc(long x) (§ return x + 1 )
    static public long unchecked_dec(long x) (§ return x - 1 )

    static public Number unchecked_add(Object x, Object y) (§ return add(x, y) )
    static public Number unchecked_minus(Object x, Object y) (§ return minus(x, y) )
    static public Number unchecked_multiply(Object x, Object y) (§ return multiply(x, y) )
    static public Number unchecked_minus(Object x) (§ return minus(x) )
    static public Number unchecked_inc(Object x) (§ return inc(x) )
    static public Number unchecked_dec(Object x) (§ return dec(x) )

    static public double unchecked_add(double x, double y) (§ return add(x, y) )
    static public double unchecked_minus(double x, double y) (§ return minus(x, y) )
    static public double unchecked_multiply(double x, double y) (§ return multiply(x, y) )
    static public double unchecked_minus(double x) (§ return minus(x) )
    static public double unchecked_inc(double x) (§ return inc(x) )
    static public double unchecked_dec(double x) (§ return dec(x) )

    static public double unchecked_add(double x, Object y) (§ return add(x, y) )
    static public double unchecked_minus(double x, Object y) (§ return minus(x, y) )
    static public double unchecked_multiply(double x, Object y) (§ return multiply(x, y) )
    static public double unchecked_add(Object x, double y) (§ return add(x, y) )
    static public double unchecked_minus(Object x, double y) (§ return minus(x, y) )
    static public double unchecked_multiply(Object x, double y) (§ return multiply(x, y) )

    static public double unchecked_add(double x, long y) (§ return add(x, y) )
    static public double unchecked_minus(double x, long y) (§ return minus(x, y) )
    static public double unchecked_multiply(double x, long y) (§ return multiply(x, y) )
    static public double unchecked_add(long x, double y) (§ return add(x, y) )
    static public double unchecked_minus(long x, double y) (§ return minus(x, y) )
    static public double unchecked_multiply(long x, double y) (§ return multiply(x, y) )

    static public Number unchecked_add(long x, Object y) (§ return add(x, y) )
    static public Number unchecked_minus(long x, Object y) (§ return minus(x, y) )
    static public Number unchecked_multiply(long x, Object y) (§ return multiply(x, y) )
    static public Number unchecked_add(Object x, long y) (§ return add(x, y) )
    static public Number unchecked_minus(Object x, long y) (§ return minus(x, y) )
    static public Number unchecked_multiply(Object x, long y) (§ return multiply(x, y) )

    static public Number quotient(double x, Object y) (§ return quotient((Object)x, y) )
    static public Number quotient(Object x, double y) (§ return quotient(x, (Object)y) )
    static public Number quotient(long x, Object y) (§ return quotient((Object)x, y) )
    static public Number quotient(Object x, long y) (§ return quotient(x, (Object)y) )
    static public double quotient(double x, long y) (§ return quotient(x, (double)y) )
    static public double quotient(long x, double y) (§ return quotient((double)x, y) )

    static public Number remainder(double x, Object y) (§ return remainder((Object)x, y) )
    static public Number remainder(Object x, double y) (§ return remainder(x, (Object)y) )
    static public Number remainder(long x, Object y) (§ return remainder((Object)x, y) )
    static public Number remainder(Object x, long y) (§ return remainder(x, (Object)y) )
    static public double remainder(double x, long y) (§ return remainder(x, (double)y) )
    static public double remainder(long x, double y) (§ return remainder((double)x, y) )

    static public long add(long x, long y)
    (§
        long ret = x + y
        if ((ret :xor x) < 0 && (ret :xor y) < 0)
        (§
            return throwIntOverflow()
        )
        return ret
    )

    static public Number addP(long x, long y)
    (§
        long ret = x + y
        if ((ret :xor x) < 0 && (ret :xor y) < 0)
        (§
            return addP((Number)x, (Number)y)
        )
        return num(ret)
    )

    static public long minus(long x, long y)
    (§
        long ret = x - y
        if (((ret :xor x) < 0 && (ret :xor ~y) < 0))
        (§
            return throwIntOverflow()
        )
        return ret
    )

    static public Number minusP(long x, long y)
    (§
        long ret = x - y
        if (((ret :xor x) < 0 && (ret :xor ~y) < 0))
        (§
            return minusP((Number)x, (Number)y)
        )
        return num(ret)
    )

    static public long minus(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            return throwIntOverflow()
        )
        return -x
    )

    static public Number minusP(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            return BigInt.fromBigInteger(BigInteger.valueOf(x).negate())
        )
        return num(-x)
    )

    static public long inc(long x)
    (§
        if (x == Long.MAX_VALUE)
        (§
            return throwIntOverflow()
        )
        return x + 1
    )

    static public Number incP(long x)
    (§
        if (x == Long.MAX_VALUE)
        (§
            return BIGINT_OPS.inc(x)
        )
        return num(x + 1)
    )

    static public long dec(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            return throwIntOverflow()
        )
        return x - 1
    )

    static public Number decP(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            return BIGINT_OPS.dec(x)
        )
        return num(x - 1)
    )

    static public long multiply(long x, long y)
    (§
        if (x == Long.MIN_VALUE && y < 0)
        (§
            return throwIntOverflow()
        )
        long ret = x * y
        if (y != 0 && ret/y != x)
        (§
            return throwIntOverflow()
        )
        return ret
    )

    static public Number multiplyP(long x, long y)
    (§
        if (x == Long.MIN_VALUE && y < 0)
        (§
            return multiplyP((Number)x, (Number)y)
        )
        long ret = x * y
        if (y != 0 && ret/y != x)
        (§
            return multiplyP((Number)x, (Number)y)
        )
        return num(ret)
    )

    static public long quotient(long x, long y)
    (§
        return x / y
    )

    static public long remainder(long x, long y)
    (§
        return x % y
    )

    static public boolean equiv(long x, long y)
    (§
        return (x == y)
    )

    static public boolean lt(long x, long y)
    (§
        return (x < y)
    )

    static public boolean lte(long x, long y)
    (§
        return (x <= y)
    )

    static public boolean gt(long x, long y)
    (§
        return (x > y)
    )

    static public boolean gte(long x, long y)
    (§
        return (x >= y)
    )

    static public boolean isPos(long x)
    (§
        return (x > 0)
    )

    static public boolean isNeg(long x)
    (§
        return (x < 0)
    )

    static public boolean isZero(long x)
    (§
        return (x == 0)
    )

    ;; overload resolution

    static public Number add(long x, Object y)
    (§
        return add((Object)x, y)
    )

    static public Number add(Object x, long y)
    (§
        return add(x, (Object)y)
    )

    static public Number addP(long x, Object y)
    (§
        return addP((Object)x, y)
    )

    static public Number addP(Object x, long y)
    (§
        return addP(x, (Object)y)
    )

    static public double add(double x, Object y)
    (§
        return add(x, ((Number)y).doubleValue())
    )

    static public double add(Object x, double y)
    (§
        return add(((Number)x).doubleValue(), y)
    )

    static public double add(double x, long y)
    (§
        return x + y
    )

    static public double add(long x, double y)
    (§
        return x + y
    )

    static public double addP(double x, Object y)
    (§
        return addP(x, ((Number)y).doubleValue())
    )

    static public double addP(Object x, double y)
    (§
        return addP(((Number)x).doubleValue(), y)
    )

    static public double addP(double x, long y)
    (§
        return x + y
    )

    static public double addP(long x, double y)
    (§
        return x + y
    )

    static public Number minus(long x, Object y)
    (§
        return minus((Object)x, y)
    )

    static public Number minus(Object x, long y)
    (§
        return minus(x, (Object)y)
    )

    static public Number minusP(long x, Object y)
    (§
        return minusP((Object)x, y)
    )

    static public Number minusP(Object x, long y)
    (§
        return minusP(x, (Object)y)
    )

    static public double minus(double x, Object y)
    (§
        return minus(x, ((Number)y).doubleValue())
    )

    static public double minus(Object x, double y)
    (§
        return minus(((Number)x).doubleValue(), y)
    )

    static public double minus(double x, long y)
    (§
        return x - y
    )

    static public double minus(long x, double y)
    (§
        return x - y
    )

    static public double minusP(double x, Object y)
    (§
        return minus(x, ((Number)y).doubleValue())
    )

    static public double minusP(Object x, double y)
    (§
        return minus(((Number)x).doubleValue(), y)
    )

    static public double minusP(double x, long y)
    (§
        return x - y
    )

    static public double minusP(long x, double y)
    (§
        return x - y
    )

    static public Number multiply(long x, Object y)
    (§
        return multiply((Object)x, y)
    )

    static public Number multiply(Object x, long y)
    (§
        return multiply(x, (Object)y)
    )

    static public Number multiplyP(long x, Object y)
    (§
        return multiplyP((Object)x, y)
    )

    static public Number multiplyP(Object x, long y)
    (§
        return multiplyP(x, (Object)y)
    )

    static public double multiply(double x, Object y)
    (§
        return multiply(x, ((Number)y).doubleValue())
    )

    static public double multiply(Object x, double y)
    (§
        return multiply(((Number)x).doubleValue(), y)
    )

    static public double multiply(double x, long y)
    (§
        return x * y
    )

    static public double multiply(long x, double y)
    (§
        return x * y
    )

    static public double multiplyP(double x, Object y)
    (§
        return multiplyP(x, ((Number)y).doubleValue())
    )

    static public double multiplyP(Object x, double y)
    (§
        return multiplyP(((Number)x).doubleValue(), y)
    )

    static public double multiplyP(double x, long y)
    (§
        return x * y
    )

    static public double multiplyP(long x, double y)
    (§
        return x * y
    )

    static public Number divide(long x, Object y)
    (§
        return divide((Object)x, y)
    )

    static public Number divide(Object x, long y)
    (§
        return divide(x, (Object)y)
    )

    static public double divide(double x, Object y)
    (§
        return x / ((Number)y).doubleValue()
    )

    static public double divide(Object x, double y)
    (§
        return ((Number)x).doubleValue() / y
    )

    static public double divide(double x, long y)
    (§
        return x / y
    )

    static public double divide(long x, double y)
    (§
        return x / y
    )

    static public Number divide(long x, long y)
    (§
        return divide((Number)x, (Number)y)
    )

    static public boolean lt(long x, Object y)
    (§
        return lt((Object)x, y)
    )

    static public boolean lt(Object x, long y)
    (§
        return lt(x, (Object)y)
    )

    static public boolean lt(double x, Object y)
    (§
        return (x < ((Number)y).doubleValue())
    )

    static public boolean lt(Object x, double y)
    (§
        return (((Number)x).doubleValue() < y)
    )

    static public boolean lt(double x, long y)
    (§
        return (x < y)
    )

    static public boolean lt(long x, double y)
    (§
        return (x < y)
    )

    static public boolean lte(long x, Object y)
    (§
        return lte((Object)x, y)
    )

    static public boolean lte(Object x, long y)
    (§
        return lte(x, (Object)y)
    )

    static public boolean lte(double x, Object y)
    (§
        return (x <= ((Number)y).doubleValue())
    )

    static public boolean lte(Object x, double y)
    (§
        return (((Number)x).doubleValue() <= y)
    )

    static public boolean lte(double x, long y)
    (§
        return (x <= y)
    )

    static public boolean lte(long x, double y)
    (§
        return (x <= y)
    )

    static public boolean gt(long x, Object y)
    (§
        return gt((Object)x, y)
    )

    static public boolean gt(Object x, long y)
    (§
        return gt(x, (Object)y)
    )

    static public boolean gt(double x, Object y)
    (§
        return (x > ((Number)y).doubleValue())
    )

    static public boolean gt(Object x, double y)
    (§
        return (((Number)x).doubleValue() > y)
    )

    static public boolean gt(double x, long y)
    (§
        return (x > y)
    )

    static public boolean gt(long x, double y)
    (§
        return (x > y)
    )

    static public boolean gte(long x, Object y)
    (§
        return gte((Object)x, y)
    )

    static public boolean gte(Object x, long y)
    (§
        return gte(x, (Object)y)
    )

    static public boolean gte(double x, Object y)
    (§
        return (x >= ((Number)y).doubleValue())
    )

    static public boolean gte(Object x, double y)
    (§
        return (((Number)x).doubleValue() >= y)
    )

    static public boolean gte(double x, long y)
    (§
        return (x >= y)
    )

    static public boolean gte(long x, double y)
    (§
        return (x >= y)
    )

    static public boolean equiv(long x, Object y)
    (§
        return equiv((Object)x, y)
    )

    static public boolean equiv(Object x, long y)
    (§
        return equiv(x, (Object)y)
    )

    static public boolean equiv(double x, Object y)
    (§
        return (x == ((Number)y).doubleValue())
    )

    static public boolean equiv(Object x, double y)
    (§
        return (((Number)x).doubleValue() == y)
    )

    static public boolean equiv(double x, long y)
    (§
        return (x == y)
    )

    static public boolean equiv(long x, double y)
    (§
        return (x == y)
    )

    static boolean isNaN(Object x)
    (§
        return (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN()
    )

    static public double max(double x, double y)
    (§
        return Math.max(x, y)
    )

    static public Object max(double x, long y)
    (§
        if (Double.isNaN(x))
        (§
            return x
        )
        if (x > y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object max(double x, Object y)
    (§
        if (Double.isNaN(x))
        (§
            return x
        )
        else if (isNaN(y))
        (§
            return y
        )
        if (x > ((Number)y).doubleValue())
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object max(long x, double y)
    (§
        if (Double.isNaN(y))
        (§
            return y
        )
        if (x > y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public long max(long x, long y)
    (§
        if (x > y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object max(long x, Object y)
    (§
        if (isNaN(y))
        (§
            return y
        )
        if (gt(x, y))
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object max(Object x, long y)
    (§
        if (isNaN(x))
        (§
            return x
        )
        if (gt(x, y))
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object max(Object x, double y)
    (§
        if (isNaN(x))
        (§
            return x
        )
        else if (Double.isNaN(y))
        (§
            return y
        )
        if (((Number)x).doubleValue() > y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object max(Object x, Object y)
    (§
        if (isNaN(x))
        (§
            return x
        )
        else if (isNaN(y))
        (§
            return y
        )
        if (gt(x, y))
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public double min(double x, double y)
    (§
        return Math.min(x, y)
    )

    static public Object min(double x, long y)
    (§
        if (Double.isNaN(x))
        (§
            return x
        )
        if (x < y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object min(double x, Object y)
    (§
        if (Double.isNaN(x))
        (§
            return x
        )
        else if (isNaN(y))
        (§
            return y
        )
        if (x < ((Number)y).doubleValue())
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object min(long x, double y)
    (§
        if (Double.isNaN(y))
        (§
            return y
        )
        if (x < y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public long min(long x, long y)
    (§
        if (x < y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object min(long x, Object y)
    (§
        if (isNaN(y))
        (§
            return y
        )
        if (lt(x, y))
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object min(Object x, long y)
    (§
        if (isNaN(x))
        (§
            return x
        )
        if (lt(x, y))
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object min(Object x, double y)
    (§
        if (isNaN(x))
        (§
            return x
        )
        else if (Double.isNaN(y))
        (§
            return y
        )
        if (((Number)x).doubleValue() < y)
        (§
            return x
        )
        else
        (§
            return y
        )
    )

    static public Object min(Object x, Object y)
    (§
        if (isNaN(x))
        (§
            return x
        )
        else if (isNaN(y))
        (§
            return y
        )
        if (lt(x, y))
        (§
            return x
        )
        else
        (§
            return y
        )
    )
)
)

(§ java cloiure.lang.Obj

import java.io.Serializable

public abstract class Obj implements IObj, Serializable
(§
    final IPersistentMap _meta

    public Obj(IPersistentMap meta)
    (§
        this._meta = meta
    )

    public Obj()
    (§
        _meta = null
    )

    final public IPersistentMap meta()
    (§
        return _meta
    )

    abstract public Obj withMeta(IPersistentMap meta)
)
)

(§ java cloiure.lang.PersistentArrayMap

import java.io.Serializable
import java.util.Arrays
import java.util.Iterator
import java.util.Map
import java.util.NoSuchElementException

;;
 ; Simple implementation of persistent map on an array
 
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 
 ; Copies array on every change, so only appropriate for _very_small_ maps
 
 ; null keys and values are ok, but you won't be able to distinguish a null value via valAt - use contains/entryAt
 ;
public class PersistentArrayMap extends APersistentMap implements IObj, IEditableCollection, IMapIterable, IKVReduce
(§
    final Object[] array
    static final int HASHTABLE_THRESHOLD = 16

    public static final PersistentArrayMap EMPTY = new PersistentArrayMap()
    private final IPersistentMap _meta

    static public IPersistentMap create(Map other)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (Object o :in other.entrySet())
        (§
            Map.Entry e = (Entry) o
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        return ret.persistent()
    )

    protected PersistentArrayMap()
    (§
        this.array = new Object[] (§)
        this._meta = null
    )

    public PersistentArrayMap withMeta(IPersistentMap meta)
    (§
        return new PersistentArrayMap(meta, array)
    )

    PersistentArrayMap create(Object... init)
    (§
        return new PersistentArrayMap(meta(), init)
    )

    IPersistentMap createHT(Object[] init)
    (§
        return PersistentHashMap.create(meta(), init)
    )

    static public PersistentArrayMap createWithCheck(Object[] init)
    (§
        for (int i = 0 i < init.length i += 2)
        (§
            for (int j = i + 2 j < init.length j += 2)
            (§
                if (equalKey(init[i], init[j]))
                (§
                    throw new IllegalArgumentException("Duplicate key: " + init[i])
                )
            )
        )
        return new PersistentArrayMap(init)
    )

    static public PersistentArrayMap createAsIfByAssoc(Object[] init)
    (§
        if ((init.length & 1) == 1)
        (§
            throw new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1]))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        int n = 0
        for (int i = 0 i < init.length i += 2)
        (§
            boolean duplicateKey = false
            for (int j = 0 j < i j += 2)
            (§
                if (equalKey(init[i], init[j]))
                (§
                    duplicateKey = true
                    break
                )
            )
            if (!duplicateKey)
            (§
                n += 2
            )
        )
        if (n < init.length)
        (§
            ;; Create a new shorter array with unique keys, and
            ;; the last value associated with each key.  To behave
            ;; like assoc, the first occurrence of each key must
            ;; be used, since its metadata may be different than
            ;; later equal keys.
            Object[] nodups = new Object[n]
            int m = 0
            for (int i = 0 i < init.length i += 2)
            (§
                boolean duplicateKey = false
                for (int j = 0 j < m j += 2)
                (§
                    if (equalKey(init[i], nodups[j]))
                    (§
                        duplicateKey = true
                        break
                    )
                )
                if (!duplicateKey)
                (§
                    int j
                    for (j = init.length - 2 j >= i j -= 2)
                    (§
                        if (equalKey(init[i], init[j]))
                        (§
                            break
                        )
                    )
                    nodups[m] = init[i]
                    nodups[m + 1] = init[j + 1]
                    m += 2
                )
            )
            if (m != n)
            (§
                throw new IllegalArgumentException("Internal error: m=" + m)
            )
            init = nodups
        )
        return new PersistentArrayMap(init)
    )

    ;;
     ; This ctor captures/aliases the passed array, so do not modify later
     
     ; @param init {key1, val1, key2, val2, ...}
     ;
    public PersistentArrayMap(Object[] init)
    (§
        this.array = init
        this._meta = null
    )

    public PersistentArrayMap(IPersistentMap meta, Object[] init)
    (§
        this._meta = meta
        this.array = init
    )

    public int count()
    (§
        return array.length / 2
    )

    public boolean containsKey(Object key)
    (§
        return (indexOf(key) >= 0)
    )

    public IMapEntry entryAt(Object key)
    (§
        int i = indexOf(key)
        if (i >= 0)
        (§
            return (IMapEntry) MapEntry.create(array[i], array[i + 1])
        )
        return null
    )

    public IPersistentMap assocEx(Object key, Object val)
    (§
        int i = indexOf(key)
        Object[] newArray
        if (i >= 0)
        (§
            throw Util.runtimeException("Key already present")
        )
        else ;; didn't have key, grow
        (§
            if (array.length > HASHTABLE_THRESHOLD)
            (§
                return createHT(array).assocEx(key, val)
            )
            newArray = new Object[array.length + 2]
            if (array.length > 0)
            (§
                System.arraycopy(array, 0, newArray, 2, array.length)
            )
            newArray[0] = key
            newArray[1] = val
        )
        return create(newArray)
    )

    public IPersistentMap assoc(Object key, Object val)
    (§
        int i = indexOf(key)
        Object[] newArray
        if (i >= 0) ;; already have key, same-sized replacement
        (§
            if (array[i + 1] == val) ;; no change, no op
            (§
                return this
            )
            newArray = array.clone()
            newArray[i + 1] = val
        )
        else ;; didn't have key, grow
        (§
            if (array.length > HASHTABLE_THRESHOLD)
            (§
                return createHT(array).assoc(key, val)
            )
            newArray = new Object[array.length + 2]
            if (array.length > 0)
            (§
                System.arraycopy(array, 0, newArray, 0, array.length)
            )
            newArray[newArray.length - 2] = key
            newArray[newArray.length - 1] = val
        )
        return create(newArray)
    )

    public IPersistentMap without(Object key)
    (§
        int i = indexOf(key)
        if (i >= 0) ;; have key, will remove
        (§
            int newlen = array.length - 2
            if (newlen == 0)
            (§
                return empty()
            )
            Object[] newArray = new Object[newlen]
            System.arraycopy(array, 0, newArray, 0, i)
            System.arraycopy(array, i + 2, newArray, i, newlen - i)
            return create(newArray)
        )
        ;; don't have key, no op
        return this
    )

    public IPersistentMap empty()
    (§
        return (IPersistentMap) EMPTY.withMeta(meta())
    )

    final public Object valAt(Object key, Object notFound)
    (§
        int i = indexOf(key)
        if (i >= 0)
        (§
            return array[i + 1]
        )
        return notFound
    )

    public Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public int capacity()
    (§
        return count()
    )

    private int indexOfObject(Object key)
    (§
        Util.EquivPred ep = Util.equivPred(key)
        for (int i = 0 i < array.length i += 2)
        (§
            if (ep.equiv(key, array[i]))
            (§
                return i
            )
        )
        return -1
    )

    private int indexOf(Object key)
    (§
        if (key instanceof Keyword)
        (§
            for (int i = 0 i < array.length i += 2)
            (§
                if (key == array[i])
                (§
                    return i
                )
            )
            return -1
        )
        else
        (§
            return indexOfObject(key)
        )
    )

    static boolean equalKey(Object k1, Object k2)
    (§
        if (k1 instanceof Keyword)
        (§
            return (k1 == k2)
        )
        return Util.equiv(k1, k2)
    )

    public Iterator iterator()
    (§
        return new Iter(array, APersistentMap.MAKE_ENTRY)
    )

    public Iterator keyIterator()
    (§
        return new Iter(array, APersistentMap.MAKE_KEY)
    )

    public Iterator valIterator()
    (§
        return new Iter(array, APersistentMap.MAKE_VAL)
    )

    public ISeq seq()
    (§
        if (array.length > 0)
        (§
            return new Seq(array, 0)
        )
        return null
    )

    public IPersistentMap meta()
    (§
        return _meta
    )

    static class Seq extends ASeq implements Counted
    (§
        final Object[] array
        final int i

        Seq(Object[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public Seq(IPersistentMap meta, Object[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            return MapEntry.create(array[i], array[i + 1])
        )

        public ISeq next()
        (§
            if (i + 2 < array.length)
            (§
                return new Seq(array, i + 2)
            )
            return null
        )

        public int count()
        (§
            return (array.length - i) / 2
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            return new Seq(meta, array, i)
        )
    )

    static class Iter implements Iterator
    (§
        IFn f
        Object[] array
        int i

        ;; for iterator
        Iter(Object[] array, IFn f)
        (§
            this(array, -2, f)
        )

        ;; for entryAt
        Iter(Object[] array, int i, IFn f)
        (§
            this.array = array
            this.i = i
            this.f = f
        )

        public boolean hasNext()
        (§
            return (i < array.length - 2)
        )

        public Object next()
        (§
            try
            (§
                i += 2
                return f.invoke(array[i], array[i + 1])
            )
            catch (IndexOutOfBoundsException e)
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    public Object kvreduce(IFn f, Object init)
    (§
        for (int i = 0 i < array.length i += 2)
        (§
            init = f.invoke(init, array[i], array[i + 1])
            if (RT.isReduced(init))
            (§
                return ((IDeref)init).deref()
            )
        )
        return init
    )

    public ITransientMap asTransient()
    (§
        return new TransientArrayMap(array)
    )

    static final class TransientArrayMap extends ATransientMap
    (§
        volatile int len
        final Object[] array
        volatile Thread owner

        public TransientArrayMap(Object[] array)
        (§
            this.owner = Thread.currentThread()
            this.array = new Object[Math.max(HASHTABLE_THRESHOLD, array.length)]
            System.arraycopy(array, 0, this.array, 0, array.length)
            this.len = array.length
        )

        private int indexOf(Object key)
        (§
            for (int i = 0 i < len i += 2)
            (§
                if (equalKey(array[i], key))
                (§
                    return i
                )
            )
            return -1
        )

        ITransientMap doAssoc(Object key, Object val)
        (§
            int i = indexOf(key)
            if (i >= 0) ;; already have key,
            (§
                if (array[i + 1] != val) ;; no change, no op
                (§
                    array[i + 1] = val
                )
            )
            else ;; didn't have key, grow
            (§
                if (len >= array.length)
                (§
                    return PersistentHashMap.create(array).asTransient().assoc(key, val)
                )
                array[len++] = key
                array[len++] = val
            )
            return this
        )

        ITransientMap doWithout(Object key)
        (§
            int i = indexOf(key)
            if (i >= 0) ;; have key, will remove
            (§
                if (len >= 2)
                (§
                    array[i] = array[len - 2]
                    array[i + 1] = array[len - 1]
                )
                len -= 2
            )
            return this
        )

        Object doValAt(Object key, Object notFound)
        (§
            int i = indexOf(key)
            if (i >= 0)
            (§
                return array[i + 1]
            )
            return notFound
        )

        int doCount()
        (§
            return len / 2
        )

        IPersistentMap doPersistent()
        (§
            ensureEditable()
            owner = null
            Object[] a = new Object[len]
            System.arraycopy(array, 0, a, 0, len)
            return new PersistentArrayMap(a)
        )

        void ensureEditable()
        (§
            if (owner == null)
            (§
                throw new IllegalAccessError("Transient used after persistent! call")
            )
        )
    )
)
)

(§ java cloiure.lang.PersistentHashMap

import java.io.Serializable
import java.util.*
import java.util.concurrent.Callable
import java.util.concurrent.atomic.AtomicReference

;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;
public class PersistentHashMap extends APersistentMap implements IEditableCollection, IObj, IMapIterable, IKVReduce
(§
    final int count
    final INode root
    final boolean hasNull
    final Object nullValue
    final IPersistentMap _meta

    final public static PersistentHashMap EMPTY = new PersistentHashMap(0, null, false, null)
    final private static Object NOT_FOUND = new Object()

    static public IPersistentMap create(Map other)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (Object o :in other.entrySet())
        (§
            Map.Entry e = (Entry) o
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        return ret.persistent()
    )

    ;;
     ; @param init {key1, val1, key2, val2, ...}
     ;
    public static PersistentHashMap create(Object... init)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (int i = 0 i < init.length i += 2)
        (§
            ret = ret.assoc(init[i], init[i + 1])
        )
        return (PersistentHashMap) ret.persistent()
    )

    public static PersistentHashMap createWithCheck(Object... init)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (int i = 0 i < init.length i += 2)
        (§
            ret = ret.assoc(init[i], init[i + 1])
            if (ret.count() != i / 2 + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + init[i])
            )
        )
        return (PersistentHashMap) ret.persistent()
    )

    static public PersistentHashMap create(ISeq items)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (  items != null items = items.next().next())
        (§
            if (items.next() == null)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
        )
        return (PersistentHashMap) ret.persistent()
    )

    static public PersistentHashMap createWithCheck(ISeq items)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (int i = 0 items != null items = items.next().next(), ++i)
        (§
            if (items.next() == null)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + items.first())
            )
        )
        return (PersistentHashMap) ret.persistent()
    )

    ;;
     ; @param init {key1, val1, key2, val2, ...}
     ;
    public static PersistentHashMap create(IPersistentMap meta, Object... init)
    (§
        return create(init).withMeta(meta)
    )

    PersistentHashMap(int count, INode root, boolean hasNull, Object nullValue)
    (§
        this.count = count
        this.root = root
        this.hasNull = hasNull
        this.nullValue = nullValue
        this._meta = null
    )

    public PersistentHashMap(IPersistentMap meta, int count, INode root, boolean hasNull, Object nullValue)
    (§
        this._meta = meta
        this.count = count
        this.root = root
        this.hasNull = hasNull
        this.nullValue = nullValue
    )

    static int hash(Object k)
    (§
        return Util.hasheq(k)
    )

    public boolean containsKey(Object key)
    (§
        if (key == null)
        (§
            return hasNull
        )
        return (root != null) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false
    )

    public IMapEntry entryAt(Object key)
    (§
        if (key == null)
        (§
            return hasNull ? (IMapEntry) MapEntry.create(null, nullValue) :or null
        )
        return (root != null) ? root.find(0, hash(key), key) :or null
    )

    public IPersistentMap assoc(Object key, Object val)
    (§
        if (key == null)
        (§
            if (hasNull && val == nullValue)
            (§
                return this
            )
            return new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)
        )
        Box addedLeaf = new Box(null)
        INode newroot = ((root == null) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf)
        if (newroot == root)
        (§
            return this
        )
        return new PersistentHashMap(meta(), (addedLeaf.val == null) ? count :or count + 1, newroot, hasNull, nullValue)
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (key == null)
        (§
            return hasNull ? nullValue :or notFound
        )
        return (root != null) ? root.find(0, hash(key), key, notFound) :or notFound
    )

    public Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public IPersistentMap assocEx(Object key, Object val)
    (§
        if (containsKey(key))
        (§
            throw Util.runtimeException("Key already present")
        )
        return assoc(key, val)
    )

    public IPersistentMap without(Object key)
    (§
        if (key == null)
        (§
            return hasNull ? new PersistentHashMap(meta(), count - 1, root, false, null) :or this
        )
        if (root == null)
        (§
            return this
        )
        INode newroot = root.without(0, hash(key), key)
        if (newroot == root)
        (§
            return this
        )
        return new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue)
    )

    static final Iterator EMPTY_ITER = new Iterator()
    (§
        public boolean hasNext()
        (§
            return false
        )

        public Object next()
        (§
            throw new NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    private Iterator iterator(final IFn f)
    (§
        final Iterator rootIter = (root == null) ? EMPTY_ITER :or root.iterator(f)
        if (hasNull)
        (§
            return new Iterator()
            (§
                private boolean seen = false
                public boolean hasNext()
                (§
                    if (!seen)
                    (§
                        return true
                    )
                    else
                    (§
                        return rootIter.hasNext()
                    )
                )

                public Object next()
                (§
                    if (!seen)
                    (§
                        seen = true
                        return f.invoke(null, nullValue)
                    )
                    else
                    (§
                        return rootIter.next()
                    )
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )
        else
        (§
            return rootIter
        )
    )

    public Iterator iterator()
    (§
        return iterator(APersistentMap.MAKE_ENTRY)
    )

    public Iterator keyIterator()
    (§
        return iterator(APersistentMap.MAKE_KEY)
    )

    public Iterator valIterator()
    (§
        return iterator(APersistentMap.MAKE_VAL)
    )

    public Object kvreduce(IFn f, Object init)
    (§
        init = hasNull ? f.invoke(init, null, nullValue) :or init
        if (RT.isReduced(init))
        (§
            return ((IDeref)init).deref()
        )
        if (root != null)
        (§
            init = root.kvreduce(f, init)
            if (RT.isReduced(init))
            (§
                return ((IDeref)init).deref()
            )
            else
            (§
                return init
            )
        )
        return init
    )

    public Object fold(long n, final IFn combinef, final IFn reducef, IFn fjinvoke, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
    (§
        ;; we are ignoring n for now
        Callable top = new Callable()
        (§
            public Object call() throws Exception
            (§
                Object ret = combinef.invoke()
                if (root != null)
                (§
                    ret = combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin))
                )
                return hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), null, nullValue)) :or ret
            )
        )
        return fjinvoke.invoke(top)
    )

    public int count()
    (§
        return count
    )

    public ISeq seq()
    (§
        ISeq s = (root != null) ? root.nodeSeq() :or null
        return hasNull ? new Cons(MapEntry.create(null, nullValue), s) :or s
    )

    public IPersistentCollection empty()
    (§
        return EMPTY.withMeta(meta())
    )

    static int mask(int hash, int shift)
    (§
        return (hash >>> shift) & 0x01f
    )

    public PersistentHashMap withMeta(IPersistentMap meta)
    (§
        return new PersistentHashMap(meta, count, root, hasNull, nullValue)
    )

    public TransientHashMap asTransient()
    (§
        return new TransientHashMap(this)
    )

    public IPersistentMap meta()
    (§
        return _meta
    )

    static final class TransientHashMap extends ATransientMap
    (§
        final AtomicReference<Thread> edit
        volatile INode root
        volatile int count
        volatile boolean hasNull
        volatile Object nullValue
        final Box leafFlag = new Box(null)

        TransientHashMap(PersistentHashMap m)
        (§
            this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue)
        )

        TransientHashMap(AtomicReference<Thread> edit, INode root, int count, boolean hasNull, Object nullValue)
        (§
            this.edit = edit
            this.root = root
            this.count = count
            this.hasNull = hasNull
            this.nullValue = nullValue
        )

        ITransientMap doAssoc(Object key, Object val)
        (§
            if (key == null)
            (§
                if (this.nullValue != val)
                (§
                    this.nullValue = val
                )
                if (!hasNull)
                (§
                    this.count++
                    this.hasNull = true
                )
                return this
            )
            leafFlag.val = null
            INode n = ((root == null) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag)
            if (n != this.root)
            (§
                this.root = n
            )
            if (leafFlag.val != null)
            (§
                this.count++
            )
            return this
        )

        ITransientMap doWithout(Object key)
        (§
            if (key == null)
            (§
                if (!hasNull)
                (§
                    return this
                )
                hasNull = false
                nullValue = null
                this.count--
                return this
            )
            if (root == null)
            (§
                return this
            )
            leafFlag.val = null
            INode n = root.without(edit, 0, hash(key), key, leafFlag)
            if (n != root)
            (§
                this.root = n
            )
            if (leafFlag.val != null)
            (§
                this.count--
            )
            return this
        )

        IPersistentMap doPersistent()
        (§
            edit.set(null)
            return new PersistentHashMap(count, root, hasNull, nullValue)
        )

        Object doValAt(Object key, Object notFound)
        (§
            if (key == null)
            (§
                if (hasNull)
                (§
                    return nullValue
                )
                else
                (§
                    return notFound
                )
            )
            if (root == null)
            (§
                return notFound
            )
            return root.find(0, hash(key), key, notFound)
        )

        int doCount()
        (§
            return count
        )

        void ensureEditable()
        (§
            if (edit.get() == null)
            (§
                throw new IllegalAccessError("Transient used after persistent! call")
            )
        )
    )

    static interface INode extends Serializable
    (§
        INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)

        INode without(int shift, int hash, Object key)

        IMapEntry find(int shift, int hash, Object key)

        Object find(int shift, int hash, Object key, Object notFound)

        ISeq nodeSeq()

        INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)

        INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)

        public Object kvreduce(IFn f, Object init)

        Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)

        ;; returns the result of (f [k v]) for each iterated element
        Iterator iterator(IFn f)
    )

    final static class ArrayNode implements INode
    (§
        int count
        final INode[] array
        final AtomicReference<Thread> edit

        ArrayNode(AtomicReference<Thread> edit, int count, INode[] array)
        (§
            this.array = array
            this.edit = edit
            this.count = count
        )

        public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == null)
            (§
                return new ArrayNode(null, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))
            )
            INode n = node.assoc(shift + 5, hash, key, val, addedLeaf)
            if (n == node)
            (§
                return this
            )
            return new ArrayNode(null, count, cloneAndSet(array, idx, n))
        )

        public INode without(int shift, int hash, Object key)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == null)
            (§
                return this
            )
            INode n = node.without(shift + 5, hash, key)
            if (n == node)
            (§
                return this
            )
            if (n == null)
            (§
                if (count <= 8) ;; shrink
                (§
                    return pack(null, idx)
                )
                return new ArrayNode(null, count - 1, cloneAndSet(array, idx, n))
            )
            else
            (§
                return new ArrayNode(null, count, cloneAndSet(array, idx, n))
            )
        )

        public IMapEntry find(int shift, int hash, Object key)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == null)
            (§
                return null
            )
            return node.find(shift + 5, hash, key)
        )

        public Object find(int shift, int hash, Object key, Object notFound)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == null)
            (§
                return notFound
            )
            return node.find(shift + 5, hash, key, notFound)
        )

        public ISeq nodeSeq()
        (§
            return Seq.create(array)
        )

        public Iterator iterator(IFn f)
        (§
            return new Iter(array, f)
        )

        public Object kvreduce(IFn f, Object init)
        (§
            for (INode node :in array)
            (§
                if (node != null)
                (§
                    init = node.kvreduce(f, init)
                    if (RT.isReduced(init))
                    (§
                        return init
                    )
                )
            )
            return init
        )

        public Object fold(final IFn combinef, final IFn reducef, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
        (§
            List<Callable> tasks = new ArrayList()
            for (final INode node :in array)
            (§
                if (node != null)
                (§
                    tasks.add(new Callable()
                    (§
                        public Object call() throws Exception
                        (§
                            return node.fold(combinef, reducef, fjtask, fjfork, fjjoin)
                        )
                    ))
                )
            )

            return foldTasks(tasks, combinef, fjtask, fjfork, fjjoin)
        )

        static public Object foldTasks(List<Callable> tasks, final IFn combinef, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
        (§
            if (tasks.isEmpty())
            (§
                return combinef.invoke()
            )

            if (tasks.size() == 1)
            (§
                Object ret = null
                try
                (§
                    return tasks.get(0).call()
                )
                catch (Exception e)
                (§
                    throw Util.sneakyThrow(e)
                )
            )

            List<Callable> t1 = tasks.subList(0, tasks.size() / 2)
            final List<Callable> t2 = tasks.subList(tasks.size() / 2, tasks.size())

            Object forked = fjfork.invoke(fjtask.invoke(new Callable()
            (§
                public Object call() throws Exception
                (§
                    return foldTasks(t2, combinef, fjtask, fjfork, fjjoin)
                )
            )))

            return combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked))
        )

        private ArrayNode ensureEditable(AtomicReference<Thread> edit)
        (§
            if (this.edit == edit)
            (§
                return this
            )
            return new ArrayNode(edit, count, this.array.clone())
        )

        private ArrayNode editAndSet(AtomicReference<Thread> edit, int i, INode n)
        (§
            ArrayNode editable = ensureEditable(edit)
            editable.array[i] = n
            return editable
        )

        private INode pack(AtomicReference<Thread> edit, int idx)
        (§
            Object[] newArray = new Object[2 * (count - 1)]
            int j = 1
            int bitmap = 0
            for (int i = 0 i < idx i++)
            (§
                if (array[i] != null)
                (§
                    newArray[j] = array[i]
                    bitmap |= 1 << i
                    j += 2
                )
            )
            for (int i = idx + 1 i < array.length i++)
            (§
                if (array[i] != null)
                (§
                    newArray[j] = array[i]
                    bitmap |= 1 << i
                    j += 2
                )
            )
            return new BitmapIndexedNode(edit, bitmap, newArray)
        )

        public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == null)
            (§
                ArrayNode editable = editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf))
                editable.count++
                return editable
            )
            INode n = node.assoc(edit, shift + 5, hash, key, val, addedLeaf)
            if (n == node)
            (§
                return this
            )
            return editAndSet(edit, idx, n)
        )

        public INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == null)
            (§
                return this
            )
            INode n = node.without(edit, shift + 5, hash, key, removedLeaf)
            if (n == node)
            (§
                return this
            )
            if (n == null)
            (§
                if (count <= 8) ;; shrink
                (§
                    return pack(edit, idx)
                )
                ArrayNode editable = editAndSet(edit, idx, n)
                editable.count--
                return editable
            )
            return editAndSet(edit, idx, n)
        )

        static class Seq extends ASeq
        (§
            final INode[] nodes
            final int i
            final ISeq s

            static ISeq create(INode[] nodes)
            (§
                return create(null, nodes, 0, null)
            )

            private static ISeq create(IPersistentMap meta, INode[] nodes, int i, ISeq s)
            (§
                if (s != null)
                (§
                    return new Seq(meta, nodes, i, s)
                )
                for (int j = i j < nodes.length j++)
                (§
                    if (nodes[j] != null)
                    (§
                        ISeq ns = nodes[j].nodeSeq()
                        if (ns != null)
                        (§
                            return new Seq(meta, nodes, j + 1, ns)
                        )
                    )
                )
                return null
            )

            private Seq(IPersistentMap meta, INode[] nodes, int i, ISeq s)
            (§
                super(meta)
                this.nodes = nodes
                this.i = i
                this.s = s
            )

            public Obj withMeta(IPersistentMap meta)
            (§
                return new Seq(meta, nodes, i, s)
            )

            public Object first()
            (§
                return s.first()
            )

            public ISeq next()
            (§
                return create(null, nodes, i, s.next())
            )
        )

        static class Iter implements Iterator
        (§
            private final INode[] array
            private final IFn f
            private int i = 0
            private Iterator nestedIter

            private Iter(INode[] array, IFn f)
            (§
                this.array = array
                this.f = f
            )

            public boolean hasNext()
            (§
                while (true)
                (§
                    if (nestedIter != null)
                    (§
                        if (nestedIter.hasNext())
                        (§
                            return true
                        )
                        else
                        (§
                            nestedIter = null
                        )
                    )

                    if (i < array.length)
                    (§
                        INode node = array[i++]
                        if (node != null)
                        (§
                            nestedIter = node.iterator(f)
                        )
                    )
                    else
                    (§
                        return false
                    )
                )
            )

            public Object next()
            (§
                if (hasNext())
                (§
                    return nestedIter.next()
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    final static class BitmapIndexedNode implements INode
    (§
        static final BitmapIndexedNode EMPTY = new BitmapIndexedNode(null, 0, new Object[0])

        int bitmap
        Object[] array
        final AtomicReference<Thread> edit

        final int index(int bit)
        (§
            return Integer.bitCount(bitmap & (bit - 1))
        )

        BitmapIndexedNode(AtomicReference<Thread> edit, int bitmap, Object[] array)
        (§
            this.bitmap = bitmap
            this.array = array
            this.edit = edit
        )

        public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int bit = bitpos(hash, shift)
            int idx = index(bit)
            if ((bitmap & bit) != 0)
            (§
                Object keyOrNull = array[2 * idx]
                Object valOrNode = array[2 * idx + 1]
                if (keyOrNull == null)
                (§
                    INode n = ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf)
                    if (n == valOrNode)
                    (§
                        return this
                    )
                    return new BitmapIndexedNode(null, bitmap, cloneAndSet(array, 2 * idx + 1, n))
                )
                if (Util.equiv(key, keyOrNull))
                (§
                    if (val == valOrNode)
                    (§
                        return this
                    )
                    return new BitmapIndexedNode(null, bitmap, cloneAndSet(array, 2 * idx + 1, val))
                )
                addedLeaf.val = addedLeaf
                return new BitmapIndexedNode(null, bitmap, cloneAndSet(array, 2 * idx, null, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val)))
            )
            else
            (§
                int n = Integer.bitCount(bitmap)
                if (n >= 16)
                (§
                    INode[] nodes = new INode[32]
                    int jdx = mask(hash, shift)
                    nodes[jdx] = EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)
                    int j = 0
                    for (int i = 0 i < 32 i++)
                    (§
                        if (((bitmap >>> i) & 1) != 0)
                        (§
                            if (array[j] == null)
                            (§
                                nodes[i] = (INode) array[j + 1]
                            )
                            else
                            (§
                                nodes[i] = EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf)
                            )
                            j += 2
                        )
                    )
                    return new ArrayNode(null, n + 1, nodes)
                )
                else
                (§
                    Object[] newArray = new Object[2 * (n + 1)]
                    System.arraycopy(array, 0, newArray, 0, 2 * idx)
                    newArray[2 * idx] = key
                    addedLeaf.val = addedLeaf
                    newArray[2 * idx + 1] = val
                    System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx))
                    return new BitmapIndexedNode(null, bitmap | bit, newArray)
                )
            )
        )

        public INode without(int shift, int hash, Object key)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                return this
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == null)
            (§
                INode n = ((INode) valOrNode).without(shift + 5, hash, key)
                if (n == valOrNode)
                (§
                    return this
                )
                if (n != null)
                (§
                    return new BitmapIndexedNode(null, bitmap, cloneAndSet(array, 2 * idx + 1, n))
                )
                if (bitmap == bit)
                (§
                    return null
                )
                return new BitmapIndexedNode(null, bitmap :xor bit, removePair(array, idx))
            )
            if (Util.equiv(key, keyOrNull))
            (§
                ;; TODO: collapse
                return new BitmapIndexedNode(null, bitmap :xor bit, removePair(array, idx))
            )
            return this
        )

        public IMapEntry find(int shift, int hash, Object key)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                return null
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == null)
            (§
                return ((INode) valOrNode).find(shift + 5, hash, key)
            )
            if (Util.equiv(key, keyOrNull))
            (§
                return (IMapEntry) MapEntry.create(keyOrNull, valOrNode)
            )
            return null
        )

        public Object find(int shift, int hash, Object key, Object notFound)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                return notFound
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == null)
            (§
                return ((INode) valOrNode).find(shift + 5, hash, key, notFound)
            )
            if (Util.equiv(key, keyOrNull))
            (§
                return valOrNode
            )
            return notFound
        )

        public ISeq nodeSeq()
        (§
            return NodeSeq.create(array)
        )

        public Iterator iterator(IFn f)
        (§
            return new NodeIter(array, f)
        )

        public Object kvreduce(IFn f, Object init)
        (§
            return NodeSeq.kvreduce(array, f, init)
        )

        public Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
        (§
            return NodeSeq.kvreduce(array, reducef, combinef.invoke())
        )

        private BitmapIndexedNode ensureEditable(AtomicReference<Thread> edit)
        (§
            if (this.edit == edit)
            (§
                return this
            )
            int n = Integer.bitCount(bitmap)
            Object[] newArray = new Object[(n >= 0) ? 2 * (n + 1) :or 4] ;; make room for next assoc
            System.arraycopy(array, 0, newArray, 0, 2 * n)
            return new BitmapIndexedNode(edit, bitmap, newArray)
        )

        private BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
        (§
            BitmapIndexedNode editable = ensureEditable(edit)
            editable.array[i] = a
            return editable
        )

        private BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
        (§
            BitmapIndexedNode editable = ensureEditable(edit)
            editable.array[i] = a
            editable.array[j] = b
            return editable
        )

        private BitmapIndexedNode editAndRemovePair(AtomicReference<Thread> edit, int bit, int i)
        (§
            if (bitmap == bit)
            (§
                return null
            )
            BitmapIndexedNode editable = ensureEditable(edit)
            editable.bitmap ^= bit
            System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1))
            editable.array[editable.array.length - 2] = null
            editable.array[editable.array.length - 1] = null
            return editable
        )

        public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int bit = bitpos(hash, shift)
            int idx = index(bit)
            if ((bitmap & bit) != 0)
            (§
                Object keyOrNull = array[2 * idx]
                Object valOrNode = array[2 * idx + 1]
                if (keyOrNull == null)
                (§
                    INode n = ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf)
                    if (n == valOrNode)
                    (§
                        return this
                    )
                    return editAndSet(edit, 2 * idx + 1, n)
                )
                if (Util.equiv(key, keyOrNull))
                (§
                    if (val == valOrNode)
                    (§
                        return this
                    )
                    return editAndSet(edit, 2 * idx + 1, val)
                )
                addedLeaf.val = addedLeaf
                return editAndSet(edit, 2 * idx, null, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val))
            )
            else
            (§
                int n = Integer.bitCount(bitmap)
                if (n * 2 < array.length)
                (§
                    addedLeaf.val = addedLeaf
                    BitmapIndexedNode editable = ensureEditable(edit)
                    System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx))
                    editable.array[2 * idx] = key
                    editable.array[2 * idx + 1] = val
                    editable.bitmap |= bit
                    return editable
                )
                if (n >= 16)
                (§
                    INode[] nodes = new INode[32]
                    int jdx = mask(hash, shift)
                    nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)
                    int j = 0
                    for (int i = 0 i < 32 i++)
                    (§
                        if (((bitmap >>> i) & 1) != 0)
                        (§
                            if (array[j] == null)
                            (§
                                nodes[i] = (INode) array[j + 1]
                            )
                            else
                            (§
                                nodes[i] = EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf)
                            )
                            j += 2
                        )
                    )
                    return new ArrayNode(edit, n + 1, nodes)
                )
                else
                (§
                    Object[] newArray = new Object[2 * (n + 4)]
                    System.arraycopy(array, 0, newArray, 0, 2 * idx)
                    newArray[2 * idx] = key
                    addedLeaf.val = addedLeaf
                    newArray[2 * idx + 1] = val
                    System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx))
                    BitmapIndexedNode editable = ensureEditable(edit)
                    editable.array = newArray
                    editable.bitmap |= bit
                    return editable
                )
            )
        )

        public INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                return this
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == null)
            (§
                INode n = ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf)
                if (n == valOrNode)
                (§
                    return this
                )
                if (n != null)
                (§
                    return editAndSet(edit, 2 * idx + 1, n)
                )
                if (bitmap == bit)
                (§
                    return null
                )
                return editAndRemovePair(edit, bit, idx)
            )
            if (Util.equiv(key, keyOrNull))
            (§
                removedLeaf.val = removedLeaf
                ;; TODO: collapse
                return editAndRemovePair(edit, bit, idx)
            )
            return this
        )
    )

    final static class HashCollisionNode implements INode
    (§
        final int hash
        int count
        Object[] array
        final AtomicReference<Thread> edit

        HashCollisionNode(AtomicReference<Thread> edit, int hash, int count, Object... array)
        (§
            this.edit = edit
            this.hash = hash
            this.count = count
            this.array = array
        )

        public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            if (hash == this.hash)
            (§
                int idx = findIndex(key)
                if (idx != -1)
                (§
                    if (array[idx + 1] == val)
                    (§
                        return this
                    )
                    return new HashCollisionNode(null, hash, count, cloneAndSet(array, idx + 1, val))
                )
                Object[] newArray = new Object[2 * (count + 1)]
                System.arraycopy(array, 0, newArray, 0, 2 * count)
                newArray[2 * count] = key
                newArray[2 * count + 1] = val
                addedLeaf.val = addedLeaf
                return new HashCollisionNode(edit, hash, count + 1, newArray)
            )
            ;; nest it in a bitmap node
            return new BitmapIndexedNode(null, bitpos(this.hash, shift), new Object[] (§ null, this )).assoc(shift, hash, key, val, addedLeaf)
        )

        public INode without(int shift, int hash, Object key)
        (§
            int idx = findIndex(key)
            if (idx == -1)
            (§
                return this
            )
            if (count == 1)
            (§
                return null
            )
            return new HashCollisionNode(null, hash, count - 1, removePair(array, idx / 2))
        )

        public IMapEntry find(int shift, int hash, Object key)
        (§
            int idx = findIndex(key)
            if (idx < 0)
            (§
                return null
            )
            if (Util.equiv(key, array[idx]))
            (§
                return (IMapEntry) MapEntry.create(array[idx], array[idx + 1])
            )
            return null
        )

        public Object find(int shift, int hash, Object key, Object notFound)
        (§
            int idx = findIndex(key)
            if (idx < 0)
            (§
                return notFound
            )
            if (Util.equiv(key, array[idx]))
            (§
                return array[idx + 1]
            )
            return notFound
        )

        public ISeq nodeSeq()
        (§
            return NodeSeq.create(array)
        )

        public Iterator iterator(IFn f)
        (§
            return new NodeIter(array, f)
        )

        public Object kvreduce(IFn f, Object init)
        (§
            return NodeSeq.kvreduce(array, f, init)
        )

        public Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
        (§
            return NodeSeq.kvreduce(array, reducef, combinef.invoke())
        )

        public int findIndex(Object key)
        (§
            for (int i = 0 i < 2 * count i += 2)
            (§
                if (Util.equiv(key, array[i]))
                (§
                    return i
                )
            )
            return -1
        )

        private HashCollisionNode ensureEditable(AtomicReference<Thread> edit)
        (§
            if (this.edit == edit)
            (§
                return this
            )
            Object[] newArray = new Object[2 * (count + 1)] ;; make room for next assoc
            System.arraycopy(array, 0, newArray, 0, 2 * count)
            return new HashCollisionNode(edit, hash, count, newArray)
        )

        private HashCollisionNode ensureEditable(AtomicReference<Thread> edit, int count, Object[] array)
        (§
            if (this.edit == edit)
            (§
                this.array = array
                this.count = count
                return this
            )
            return new HashCollisionNode(edit, hash, count, array)
        )

        private HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
        (§
            HashCollisionNode editable = ensureEditable(edit)
            editable.array[i] = a
            return editable
        )

        private HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
        (§
            HashCollisionNode editable = ensureEditable(edit)
            editable.array[i] = a
            editable.array[j] = b
            return editable
        )

        public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            if (hash == this.hash)
            (§
                int idx = findIndex(key)
                if (idx != -1)
                (§
                    if (array[idx + 1] == val)
                    (§
                        return this
                    )
                    return editAndSet(edit, idx + 1, val)
                )
                if (array.length > 2 * count)
                (§
                    addedLeaf.val = addedLeaf
                    HashCollisionNode editable = editAndSet(edit, 2 * count, key, 2 * count + 1, val)
                    editable.count++
                    return editable
                )
                Object[] newArray = new Object[array.length + 2]
                System.arraycopy(array, 0, newArray, 0, array.length)
                newArray[array.length] = key
                newArray[array.length + 1] = val
                addedLeaf.val = addedLeaf
                return ensureEditable(edit, count + 1, newArray)
            )
            ;; nest it in a bitmap node
            return new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ null, this, null, null )).assoc(edit, shift, hash, key, val, addedLeaf)
        )

        public INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
        (§
            int idx = findIndex(key)
            if (idx == -1)
            (§
                return this
            )
            removedLeaf.val = removedLeaf
            if (count == 1)
            (§
                return null
            )
            HashCollisionNode editable = ensureEditable(edit)
            editable.array[idx] = editable.array[2 * count - 2]
            editable.array[idx + 1] = editable.array[2 * count - 1]
            editable.array[2 * count - 2] = editable.array[2 * count - 1] = null
            editable.count--
            return editable
        )
    )

    private static INode[] cloneAndSet(INode[] array, int i, INode a)
    (§
        INode[] clone = array.clone()
        clone[i] = a
        return clone
    )

    private static Object[] cloneAndSet(Object[] array, int i, Object a)
    (§
        Object[] clone = array.clone()
        clone[i] = a
        return clone
    )

    private static Object[] cloneAndSet(Object[] array, int i, Object a, int j, Object b)
    (§
        Object[] clone = array.clone()
        clone[i] = a
        clone[j] = b
        return clone
    )

    private static Object[] removePair(Object[] array, int i)
    (§
        Object[] newArray = new Object[array.length - 2]
        System.arraycopy(array, 0, newArray, 0, 2 * i)
        System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i)
        return newArray
    )

    private static INode createNode(int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
    (§
        int key1hash = hash(key1)
        if (key1hash == key2hash)
        (§
            return new HashCollisionNode(null, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))
        )
        Box addedLeaf = new Box(null)
        AtomicReference<Thread> edit = new AtomicReference<Thread>()
        return BitmapIndexedNode.EMPTY
            .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
            .assoc(edit, shift, key2hash, key2, val2, addedLeaf)
    )

    private static INode createNode(AtomicReference<Thread> edit, int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
    (§
        int key1hash = hash(key1)
        if (key1hash == key2hash)
        (§
            return new HashCollisionNode(null, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))
        )
        Box addedLeaf = new Box(null)
        return BitmapIndexedNode.EMPTY
            .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
            .assoc(edit, shift, key2hash, key2, val2, addedLeaf)
    )

    private static int bitpos(int hash, int shift)
    (§
        return 1 << mask(hash, shift)
    )

    static final class NodeIter implements Iterator
    (§
        private static final Object NULL = new Object()
        final Object[] array
        final IFn f
        private int i = 0
        private Object nextEntry = NULL
        private Iterator nextIter

        NodeIter(Object[] array, IFn f)
        (§
            this.array = array
            this.f = f
        )

        private boolean advance()
        (§
            while (i<array.length)
            (§
                Object key = array[i]
                Object nodeOrVal = array[i + 1]
                i += 2
                if (key != null)
                (§
                    nextEntry = f.invoke(key, nodeOrVal)
                    return true
                )
                else if (nodeOrVal != null)
                (§
                    Iterator iter = ((INode) nodeOrVal).iterator(f)
                    if (iter != null && iter.hasNext())
                    (§
                        nextIter = iter
                        return true
                    )
                )
            )
            return false
        )

        public boolean hasNext()
        (§
            if (nextEntry != NULL || nextIter != null)
            (§
                return true
            )
            return advance()
        )

        public Object next()
        (§
            Object ret = nextEntry
            if (ret != NULL)
            (§
                nextEntry = NULL
                return ret
            )
            else if (nextIter != null)
            (§
                ret = nextIter.next()
                if (!nextIter.hasNext())
                (§
                    nextIter = null
                )
                return ret
            )
            else if (advance())
            (§
                return next()
            )
            throw new NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    static final class NodeSeq extends ASeq
    (§
        final Object[] array
        final int i
        final ISeq s

        NodeSeq(Object[] array, int i)
        (§
            this(null, array, i, null)
        )

        static ISeq create(Object[] array)
        (§
            return create(array, 0, null)
        )

        static public Object kvreduce(Object[] array, IFn f, Object init)
        (§
            for (int i = 0 i < array.length i += 2)
            (§
                if (array[i] != null)
                (§
                    init = f.invoke(init, array[i], array[i + 1])
                )
                else
                (§
                    INode node = (INode) array[i + 1]
                    if (node != null)
                    (§
                        init = node.kvreduce(f, init)
                    )
                )
                if (RT.isReduced(init))
                (§
                    return init
                )
            )
            return init
        )

        private static ISeq create(Object[] array, int i, ISeq s)
        (§
            if (s != null)
            (§
                return new NodeSeq(null, array, i, s)
            )
            for (int j = i j < array.length j+=2)
            (§
                if (array[j] != null)
                (§
                    return new NodeSeq(null, array, j, null)
                )
                INode node = (INode) array[j + 1]
                if (node != null)
                (§
                    ISeq nodeSeq = node.nodeSeq()
                    if (nodeSeq != null)
                    (§
                        return new NodeSeq(null, array, j + 2, nodeSeq)
                    )
                )
            )
            return null
        )

        NodeSeq(IPersistentMap meta, Object[] array, int i, ISeq s)
        (§
            super(meta)
            this.array = array
            this.i = i
            this.s = s
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            return new NodeSeq(meta, array, i, s)
        )

        public Object first()
        (§
            if (s != null)
            (§
                return s.first()
            )
            return MapEntry.create(array[i], array[i + 1])
        )

        public ISeq next()
        (§
            if (s != null)
            (§
                return create(array, i, s.next())
            )
            return create(array, i + 2, null)
        )
    )
)
)

(§ java cloiure.lang.PersistentHashSet

import java.util.List

public class PersistentHashSet extends APersistentSet implements IObj, IEditableCollection
(§
    static public final PersistentHashSet EMPTY = new PersistentHashSet(null, PersistentHashMap.EMPTY)

    final IPersistentMap _meta

    public static PersistentHashSet create(Object... init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (int i = 0 i < init.length i++)
        (§
            ret = (ITransientSet)ret.conj(init[i])
        )
        return (PersistentHashSet)ret.persistent()
    )

    public static PersistentHashSet create(List init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (Object key :in init)
        (§
            ret = (ITransientSet) ret.conj(key)
        )
        return (PersistentHashSet)ret.persistent()
    )

    static public PersistentHashSet create(ISeq items)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (  items != null items = items.next())
        (§
            ret = (ITransientSet) ret.conj(items.first())
        )
        return (PersistentHashSet)ret.persistent()
    )

    public static PersistentHashSet createWithCheck(Object... init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (int i = 0 i < init.length i++)
        (§
            ret = (ITransientSet) ret.conj(init[i])
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + init[i])
            )
        )
        return (PersistentHashSet) ret.persistent()
    )

    public static PersistentHashSet createWithCheck(List init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        int i = 0
        for (Object key :in init)
        (§
            ret = (ITransientSet) ret.conj(key)
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + key)
            )
            ++i
        )
        return (PersistentHashSet) ret.persistent()
    )

    static public PersistentHashSet createWithCheck(ISeq items)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (int i = 0 items != null items = items.next(), ++i)
        (§
            ret = (ITransientSet) ret.conj(items.first())
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + items.first())
            )
        )
        return (PersistentHashSet) ret.persistent()
    )

    PersistentHashSet(IPersistentMap meta, IPersistentMap impl)
    (§
        super(impl)
        this._meta = meta
    )

    public IPersistentSet disjoin(Object key)
    (§
        if (contains(key))
        (§
            return new PersistentHashSet(meta(), impl.without(key))
        )
        return this
    )

    public IPersistentSet cons(Object o)
    (§
        if (contains(o))
        (§
            return this
        )
        return new PersistentHashSet(meta(), impl.assoc(o, o))
    )

    public IPersistentCollection empty()
    (§
        return EMPTY.withMeta(meta())
    )

    public PersistentHashSet withMeta(IPersistentMap meta)
    (§
        return new PersistentHashSet(meta, impl)
    )

    public ITransientCollection asTransient()
    (§
        return new TransientHashSet(((PersistentHashMap) impl).asTransient())
    )

    public IPersistentMap meta()
    (§
        return _meta
    )

    static final class TransientHashSet extends ATransientSet
    (§
        TransientHashSet(ITransientMap impl)
        (§
            super(impl)
        )

        public IPersistentCollection persistent()
        (§
            return new PersistentHashSet(null, impl.persistent())
        )
    )
)
)

(§ java cloiure.lang.PersistentList

import java.io.Serializable
import java.util.*

public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted
(§
    private final Object _first
    private final IPersistentList _rest
    private final int _count

    static public class Primordial extends RestFn
    (§
        final public int getRequiredArity()
        (§
            return 0
        )

        final protected Object doInvoke(Object args)
        (§
            if (args instanceof ArraySeq)
            (§
                Object[] argsarray = ((ArraySeq) args).array
                IPersistentList ret = EMPTY
                for (int i = argsarray.length - 1 i >= ((ArraySeq)args).i --i)
                (§
                    ret = (IPersistentList) ret.cons(argsarray[i])
                )
                return ret
            )
            LinkedList list = new LinkedList()
            for (ISeq s = RT.seq(args) s != null s = s.next())
            (§
                list.add(s.first())
            )
            return create(list)
        )

        static public Object invokeStatic(ISeq args)
        (§
            if (args instanceof ArraySeq)
            (§
                Object[] argsarray = ((ArraySeq) args).array
                IPersistentList ret = EMPTY
                for (int i = argsarray.length - 1 i >= 0 --i)
                (§
                    ret = (IPersistentList) ret.cons(argsarray[i])
                )
                return ret
            )
            LinkedList list = new LinkedList()
            for (ISeq s = RT.seq(args) s != null s = s.next())
            (§
                list.add(s.first())
            )
            return create(list)
        )

        public IObj withMeta(IPersistentMap meta)
        (§
            throw new UnsupportedOperationException()
        )

        public IPersistentMap meta()
        (§
            return null
        )
    )

    public static IFn creator = new Primordial()

    final public static EmptyList EMPTY = new EmptyList(null)

    public PersistentList(Object first)
    (§
        this._first = first
        this._rest = null

        this._count = 1
    )

    PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count)
    (§
        super(meta)
        this._first = _first
        this._rest = _rest
        this._count = _count
    )

    public static IPersistentList create(List init)
    (§
        IPersistentList ret = EMPTY
        for (ListIterator i = init.listIterator(init.size()) i.hasPrevious() )
        (§
            ret = (IPersistentList) ret.cons(i.previous())
        )
        return ret
    )

    public Object first()
    (§
        return _first
    )

    public ISeq next()
    (§
        if (_count == 1)
        (§
            return null
        )
        return (ISeq) _rest
    )

    public Object peek()
    (§
        return first()
    )

    public IPersistentList pop()
    (§
        if (_rest == null)
        (§
            return EMPTY.withMeta(_meta)
        )
        return _rest
    )

    public int count()
    (§
        return _count
    )

    public PersistentList cons(Object o)
    (§
        return new PersistentList(meta(), o, this, _count + 1)
    )

    public IPersistentCollection empty()
    (§
        return EMPTY.withMeta(meta())
    )

    public PersistentList withMeta(IPersistentMap meta)
    (§
        if (meta != _meta)
        (§
            return new PersistentList(meta, _first, _rest, _count)
        )
        return this
    )

    public Object reduce(IFn f)
    (§
        Object ret = first()
        for (ISeq s = next() s != null s = s.next())
        (§
            ret = f.invoke(ret, s.first())
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
        )
        return ret
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = f.invoke(start, first())
        for (ISeq s = next() s != null s = s.next())
        (§
            if (RT.isReduced(ret))
            (§
                return ((IDeref)ret).deref()
            )
            ret = f.invoke(ret, s.first())
        )
        if (RT.isReduced(ret))
        (§
            return ((IDeref)ret).deref()
        )
        return ret
    )

    static class EmptyList extends Obj implements IPersistentList, List, ISeq, Counted, IHashEq
    (§
        static final int hasheq = Murmur3.hashOrdered(Collections.EMPTY_LIST)

        public int hashCode()
        (§
            return 1
        )

        public int hasheq()
        (§
            return hasheq
        )

        public String toString()
        (§
            return "()"
        )

        public boolean equals(Object o)
        (§
            return ((o instanceof Sequential || o instanceof List) && RT.seq(o) == null)
        )

        public boolean equiv(Object o)
        (§
            return equals(o)
        )

        EmptyList(IPersistentMap meta)
        (§
            super(meta)
        )

        public Object first()
        (§
            return null
        )

        public ISeq next()
        (§
            return null
        )

        public ISeq more()
        (§
            return this
        )

        public PersistentList cons(Object o)
        (§
            return new PersistentList(meta(), o, null, 1)
        )

        public IPersistentCollection empty()
        (§
            return this
        )

        public EmptyList withMeta(IPersistentMap meta)
        (§
            if (meta != meta())
            (§
                return new EmptyList(meta)
            )
            return this
        )

        public Object peek()
        (§
            return null
        )

        public IPersistentList pop()
        (§
            throw new IllegalStateException("Can't pop empty list")
        )

        public int count()
        (§
            return 0
        )

        public ISeq seq()
        (§
            return null
        )

        public int size()
        (§
            return 0
        )

        public boolean isEmpty()
        (§
            return true
        )

        public boolean contains(Object o)
        (§
            return false
        )

        public Iterator iterator()
        (§
            return new Iterator()
            (§
                public boolean hasNext()
                (§
                    return false
                )

                public Object next()
                (§
                    throw new NoSuchElementException()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )

        public Object[] toArray()
        (§
            return RT.EMPTY_ARRAY
        )

        public boolean add(Object o)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean remove(Object o)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean addAll(Collection collection)
        (§
            throw new UnsupportedOperationException()
        )

        public void clear()
        (§
            throw new UnsupportedOperationException()
        )

        public boolean retainAll(Collection collection)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean removeAll(Collection collection)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean containsAll(Collection collection)
        (§
            return collection.isEmpty()
        )

        public Object[] toArray(Object[] objects)
        (§
            if (objects.length > 0)
            (§
                objects[0] = null
            )
            return objects
        )

        private List reify()
        (§
            return Collections.unmodifiableList(new ArrayList(this))
        )

        public List subList(int fromIndex, int toIndex)
        (§
            return reify().subList(fromIndex, toIndex)
        )

        public Object set(int index, Object element)
        (§
            throw new UnsupportedOperationException()
        )

        public Object remove(int index)
        (§
            throw new UnsupportedOperationException()
        )

        public int indexOf(Object o)
        (§
            ISeq s = seq()
            for (int i = 0 s != null s = s.next(), i++)
            (§
                if (Util.equiv(s.first(), o))
                (§
                    return i
                )
            )
            return -1
        )

        public int lastIndexOf(Object o)
        (§
            return reify().lastIndexOf(o)
        )

        public ListIterator listIterator()
        (§
            return reify().listIterator()
        )

        public ListIterator listIterator(int index)
        (§
            return reify().listIterator(index)
        )

        public Object get(int index)
        (§
            return RT.nth(this, index)
        )

        public void add(int index, Object element)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean addAll(int index, Collection c)
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(§ java cloiure.lang.PersistentQueue

import java.util.Collection
import java.util.Iterator
import java.util.NoSuchElementException

;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;
public class PersistentQueue extends Obj implements IPersistentList, Collection, Counted, IHashEq
(§
    final public static PersistentQueue EMPTY = new PersistentQueue(null, 0, null, null)

    final int cnt
    final ISeq f
    final PersistentVector r
    int _hash
    int _hasheq

    PersistentQueue(IPersistentMap meta, int cnt, ISeq f, PersistentVector r)
    (§
        super(meta)
        this.cnt = cnt
        this.f = f
        this.r = r
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Sequential))
        (§
            return false
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != null s = s.next(), ms = ms.next())
        (§
            if (ms == null || !Util.equiv(s.first(), ms.first()))
            (§
                return false
            )
        )
        return (ms == null)
    )

    public boolean equals(Object obj)
    (§
        if (!(obj instanceof Sequential))
        (§
            return false
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != null s = s.next(), ms = ms.next())
        (§
            if (ms == null || !Util.equals(s.first(), ms.first()))
            (§
                return false
            )
        )
        return (ms == null)
    )

    public int hashCode()
    (§
        int hash = this._hash
        if (hash == 0)
        (§
            hash = 1
            for (ISeq s = seq() s != null s = s.next())
            (§
                hash = 31 * hash + ((s.first() == null) ? 0 :or s.first().hashCode())
            )
            this._hash = hash
        )
        return hash
    )

    public int hasheq()
    (§
        int cached = this._hasheq
        if (cached == 0)
        (§
            this._hasheq  = cached = Murmur3.hashOrdered(this)
        )
        return cached
    )

    public Object peek()
    (§
        return RT.first(f)
    )

    public PersistentQueue pop()
    (§
        if (f == null) ;; hmmm... pop of empty queue -> empty queue?
        (§
            return this
        )
        ISeq f1 = f.next()
        PersistentVector r1 = r
        if (f1 == null)
        (§
            f1 = RT.seq(r)
            r1 = null
        )
        return new PersistentQueue(meta(), cnt - 1, f1, r1)
    )

    public int count()
    (§
        return cnt
    )

    public ISeq seq()
    (§
        if (f == null)
        (§
            return null
        )
        return new Seq(f, RT.seq(r))
    )

    public PersistentQueue cons(Object o)
    (§
        if (f == null) ;; empty
        (§
            return new PersistentQueue(meta(), cnt + 1, RT.list(o), null)
        )
        else
        (§
            return new PersistentQueue(meta(), cnt + 1, f, ((r != null) ? r :or PersistentVector.EMPTY).cons(o))
        )
    )

    public IPersistentCollection empty()
    (§
        return EMPTY.withMeta(meta())
    )

    public PersistentQueue withMeta(IPersistentMap meta)
    (§
        return new PersistentQueue(meta, cnt, f, r)
    )

    static class Seq extends ASeq
    (§
        final ISeq f
        final ISeq rseq

        Seq(ISeq f, ISeq rseq)
        (§
            this.f = f
            this.rseq = rseq
        )

        Seq(IPersistentMap meta, ISeq f, ISeq rseq)
        (§
            super(meta)
            this.f = f
            this.rseq = rseq
        )

        public Object first()
        (§
            return f.first()
        )

        public ISeq next()
        (§
            ISeq f1 = f.next()
            ISeq r1 = rseq
            if (f1 == null)
            (§
                if (rseq == null)
                (§
                    return null
                )
                f1 = rseq
                r1 = null
            )
            return new Seq(f1, r1)
        )

        public int count()
        (§
            return RT.count(f) + RT.count(rseq)
        )

        public Seq withMeta(IPersistentMap meta)
        (§
            return new Seq(meta, f, rseq)
        )
    )

    public Object[] toArray()
    (§
        return RT.seqToArray(seq())
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (contains(o))
            (§
                return true
            )
        )
        return false
    )

    public Object[] toArray(Object[] a)
    (§
        return RT.seqToPassedArray(seq(), a)
    )

    public int size()
    (§
        return count()
    )

    public boolean isEmpty()
    (§
        return (count() == 0)
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != null s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                return true
            )
        )
        return false
    )

    public Iterator iterator()
    (§
        return new Iterator()
        (§
            private ISeq fseq = f
            private final Iterator riter = (r != null) ? r.iterator() :or null

            public boolean hasNext()
            (§
                return ((fseq != null && fseq.seq() != null) || (riter != null && riter.hasNext()))
            )

            public Object next()
            (§
                if (fseq != null)
                (§
                    Object ret = fseq.first()
                    fseq = fseq.next()
                    return ret
                )
                else if (riter != null && riter.hasNext())
                (§
                    return riter.next()
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )
)
)

(§ java cloiure.lang.PersistentStructMap

import java.util.Iterator
import java.util.Map
import java.io.Serializable
import java.util.NoSuchElementException

public class PersistentStructMap extends APersistentMap implements IObj
(§
    public static class Def implements Serializable
    (§
        final ISeq keys
        final IPersistentMap keyslots

        Def(ISeq keys, IPersistentMap keyslots)
        (§
            this.keys = keys
            this.keyslots = keyslots
        )
    )

    final Def def
    final Object[] vals
    final IPersistentMap ext
    final IPersistentMap _meta

    static public Def createSlotMap(ISeq keys)
    (§
        if (keys == null)
        (§
            throw new IllegalArgumentException("Must supply keys")
        )
        int c = RT.count(keys)
        Object[] v = new Object[2 * c]
        int i = 0
        for (ISeq s = keys s != null s = s.next(), i++)
        (§
            v[2 * i] =  s.first()
            v[2 * i + 1] = i
        )
        return new Def(keys, RT.map(v))
    )

    static public PersistentStructMap create(Def def, ISeq keyvals)
    (§
        Object[] vals = new Object[def.keyslots.count()]
        IPersistentMap ext = PersistentHashMap.EMPTY
        for (  keyvals != null keyvals = keyvals.next().next())
        (§
            if (keyvals.next() == null)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", keyvals.first()))
            )
            Object k = keyvals.first()
            Object v = RT.second(keyvals)
            Map.Entry e = def.keyslots.entryAt(k)
            if (e != null)
            (§
                vals[(Integer) e.getValue()] = v
            )
            else
            (§
                ext = ext.assoc(k, v)
            )
        )
        return new PersistentStructMap(null, def, vals, ext)
    )

    static public PersistentStructMap construct(Def def, ISeq valseq)
    (§
        Object[] vals = new Object[def.keyslots.count()]
        IPersistentMap ext = PersistentHashMap.EMPTY
        for (int i = 0 i < vals.length && valseq != null valseq = valseq.next(), i++)
        (§
            vals[i] = valseq.first()
        )
        if (valseq != null)
        (§
            throw new IllegalArgumentException("Too many arguments to struct constructor")
        )
        return new PersistentStructMap(null, def, vals, ext)
    )

    static public IFn getAccessor(final Def def, Object key)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != null)
        (§
            final int i = (Integer) e.getValue()
            return new AFn()
            (§
                public Object invoke(Object arg1)
                (§
                    PersistentStructMap m = (PersistentStructMap) arg1
                    if (m.def != def)
                    (§
                        throw Util.runtimeException("Accessor/struct mismatch")
                    )
                    return m.vals[i]
                )
            )
        )
        throw new IllegalArgumentException("Not a key of struct")
    )

    protected PersistentStructMap(IPersistentMap meta, Def def, Object[] vals, IPersistentMap ext)
    (§
        this._meta = meta
        this.ext = ext
        this.def = def
        this.vals = vals
    )

    ;;
     ; Returns a new instance of PersistentStructMap using the given parameters.
     ; This function is used instead of the PersistentStructMap constructor by
     ; all methods that return a new PersistentStructMap.  This is done so as to
     ; allow subclasses to return instances of their class from all
     ; PersistentStructMap methods.
     ;
    protected PersistentStructMap makeNew(IPersistentMap meta, Def def, Object[] vals, IPersistentMap ext)
    (§
        return new PersistentStructMap(meta, def, vals, ext)
    )

    public IObj withMeta(IPersistentMap meta)
    (§
        if (meta == _meta)
        (§
            return this
        )
        return makeNew(meta, def, vals, ext)
    )

    public IPersistentMap meta()
    (§
        return _meta
    )

    public boolean containsKey(Object key)
    (§
        return def.keyslots.containsKey(key) || ext.containsKey(key)
    )

    public IMapEntry entryAt(Object key)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != null)
        (§
            return (IMapEntry) MapEntry.create(e.getKey(), vals[(Integer) e.getValue()])
        )
        return ext.entryAt(key)
    )

    public IPersistentMap assoc(Object key, Object val)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != null)
        (§
            int i = (Integer) e.getValue()
            Object[] newVals = vals.clone()
            newVals[i] = val
            return makeNew(_meta, def, newVals, ext)
        )
        return makeNew(_meta, def, vals, ext.assoc(key, val))
    )

    public Object valAt(Object key)
    (§
        Integer i = (Integer) def.keyslots.valAt(key)
        if (i != null)
        (§
            return vals[i]
        )
        return ext.valAt(key)
    )

    public Object valAt(Object key, Object notFound)
    (§
        Integer i = (Integer) def.keyslots.valAt(key)
        if (i != null)
        (§
            return vals[i]
        )
        return ext.valAt(key, notFound)
    )

    public IPersistentMap assocEx(Object key, Object val)
    (§
        if (containsKey(key))
        (§
            throw Util.runtimeException("Key already present")
        )
        return assoc(key, val)
    )

    public IPersistentMap without(Object key)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != null)
        (§
            throw Util.runtimeException("Can't remove struct key")
        )
        IPersistentMap newExt = ext.without(key)
        if (newExt == ext)
        (§
            return this
        )
        return makeNew(_meta, def, vals, newExt)
    )

    public Iterator iterator()
    (§
        return new Iterator()
        (§
            private ISeq ks = def.keys
            private Iterator extIter = (ext == null) ? null :or ext.iterator()

            public boolean hasNext()
            (§
                return ((ks != null && ks.seq() != null) || (extIter != null && extIter.hasNext()))
            )

            public Object next()
            (§
                if (ks != null)
                (§
                    Object key = ks.first()
                    ks = ks.next()
                    return entryAt(key)
                )
                else if (extIter != null && extIter.hasNext())
                (§
                    return extIter.next()
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    public int count()
    (§
        return vals.length + RT.count(ext)
    )

    public ISeq seq()
    (§
        return new Seq(null, def.keys, vals, 0, ext)
    )

    public IPersistentCollection empty()
    (§
        return construct(def, null)
    )

    static class Seq extends ASeq
    (§
        final int i
        final ISeq keys
        final Object[] vals
        final IPersistentMap ext

        public Seq(IPersistentMap meta, ISeq keys, Object[] vals, int i, IPersistentMap ext)
        (§
            super(meta)
            this.i = i
            this.keys = keys
            this.vals = vals
            this.ext = ext
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            if (meta != _meta)
            (§
                return new Seq(meta, keys, vals, i, ext)
            )
            return this
        )

        public Object first()
        (§
            return MapEntry.create(keys.first(), vals[i])
        )

        public ISeq next()
        (§
            if (i + 1 < vals.length)
            (§
                return new Seq(_meta, keys.next(), vals, i + 1, ext)
            )
            return ext.seq()
        )
    )
)
)

(§ java cloiure.lang.PersistentTreeMap

import java.util.*

;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 
 ; See Okasaki, Kahrs, Larsen et al
 ;
public class PersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, IKVReduce
(§
    public final Comparator comp
    public final Node tree
    public final int _count
    final IPersistentMap _meta

    final static public PersistentTreeMap EMPTY = new PersistentTreeMap()

    static public IPersistentMap create(Map other)
    (§
        IPersistentMap ret = EMPTY
        for (Object o :in other.entrySet())
        (§
            Map.Entry e = (Entry) o
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        return ret
    )

    public PersistentTreeMap()
    (§
        this(RT.DEFAULT_COMPARATOR)
    )

    public PersistentTreeMap withMeta(IPersistentMap meta)
    (§
        return new PersistentTreeMap(meta, comp, tree, _count)
    )

    private PersistentTreeMap(Comparator comp)
    (§
        this(null, comp)
    )

    public PersistentTreeMap(IPersistentMap meta, Comparator comp)
    (§
        this.comp = comp
        this._meta = meta
        tree = null
        _count = 0
    )

    PersistentTreeMap(IPersistentMap meta, Comparator comp, Node tree, int _count)
    (§
        this._meta = meta
        this.comp = comp
        this.tree = tree
        this._count = _count
    )

    static public PersistentTreeMap create(ISeq items)
    (§
        IPersistentMap ret = EMPTY
        for (  items != null items = items.next().next())
        (§
            if (items.next() == null)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
        )
        return (PersistentTreeMap) ret
    )

    static public PersistentTreeMap create(Comparator comp, ISeq items)
    (§
        IPersistentMap ret = new PersistentTreeMap(comp)
        for (  items != null items = items.next().next())
        (§
            if (items.next() == null)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
        )
        return (PersistentTreeMap) ret
    )

    public boolean containsKey(Object key)
    (§
        return (entryAt(key) != null)
    )

    public boolean equals(Object obj)
    (§
        try
        (§
            return super.equals(obj)
        )
        catch (ClassCastException e)
        (§
            return false
        )
    )

    public boolean equiv(Object obj)
    (§
        try
        (§
            return super.equiv(obj)
        )
        catch (ClassCastException e)
        (§
            return false
        )
    )

    public PersistentTreeMap assocEx(Object key, Object val)
    (§
        Box found = new Box(null)
        Node t = add(tree, key, val, found)
        if (t == null) ;; null == already contains key
        (§
            throw Util.runtimeException("Key already present")
        )
        return new PersistentTreeMap(comp, t.blacken(), _count + 1, meta())
    )

    public PersistentTreeMap assoc(Object key, Object val)
    (§
        Box found = new Box(null)
        Node t = add(tree, key, val, found)
        if (t == null) ;; null == already contains key
        (§
            Node foundNode = (Node) found.val
            if (foundNode.val() == val) ;; note only get same collection on identity of val, not equals()
            (§
                return this
            )
            return new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())
        )
        return new PersistentTreeMap(comp, t.blacken(), _count + 1, meta())
    )

    public PersistentTreeMap without(Object key)
    (§
        Box found = new Box(null)
        Node t = remove(tree, key, found)
        if (t == null)
        (§
            if (found.val == null) ;; null == doesn't contain key
            (§
                return this
            )
            ;; empty
            return new PersistentTreeMap(meta(), comp)
        )
        return new PersistentTreeMap(comp, t.blacken(), _count - 1, meta())
    )

    public ISeq seq()
    (§
        if (_count > 0)
        (§
            return Seq.create(tree, true, _count)
        )
        return null
    )

    public IPersistentCollection empty()
    (§
        return new PersistentTreeMap(meta(), comp)
    )

    public ISeq rseq()
    (§
        if (_count > 0)
        (§
            return Seq.create(tree, false, _count)
        )
        return null
    )

    public Comparator comparator()
    (§
        return comp
    )

    public Object entryKey(Object entry)
    (§
        return ((IMapEntry) entry).key()
    )

    public ISeq seq(boolean ascending)
    (§
        if (_count > 0)
        (§
            return Seq.create(tree, ascending, _count)
        )
        return null
    )

    public ISeq seqFrom(Object key, boolean ascending)
    (§
        if (_count > 0)
        (§
            ISeq stack = null
            Node t = tree
            while (t != null)
            (§
                int c = doCompare(key, t.key)
                if (c == 0)
                (§
                    stack = RT.cons(t, stack)
                    return new Seq(stack, ascending)
                )
                else if (ascending)
                (§
                    if (c < 0)
                    (§
                        stack = RT.cons(t, stack)
                        t = t.left()
                    )
                    else
                    (§
                        t = t.right()
                    )
                )
                else
                (§
                    if (c > 0)
                    (§
                        stack = RT.cons(t, stack)
                        t = t.right()
                    )
                    else
                    (§
                        t = t.left()
                    )
                )
            )
            if (stack != null)
            (§
                return new Seq(stack, ascending)
            )
        )
        return null
    )

    public NodeIterator iterator()
    (§
        return new NodeIterator(tree, true)
    )

    public Object kvreduce(IFn f, Object init)
    (§
        if (tree != null)
        (§
            init = tree.kvreduce(f, init)
        )
        if (RT.isReduced(init))
        (§
            init = ((IDeref)init).deref()
        )
        return init
    )

    public NodeIterator reverseIterator()
    (§
        return new NodeIterator(tree, false)
    )

    public Iterator keys()
    (§
        return keys(iterator())
    )

    public Iterator vals()
    (§
        return vals(iterator())
    )

    public Iterator keys(NodeIterator it)
    (§
        return new KeyIterator(it)
    )

    public Iterator vals(NodeIterator it)
    (§
        return new ValIterator(it)
    )

    public Object minKey()
    (§
        Node t = min()
        return (t != null) ? t.key :or null
    )

    public Node min()
    (§
        Node t = tree
        if (t != null)
        (§
            while (t.left() != null)
                t = t.left()
        )
        return t
    )

    public Object maxKey()
    (§
        Node t = max()
        return (t != null) ? t.key :or null
    )

    public Node max()
    (§
        Node t = tree
        if (t != null)
        (§
            while (t.right() != null)
                t = t.right()
        )
        return t
    )

    public int depth()
    (§
        return depth(tree)
    )

    int depth(Node t)
    (§
        if (t == null)
        (§
            return 0
        )
        return 1 + Math.max(depth(t.left()), depth(t.right()))
    )

    public Object valAt(Object key, Object notFound)
    (§
        Node n = entryAt(key)
        return (n != null) ? n.val() :or notFound
    )

    public Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public int capacity()
    (§
        return _count
    )

    public int count()
    (§
        return _count
    )

    public Node entryAt(Object key)
    (§
        Node t = tree
        while (t != null)
        (§
            int c = doCompare(key, t.key)
            if (c == 0)
            (§
                return t
            )
            else if (c < 0)
            (§
                t = t.left()
            )
            else
            (§
                t = t.right()
            )
        )
        return t
    )

    public int doCompare(Object k1, Object k2)
    (§
        return comp.compare(k1, k2)
    )

    Node add(Node t, Object key, Object val, Box found)
    (§
        if (t == null)
        (§
            if (val == null)
            (§
                return new Red(key)
            )
            return new RedVal(key, val)
        )
        int c = doCompare(key, t.key)
        if (c == 0)
        (§
            found.val = t
            return null
        )
        Node ins = (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found)
        if (ins == null) ;; found below
        (§
            return null
        )
        if (c < 0)
        (§
            return t.addLeft(ins)
        )
        return t.addRight(ins)
    )

    Node remove(Node t, Object key, Box found)
    (§
        if (t == null)
        (§
            return null ;; not found indicator
        )
        int c = doCompare(key, t.key)
        if (c == 0)
        (§
            found.val = t
            return append(t.left(), t.right())
        )
        Node del = (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found)
        if (del == null && found.val == null) ;; not found below
        (§
            return null
        )
        if (c < 0)
        (§
            if (t.left() instanceof Black)
            (§
                return balanceLeftDel(t.key, t.val(), del, t.right())
            )
            else
            (§
                return red(t.key, t.val(), del, t.right())
            )
        )
        if (t.right() instanceof Black)
        (§
            return balanceRightDel(t.key, t.val(), t.left(), del)
        )
        return red(t.key, t.val(), t.left(), del)
    )

    static Node append(Node left, Node right)
    (§
        if (left == null)
        (§
            return right
        )
        else if (right == null)
        (§
            return left
        )
        else if (left instanceof Red)
        (§
            if (right instanceof Red)
            (§
                Node app = append(left.right(), right.left())
                if (app instanceof Red)
                (§
                    return red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right()))
                )
                else
                (§
                    return red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right()))
                )
            )
            else
            (§
                return red(left.key, left.val(), left.left(), append(left.right(), right))
            )
        )
        else if (right instanceof Red)
        (§
            return red(right.key, right.val(), append(left, right.left()), right.right())
        )
        else ;; black/black
        (§
            Node app = append(left.right(), right.left())
            if (app instanceof Red)
            (§
                return red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right()))
            )
            else
            (§
                return balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right()))
            )
        )
    )

    static Node balanceLeftDel(Object key, Object val, Node del, Node right)
    (§
        if (del instanceof Red)
        (§
            return red(key, val, del.blacken(), right)
        )
        else if (right instanceof Black)
        (§
            return rightBalance(key, val, del, right.redden())
        )
        else if (right instanceof Red && right.left() instanceof Black)
        (§
            return red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden()))
        )
        else
        (§
            throw new UnsupportedOperationException("Invariant violation")
        )
    )

    static Node balanceRightDel(Object key, Object val, Node left, Node del)
    (§
        if (del instanceof Red)
        (§
            return red(key, val, left, del.blacken())
        )
        else if (left instanceof Black)
        (§
            return leftBalance(key, val, left.redden(), del)
        )
        else if (left instanceof Red && left.right() instanceof Black)
        (§
            return red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del))
        )
        else
        (§
            throw new UnsupportedOperationException("Invariant violation")
        )
    )

    static Node leftBalance(Object key, Object val, Node ins, Node right)
    (§
        if (ins instanceof Red && ins.left() instanceof Red)
        (§
            return red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right))
        )
        else if (ins instanceof Red && ins.right() instanceof Red)
        (§
            return red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right))
        )
        else
        (§
            return black(key, val, ins, right)
        )
    )

    static Node rightBalance(Object key, Object val, Node left, Node ins)
    (§
        if (ins instanceof Red && ins.right() instanceof Red)
        (§
            return red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken())
        )
        else if (ins instanceof Red && ins.left() instanceof Red)
        (§
            return red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right()))
        )
        else
        (§
            return black(key, val, left, ins)
        )
    )

    Node replace(Node t, Object key, Object val)
    (§
        int c = doCompare(key, t.key)
        return t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right())
    )

    PersistentTreeMap(Comparator comp, Node tree, int count, IPersistentMap meta)
    (§
        this._meta = meta
        this.comp = comp
        this.tree = tree
        this._count = count
    )

    static Red red(Object key, Object val, Node left, Node right)
    (§
        if (left == null && right == null)
        (§
            if (val == null)
            (§
                return new Red(key)
            )
            return new RedVal(key, val)
        )
        if (val == null)
        (§
            return new RedBranch(key, left, right)
        )
        return new RedBranchVal(key, val, left, right)
    )

    static Black black(Object key, Object val, Node left, Node right)
    (§
        if (left == null && right == null)
        (§
            if (val == null)
            (§
                return new Black(key)
            )
            return new BlackVal(key, val)
        )
        if (val == null)
        (§
            return new BlackBranch(key, left, right)
        )
        return new BlackBranchVal(key, val, left, right)
    )

    public IPersistentMap meta()
    (§
        return _meta
    )

    static abstract class Node extends AMapEntry
    (§
        final Object key

        Node(Object key)
        (§
            this.key = key
        )

        public Object key()
        (§
            return key
        )

        public Object val()
        (§
            return null
        )

        public Object getKey()
        (§
            return key()
        )

        public Object getValue()
        (§
            return val()
        )

        Node left()
        (§
            return null
        )

        Node right()
        (§
            return null
        )

        abstract Node addLeft(Node ins)

        abstract Node addRight(Node ins)

        abstract Node removeLeft(Node del)

        abstract Node removeRight(Node del)

        abstract Node blacken()

        abstract Node redden()

        Node balanceLeft(Node parent)
        (§
            return black(parent.key, parent.val(), this, parent.right())
        )

        Node balanceRight(Node parent)
        (§
            return black(parent.key, parent.val(), parent.left(), this)
        )

        abstract Node replace(Object key, Object val, Node left, Node right)

        public Object kvreduce(IFn f, Object init)
        (§
            if (left() != null)
            (§
                init = left().kvreduce(f, init)
                if (RT.isReduced(init))
                (§
                    return init
                )
            )
            init = f.invoke(init, key(), val())
            if (RT.isReduced(init))
            (§
                return init
            )

            if (right() != null)
            (§
                init = right().kvreduce(f, init)
            )
            return init
        )
    )

    static class Black extends Node
    (§
        public Black(Object key)
        (§
            super(key)
        )

        Node addLeft(Node ins)
        (§
            return ins.balanceLeft(this)
        )

        Node addRight(Node ins)
        (§
            return ins.balanceRight(this)
        )

        Node removeLeft(Node del)
        (§
            return balanceLeftDel(key, val(), del, right())
        )

        Node removeRight(Node del)
        (§
            return balanceRightDel(key, val(), left(), del)
        )

        Node blacken()
        (§
            return this
        )

        Node redden()
        (§
            return new Red(key)
        )

        Node replace(Object key, Object val, Node left, Node right)
        (§
            return black(key, val, left, right)
        )
    )

    static class BlackVal extends Black
    (§
        final Object val

        public BlackVal(Object key, Object val)
        (§
            super(key)
            this.val = val
        )

        public Object val()
        (§
            return val
        )

        Node redden()
        (§
            return new RedVal(key, val)
        )
    )

    static class BlackBranch extends Black
    (§
        final Node left

        final Node right

        public BlackBranch(Object key, Node left, Node right)
        (§
            super(key)
            this.left = left
            this.right = right
        )

        public Node left()
        (§
            return left
        )

        public Node right()
        (§
            return right
        )

        Node redden()
        (§
            return new RedBranch(key, left, right)
        )
    )

    static class BlackBranchVal extends BlackBranch
    (§
        final Object val

        public BlackBranchVal(Object key, Object val, Node left, Node right)
        (§
            super(key, left, right)
            this.val = val
        )

        public Object val()
        (§
            return val
        )

        Node redden()
        (§
            return new RedBranchVal(key, val, left, right)
        )
    )

    static class Red extends Node
    (§
        public Red(Object key)
        (§
            super(key)
        )

        Node addLeft(Node ins)
        (§
            return red(key, val(), ins, right())
        )

        Node addRight(Node ins)
        (§
            return red(key, val(), left(), ins)
        )

        Node removeLeft(Node del)
        (§
            return red(key, val(), del, right())
        )

        Node removeRight(Node del)
        (§
            return red(key, val(), left(), del)
        )

        Node blacken()
        (§
            return new Black(key)
        )

        Node redden()
        (§
            throw new UnsupportedOperationException("Invariant violation")
        )

        Node replace(Object key, Object val, Node left, Node right)
        (§
            return red(key, val, left, right)
        )
    )

    static class RedVal extends Red
    (§
        final Object val

        public RedVal(Object key, Object val)
        (§
            super(key)
            this.val = val
        )

        public Object val()
        (§
            return val
        )

        Node blacken()
        (§
            return new BlackVal(key, val)
        )
    )

    static class RedBranch extends Red
    (§
        final Node left

        final Node right

        public RedBranch(Object key, Node left, Node right)
        (§
            super(key)
            this.left = left
            this.right = right
        )

        public Node left()
        (§
            return left
        )

        public Node right()
        (§
            return right
        )

        Node balanceLeft(Node parent)
        (§
            if (left instanceof Red)
            (§
                return red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right()))
            )
            else if (right instanceof Red)
            (§
                return red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right()))
            )
            else
            (§
                return super.balanceLeft(parent)
            )
        )

        Node balanceRight(Node parent)
        (§
            if (right instanceof Red)
            (§
                return red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken())
            )
            else if (left instanceof Red)
            (§
                return red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right))
            )
            else
            (§
                return super.balanceRight(parent)
            )
        )

        Node blacken()
        (§
            return new BlackBranch(key, left, right)
        )
    )

    static class RedBranchVal extends RedBranch
    (§
        final Object val

        public RedBranchVal(Object key, Object val, Node left, Node right)
        (§
            super(key, left, right)
            this.val = val
        )

        public Object val()
        (§
            return val
        )

        Node blacken()
        (§
            return new BlackBranchVal(key, val, left, right)
        )
    )

    static public class Seq extends ASeq
    (§
        final ISeq stack
        final boolean asc
        final int cnt

        public Seq(ISeq stack, boolean asc)
        (§
            this.stack = stack
            this.asc = asc
            this.cnt = -1
        )

        public Seq(ISeq stack, boolean asc, int cnt)
        (§
            this.stack = stack
            this.asc = asc
            this.cnt = cnt
        )

        Seq(IPersistentMap meta, ISeq stack, boolean asc, int cnt)
        (§
            super(meta)
            this.stack = stack
            this.asc = asc
            this.cnt = cnt
        )

        static Seq create(Node t, boolean asc, int cnt)
        (§
            return new Seq(push(t, null, asc), asc, cnt)
        )

        static ISeq push(Node t, ISeq stack, boolean asc)
        (§
            while (t != null)
            (§
                stack = RT.cons(t, stack)
                t = asc ? t.left() :or t.right()
            )
            return stack
        )

        public Object first()
        (§
            return stack.first()
        )

        public ISeq next()
        (§
            Node t = (Node) stack.first()
            ISeq nextstack = push(asc ? t.right() :or t.left(), stack.next(), asc)
            if (nextstack != null)
            (§
                return new Seq(nextstack, asc, cnt - 1)
            )
            return null
        )

        public int count()
        (§
            if (cnt < 0)
            (§
                return super.count()
            )
            return cnt
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            return new Seq(meta, stack, asc, cnt)
        )
    )

    static public class NodeIterator implements Iterator
    (§
        Stack stack = new Stack()
        boolean asc

        NodeIterator(Node t, boolean asc)
        (§
            this.asc = asc
            push(t)
        )

        void push(Node t)
        (§
            while (t != null)
            (§
                stack.push(t)
                t = asc ? t.left() :or t.right()
            )
        )

        public boolean hasNext()
        (§
            return !stack.isEmpty()
        )

        public Object next()
        (§
            try
            (§
                Node t = (Node) stack.pop()
                push(asc ? t.right() :or t.left())
                return t
            )
            catch (EmptyStackException e)
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    static class KeyIterator implements Iterator
    (§
        NodeIterator it

        KeyIterator(NodeIterator it)
        (§
            this.it = it
        )

        public boolean hasNext()
        (§
            return it.hasNext()
        )

        public Object next()
        (§
            return ((Node) it.next()).key
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    static class ValIterator implements Iterator
    (§
        NodeIterator it

        ValIterator(NodeIterator it)
        (§
            this.it = it
        )

        public boolean hasNext()
        (§
            return it.hasNext()
        )

        public Object next()
        (§
            return ((Node) it.next()).val()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(§ java cloiure.lang.PersistentTreeSet

import java.util.Comparator

public class PersistentTreeSet extends APersistentSet implements IObj, Reversible, Sorted
(§
    static public final PersistentTreeSet EMPTY = new PersistentTreeSet(null, PersistentTreeMap.EMPTY)

    final IPersistentMap _meta

    static public PersistentTreeSet create(ISeq items)
    (§
        PersistentTreeSet ret = EMPTY
        for (  items != null items = items.next())
        (§
            ret = (PersistentTreeSet) ret.cons(items.first())
        )
        return ret
    )

    static public PersistentTreeSet create(Comparator comp, ISeq items)
    (§
        PersistentTreeSet ret = new PersistentTreeSet(null, new PersistentTreeMap(null, comp))
        for (  items != null items = items.next())
        (§
            ret = (PersistentTreeSet) ret.cons(items.first())
        )
        return ret
    )

    PersistentTreeSet(IPersistentMap meta, IPersistentMap impl)
    (§
        super(impl)
        this._meta = meta
    )

    public boolean equals(Object obj)
    (§
        try
        (§
            return super.equals(obj)
        )
        catch (ClassCastException e)
        (§
            return false
        )
    )

    public boolean equiv(Object obj)
    (§
        try
        (§
            return super.equiv(obj)
        )
        catch (ClassCastException e)
        (§
            return false
        )
    )

    public IPersistentSet disjoin(Object key)
    (§
        if (contains(key))
        (§
            return new PersistentTreeSet(meta(), impl.without(key))
        )
        return this
    )

    public IPersistentSet cons(Object o)
    (§
        if (contains(o))
        (§
            return this
        )
        return new PersistentTreeSet(meta(), impl.assoc(o, o))
    )

    public IPersistentCollection empty()
    (§
        return new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty())
    )

    public ISeq rseq()
    (§
        return APersistentMap.KeySeq.create(((Reversible) impl).rseq())
    )

    public PersistentTreeSet withMeta(IPersistentMap meta)
    (§
        return new PersistentTreeSet(meta, impl)
    )

    public Comparator comparator()
    (§
        return ((Sorted)impl).comparator()
    )

    public Object entryKey(Object entry)
    (§
        return entry
    )

    public ISeq seq(boolean ascending)
    (§
        PersistentTreeMap m = (PersistentTreeMap) impl
        return RT.keys(m.seq(ascending))
    )

    public ISeq seqFrom(Object key, boolean ascending)
    (§
        PersistentTreeMap m = (PersistentTreeMap) impl
        return RT.keys(m.seqFrom(key, ascending))
    )

    public IPersistentMap meta()
    (§
        return _meta
    )
)
)

(§ java cloiure.lang.PersistentVector

import java.io.Serializable
import java.util.ArrayList
import java.util.Iterator
import java.util.List
import java.util.NoSuchElementException
import java.util.concurrent.atomic.AtomicReference

public class PersistentVector extends APersistentVector implements IObj, IEditableCollection, IReduce, IKVReduce
(§
    public static class Node implements Serializable
    (§
        transient public final AtomicReference<Thread> edit
        public final Object[] array

        public Node(AtomicReference<Thread> edit, Object[] array)
        (§
            this.edit = edit
            this.array = array
        )

        Node(AtomicReference<Thread> edit)
        (§
            this.edit = edit
            this.array = new Object[32]
        )
    )

    final static AtomicReference<Thread> NOEDIT = new AtomicReference<Thread>(null)
    public final static Node EMPTY_NODE = new Node(NOEDIT, new Object[32])

    final int cnt
    public final int shift
    public final Node root
    public final Object[] tail
    final IPersistentMap _meta

    public final static PersistentVector EMPTY = new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§))

    private static final IFn TRANSIENT_VECTOR_CONJ = new AFn()
    (§
        public Object invoke(Object coll, Object val)
        (§
            return ((ITransientVector)coll).conj(val)
        )
        public Object invoke(Object coll)
        (§
            return coll
        )
    )

    static public PersistentVector adopt(Object [] items)
    (§
        return new PersistentVector(items.length, 5, EMPTY_NODE, items)
    )

    static public PersistentVector create(IReduceInit items)
    (§
        TransientVector ret = EMPTY.asTransient()
        items.reduce(TRANSIENT_VECTOR_CONJ, ret)
        return ret.persistent()
    )

    static public PersistentVector create(ISeq items)
    (§
        Object[] arr = new Object[32]
        int i = 0
        for (  items != null && i < 32 items = items.next())
        (§
            arr[i++] = items.first()
        )

        if (items != null) ;; >32, construct with array directly
        (§
            PersistentVector start = new PersistentVector(32, 5, EMPTY_NODE, arr)
            TransientVector ret = start.asTransient()
            for (  items != null items = items.next())
            (§
                ret = ret.conj(items.first())
            )
            return ret.persistent()
        )
        else if (i == 32) ;; exactly 32, skip copy
        (§
            return new PersistentVector(32, 5, EMPTY_NODE, arr)
        )
        else ;; <32, copy to minimum array and construct
        (§
            Object[] arr2 = new Object[i]
            System.arraycopy(arr, 0, arr2, 0, i)
            return new PersistentVector(i, 5, EMPTY_NODE, arr2)
        )
    )

    static public PersistentVector create(List list)
    (§
        int size = list.size()
        if (size <= 32)
        (§
            return new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())
        )

        TransientVector ret = EMPTY.asTransient()
        for (int i = 0 i < size i++)
        (§
            ret = ret.conj(list.get(i))
        )
        return ret.persistent()
    )

    static public PersistentVector create(Iterable items)
    (§
        ;; optimize common case
        if (items instanceof ArrayList)
        (§
            return create((ArrayList)items)
        )

        Iterator iter = items.iterator()
        TransientVector ret = EMPTY.asTransient()
        while (iter.hasNext())
            ret = ret.conj(iter.next())
        return ret.persistent()
    )

    static public PersistentVector create(Object... items)
    (§
        TransientVector ret = EMPTY.asTransient()
        for (Object item :in items)
        (§
            ret = ret.conj(item)
        )
        return ret.persistent()
    )

    PersistentVector(int cnt, int shift, Node root, Object[] tail)
    (§
        this._meta = null
        this.cnt = cnt
        this.shift = shift
        this.root = root
        this.tail = tail
    )

    PersistentVector(IPersistentMap meta, int cnt, int shift, Node root, Object[] tail)
    (§
        this._meta = meta
        this.cnt = cnt
        this.shift = shift
        this.root = root
        this.tail = tail
    )

    public TransientVector asTransient()
    (§
        return new TransientVector(this)
    )

    final int tailoff()
    (§
        if (cnt < 32)
        (§
            return 0
        )
        return ((cnt - 1) >>> 5) << 5
    )

    public Object[] arrayFor(int i)
    (§
        if (i >= 0 && i < cnt)
        (§
            if (i >= tailoff())
            (§
                return tail
            )
            Node node = root
            for (int level = shift level > 0 level -= 5)
            (§
                node = (Node) node.array[(i >>> level) & 0x01f]
            )
            return node.array
        )
        throw new IndexOutOfBoundsException()
    )

    public Object nth(int i)
    (§
        Object[] node = arrayFor(i)
        return node[i & 0x01f]
    )

    public Object nth(int i, Object notFound)
    (§
        if (i >= 0 && i < cnt)
        (§
            return nth(i)
        )
        return notFound
    )

    public PersistentVector assocN(int i, Object val)
    (§
        if (i >= 0 && i < cnt)
        (§
            if (i >= tailoff())
            (§
                Object[] newTail = new Object[tail.length]
                System.arraycopy(tail, 0, newTail, 0, tail.length)
                newTail[i & 0x01f] = val

                return new PersistentVector(meta(), cnt, shift, root, newTail)
            )

            return new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)
        )
        if (i == cnt)
        (§
            return cons(val)
        )
        throw new IndexOutOfBoundsException()
    )

    private static Node doAssoc(int level, Node node, int i, Object val)
    (§
        Node ret = new Node(node.edit, node.array.clone())
        if (level == 0)
        (§
            ret.array[i & 0x01f] = val
        )
        else
        (§
            int subidx = (i >>> level) & 0x01f
            ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val)
        )
        return ret
    )

    public int count()
    (§
        return cnt
    )

    public PersistentVector withMeta(IPersistentMap meta)
    (§
        return new PersistentVector(meta, cnt, shift, root, tail)
    )

    public IPersistentMap meta()
    (§
        return _meta
    )

    public PersistentVector cons(Object val)
    (§
        ;; room in tail?
        if (cnt - tailoff() < 32)
        (§
            Object[] newTail = new Object[tail.length + 1]
            System.arraycopy(tail, 0, newTail, 0, tail.length)
            newTail[tail.length] = val
            return new PersistentVector(meta(), cnt + 1, shift, root, newTail)
        )
        ;; full tail, push into tree
        Node newroot
        Node tailnode = new Node(root.edit, tail)
        int newshift = shift
        ;; overflow root?
        if ((cnt >>> 5) > (1 << shift))
        (§
            newroot = new Node(root.edit)
            newroot.array[0] = root
            newroot.array[1] = newPath(root.edit, shift, tailnode)
            newshift += 5
        )
        else
        (§
            newroot = pushTail(shift, root, tailnode)
        )
        return new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ val ))
    )

    private Node pushTail(int level, Node parent, Node tailnode)
    (§
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        int subidx = ((cnt - 1) >>> level) & 0x01f
        Node ret = new Node(parent.edit, parent.array.clone())
        Node nodeToInsert
        if (level == 5)
        (§
            nodeToInsert = tailnode
        )
        else
        (§
            Node child = (Node) parent.array[subidx]
            nodeToInsert = (child != null) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode)
        )
        ret.array[subidx] = nodeToInsert
        return ret
    )

    private static Node newPath(AtomicReference<Thread> edit, int level, Node node)
    (§
        if (level == 0)
        (§
            return node
        )
        Node ret = new Node(edit)
        ret.array[0] = newPath(edit, level - 5, node)
        return ret
    )

    public IChunkedSeq chunkedSeq()
    (§
        if (count() == 0)
        (§
            return null
        )
        return new ChunkedSeq(this, 0, 0)
    )

    public ISeq seq()
    (§
        return chunkedSeq()
    )

    @Override
    Iterator rangedIterator(final int start, final int end)
    (§
        return new Iterator()
        (§
            int i = start
            int base = i - (i%32)
            Object[] array = (start < count()) ? arrayFor(i) :or null

            public boolean hasNext()
            (§
                return (i < end)
            )

            public Object next()
            (§
                if (i < end)
                (§
                    if (i - base == 32)
                    (§
                        array = arrayFor(i)
                        base += 32
                    )
                    return array[i++ & 0x01f]
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    public Iterator iterator()
    (§
        return rangedIterator(0, count())
    )

    public Object reduce(IFn f)
    (§
        Object init
        if (cnt > 0)
        (§
            init = arrayFor(0)[0]
        )
        else
        (§
            return f.invoke()
        )
        int step = 0
        for (int i = 0 i < cnt i += step)
        (§
            Object[] array = arrayFor(i)
            for (int j = (i == 0) ? 1 :or 0 j < array.length ++j)
            (§
                init = f.invoke(init, array[j])
                if (RT.isReduced(init))
                (§
                    return ((IDeref)init).deref()
                )
            )
            step = array.length
        )
        return init
    )

    public Object reduce(IFn f, Object init)
    (§
        int step = 0
        for (int i = 0 i < cnt i += step)
        (§
            Object[] array = arrayFor(i)
            for (int j = 0 j < array.length ++j)
            (§
                init = f.invoke(init, array[j])
                if (RT.isReduced(init))
                (§
                    return ((IDeref)init).deref()
                )
            )
            step = array.length
        )
        return init
    )

    public Object kvreduce(IFn f, Object init)
    (§
        int step = 0
        for (int i = 0 i < cnt i += step)
        (§
            Object[] array = arrayFor(i)
            for (int j = 0 j < array.length ++j)
            (§
                init = f.invoke(init, j + i, array[j])
                if (RT.isReduced(init))
                (§
                    return ((IDeref)init).deref()
                )
            )
            step = array.length
        )
        return init
    )

    static public final class ChunkedSeq extends ASeq implements IChunkedSeq, Counted
    (§
        public final PersistentVector vec
        final Object[] node
        final int i
        public final int offset

        public ChunkedSeq(PersistentVector vec, int i, int offset)
        (§
            this.vec = vec
            this.i = i
            this.offset = offset
            this.node = vec.arrayFor(i)
        )

        ChunkedSeq(IPersistentMap meta, PersistentVector vec, Object[] node, int i, int offset)
        (§
            super(meta)
            this.vec = vec
            this.node = node
            this.i = i
            this.offset = offset
        )

        ChunkedSeq(PersistentVector vec, Object[] node, int i, int offset)
        (§
            this.vec = vec
            this.node = node
            this.i = i
            this.offset = offset
        )

        public IChunk chunkedFirst()
        (§
            return new ArrayChunk(node, offset)
        )

        public ISeq chunkedNext()
        (§
            if (i + node.length < vec.cnt)
            (§
                return new ChunkedSeq(vec, i + node.length, 0)
            )
            return null
        )

        public ISeq chunkedMore()
        (§
            ISeq s = chunkedNext()
            if (s == null)
            (§
                return PersistentList.EMPTY
            )
            return s
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            if (meta == this._meta)
            (§
                return this
            )
            return new ChunkedSeq(meta, vec, node, i, offset)
        )

        public Object first()
        (§
            return node[offset]
        )

        public ISeq next()
        (§
            if (offset + 1 < node.length)
            (§
                return new ChunkedSeq(vec, node, i, offset + 1)
            )
            return chunkedNext()
        )

        public int count()
        (§
            return vec.cnt - (i + offset)
        )
    )

    public IPersistentCollection empty()
    (§
        return EMPTY.withMeta(meta())
    )

    public PersistentVector pop()
    (§
        if (cnt == 0)
        (§
            throw new IllegalStateException("Can't pop empty vector")
        )
        if (cnt == 1)
        (§
            return EMPTY.withMeta(meta())
        )
        if (cnt - tailoff() > 1)
        (§
            Object[] newTail = new Object[tail.length - 1]
            System.arraycopy(tail, 0, newTail, 0, newTail.length)
            return new PersistentVector(meta(), cnt - 1, shift, root, newTail)
        )
        Object[] newtail = arrayFor(cnt - 2)

        Node newroot = popTail(shift, root)
        int newshift = shift
        if (newroot == null)
        (§
            newroot = EMPTY_NODE
        )
        if (shift > 5 && newroot.array[1] == null)
        (§
            newroot = (Node) newroot.array[0]
            newshift -= 5
        )
        return new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail)
    )

    private Node popTail(int level, Node node)
    (§
        int subidx = ((cnt - 2) >>> level) & 0x01f
        if (level > 5)
        (§
            Node newchild = popTail(level - 5, (Node) node.array[subidx])
            if (newchild == null && subidx == 0)
            (§
                return null
            )
            else
            (§
                Node ret = new Node(root.edit, node.array.clone())
                ret.array[subidx] = newchild
                return ret
            )
        )
        else if (subidx == 0)
        (§
            return null
        )
        else
        (§
            Node ret = new Node(root.edit, node.array.clone())
            ret.array[subidx] = null
            return ret
        )
    )

    static final class TransientVector extends AFn implements ITransientVector, ITransientAssociative2, Counted
    (§
        volatile int cnt
        volatile int shift
        volatile Node root
        volatile Object[] tail

        TransientVector(int cnt, int shift, Node root, Object[] tail)
        (§
            this.cnt = cnt
            this.shift = shift
            this.root = root
            this.tail = tail
        )

        TransientVector(PersistentVector v)
        (§
            this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail))
        )

        public int count()
        (§
            ensureEditable()
            return cnt
        )

        Node ensureEditable(Node node)
        (§
            if (node.edit == root.edit)
            (§
                return node
            )
            return new Node(root.edit, node.array.clone())
        )

        void ensureEditable()
        (§
            if (root.edit.get() == null)
            (§
                throw new IllegalAccessError("Transient used after persistent! call")
            )
        )

        static Node editableRoot(Node node)
        (§
            return new Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone())
        )

        public PersistentVector persistent()
        (§
            ensureEditable()
            root.edit.set(null)
            Object[] trimmedTail = new Object[cnt - tailoff()]
            System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length)
            return new PersistentVector(cnt, shift, root, trimmedTail)
        )

        static Object[] editableTail(Object[] tl)
        (§
            Object[] ret = new Object[32]
            System.arraycopy(tl, 0, ret, 0, tl.length)
            return ret
        )

        public TransientVector conj(Object val)
        (§
            ensureEditable()
            int i = cnt
            ;; room in tail?
            if (i - tailoff() < 32)
            (§
                tail[i & 0x01f] = val
                ++cnt
                return this
            )
            ;; full tail, push into tree
            Node newroot
            Node tailnode = new Node(root.edit, tail)
            tail = new Object[32]
            tail[0] = val
            int newshift = shift
            ;; overflow root?
            if ((cnt >>> 5) > (1 << shift))
            (§
                newroot = new Node(root.edit)
                newroot.array[0] = root
                newroot.array[1] = newPath(root.edit, shift, tailnode)
                newshift += 5
            )
            else
            (§
                newroot = pushTail(shift, root, tailnode)
            )
            root = newroot
            shift = newshift
            ++cnt
            return this
        )

        private Node pushTail(int level, Node parent, Node tailnode)
        (§
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            parent = ensureEditable(parent)
            int subidx = ((cnt - 1) >>> level) & 0x01f
            Node ret = parent
            Node nodeToInsert
            if (level == 5)
            (§
                nodeToInsert = tailnode
            )
            else
            (§
                Node child = (Node) parent.array[subidx]
                nodeToInsert = (child != null) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode)
            )
            ret.array[subidx] = nodeToInsert
            return ret
        )

        final private int tailoff()
        (§
            if (cnt < 32)
            (§
                return 0
            )
            return ((cnt - 1) >>> 5) << 5
        )

        private Object[] arrayFor(int i)
        (§
            if (i >= 0 && i < cnt)
            (§
                if (i >= tailoff())
                (§
                    return tail
                )
                Node node = root
                for (int level = shift level > 0 level -= 5)
                (§
                    node = (Node) node.array[(i >>> level) & 0x01f]
                )
                return node.array
            )
            throw new IndexOutOfBoundsException()
        )

        private Object[] editableArrayFor(int i)
        (§
            if (i >= 0 && i < cnt)
            (§
                if (i >= tailoff())
                (§
                    return tail
                )
                Node node = root
                for (int level = shift level > 0 level -= 5)
                (§
                    node = ensureEditable((Node) node.array[(i >>> level) & 0x01f])
                )
                return node.array
            )
            throw new IndexOutOfBoundsException()
        )

        public Object valAt(Object key)
        (§
            ;; note - relies on ensureEditable in 2-arg valAt
            return valAt(key, null)
        )

        public Object valAt(Object key, Object notFound)
        (§
            ensureEditable()
            if (Util.isInteger(key))
            (§
                int i = ((Number) key).intValue()
                if (i >= 0 && i < cnt)
                (§
                    return nth(i)
                )
            )
            return notFound
        )

        private static final Object NOT_FOUND = new Object()

        public final boolean containsKey(Object key)
        (§
            return (valAt(key, NOT_FOUND) != NOT_FOUND)
        )

        public final IMapEntry entryAt(Object key)
        (§
            Object v = valAt(key, NOT_FOUND)
            if (v != NOT_FOUND)
            (§
                return MapEntry.create(key, v)
            )
            return null
        )

        public Object invoke(Object arg1)
        (§
            ;; note - relies on ensureEditable in nth
            if (Util.isInteger(arg1))
            (§
                return nth(((Number) arg1).intValue())
            )
            throw new IllegalArgumentException("Key must be integer")
        )

        public Object nth(int i)
        (§
            ensureEditable()
            Object[] node = arrayFor(i)
            return node[i & 0x01f]
        )

        public Object nth(int i, Object notFound)
        (§
            if (i >= 0 && i < count())
            (§
                return nth(i)
            )
            return notFound
        )

        public TransientVector assocN(int i, Object val)
        (§
            ensureEditable()
            if (i >= 0 && i < cnt)
            (§
                if (i >= tailoff())
                (§
                    tail[i & 0x01f] = val
                    return this
                )

                root = doAssoc(shift, root, i, val)
                return this
            )
            if (i == cnt)
            (§
                return conj(val)
            )
            throw new IndexOutOfBoundsException()
        )

        public TransientVector assoc(Object key, Object val)
        (§
            ;; note - relies on ensureEditable in assocN
            if (Util.isInteger(key))
            (§
                int i = ((Number) key).intValue()
                return assocN(i, val)
            )
            throw new IllegalArgumentException("Key must be integer")
        )

        private Node doAssoc(int level, Node node, int i, Object val)
        (§
            node = ensureEditable(node)
            Node ret = node
            if (level == 0)
            (§
                ret.array[i & 0x01f] = val
            )
            else
            (§
                int subidx = (i >>> level) & 0x01f
                ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val)
            )
            return ret
        )

        public TransientVector pop()
        (§
            ensureEditable()
            if (cnt == 0)
            (§
                throw new IllegalStateException("Can't pop empty vector")
            )
            if (cnt == 1)
            (§
                cnt = 0
                return this
            )
            int i = cnt - 1
            ;; pop in tail?
            if ((i & 0x01f) > 0)
            (§
                --cnt
                return this
            )

            Object[] newtail = editableArrayFor(cnt - 2)

            Node newroot = popTail(shift, root)
            int newshift = shift
            if (newroot == null)
            (§
                newroot = new Node(root.edit)
            )
            if (shift > 5 && newroot.array[1] == null)
            (§
                newroot = ensureEditable((Node) newroot.array[0])
                newshift -= 5
            )
            root = newroot
            shift = newshift
            --cnt
            tail = newtail
            return this
        )

        private Node popTail(int level, Node node)
        (§
            node = ensureEditable(node)
            int subidx = ((cnt - 2) >>> level) & 0x01f
            if (level > 5)
            (§
                Node newchild = popTail(level - 5, (Node) node.array[subidx])
                if (newchild == null && subidx == 0)
                (§
                    return null
                )
                else
                (§
                    Node ret = node
                    ret.array[subidx] = newchild
                    return ret
                )
            )
            else if (subidx == 0)
            (§
                return null
            )
            else
            (§
                Node ret = node
                ret.array[subidx] = null
                return ret
            )
        )
    )
)
)

(§ java cloiure.lang.ProxyHandler

import java.lang.reflect.InvocationHandler
import java.lang.reflect.Method

public class ProxyHandler implements InvocationHandler
(§
    ;; method-name-string->fn
    final IPersistentMap fns

    public ProxyHandler(IPersistentMap fns)
    (§
        this.fns = fns
    )

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
    (§
        Class rt = method.getReturnType()
        IFn fn = (IFn) fns.valAt(method.getName())
        if (fn == null)
        (§
            if (rt == Void.TYPE)
            (§
                return null
            )
            else if (method.getName().equals("equals"))
            (§
                return (proxy == args[0])
            )
            else if (method.getName().equals("hashCode"))
            (§
                return System.identityHashCode(proxy)
            )
            else if (method.getName().equals("toString"))
            (§
                return "Proxy: " + System.identityHashCode(proxy)
            )
            throw new UnsupportedOperationException()
        )
        Object ret = fn.applyTo(ArraySeq.create(args))
        if (rt == Void.TYPE)
        (§
            return null
        )
        else if (rt.isPrimitive())
        (§
            if (rt == Character.TYPE)
            (§
                return ret
            )
            else if (rt == Integer.TYPE)
            (§
                return ((Number) ret).intValue()
            )
            else if (rt == Long.TYPE)
            (§
                return ((Number) ret).longValue()
            )
            else if (rt == Float.TYPE)
            (§
                return ((Number) ret).floatValue()
            )
            else if (rt == Double.TYPE)
            (§
                return ((Number) ret).doubleValue()
            )
            else if (rt == Boolean.TYPE && !(ret instanceof Boolean))
            (§
                return (ret == null) ? Boolean.FALSE :or Boolean.TRUE
            )
            else if (rt == Byte.TYPE)
            (§
                return (byte) ((Number) ret).intValue()
            )
            else if (rt == Short.TYPE)
            (§
                return (short) ((Number) ret).intValue()
            )
        )
        return ret
    )
)
)

(§ java cloiure.lang.Range

import java.io.Serializable
import java.util.*

;;
 ; Implements generic numeric (potentially infinite) range.
 ;
public class Range extends ASeq implements IChunkedSeq, IReduce
(§
    private static final int CHUNK_SIZE = 32

    ;; Invariants guarantee this is never an "empty" seq
    final Object end
    final Object start
    final Object step
    final BoundsCheck boundsCheck

    private volatile IChunk _chunk ;; lazy
    private volatile ISeq _chunkNext ;; lazy
    private volatile ISeq _next ;; cached

    private static interface BoundsCheck extends Serializable
    (§
        boolean exceededBounds(Object val)
    )

    private static BoundsCheck positiveStep(final Object end)
    (§
        return new BoundsCheck()
        (§
            public boolean exceededBounds(Object val)
            (§
                return Numbers.gte(val, end)
            )
        )
    )

    private static BoundsCheck negativeStep(final Object end)
    (§
        return new BoundsCheck()
        (§
            public boolean exceededBounds(Object val)
            (§
                return Numbers.lte(val, end)
            )
        )
    )

    private Range(Object start, Object end, Object step, BoundsCheck boundsCheck)
    (§
        this.end = end
        this.start = start
        this.step = step
        this.boundsCheck = boundsCheck
    )

    private Range(Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
    (§
        this.end = end
        this.start = start
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    private Range(IPersistentMap meta, Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
    (§
        super(meta)
        this.end = end
        this.start = start
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    public static ISeq create(Object end)
    (§
        if (Numbers.isPos(end))
        (§
            return new Range(0(§ L), end, 1(§ L), positiveStep(end))
        )
        return PersistentList.EMPTY
    )

    public static ISeq create(Object start, Object end)
    (§
        return create(start, end, 1(§ L))
    )

    public static ISeq create(final Object start, Object end, Object step)
    (§
        if ((Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end))
        (§
            return PersistentList.EMPTY
        )
        if (Numbers.isZero(step))
        (§
            return Repeat.create(start)
        )
        return new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end))
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta == _meta)
        (§
            return this
        )
        return new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext)
    )

    public Object first()
    (§
        return start
    )

    public void forceChunk()
    (§
        if (_chunk != null)
        (§
            return
        )

        Object[] arr = new Object[CHUNK_SIZE]
        int n = 0
        Object val = start
        while (n < CHUNK_SIZE)
        (§
            arr[n++] = val
            val = Numbers.addP(val, step)
            if (boundsCheck.exceededBounds(val))
            (§
                ;; partial last chunk
                _chunk = new ArrayChunk(arr, 0, n)
                return
            )
        )

        ;; full last chunk
        if (boundsCheck.exceededBounds(val))
        (§
            _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE)
            return
        )

        ;; full intermediate chunk
        _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE)
        _chunkNext = new Range(val, end, step, boundsCheck)
    )

    public ISeq next()
    (§
        if (_next != null)
        (§
            return _next
        )

        forceChunk()
        if (_chunk.count() > 1)
        (§
            IChunk smallerChunk = _chunk.dropFirst()
            _next = new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext)
            return _next
        )
        return chunkedNext()
    )

    public IChunk chunkedFirst()
    (§
        forceChunk()
        return _chunk
    )

    public ISeq chunkedNext()
    (§
        return chunkedMore().seq()
    )

    public ISeq chunkedMore()
    (§
        forceChunk()
        if (_chunkNext == null)
        (§
            return PersistentList.EMPTY
        )
        return _chunkNext
    )

    public Object reduce(IFn f)
    (§
        Object acc = start
        Number i = Numbers.addP(start, step)
        while (!boundsCheck.exceededBounds(i))
        (§
            acc = f.invoke(acc, i)
            if (RT.isReduced(acc))
            (§
                return ((Reduced)acc).deref()
            )
            i = Numbers.addP(i, step)
        )
        return acc
    )

    public Object reduce(IFn f, Object val)
    (§
        Object acc = val
        Object i = start
        while (!boundsCheck.exceededBounds(i))
        (§
            acc = f.invoke(acc, i)
            if (RT.isReduced(acc))
            (§
                return ((Reduced)acc).deref()
            )
            i = Numbers.addP(i, step)
        )
        return acc
    )

    public Iterator iterator()
    (§
        return new RangeIterator()
    )

    private class RangeIterator implements Iterator
    (§
        private Object next

        public RangeIterator()
        (§
            this.next = start
        )

        public boolean hasNext()
        (§
            return (!boundsCheck.exceededBounds(next))
        )

        public Object next()
        (§
            if (hasNext())
            (§
                Object ret = next
                next = Numbers.addP(next, step)
                return ret
            )
            else
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(§ java cloiure.lang.Ratio

import java.math.BigInteger
import java.math.BigDecimal
import java.math.MathContext

public class Ratio extends Number implements Comparable
(§
    final public BigInteger numerator
    final public BigInteger denominator

    public Ratio(BigInteger numerator, BigInteger denominator)
    (§
        this.numerator = numerator
        this.denominator = denominator
    )

    public boolean equals(Object arg0)
    (§
        return (arg0 != null && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator))
    )

    public int hashCode()
    (§
        return numerator.hashCode() :xor denominator.hashCode()
    )

    public String toString()
    (§
        return numerator.toString() + "/" + denominator.toString()
    )

    public int intValue()
    (§
        return (int) doubleValue()
    )

    public long longValue()
    (§
        return bigIntegerValue().longValue()
    )

    public float floatValue()
    (§
        return (float)doubleValue()
    )

    public double doubleValue()
    (§
        return decimalValue(MathContext.DECIMAL64).doubleValue()
    )

    public BigDecimal decimalValue()
    (§
        return decimalValue(MathContext.UNLIMITED)
    )

    public BigDecimal decimalValue(MathContext mc)
    (§
        BigDecimal numerator = new BigDecimal(this.numerator)
        BigDecimal denominator = new BigDecimal(this.denominator)

        return numerator.divide(denominator, mc)
    )

    public BigInteger bigIntegerValue()
    (§
        return numerator.divide(denominator)
    )

    public int compareTo(Object o)
    (§
        Number other = (Number)o
        return Numbers.compare(this, other)
    )
)
)

(§ java cloiure.lang.ReaderConditional

public class ReaderConditional implements ILookup
(§
    public static final Keyword FORM_KW = Keyword.intern("form")
    public static final Keyword SPLICING_KW = Keyword.intern("splicing?")

    public final Object form
    public final Boolean splicing

    public static ReaderConditional create(Object form, boolean splicing)
    (§
        return new ReaderConditional(form, splicing)
    )

    private ReaderConditional(Object form, boolean splicing)
    (§
        this.form = form
        this.splicing = splicing
    )

    public Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (FORM_KW.equals(key))
        (§
            return this.form
        )
        else if (SPLICING_KW.equals(key))
        (§
            return this.splicing
        )
        else
        (§
            return notFound
        )
    )

    @Override
    public boolean equals(Object o)
    (§
        if (this == o)
        (§
            return true
        )
        if (o == null || getClass() != o.getClass())
        (§
            return false
        )

        ReaderConditional that = (ReaderConditional) o

        if ((form != null) ? !form.equals(that.form) :or that.form != null)
        (§
            return false
        )
        if ((splicing != null) ? !splicing.equals(that.splicing) :or that.splicing != null)
        (§
            return false
        )
        return true
    )

    @Override
    public int hashCode()
    (§
        int result = Util.hash(form)
        result = 31 * result + Util.hash(splicing)
        return result
    )
)
)

(§ java cloiure.lang.RecordIterator

import java.util.Iterator

public final class RecordIterator implements Iterator
(§
    int i = 0
    final int basecnt
    final ILookup rec
    final IPersistentVector basefields
    final Iterator extmap

    public RecordIterator (ILookup rec, IPersistentVector basefields, Iterator extmap)
    (§
        this.rec = rec
        this.basefields = basefields
        this.basecnt = basefields.count()
        this.extmap = extmap
    )

    public boolean hasNext()
    (§
        if (i < basecnt)
        (§
            return true
        )
        else
        (§
            return extmap.hasNext()
        )
    )

    public Object next()
    (§
        if (i < basecnt)
        (§
            Object k = basefields.nth(i)
            i++
            return MapEntry.create(k, rec.valAt(k))
        )
        else
        (§
            return extmap.next()
        )
    )

    public void remove()
    (§
        throw new UnsupportedOperationException()
    )
)
)

(§ java cloiure.lang.Reduced

public final class Reduced implements IDeref
(§
    Object val

    public Reduced(Object val)
    (§
        this.val = val
    )

    public Object deref()
    (§
        return val
    )
)
)

(§ java cloiure.lang.Ref

import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.locks.ReentrantReadWriteLock

public class Ref extends ARef implements IFn, Comparable<Ref>, IRef
(§
    public int compareTo(Ref ref)
    (§
        if (this.id == ref.id)
        (§
            return 0
        )
        else if (this.id < ref.id)
        (§
            return -1
        )
        else
        (§
            return 1
        )
    )

    public int getMinHistory()
    (§
        return minHistory
    )

    public Ref setMinHistory(int minHistory)
    (§
        this.minHistory = minHistory
        return this
    )

    public int getMaxHistory()
    (§
        return maxHistory
    )

    public Ref setMaxHistory(int maxHistory)
    (§
        this.maxHistory = maxHistory
        return this
    )

    public static class TVal
    (§
        Object val
        long point
        TVal prior
        TVal next

        TVal(Object val, long point, TVal prior)
        (§
            this.val = val
            this.point = point
            this.prior = prior
            this.next = prior.next
            this.prior.next = this
            this.next.prior = this
        )

        TVal(Object val, long point)
        (§
            this.val = val
            this.point = point
            this.next = this
            this.prior = this
        )
    )

    TVal tvals
    final AtomicInteger faults
    final ReentrantReadWriteLock lock
    LockingTransaction.Info tinfo
    final long id

    volatile int minHistory = 0
    volatile int maxHistory = 10

    static final AtomicLong ids = new AtomicLong()

    public Ref(Object initVal)
    (§
        this(initVal, null)
    )

    public Ref(Object initVal, IPersistentMap meta)
    (§
        super(meta)
        this.id = ids.getAndIncrement()
        this.faults = new AtomicInteger()
        this.lock = new ReentrantReadWriteLock()
        tvals = new TVal(initVal, 0)
    )

    ;; the latest val

    ;; ok out of transaction
    Object currentVal()
    (§
        try
        (§
            lock.readLock().lock()
            if (tvals != null)
            (§
                return tvals.val
            )
            throw new IllegalStateException(this.toString() + " is unbound.")
        )
        finally
        (§
            lock.readLock().unlock()
        )
    )

    public Object deref()
    (§
        LockingTransaction t = LockingTransaction.getRunning()
        if (t == null)
        (§
            return currentVal()
        )
        return t.doGet(this)
    )

    public Object set(Object val)
    (§
        return LockingTransaction.getEx().doSet(this, val)
    )

    public Object commute(IFn fn, ISeq args)
    (§
        return LockingTransaction.getEx().doCommute(this, fn, args)
    )

    public Object alter(IFn fn, ISeq args)
    (§
        LockingTransaction t = LockingTransaction.getEx()
        return t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args)))
    )

    public void touch()
    (§
        LockingTransaction.getEx().doEnsure(this)
    )

    boolean isBound()
    (§
        try
        (§
            lock.readLock().lock()
            return (tvals != null)
        )
        finally
        (§
            lock.readLock().unlock()
        )
    )

    public void trimHistory()
    (§
        try
        (§
            lock.writeLock().lock()
            if (tvals != null)
            (§
                tvals.next = tvals
                tvals.prior = tvals
            )
        )
        finally
        (§
            lock.writeLock().unlock()
        )
    )

    public int getHistoryCount()
    (§
        try
        (§
            lock.writeLock().lock()
            return histCount()
        )
        finally
        (§
            lock.writeLock().unlock()
        )
    )

    int histCount()
    (§
        if (tvals == null)
        (§
            return 0
        )
        else
        (§
            int count = 0
            for (TVal tv = tvals.next tv != tvals tv = tv.next)
            (§
                count++
            )
            return count
        )
    )

    final public IFn fn()
    (§
        return (IFn) deref()
    )

    public Object call()
    (§
        return invoke()
    )

    public void run()
    (§
        invoke()
    )

    public Object invoke()
    (§
        return fn().invoke()
    )

    public Object invoke(Object arg1)
    (§
        return fn().invoke(arg1)
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        return fn().invoke(arg1, arg2)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        return fn().invoke(arg1, arg2, arg3)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20)
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args)
    )

    public Object applyTo(ISeq arglist)
    (§
        return AFn.applyToHelper(this, arglist)
    )
)
)

(§ java cloiure.lang.Reflector

import java.lang.reflect.Constructor
import java.lang.reflect.Field
import java.lang.reflect.Method
import java.lang.reflect.Modifier
import java.util.ArrayList
import java.util.Iterator
import java.util.List

public class Reflector
(§
    public static Object invokeInstanceMethod(Object target, String methodName, Object[] args)
    (§
        Class c = target.getClass()
        List methods = getMethods(c, args.length, methodName, false)
        return invokeMatchingMethod(methodName, methods, target, args)
    )

    private static Throwable getCauseOrElse(Exception e)
    (§
        if (e.getCause() != null)
        (§
            return e.getCause()
        )
        return e
    )

    private static RuntimeException throwCauseOrElseException(Exception e)
    (§
        if (e.getCause() != null)
        (§
            throw Util.sneakyThrow(e.getCause())
        )
        throw Util.sneakyThrow(e)
    )

    private static String noMethodReport(String methodName, Object target)
    (§
        return "No matching method found: " + methodName + ((target == null) ? "" :or " for " + target.getClass())
    )

    static Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
    (§
        Method m = null
        Object[] boxedArgs = null
        if (methods.isEmpty())
        (§
            throw new IllegalArgumentException(noMethodReport(methodName, target))
        )
        else if (methods.size() == 1)
        (§
            m = (Method) methods.get(0)
            boxedArgs = boxArgs(m.getParameterTypes(), args)
        )
        else ;; overloaded w/same arity
        (§
            Method foundm = null
            for (Iterator i = methods.iterator() i.hasNext() )
            (§
                m = (Method) i.next()

                Class[] params = m.getParameterTypes()
                if (isCongruent(params, args))
                (§
                    if (foundm == null || Compiler.subsumes(params, foundm.getParameterTypes()))
                    (§
                        foundm = m
                        boxedArgs = boxArgs(params, args)
                    )
                )
            )
            m = foundm
        )
        if (m == null)
        (§
            throw new IllegalArgumentException(noMethodReport(methodName, target))
        )

        if (!Modifier.isPublic(m.getDeclaringClass().getModifiers()))
        (§
            ;; public method of non-public class, try to find it in hierarchy
            Method oldm = m
            m = getAsMethodOfPublicBase(target.getClass(), m)
            if (m == null)
            (§
                throw new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString())
            )
        )
        try
        (§
            return prepRet(m.getReturnType(), m.invoke(target, boxedArgs))
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(getCauseOrElse(e))
        )
    )

    public static Method getAsMethodOfPublicBase(Class c, Method m)
    (§
        for (Class iface :in c.getInterfaces())
        (§
            for (Method im :in iface.getMethods())
            (§
                if (isMatch(im, m))
                (§
                    return im
                )
            )
        )
        Class sc = c.getSuperclass()
        if (sc == null)
        (§
            return null
        )
        for (Method scm :in sc.getMethods())
        (§
            if (isMatch(scm, m))
            (§
                return scm
            )
        )
        return getAsMethodOfPublicBase(sc, m)
    )

    public static boolean isMatch(Method lhs, Method rhs)
    (§
        if (!lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers()))
        (§
            return false
        )

        Class[] types1 = lhs.getParameterTypes()
        Class[] types2 = rhs.getParameterTypes()
        if (types1.length != types2.length)
        (§
            return false
        )

        boolean match = true
        for (int i = 0 i < types1.length ++i)
        (§
            if (!types1[i].isAssignableFrom(types2[i]))
            (§
                match = false
                break
            )
        )
        return match
    )

    public static Object invokeConstructor(Class c, Object[] args)
    (§
        try
        (§
            Constructor[] allctors = c.getConstructors()
            ArrayList ctors = new ArrayList()
            for (int i = 0 i < allctors.length i++)
            (§
                Constructor ctor = allctors[i]
                if (ctor.getParameterTypes().length == args.length)
                (§
                    ctors.add(ctor)
                )
            )
            if (ctors.isEmpty())
            (§
                throw new IllegalArgumentException("No matching ctor found for " + c)
            )
            else if (ctors.size() == 1)
            (§
                Constructor ctor = (Constructor) ctors.get(0)
                return ctor.newInstance(boxArgs(ctor.getParameterTypes(), args))
            )
            else ;; overloaded w/same arity
            (§
                for (Iterator iterator = ctors.iterator() iterator.hasNext() )
                (§
                    Constructor ctor = (Constructor) iterator.next()
                    Class[] params = ctor.getParameterTypes()
                    if (isCongruent(params, args))
                    (§
                        Object[] boxedArgs = boxArgs(params, args)
                        return ctor.newInstance(boxedArgs)
                    )
                )
                throw new IllegalArgumentException("No matching ctor found for " + c)
            )
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(getCauseOrElse(e))
        )
    )

    public static Object invokeStaticMethodVariadic(String className, String methodName, Object... args)
    (§
        return invokeStaticMethod(className, methodName, args)
    )

    public static Object invokeStaticMethod(String className, String methodName, Object[] args)
    (§
        Class c = RT.classForName(className)
        return invokeStaticMethod(c, methodName, args)
    )

    public static Object invokeStaticMethod(Class c, String methodName, Object[] args)
    (§
        if (methodName.equals("new"))
        (§
            return invokeConstructor(c, args)
        )
        List methods = getMethods(c, args.length, methodName, true)
        return invokeMatchingMethod(methodName, methods, null, args)
    )

    public static Object getStaticField(String className, String fieldName)
    (§
        Class c = RT.classForName(className)
        return getStaticField(c, fieldName)
    )

    public static Object getStaticField(Class c, String fieldName)
    (§
        Field f = getField(c, fieldName, true)
        if (f != null)
        (§
            try
            (§
                return prepRet(f.getType(), f.get(null))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)
    )

    public static Object setStaticField(String className, String fieldName, Object val)
    (§
        Class c = RT.classForName(className)
        return setStaticField(c, fieldName, val)
    )

    public static Object setStaticField(Class c, String fieldName, Object val)
    (§
        Field f = getField(c, fieldName, true)
        if (f != null)
        (§
            try
            (§
                f.set(null, boxArg(f.getType(), val))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
            return val
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)
    )

    public static Object getInstanceField(Object target, String fieldName)
    (§
        Class c = target.getClass()
        Field f = getField(c, fieldName, false)
        if (f != null)
        (§
            try
            (§
                return prepRet(f.getType(), f.get(target))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())
    )

    public static Object setInstanceField(Object target, String fieldName, Object val)
    (§
        Class c = target.getClass()
        Field f = getField(c, fieldName, false)
        if (f != null)
        (§
            try
            (§
                f.set(target, boxArg(f.getType(), val))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
            return val
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    public static Object invokeNoArgInstanceMember(Object target, String name)
    (§
        return invokeNoArgInstanceMember(target, name, false)
    )

    public static Object invokeNoArgInstanceMember(Object target, String name, boolean requireField)
    (§
        Class c = target.getClass()

        if (requireField)
        (§
            Field f = getField(c, name, false)
            if (f != null)
            (§
                return getInstanceField(target, name)
            )
            else
            (§
                throw new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass())
            )
        )
        else
        (§
            List meths = getMethods(c, 0, name, false)
            if (meths.size() > 0)
            (§
                return invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY)
            )
            else
            (§
                return getInstanceField(target, name)
            )
        )
    )

    public static Object invokeInstanceMember(Object target, String name)
    (§
        ;; check for field first
        Class c = target.getClass()
        Field f = getField(c, name, false)
        if (f != null) ;; field get
        (§
            try
            (§
                return prepRet(f.getType(), f.get(target))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
        return invokeInstanceMethod(target, name, RT.EMPTY_ARRAY)
    )

    public static Object invokeInstanceMember(String name, Object target, Object arg1)
    (§
        ;; check for field first
        Class c = target.getClass()
        Field f = getField(c, name, false)
        if (f != null) ;; field set
        (§
            try
            (§
                f.set(target, boxArg(f.getType(), arg1))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
            return arg1
        )
        return invokeInstanceMethod(target, name, new Object[] (§ arg1 ))
    )

    public static Object invokeInstanceMember(String name, Object target, Object... args)
    (§
        return invokeInstanceMethod(target, name, args)
    )

    static public Field getField(Class c, String name, boolean getStatics)
    (§
        Field[] allfields = c.getFields()
        for (int i = 0 i < allfields.length i++)
        (§
            if (name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
            (§
                return allfields[i]
            )
        )
        return null
    )

    static public List getMethods(Class c, int arity, String name, boolean getStatics)
    (§
        Method[] allmethods = c.getMethods()
        ArrayList methods = new ArrayList()
        ArrayList bridgeMethods = new ArrayList()
        for (int i = 0 i < allmethods.length i++)
        (§
            Method method = allmethods[i]
            if (name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity)
            (§
                try
                (§
                    if (method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method))
                    (§
                        bridgeMethods.add(method)
                    )
                    else
                    (§
                        methods.add(method)
                    )
                )
                catch (NoSuchMethodException e)
                (§
                )
            )
        )

        if (methods.isEmpty())
        (§
            methods.addAll(bridgeMethods)
        )
        if (!getStatics && c.isInterface())
        (§
            allmethods = Object.class.getMethods()
            for (int i = 0 i < allmethods.length i++)
            (§
                if (name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity)
                (§
                    methods.add(allmethods[i])
                )
            )
        )
        return methods
    )

    static Object boxArg(Class paramType, Object arg)
    (§
        if (!paramType.isPrimitive())
        (§
            return paramType.cast(arg)
        )
        else if (paramType == boolean.class)
        (§
            return Boolean.class.cast(arg)
        )
        else if (paramType == char.class)
        (§
            return Character.class.cast(arg)
        )
        else if (arg instanceof Number)
        (§
            Number n = (Number) arg
            if (paramType == int.class)
            (§
                return n.intValue()
            )
            else if (paramType == float.class)
            (§
                return n.floatValue()
            )
            else if (paramType == double.class)
            (§
                return n.doubleValue()
            )
            else if (paramType == long.class)
            (§
                return n.longValue()
            )
            else if (paramType == short.class)
            (§
                return n.shortValue()
            )
            else if (paramType == byte.class)
            (§
                return n.byteValue()
            )
        )
        throw new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName())
    )

    static Object[] boxArgs(Class[] params, Object[] args)
    (§
        if (params.length == 0)
        (§
            return null
        )
        Object[] ret = new Object[params.length]
        for (int i = 0 i < params.length i++)
        (§
            Object arg = args[i]
            Class paramType = params[i]
            ret[i] = boxArg(paramType, arg)
        )
        return ret
    )

    static public boolean paramArgTypeMatch(Class paramType, Class argType)
    (§
        if (argType == null)
        (§
            return !paramType.isPrimitive()
        )
        if (paramType == argType || paramType.isAssignableFrom(argType))
        (§
            return true
        )
        if (paramType == int.class)
        (§
            return argType == Integer.class
                || argType == long.class
                || argType == Long.class
                || argType == short.class
                || argType == byte.class
        )
        else if (paramType == float.class)
        (§
            return argType == Float.class
                || argType == double.class
        )
        else if (paramType == double.class)
        (§
            return argType == Double.class
                || argType == float.class
        )
        else if (paramType == long.class)
        (§
            return argType == Long.class
                || argType == int.class
                || argType == short.class
                || argType == byte.class
        )
        else if (paramType == char.class)
        (§
            return argType == Character.class
        )
        else if (paramType == short.class)
        (§
            return argType == Short.class
        )
        else if (paramType == byte.class)
        (§
            return argType == Byte.class
        )
        else if (paramType == boolean.class)
        (§
            return argType == Boolean.class
        )
        return false
    )

    static boolean isCongruent(Class[] params, Object[] args)
    (§
        boolean ret = false
        if (args == null)
        (§
            return (params.length == 0)
        )
        if (params.length == args.length)
        (§
            ret = true
            for (int i = 0 ret && i < params.length i++)
            (§
                Object arg = args[i]
                Class argType = (arg == null) ? null :or arg.getClass()
                Class paramType = params[i]
                ret = paramArgTypeMatch(paramType, argType)
            )
        )
        return ret
    )

    public static Object prepRet(Class c, Object x)
    (§
        if (!(c.isPrimitive() || c == Boolean.class))
        (§
            return x
        )
        if (x instanceof Boolean)
        (§
            return ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE
        )
        return x
    )
)
)

(§ java cloiure.lang.Repeat

public class Repeat extends ASeq implements IReduce
(§
    private static final long INFINITE = -1

    private final long count ;; always INFINITE or >0
    private final Object val
    private volatile ISeq _next ;; cached

    private Repeat(long count, Object val)
    (§
        this.count = count
        this.val = val
    )

    private Repeat(IPersistentMap meta, long count, Object val)
    (§
        super(meta)
        this.count = count
        this.val = val
    )

    public static Repeat create(Object val)
    (§
        return new Repeat(INFINITE, val)
    )

    public static ISeq create(long count, Object val)
    (§
        if (count <= 0)
        (§
            return PersistentList.EMPTY
        )
        return new Repeat(count, val)
    )

    public Object first()
    (§
        return val
    )

    public ISeq next()
    (§
        if (_next == null)
        (§
            if (count > 1)
            (§
                _next = new Repeat(count - 1, val)
            )
            else if (count == INFINITE)
            (§
                _next = this
            )
        )
        return _next
    )

    public Repeat withMeta(IPersistentMap meta)
    (§
        return new Repeat(meta, count, val)
    )

    public Object reduce(IFn f)
    (§
        Object ret = val
        if (count == INFINITE)
        (§
            while (true)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
        )
        else
        (§
            for (long i = 1 i < count i++)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = start
        if (count == INFINITE)
        (§
            while (true)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
        )
        else
        (§
            for (long i = 0 i < count i++)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    return ((IDeref)ret).deref()
                )
            )
            return ret
        )
    )
)
)

(§ java cloiure.lang.RestFn

public abstract class RestFn extends AFunction
(§
    abstract public int getRequiredArity()

    protected Object doInvoke(Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object args)
    (§
        return null
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object arg20, Object args)
    (§
        return null
    )

    public Object applyTo(ISeq args)
    (§
        if (RT.boundedLength(args, getRequiredArity()) <= getRequiredArity())
        (§
            return AFn.applyToHelper(this, Util.ret1(args, args = null))
        )
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(Util.ret1(args, args = null))
            (§ case 1)
                return doInvoke(args.first(),
                        Util.ret1(args.next(), args = null))
            (§ case 2)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 3)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 4)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 5)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 6)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 7)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 8)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 9)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 10)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 11)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 12)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 13)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 14)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 15)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 16)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 17)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 18)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 19)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
            (§ case 20)
                return doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = null))
        )
        return throwArity(-1)
    )

    public Object invoke()
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(null)
            (§ default)
                return throwArity(0)
        )
    )

    public Object invoke(Object arg1)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), null)
            (§ default)
                return throwArity(1)
        )
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), null)
            (§ default)
                return throwArity(2)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), ArraySeq.create(Util.ret1(arg3, arg3 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null), null)
            (§ default)
                return throwArity(3)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), ArraySeq.create(Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null), ArraySeq.create(Util.ret1(arg4, arg4 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null), null)
            (§ default)
                return throwArity(4)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        ArraySeq.create(Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null),
                        ArraySeq.create(Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        ArraySeq.create(Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(Util.ret1(arg5, arg5 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), null)
            (§ default)
                return throwArity(5)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        ArraySeq.create(Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null),
                        ArraySeq.create(Util.ret1(arg3, arg3 = null), Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        ArraySeq.create(Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        ArraySeq.create(Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null),
                        ArraySeq.create(Util.ret1(arg6, arg6 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        null)
            (§ default)
                return throwArity(6)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(Util.ret1(arg7, arg7 = null)))
            (§ case 7)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), null)
            (§ default)
                return throwArity(7)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null)))
            (§ case 7)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(Util.ret1(arg8, arg8 = null)))
            (§ case 8)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null), null)
            (§ default)
                return throwArity(8)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 7)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null)))
            (§ case 8)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null), ArraySeq.create(Util.ret1(arg9, arg9 = null)))
            (§ case 9)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null), null)
            (§ default)
                return throwArity(9)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 7)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 8)
                return doInvoke(Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null), ArraySeq.create(Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null), ArraySeq.create(
                            Util.ret1(arg10, arg10 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), null)
            (§ default)
                return throwArity(10)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null), ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null), ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), ArraySeq.create(
                            Util.ret1(arg11, arg11 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null), null)
            (§ default)
                return throwArity(11)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null), ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null), ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null), ArraySeq.create(
                            Util.ret1(arg12, arg12 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null), null)
            (§ default)
                return throwArity(12)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(
                        ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), null)
            (§ default)
                return throwArity(13)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = null)))
            (§ case 14)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),
                        null)
            (§ default)
                return throwArity(14)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null)))
            (§ case 14)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = null)))
            (§ case 15)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null), null)
            (§ default)
                return throwArity(15)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 14)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null)))
            (§ case 15)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null), ArraySeq.create(
                            Util.ret1(arg16, arg16 = null)))
            (§ case 16)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), null)
            (§ default)
                return throwArity(16)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 14)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 15)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null), ArraySeq.create(
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null)))
            (§ case 16)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), ArraySeq.create(
                            Util.ret1(arg17, arg17 = null)))
            (§ case 17)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null),
                        Util.ret1(arg17, arg17 = null), null)
            (§ default)
                return throwArity(17)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),

                            Util.ret1(arg18, arg18 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 14)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 15)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null), ArraySeq.create(
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 16)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), ArraySeq.create(
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null)))
            (§ case 17)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null),
                        Util.ret1(arg17, arg17 = null), ArraySeq.create(
                            Util.ret1(arg18, arg18 = null)))
            (§ case 18)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null),
                        Util.ret1(arg17, arg17 = null),
                        Util.ret1(arg18, arg18 = null), null)
            (§ default)
                return throwArity(18)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 1)
                ISeq packed = PersistentList.EMPTY
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 3)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null), ArraySeq.create(
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 4)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 5)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null), ArraySeq.create(
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),

                            Util.ret1(arg19, arg19 = null)))
            (§ case 6)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null), ArraySeq.create(
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),

                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 7)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),

                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null), ArraySeq.create(
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),

                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 9)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 10)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 13)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 14)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 15)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null), ArraySeq.create(
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 16)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), ArraySeq.create(
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 17)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null),
                        Util.ret1(arg17, arg17 = null), ArraySeq.create(
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null)))
            (§ case 18)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null),
                        Util.ret1(arg17, arg17 = null),
                        Util.ret1(arg18, arg18 = null), ArraySeq.create(
                            Util.ret1(arg19, arg19 = null)))
            (§ case 19)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null),
                        Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null),
                        Util.ret1(arg5, arg5 = null),
                        Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null),
                        Util.ret1(arg8, arg8 = null),
                        Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null),
                        Util.ret1(arg11, arg11 = null),
                        Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null),
                        Util.ret1(arg14, arg14 = null),

                        Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null),
                        Util.ret1(arg17, arg17 = null),
                        Util.ret1(arg18, arg18 = null),
                        Util.ret1(arg19, arg19 = null), null)
            (§ default)
                return throwArity(19)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = null),
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 1)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), ArraySeq.create(
                            Util.ret1(arg2, arg2 = null),
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 2)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null),
                        Util.ret1(arg2, arg2 = null), ArraySeq.create(
                            Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null),
                            Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null),
                            Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null),

                            Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        ArraySeq.create(Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ArraySeq.create(Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null), Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null), Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), ArraySeq.create(Util.ret1(arg6, arg6 = null), Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        ArraySeq.create(Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 7)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ArraySeq.create(Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 8)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), ArraySeq.create(Util.ret1(arg9, arg9 = null), Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 9)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        ArraySeq.create(Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 10)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), ArraySeq.create(Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), ArraySeq.create(Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 12)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        ArraySeq.create(Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 13)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), ArraySeq.create(Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 14)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), ArraySeq.create(Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 15)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        ArraySeq.create(Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 16)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), ArraySeq.create(Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 17)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), ArraySeq.create(Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 18)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                        ArraySeq.create(Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 19)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                        Util.ret1(arg19, arg19 = null), ArraySeq.create(Util.ret1(arg20, arg20 = null)))
            (§ case 20)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                        Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null), null)
            (§ default)
                return throwArity(20)
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                return doInvoke(ontoArrayPrepend(args, Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 1)
                return doInvoke(Util.ret1(arg1, arg1 = null), ontoArrayPrepend(args, Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null), Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 2)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), ontoArrayPrepend(args, Util.ret1(arg3, arg3 = null),
                            Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null),
                            Util.ret1(arg6, arg6 = null), Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 3)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        ontoArrayPrepend(args, Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                            Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 4)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), ontoArrayPrepend(args, Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null), Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null), Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 5)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), ontoArrayPrepend(args, Util.ret1(arg6, arg6 = null), Util.ret1(arg7, arg7 = null),
                            Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 6)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        ontoArrayPrepend(args, Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 7)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), ontoArrayPrepend(args, Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                            Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null),
                            Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 8)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), ontoArrayPrepend(args, Util.ret1(arg9, arg9 = null), Util.ret1(arg10, arg10 = null),
                            Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 9)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        ontoArrayPrepend(args, Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 10)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), ontoArrayPrepend(args, Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                            Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null),
                            Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 11)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), ontoArrayPrepend(args, Util.ret1(arg12, arg12 = null), Util.ret1(arg13, arg13 = null),
                            Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 12)
                return doInvoke(
                        Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        ontoArrayPrepend(args, Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 13)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), ontoArrayPrepend(args, Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                            Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null),
                            Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 14)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), ontoArrayPrepend(args, Util.ret1(arg15, arg15 = null), Util.ret1(arg16, arg16 = null),
                            Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 15)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        ontoArrayPrepend(args, Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 16)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), ontoArrayPrepend(args, Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                            Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 17)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), ontoArrayPrepend(args, Util.ret1(arg18, arg18 = null), Util.ret1(arg19, arg19 = null),
                            Util.ret1(arg20, arg20 = null)))
            (§ case 18)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                        ontoArrayPrepend(args, Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null)))
            (§ case 19)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                        Util.ret1(arg19, arg19 = null), ontoArrayPrepend(args, Util.ret1(arg20, arg20 = null)))
            (§ case 20)
                return doInvoke(Util.ret1(arg1, arg1 = null), Util.ret1(arg2, arg2 = null), Util.ret1(arg3, arg3 = null),
                        Util.ret1(arg4, arg4 = null), Util.ret1(arg5, arg5 = null), Util.ret1(arg6, arg6 = null),
                        Util.ret1(arg7, arg7 = null), Util.ret1(arg8, arg8 = null), Util.ret1(arg9, arg9 = null),
                        Util.ret1(arg10, arg10 = null), Util.ret1(arg11, arg11 = null), Util.ret1(arg12, arg12 = null),
                        Util.ret1(arg13, arg13 = null), Util.ret1(arg14, arg14 = null), Util.ret1(arg15, arg15 = null),
                        Util.ret1(arg16, arg16 = null), Util.ret1(arg17, arg17 = null), Util.ret1(arg18, arg18 = null),
                        Util.ret1(arg19, arg19 = null), Util.ret1(arg20, arg20 = null), ArraySeq.create(args))
            (§ default)
                return throwArity(21)
        )
    )

    protected static ISeq ontoArrayPrepend(Object[] array, Object... args)
    (§
        ISeq ret = ArraySeq.create(array)
        for (int i = args.length - 1 i >= 0 --i)
        (§
            ret = RT.cons(args[i], ret)
        )
        return ret
    )

    protected static ISeq findKey(Object key, ISeq args)
    (§
        while (args != null)
        (§
            if (key == args.first())
            (§
                return args.next()
            )
            args = RT.next(args)
            args = RT.next(args)
        )
        return null
    )
)
)

(§ java cloiure.lang.Reversible

public interface Reversible
(§
    ISeq rseq()
)
)

(§ java cloiure.lang.RT

import java.net.MalformedURLException
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.Callable
import java.util.*
import java.util.regex.Matcher
import java.util.regex.Pattern
import java.io.*
import java.lang.reflect.Array
import java.math.BigDecimal
import java.math.BigInteger
import java.security.AccessController
import java.security.PrivilegedAction
import java.net.URL
import java.net.JarURLConnection
import java.nio.charset.Charset
import java.net.URLConnection

public class RT
(§
    static final public Boolean T = Boolean.TRUE
    static final public Boolean F = Boolean.FALSE
    static final public String LOADER_SUFFIX = "__init"

    ;; simple-symbol->class
    final static public IPersistentMap DEFAULT_IMPORTS = map(
            Symbol.intern("Boolean"), Boolean.class,
            Symbol.intern("Byte"), Byte.class,
            Symbol.intern("Character"), Character.class,
            Symbol.intern("Class"), Class.class,
            Symbol.intern("ClassLoader"), ClassLoader.class,
            Symbol.intern("Compiler"), Compiler.class,
            Symbol.intern("Double"), Double.class,
            Symbol.intern("Enum"), Enum.class,
            Symbol.intern("Float"), Float.class,
            Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
            Symbol.intern("Integer"), Integer.class,
            Symbol.intern("Long"), Long.class,
            Symbol.intern("Math"), Math.class,
            Symbol.intern("Number"), Number.class,
            Symbol.intern("Object"), Object.class,
            Symbol.intern("Package"), Package.class,
            Symbol.intern("Process"), Process.class,
            Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
            Symbol.intern("Runtime"), Runtime.class,
            Symbol.intern("RuntimePermission"), RuntimePermission.class,
            Symbol.intern("SecurityManager"), SecurityManager.class,
            Symbol.intern("Short"), Short.class,
            Symbol.intern("StackTraceElement"), StackTraceElement.class,
            Symbol.intern("StrictMath"), StrictMath.class,
            Symbol.intern("String"), String.class,
            Symbol.intern("StringBuffer"), StringBuffer.class,
            Symbol.intern("StringBuilder"), StringBuilder.class,
            Symbol.intern("System"), System.class,
            Symbol.intern("Thread"), Thread.class,
            Symbol.intern("ThreadGroup"), ThreadGroup.class,
            Symbol.intern("ThreadLocal"), ThreadLocal.class,
            Symbol.intern("Throwable"), Throwable.class,
            Symbol.intern("Void"), Void.class,
            Symbol.intern("Appendable"), Appendable.class,
            Symbol.intern("CharSequence"), CharSequence.class,
            Symbol.intern("Cloneable"), Cloneable.class,
            Symbol.intern("Comparable"), Comparable.class,
            Symbol.intern("Iterable"), Iterable.class,
            Symbol.intern("Readable"), Readable.class,
            Symbol.intern("Runnable"), Runnable.class,
            Symbol.intern("Callable"), Callable.class,
            Symbol.intern("BigInteger"), BigInteger.class,
            Symbol.intern("BigDecimal"), BigDecimal.class,
            Symbol.intern("ArithmeticException"), ArithmeticException.class,
            Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
            Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
            Symbol.intern("ClassCastException"), ClassCastException.class,
            Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
            Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
            Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
            Symbol.intern("Exception"), Exception.class,
            Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
            Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
            Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
            Symbol.intern("IllegalStateException"), IllegalStateException.class,
            Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
            Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
            Symbol.intern("InstantiationException"), InstantiationException.class,
            Symbol.intern("InterruptedException"), InterruptedException.class,
            Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
            Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
            Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
            Symbol.intern("NullPointerException"), NullPointerException.class,
            Symbol.intern("NumberFormatException"), NumberFormatException.class,
            Symbol.intern("RuntimeException"), RuntimeException.class,
            Symbol.intern("SecurityException"), SecurityException.class,
            Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
            Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
            Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
            Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
            Symbol.intern("AssertionError"), AssertionError.class,
            Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
            Symbol.intern("ClassFormatError"), ClassFormatError.class,
            Symbol.intern("Error"), Error.class,
            Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
            Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
            Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
            Symbol.intern("InstantiationError"), InstantiationError.class,
            Symbol.intern("InternalError"), InternalError.class,
            Symbol.intern("LinkageError"), LinkageError.class,
            Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
            Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
            Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
            Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
            Symbol.intern("StackOverflowError"), StackOverflowError.class,
            Symbol.intern("ThreadDeath"), ThreadDeath.class,
            Symbol.intern("UnknownError"), UnknownError.class,
            Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
            Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
            Symbol.intern("VerifyError"), VerifyError.class,
            Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
            Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
            Symbol.intern("Thread$State"), Thread.State.class,
            Symbol.intern("Deprecated"), Deprecated.class,
            Symbol.intern("Override"), Override.class,
            Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    )

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    static public Charset UTF8 = Charset.forName("UTF-8")

    static Object readTrueFalseUnknown(String s)
    (§
        if (s.equals("true"))
        (§
            return Boolean.TRUE
        )
        else if (s.equals("false"))
        (§
            return Boolean.FALSE
        )
        return Keyword.intern(null, "unknown")
    )

    static public final Namespace CLOIURE_NS = Namespace.findOrCreate(Symbol.intern("cloiure.core"))
    final static public Var OUT = Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic()
    final static public Var IN = Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic()
    final static public Var ERR = Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic()
    final static Keyword TAG_KEY = Keyword.intern(null, "tag")
    final static Keyword CONST_KEY = Keyword.intern(null, "const")
    final static public Var AGENT = Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), null).setDynamic()
    static Object readeval = readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true"))
    final static public Var READEVAL = Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"),  readeval).setDynamic()
    final static public Var DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic()
    final static public Var DEFAULT_DATA_READER_FN = Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic()
    final static public Var DEFAULT_DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map())
    final static public Var SUPPRESS_READ = Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), null).setDynamic()
    final static public Var ASSERT = Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic()
    final static public Var MATH_CONTEXT = Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), null).setDynamic()
    static Keyword LINE_KEY = Keyword.intern(null, "line")
    static Keyword COLUMN_KEY = Keyword.intern(null, "column")
    static Keyword FILE_KEY = Keyword.intern(null, "file")
    static Keyword DECLARED_KEY = Keyword.intern(null, "declared")
    static Keyword DOC_KEY = Keyword.intern(null, "doc")
    final static public Var USE_CONTEXT_CLASSLOADER = Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic()
    ;; boolean
    static final public Var UNCHECKED_MATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic()

    final static Symbol LOAD_FILE = Symbol.intern("load-file")
    final static Symbol IN_NAMESPACE = Symbol.intern("in-ns")
    final static Symbol NAMESPACE = Symbol.intern("ns")
    static final Symbol IDENTICAL = Symbol.intern("identical?")
    final static Var CMD_LINE_ARGS = Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), null).setDynamic()
    ;; symbol
    final public static Var CURRENT_NS = Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic()

    final static Var FLUSH_ON_NEWLINE = Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic()
    final static Var PRINT_META = Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic()
    final static Var PRINT_READABLY = Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic()
    final static Var PRINT_DUP = Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic()
    final static Var WARN_ON_REFLECTION = Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic()
    final static Var ALLOW_UNRESOLVED_VARS = Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic()
    final static Var READER_RESOLVER = Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), null).setDynamic()

    final static Var IN_NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F)
    final static Var NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("ns"), F)
    final static Var FN_LOADER_VAR = Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), null).setDynamic()
    static final Var PRINT_INITIALIZED = Var.intern(CLOIURE_NS, Symbol.intern("print-initialized"))
    static final Var PR_ON = Var.intern(CLOIURE_NS, Symbol.intern("pr-on"))

    final static IFn inNamespace = new AFn()
    (§
        public Object invoke(Object arg1)
        (§
            Symbol nsname = (Symbol) arg1
            Namespace ns = Namespace.findOrCreate(nsname)
            CURRENT_NS.set(ns)
            return ns
        )
    )

    final static IFn bootNamespace = new AFn()
    (§
        public Object invoke(Object __form, Object __env, Object arg1)
        (§
            Symbol nsname = (Symbol) arg1
            Namespace ns = Namespace.findOrCreate(nsname)
            CURRENT_NS.set(ns)
            return ns
        )
    )

    public static List<String> processCommandLine(String[] args)
    (§
        List<String> arglist = Arrays.asList(args)
        int split = arglist.indexOf("--")
        if (split >= 0)
        (§
            CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length)))
            return arglist.subList(0, split)
        )
        return arglist
    )

    ;; duck typing stderr plays nice with e.g. swank
    public static PrintWriter errPrintWriter()
    (§
        Writer w = (Writer) ERR.deref()
        if (w instanceof PrintWriter)
        (§
            return (PrintWriter) w
        )
        else
        (§
            return new PrintWriter(w)
        )
    )

    static public final Object[] EMPTY_ARRAY = new Object[] (§)
    static public final Comparator DEFAULT_COMPARATOR = new DefaultComparator()

    private static final class DefaultComparator implements Comparator, Serializable
    (§
        public int compare(Object o1, Object o2)
        (§
            return Util.compare(o1, o2)
        )

        private Object readResolve() throws ObjectStreamException
        (§
            ;; ensures that we aren't hanging onto a new default comparator for every
            ;; sorted set, etc., we deserialize
            return DEFAULT_COMPARATOR
        )
    )

    static AtomicInteger id = new AtomicInteger(1)

    static public void addURL(Object url) throws MalformedURLException
    (§
        URL u = (url instanceof String) ? (new URL((String) url)) :or (URL) url
        ClassLoader ccl = Thread.currentThread().getContextClassLoader()
        if (ccl instanceof DynamicClassLoader)
        (§
            ((DynamicClassLoader)ccl).addURL(u)
        )
        else
        (§
            throw new IllegalAccessError("Context classloader is not a DynamicClassLoader")
        )
    )

    public static boolean checkSpecAsserts = Boolean.getBoolean("cloiure.spec.check-asserts")
    public static boolean instrumentMacros = ! Boolean.getBoolean("cloiure.spec.skip-macros")
    static volatile boolean CHECK_SPECS = false

    static
    (§
        Keyword arglistskw = Keyword.intern(null, "arglists")
        Symbol namesym = Symbol.intern("name")
        OUT.setTag(Symbol.intern("java.io.Writer"))
        CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace"))
        AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil"))
        AGENT.setTag(Symbol.intern("cloiure.lang.Agent"))
        MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext"))
        Var nv = Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace)
        nv.setMacro()
        Var v
        v = Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace)
        v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym))))
        v = Var.intern(CLOIURE_NS, LOAD_FILE, new AFn()
        (§
            public Object invoke(Object arg1)
            (§
                try
                (§
                    return Compiler.loadFile((String) arg1)
                )
                catch (IOException e)
                (§
                    throw Util.sneakyThrow(e)
                )
            )
        ))
        v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym))))
        try
        (§
            doInit()
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(e)
        )

        CHECK_SPECS = RT.instrumentMacros
    )

    static public Keyword keyword(String ns, String name)
    (§
        return Keyword.intern((Symbol.intern(ns, name)))
    )

    static public Var var(String ns, String name)
    (§
        return Var.intern(Namespace.findOrCreate(Symbol.intern(null, ns)), Symbol.intern(null, name))
    )

    static public Var var(String ns, String name, Object init)
    (§
        return Var.intern(Namespace.findOrCreate(Symbol.intern(null, ns)), Symbol.intern(null, name), init)
    )

    public static void loadResourceScript(String name) throws IOException
    (§
        loadResourceScript(name, true)
    )

    public static void maybeLoadResourceScript(String name) throws IOException
    (§
        loadResourceScript(name, false)
    )

    public static void loadResourceScript(String name, boolean failIfNotFound) throws IOException
    (§
        loadResourceScript(RT.class, name, failIfNotFound)
    )

    public static void loadResourceScript(Class c, String name) throws IOException
    (§
        loadResourceScript(c, name, true)
    )

    public static void loadResourceScript(Class c, String name, boolean failIfNotFound) throws IOException
    (§
        int slash = name.lastIndexOf((§ char \/))
        String file = (slash >= 0) ? name.substring(slash + 1) :or name
        InputStream ins = resourceAsStream(baseLoader(), name)
        if (ins != null)
        (§
            try
            (§
                Compiler.load(new InputStreamReader(ins, UTF8), name, file)
            )
            finally
            (§
                ins.close()
            )
        )
        else if (failIfNotFound)
        (§
            throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + name)
        )
    )

    static public void init()
    (§
        RT.errPrintWriter().println("No need to call RT.init() anymore")
    )

    static public long lastModified(URL url, String libfile) throws IOException
    (§
        URLConnection connection = url.openConnection()
        try
        (§
            if (url.getProtocol().equals("jar"))
            (§
                return ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime()
            )
            else
            (§
                return connection.getLastModified()
            )
        )
        finally
        (§
            InputStream ins = connection.getInputStream()
            if (ins != null)
            (§
                ins.close()
            )
        )
    )

    static void compile(String cljfile) throws IOException
    (§
        InputStream ins = resourceAsStream(baseLoader(), cljfile)
        if (ins != null)
        (§
            try
            (§
                Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/")))
            )
            finally
            (§
                ins.close()
            )
        )
        else
        (§
            throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + cljfile)
        )
    )

    static public void load(String scriptbase) throws IOException, ClassNotFoundException
    (§
        load(scriptbase, true)
    )

    static public void load(String scriptbase, boolean failIfNotFound) throws IOException, ClassNotFoundException
    (§
        String classfile = scriptbase + LOADER_SUFFIX + ".class"
        String cljfile = scriptbase + ".cli"
        String scriptfile = cljfile
        URL classURL = getResource(baseLoader(), classfile)
        URL cljURL = getResource(baseLoader(), scriptfile)
        if (cljURL == null)
        (§
            scriptfile = scriptbase + ".clic"
            cljURL = getResource(baseLoader(), scriptfile)
        )
        boolean loaded = false

        if ((classURL != null && (cljURL == null || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == null)
        (§
            try
            (§
                Var.pushThreadBindings(RT.mapUniqueKeys(
                            CURRENT_NS, CURRENT_NS.deref(),
                            WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                            RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                ))
                loaded = (loadClassForName(scriptbase.replace((§ char \/), (§ char \.)) + LOADER_SUFFIX) != null)
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
        if (!loaded && cljURL != null)
        (§
            if (booleanCast(Compiler.COMPILE_FILES.deref()))
            (§
                compile(scriptfile)
            )
            else
            (§
                loadResourceScript(RT.class, scriptfile)
            )
        )
        else if (!loaded && failIfNotFound)
        (§
            throw new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile,
                        scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or ""))
        )
    )

    static void doInit()
        throws ClassNotFoundException, IOException
    (§
        load("cloiure/core")

        Var.pushThreadBindings(RT.mapUniqueKeys(
                    CURRENT_NS, CURRENT_NS.deref(),
                    WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                    RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        ))
        try
        (§
            Symbol USER = Symbol.intern("user")
            Symbol CLOIURE = Symbol.intern("cloiure.core")

            Var in_ns = var("cloiure.core", "in-ns")
            Var refer = var("cloiure.core", "refer")
            in_ns.invoke(USER)
            refer.invoke(CLOIURE)
            maybeLoadResourceScript("user.cli")

            ;; start socket servers
            Var require = var("cloiure.core", "require")
            Symbol SERVER = Symbol.intern("cloiure.core.server")
            require.invoke(SERVER)
            Var start_servers = var("cloiure.core.server", "start-servers")
            start_servers.invoke(System.getProperties())
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )

    static public int nextID()
    (§
        return id.getAndIncrement()
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    public static void loadLibrary(String libname)
    (§
        System.loadLibrary(libname)
    )

    private static final int CHUNK_SIZE = 32

    public static ISeq chunkIteratorSeq(final Iterator iter)
    (§
        if (iter.hasNext())
        (§
            return new LazySeq(new AFn()
            (§
                public Object invoke()
                (§
                    Object[] arr = new Object[CHUNK_SIZE]
                    int n = 0
                    while (iter.hasNext() && n < CHUNK_SIZE)
                        arr[n++] = iter.next()
                    return new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter))
                )
            ))
        )
        return null
    )

    static public ISeq seq(Object coll)
    (§
        if (coll instanceof ASeq)
        (§
            return (ASeq) coll
        )
        else if (coll instanceof LazySeq)
        (§
            return ((LazySeq) coll).seq()
        )
        else
        (§
            return seqFrom(coll)
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    static ISeq seqFrom(Object coll)
    (§
        if (coll instanceof Seqable)
        (§
            return ((Seqable) coll).seq()
        )
        else if (coll == null)
        (§
            return null
        )
        else if (coll instanceof Iterable)
        (§
            return chunkIteratorSeq(((Iterable) coll).iterator())
        )
        else if (coll.getClass().isArray())
        (§
            return ArraySeq.createFromObject(coll)
        )
        else if (coll instanceof CharSequence)
        (§
            return StringSeq.create((CharSequence) coll)
        )
        else if (coll instanceof Map)
        (§
            return seq(((Map) coll).entrySet())
        )
        else
        (§
            Class c = coll.getClass()
            Class sc = c.getSuperclass()
            throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName())
        )
    )

    static public boolean canSeq(Object coll)
    (§
        return coll instanceof ISeq
            || coll instanceof Seqable
            || coll == null
            || coll instanceof Iterable
            || coll.getClass().isArray()
            || coll instanceof CharSequence
            || coll instanceof Map
    )

    static public Iterator iter(Object coll)
    (§
        if (coll instanceof Iterable)
        (§
            return ((Iterable)coll).iterator()
        )
        else if (coll == null)
        (§
            return new Iterator()
            (§
                public boolean hasNext()
                (§
                    return false
                )

                public Object next()
                (§
                    throw new NoSuchElementException()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )
        else if (coll instanceof Map)
        (§
            return ((Map)coll).entrySet().iterator()
        )
        else if (coll instanceof String)
        (§
            final String s = (String) coll
            return new Iterator()
            (§
                int i = 0

                public boolean hasNext()
                (§
                    return (i < s.length())
                )

                public Object next()
                (§
                    return s.charAt(i++)
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )
        )
        else if (coll.getClass().isArray())
        (§
            return ArrayIter.createFromObject(coll)
        )
        else
        (§
            return iter(seq(coll))
        )
    )

    static public Object seqOrElse(Object o)
    (§
        return (seq(o) == null) ? null :or o
    )

    static public ISeq keys(Object coll)
    (§
        if (coll instanceof IPersistentMap)
        (§
            return APersistentMap.KeySeq.createFromMap((IPersistentMap)coll)
        )
        else
        (§
            return APersistentMap.KeySeq.create(seq(coll))
        )
    )

    static public ISeq vals(Object coll)
    (§
        if (coll instanceof IPersistentMap)
        (§
            return APersistentMap.ValSeq.createFromMap((IPersistentMap)coll)
        )
        else
        (§
            return APersistentMap.ValSeq.create(seq(coll))
        )
    )

    static public IPersistentMap meta(Object x)
    (§
        if (x instanceof IMeta)
        (§
            return ((IMeta) x).meta()
        )
        return null
    )

    public static int count(Object o)
    (§
        if (o instanceof Counted)
        (§
            return ((Counted) o).count()
        )
        return countFrom(Util.ret1(o, o = null))
    )

    static int countFrom(Object o)
    (§
        if (o == null)
        (§
            return 0
        )
        else if (o instanceof IPersistentCollection)
        (§
            ISeq s = seq(o)
            o = null
            int i = 0
            for (  s != null s = s.next())
            (§
                if (s instanceof Counted)
                (§
                    return i + s.count()
                )
                i++
            )
            return i
        )
        else if (o instanceof CharSequence)
        (§
            return ((CharSequence) o).length()
        )
        else if (o instanceof Collection)
        (§
            return ((Collection) o).size()
        )
        else if (o instanceof Map)
        (§
            return ((Map) o).size()
        )
        else if (o instanceof Map.Entry)
        (§
            return 2
        )
        else if (o.getClass().isArray())
        (§
            return Array.getLength(o)
        )

        throw new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName())
    )

    static public IPersistentCollection conj(IPersistentCollection coll, Object x)
    (§
        if (coll == null)
        (§
            return new PersistentList(x)
        )
        return coll.cons(x)
    )

    static public ISeq cons(Object x, Object coll)
    (§
        if (coll == null)
        (§
            return new PersistentList(x)
        )
        else if (coll instanceof ISeq)
        (§
            return new Cons(x, (ISeq) coll)
        )
        else
        (§
            return new Cons(x, seq(coll))
        )
    )

    static public Object first(Object x)
    (§
        if (x instanceof ISeq)
        (§
            return ((ISeq) x).first()
        )
        ISeq seq = seq(x)
        if (seq == null)
        (§
            return null
        )
        return seq.first()
    )

    static public Object second(Object x)
    (§
        return first(next(x))
    )

    static public Object third(Object x)
    (§
        return first(next(next(x)))
    )

    static public Object fourth(Object x)
    (§
        return first(next(next(next(x))))
    )

    static public ISeq next(Object x)
    (§
        if (x instanceof ISeq)
        (§
            return ((ISeq) x).next()
        )
        ISeq seq = seq(x)
        if (seq == null)
        (§
            return null
        )
        return seq.next()
    )

    static public ISeq more(Object x)
    (§
        if (x instanceof ISeq)
        (§
            return ((ISeq) x).more()
        )
        ISeq seq = seq(x)
        if (seq == null)
        (§
            return PersistentList.EMPTY
        )
        return seq.more()
    )

    static public Object peek(Object x)
    (§
        if (x == null)
        (§
            return null
        )
        return ((IPersistentStack) x).peek()
    )

    static public Object pop(Object x)
    (§
        if (x == null)
        (§
            return null
        )
        return ((IPersistentStack) x).pop()
    )

    static public Object get(Object coll, Object key)
    (§
        if (coll instanceof ILookup)
        (§
            return ((ILookup) coll).valAt(key)
        )
        return getFrom(coll, key)
    )

    static Object getFrom(Object coll, Object key)
    (§
        if (coll == null)
        (§
            return null
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            return m.get(key)
        )
        else if (coll instanceof IPersistentSet)
        (§
            IPersistentSet set = (IPersistentSet) coll
            return set.get(key)
        )
        else if (key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
        (§
            int n = ((Number) key).intValue()
            if (n >= 0 && n < count(coll))
            (§
                return nth(coll, n)
            )
            return null
        )
        else if (coll instanceof ITransientSet)
        (§
            ITransientSet set = (ITransientSet) coll
            return set.get(key)
        )

        return null
    )

    static public Object get(Object coll, Object key, Object notFound)
    (§
        if (coll instanceof ILookup)
        (§
            return ((ILookup) coll).valAt(key, notFound)
        )
        return getFrom(coll, key, notFound)
    )

    static Object getFrom(Object coll, Object key, Object notFound)
    (§
        if (coll == null)
        (§
            return notFound
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            if (m.containsKey(key))
            (§
                return m.get(key)
            )
            return notFound
        )
        else if (coll instanceof IPersistentSet)
        (§
            IPersistentSet set = (IPersistentSet) coll
            if (set.contains(key))
            (§
                return set.get(key)
            )
            return notFound
        )
        else if (key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
        (§
            int n = ((Number) key).intValue()
            return (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound
        )
        else if (coll instanceof ITransientSet)
        (§
            ITransientSet set = (ITransientSet) coll
            if (set.contains(key))
            (§
                return set.get(key)
            )
            return notFound
        )
        return notFound
    )

    static public Associative assoc(Object coll, Object key, Object val)
    (§
        if (coll == null)
        (§
            return new PersistentArrayMap(new Object[] (§ key, val ))
        )
        return ((Associative) coll).assoc(key, val)
    )

    static public Object contains(Object coll, Object key)
    (§
        if (coll == null)
        (§
            return F
        )
        else if (coll instanceof Associative)
        (§
            return ((Associative) coll).containsKey(key) ? T :or F
        )
        else if (coll instanceof IPersistentSet)
        (§
            return ((IPersistentSet) coll).contains(key) ? T :or F
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            return m.containsKey(key) ? T :or F
        )
        else if (coll instanceof Set)
        (§
            Set s = (Set) coll
            return s.contains(key) ? T :or F
        )
        else if (key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
        (§
            int n = ((Number) key).intValue()
            return (n >= 0 && n < count(coll)) ? T :or F
        )
        else if (coll instanceof ITransientSet)
        (§
            return ((ITransientSet)coll).contains(key) ? T :or F
        )
        else if (coll instanceof ITransientAssociative2)
        (§
            return (((ITransientAssociative2)coll).containsKey(key)) ? T :or F
        )
        throw new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName())
    )

    static public Object find(Object coll, Object key)
    (§
        if (coll == null)
        (§
            return null
        )
        else if (coll instanceof Associative)
        (§
            return ((Associative) coll).entryAt(key)
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            if (m.containsKey(key))
            (§
                return MapEntry.create(key, m.get(key))
            )
            return null
        )
        else if (coll instanceof ITransientAssociative2)
        (§
            return ((ITransientAssociative2) coll).entryAt(key)
        )
        throw new IllegalArgumentException("find not supported on type: " + coll.getClass().getName())
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else null
    static public ISeq findKey(Keyword key, ISeq keyvals)
    (§
        while (keyvals != null)
        (§
            ISeq r = keyvals.next()
            if (r == null)
            (§
                throw Util.runtimeException("Malformed keyword argslist")
            )
            if (keyvals.first() == key)
            (§
                return r
            )
            keyvals = r.next()
        )
        return null
    )

    static public Object dissoc(Object coll, Object key)
    (§
        if (coll == null)
        (§
            return null
        )
        return ((IPersistentMap) coll).without(key)
    )

    static public Object nth(Object coll, int n)
    (§
        if (coll instanceof Indexed)
        (§
            return ((Indexed) coll).nth(n)
        )
        return nthFrom(Util.ret1(coll, coll = null), n)
    )

    static Object nthFrom(Object coll, int n)
    (§
        if (coll == null)
        (§
            return null
        )
        else if (coll instanceof CharSequence)
        (§
            return Character.valueOf(((CharSequence) coll).charAt(n))
        )
        else if (coll.getClass().isArray())
        (§
            return Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))
        )
        else if (coll instanceof RandomAccess)
        (§
            return ((List) coll).get(n)
        )
        else if (coll instanceof Matcher)
        (§
            return ((Matcher) coll).group(n)
        )
        else if (coll instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) coll
            if (n == 0)
            (§
                return e.getKey()
            )
            else if (n == 1)
            (§
                return e.getValue()
            )
            throw new IndexOutOfBoundsException()
        )
        else if (coll instanceof Sequential)
        (§
            ISeq seq = RT.seq(coll)
            coll = null
            for (int i = 0 i <= n && seq != null ++i, seq = seq.next())
            (§
                if (i == n)
                (§
                    return seq.first()
                )
            )
            throw new IndexOutOfBoundsException()
        )
        else
        (§
            throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())
        )
    )

    static public Object nth(Object coll, int n, Object notFound)
    (§
        if (coll instanceof Indexed)
        (§
            Indexed v = (Indexed) coll
            return v.nth(n, notFound)
        )
        return nthFrom(coll, n, notFound)
    )

    static Object nthFrom(Object coll, int n, Object notFound)
    (§
        if (coll == null)
        (§
            return notFound
        )
        else if (n < 0)
        (§
            return notFound
        )
        else if (coll instanceof CharSequence)
        (§
            CharSequence s = (CharSequence) coll
            if (n < s.length())
            (§
                return Character.valueOf(s.charAt(n))
            )
            return notFound
        )
        else if (coll.getClass().isArray())
        (§
            if (n < Array.getLength(coll))
            (§
                return Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))
            )
            return notFound
        )
        else if (coll instanceof RandomAccess)
        (§
            List list = (List) coll
            if (n < list.size())
            (§
                return list.get(n)
            )
            return notFound
        )
        else if (coll instanceof Matcher)
        (§
            Matcher m = (Matcher) coll
            if (n < m.groupCount())
            (§
                return m.group(n)
            )
            return notFound
        )
        else if (coll instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) coll
            if (n == 0)
            (§
                return e.getKey()
            )
            else if (n == 1)
            (§
                return e.getValue()
            )
            return notFound
        )
        else if (coll instanceof Sequential)
        (§
            ISeq seq = RT.seq(coll)
            coll = null
            for (int i = 0 i <= n && seq != null ++i, seq = seq.next())
            (§
                if (i == n)
                (§
                    return seq.first()
                )
            )
            return notFound
        )
        else
        (§
            throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())
        )
    )

    static public Object assocN(int n, Object val, Object coll)
    (§
        if (coll == null)
        (§
            return null
        )
        else if (coll instanceof IPersistentVector)
        (§
            return ((IPersistentVector) coll).assocN(n, val)
        )
        else if (coll instanceof Object[])
        (§
            ;; hmm... this is not persistent
            Object[] array = ((Object[]) coll)
            array[n] = val
            return array
        )
        else
        (§
            return null
        )
    )

    static boolean hasTag(Object o, Object tag)
    (§
        return Util.equals(tag, RT.get(RT.meta(o), TAG_KEY))
    )

    static public Object box(Object x)
    (§
        return x
    )

    static public Character box(char x)
    (§
        return Character.valueOf(x)
    )

    static public Object box(boolean x)
    (§
        return x ? T :or F
    )

    static public Object box(Boolean x)
    (§
        return x
    )

    static public Number box(byte x)
    (§
        return x
    )

    static public Number box(short x)
    (§
        return x
    )

    static public Number box(int x)
    (§
        return x
    )

    static public Number box(long x)
    (§
        return x
    )

    static public Number box(float x)
    (§
        return x
    )

    static public Number box(double x)
    (§
        return x
    )

    static public char charCast(Object x)
    (§
        if (x instanceof Character)
        (§
            return ((Character) x).charValue()
        )
        long n = ((Number) x).longValue()
        if (n < Character.MIN_VALUE || n > Character.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        return (char) n
    )

    static public char charCast(byte x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        return i
    )

    static public char charCast(short x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        return i
    )

    static public char charCast(char x)
    (§
        return x
    )

    static public char charCast(int x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        return i
    )

    static public char charCast(long x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        return i
    )

    static public char charCast(float x)
    (§
        if (x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
        (§
            return (char) x
        )
        throw new IllegalArgumentException("Value out of range for char: " + x)
    )

    static public char charCast(double x)
    (§
        if (x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
        (§
            return (char) x
        )
        throw new IllegalArgumentException("Value out of range for char: " + x)
    )

    static public boolean booleanCast(Object x)
    (§
        if (x instanceof Boolean)
        (§
            return ((Boolean) x).booleanValue()
        )
        return (x != null)
    )

    static public boolean booleanCast(boolean x)
    (§
        return x
    )

    static public byte byteCast(Object x)
    (§
        if (x instanceof Byte)
        (§
            return ((Byte) x).byteValue()
        )
        long n = longCast(x)
        if (n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        return (byte) n
    )

    static public byte byteCast(byte x)
    (§
        return x
    )

    static public byte byteCast(short x)
    (§
        byte i = (byte) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        return i
    )

    static public byte byteCast(int x)
    (§
        byte i = (byte) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        return i
    )

    static public byte byteCast(long x)
    (§
        byte i = (byte) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        return i
    )

    static public byte byteCast(float x)
    (§
        if (x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
        (§
            return (byte) x
        )
        throw new IllegalArgumentException("Value out of range for byte: " + x)
    )

    static public byte byteCast(double x)
    (§
        if (x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
        (§
            return (byte) x
        )
        throw new IllegalArgumentException("Value out of range for byte: " + x)
    )

    static public short shortCast(Object x)
    (§
        if (x instanceof Short)
        (§
            return ((Short) x).shortValue()
        )
        long n = longCast(x)
        if (n < Short.MIN_VALUE || n > Short.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for short: " + x)
        )
        return (short) n
    )

    static public short shortCast(byte x)
    (§
        return x
    )

    static public short shortCast(short x)
    (§
        return x
    )

    static public short shortCast(int x)
    (§
        short i = (short) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for short: " + x)
        )
        return i
    )

    static public short shortCast(long x)
    (§
        short i = (short) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for short: " + x)
        )
        return i
    )

    static public short shortCast(float x)
    (§
        if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
        (§
            return (short) x
        )
        throw new IllegalArgumentException("Value out of range for short: " + x)
    )

    static public short shortCast(double x)
    (§
        if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
        (§
            return (short) x
        )
        throw new IllegalArgumentException("Value out of range for short: " + x)
    )

    static public int intCast(Object x)
    (§
        if (x instanceof Integer)
        (§
            return ((Integer)x).intValue()
        )
        if (x instanceof Number)
        (§
            long n = longCast(x)
            return intCast(n)
        )
        return ((Character) x).charValue()
    )

    static public int intCast(char x)
    (§
        return x
    )

    static public int intCast(byte x)
    (§
        return x
    )

    static public int intCast(short x)
    (§
        return x
    )

    static public int intCast(int x)
    (§
        return x
    )

    static public int intCast(float x)
    (§
        if (x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for int: " + x)
        )
        return (int) x
    )

    static public int intCast(long x)
    (§
        int i = (int) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for int: " + x)
        )
        return i
    )

    static public int intCast(double x)
    (§
        if (x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for int: " + x)
        )
        return (int) x
    )

    static public long longCast(Object x)
    (§
        if (x instanceof Integer || x instanceof Long)
        (§
            return ((Number) x).longValue()
        )
        else if (x instanceof BigInt)
        (§
            BigInt bi = (BigInt) x
            if (bi.bipart == null)
            (§
                return bi.lpart
            )
            else
            (§
                throw new IllegalArgumentException("Value out of range for long: " + x)
            )
        )
        else if (x instanceof BigInteger)
        (§
            BigInteger bi = (BigInteger) x
            if (bi.bitLength() < 64)
            (§
                return bi.longValue()
            )
            else
            (§
                throw new IllegalArgumentException("Value out of range for long: " + x)
            )
        )
        else if (x instanceof Byte || x instanceof Short)
        (§
            return ((Number) x).longValue()
        )
        else if (x instanceof Ratio)
        (§
            return longCast(((Ratio)x).bigIntegerValue())
        )
        else if (x instanceof Character)
        (§
            return longCast(((Character) x).charValue())
        )
        else
        (§
            return longCast(((Number)x).doubleValue())
        )
    )

    static public long longCast(byte x)
    (§
        return x
    )

    static public long longCast(short x)
    (§
        return x
    )

    static public long longCast(int x)
    (§
        return x
    )

    static public long longCast(float x)
    (§
        if (x < Long.MIN_VALUE || x > Long.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for long: " + x)
        )
        return (long) x
    )

    static public long longCast(long x)
    (§
        return x
    )

    static public long longCast(double x)
    (§
        if (x < Long.MIN_VALUE || x > Long.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for long: " + x)
        )
        return (long) x
    )

    static public float floatCast(Object x)
    (§
        if (x instanceof Float)
        (§
            return ((Float) x).floatValue()
        )
        double n = ((Number) x).doubleValue()
        if (n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for float: " + x)
        )
        return (float) n
    )

    static public float floatCast(byte x)
    (§
        return x
    )

    static public float floatCast(short x)
    (§
        return x
    )

    static public float floatCast(int x)
    (§
        return x
    )

    static public float floatCast(float x)
    (§
        return x
    )

    static public float floatCast(long x)
    (§
        return x
    )

    static public float floatCast(double x)
    (§
        if (x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for float: " + x)
        )
        return (float) x
    )

    static public double doubleCast(Object x)
    (§
        return ((Number) x).doubleValue()
    )

    static public double doubleCast(byte x)
    (§
        return x
    )

    static public double doubleCast(short x)
    (§
        return x
    )

    static public double doubleCast(int x)
    (§
        return x
    )

    static public double doubleCast(float x)
    (§
        return x
    )

    static public double doubleCast(long x)
    (§
        return x
    )

    static public double doubleCast(double x)
    (§
        return x
    )

    static public byte uncheckedByteCast(Object x)
    (§
        return ((Number) x).byteValue()
    )

    static public byte uncheckedByteCast(byte x)
    (§
        return x
    )

    static public byte uncheckedByteCast(short x)
    (§
        return (byte) x
    )

    static public byte uncheckedByteCast(int x)
    (§
        return (byte) x
    )

    static public byte uncheckedByteCast(long x)
    (§
        return (byte) x
    )

    static public byte uncheckedByteCast(float x)
    (§
        return (byte) x
    )

    static public byte uncheckedByteCast(double x)
    (§
        return (byte) x
    )

    static public short uncheckedShortCast(Object x)
    (§
        return ((Number) x).shortValue()
    )

    static public short uncheckedShortCast(byte x)
    (§
        return x
    )

    static public short uncheckedShortCast(short x)
    (§
        return x
    )

    static public short uncheckedShortCast(int x)
    (§
        return (short) x
    )

    static public short uncheckedShortCast(long x)
    (§
        return (short) x
    )

    static public short uncheckedShortCast(float x)
    (§
        return (short) x
    )

    static public short uncheckedShortCast(double x)
    (§
        return (short) x
    )

    static public char uncheckedCharCast(Object x)
    (§
        if (x instanceof Character)
        (§
            return ((Character) x).charValue()
        )
        return (char) ((Number) x).longValue()
    )

    static public char uncheckedCharCast(byte x)
    (§
        return (char) x
    )

    static public char uncheckedCharCast(short x)
    (§
        return (char) x
    )

    static public char uncheckedCharCast(char x)
    (§
        return x
    )

    static public char uncheckedCharCast(int x)
    (§
        return (char) x
    )

    static public char uncheckedCharCast(long x)
    (§
        return (char) x
    )

    static public char uncheckedCharCast(float x)
    (§
        return (char) x
    )

    static public char uncheckedCharCast(double x)
    (§
        return (char) x
    )

    static public int uncheckedIntCast(Object x)
    (§
        if (x instanceof Number)
        (§
            return ((Number)x).intValue()
        )
        return ((Character) x).charValue()
    )

    static public int uncheckedIntCast(byte x)
    (§
        return x
    )

    static public int uncheckedIntCast(short x)
    (§
        return x
    )

    static public int uncheckedIntCast(char x)
    (§
        return x
    )

    static public int uncheckedIntCast(int x)
    (§
        return x
    )

    static public int uncheckedIntCast(long x)
    (§
        return (int) x
    )

    static public int uncheckedIntCast(float x)
    (§
        return (int) x
    )

    static public int uncheckedIntCast(double x)
    (§
        return (int) x
    )

    static public long uncheckedLongCast(Object x)
    (§
        return ((Number) x).longValue()
    )

    static public long uncheckedLongCast(byte x)
    (§
        return x
    )

    static public long uncheckedLongCast(short x)
    (§
        return x
    )

    static public long uncheckedLongCast(int x)
    (§
        return x
    )

    static public long uncheckedLongCast(long x)
    (§
        return x
    )

    static public long uncheckedLongCast(float x)
    (§
        return (long) x
    )

    static public long uncheckedLongCast(double x)
    (§
        return (long) x
    )

    static public float uncheckedFloatCast(Object x)
    (§
        return ((Number) x).floatValue()
    )

    static public float uncheckedFloatCast(byte x)
    (§
        return x
    )

    static public float uncheckedFloatCast(short x)
    (§
        return x
    )

    static public float uncheckedFloatCast(int x)
    (§
        return x
    )

    static public float uncheckedFloatCast(long x)
    (§
        return x
    )

    static public float uncheckedFloatCast(float x)
    (§
        return x
    )

    static public float uncheckedFloatCast(double x)
    (§
        return (float) x
    )

    static public double uncheckedDoubleCast(Object x)
    (§
        return ((Number) x).doubleValue()
    )

    static public double uncheckedDoubleCast(byte x)
    (§
        return x
    )

    static public double uncheckedDoubleCast(short x)
    (§
        return x
    )

    static public double uncheckedDoubleCast(int x)
    (§
        return x
    )

    static public double uncheckedDoubleCast(long x)
    (§
        return x
    )

    static public double uncheckedDoubleCast(float x)
    (§
        return x
    )

    static public double uncheckedDoubleCast(double x)
    (§
        return x
    )

    static public IPersistentMap map(Object... init)
    (§
        if (init == null)
        (§
            return PersistentArrayMap.EMPTY
        )
        else if (init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
        (§
            return PersistentArrayMap.createWithCheck(init)
        )
        return PersistentHashMap.createWithCheck(init)
    )

    static public IPersistentMap mapUniqueKeys(Object... init)
    (§
        if (init == null)
        (§
            return PersistentArrayMap.EMPTY
        )
        else if (init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
        (§
            return new PersistentArrayMap(init)
        )
        return PersistentHashMap.create(init)
    )

    static public IPersistentSet set(Object... init)
    (§
        return PersistentHashSet.createWithCheck(init)
    )

    static public IPersistentVector vector(Object... init)
    (§
        return LazilyPersistentVector.createOwning(init)
    )

    static public IPersistentVector subvec(IPersistentVector v, int start, int end)
    (§
        if (end < start || start < 0 || end > v.count())
        (§
            throw new IndexOutOfBoundsException()
        )
        if (start == end)
        (§
            return PersistentVector.EMPTY
        )
        return new APersistentVector.SubVector(null, v, start, end)
    )

    static public ISeq list()
    (§
        return null
    )

    static public ISeq list(Object arg1)
    (§
        return new PersistentList(arg1)
    )

    static public ISeq list(Object arg1, Object arg2)
    (§
        return listStar(arg1, arg2, null)
    )

    static public ISeq list(Object arg1, Object arg2, Object arg3)
    (§
        return listStar(arg1, arg2, arg3, null)
    )

    static public ISeq list(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        return listStar(arg1, arg2, arg3, arg4, null)
    )

    static public ISeq list(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        return listStar(arg1, arg2, arg3, arg4, arg5, null)
    )

    static public ISeq listStar(Object arg1, ISeq rest)
    (§
        return (ISeq) cons(arg1, rest)
    )

    static public ISeq listStar(Object arg1, Object arg2, ISeq rest)
    (§
        return (ISeq) cons(arg1, cons(arg2, rest))
    )

    static public ISeq listStar(Object arg1, Object arg2, Object arg3, ISeq rest)
    (§
        return (ISeq) cons(arg1, cons(arg2, cons(arg3, rest)))
    )

    static public ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, ISeq rest)
    (§
        return (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest))))
    )

    static public ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, ISeq rest)
    (§
        return (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest)))))
    )

    static public ISeq arrayToList(Object[] a)
    (§
        ISeq ret = null
        for (int i = a.length - 1 i >= 0 --i)
        (§
            ret = (ISeq) cons(a[i], ret)
        )
        return ret
    )

    static public Object[] object_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            return new Object[((Number) sizeOrSeq).intValue()]
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            Object[] ret = new Object[size]
            for (int i = 0 i < size && s != null i++, s = s.next())
            (§
                ret[i] = s.first()
            )
            return ret
        )
    )

    static public Object[] toArray(Object coll)
    (§
        if (coll == null)
        (§
            return EMPTY_ARRAY
        )
        else if (coll instanceof Object[])
        (§
            return (Object[]) coll
        )
        else if (coll instanceof Collection)
        (§
            return ((Collection) coll).toArray()
        )
        else if (coll instanceof Iterable)
        (§
            ArrayList ret = new ArrayList()
            for (Object o :in (Iterable)coll)
            (§
                ret.add(o)
            )
            return ret.toArray()
        )
        else if (coll instanceof Map)
        (§
            return ((Map) coll).entrySet().toArray()
        )
        else if (coll instanceof String)
        (§
            char[] chars = ((String) coll).toCharArray()
            Object[] ret = new Object[chars.length]
            for (int i = 0 i < chars.length i++)
            (§
                ret[i] = chars[i]
            )
            return ret
        )
        else if (coll.getClass().isArray())
        (§
            ISeq s = (seq(coll))
            Object[] ret = new Object[count(s)]
            for (int i = 0 i < ret.length i++, s = s.next())
            (§
                ret[i] = s.first()
            )
            return ret
        )
        else
        (§
            throw Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]")
        )
    )

    static public Object[] seqToArray(ISeq seq)
    (§
        int len = length(seq)
        Object[] ret = new Object[len]
        for (int i = 0 seq != null ++i, seq = seq.next())
        (§
            ret[i] = seq.first()
        )
        return ret
    )

    ;; supports java Collection.toArray(T[])
    static public Object[] seqToPassedArray(ISeq seq, Object[] passed)
    (§
        Object[] dest = passed
        int len = count(seq)
        if (len > dest.length)
        (§
            dest = (Object[]) Array.newInstance(passed.getClass().getComponentType(), len)
        )
        for (int i = 0 seq != null ++i, seq = seq.next())
        (§
            dest[i] = seq.first()
        )
        if (len < passed.length)
        (§
            dest[len] = null
        )
        return dest
    )

    static public Object seqToTypedArray(ISeq seq)
    (§
        Class type = (seq != null && seq.first() != null) ? seq.first().getClass() :or Object.class
        return seqToTypedArray(type, seq)
    )

    static public Object seqToTypedArray(Class type, ISeq seq)
    (§
        Object ret = Array.newInstance(type, length(seq))
        if (type == Integer.TYPE)
        (§
            for (int i = 0 seq != null ++i, seq = seq.next())
            (§
                Array.set(ret, i, intCast(seq.first()))
            )
        )
        else if (type == Byte.TYPE)
        (§
            for (int i = 0 seq != null ++i, seq = seq.next())
            (§
                Array.set(ret, i, byteCast(seq.first()))
            )
        )
        else if (type == Float.TYPE)
        (§
            for (int i = 0 seq != null ++i, seq = seq.next())
            (§
                Array.set(ret, i, floatCast(seq.first()))
            )
        )
        else if (type == Short.TYPE)
        (§
            for (int i = 0 seq != null ++i, seq = seq.next())
            (§
                Array.set(ret, i, shortCast(seq.first()))
            )
        )
        else if (type == Character.TYPE)
        (§
            for (int i = 0 seq != null ++i, seq = seq.next())
            (§
                Array.set(ret, i, charCast(seq.first()))
            )
        )
        else
        (§
            for (int i = 0 seq != null ++i, seq = seq.next())
            (§
                Array.set(ret, i, seq.first())
            )
        )
        return ret
    )

    static public int length(ISeq list)
    (§
        int i = 0
        for (ISeq c = list c != null c = c.next())
        (§
            i++
        )
        return i
    )

    static public int boundedLength(ISeq list, int limit)
    (§
        int i = 0
        for (ISeq c = list c != null && i <= limit c = c.next())
        (§
            i++
        )
        return i
    )

    static Character readRet(int ret)
    (§
        if (ret == -1)
        (§
            return null
        )
        return box((char) ret)
    )

    static public Character readChar(Reader r) throws IOException
    (§
        int ret = r.read()
        return readRet(ret)
    )

    static public Character peekChar(Reader r) throws IOException
    (§
        int ret
        if (r instanceof PushbackReader)
        (§
            ret = r.read()
            ((PushbackReader) r).unread(ret)
        )
        else
        (§
            r.mark(1)
            ret = r.read()
            r.reset()
        )

        return readRet(ret)
    )

    static public int getLineNumber(Reader r)
    (§
        if (r instanceof LineNumberingPushbackReader)
        (§
            return ((LineNumberingPushbackReader) r).getLineNumber()
        )
        return 0
    )

    static public int getColumnNumber(Reader r)
    (§
        if (r instanceof LineNumberingPushbackReader)
        (§
            return ((LineNumberingPushbackReader) r).getColumnNumber()
        )
        return 0
    )

    static public LineNumberingPushbackReader getLineNumberingReader(Reader r)
    (§
        if (isLineNumberingReader(r))
        (§
            return (LineNumberingPushbackReader) r
        )
        return new LineNumberingPushbackReader(r)
    )

    static public boolean isLineNumberingReader(Reader r)
    (§
        return (r instanceof LineNumberingPushbackReader)
    )

    static public boolean isReduced(Object r)
    (§
        return (r instanceof Reduced)
    )

    static public String resolveClassNameInContext(String className)
    (§
        ;; todo - look up in context var
        return className
    )

    static public boolean suppressRead()
    (§
        return booleanCast(SUPPRESS_READ.deref())
    )

    static public String printString(Object x)
    (§
        try
        (§
            StringWriter sw = new StringWriter()
            print(x, sw)
            return sw.toString()
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    static public Object readString(String s)
    (§
        return readString(s, null)
    )

    static public Object readString(String s, Object opts)
    (§
        PushbackReader r = new PushbackReader(new StringReader(s))
        return LispReader.read(r, opts)
    )

    static public void print(Object x, Writer w) throws IOException
    (§
        ;; call multimethod
        if (PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref()))
        (§
            PR_ON.invoke(x, w)
        )
        else
        (§
            boolean readably = booleanCast(PRINT_READABLY.deref())
            if (x instanceof Obj)
            (§
                Obj o = (Obj) x
                if (RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                (§
                    IPersistentMap meta = o.meta()
                    w.write("#^")
                    if (meta.count() == 1 && meta.containsKey(TAG_KEY))
                    (§
                        print(meta.valAt(TAG_KEY), w)
                    )
                    else
                    (§
                        print(meta, w)
                    )
                    w.write((§ char \space))
                )
            )
            if (x == null)
            (§
                w.write("nil")
            )
            else if (x instanceof ISeq || x instanceof IPersistentList)
            (§
                w.write((§ char \())
                printInnerSeq(seq(x), w)
                w.write((§ char \)))
            )
            else if (x instanceof String)
            (§
                String s = (String) x
                if (!readably)
                (§
                    w.write(s)
                )
                else
                (§
                    w.write((§ char \")) ;; oops! "
                    for (int i = 0 i < s.length() i++)
                    (§
                        char c = s.charAt(i)
                        switch (c)
                        (§
                            (§ case (§ char "\n"))
                                w.write("\\n")
                                break
                            (§ case (§ char "\t"))
                                w.write("\\t")
                                break
                            (§ case (§ char "\r"))
                                w.write("\\r")
                                break
                            (§ case (§ char \"))
                                w.write("\\\"")
                                break
                            (§ case (§ char \\))
                                w.write("\\\\")
                                break
                            (§ case (§ char "\f"))
                                w.write("\\f")
                                break
                            (§ case (§ char "\b"))
                                w.write("\\b")
                                break
                            (§ default)
                                w.write(c)
                                break
                        )
                    )
                    w.write((§ char \")) ;; oops! "
                )
            )
            else if (x instanceof IPersistentMap)
            (§
                w.write((§ char \{))
                for (ISeq s = seq(x) s != null s = s.next())
                (§
                    IMapEntry e = (IMapEntry) s.first()
                    print(e.key(), w)
                    w.write((§ char \space))
                    print(e.val(), w)
                    if (s.next() != null)
                    (§
                        w.write(", ")
                    )
                )
                w.write((§ char \}))
            )
            else if (x instanceof IPersistentVector)
            (§
                IPersistentVector a = (IPersistentVector) x
                w.write((§ char \[))
                for (int i = 0 i < a.count() i++)
                (§
                    print(a.nth(i), w)
                    if (i < a.count() - 1)
                    (§
                        w.write((§ char \space))
                    )
                )
                w.write((§ char \]))
            )
            else if (x instanceof IPersistentSet)
            (§
                w.write("#{")
                for (ISeq s = seq(x) s != null s = s.next())
                (§
                    print(s.first(), w)
                    if (s.next() != null)
                    (§
                        w.write(" ")
                    )
                )
                w.write((§ char \}))
            )
            else if (x instanceof Character)
            (§
                char c = ((Character) x).charValue()
                if (!readably)
                (§
                    w.write(c)
                )
                else
                (§
                    w.write((§ char \\))
                    switch (c)
                    (§
                        (§ case (§ char "\n"))
                            w.write("newline")
                            break
                        (§ case (§ char "\t"))
                            w.write("tab")
                            break
                        (§ case (§ char \space))
                            w.write("space")
                            break
                        (§ case (§ char "\b"))
                            w.write("backspace")
                            break
                        (§ case (§ char "\f"))
                            w.write("formfeed")
                            break
                        (§ case (§ char "\r"))
                            w.write("return")
                            break
                        (§ default)
                            w.write(c)
                            break
                    )
                )
            )
            else if (x instanceof Class)
            (§
                w.write("#=")
                w.write(((Class) x).getName())
            )
            else if (x instanceof BigDecimal && readably)
            (§
                w.write(x.toString())
                w.write((§ char \M))
            )
            else if (x instanceof BigInt && readably)
            (§
                w.write(x.toString())
                w.write((§ char \N))
            )
            else if (x instanceof BigInteger && readably)
            (§
                w.write(x.toString())
                w.write("BIGINT")
            )
            else if (x instanceof Var)
            (§
                Var v = (Var) x
                w.write("#=(var " + v.ns.name + "/" + v.sym + ")")
            )
            else if (x instanceof Pattern)
            (§
                Pattern p = (Pattern) x
                w.write("#\"" + p.pattern() + "\"")
            )
            else
            (§
                w.write(x.toString())
            )
        )
    )

    private static void printInnerSeq(ISeq x, Writer w) throws IOException
    (§
        for (ISeq s = x s != null s = s.next())
        (§
            print(s.first(), w)
            if (s.next() != null)
            (§
                w.write((§ char \space))
            )
        )
    )

    static public void formatAesthetic(Writer w, Object obj) throws IOException
    (§
        if (obj == null)
        (§
            w.write("null")
        )
        else
        (§
            w.write(obj.toString())
        )
    )

    static public void formatStandard(Writer w, Object obj) throws IOException
    (§
        if (obj == null)
        (§
            w.write("null")
        )
        else if (obj instanceof String)
        (§
            w.write((§ char \")) ;; oops! "
            w.write((String) obj)
            w.write((§ char \")) ;; oops! "
        )
        else if (obj instanceof Character)
        (§
            w.write((§ char \\))
            char c = ((Character) obj).charValue()
            switch (c)
            (§
                (§ case (§ char "\n"))
                    w.write("newline")
                    break
                (§ case (§ char "\t"))
                    w.write("tab")
                    break
                (§ case (§ char \space))
                    w.write("space")
                    break
                (§ case (§ char "\b"))
                    w.write("backspace")
                    break
                (§ case (§ char "\f"))
                    w.write("formfeed")
                    break
                (§ default)
                    w.write(c)
                    break
            )
        )
        else
        (§
            w.write(obj.toString())
        )
    )

    static public Object format(Object o, String s, Object... args) throws IOException
    (§
        Writer w
        if (o == null)
        (§
            w = new StringWriter()
        )
        else if (Util.equals(o, T))
        (§
            w = (Writer) OUT.deref()
        )
        else
        (§
            w = (Writer) o
        )
        doFormat(w, s, ArraySeq.create(args))
        if (o == null)
        (§
            return w.toString()
        )
        return null
    )

    static public ISeq doFormat(Writer w, String s, ISeq args) throws IOException
    (§
        for (int i = 0 i < s.length() )
        (§
            char c = s.charAt(i++)
            switch (Character.toLowerCase(c))
            (§
                (§ case (§ char \~))
                    char d = s.charAt(i++)
                    switch (Character.toLowerCase(d))
                    (§
                        (§ case (§ char \%))
                            w.write((§ char "\n"))
                            break
                        (§ case (§ char \t))
                            w.write((§ char "\t"))
                            break
                        (§ case (§ char \a))
                            if (args == null)
                            (§
                                throw new IllegalArgumentException("Missing argument")
                            )
                            RT.formatAesthetic(w, RT.first(args))
                            args = RT.next(args)
                            break
                        (§ case (§ char \s))
                            if (args == null)
                            (§
                                throw new IllegalArgumentException("Missing argument")
                            )
                            RT.formatStandard(w, RT.first(args))
                            args = RT.next(args)
                            break
                        (§ case (§ char \{))
                            int j = s.indexOf("~}", i) ;; note - does not nest
                            if (j == -1)
                            (§
                                throw new IllegalArgumentException("Missing ~}")
                            )
                            String subs = s.substring(i, j)
                            for (ISeq sargs = RT.seq(RT.first(args)) sargs != null )
                            (§
                                sargs = doFormat(w, subs, sargs)
                            )
                            args = RT.next(args)
                            i = j + 2 ;; skip "~}"
                            break
                        (§ case (§ char \^))
                            if (args == null)
                            (§
                                return null
                            )
                            break
                        (§ case (§ char \~))
                            w.write((§ char \~))
                            break
                        (§ default)
                            throw new IllegalArgumentException("Unsupported ~ directive: " + d)
                    )
                    break
                (§ default)
                    w.write(c)
                    break
            )
        )
        return args
    )

    static public Object[] setValues(Object... vals)
    (§
        if (vals.length > 0)
        (§
            return vals
        )
        return null
    )

    static public ClassLoader makeClassLoader()
    (§
        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
        (§
            public Object run()
            (§
                try
                (§
                    Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T))
                    return new DynamicClassLoader(baseLoader())
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )
        ))
    )

    static public ClassLoader baseLoader()
    (§
        if (Compiler.LOADER.isBound())
        (§
            return (ClassLoader) Compiler.LOADER.deref()
        )
        else if (booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
        (§
            return Thread.currentThread().getContextClassLoader()
        )
        return Compiler.class.getClassLoader()
    )

    static public InputStream resourceAsStream(ClassLoader loader, String name)
    (§
        if (loader == null)
        (§
            return ClassLoader.getSystemResourceAsStream(name)
        )
        else
        (§
            return loader.getResourceAsStream(name)
        )
    )

    static public URL getResource(ClassLoader loader, String name)
    (§
        if (loader == null)
        (§
            return ClassLoader.getSystemResource(name)
        )
        else
        (§
            return loader.getResource(name)
        )
    )

    static public Class classForName(String name, boolean load, ClassLoader loader)
    (§
        try
        (§
            Class c = null
            if (!(loader instanceof DynamicClassLoader))
            (§
                c = DynamicClassLoader.findInMemoryClass(name)
            )
            if (c != null)
            (§
                return c
            )
            return Class.forName(name, load, loader)
        )
        catch (ClassNotFoundException e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    static public Class classForName(String name)
    (§
        return classForName(name, true, baseLoader())
    )

    static public Class classForNameNonLoading(String name)
    (§
        return classForName(name, false, baseLoader())
    )

    static public Class loadClassForName(String name)
    (§
        try
        (§
            classForNameNonLoading(name)
        )
        catch (Exception e)
        (§
            if (e instanceof ClassNotFoundException)
            (§
                return null
            )
            else
            (§
                throw Util.sneakyThrow(e)
            )
        )
        return classForName(name)
    )

    static public float aget(float[] xs, int i)
    (§
        return xs[i]
    )

    static public float aset(float[] xs, int i, float v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(float[] xs)
    (§
        return xs.length
    )

    static public float[] aclone(float[] xs)
    (§
        return xs.clone()
    )

    static public double aget(double[] xs, int i)
    (§
        return xs[i]
    )

    static public double aset(double[] xs, int i, double v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(double[] xs)
    (§
        return xs.length
    )

    static public double[] aclone(double[] xs)
    (§
        return xs.clone()
    )

    static public int aget(int[] xs, int i)
    (§
        return xs[i]
    )

    static public int aset(int[] xs, int i, int v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(int[] xs)
    (§
        return xs.length
    )

    static public int[] aclone(int[] xs)
    (§
        return xs.clone()
    )

    static public long aget(long[] xs, int i)
    (§
        return xs[i]
    )

    static public long aset(long[] xs, int i, long v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(long[] xs)
    (§
        return xs.length
    )

    static public long[] aclone(long[] xs)
    (§
        return xs.clone()
    )

    static public char aget(char[] xs, int i)
    (§
        return xs[i]
    )

    static public char aset(char[] xs, int i, char v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(char[] xs)
    (§
        return xs.length
    )

    static public char[] aclone(char[] xs)
    (§
        return xs.clone()
    )

    static public byte aget(byte[] xs, int i)
    (§
        return xs[i]
    )

    static public byte aset(byte[] xs, int i, byte v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(byte[] xs)
    (§
        return xs.length
    )

    static public byte[] aclone(byte[] xs)
    (§
        return xs.clone()
    )

    static public short aget(short[] xs, int i)
    (§
        return xs[i]
    )

    static public short aset(short[] xs, int i, short v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(short[] xs)
    (§
        return xs.length
    )

    static public short[] aclone(short[] xs)
    (§
        return xs.clone()
    )

    static public boolean aget(boolean[] xs, int i)
    (§
        return xs[i]
    )

    static public boolean aset(boolean[] xs, int i, boolean v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(boolean[] xs)
    (§
        return xs.length
    )

    static public boolean[] aclone(boolean[] xs)
    (§
        return xs.clone()
    )

    static public Object aget(Object[] xs, int i)
    (§
        return xs[i]
    )

    static public Object aset(Object[] xs, int i, Object v)
    (§
        xs[i] = v
        return v
    )

    static public int alength(Object[] xs)
    (§
        return xs.length
    )

    static public Object[] aclone(Object[] xs)
    (§
        return xs.clone()
    )
)
)

(§ java cloiure.lang.Seqable

public interface Seqable
(§
    ISeq seq()
)
)

(§ java cloiure.lang.SeqEnumeration

import java.util.Enumeration

public class SeqEnumeration implements Enumeration
(§
    ISeq seq

    public SeqEnumeration(ISeq seq)
    (§
        this.seq = seq
    )

    public boolean hasMoreElements()
    (§
        return (seq != null)
    )

    public Object nextElement()
    (§
        Object ret = RT.first(seq)
        seq = RT.next(seq)
        return ret
    )
)
)

(§ java cloiure.lang.SeqIterator

import java.util.Iterator
import java.util.NoSuchElementException

public class SeqIterator implements Iterator
(§
    static final Object START = new Object()

    Object seq
    Object next

    public SeqIterator(Object o)
    (§
        seq = START
        next = o
    )

    ;; preserved for binary compatibility
    public SeqIterator(ISeq o)
    (§
        seq = START
        next = o
    )

    public boolean hasNext()
    (§
        if (seq == START)
        (§
            seq = null
            next = RT.seq(next)
        )
        else if (seq == next)
        (§
            next = RT.next(seq)
        )
        return (next != null)
    )

    public Object next() throws NoSuchElementException
    (§
        if (!hasNext())
        (§
            throw new NoSuchElementException()
        )
        seq = next
        return RT.first(next)
    )

    public void remove()
    (§
        throw new UnsupportedOperationException()
    )
)
)

(§ java cloiure.lang.Sequential

public interface Sequential
(§
)
)

(§ java cloiure.lang.Settable

public interface Settable
(§
    Object doSet(Object val)
    Object doReset(Object val)
)
)

(§ java cloiure.lang.Sorted

import java.util.Comparator

public interface Sorted
(§
    Comparator comparator()

    Object entryKey(Object entry)

    ISeq seq(boolean ascending)

    ISeq seqFrom(Object key, boolean ascending)
)
)

(§ java cloiure.lang.StringSeq

public class StringSeq extends ASeq implements IndexedSeq
(§
    public final CharSequence s
    public final int i

    static public StringSeq create(CharSequence s)
    (§
        if (s.length() == 0)
        (§
            return null
        )
        return new StringSeq(null, s, 0)
    )

    StringSeq(IPersistentMap meta, CharSequence s, int i)
    (§
        super(meta)
        this.s = s
        this.i = i
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta == meta())
        (§
            return this
        )
        return new StringSeq(meta, s, i)
    )

    public Object first()
    (§
        return Character.valueOf(s.charAt(i))
    )

    public ISeq next()
    (§
        if (i + 1 < s.length())
        (§
            return new StringSeq(_meta, s, i + 1)
        )
        return null
    )

    public int index()
    (§
        return i
    )

    public int count()
    (§
        return s.length() - i
    )
)
)

(§ java cloiure.lang.Symbol

import java.io.Serializable
import java.io.ObjectStreamException

public class Symbol extends AFn implements IObj, Comparable, Named, Serializable, IHashEq
(§
    final String ns
    final String name
    private int _hasheq
    final IPersistentMap _meta
    transient String _str

    public String toString()
    (§
        if (_str == null)
        (§
            if (ns != null)
            (§
                _str = (ns + "/" + name)
            )
            else
            (§
                _str = name
            )
        )
        return _str
    )

    public String getNamespace()
    (§
        return ns
    )

    public String getName()
    (§
        return name
    )

    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    static public Symbol create(String ns, String name)
    (§
        return Symbol.intern(ns, name)
    )

    static public Symbol create(String nsname)
    (§
        return Symbol.intern(nsname)
    )

    static public Symbol intern(String ns, String name)
    (§
        return new Symbol(ns, name)
    )

    static public Symbol intern(String nsname)
    (§
        int i = nsname.indexOf((§ char \/))
        if (i == -1 || nsname.equals("/"))
        (§
            return new Symbol(null, nsname)
        )
        else
        (§
            return new Symbol(nsname.substring(0, i), nsname.substring(i + 1))
        )
    )

    private Symbol(String ns_interned, String name_interned)
    (§
        this.name = name_interned
        this.ns = ns_interned
        this._meta = null
    )

    public boolean equals(Object o)
    (§
        if (this == o)
        (§
            return true
        )
        if (!(o instanceof Symbol))
        (§
            return false
        )

        Symbol symbol = (Symbol) o

        return Util.equals(ns, symbol.ns) && name.equals(symbol.name)
    )

    public int hashCode()
    (§
        return Util.hashCombine(name.hashCode(), Util.hash(ns))
    )

    public int hasheq()
    (§
        if (_hasheq == 0)
        (§
            _hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns))
        )
        return _hasheq
    )

    public IObj withMeta(IPersistentMap meta)
    (§
        return new Symbol(meta, ns, name)
    )

    private Symbol(IPersistentMap meta, String ns, String name)
    (§
        this.name = name
        this.ns = ns
        this._meta = meta
    )

    public int compareTo(Object o)
    (§
        Symbol s = (Symbol) o
        if (this.equals(o))
        (§
            return 0
        )
        if (this.ns == null && s.ns != null)
        (§
            return -1
        )
        if (this.ns != null)
        (§
            if (s.ns == null)
            (§
                return 1
            )
            int nsc = this.ns.compareTo(s.ns)
            if (nsc != 0)
            (§
                return nsc
            )
        )
        return this.name.compareTo(s.name)
    )

    private Object readResolve() throws ObjectStreamException
    (§
        return intern(ns, name)
    )

    public Object invoke(Object obj)
    (§
        return RT.get(obj, this)
    )

    public Object invoke(Object obj, Object notFound)
    (§
        return RT.get(obj, this, notFound)
    )

    public IPersistentMap meta()
    (§
        return _meta
    )
)
)

(§ java cloiure.lang.TaggedLiteral

public class TaggedLiteral implements ILookup
(§
    public static final Keyword TAG_KW = Keyword.intern("tag")
    public static final Keyword FORM_KW = Keyword.intern("form")

    public final Symbol tag
    public final Object form

    public static TaggedLiteral create(Symbol tag, Object form)
    (§
        return new TaggedLiteral(tag, form)
    )

    private TaggedLiteral(Symbol tag, Object form)
    (§
        this.tag = tag
        this.form = form
    )

    public Object valAt(Object key)
    (§
        return valAt(key, null)
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (FORM_KW.equals(key))
        (§
            return this.form
        )
        else if (TAG_KW.equals(key))
        (§
            return this.tag
        )
        else
        (§
            return notFound
        )
    )

    @Override
    public boolean equals(Object o)
    (§
        if (this == o)
        (§
            return true
        )
        if (o == null || getClass() != o.getClass())
        (§
            return false
        )

        TaggedLiteral that = (TaggedLiteral) o

        if ((form != null) ? !form.equals(that.form) :or that.form != null)
        (§
            return false
        )
        if ((tag != null) ? !tag.equals(that.tag) :or that.tag != null)
        (§
            return false
        )

        return true
    )

    @Override
    public int hashCode()
    (§
        int result = Util.hash(tag)
        result = 31 * result + Util.hash(form)
        return result
    )
)
)

(§ java cloiure.lang.TransactionalHashMap

import java.util.concurrent.ConcurrentMap
import java.util.*

public class TransactionalHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
(§
    final Ref[] bins

    IPersistentMap mapAt(int bin)
    (§
        return (IPersistentMap) bins[bin].deref()
    )

    final int binFor(Object k)
    (§
        ;; spread hashes, a la Cliff Click
        int h = k.hashCode()
        h ^= (h >>> 20) :xor (h >>> 12)
        h ^= (h >>> 7) :xor (h >>> 4)
        return h % bins.length
    )

    Entry entryAt(Object k)
    (§
        return mapAt(binFor(k)).entryAt(k)
    )

    public TransactionalHashMap()
    (§
        this(421)
    )

    public TransactionalHashMap(int nBins)
    (§
        bins = new Ref[nBins]
        for (int i = 0 i < nBins i++)
        (§
            bins[i] = new Ref(PersistentHashMap.EMPTY)
        )
    )

    public TransactionalHashMap(Map<? extends K, ? extends V> m)
    (§
        this(m.size())
        putAll(m)
    )

    public int size()
    (§
        int n = 0
        for (int i = 0 i < bins.length i++)
        (§
            n += mapAt(i).count()
        )
        return n
    )

    public boolean isEmpty()
    (§
        return (size() == 0)
    )

    public boolean containsKey(Object k)
    (§
        return (entryAt(k) != null)
    )

    public V get(Object k)
    (§
        Entry e = entryAt(k)
        if (e != null)
        (§
            return (V) e.getValue()
        )
        return null
    )

    public V put(K k, V v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Object ret = map.valAt(k)
        r.set(map.assoc(k, v))
        return (V) ret
    )

    public V remove(Object k)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Object ret = map.valAt(k)
        r.set(map.without(k))
        return (V) ret
    )

    public void putAll(Map<? extends K, ? extends V> map)
    (§
        for (Iterator i = map.entrySet().iterator() i.hasNext() )
        (§
            Entry<K, V> e = (Entry) i.next()
            put(e.getKey(), e.getValue())
        )
    )

    public void clear()
    (§
        for (int i = 0 i < bins.length i++)
        (§
            Ref r = bins[i]
            IPersistentMap map = (IPersistentMap) r.deref()
            if (map.count() > 0)
            (§
                r.set(PersistentHashMap.EMPTY)
            )
        )
    )

    public Set<Entry<K, V>> entrySet()
    (§
        final ArrayList<Map.Entry<K, V>> entries = new ArrayList(bins.length)
        for (int i = 0 i < bins.length i++)
        (§
            IPersistentMap map = mapAt(i)
            if (map.count() > 0)
            (§
                entries.addAll((Collection) RT.seq(map))
            )
        )
        return new AbstractSet<Entry<K, V>>()
        (§
            public Iterator iterator()
            (§
                return Collections.unmodifiableList(entries).iterator()
            )

            public int size()
            (§
                return entries.size()
            )
        )
    )

    public V putIfAbsent(K k, V v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e == null)
        (§
            r.set(map.assoc(k, v))
            return null
        )
        else
        (§
            return (V) e.getValue()
        )
    )

    public boolean remove(Object k, Object v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e != null && e.getValue().equals(v))
        (§
            r.set(map.without(k))
            return true
        )
        return false
    )

    public boolean replace(K k, V oldv, V newv)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e != null && e.getValue().equals(oldv))
        (§
            r.set(map.assoc(k, newv))
            return true
        )
        return false
    )

    public V replace(K k, V v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e != null)
        (§
            r.set(map.assoc(k, v))
            return (V) e.getValue()
        )
        return null
    )
)
)

(§ java cloiure.lang.TransformerIterator

import java.util.Iterator
import java.util.List
import java.util.NoSuchElementException
import java.util.Queue
import java.util.LinkedList

public class TransformerIterator implements Iterator
(§
    private static final Buffer EMPTY = new Empty()
    private static final Object NONE = new Object()

    ;; Source
    private final Iterator sourceIter
    private final IFn xf
    private final boolean multi

    ;; Iteration state
    private volatile Buffer buffer = EMPTY
    private volatile Object next = NONE
    private volatile boolean completed = false

    private TransformerIterator(IFn xform, Iterator sourceIter, boolean multi)
    (§
        this.sourceIter = sourceIter
        this.xf = (IFn) xform.invoke(new AFn()
        (§
            public Object invoke()
            (§
                return null
            )

            public Object invoke(Object acc)
            (§
                return acc
            )

            public Object invoke(Object acc, Object o)
            (§
                buffer = buffer.add(o)
                return acc
            )
        ))
        this.multi = multi
    )

    public static Iterator create(IFn xform, Iterator source)
    (§
        return new TransformerIterator(xform, source, false)
    )

    public static Iterator createMulti(IFn xform, List sources)
    (§
        Iterator[] iters = new Iterator[sources.size()]
        for (int i = 0 i < sources.size() i++)
        (§
            iters[i] = (Iterator)sources.get(i)
        )
        return new TransformerIterator(xform, new MultiIterator(iters), true)
    )

    private boolean step()
    (§
        if (next != NONE)
        (§
            return true
        )

        while (next == NONE)
        (§
            if (buffer.isEmpty())
            (§
                if (completed)
                (§
                    return false
                )
                else if (sourceIter.hasNext())
                (§
                    Object iter = null
                    if (multi)
                    (§
                        iter = xf.applyTo(RT.cons(null, sourceIter.next()))
                    )
                    else
                    (§
                        iter = xf.invoke(null, sourceIter.next())
                    )

                    if (RT.isReduced(iter))
                    (§
                        xf.invoke(null)
                        completed = true
                    )
                )
                else
                (§
                    xf.invoke(null)
                    completed = true
                )
            )
            else
            (§
                next = buffer.remove()
            )
        )
        return true
    )

    public boolean hasNext()
    (§
        return step()
    )

    public Object next()
    (§
        if (hasNext())
        (§
            Object ret = next
            next = NONE
            return ret
        )
        throw new NoSuchElementException()
    )

    public void remove()
    (§
        throw new UnsupportedOperationException()
    )

    private static interface Buffer
    (§
        Buffer add(Object o)
        Object remove()
        boolean isEmpty()
    )

    private static class Empty implements Buffer
    (§
        public Buffer add(Object o)
        (§
            return new Single(o)
        )

        public Object remove()
        (§
            throw new IllegalStateException("Removing object from empty buffer")
        )

        public boolean isEmpty()
        (§
            return true
        )

        public String toString()
        (§
            return "Empty"
        )
    )

    private static class Single implements Buffer
    (§
        private volatile Object val

        public Single(Object o)
        (§
            this.val = o
        )

        public Buffer add(Object o)
        (§
            if (val == NONE)
            (§
                val = o
                return this
            )
            else
            (§
                return new Many(val, o)
            )
        )

        public Object remove()
        (§
            if (val == NONE)
            (§
                throw new IllegalStateException("Removing object from empty buffer")
            )
            Object ret = val
            val = NONE
            return ret
        )

        public boolean isEmpty()
        (§
            return (val == NONE)
        )

        public String toString()
        (§
            return "Single: " + val
        )
    )

    private static class Many implements Buffer
    (§
        private final Queue vals = new LinkedList()

        public Many(Object o1, Object o2)
        (§
            vals.add(o1)
            vals.add(o2)
        )

        public Buffer add(Object o)
        (§
            vals.add(o)
            return this
        )

        public Object remove()
        (§
            return vals.remove()
        )

        public boolean isEmpty()
        (§
            return vals.isEmpty()
        )

        public String toString()
        (§
            return "Many: " + vals.toString()
        )
    )

    private static class MultiIterator implements Iterator
    (§
        private final Iterator[] iters

        public MultiIterator(Iterator[] iters)
        (§
            this.iters = iters
        )

        public boolean hasNext()
        (§
            for (Iterator iter :in iters)
            (§
                if (!iter.hasNext())
                (§
                    return false
                )
            )
            return true
        )

        public Object next()
        (§
            Object[] nexts = new Object[iters.length]
            for (int i = 0 i < iters.length i++)
            (§
                nexts[i] = iters[i].next()
            )
            return new ArraySeq(nexts, 0)
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(§ java cloiure.lang.Tuple

import java.util.Collection
import java.util.RandomAccess

public class Tuple
(§
    static final int MAX_SIZE = 6

    public static IPersistentVector create()
    (§
        return PersistentVector.EMPTY
    )

    public static IPersistentVector create(Object v0)
    (§
        return RT.vector(v0)
    )

    public static IPersistentVector create(Object v0, Object v1)
    (§
        return RT.vector(v0, v1)
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2)
    (§
        return RT.vector(v0, v1, v2)
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2, Object v3)
    (§
        return RT.vector(v0, v1, v2, v3)
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4)
    (§
        return RT.vector(v0, v1, v2, v3, v4)
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4, Object v5)
    (§
        return RT.vector(v0, v1, v2, v3, v4, v5)
    )
)
)

(§ java cloiure.lang.Util

import java.io.IOException
import java.lang.ref.Reference
import java.math.BigInteger
import java.util.Collection
import java.util.Map
import java.util.concurrent.ConcurrentHashMap
import java.lang.ref.ReferenceQueue

public class Util
(§
    static public boolean equiv(Object k1, Object k2)
    (§
        if (k1 == k2)
        (§
            return true
        )
        if (k1 != null)
        (§
            if (k1 instanceof Number && k2 instanceof Number)
            (§
                return Numbers.equal((Number)k1, (Number)k2)
            )
            else if (k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
            (§
                return pcequiv(k1, k2)
            )
            return k1.equals(k2)
        )
        return false
    )

    public interface EquivPred
    (§
        boolean equiv(Object k1, Object k2)
    )

    static EquivPred equivNull = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            return (k2 == null)
        )
    )

    static EquivPred equivEquals = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            return k1.equals(k2)
        )
    )

    static EquivPred equivNumber = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            if (k2 instanceof Number)
            (§
                return Numbers.equal((Number) k1, (Number) k2)
            )
            return false
        )
    )

    static EquivPred equivColl = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            if (k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
            (§
                return pcequiv(k1, k2)
            )
            return k1.equals(k2)
        )
    )

    static public EquivPred equivPred(Object k1)
    (§
        if (k1 == null)
        (§
            return equivNull
        )
        else if (k1 instanceof Number)
        (§
            return equivNumber
        )
        else if (k1 instanceof String || k1 instanceof Symbol)
        (§
            return equivEquals
        )
        else if (k1 instanceof Collection || k1 instanceof Map)
        (§
            return equivColl
        )
        return equivEquals
    )

    static public boolean equiv(long k1, long k2)
    (§
        return (k1 == k2)
    )

    static public boolean equiv(Object k1, long k2)
    (§
        return equiv(k1, (Object)k2)
    )

    static public boolean equiv(long k1, Object k2)
    (§
        return equiv((Object)k1, k2)
    )

    static public boolean equiv(double k1, double k2)
    (§
        return (k1 == k2)
    )

    static public boolean equiv(Object k1, double k2)
    (§
        return equiv(k1, (Object)k2)
    )

    static public boolean equiv(double k1, Object k2)
    (§
        return equiv((Object)k1, k2)
    )

    static public boolean equiv(boolean k1, boolean k2)
    (§
        return (k1 == k2)
    )

    static public boolean equiv(Object k1, boolean k2)
    (§
        return equiv(k1, (Object)k2)
    )

    static public boolean equiv(boolean k1, Object k2)
    (§
        return equiv((Object)k1, k2)
    )

    static public boolean equiv(char c1, char c2)
    (§
        return (c1 == c2)
    )

    static public boolean pcequiv(Object k1, Object k2)
    (§
        if (k1 instanceof IPersistentCollection)
        (§
            return ((IPersistentCollection)k1).equiv(k2)
        )
        return ((IPersistentCollection)k2).equiv(k1)
    )

    static public boolean equals(Object k1, Object k2)
    (§
        if (k1 == k2)
        (§
            return true
        )
        return (k1 != null && k1.equals(k2))
    )

    static public boolean identical(Object k1, Object k2)
    (§
        return (k1 == k2)
    )

    static public Class classOf(Object x)
    (§
        if (x != null)
        (§
            return x.getClass()
        )
        return null
    )

    static public int compare(Object k1, Object k2)
    (§
        if (k1 == k2)
        (§
            return 0
        )
        if (k1 != null)
        (§
            if (k2 == null)
            (§
                return 1
            )
            if (k1 instanceof Number)
            (§
                return Numbers.compare((Number) k1, (Number) k2)
            )
            return ((Comparable) k1).compareTo(k2)
        )
        return -1
    )

    static public int hash(Object o)
    (§
        if (o == null)
        (§
            return 0
        )
        return o.hashCode()
    )

    public static int hasheq(Object o)
    (§
        if (o == null)
        (§
            return 0
        )
        if (o instanceof IHashEq)
        (§
            return dohasheq((IHashEq) o)
        )
        if (o instanceof Number)
        (§
            return Numbers.hasheq((Number)o)
        )
        if (o instanceof String)
        (§
            return Murmur3.hashInt(o.hashCode())
        )
        return o.hashCode()
    )

    private static int dohasheq(IHashEq o)
    (§
        return o.hasheq()
    )

    static public int hashCombine(int seed, int hash)
    (§
        ;; a la boost
        seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2)
        return seed
    )

    static public boolean isPrimitive(Class c)
    (§
        return (c != null && c.isPrimitive() && !(c == Void.TYPE))
    )

    static public boolean isInteger(Object x)
    (§
        return (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger)
    )

    static public Object ret1(Object ret, Object nil)
    (§
        return ret
    )

    static public ISeq ret1(ISeq ret, Object nil)
    (§
        return ret
    )

    static public <K, V> void clearCache(ReferenceQueue rq, ConcurrentHashMap<K, Reference<V>> cache)
    (§
        ;; cleanup any dead entries
        if (rq.poll() != null)
        (§
            while (rq.poll() != null)
            (§
            )
            for (Map.Entry<K, Reference<V>> e :in cache.entrySet())
            (§
                Reference<V> val = e.getValue()
                if (val != null && val.get() == null)
                (§
                    cache.remove(e.getKey(), val)
                )
            )
        )
    )

    static public RuntimeException runtimeException(String s)
    (§
        return new RuntimeException(s)
    )

    static public RuntimeException runtimeException(String s, Throwable e)
    (§
        return new RuntimeException(s, e)
    )

    ;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     
     ; <code>throw sneakyThrow(some exception);</code>
     ;
    static public RuntimeException sneakyThrow(Throwable t)
    (§
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        if (t == null)
        (§
            throw new NullPointerException()
        )
        Util.<RuntimeException>sneakyThrow0(t)
        return null
    )

    @SuppressWarnings("unchecked")
    static private <T extends Throwable> void sneakyThrow0(Throwable t) throws T
    (§
        throw (T) t
    )

    static public Object loadWithClass(String scriptbase, Class<?> loadFrom) throws IOException, ClassNotFoundException
    (§
        Var.pushThreadBindings(RT.map(new Object[] (§ Compiler.LOADER, loadFrom.getClassLoader() )))
        try
        (§
            return RT.var("cloiure.core", "load").invoke(scriptbase)
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )
)
)

(§ java cloiure.lang.Var

import java.io.ObjectStreamException
import java.io.Serializable
import java.util.concurrent.atomic.AtomicBoolean

public final class Var extends ARef implements IFn, IRef, Settable, Serializable
(§
    static class TBox
    (§
        volatile Object val
        final Thread thread

        public TBox(Thread t, Object val)
        (§
            this.thread = t
            this.val = val
        )
    )

    static public class Unbound extends AFn
    (§
        final public Var v

        public Unbound(Var v)
        (§
            this.v = v
        )

        public String toString()
        (§
            return "Unbound: " + v
        )

        public Object throwArity(int n)
        (§
            throw new IllegalStateException("Attempting to call unbound fn: " + v)
        )
    )

    static class Frame
    (§
        final static Frame TOP = new Frame(PersistentHashMap.EMPTY, null)
        ;; Var->TBox
        Associative bindings
        ;; Var->val
        Frame prev

        public Frame(Associative bindings, Frame prev)
        (§
            this.bindings = bindings
            this.prev = prev
        )

        protected Object clone()
        (§
            return new Frame(this.bindings, null)
        )
    )

    static final ThreadLocal<Frame> dvals = new ThreadLocal<Frame>()
    (§
        protected Frame initialValue()
        (§
            return Frame.TOP
        )
    )

    static public volatile int rev = 0

    static Keyword privateKey = Keyword.intern(null, "private")
    static IPersistentMap privateMeta = new PersistentArrayMap(new Object[] (§ privateKey, Boolean.TRUE ))
    static Keyword macroKey = Keyword.intern(null, "macro")
    static Keyword nameKey = Keyword.intern(null, "name")
    static Keyword nsKey = Keyword.intern(null, "ns")

    volatile Object root

    volatile boolean dynamic = false
    transient final AtomicBoolean threadBound
    public final Symbol sym
    public final Namespace ns

    public static Object getThreadBindingFrame()
    (§
        return dvals.get()
    )

    public static Object cloneThreadBindingFrame()
    (§
        return dvals.get().clone()
    )

    public static void resetThreadBindingFrame(Object frame)
    (§
        dvals.set((Frame) frame)
    )

    public Var setDynamic()
    (§
        this.dynamic = true
        return this
    )

    public Var setDynamic(boolean b)
    (§
        this.dynamic = b
        return this
    )

    public final boolean isDynamic()
    (§
        return dynamic
    )

    public static Var intern(Namespace ns, Symbol sym, Object root)
    (§
        return intern(ns, sym, root, true)
    )

    public static Var intern(Namespace ns, Symbol sym, Object root, boolean replaceRoot)
    (§
        Var dvout = ns.intern(sym)
        if (!dvout.hasRoot() || replaceRoot)
        (§
            dvout.bindRoot(root)
        )
        return dvout
    )

    public String toString()
    (§
        if (ns != null)
        (§
            return "#'" + ns.name + "/" + sym
        )
        return "#<Var: " + ((sym != null) ? sym.toString() :or "--unnamed--") + ">"
    )

    public static Var find(Symbol nsQualifiedSym)
    (§
        if (nsQualifiedSym.ns == null)
        (§
            throw new IllegalArgumentException("Symbol must be namespace-qualified")
        )
        Namespace ns = Namespace.find(Symbol.intern(nsQualifiedSym.ns))
        if (ns == null)
        (§
            throw new IllegalArgumentException("No such namespace: " + nsQualifiedSym.ns)
        )
        return ns.findInternedVar(Symbol.intern(nsQualifiedSym.name))
    )

    public static Var intern(Symbol nsName, Symbol sym)
    (§
        Namespace ns = Namespace.findOrCreate(nsName)
        return intern(ns, sym)
    )

    public static Var internPrivate(String nsName, String sym)
    (§
        Namespace ns = Namespace.findOrCreate(Symbol.intern(nsName))
        Var ret = intern(ns, Symbol.intern(sym))
        ret.setMeta(privateMeta)
        return ret
    )

    public static Var intern(Namespace ns, Symbol sym)
    (§
        return ns.intern(sym)
    )

    public static Var create()
    (§
        return new Var(null, null)
    )

    public static Var create(Object root)
    (§
        return new Var(null, null, root)
    )

    Var(Namespace ns, Symbol sym)
    (§
        this.ns = ns
        this.sym = sym
        this.threadBound = new AtomicBoolean(false)
        this.root = new Unbound(this)
        setMeta(PersistentHashMap.EMPTY)
    )

    Var(Namespace ns, Symbol sym, Object root)
    (§
        this(ns, sym)
        this.root = root
        ++rev
    )

    public boolean isBound()
    (§
        return (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this)))
    )

    final public Object get()
    (§
        if (!threadBound.get())
        (§
            return root
        )
        return deref()
    )

    final public Object deref()
    (§
        TBox b = getThreadBinding()
        if (b != null)
        (§
            return b.val
        )
        return root
    )

    public void setValidator(IFn vf)
    (§
        if (hasRoot())
        (§
            validate(vf, root)
        )
        validator = vf
    )

    public Object alter(IFn fn, ISeq args)
    (§
        set(fn.applyTo(RT.cons(deref(), args)))
        return this
    )

    public Object set(Object val)
    (§
        validate(getValidator(), val)
        TBox b = getThreadBinding()
        if (b != null)
        (§
            if (Thread.currentThread() != b.thread)
            (§
                throw new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym))
            )
            return (b.val = val)
        )
        throw new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym))
    )

    public Object doSet(Object val)
    (§
        return set(val)
    )

    public Object doReset(Object val)
    (§
        bindRoot(val)
        return val
    )

    public void setMeta(IPersistentMap m)
    (§
        ;; ensure these basis keys
        resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns))
    )

    public void setMacro()
    (§
        alterMeta(assoc, RT.list(macroKey, RT.T))
    )

    public boolean isMacro()
    (§
        return RT.booleanCast(meta().valAt(macroKey))
    )

    public boolean isPublic()
    (§
        return !RT.booleanCast(meta().valAt(privateKey))
    )

    final public Object getRawRoot()
    (§
        return root
    )

    public Object getTag()
    (§
        return meta().valAt(RT.TAG_KEY)
    )

    public void setTag(Symbol tag)
    (§
        alterMeta(assoc, RT.list(RT.TAG_KEY, tag))
    )

    final public boolean hasRoot()
    (§
        return !(root instanceof Unbound)
    )

    ;; binding root always clears macro flag
    synchronized public void bindRoot(Object root)
    (§
        validate(getValidator(), root)
        Object oldroot = this.root
        this.root = root
        ++rev
        alterMeta(dissoc, RT.list(macroKey))
        notifyWatches(oldroot, this.root)
    )

    synchronized void swapRoot(Object root)
    (§
        validate(getValidator(), root)
        Object oldroot = this.root
        this.root = root
        ++rev
        notifyWatches(oldroot, root)
    )

    synchronized public void unbindRoot()
    (§
        this.root = new Unbound(this)
        ++rev
    )

    synchronized public void commuteRoot(IFn fn)
    (§
        Object newRoot = fn.invoke(root)
        validate(getValidator(), newRoot)
        Object oldroot = root
        this.root = newRoot
        ++rev
        notifyWatches(oldroot, newRoot)
    )

    synchronized public Object alterRoot(IFn fn, ISeq args)
    (§
        Object newRoot = fn.applyTo(RT.cons(root, args))
        validate(getValidator(), newRoot)
        Object oldroot = root
        this.root = newRoot
        ++rev
        notifyWatches(oldroot, newRoot)
        return newRoot
    )

    public static void pushThreadBindings(Associative bindings)
    (§
        Frame f = dvals.get()
        Associative bmap = f.bindings
        for (ISeq bs = bindings.seq() bs != null bs = bs.next())
        (§
            IMapEntry e = (IMapEntry) bs.first()
            Var v = (Var) e.key()
            if (!v.dynamic)
            (§
                throw new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym))
            )
            v.validate(v.getValidator(), e.val())
            v.threadBound.set(true)
            bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val()))
        )
        dvals.set(new Frame(bmap, f))
    )

    public static void popThreadBindings()
    (§
        Frame f = dvals.get().prev
        if (f == null)
        (§
            throw new IllegalStateException("Pop without matching push")
        )
        else if (f == Frame.TOP)
        (§
            dvals.remove()
        )
        else
        (§
            dvals.set(f)
        )
    )

    public static Associative getThreadBindings()
    (§
        Frame f = dvals.get()
        IPersistentMap ret = PersistentHashMap.EMPTY
        for (ISeq bs = f.bindings.seq() bs != null bs = bs.next())
        (§
            IMapEntry e = (IMapEntry) bs.first()
            Var v = (Var) e.key()
            TBox b = (TBox) e.val()
            ret = ret.assoc(v, b.val)
        )
        return ret
    )

    public final TBox getThreadBinding()
    (§
        if (threadBound.get())
        (§
            IMapEntry e = dvals.get().bindings.entryAt(this)
            if (e != null)
            (§
                return (TBox) e.val()
            )
        )
        return null
    )

    final public IFn fn()
    (§
        return (IFn) deref()
    )

    public Object call()
    (§
        return invoke()
    )

    public void run()
    (§
        invoke()
    )

    public Object invoke()
    (§
        return fn().invoke()
    )

    public Object invoke(Object arg1)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null),
                Util.ret1(arg16, arg16 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null),
                Util.ret1(arg16, arg16 = null),
                Util.ret1(arg17, arg17 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null),
                Util.ret1(arg16, arg16 = null),
                Util.ret1(arg17, arg17 = null),
                Util.ret1(arg18, arg18 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null),
                Util.ret1(arg16, arg16 = null),
                Util.ret1(arg17, arg17 = null),
                Util.ret1(arg18, arg18 = null),
                Util.ret1(arg19, arg19 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null),
                Util.ret1(arg16, arg16 = null),
                Util.ret1(arg17, arg17 = null),
                Util.ret1(arg18, arg18 = null),
                Util.ret1(arg19, arg19 = null),
                Util.ret1(arg20, arg20 = null))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        return fn().invoke(Util.ret1(arg1, arg1 = null),
                Util.ret1(arg2, arg2 = null),
                Util.ret1(arg3, arg3 = null),
                Util.ret1(arg4, arg4 = null),
                Util.ret1(arg5, arg5 = null),
                Util.ret1(arg6, arg6 = null),
                Util.ret1(arg7, arg7 = null),
                Util.ret1(arg8, arg8 = null),
                Util.ret1(arg9, arg9 = null),
                Util.ret1(arg10, arg10 = null),
                Util.ret1(arg11, arg11 = null),
                Util.ret1(arg12, arg12 = null),
                Util.ret1(arg13, arg13 = null),
                Util.ret1(arg14, arg14 = null),
                Util.ret1(arg15, arg15 = null),
                Util.ret1(arg16, arg16 = null),
                Util.ret1(arg17, arg17 = null),
                Util.ret1(arg18, arg18 = null),
                Util.ret1(arg19, arg19 = null),
                Util.ret1(arg20, arg20 = null),
                (Object[])Util.ret1(args, args = null))
    )

    public Object applyTo(ISeq arglist)
    (§
        return fn().applyTo(arglist)
    )

    static IFn assoc = new AFn()
    (§
        @Override
        public Object invoke(Object m, Object k, Object v)
        (§
            return RT.assoc(m, k, v)
        )
    )

    static IFn dissoc = new AFn()
    (§
        @Override
        public Object invoke(Object c, Object k)
        (§
            return RT.dissoc(c, k)
        )
    )

    ;; Note - serialization only supports reconnecting the Var identity on the deserializing end
    ;; Neither the value in the var nor any of its properties are serialized

    private static class Serialized implements Serializable
    (§
        public Serialized(Symbol nsName, Symbol sym)
        (§
            this.nsName = nsName
            this.sym = sym
        )

        private Symbol nsName
        private Symbol sym

        private Object readResolve() throws ObjectStreamException
        (§
            return intern(nsName, sym)
        )
    )

    private Object writeReplace() throws ObjectStreamException
    (§
        return new Serialized(ns.getName(), sym)
    )
)
)

(§ java cloiure.lang.Volatile

final public class Volatile implements IDeref
(§
    volatile Object val

    public Volatile(Object val)
    (§
        this.val = val
    )

    public Object deref()
    (§
        return val
    )

    public Object reset(Object newval)
    (§
        return this.val = newval
    )
)
)

(§ java cloiure.lang.WarnBoxedMath

import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.ElementType
import java.lang.annotation.Target

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface WarnBoxedMath
(§
    boolean value() default true
)
)

(§ java cloiure.main

import cloiure.lang.Symbol
import cloiure.lang.Var
import cloiure.lang.RT

public class main
(§
    final static private Symbol CLOIURE_MAIN = Symbol.intern("cloiure.main")
    final static private Var REQUIRE = RT.var("cloiure.core", "require")
    final static private Var MAIN = RT.var("cloiure.main", "main")

    public static void main(String[] args)
    (§
        REQUIRE.invoke(CLOIURE_MAIN)
        MAIN.applyTo(RT.seq(args))
    )
)
)
