(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_method
    (§ defn #_"Object" call [#_"AFn" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"AFn" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this]
        (ß throwArity(0))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1]
        (ß throwArity(1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2]
        (ß throwArity(2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß throwArity(3))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß throwArity(4))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß throwArity(5))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß throwArity(6))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß throwArity(7))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß throwArity(8))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß throwArity(9))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß throwArity(10))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß throwArity(11))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß throwArity(12))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß throwArity(13))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß throwArity(14))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß throwArity(15))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß throwArity(16))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß throwArity(17))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß throwArity(18))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß throwArity(19))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß throwArity(20))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß throwArity(21))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"AFn" this, #_"ISeq" arglist]
        (ß applyToHelper(this, Util.ret1(arglist, (§ ass arglist nil))))
    )

    (§ defn #_"Object" applyToHelper [#_"IFn" ifn, #_"ISeq" arglist]
        (§ switch (ß RT.boundedLength(arglist, 20))
            (§ case 0)
            (do
                (§ ass arglist nil)
                (ß ifn.invoke())
            )
            (§ case 1)
            (do
                (ß ifn.invoke(Util.ret1(arglist.first(), (§ ass arglist nil))))
            )
            (§ case 2)
            (do
                (ß ifn.invoke(arglist.first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 3)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 4)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 5)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 6)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 7)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 8)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 9)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 10)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 11)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 12)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 13)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 14)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 15)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 16)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 17)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 18)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 19)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ case 20)
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        Util.ret1((§ ass arglist (ß arglist.next())).first(), (§ ass arglist nil))))
            )
            (§ default )
            (do
                (ß ifn.invoke(arglist.first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        (§ ass arglist (ß arglist.next())).first(),
                        RT.seqToArray(Util.ret1(arglist.next(), (§ ass arglist nil)))))
            )
        )
    )

    #_method
    (§ defn #_"Object" throwArity [#_"AFn" this, #_"int" n]
        (let [#_"String" name (ß getClass().getSimpleName())]
            (throw (ß new ArityException(n, Compiler.demunge(name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (§ init
        #_volatile
        (§ field #_"MethodImplCache" __methodImplCache nil)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"AFunction" this]
        nil
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"AFunction" this, #_"IPersistentMap" meta]
        (§ reify RestFn()
            #_protected
            #_method
            (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" args]
                (ß AFunction.this.applyTo((ISeq) args))
            )

            #_method
            (§ defn #_"IPersistentMap" meta [#_"RestFn" this]
                meta
            )

            #_method
            (§ defn #_"IObj" withMeta [#_"RestFn" this, #_"IPersistentMap" meta]
                (ß AFunction.this.withMeta(meta))
            )

            #_method
            (§ defn #_"int" getRequiredArity [#_"RestFn" this]
                0
            )
        )
    )

    #_method
    (§ defn #_"int" compare [#_"AFunction" this, #_"Object" o1, #_"Object" o2]
        (let [#_"Object" o (ß invoke(o1, o2))]
            (when (ß o instanceof Boolean)
                (when (ß RT.booleanCast(o))
                    (§ return -1)
                )
                (§ return (ß RT.booleanCast(invoke(o2, o1)) ? 1 :or 0))
            )

            (let [#_"Number" n (ß (Number) o)]
                (ß n.intValue())
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Agent (§ extends ARef)
    (class-ns ActionQueue
        (§ def #_"ActionQueue" EMPTY (ß new ActionQueue(PersistentQueue.EMPTY, nil)))

        (§ init
            (§ field #_"IPersistentStack" q nil)
            (§ field #_"Throwable" error nil) ;; non-null indicates fail state
        )

        (§ constructor #_"ActionQueue" ActionQueue [#_"IPersistentStack" q, #_"Throwable" error]
            (let [this (ß super())]
                (§ ass (ß this.q) q)
                (§ ass (ß this.error) error)
                this
            )
        )
    )

    (class-ns Action (§ implements Runnable)
        (§ init
            (§ field #_"Agent" agent nil)
            (§ field #_"IFn" fn nil)
            (§ field #_"ISeq" args nil)
            (§ field #_"Executor" exec nil)
        )

        (§ constructor #_"Action" Action [#_"Agent" agent, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
            (let [this (ß super())]
                (§ ass (ß this.agent) agent)
                (§ ass (ß this.args) args)
                (§ ass (ß this.fn) fn)
                (§ ass (ß this.exec) exec)
                this
            )
        )

        #_method
        (§ defn #_"void" execute [#_"Action" this]
            (try
                (ß exec.execute(this))
                (catch Throwable error
                    (when (ß agent.errorHandler != nil)
                        (try
                            (ß agent.errorHandler.invoke(agent, error))
                            (catch Throwable e
                                ;; ignore errorHandler errors
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn #_"void" doRun [#_"Action" action]
            (try
                (ß nested.set(PersistentVector.EMPTY))

                (let [#_"Throwable" error nil]
                    (try
                        (let [#_"Object" oldval (ß action.agent.state)]
                            (let [#_"Object" newval (ß action.fn.applyTo(RT.cons(action.agent.state, action.args)))]
                                (ß action.agent.setState(newval))
                                (ß action.agent.notifyWatches(oldval, newval))
                            )
                        )
                        (catch Throwable e
                            (§ ass error e)
                        )
                    )

                    (if (nil? error)
                        (do
                            (ß releasePendingSends())
                        )
                        (do
                            (ß nested.set(nil)) ;; allow errorHandler to send
                            (when (ß action.agent.errorHandler != nil)
                                (try
                                    (ß action.agent.errorHandler.invoke(action.agent, error))
                                    (catch Throwable e
                                        ;; ignore errorHandler errors
                                    )
                                )
                            )
                            (when (ß action.agent.errorMode == CONTINUE)
                                (§ ass error nil)
                            )
                        )
                    )

                    (let [#_"boolean" popped false]
                        (let [#_"ActionQueue" next nil]
                            (while (ß !popped)
                                (let [#_"ActionQueue" prior (ß action.agent.aq.get())]
                                    (§ ass next (ß new ActionQueue(prior.q.pop(), error)))
                                    (§ ass popped (ß action.agent.aq.compareAndSet(prior, next)))
                                )
                            )

                            (when (ß error == nil && next.q.count() > 0)
                                (ß ((Action) next.q.peek()).execute())
                            )
                        )
                    )
                )
                (finally
                    (ß nested.set(nil))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" run [#_"Action" this]
            (ß doRun(this))
            nil
        )
    )

    (§ def #_"Keyword" CONTINUE (ß Keyword.intern(nil, "continue")))
    (§ def #_"Keyword" FAIL (ß Keyword.intern(nil, "fail")))

    (§ def- #_"AtomicLong" sendThreadPoolCounter (AtomicLong. 0))
    (§ def- #_"AtomicLong" sendOffThreadPoolCounter (AtomicLong. 0))

    (§ defn- #_"ThreadFactory" createThreadFactory [#_"String" format, #_"AtomicLong" threadPoolCounter]
        (§ reify ThreadFactory()
            #_method
            (§ defn #_"Thread" newThread [#_"ThreadFactory" this, #_"Runnable" runnable]
                (let [#_"Thread" thread (Thread. runnable)]
                    (ß thread.setName(String.format(format, threadPoolCounter.getAndIncrement())))
                    thread
                )
            )
        )
    )

    #_volatile
    (§ def #_"ExecutorService" pooledExecutor (ß Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))))

    #_volatile
    (§ def #_"ExecutorService" soloExecutor (ß Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))))

    (§ def #_"ThreadLocal<IPersistentVector>" nested (ß new ThreadLocal<IPersistentVector>()))

    (§ defn #_"void" shutdown []
        (ß soloExecutor.shutdown())
        (ß pooledExecutor.shutdown())
        nil
    )

    (§ init
        #_volatile
        (§ field #_"Object" state nil)
        (§ field #_"AtomicReference<ActionQueue>" aq (ß new AtomicReference<ActionQueue>(ActionQueue.EMPTY)))

        #_volatile
        (§ field #_"Keyword" errorMode CONTINUE)
        #_volatile
        (§ field #_"IFn" errorHandler nil)
    )

    (§ constructor #_"Agent" Agent [#_"Object" state]
        (let [this (ß this(state, nil))]
            this
        )
    )

    (§ constructor #_"Agent" Agent [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (ß super(meta))]
            (ß setState(state))
            this
        )
    )

    #_method
    (§ defn #_"boolean" setState [#_"Agent" this, #_"Object" newState]
        (ß validate(newState))
        (let [#_"boolean" ret (ß (state != newState))]
            (§ ass state newState)
            ret
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Agent" this]
        state
    )

    #_method
    (§ defn #_"Throwable" getError [#_"Agent" this]
        (ß aq.get().error)
    )

    #_method
    (§ defn #_"void" setErrorMode [#_"Agent" this, #_"Keyword" k]
        (§ ass errorMode k)
        nil
    )

    #_method
    (§ defn #_"Keyword" getErrorMode [#_"Agent" this]
        errorMode
    )

    #_method
    (§ defn #_"void" setErrorHandler [#_"Agent" this, #_"IFn" f]
        (§ ass errorHandler f)
        nil
    )

    #_method
    (§ defn #_"IFn" getErrorHandler [#_"Agent" this]
        errorHandler
    )

    #_method
    (§ defn #_"Object" restart [#_"Agent" this, #_"Object" newState, #_"boolean" clearActions]
        (§ sync this
            (when (ß getError() == nil)
                (throw (ß Util.runtimeException("Agent does not need a restart")))
            )
            (ß validate(newState))
            (§ ass state newState)

            (if clearActions
                (do
                    (ß aq.set(ActionQueue.EMPTY))
                )
                (do
                    (let [#_"boolean" restarted false]
                        (let [#_"ActionQueue" prior nil]
                            (while (ß !restarted)
                                (§ ass prior (ß aq.get()))
                                (§ ass restarted (ß aq.compareAndSet(prior, new ActionQueue(prior.q, nil))))
                            )

                            (when (ß prior.q.count() > 0)
                                (ß ((Action) prior.q.peek()).execute())
                            )
                        )
                    )
                )
            )

            newState
        )
    )

    #_method
    (§ defn #_"Object" dispatch [#_"Agent" this, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let [#_"Throwable" error (ß getError())]
            (when (some? error)
                (throw (ß Util.runtimeException("Agent is failed, needs restart", error)))
            )
            (let [#_"Action" action (ß new Action(this, fn, args, exec))]
                (ß dispatchAction(action))

                this
            )
        )
    )

    (§ defn #_"void" dispatchAction [#_"Action" action]
        (let [#_"LockingTransaction" trans (ß LockingTransaction.getRunning())]
            (cond (some? trans)
                (do
                    (ß trans.enqueue(action))
                )
                (ß nested.get() != nil)
                (do
                    (ß nested.set(nested.get().cons(action)))
                )
                :else
                (do
                    (ß action.agent.enqueue(action))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" enqueue [#_"Agent" this, #_"Action" action]
        (let [#_"boolean" queued false]
            (let [#_"ActionQueue" prior nil]
                (while (ß !queued)
                    (§ ass prior (ß aq.get()))
                    (§ ass queued (ß aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error))))
                )

                (when (ß prior.q.count() == 0 && prior.error == nil)
                    (ß action.execute())
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" getQueueCount [#_"Agent" this]
        (ß aq.get().q.count())
    )

    (§ defn #_"int" releasePendingSends []
        (let [#_"IPersistentVector" sends (ß nested.get())]
            (when (nil? sends)
                (§ return 0)
            )
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < sends.count()) [(§ ass i (ß i + 1))]
                (let [#_"Action" a (ß (Action) sends.valAt(i))]
                    (ß a.agent.enqueue(a))
                )
            )
            (ß nested.set(PersistentVector.EMPTY))
            (ß sends.count())
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_method
    (§ defn #_"Object" nth [#_"AMapEntry" this, #_"int" i]
        (cond (ß i == 0)
            (do
                (ß key())
            )
            (ß i == 1)
            (do
                (ß val())
            )
            :else
            (do
                (throw (IndexOutOfBoundsException.))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" asVector [#_"AMapEntry" this]
        (ß LazilyPersistentVector.createOwning(key(), val()))
    )

    #_method
    (§ defn #_"IPersistentVector" assocN [#_"AMapEntry" this, #_"int" i, #_"Object" val]
        (ß asVector().assocN(i, val))
    )

    #_method
    (§ defn #_"int" count [#_"AMapEntry" this]
        2
    )

    #_method
    (§ defn #_"ISeq" seq [#_"AMapEntry" this]
        (ß asVector().seq())
    )

    #_method
    (§ defn #_"IPersistentVector" cons [#_"AMapEntry" this, #_"Object" o]
        (ß asVector().cons(o))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"AMapEntry" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" pop [#_"AMapEntry" this]
        (ß LazilyPersistentVector.createOwning(key()))
    )

    #_method
    (§ defn #_"Object" setValue [#_"AMapEntry" this, #_"Object" value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (§ init
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentMap" this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"IPersistentCollection" cons [#_"APersistentMap" this, #_"Object" o]
        (cond (ß o instanceof Map.Entry)
            (do
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                    (§ return (ß assoc(e.getKey(), e.getValue())))
                )
            )
            (ß o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
                    (when (ß v.count() != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß assoc(v.nth(0), v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ret this]
            (loop-when-recur [(§ var #_"ISeq" es (ß RT.seq(o)))] (some? es) [(§ ass es (ß es.next()))]
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) es.first()))]
                    (§ ass ret (ß ret.assoc(e.getKey(), e.getValue())))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentMap" this, #_"Object" obj]
        (ß mapEquals(this, obj))
    )

    (§ defn #_"boolean" mapEquals [#_"IPersistentMap" m1, #_"Object" obj]
        (when (ß m1 == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Map))
            (§ return false)
        )
        (let [#_"Map" m (ß (Map) obj)]
            (when (ß m.size() != m1.count())
                (§ return false)
            )

            (loop-when-recur [(§ var #_"ISeq" s (ß m1.seq()))] (some? s) [(§ ass s (ß s.next()))]
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) s.first()))]
                    (let [#_"boolean" found (ß m.containsKey(e.getKey()))]
                        (when (ß !found || !Util.equals(e.getValue(), m.get(e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentMap" this, #_"Object" obj]
        (when (ß !(obj instanceof Map))
            (§ return false)
        )
        (when (ß obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
            (§ return false)
        )

        (let [#_"Map" m (ß (Map) obj)]
            (when (ß m.size() != size())
                (§ return false)
            )

            (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) s.first()))]
                    (let [#_"boolean" found (ß m.containsKey(e.getKey()))]
                        (when (ß !found || !Util.equiv(e.getValue(), m.get(e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentMap" this]
        (let [#_"int" cached (ß this._hash)]
            (when (ß cached == 0)
                (§ ass (ß this._hash) (§ ass cached (ß mapHash(this))))
            )
            cached
        )
    )

    (§ defn #_"int" mapHash [#_"IPersistentMap" m]
        (let [#_"int" hash 0]
            (loop-when-recur [(§ var #_"ISeq" s (ß m.seq()))] (some? s) [(§ ass s (ß s.next()))]
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) s.first()))]
                    (§ ass hash (ß hash + (((e.getKey() == nil) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == nil) ? 0 :or e.getValue().hashCode()))))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentMap" this]
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (§ ass (ß this._hasheq) (§ ass cached (ß Murmur3.hashUnordered(this))))
            )
            cached
        )
    )

    (§ defn #_"int" mapHasheq [#_"IPersistentMap" m]
        (ß Murmur3.hashUnordered(m))
    )

    (class-ns KeySeq (§ extends ASeq)
        (§ defn #_"KeySeq" create [#_"ISeq" seq]
            (when (nil? seq)
                (§ return nil)
            )
            (ß new KeySeq(seq, nil))
        )

        (§ defn #_"KeySeq" createFromMap [#_"IPersistentMap" map]
            (when (nil? map)
                (§ return nil)
            )
            (let [#_"ISeq" seq (ß map.seq())]
                (when (nil? seq)
                    (§ return nil)
                )
                (ß new KeySeq(seq, map))
            )
        )

        (§ init
            (§ field #_"ISeq" seq nil)
            (§ field #_"Iterable" iterable nil)
        )

        (§ constructor- #_"KeySeq" KeySeq [#_"ISeq" seq, #_"Iterable" iterable]
            (let [this (ß super())]
                (§ ass (ß this.seq) seq)
                (§ ass (ß this.iterable) iterable)
                this
            )
        )

        (§ constructor- #_"KeySeq" KeySeq [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
            (let [this (ß super(meta))]
                (§ ass (ß this.seq) seq)
                (§ ass (ß this.iterable) iterable)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"KeySeq" this]
            (ß ((Map.Entry) seq.first()).getKey())
        )

        #_method
        (§ defn #_"ISeq" next [#_"KeySeq" this]
            (ß create(seq.next()))
        )

        #_method
        (§ defn #_"KeySeq" withMeta [#_"KeySeq" this, #_"IPersistentMap" meta]
            (ß new KeySeq(meta, seq, iterable))
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"KeySeq" this]
            (when (nil? iterable)
                (§ return (ß super.iterator()))
            )

            (when (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).keyIterator()))
            )

            (let [#_"Iterator" mapIter (ß iterable.iterator())]
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        (ß mapIter.hasNext())
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (ß ((Map.Entry)mapIter.next()).getKey())
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )

    (class-ns ValSeq (§ extends ASeq)
        (§ defn #_"ValSeq" create [#_"ISeq" seq]
            (when (nil? seq)
                (§ return nil)
            )
            (ß new ValSeq(seq, nil))
        )

        (§ defn #_"ValSeq" createFromMap [#_"IPersistentMap" map]
            (when (nil? map)
                (§ return nil)
            )
            (let [#_"ISeq" seq (ß map.seq())]
                (when (nil? seq)
                    (§ return nil)
                )
                (ß new ValSeq(seq, map))
            )
        )

        (§ init
            (§ field #_"ISeq" seq nil)
            (§ field #_"Iterable" iterable nil)
        )

        (§ constructor- #_"ValSeq" ValSeq [#_"ISeq" seq, #_"Iterable" iterable]
            (let [this (ß super())]
                (§ ass (ß this.seq) seq)
                (§ ass (ß this.iterable) iterable)
                this
            )
        )

        (§ constructor- #_"ValSeq" ValSeq [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
            (let [this (ß super(meta))]
                (§ ass (ß this.seq) seq)
                (§ ass (ß this.iterable) iterable)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ValSeq" this]
            (ß ((Map.Entry) seq.first()).getValue())
        )

        #_method
        (§ defn #_"ISeq" next [#_"ValSeq" this]
            (ß create(seq.next()))
        )

        #_method
        (§ defn #_"ValSeq" withMeta [#_"ValSeq" this, #_"IPersistentMap" meta]
            (ß new ValSeq(meta, seq, iterable))
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"ValSeq" this]
            (when (nil? iterable)
                (§ return (ß super.iterator()))
            )

            (when (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).valIterator()))
            )

            (let [#_"Iterator" mapIter (ß iterable.iterator())]
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        (ß mapIter.hasNext())
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (ß ((Map.Entry)mapIter.next()).getValue())
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )

    (§ def #_"IFn" MAKE_ENTRY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" key, #_"Object" val]
                (ß MapEntry.create(key, val))
            )
        )
    )

    (§ def #_"IFn" MAKE_KEY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" key, #_"Object" val]
                key
            )
        )
    )

    (§ def #_"IFn" MAKE_VAL
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" key, #_"Object" val]
                val
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentMap" this, #_"Object" arg1]
        (ß valAt(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentMap" this, #_"Object" arg1, #_"Object" notFound]
        (ß valAt(arg1, notFound))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsValue [#_"APersistentMap" this, #_"Object" value]
        (ß values().contains(value))
    )

    #_method
    (§ defn #_"Set" entrySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (ß APersistentMap.this.iterator())
            )

            #_method
            (§ defn #_"int" size [#_"AbstractSet" this]
                (ß count())
            )

            #_method
            (§ defn #_"int" hashCode [#_"AbstractSet" this]
                (ß APersistentMap.this.hashCode())
            )

            #_method
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" o]
                (when (ß o instanceof Entry)
                    (let [#_"Entry" e (ß (Entry) o)]
                        (let [#_"Entry" found (ß entryAt(e.getKey()))]
                            (when (ß found != nil && Util.equals(found.getValue(), e.getValue()))
                                (§ return true)
                            )
                        )
                    )
                )
                false
            )
        )
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentMap" this, #_"Object" key]
        (ß valAt(key))
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentMap" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Set" keySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (let [#_"Iterator" mi (ß APersistentMap.this.iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (ß mi.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Entry" e (ß (Entry) mi.next())]
                                (ß e.getKey())
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" size [#_"AbstractSet" this]
                (ß count())
            )

            #_method
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" o]
                (ß APersistentMap.this.containsKey(o))
            )
        )
    )

    #_method
    (§ defn #_"Object" put [#_"APersistentMap" this, #_"Object" key, #_"Object" value]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" putAll [#_"APersistentMap" this, #_"Map" t]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"APersistentMap" this, #_"Object" key]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentMap" this]
        (ß count())
    )

    #_method
    (§ defn #_"Collection" values [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractCollection" this]
                (let [#_"Iterator" mi (ß APersistentMap.this.iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (ß mi.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Entry" e (ß (Entry) mi.next())]
                                (ß e.getValue())
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" size [#_"AbstractCollection" this]
                (ß count())
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (§ init
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
        (§ field #_"IPersistentMap" impl nil)
    )

    #_protected
    (§ constructor #_"APersistentSet" APersistentSet [#_"IPersistentMap" impl]
        (let [this (ß super())]
            (§ ass (ß this.impl) impl)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentSet" this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"boolean" contains [#_"APersistentSet" this, #_"Object" key]
        (ß impl.containsKey(key))
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentSet" this, #_"Object" key]
        (ß impl.valAt(key))
    )

    #_method
    (§ defn #_"int" count [#_"APersistentSet" this]
        (ß impl.count())
    )

    #_method
    (§ defn #_"ISeq" seq [#_"APersistentSet" this]
        (ß RT.keys(impl))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentSet" this, #_"Object" arg1]
        (ß get(arg1))
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentSet" this, #_"Object" obj]
        (ß setEquals(this, obj))
    )

    (§ defn #_"boolean" setEquals [#_"IPersistentSet" s1, #_"Object" obj]
        (when (ß s1 == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Set))
            (§ return false)
        )
        (let [#_"Set" m (ß (Set) obj)]
            (when (ß m.size() != s1.count())
                (§ return false)
            )

            (doseq [#_"Object" aM m]
                (when (ß !s1.contains(aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentSet" this, #_"Object" obj]
        (when (ß !(obj instanceof Set))
            (§ return false)
        )

        (let [#_"Set" m (ß (Set) obj)]
            (when (ß m.size() != size())
                (§ return false)
            )

            (doseq [#_"Object" aM m]
                (when (ß !contains(aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentSet" this]
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
                    (let [#_"Object" e (ß s.first())]
                        (§ ass hash (ß hash + Util.hash(e)))
                    )
                )
                (§ ass (ß this._hash) hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentSet" this]
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (§ ass (ß this._hasheq) (§ ass cached (ß Murmur3.hashUnordered(this))))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"APersistentSet" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"APersistentSet" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"APersistentSet" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentSet" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentSet" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"APersistentSet" this]
        (if (ß impl instanceof IMapIterable)
            (do
                (ß ((IMapIterable)impl).keyIterator())
            )
            (do
                (§ reify Iterator()
                    (§ init
                        (§ field- #_"Iterator" iter (ß impl.iterator()))
                    )

                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        (ß iter.hasNext())
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (ß ((IMapEntry)iter.next()).key())
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (§ init
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentVector" this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"ISeq" seq [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß new APersistentVector'Seq(this, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß new RSeq(this, count() - 1)))
        )
        nil
    )

    (§ defn #_"boolean" doEquals [#_"IPersistentVector" v, #_"Object" obj]
        (cond (ß obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ov (ß (IPersistentVector) obj)]
                    (when (ß ov.count() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < v.count()) [(§ ass i (ß i + 1))]
                        (when (ß !Util.equals(v.nth(i), ov.nth(i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß obj instanceof List)
            (do
                (let [#_"Collection" ma (ß (Collection) obj)]
                    (when (ß ma.size() != v.count() || ma.hashCode() != v.hashCode())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"Iterator" i1 (ß ((List) v).iterator()), i2 (ß ma.iterator()))] (ß i1.hasNext()) [(ß )]
                        (when (ß !Util.equals(i1.next(), i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ms (ß RT.seq(obj))]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < v.count()) [(§ ass i (ß i + 1), ms (ß ms.next()))]
                        (when (ß ms == nil || !Util.equals(v.nth(i), ms.first()))
                            (§ return false)
                        )
                    )
                    (when (some? ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (§ defn #_"boolean" doEquiv [#_"IPersistentVector" v, #_"Object" obj]
        (cond (ß obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ov (ß (IPersistentVector) obj)]
                    (when (ß ov.count() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < v.count()) [(§ ass i (ß i + 1))]
                        (when (ß !Util.equiv(v.nth(i), ov.nth(i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß obj instanceof List)
            (do
                (let [#_"Collection" ma (ß (Collection) obj)]
                    (when (ß ma.size() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"Iterator" i1 (ß ((List) v).iterator()), i2 (ß ma.iterator()))] (ß i1.hasNext()) [(ß )]
                        (when (ß !Util.equiv(i1.next(), i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ms (ß RT.seq(obj))]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < v.count()) [(§ ass i (ß i + 1), ms (ß ms.next()))]
                        (when (ß ms == nil || !Util.equiv(v.nth(i), ms.first()))
                            (§ return false)
                        )
                    )
                    (when (some? ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentVector" this, #_"Object" obj]
        (when (ß obj == this)
            (§ return true)
        )
        (ß doEquals(this, obj))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentVector" this, #_"Object" obj]
        (when (ß obj == this)
            (§ return true)
        )
        (ß doEquiv(this, obj))
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentVector" this]
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (§ ass hash 1)
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < count()) [(§ ass i (ß i + 1))]
                    (let [#_"Object" obj (ß nth(i))]
                        (§ ass hash (ß 31 * hash + ((obj == nil) ? 0 :or obj.hashCode())))
                    )
                )
                (§ ass (ß this._hash) hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentVector" this]
        (let [#_"int" hash (ß this._hasheq)]
            (when (ß hash == 0)
                (§ let [#_"int" n]
                    (§ ass hash 1)

                    (loop-when-recur [(§ ass n 0)] (ß n < count()) [(§ ass n (ß n + 1))]
                        (§ ass hash (ß 31 * hash + Util.hasheq(nth(n))))
                    )

                    (§ ass (ß this._hasheq) (§ ass hash (ß Murmur3.mixCollHash(hash, n))))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentVector" this, #_"int" index]
        (ß nth(index))
    )

    #_method
    (§ defn #_"Object" nth [#_"APersistentVector" this, #_"int" i, #_"Object" notFound]
        (when (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    #_method
    (§ defn #_"Object" remove [#_"APersistentVector" this, #_"int" i]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"APersistentVector" this, #_"Object" o]
        (loop-when-recur [(§ var #_"int" i 0)] (ß i < count()) [(§ ass i (ß i + 1))]
            (when (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"APersistentVector" this, #_"Object" o]
        (loop-when-recur [(§ var #_"int" i (ß count() - 1))] (ß i >= 0) [(§ ass i (ß i - 1))]
            (when (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this]
        (ß listIterator(0))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this, #_"int" index]
        (§ reify ListIterator()
            (let [#_"int" nexti index]
                #_method
                (§ defn #_"boolean" hasNext [#_"ListIterator" this]
                    (ß (nexti < count()))
                )

                #_method
                (§ defn #_"Object" next [#_"ListIterator" this]
                    (if (ß nexti < count())
                        (let [_ (ß nth(nexti))]
                            (§ ass nexti (ß nexti + 1))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"boolean" hasPrevious [#_"ListIterator" this]
                    (ß (nexti > 0))
                )

                #_method
                (§ defn #_"Object" previous [#_"ListIterator" this]
                    (if (ß nexti > 0)
                        (do
                            (§ ass nexti (ß nexti - 1))
                            (ß nth(nexti))
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"int" nextIndex [#_"ListIterator" this]
                    nexti
                )

                #_method
                (§ defn #_"int" previousIndex [#_"ListIterator" this]
                    (ß nexti - 1)
                )

                #_method
                (§ defn #_"void" remove [#_"ListIterator" this]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" set [#_"ListIterator" this, #_"Object" o]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" add [#_"ListIterator" this, #_"Object" o]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" rangedIterator [#_"APersistentVector" this, #_"int" start, #_"int" end]
        (§ reify Iterator()
            (let [#_"int" i start]
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß (i < end))
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (if (ß i < end)
                        (let [_ (ß nth(i))]
                            (§ ass i (ß i + 1))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"List" subList [#_"APersistentVector" this, #_"int" fromIndex, #_"int" toIndex]
        (ß (List) RT.subvec(this, fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"APersistentVector" this, #_"int" i, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" add [#_"APersistentVector" this, #_"int" i, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"int" i, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentVector" this, #_"Object" arg1]
        (when (ß Util.isInteger(arg1))
            (§ return (ß nth(((Number) arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (let [#_"int" i 0]
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß (i < count()))
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (if (ß i < count())
                        (let [_ (ß nth(i))]
                            (§ ass i (ß i + 1))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" peek [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß nth(count() - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"APersistentVector" this, #_"Object" key]
        (when (ß !(Util.isInteger(key)))
            (§ return false)
        )
        (let [#_"int" i (ß ((Number) key).intValue())]
            (ß (i >= 0 && i < count()))
        )
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"APersistentVector" this, #_"Object" key]
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (when (ß i >= 0 && i < count())
                    (§ return (ß (IMapEntry) MapEntry.create(key, nth(i))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentVector" assoc [#_"APersistentVector" this, #_"Object" key, #_"Object" val]
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (§ return (ß assocN(i, val)))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" valAt [#_"APersistentVector" this, #_"Object" key, #_"Object" notFound]
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (when (ß i >= 0 && i < count())
                    (§ return (ß nth(i)))
                )
            )
        )
        notFound
    )

    #_method
    (§ defn #_"Object" valAt [#_"APersistentVector" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this]
        (let [#_"Object[]" ret (ß new Object[count()])]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < count()) [(§ ass i (ß i + 1))]
                (§ ass (ß ret[i]) (ß nth(i)))
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" add [#_"APersistentVector" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"APersistentVector" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"APersistentVector" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentVector" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentVector" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [#_"APersistentVector" this, #_"Object" o]
        (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"int" length [#_"APersistentVector" this]
        (ß count())
    )

    #_method
    (§ defn #_"int" compareTo [#_"APersistentVector" this, #_"Object" o]
        (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
            (cond (ß count() < v.count())
                (do
                    (§ return -1)
                )
                (ß count() > v.count())
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < count()) [(§ ass i (ß i + 1))]
                (let [#_"int" c (ß Util.compare(nth(i), v.nth(i)))]
                    (when (ß c != 0)
                        (§ return c)
                    )
                )
            )
            0
        )
    )

    (class-ns APersistentVector'Seq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            ;; todo - something more efficient
            (§ field #_"IPersistentVector" v nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"APersistentVector'Seq" APersistentVector'Seq [#_"IPersistentVector" v, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.v) v)
                (§ ass (ß this.i) i)
                this
            )
        )

        (§ constructor #_"APersistentVector'Seq" APersistentVector'Seq [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.v) v)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"APersistentVector'Seq" this]
            (ß v.nth(i))
        )

        #_method
        (§ defn #_"ISeq" next [#_"APersistentVector'Seq" this]
            (when (ß i + 1 < v.count())
                (§ return (ß new APersistentVector'Seq(v, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" index [#_"APersistentVector'Seq" this]
            i
        )

        #_method
        (§ defn #_"int" count [#_"APersistentVector'Seq" this]
            (ß v.count() - i)
        )

        #_method
        (§ defn #_"APersistentVector'Seq" withMeta [#_"APersistentVector'Seq" this, #_"IPersistentMap" meta]
            (ß new APersistentVector'Seq(meta, v, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"APersistentVector'Seq" this, #_"IFn" f]
            (let [#_"Object" ret (ß v.nth(i))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < v.count()) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, v.nth(x))))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"APersistentVector'Seq" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, v.nth(i)))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < v.count()) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, v.nth(x))))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )
    )

    (class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
        (§ init
            (§ field #_"IPersistentVector" v nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"RSeq" RSeq [#_"IPersistentVector" vector, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.v) vector)
                (§ ass (ß this.i) i)
                this
            )
        )

        (§ constructor #_"RSeq" RSeq [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.v) v)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"RSeq" this]
            (ß v.nth(i))
        )

        #_method
        (§ defn #_"ISeq" next [#_"RSeq" this]
            (when (ß i > 0)
                (§ return (ß new APersistentVector.RSeq(v, i - 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" index [#_"RSeq" this]
            i
        )

        #_method
        (§ defn #_"int" count [#_"RSeq" this]
            (ß i + 1)
        )

        #_method
        (§ defn #_"APersistentVector.RSeq" withMeta [#_"RSeq" this, #_"IPersistentMap" meta]
            (ß new APersistentVector.RSeq(meta, v, i))
        )
    )

    (class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
        (§ init
            (§ field #_"IPersistentVector" v nil)
            (§ field #_"int" start 0)
            (§ field #_"int" end 0)
            (§ field #_"IPersistentMap" _meta nil)
        )

        (§ constructor #_"SubVector" SubVector [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" start, #_"int" end]
            (let [this (ß super())]
                (§ ass (ß this._meta) meta)

                (when (ß v instanceof APersistentVector.SubVector)
                    (let [(§ var #_"APersistentVector.SubVector" sv (ß (APersistentVector.SubVector) v))]
                        (§ ass start (ß start + sv.start))
                        (§ ass end (ß end + sv.start))
                        (§ ass v (ß sv.v))
                    )
                )
                (§ ass (ß this.v) v)
                (§ ass (ß this.start) start)
                (§ ass (ß this.end) end)
                this
            )
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"SubVector" this]
            (when (ß v instanceof APersistentVector)
                (§ return (ß ((APersistentVector)v).rangedIterator(start, end)))
            )
            (ß super.iterator())
        )

        #_method
        (§ defn #_"Object" nth [#_"SubVector" this, #_"int" i]
            (when (ß (start + i >= end) || (i < 0))
                (throw (IndexOutOfBoundsException.))
            )
            (ß v.nth(start + i))
        )

        #_method
        (§ defn #_"IPersistentVector" assocN [#_"SubVector" this, #_"int" i, #_"Object" val]
            (cond (ß start + i > end)
                (do
                    (throw (IndexOutOfBoundsException.))
                )
                (ß start + i == end)
                (do
                    (§ return (ß cons(val)))
                )
            )
            (ß new SubVector(_meta, v.assocN(start + i, val), start, end))
        )

        #_method
        (§ defn #_"int" count [#_"SubVector" this]
            (ß end - start)
        )

        #_method
        (§ defn #_"IPersistentVector" cons [#_"SubVector" this, #_"Object" o]
            (ß new SubVector(_meta, v.assocN(end, o), start, end + 1))
        )

        #_method
        (§ defn #_"IPersistentCollection" empty [#_"SubVector" this]
            (ß PersistentVector.EMPTY.withMeta(meta()))
        )

        #_method
        (§ defn #_"IPersistentStack" pop [#_"SubVector" this]
            (when (ß end - 1 == start)
                (§ return (ß PersistentVector.EMPTY))
            )
            (ß new SubVector(_meta, v, start, end - 1))
        )

        #_method
        (§ defn #_"SubVector" withMeta [#_"SubVector" this, #_"IPersistentMap" meta]
            (when (ß meta == _meta)
                (§ return this)
            )
            (ß new SubVector(meta, v, start, end))
        )

        #_method
        (§ defn #_"IPersistentMap" meta [#_"SubVector" this]
            (ß _meta)
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (§ init
        #_protected
        #_volatile
        (§ field #_"IFn" validator nil)
        #_volatile
        (§ field- #_"IPersistentMap" watches (ß PersistentHashMap.EMPTY))
    )

    (§ constructor #_"ARef" ARef []
        (let [this (ß super())]
            this
        )
    )

    (§ constructor #_"ARef" ARef [#_"IPersistentMap" meta]
        (let [this (ß super(meta))]
            this
        )
    )

    #_method
    (§ defn #_"void" validate [#_"ARef" this, #_"IFn" vf, #_"Object" val]
        (try
            (when (ß vf != nil && !RT.booleanCast(vf.invoke(val)))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException re
                (throw re)
            )
            (catch Exception e
                (throw (ß new IllegalStateException("Invalid reference state", e)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" validate [#_"ARef" this, #_"Object" val]
        (ß validate(validator, val))
        nil
    )

    #_method
    (§ defn #_"void" setValidator [#_"ARef" this, #_"IFn" vf]
        (ß validate(vf, deref()))
        (§ ass validator vf)
        nil
    )

    #_method
    (§ defn #_"IFn" getValidator [#_"ARef" this]
        validator
    )

    #_method
    (§ defn #_"IPersistentMap" getWatches [#_"ARef" this]
        watches
    )

    #_method
    (§ defn #_"IRef" addWatch [#_"ARef" this, #_"Object" key, #_"IFn" callback]
        (§ sync this
            (§ ass watches (ß watches.assoc(key, callback)))
            this
        )
    )

    #_method
    (§ defn #_"IRef" removeWatch [#_"ARef" this, #_"Object" key]
        (§ sync this
            (§ ass watches (ß watches.without(key)))
            this
        )
    )

    #_method
    (§ defn #_"void" notifyWatches [#_"ARef" this, #_"Object" oldval, #_"Object" newval]
        (let [#_"IPersistentMap" ws watches]
            (when (ß ws.count() > 0)
                (loop-when-recur [(§ var #_"ISeq" s (ß ws.seq()))] (some? s) [(§ ass s (ß s.next()))]
                    (let [(§ var #_"Map.Entry" e (ß (Map.Entry) s.first()))]
                        (let [#_"IFn" fn (ß (IFn) e.getValue())]
                            (when (some? fn)
                                (ß fn.invoke(e.getKey(), this, oldval, newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (§ init
        (§ field- #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"AReference" AReference []
        (let [this (ß this(nil))]
            this
        )
    )

    (§ constructor #_"AReference" AReference [#_"IPersistentMap" meta]
        (let [this (ß super())]
            (§ ass _meta meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"AReference" this]
        (§ sync this
            (ß _meta)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" alterMeta [#_"AReference" this, #_"IFn" alter, #_"ISeq" args]
        (§ sync this
            (§ ass _meta (ß (IPersistentMap) alter.applyTo(new Cons(_meta, args))))
            (ß _meta)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" resetMeta [#_"AReference" this, #_"IPersistentMap" m]
        (§ sync this
            (§ ass _meta m)
            m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (§ init
        (§ field #_"int" actual 0)
        (§ field #_"String" name nil)
    )

    (§ constructor #_"ArityException" ArityException [#_"int" actual, #_"String" name]
        (let [this (ß this(actual, name, nil))]
            this
        )
    )

    (§ constructor #_"ArityException" ArityException [#_"int" actual, #_"String" name, #_"Throwable" cause]
        (let [this (ß super("Wrong number of args (" + actual + ") passed to: " + name, cause))]
            (§ ass (ß this.actual) actual)
            (§ ass (ß this.name) name)
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" off 0)
        (§ field #_"int" end 0)
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" array]
        (let [this (ß this(array, 0, array.length))]
            this
        )
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" array, #_"int" off]
        (let [this (ß this(array, off, array.length))]
            this
        )
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" array, #_"int" off, #_"int" end]
        (let [this (ß super())]
            (§ ass (ß this.array) array)
            (§ ass (ß this.off) off)
            (§ ass (ß this.end) end)
            this
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"ArrayChunk" this, #_"int" i]
        (ß array[off + i])
    )

    #_method
    (§ defn #_"Object" nth [#_"ArrayChunk" this, #_"int" i, #_"Object" notFound]
        (when (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    #_method
    (§ defn #_"int" count [#_"ArrayChunk" this]
        (ß end - off)
    )

    #_method
    (§ defn #_"IChunk" dropFirst [#_"ArrayChunk" this]
        (when (ß off == end)
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß new ArrayChunk(array, off + 1, end))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArrayChunk" this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret (ß f.invoke(start, array[off]))]
            (when (ß RT.isReduced(ret))
                (§ return ret)
            )
            (loop-when-recur [(§ var #_"int" x (ß off + 1))] (ß x < end) [(§ ass x (ß x + 1))]
                (§ ass ret (ß f.invoke(ret, array[x])))
                (when (ß RT.isReduced(ret))
                    (§ return ret)
                )
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter (§ implements Iterator)
    (§ def #_"Iterator" EMPTY_ITERATOR
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (ß new java.util.NoSuchElementException()))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (ß new UnsupportedOperationException("remove() not supported")))
            )
        )
    )

    (§ defn #_"Iterator" create []
        EMPTY_ITERATOR
    )

    (§ defn #_"Iterator" create [#_"Object..." array]
        (when (ß array == nil || array.length == 0)
            (§ return EMPTY_ITERATOR)
        )
        (ß new ArrayIter(array, 0))
    )

    (§ defn #_"Iterator" createFromObject [#_"Object" array]
        (when (ß array == nil || Array.getLength(array) == 0)
            (§ return EMPTY_ITERATOR)
        )
        (let [#_"Class" aclass (ß array.getClass())]
            (when (ß aclass == int[].class)
                (§ return (ß new ArrayIter_int((int[]) array, 0)))
            )
            (when (ß aclass == float[].class)
                (§ return (ß new ArrayIter_float((float[]) array, 0)))
            )
            (when (ß aclass == double[].class)
                (§ return (ß new ArrayIter_double((double[]) array, 0)))
            )
            (when (ß aclass == long[].class)
                (§ return (ß new ArrayIter_long((long[]) array, 0)))
            )
            (when (ß aclass == byte[].class)
                (§ return (ß new ArrayIter_byte((byte[]) array, 0)))
            )
            (when (ß aclass == char[].class)
                (§ return (ß new ArrayIter_char((char[]) array, 0)))
            )
            (when (ß aclass == short[].class)
                (§ return (ß new ArrayIter_short((short[]) array, 0)))
            )
            (when (ß aclass == boolean[].class)
                (§ return (ß new ArrayIter_boolean((boolean[]) array, 0)))
            )
            (ß new ArrayIter(array, 0))
        )
    )

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter" ArrayIter [#_"Object" array, #_"int" i]
        (let [this (ß super())]
            (§ ass (ß this.i) i)
            (§ ass (ß this.array) (ß (Object[]) array))
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Object" next [#_"ArrayIter" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß array[i])]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )

    (class-ns ArrayIter_int (§ implements Iterator<Long>)
        (§ init
            (§ field #_"int[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_int" ArrayIter_int [#_"int[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_int" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Long" next [#_"ArrayIter_int" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß Long.valueOf(array[i]))]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_int" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_float (§ implements Iterator<Double>)
        (§ init
            (§ field #_"float[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_float" ArrayIter_float [#_"float[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_float" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Double" next [#_"ArrayIter_float" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß Double.valueOf(array[i]))]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_float" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_double (§ implements Iterator<Double>)
        (§ init
            (§ field #_"double[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_double" ArrayIter_double [#_"double[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_double" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Double" next [#_"ArrayIter_double" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß array[i])]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_double" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_long (§ implements Iterator<Long>)
        (§ init
            (§ field #_"long[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_long" ArrayIter_long [#_"long[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_long" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Long" next [#_"ArrayIter_long" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß Long.valueOf(array[i]))]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_long" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_byte (§ implements Iterator<Byte>)
        (§ init
            (§ field #_"byte[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_byte" ArrayIter_byte [#_"byte[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_byte" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Byte" next [#_"ArrayIter_byte" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß array[i])]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_byte" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_char (§ implements Iterator<Character>)
        (§ init
            (§ field #_"char[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_char" ArrayIter_char [#_"char[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_char" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Character" next [#_"ArrayIter_char" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß array[i])]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_char" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_short (§ implements Iterator<Long>)
        (§ init
            (§ field #_"short[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_short" ArrayIter_short [#_"short[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_short" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Long" next [#_"ArrayIter_short" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß Long.valueOf(array[i]))]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_short" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
        (§ init
            (§ field #_"boolean[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArrayIter_boolean" ArrayIter_boolean [#_"boolean[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ArrayIter_boolean" this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Boolean" next [#_"ArrayIter_boolean" this]
            (when (ß array != nil && i < array.length)
                (let [_ (ß Boolean.valueOf(array[i]))]
                    (§ ass i (ß i + 1))
                    (§ return _)
                )
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [#_"ArrayIter_boolean" this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ defn #_"ArraySeq" create []
        nil
    )

    (§ defn #_"ArraySeq" create [#_"Object..." array]
        (when (ß array == nil || array.length == 0)
            (§ return nil)
        )
        (ß new ArraySeq(array, 0))
    )

    (§ defn #_"ISeq" createFromObject [#_"Object" array]
        (when (ß array == nil || Array.getLength(array) == 0)
            (§ return nil)
        )
        (let [#_"Class" aclass (ß array.getClass())]
            (when (ß aclass == int[].class)
                (§ return (ß new ArraySeq_int(nil, (int[]) array, 0)))
            )
            (when (ß aclass == float[].class)
                (§ return (ß new ArraySeq_float(nil, (float[]) array, 0)))
            )
            (when (ß aclass == double[].class)
                (§ return (ß new ArraySeq_double(nil, (double[]) array, 0)))
            )
            (when (ß aclass == long[].class)
                (§ return (ß new ArraySeq_long(nil, (long[]) array, 0)))
            )
            (when (ß aclass == byte[].class)
                (§ return (ß new ArraySeq_byte(nil, (byte[]) array, 0)))
            )
            (when (ß aclass == char[].class)
                (§ return (ß new ArraySeq_char(nil, (char[]) array, 0)))
            )
            (when (ß aclass == short[].class)
                (§ return (ß new ArraySeq_short(nil, (short[]) array, 0)))
            )
            (when (ß aclass == boolean[].class)
                (§ return (ß new ArraySeq_boolean(nil, (boolean[]) array, 0)))
            )
            (ß new ArraySeq(array, 0))
        )
    )

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq" ArraySeq [#_"Object" array, #_"int" i]
        (let [this (ß super())]
            (§ ass (ß this.i) i)
            (§ ass (ß this.array) (ß (Object[]) array))
            this
        )
    )

    (§ constructor #_"ArraySeq" ArraySeq [#_"IPersistentMap" meta, #_"Object" array, #_"int" i]
        (let [this (ß super(meta))]
            (§ ass (ß this.i) i)
            (§ ass (ß this.array) (ß (Object[]) array))
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq" this]
        (when (some? array)
            (§ return (ß array[i]))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq" this]
        (when (ß array != nil && i + 1 < array.length)
            (§ return (ß new ArraySeq(array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq" this]
        (when (some? array)
            (§ return (ß array.length - i))
        )
        0
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq" withMeta [#_"ArraySeq" this, #_"IPersistentMap" meta]
        (ß new ArraySeq(meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq" this, #_"IFn" f]
        (when (some? array)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                (§ return ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq" this, #_"IFn" f, #_"Object" start]
        (when (some? array)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (§ return ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq" this, #_"Object" o]
        (when (some? array)
            (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                (when (ß Util.equals(o, array[j]))
                    (§ return (ß j - i))
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq" this, #_"Object" o]
        (when (some? array)
            (if (nil? o)
                (do
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß array[j] == nil)
                            (§ return (ß j - i))
                        )
                    )
                )
                (do
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß o.equals(array[j]))
                            (§ return (ß j - i))
                        )
                    )
                )
            )
        )
        -1
    )

    (class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"int[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_int" ArraySeq_int [#_"IPersistentMap" meta, #_"int[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_int" this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_int" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_int(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_int" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_int" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_int" withMeta [#_"ArraySeq_int" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_int(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_int" this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_int" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_int" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"int" k (ß ((Number) o).intValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß k == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_int" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"int" k (ß ((Number) o).intValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß k == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"float[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_float" ArraySeq_float [#_"IPersistentMap" meta, #_"float[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_float" this]
            (ß Numbers.num(array[i]))
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_float" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_float(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_float" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_float" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_float" withMeta [#_"ArraySeq_float" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_float(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_float" this, #_"IFn" f]
            (let [#_"Object" ret (ß Numbers.num(array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, Numbers.num(array[x]))))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_float" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, Numbers.num(array[i])))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, Numbers.num(array[x]))))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_float" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"float" f (ß ((Number) o).floatValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß f == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_float" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"float" f (ß ((Number) o).floatValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß f == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"double[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_double" ArraySeq_double [#_"IPersistentMap" meta, #_"double[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_double" this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_double" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_double(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_double" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_double" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_double" withMeta [#_"ArraySeq_double" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_double(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_double" this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_double" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_double" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"double" d (ß ((Number) o).doubleValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß d == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_double" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"double" d (ß ((Number) o).doubleValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß d == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"long[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_long" ArraySeq_long [#_"IPersistentMap" meta, #_"long[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_long" this]
            (ß Numbers.num(array[i]))
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_long" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_long(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_long" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_long" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_long" withMeta [#_"ArraySeq_long" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_long(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_long" this, #_"IFn" f]
            (let [#_"Object" ret (ß Numbers.num(array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, Numbers.num(array[x]))))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_long" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, Numbers.num(array[i])))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, Numbers.num(array[x]))))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_long" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"long" l (ß ((Number) o).longValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß l == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_long" this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"long" l (ß ((Number) o).longValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß l == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"byte[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_byte" ArraySeq_byte [#_"IPersistentMap" meta, #_"byte[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_byte" this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_byte" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_byte(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_byte" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_byte" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_byte" withMeta [#_"ArraySeq_byte" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_byte(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_byte" this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_byte" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_byte" this, #_"Object" o]
            (when (ß o instanceof Byte)
                (let [#_"byte" b (ß ((Byte) o).byteValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_byte" this, #_"Object" o]
            (when (ß o instanceof Byte)
                (let [#_"byte" b (ß ((Byte) o).byteValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"char[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_char" ArraySeq_char [#_"IPersistentMap" meta, #_"char[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_char" this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_char" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_char(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_char" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_char" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_char" withMeta [#_"ArraySeq_char" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_char(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_char" this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_char" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_char" this, #_"Object" o]
            (when (ß o instanceof Character)
                (let [#_"char" c (ß ((Character) o).charValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß c == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_char" this, #_"Object" o]
            (when (ß o instanceof Character)
                (let [#_"char" c (ß ((Character) o).charValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß c == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"short[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_short" ArraySeq_short [#_"IPersistentMap" meta, #_"short[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_short" this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_short" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_short(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_short" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_short" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_short" withMeta [#_"ArraySeq_short" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_short(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_short" this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_short" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_short" this, #_"Object" o]
            (when (ß o instanceof Short)
                (let [#_"short" s (ß ((Short) o).shortValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß s == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_short" this, #_"Object" o]
            (when (ß o instanceof Short)
                (let [#_"short" s (ß ((Short) o).shortValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß s == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ init
            (§ field #_"boolean[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"ArraySeq_boolean" ArraySeq_boolean [#_"IPersistentMap" meta, #_"boolean[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"ArraySeq_boolean" this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ArraySeq_boolean" this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_boolean(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"ArraySeq_boolean" this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [#_"ArraySeq_boolean" this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_boolean" withMeta [#_"ArraySeq_boolean" this, #_"IPersistentMap" meta]
            (ß new ArraySeq_boolean(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_boolean" this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (§ ass ret (ß f.invoke(ret, array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [#_"ArraySeq_boolean" this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(§ var #_"int" x (ß i + 1))] (ß x < array.length) [(§ ass x (ß x + 1))]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass ret (ß f.invoke(ret, array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [#_"ArraySeq_boolean" this, #_"Object" o]
            (when (ß o instanceof Boolean)
                (let [#_"boolean" b (ß ((Boolean) o).booleanValue())]
                    (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(§ ass j (ß j + 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"ArraySeq_boolean" this, #_"Object" o]
            (when (ß o instanceof Boolean)
                (let [#_"boolean" b (ß ((Boolean) o).booleanValue())]
                    (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (nil? o)
                (§ return -1)
            )
            (loop-when-recur [(§ var #_"int" j (ß array.length - 1))] (ß j >= i) [(§ ass j (ß j - 1))]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (§ init
        #_transient
        (§ field #_"int" _hash 0)
        #_transient
        (§ field #_"int" _hasheq 0)
    )

    #_protected
    (§ constructor #_"ASeq" ASeq [#_"IPersistentMap" meta]
        (let [this (ß super(meta))]
            this
        )
    )

    #_protected
    (§ constructor #_"ASeq" ASeq []
        (let [this (ß super())]
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"ASeq" this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"ASeq" this]
        (ß PersistentList.EMPTY)
    )

    #_method
    (§ defn #_"boolean" equiv [#_"ASeq" this, #_"Object" obj]
        (when (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()), ms (ß ms.next()))]
                (when (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"ASeq" this, #_"Object" obj]
        (when (ß this == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()), ms (ß ms.next()))]
                (when (ß ms == nil || !Util.equals(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"ASeq" this]
        (when (ß _hash == 0)
            (let [#_"int" hash 1]
                (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
                    (§ ass hash (ß 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode())))
                )
                (§ ass (ß this._hash) hash)
            )
        )
        (ß _hash)
    )

    #_method
    (§ defn #_"int" hasheq [#_"ASeq" this]
        (when (ß _hasheq == 0)
            (§ ass _hasheq (ß Murmur3.hashOrdered(this)))
        )
        (ß _hasheq)
    )

    #_method
    (§ defn #_"int" count [#_"ASeq" this]
        (let [#_"int" i 1]
            (loop-when-recur [(§ var #_"ISeq" s (ß next()))] (some? s) [(§ ass s (ß s.next()), i (ß i + 1))]
                (when (ß s instanceof Counted)
                    (§ return (ß i + s.count()))
                )
            )
            i
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"ASeq" this]
        this
    )

    #_method
    (§ defn #_"ISeq" cons [#_"ASeq" this, #_"Object" o]
        (ß new Cons(o, this))
    )

    #_method
    (§ defn #_"ISeq" more [#_"ASeq" this]
        (let [#_"ISeq" s (ß next())]
            (when (nil? s)
                (§ return (ß PersistentList.EMPTY))
            )
            s
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"ASeq" this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"ASeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"ASeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"ASeq" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"ASeq" this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [#_"ASeq" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"ASeq" this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [#_"ASeq" this, #_"Object" o]
        (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ASeq" this]
        (SeqIterator. this)
    )

    #_method
    (§ defn- #_"List" reify [#_"ASeq" this]
        (ß Collections.unmodifiableList(new ArrayList(this)))
    )

    #_method
    (§ defn #_"List" subList [#_"ASeq" this, #_"int" fromIndex, #_"int" toIndex]
        (ß reify().subList(fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"ASeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"ASeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"ASeq" this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (loop-when-recur [(§ var #_"int" i 0)] (some? s) [(§ ass s (ß s.next()), i (ß i + 1))]
                (when (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ASeq" this, #_"Object" o]
        (ß reify().lastIndexOf(o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this, #_"int" index]
        (ß reify().listIterator(index))
    )

    #_method
    (§ defn #_"Object" get [#_"ASeq" this, #_"int" index]
        (ß RT.nth(this, index))
    )

    #_method
    (§ defn #_"void" add [#_"ASeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Associative

(§ interface Associative (§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" containsKey [#_"Associative" this, #_"Object" key])
    #_abstract
    (#_"IMapEntry" entryAt [#_"Associative" this, #_"Object" key])
    #_abstract
    (#_"Associative" assoc [#_"Associative" this, #_"Object" key, #_"Object" val])
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (§ init
        (§ field #_"AtomicReference" state nil)
    )

    (§ constructor #_"Atom" Atom [#_"Object" state]
        (let [this (ß super())]
            (§ ass (ß this.state) (AtomicReference. state))
            this
        )
    )

    (§ constructor #_"Atom" Atom [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (ß super(meta))]
            (§ ass (ß this.state) (AtomicReference. state))
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Atom" this]
        (ß state.get())
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" f]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v, arg))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v, arg1, arg2))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.applyTo(RT.listStar(v, x, y, args)))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" f]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv, arg))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv, arg1, arg2))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.applyTo(RT.listStar(oldv, x, y, args)))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" compareAndSet [#_"Atom" this, #_"Object" oldv, #_"Object" newv]
        (ß validate(newv))
        (let [#_"boolean" ret (ß state.compareAndSet(oldv, newv))]
            (when ret
                (ß notifyWatches(oldv, newv))
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reset [#_"Atom" this, #_"Object" newval]
        (let [#_"Object" oldval (ß state.get())]
            (ß validate(newval))
            (ß state.set(newval))
            (ß notifyWatches(oldval, newval))
            newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" resetVals [#_"Atom" this, #_"Object" newv]
        (ß validate(newv))
        (while true
            (let [#_"Object" oldv (ß deref())]
                (when (ß state.compareAndSet(oldv, newv))
                    (ß notifyWatches(oldv, newv))
                    (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

(§ import cloiure.lang.PersistentHashMap.INode)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_abstract
    (§ defn #_"void" ensureEditable [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"ITransientMap" doAssoc [#_"ATransientMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (§ defn #_"ITransientMap" doWithout [#_"ATransientMap" this, #_"Object" key])
    #_abstract
    (§ defn #_"Object" doValAt [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound])
    #_abstract
    (§ defn #_"int" doCount [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"IPersistentMap" doPersistent [#_"ATransientMap" this])

    #_method
    (§ defn #_"ITransientMap" conj [#_"ATransientMap" this, #_"Object" o]
        (ß ensureEditable())
        (cond (ß o instanceof Map.Entry)
            (do
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                    (§ return (ß assoc(e.getKey(), e.getValue())))
                )
            )
            (ß o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
                    (when (ß v.count() != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß assoc(v.nth(0), v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ret this]
            (loop-when-recur [(§ var #_"ISeq" es (ß RT.seq(o)))] (some? es) [(§ ass es (ß es.next()))]
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) es.first()))]
                    (§ ass ret (ß ret.assoc(e.getKey(), e.getValue())))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientMap" this, #_"Object" arg1]
        (ß valAt(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientMap" this, #_"Object" arg1, #_"Object" notFound]
        (ß valAt(arg1, notFound))
    )

    #_method
    (§ defn #_"Object" valAt [#_"ATransientMap" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"ITransientMap" assoc [#_"ATransientMap" this, #_"Object" key, #_"Object" val]
        (ß ensureEditable())
        (ß doAssoc(key, val))
    )

    #_method
    (§ defn #_"ITransientMap" without [#_"ATransientMap" this, #_"Object" key]
        (ß ensureEditable())
        (ß doWithout(key))
    )

    #_method
    (§ defn #_"IPersistentMap" persistent [#_"ATransientMap" this]
        (ß ensureEditable())
        (ß doPersistent())
    )

    #_method
    (§ defn #_"Object" valAt [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound]
        (ß ensureEditable())
        (ß doValAt(key, notFound))
    )

    (§ def- #_"Object" NOT_FOUND (Object.))
    #_method
    (§ defn #_"boolean" containsKey [#_"ATransientMap" this, #_"Object" key]
        (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
    )
    #_method
    (§ defn #_"IMapEntry" entryAt [#_"ATransientMap" this, #_"Object" key]
        (let [#_"Object" v (ß valAt(key, NOT_FOUND))]
            (when (ß v != NOT_FOUND)
                (§ return (ß MapEntry.create(key, v)))
            )
            nil
        )
    )

    #_method
    (§ defn #_"int" count [#_"ATransientMap" this]
        (ß ensureEditable())
        (ß doCount())
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (§ init
        #_volatile
        (§ field #_"ITransientMap" impl nil)
    )

    (§ constructor #_"ATransientSet" ATransientSet [#_"ITransientMap" impl]
        (let [this (ß super())]
            (§ ass (ß this.impl) impl)
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"ATransientSet" this]
        (ß impl.count())
    )

    #_method
    (§ defn #_"ITransientSet" conj [#_"ATransientSet" this, #_"Object" val]
        (let [#_"ITransientMap" m (ß impl.assoc(val, val))]
            (when (ß m != impl)
                (§ ass (ß this.impl) m)
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" contains [#_"ATransientSet" this, #_"Object" key]
        (ß (this != impl.valAt(key, this)))
    )

    #_method
    (§ defn #_"ITransientSet" disjoin [#_"ATransientSet" this, #_"Object" key]
        (let [#_"ITransientMap" m (ß impl.without(key))]
            (when (ß m != impl)
                (§ ass (ß this.impl) m)
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" get [#_"ATransientSet" this, #_"Object" key]
        (ß impl.valAt(key))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientSet" this, #_"Object" key, #_"Object" notFound]
        (ß impl.valAt(key, notFound))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientSet" this, #_"Object" key]
        (ß impl.valAt(key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" ZERO (ß new BigInt(0, nil)))
    (§ def #_"BigInt" ONE (ß new BigInt(1, nil)))

    (§ init
        (§ field #_"long" lpart 0)
        (§ field #_"BigInteger" bipart nil)
    )

    (§ constructor- #_"BigInt" BigInt [#_"long" lpart, #_"BigInteger" bipart]
        (let [this (ß super())]
            (§ ass (ß this.lpart) lpart)
            (§ ass (ß this.bipart) bipart)
            this
        )
    )

    ;; must follow Long
    #_method
    (§ defn #_"int" hashCode [#_"BigInt" this]
        (when (nil? bipart)
            (§ return (ß (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (ß bipart.hashCode())
    )

    #_method
    (§ defn #_"int" hasheq [#_"BigInt" this]
        (when (nil? bipart)
            (§ return (ß Murmur3.hashLong(lpart)))
        )
        (ß bipart.hashCode())
    )

    #_method
    (§ defn #_"boolean" equals [#_"BigInt" this, #_"Object" obj]
        (when (ß this == obj)
            (§ return true)
        )
        (when (ß obj instanceof BigInt)
            (let [#_"BigInt" o (ß (BigInt) obj)]
                (when (nil? bipart)
                    (§ return (ß (o.bipart == nil && this.lpart == o.lpart)))
                )
                (§ return (ß (o.bipart != nil && this.bipart.equals(o.bipart))))
            )
        )
        false
    )

    (§ defn #_"BigInt" fromBigInteger [#_"BigInteger" val]
        (if (ß val.bitLength() < 64)
            (do
                (ß new BigInt(val.longValue(), nil))
            )
            (do
                (ß new BigInt(0, val))
            )
        )
    )

    (§ defn #_"BigInt" fromLong [#_"long" val]
        (ß new BigInt(val, nil))
    )

    #_method
    (§ defn #_"BigInteger" toBigInteger [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß BigInteger.valueOf(lpart))
            )
            (do
                bipart
            )
        )
    )

    #_method
    (§ defn #_"BigDecimal" toBigDecimal [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß BigDecimal.valueOf(lpart))
            )
            (do
                (BigDecimal. bipart)
            )
        )
    )

    #_method
    (§ defn #_"int" intValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß (int) lpart)
            )
            (do
                (ß bipart.intValue())
            )
        )
    )

    #_method
    (§ defn #_"long" longValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                lpart
            )
            (do
                (ß bipart.longValue())
            )
        )
    )

    #_method
    (§ defn #_"float" floatValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                lpart
            )
            (do
                (ß bipart.floatValue())
            )
        )
    )

    #_method
    (§ defn #_"double" doubleValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                lpart
            )
            (do
                (ß bipart.doubleValue())
            )
        )
    )

    #_method
    (§ defn #_"byte" byteValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß (byte) lpart)
            )
            (do
                (ß bipart.byteValue())
            )
        )
    )

    #_method
    (§ defn #_"short" shortValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß (short) lpart)
            )
            (do
                (ß bipart.shortValue())
            )
        )
    )

    (§ defn #_"BigInt" valueOf [#_"long" val]
        (ß new BigInt(val, nil))
    )

    #_method
    (§ defn #_"String" toString [#_"BigInt" this]
        (when (nil? bipart)
            (§ return (ß String.valueOf(lpart)))
        )
        (ß bipart.toString())
    )

    #_method
    (§ defn #_"int" bitLength [#_"BigInt" this]
        (ß toBigInteger().bitLength())
    )

    #_method
    (§ defn #_"BigInt" add [#_"BigInt" this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (let [#_"long" ret (ß lpart + y.lpart)]
                (when (ß (ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0)
                    (§ return (ß BigInt.valueOf(ret)))
                )
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" multiply [#_"BigInt" this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (let [#_"long" ret (ß lpart * y.lpart)]
                (when (ß y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE))
                    (§ return (ß BigInt.valueOf(ret)))
                )
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" quotient [#_"BigInt" this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (when (ß lpart == Long.MIN_VALUE && y.lpart == -1)
                (§ return (ß BigInt.fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (ß BigInt.valueOf(lpart / y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" remainder [#_"BigInt" this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß BigInt.valueOf(lpart % y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger())))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigInt" this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß (lpart < y.lpart)))
        )
        (ß (this.toBigInteger().compareTo(y.toBigInteger()) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (§ init
        (§ field #_"T" val nil)
        (§ field #_"Binding" rest nil)
    )

    (§ constructor #_"Binding" Binding [#_"T" val]
        (let [this (ß super())]
            (§ ass (ß this.val) val)
            (§ ass (ß this.rest) nil)
            this
        )
    )

    (§ constructor #_"Binding" Binding [#_"T" val, #_"Binding" rest]
        (let [this (ß super())]
            (§ ass (ß this.val) val)
            (§ ass (ß this.rest) rest)
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"Box" Box [#_"Object" val]
        (let [this (ß super())]
            (§ ass (ß this.val) val)
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (§ init
        (§ field #_"Object[]" buffer nil)
        (§ field #_"int" end 0)
    )

    (§ constructor #_"ChunkBuffer" ChunkBuffer [#_"int" capacity]
        (let [this (ß super())]
            (§ ass buffer (ß new Object[capacity]))
            (§ ass end 0)
            this
        )
    )

    #_method
    (§ defn #_"void" add [#_"ChunkBuffer" this, #_"Object" o]
        (§ ass (ß buffer[end]) o)
        (§ ass end (ß end + 1))
        nil
    )

    #_method
    (§ defn #_"IChunk" chunk [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ret (ß new ArrayChunk(buffer, 0, end))]
            (§ ass buffer nil)
            ret
        )
    )

    #_method
    (§ defn #_"int" count [#_"ChunkBuffer" this]
        end
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (§ init
        (§ field #_"IChunk" chunk nil)
        (§ field #_"ISeq" _more nil)
    )

    (§ constructor #_"ChunkedCons" ChunkedCons [#_"IPersistentMap" meta, #_"IChunk" chunk, #_"ISeq" more]
        (let [this (ß super(meta))]
            (§ ass (ß this.chunk) chunk)
            (§ ass (ß this._more) more)
            this
        )
    )

    (§ constructor #_"ChunkedCons" ChunkedCons [#_"IChunk" chunk, #_"ISeq" more]
        (let [this (ß this(nil, chunk, more))]
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"ChunkedCons" this, #_"IPersistentMap" meta]
        (when (ß meta != _meta)
            (§ return (ß new ChunkedCons(meta, chunk, _more)))
        )
        this
    )

    #_method
    (§ defn #_"Object" first [#_"ChunkedCons" this]
        (ß chunk.nth(0))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ChunkedCons" this]
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"ISeq" more [#_"ChunkedCons" this]
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (when (nil? _more)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"ChunkedCons" this]
        chunk
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"ChunkedCons" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"ChunkedCons" this]
        (when (nil? _more)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

#_stateless
(class-ns Compile
    (§ def- #_"String" PATH_PROP "cloiure.compile.path")
    (§ def- #_"String" REFLECTION_WARNING_PROP "cloiure.compile.warn-on-reflection")
    (§ def- #_"String" UNCHECKED_MATH_PROP "cloiure.compile.unchecked-math")

    (§ def- #_"Var" compile_path (ß RT.var("cloiure.core", "*compile-path*")))
    (§ def- #_"Var" compile (ß RT.var("cloiure.core", "compile")))
    (§ def- #_"Var" warn_on_reflection (ß RT.var("cloiure.core", "*warn-on-reflection*")))
    (§ def- #_"Var" unchecked_math (ß RT.var("cloiure.core", "*unchecked-math*")))

    (§ defn #_"void" main [#_"String[]" args] (§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" out (ß (OutputStreamWriter) RT.OUT.deref())]
            (let [#_"PrintWriter" err (ß RT.errPrintWriter())]
                (let [#_"String" path (ß System.getProperty(PATH_PROP))]
                    (let [#_"int" count (ß args.length)]
                        (when (nil? path)
                            (ß err.println("ERROR: Must set system property " + PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
                            (ß System.exit(1))
                        )

                        (let [#_"boolean" warnOnReflection (ß System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" uncheckedMathProp (ß System.getProperty(UNCHECKED_MATH_PROP))]
                                (let [#_"Object" uncheckedMath (ß Boolean.FALSE)]
                                    (cond (ß "true".equals(uncheckedMathProp))
                                        (do
                                            (§ ass uncheckedMath (ß Boolean.TRUE))
                                        )
                                        (ß "warn-on-boxed".equals(uncheckedMathProp))
                                        (do
                                            (§ ass uncheckedMath (ß Keyword.intern("warn-on-boxed")))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (ß RT.load("cloiure/core/specs/alpha"))

                                    (try
                                        (ß Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath)))

                                        (doseq [#_"String" lib args]
                                            (ß out.write("Compiling " + lib + " to " + path + "\n"))
                                            (ß out.flush())
                                            (ß compile.invoke(Symbol.intern(lib)))
                                        )
                                        (finally
                                            (ß Var.popThreadBindings())
                                            (try
                                                (ß out.flush())
                                                (catch IOException e
                                                    (ß e.printStackTrace(err))
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" DEF (ß Symbol.intern("def")))
    (§ def #_"Symbol" LOOP (ß Symbol.intern("loop*")))
    (§ def #_"Symbol" RECUR (ß Symbol.intern("recur")))
    (§ def #_"Symbol" IF (ß Symbol.intern("if")))
    (§ def #_"Symbol" LET (ß Symbol.intern("let*")))
    (§ def #_"Symbol" LETFN (ß Symbol.intern("letfn*")))
    (§ def #_"Symbol" DO (ß Symbol.intern("do")))
    (§ def #_"Symbol" FN (ß Symbol.intern("fn*")))
    (§ def #_"Symbol" FNONCE (ß (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(nil, "once"), RT.T))))
    (§ def #_"Symbol" QUOTE (ß Symbol.intern("quote")))
    (§ def #_"Symbol" THE_VAR (ß Symbol.intern("var")))
    (§ def #_"Symbol" DOT (ß Symbol.intern(".")))
    (§ def #_"Symbol" ASSIGN (ß Symbol.intern("set!")))
    (§ def #_"Symbol" TRY (ß Symbol.intern("try")))
    (§ def #_"Symbol" CATCH (ß Symbol.intern("catch")))
    (§ def #_"Symbol" FINALLY (ß Symbol.intern("finally")))
    (§ def #_"Symbol" THROW (ß Symbol.intern("throw")))
    (§ def #_"Symbol" MONITOR_ENTER (ß Symbol.intern("monitor-enter")))
    (§ def #_"Symbol" MONITOR_EXIT (ß Symbol.intern("monitor-exit")))
    (§ def #_"Symbol" IMPORT (ß Symbol.intern("cloiure.core", "import*")))
    (§ def #_"Symbol" DEFTYPE (ß Symbol.intern("deftype*")))
    (§ def #_"Symbol" CASE (ß Symbol.intern("case*")))

    (§ def #_"Symbol" CLASS (ß Symbol.intern("Class")))
    (§ def #_"Symbol" NEW (ß Symbol.intern("new")))
    (§ def #_"Symbol" THIS (ß Symbol.intern("this")))
    (§ def #_"Symbol" REIFY (ß Symbol.intern("reify*")))
    (§ def #_"Symbol" LIST (ß Symbol.intern("cloiure.core", "list")))
    (§ def #_"Symbol" HASHMAP (ß Symbol.intern("cloiure.core", "hash-map")))
    (§ def #_"Symbol" VECTOR (ß Symbol.intern("cloiure.core", "vector")))
    (§ def #_"Symbol" IDENTITY (ß Symbol.intern("cloiure.core", "identity")))

    (§ def #_"Symbol" _AMP_ (ß Symbol.intern("&")))
    (§ def #_"Symbol" ISEQ (ß Symbol.intern("cloiure.lang.ISeq")))

    (§ def #_"Keyword" loadNs (ß Keyword.intern(nil, "load-ns")))
    (§ def #_"Keyword" inlineKey (ß Keyword.intern(nil, "inline")))
    (§ def #_"Keyword" inlineAritiesKey (ß Keyword.intern(nil, "inline-arities")))
    (§ def #_"Keyword" staticKey (ß Keyword.intern(nil, "static")))
    (§ def #_"Keyword" arglistsKey (ß Keyword.intern(nil, "arglists")))
    (§ def #_"Symbol" INVOKE_STATIC (ß Symbol.intern("invokeStatic")))

    (§ def #_"Keyword" volatileKey (ß Keyword.intern(nil, "volatile")))
    (§ def #_"Keyword" implementsKey (ß Keyword.intern(nil, "implements")))
    (§ def #_"String" COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" protocolKey (ß Keyword.intern(nil, "protocol")))
    (§ def #_"Keyword" onKey (ß Keyword.intern(nil, "on")))
    (§ def #_"Keyword" dynamicKey (ß Keyword.intern("dynamic")))
    (§ def #_"Keyword" redefKey (ß Keyword.intern(nil, "redef")))

    (§ def #_"Symbol" NS (ß Symbol.intern("ns")))
    (§ def #_"Symbol" IN_NS (ß Symbol.intern("in-ns")))

    (§ def #_"IPersistentMap" specials (ß PersistentHashMap.create(
  #_map DEF, new DefExpr'Parser(),
  #_map LOOP, new LetExpr'Parser(),
  #_map RECUR, new RecurExpr'Parser(),
  #_map IF, new IfExpr'Parser(),
  #_map CASE, new CaseExpr'Parser(),
  #_map LET, new LetExpr'Parser(),
  #_map LETFN, new LetFnExpr'Parser(),
  #_map DO, new BodyExpr'Parser(),
  #_map FN, nil,
  #_map QUOTE, new ConstantExpr'Parser(),
  #_map THE_VAR, new TheVarExpr'Parser(),
  #_map IMPORT, new ImportExpr'Parser(),
  #_map DOT, new HostExpr'Parser(),
  #_map ASSIGN, new AssignExpr'Parser(),
  #_map DEFTYPE, new NewInstanceExpr.DeftypeParser(),
  #_map REIFY, new NewInstanceExpr.ReifyParser(),
  #_map TRY, new TryExpr'Parser(),
  #_map THROW, new ThrowExpr'Parser(),
  #_map MONITOR_ENTER, new MonitorEnterExpr'Parser(),
  #_map MONITOR_EXIT, new MonitorExitExpr'Parser(),
  #_map CATCH, nil,
  #_map FINALLY, nil,
  #_map NEW, new NewExpr'Parser(),
  #_map _AMP_, nil
    )))

    (§ def- #_"int" MAX_POSITIONAL_ARITY 20)
    (§ def- #_"Type" OBJECT_TYPE nil)
    (§ def- #_"Type" KEYWORD_TYPE (ß Type.getType(Keyword.class)))
    (§ def- #_"Type" VAR_TYPE (ß Type.getType(Var.class)))
    (§ def- #_"Type" SYMBOL_TYPE (ß Type.getType(Symbol.class)))
    (§ def- #_"Type" IFN_TYPE (ß Type.getType(IFn.class)))
    (§ def- #_"Type" AFUNCTION_TYPE (ß Type.getType(AFunction.class)))
    (§ def- #_"Type" RT_TYPE (ß Type.getType(RT.class)))
    (§ def- #_"Type" NUMBERS_TYPE (ß Type.getType(Numbers.class)))

    (§ def #_"Type" CLASS_TYPE (ß Type.getType(Class.class)))
    (§ def #_"Type" NS_TYPE (ß Type.getType(Namespace.class)))
    (§ def #_"Type" UTIL_TYPE (ß Type.getType(Util.class)))
    (§ def #_"Type" REFLECTOR_TYPE (ß Type.getType(Reflector.class)))
    (§ def #_"Type" THROWABLE_TYPE (ß Type.getType(Throwable.class)))
    (§ def #_"Type" BOOLEAN_OBJECT_TYPE (ß Type.getType(Boolean.class)))
    (§ def #_"Type" IPERSISTENTMAP_TYPE (ß Type.getType(IPersistentMap.class)))
    (§ def #_"Type" IOBJ_TYPE (ß Type.getType(IObj.class)))
    (§ def #_"Type" TUPLE_TYPE (ß Type.getType(Tuple.class)))

    (§ def #_"Method[]" createTupleMethods (§ array
        (ß Method.getMethod("cloiure.lang.IPersistentVector create()")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)"))
    ))

    (§ def- #_"Type[][]" ARG_TYPES nil)
    (§ def- #_"Type[]" EXCEPTION_TYPES (§ array ))

    (§ static
        (§ ass OBJECT_TYPE (ß Type.getType(Object.class)))
        (§ ass ARG_TYPES (ß new Type[MAX_POSITIONAL_ARITY + 2][]))
        (loop-when-recur [(§ var #_"int" i 0)] (ß i <= MAX_POSITIONAL_ARITY) [(§ ass i (ß i + 1))]
            (let [#_"Type[]" a (ß new Type[i])]
                (loop-when-recur [(§ var #_"int" j 0)] (ß j < i) [(§ ass j (ß j + 1))]
                    (§ ass (ß a[j]) OBJECT_TYPE)
                )
                (§ ass (ß ARG_TYPES[i]) a)
            )
        )
        (let [#_"Type[]" a (ß new Type[MAX_POSITIONAL_ARITY + 1])]
            (loop-when-recur [(§ var #_"int" j 0)] (ß j < MAX_POSITIONAL_ARITY) [(§ ass j (ß j + 1))]
                (§ ass (ß a[j]) OBJECT_TYPE)
            )
            (§ ass (ß a[MAX_POSITIONAL_ARITY]) (ß Type.getType("[Ljava/lang/Object;")))
            (§ ass (ß ARG_TYPES[MAX_POSITIONAL_ARITY + 1]) a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" LOCAL_ENV (ß Var.create(nil).setDynamic()))

    ;; vector<localbinding>
    (§ def #_"Var" LOOP_LOCALS (ß Var.create().setDynamic()))

    ;; Label
    (§ def #_"Var" LOOP_LABEL (ß Var.create().setDynamic()))

    ;; vector<object>
    (§ def #_"Var" CONSTANTS (ß Var.create().setDynamic()))

    ;; IdentityHashMap
    (§ def #_"Var" CONSTANT_IDS (ß Var.create().setDynamic()))

    ;; vector<keyword>
    (§ def #_"Var" KEYWORD_CALLSITES (ß Var.create().setDynamic()))

    ;; vector<var>
    (§ def #_"Var" PROTOCOL_CALLSITES (ß Var.create().setDynamic()))

    ;; set<var>
    (§ def #_"Var" VAR_CALLSITES (ß Var.create().setDynamic()))

    ;; keyword->constid
    (§ def #_"Var" KEYWORDS (ß Var.create().setDynamic()))

    ;; var->constid
    (§ def #_"Var" VARS (ß Var.create().setDynamic()))

    ;; FnFrame
    (§ def #_"Var" METHOD (ß Var.create(nil).setDynamic()))

    ;; nil or not
    (§ def #_"Var" IN_CATCH_FINALLY (ß Var.create(nil).setDynamic()))

    (§ def #_"Var" METHOD_RETURN_CONTEXT (ß Var.create(nil).setDynamic()))

    (§ def #_"Var" NO_RECUR (ß Var.create(nil).setDynamic()))

    ;; DynamicClassLoader
    (§ def #_"Var" LOADER (ß Var.create().setDynamic()))

    ;; String
    (§ def #_"Var" SOURCE (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic()))

    ;; String
    (§ def #_"Var" SOURCE_PATH (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic()))

    ;; String
    (§ def #_"Var" COMPILE_PATH (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), nil).setDynamic()))
    ;; boolean
    (§ def #_"Var" COMPILE_FILES (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic()))

    (§ def #_"Var" INSTANCE (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?"))))

    (§ def #_"Var" ADD_ANNOTATIONS (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations"))))

    (§ def #_"Keyword" disableLocalsClearingKey (ß Keyword.intern("disable-locals-clearing")))
    (§ def #_"Keyword" directLinkingKey (ß Keyword.intern("direct-linking")))
    (§ def #_"Keyword" elideMetaKey (ß Keyword.intern("elide-meta")))

    (§ def #_"Var" COMPILER_OPTIONS nil)

    (§ defn #_"Object" getCompilerOption [#_"Keyword" k]
        (ß RT.get(COMPILER_OPTIONS.deref(), k))
    )

    (§ static
        (let [#_"Object" compilerOptions nil]
            (doseq [#_"Map.Entry" e (ß System.getProperties().entrySet())]
                (let [#_"String" name (ß (String) e.getKey())]
                    (let [#_"String" v (ß (String) e.getValue())]
                        (when (ß name.startsWith("cloiure.compiler."))
                            (§ ass compilerOptions (ß RT.assoc(compilerOptions, RT.keyword(nil, name.substring(1 + name.lastIndexOf(\.))), RT.readString(v))))
                        )
                    )
                )
            )

            (§ ass COMPILER_OPTIONS (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic()))
        )
    )

    (§ defn #_"Object" elideMeta [#_"Object" m]
        (let [#_"Collection<Object>" elides (ß (Collection<Object>) getCompilerOption(elideMetaKey))]
            (when (some? elides)
                (doseq [#_"Object" k elides]
                    (§ ass m (ß RT.dissoc(m, k)))
                )
            )
            m
        )
    )

    ;; Integer
    (§ def #_"Var" LINE (ß Var.create(0).setDynamic()))
    (§ def #_"Var" COLUMN (ß Var.create(0).setDynamic()))

    (§ defn #_"int" lineDeref []
        (ß ((Number)LINE.deref()).intValue())
    )

    (§ defn #_"int" columnDeref []
        (ß ((Number)COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def #_"Var" LINE_BEFORE (ß Var.create(0).setDynamic()))
    (§ def #_"Var" COLUMN_BEFORE (ß Var.create(0).setDynamic()))
    (§ def #_"Var" LINE_AFTER (ß Var.create(0).setDynamic()))
    (§ def #_"Var" COLUMN_AFTER (ß Var.create(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" NEXT_LOCAL_NUM (ß Var.create(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" RET_LOCAL_NUM (ß Var.create().setDynamic()))

    (§ def #_"Var" COMPILE_STUB_SYM (ß Var.create(nil).setDynamic()))
    (§ def #_"Var" COMPILE_STUB_CLASS (ß Var.create(nil).setDynamic()))

    ;; PathNode chain
    (§ def #_"Var" CLEAR_PATH (ß Var.create(nil).setDynamic()))

    ;; tail of PathNode chain
    (§ def #_"Var" CLEAR_ROOT (ß Var.create(nil).setDynamic()))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" CLEAR_SITES (ß Var.create(nil).setDynamic()))

    (§ enum C
        (§ item STATEMENT), ;; value ignored
        (§ item EXPRESSION), ;; value required
        (§ item RETURN), ;; tail position relative to enclosing recur frame
        (§ item EVAL)
    )

    #_private
    #_stateless
    (class-ns Recur
    )

    (§ def #_"Class" RECUR_CLASS (ß Recur.class))

    (§ interface Expr
        #_abstract
        (#_"Object" eval [#_"Expr" this])
        #_abstract
        (#_"void" emit [#_"Expr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
        #_abstract
        (#_"boolean" hasJavaClass [#_"Expr" this])
        #_abstract
        (#_"Class" getJavaClass [#_"Expr" this])
    )

    #_stateless
    #_abstract
    (class-ns UntypedExpr (§ implements Expr)
        #_method
        (§ defn #_"Class" getJavaClass [#_"UntypedExpr" this]
            (throw (IllegalArgumentException. "Has no Java class"))
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"UntypedExpr" this]
            false
        )
    )

    (§ interface IParser
        #_abstract
        (#_"Expr" parse [#_"IParser" this, #_"C" context, #_"Object" form])
    )

    (§ defn #_"boolean" isSpecial [#_"Object" sym]
        (ß specials.containsKey(sym))
    )

    (§ defn #_"boolean" inTailCall [#_"C" context]
        (ß (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil))
    )

    (§ defn #_"Symbol" resolveSymbol [#_"Symbol" sym]
        ;; already qualified or classname?
        (when (ß sym.name.indexOf(\.) > 0)
            (§ return sym)
        )
        (when (ß sym.ns != nil)
            (let [#_"Namespace" ns (ß namespaceFor(sym))]
                (when (ß ns == nil || ((ns.name.name == nil) ? (sym.ns == nil) :or ns.name.name.equals(sym.ns)))
                    (§ return sym)
                )
                (§ return (ß Symbol.intern(ns.name.name, sym.name)))
            )
        )
        (let [#_"Object" o (ß currentNS().getMapping(sym))]
            (cond (nil? o)
                (do
                    (§ return (ß Symbol.intern(currentNS().name.name, sym.name)))
                )
                (ß o instanceof Class)
                (do
                    (§ return (ß Symbol.intern(nil, ((Class) o).getName())))
                )
                (ß o instanceof Var)
                (do
                    (let [#_"Var" v (ß (Var) o)]
                        (§ return (ß Symbol.intern(v.ns.name.name, v.sym.name)))
                    )
                )
            )
            nil
        )
    )

    (class-ns DefExpr (§ implements Expr)
        (§ def #_"Method" bindRootMethod (ß Method.getMethod("void bindRoot(Object)")))
        (§ def #_"Method" setTagMethod (ß Method.getMethod("void setTag(cloiure.lang.Symbol)")))
        (§ def #_"Method" setMetaMethod (ß Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)")))
        (§ def #_"Method" setDynamicMethod (ß Method.getMethod("cloiure.lang.Var setDynamic(boolean)")))
        (§ def #_"Method" symintern (ß Method.getMethod("cloiure.lang.Symbol intern(String, String)")))
        (§ def #_"Method" internVar (ß Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)")))

        (§ init
            (§ field #_"Var" var nil)
            (§ field #_"Expr" init nil)
            (§ field #_"Expr" meta nil)
            (§ field #_"boolean" initProvided false)
            (§ field #_"boolean" isDynamic false)
            (§ field #_"boolean" shadowsCoreMapping false)
            (§ field #_"String" source nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
        )

        (§ constructor #_"DefExpr" DefExpr [#_"String" source, #_"int" line, #_"int" column, #_"Var" var, #_"Expr" init, #_"Expr" meta, #_"boolean" initProvided, #_"boolean" isDynamic, #_"boolean" shadowsCoreMapping]
            (let [this (ß super())]
                (§ ass (ß this.source) source)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.var) var)
                (§ ass (ß this.init) init)
                (§ ass (ß this.meta) meta)
                (§ ass (ß this.isDynamic) isDynamic)
                (§ ass (ß this.shadowsCoreMapping) shadowsCoreMapping)
                (§ ass (ß this.initProvided) initProvided)
                this
            )
        )

        #_method
        (§ defn- #_"boolean" includesExplicitMetadata [#_"DefExpr" this, #_"MapExpr" expr]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < expr.keyvals.count()) [(§ ass i (ß i + 2))]
                (let [#_"Keyword" k (ß ((KeywordExpr) expr.keyvals.nth(i)).k)]
                    (when (ß (k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY))
                        (§ return true)
                    )
                )
            )
            false
        )

        #_method
        (§ defn #_"Object" eval [#_"DefExpr" this]
            (try
                (when initProvided
                    (ß var.bindRoot(init.eval()))
                )
                (when (some? meta)
                    (let [#_"IPersistentMap" metaMap (ß (IPersistentMap) meta.eval())]
                        (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                            (ß var.setMeta(metaMap))
                        )
                    )
                )
                (ß var.setDynamic(isDynamic))
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [#_"DefExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitVar(gen, var))

            (when shadowsCoreMapping
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "ns", NS_TYPE))
                (ß gen.swap())
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE))
                (ß gen.swap())
                (ß gen.invokeVirtual(NS_TYPE, internVar))
            )

            (when isDynamic
                (ß gen.push(isDynamic))
                (ß gen.invokeVirtual(VAR_TYPE, setDynamicMethod))
            )
            (when (some? meta)
                (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                    (ß gen.dup())
                    (ß meta.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                    (ß gen.invokeVirtual(VAR_TYPE, setMetaMethod))
                )
            )
            (when initProvided
                (ß gen.dup())
                (if (ß init instanceof FnExpr)
                    (do
                        (ß ((FnExpr)init).emitForDefn(objx, gen))
                    )
                    (do
                        (ß init.emit(C.EXPRESSION, objx, gen))
                    )
                )
                (ß gen.invokeVirtual(VAR_TYPE, bindRootMethod))
            )

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"DefExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"DefExpr" this]
            (ß Var.class)
        )

        #_stateless
        (class-ns DefExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"DefExpr'Parser" this, #_"C" context, #_"Object" form]
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                (let [#_"String" docstring nil]
                    (when (ß RT.count(form) == 4 && (RT.third(form) instanceof String))
                        (§ ass docstring (ß (String) RT.third(form)))
                        (§ ass form (ß RT.list(RT.first(form), RT.second(form), RT.fourth(form))))
                    )
                    (cond (ß RT.count(form) > 3)
                        (do
                            (throw (ß Util.runtimeException("Too many arguments to def")))
                        )
                        (ß RT.count(form) < 2)
                        (do
                            (throw (ß Util.runtimeException("Too few arguments to def")))
                        )
                        (ß !(RT.second(form) instanceof Symbol))
                        (do
                            (throw (ß Util.runtimeException("First argument to def must be a Symbol")))
                        )
                    )
                    (let [#_"Symbol" sym (ß (Symbol) RT.second(form))]
                        (let [#_"Var" v (ß lookupVar(sym, true))]
                            (when (nil? v)
                                (throw (ß Util.runtimeException("Can't refer to qualified var that doesn't exist")))
                            )
                            (let [#_"boolean" shadowsCoreMapping false]
                                (when (ß !v.ns.equals(currentNS()))
                                    (if (ß sym.ns == nil)
                                        (do
                                            (§ ass v (ß currentNS().intern(sym)))
                                            (§ ass shadowsCoreMapping true)
                                            (ß registerVar(v))
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Can't create defs outside of current ns")))
                                        )
                                    )
                                )
                                (let [#_"IPersistentMap" mm (ß sym.meta())]
                                    (let [#_"boolean" isDynamic (ß RT.booleanCast(RT.get(mm, dynamicKey)))]
                                        (when isDynamic
                                            (ß v.setDynamic())
                                        )
                                        (when (ß !isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2)
                                            (ß RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", sym, SOURCE_PATH.get(), LINE.get()))
                                        )
                                        (when (ß RT.booleanCast(RT.get(mm, arglistsKey)))
                                            (let [#_"IPersistentMap" vm (ß v.meta())]
                                                ;; drop quote
                                                (§ ass vm (ß (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey)))))
                                                (ß v.setMeta(vm))
                                            )
                                        )
                                        (let [#_"Object" source_path (ß SOURCE_PATH.get())]
                                            (§ ass source_path (ß (source_path == nil) ? "NO_SOURCE_FILE" :or source_path))
                                            (§ ass mm (ß (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path)))
                                            (when (some? docstring)
                                                (§ ass mm (ß (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring)))
                                            )
                                            (§ ass mm (ß (IPersistentMap) elideMeta(mm)))
                                            (let [#_"Expr" meta (ß (mm.count() == 0) ? nil :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm))]
                                                (ß new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name), meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns AssignExpr (§ implements Expr)
        (§ init
            (§ field #_"AssignableExpr" target nil)
            (§ field #_"Expr" val nil)
        )

        (§ constructor #_"AssignExpr" AssignExpr [#_"AssignableExpr" target, #_"Expr" val]
            (let [this (ß super())]
                (§ ass (ß this.target) target)
                (§ ass (ß this.val) val)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"AssignExpr" this]
            (ß target.evalAssign(val))
        )

        #_method
        (§ defn #_"void" emit [#_"AssignExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß target.emitAssign(context, objx, gen, val))
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"AssignExpr" this]
            (ß val.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"AssignExpr" this]
            (ß val.getJavaClass())
        )

        #_stateless
        (class-ns AssignExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"AssignExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß RT.length(form) != 3)
                        (throw (ß new IllegalArgumentException("Malformed assignment, expecting (set! target val)")))
                    )
                    (let [#_"Expr" target (ß analyze(C.EXPRESSION, RT.second(form)))]
                        (when (ß !(target instanceof AssignableExpr))
                            (throw (IllegalArgumentException. "Invalid assignment target"))
                        )
                        (ß new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form))))
                    )
                )
            )
        )
    )

    (class-ns VarExpr (§ implements Expr, AssignableExpr)
        (§ def #_"Method" getMethod (ß Method.getMethod("Object get()")))
        (§ def #_"Method" setMethod (ß Method.getMethod("Object set(Object)")))

        (§ init
            (§ field #_"Var" var nil)
            (§ field #_"Object" tag nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"VarExpr" VarExpr [#_"Var" var, #_"Symbol" tag]
            (let [this (ß super())]
                (§ ass (ß this.var) var)
                (§ ass (ß this.tag) (ß (tag != nil) ? tag :or var.getTag()))
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"VarExpr" this]
            (ß var.deref())
        )

        #_method
        (§ defn #_"void" emit [#_"VarExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitVarValue(gen, var))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"VarExpr" this]
            (ß (tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"VarExpr" this]
            (when (nil? jc)
                (§ ass jc (ß HostExpr.tagToClass(tag)))
            )
            jc
        )

        #_method
        (§ defn #_"Object" evalAssign [#_"VarExpr" this, #_"Expr" val]
            (ß var.set(val.eval()))
        )

        #_method
        (§ defn #_"void" emitAssign [#_"VarExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (ß objx.emitVar(gen, var))
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeVirtual(VAR_TYPE, setMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns TheVarExpr (§ implements Expr)
        (§ init
            (§ field #_"Var" var nil)
        )

        (§ constructor #_"TheVarExpr" TheVarExpr [#_"Var" var]
            (let [this (ß super())]
                (§ ass (ß this.var) var)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"TheVarExpr" this]
            var
        )

        #_method
        (§ defn #_"void" emit [#_"TheVarExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitVar(gen, var))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"TheVarExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"TheVarExpr" this]
            (ß Var.class)
        )

        #_stateless
        (class-ns TheVarExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"TheVarExpr'Parser" this, #_"C" context, #_"Object" form]
                (let [#_"Symbol" sym (ß (Symbol) RT.second(form))]
                    (let [#_"Var" v (ß lookupVar(sym, false))]
                        (when (some? v)
                            (§ return (TheVarExpr. v))
                        )
                        (throw (ß Util.runtimeException("Unable to resolve var: " + sym + " in this context")))
                    )
                )
            )
        )
    )

    (class-ns KeywordExpr (§ extends LiteralExpr)
        (§ init
            (§ field #_"Keyword" k nil)
        )

        (§ constructor #_"KeywordExpr" KeywordExpr [#_"Keyword" k]
            (let [this (ß super())]
                (§ ass (ß this.k) k)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"KeywordExpr" this]
            k
        )

        #_method
        (§ defn #_"Object" eval [#_"KeywordExpr" this]
            k
        )

        #_method
        (§ defn #_"void" emit [#_"KeywordExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitKeyword(gen, k))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"KeywordExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"KeywordExpr" this]
            (ß Keyword.class)
        )
    )

    (class-ns ImportExpr (§ implements Expr)
        (§ def #_"Method" forNameMethod (ß Method.getMethod("Class classForNameNonLoading(String)")))
        (§ def #_"Method" importClassMethod (ß Method.getMethod("Class importClass(Class)")))
        (§ def #_"Method" derefMethod (ß Method.getMethod("Object deref()")))

        (§ init
            (§ field #_"String" c nil)
        )

        (§ constructor #_"ImportExpr" ImportExpr [#_"String" c]
            (let [this (ß super())]
                (§ ass (ß this.c) c)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"ImportExpr" this]
            (let [#_"Namespace" ns (ß (Namespace) RT.CURRENT_NS.deref())]
                (ß ns.importClass(RT.classForNameNonLoading(c)))
                nil
            )
        )

        #_method
        (§ defn #_"void" emit [#_"ImportExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE))
            (ß gen.invokeVirtual(VAR_TYPE, derefMethod))
            (ß gen.checkCast(NS_TYPE))
            (ß gen.push(c))
            (ß gen.invokeStatic(RT_TYPE, forNameMethod))
            (ß gen.invokeVirtual(NS_TYPE, importClassMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"ImportExpr" this]
            false
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"ImportExpr" this]
            (throw (IllegalArgumentException. "ImportExpr has no Java class"))
        )

        #_stateless
        (class-ns ImportExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"ImportExpr'Parser" this, #_"C" context, #_"Object" form]
                (ß new ImportExpr((String) RT.second(form)))
            )
        )
    )

    #_stateless
    #_abstract
    (class-ns LiteralExpr (§ implements Expr)
        #_abstract
        (§ defn #_"Object" val [#_"LiteralExpr" this])

        #_method
        (§ defn #_"Object" eval [#_"LiteralExpr" this]
            (ß val())
        )
    )

    (§ interface AssignableExpr
        #_abstract
        (#_"Object" evalAssign [#_"AssignableExpr" this, #_"Expr" val])
        #_abstract
        (#_"void" emitAssign [#_"AssignableExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val])
    )

    (§ interface MaybePrimitiveExpr (§ extends Expr)
        #_abstract
        (#_"boolean" canEmitPrimitive [#_"MaybePrimitiveExpr" this])
        #_abstract
        (#_"void" emitUnboxed [#_"MaybePrimitiveExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
    )

    #_stateless
    #_abstract
    (class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ def #_"Type" BOOLEAN_TYPE (ß Type.getType(Boolean.class)))
        (§ def #_"Type" CHAR_TYPE (ß Type.getType(Character.class)))
        (§ def #_"Type" INTEGER_TYPE (ß Type.getType(Integer.class)))
        (§ def #_"Type" LONG_TYPE (ß Type.getType(Long.class)))
        (§ def #_"Type" FLOAT_TYPE (ß Type.getType(Float.class)))
        (§ def #_"Type" DOUBLE_TYPE (ß Type.getType(Double.class)))
        (§ def #_"Type" SHORT_TYPE (ß Type.getType(Short.class)))
        (§ def #_"Type" BYTE_TYPE (ß Type.getType(Byte.class)))
        (§ def #_"Type" NUMBER_TYPE (ß Type.getType(Number.class)))

        (§ def #_"Method" charValueMethod (ß Method.getMethod("char charValue()")))
        (§ def #_"Method" booleanValueMethod (ß Method.getMethod("boolean booleanValue()")))

        (§ def #_"Method" charValueOfMethod (ß Method.getMethod("Character valueOf(char)")))
        (§ def #_"Method" intValueOfMethod (ß Method.getMethod("Integer valueOf(int)")))
        (§ def #_"Method" longValueOfMethod (ß Method.getMethod("Long valueOf(long)")))
        (§ def #_"Method" floatValueOfMethod (ß Method.getMethod("Float valueOf(float)")))
        (§ def #_"Method" doubleValueOfMethod (ß Method.getMethod("Double valueOf(double)")))
        (§ def #_"Method" shortValueOfMethod (ß Method.getMethod("Short valueOf(short)")))
        (§ def #_"Method" byteValueOfMethod (ß Method.getMethod("Byte valueOf(byte)")))

        (§ def #_"Method" intValueMethod (ß Method.getMethod("int intValue()")))
        (§ def #_"Method" longValueMethod (ß Method.getMethod("long longValue()")))
        (§ def #_"Method" floatValueMethod (ß Method.getMethod("float floatValue()")))
        (§ def #_"Method" doubleValueMethod (ß Method.getMethod("double doubleValue()")))
        (§ def #_"Method" byteValueMethod (ß Method.getMethod("byte byteValue()")))
        (§ def #_"Method" shortValueMethod (ß Method.getMethod("short shortValue()")))

        (§ def #_"Method" fromIntMethod (ß Method.getMethod("cloiure.lang.Num from(int)")))
        (§ def #_"Method" fromLongMethod (ß Method.getMethod("cloiure.lang.Num from(long)")))
        (§ def #_"Method" fromDoubleMethod (ß Method.getMethod("cloiure.lang.Num from(double)")))

        (§ defn #_"void" emitBoxReturn [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" returnType]
            (when (ß returnType.isPrimitive())
                (cond (ß returnType == boolean.class)
                    (do
                        (let [#_"Label" falseLabel (ß gen.newLabel())]
                            (let [#_"Label" endLabel (ß gen.newLabel())]
                                (ß gen.ifZCmp(GeneratorAdapter.EQ, falseLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.goTo(endLabel))
                                (ß gen.mark(falseLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.mark(endLabel))
                            )
                        )
                    )
                    (ß returnType == void.class)
                    (do
                        (ß NIL_EXPR.emit(C.EXPRESSION, objx, gen))
                    )
                    (ß returnType == char.class)
                    (do
                        (ß gen.invokeStatic(CHAR_TYPE, charValueOfMethod))
                    )
                    :else
                    (do
                        (cond (ß returnType == int.class)
                            (do
                                (ß gen.invokeStatic(INTEGER_TYPE, intValueOfMethod))
                            )
                            (ß returnType == float.class)
                            (do
                                (ß gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod))
                            )
                            (ß returnType == double.class)
                            (do
                                (ß gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod))
                            )
                            (ß returnType == long.class)
                            (do
                                (ß gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)")))
                            )
                            (ß returnType == byte.class)
                            (do
                                (ß gen.invokeStatic(BYTE_TYPE, byteValueOfMethod))
                            )
                            (ß returnType == short.class)
                            (do
                                (ß gen.invokeStatic(SHORT_TYPE, shortValueOfMethod))
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn #_"void" emitUnboxArg [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" paramType]
            (if (ß paramType.isPrimitive())
                (do
                    (cond (ß paramType == boolean.class)
                        (do
                            (ß gen.checkCast(BOOLEAN_TYPE))
                            (ß gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod))
                        )
                        (ß paramType == char.class)
                        (do
                            (ß gen.checkCast(CHAR_TYPE))
                            (ß gen.invokeVirtual(CHAR_TYPE, charValueMethod))
                        )
                        :else
                        (do
                            (let [#_"Method" m nil]
                                (ß gen.checkCast(NUMBER_TYPE))
                                (if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                                    (do
                                        (cond (ß paramType == int.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("int uncheckedIntCast(Object)")))
                                            )
                                            (ß paramType == float.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("float uncheckedFloatCast(Object)")))
                                            )
                                            (ß paramType == double.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("double uncheckedDoubleCast(Object)")))
                                            )
                                            (ß paramType == long.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("long uncheckedLongCast(Object)")))
                                            )
                                            (ß paramType == byte.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("byte uncheckedByteCast(Object)")))
                                            )
                                            (ß paramType == short.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("short uncheckedShortCast(Object)")))
                                            )
                                        )
                                    )
                                    (do
                                        (cond (ß paramType == int.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("int intCast(Object)")))
                                            )
                                            (ß paramType == float.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("float floatCast(Object)")))
                                            )
                                            (ß paramType == double.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("double doubleCast(Object)")))
                                            )
                                            (ß paramType == long.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("long longCast(Object)")))
                                            )
                                            (ß paramType == byte.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("byte byteCast(Object)")))
                                            )
                                            (ß paramType == short.class)
                                            (do
                                                (§ ass m (ß Method.getMethod("short shortCast(Object)")))
                                            )
                                        )
                                    )
                                )
                                (ß gen.invokeStatic(RT_TYPE, m))
                            )
                        )
                    )
                )
                (do
                    (ß gen.checkCast(Type.getType(paramType)))
                )
            )
            nil
        )

        #_stateless
        (class-ns HostExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"HostExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (. x fieldname-sym) or
                    ;; (. x 0-ary-method)
                    ;; (. x methodname-sym args+)
                    ;; (. x (methodname-sym args?))
                    (when (ß RT.length(form) < 3)
                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (. target member ...)")))
                    )
                    ;; determine static or instance
                    ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                    (let [#_"int" line (ß lineDeref())]
                        (let [#_"int" column (ß columnDeref())]
                            (let [#_"String" source (ß (String) SOURCE.deref())]
                                (let [#_"Class" c (ß maybeClass(RT.second(form), false))]
                                    ;; at this point c will be non-null if static
                                    (let [#_"Expr" instance nil]
                                        (when (nil? c)
                                            (§ ass instance (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form))))
                                        )

                                        (let [#_"boolean" maybeField (ß (RT.length(form) == 3) && (RT.third(form) instanceof Symbol))]
                                            (when (ß maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == \-))
                                                (let [#_"Symbol" sym (ß (Symbol) RT.third(form))]
                                                    (cond (some? c)
                                                        (do
                                                            (§ ass maybeField (ß Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0))
                                                        )
                                                        (ß instance != nil && instance.hasJavaClass() && instance.getJavaClass() != nil)
                                                        (do
                                                            (§ ass maybeField (ß Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0))
                                                        )
                                                    )
                                                )
                                            )

                                            (if maybeField ;; field
                                                (do
                                                    (let [#_"Symbol" sym (ß (((Symbol)RT.third(form)).name.charAt(0) == \-) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form))]
                                                        (let [#_"Symbol" tag (ß tagOf(form))]
                                                            (if (some? c)
                                                                (do
                                                                    (ß new StaticFieldExpr(line, column, c, munge(sym.name), tag))
                                                                )
                                                                (do
                                                                    (ß new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == \-)))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (let [#_"ISeq" call (ß (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form))))]
                                                        (when (ß !(RT.first(call) instanceof Symbol))
                                                            (throw (IllegalArgumentException. "Malformed member expression"))
                                                        )
                                                        (let [#_"Symbol" sym (ß (Symbol) RT.first(call))]
                                                            (let [#_"Symbol" tag (ß tagOf(form))]
                                                                (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                                                    (let [#_"boolean" tailPosition (ß inTailCall(context))]
                                                                        (loop-when-recur [(§ var #_"ISeq" s (ß RT.next(call)))] (some? s) [(§ ass s (ß s.next()))]
                                                                            (§ ass args (ß args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first()))))
                                                                        )
                                                                        (if (some? c)
                                                                            (do
                                                                                (ß new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition))
                                                                            )
                                                                            (do
                                                                                (ß new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn #_"Class" maybeClass [#_"Object" form, #_"boolean" stringOk]
            (when (ß form instanceof Class)
                (§ return (ß (Class) form))
            )
            (let [#_"Class" c nil]
                (cond (ß form instanceof Symbol)
                    (do
                        (let [#_"Symbol" sym (ß (Symbol) form)]
                            (when (ß sym.ns == nil) ;; if ns-qualified can't be classname
                                (when (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                                    (§ return (ß (Class) COMPILE_STUB_CLASS.get()))
                                )
                                (if (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
                                    (do
                                        (§ ass c (ß RT.classForNameNonLoading(sym.name)))
                                    )
                                    (do
                                        (let [#_"Object" o (ß currentNS().getMapping(sym))]
                                            (cond (ß o instanceof Class)
                                                (do
                                                    (§ ass c (ß (Class) o))
                                                )
                                                (ß LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form))
                                                (do
                                                    (§ return nil)
                                                )
                                                :else
                                                (do
                                                    (try
                                                        (§ ass c (ß RT.classForNameNonLoading(sym.name)))
                                                        (catch Exception e
                                                            ;; aargh
                                                            ;; leave c set to nil -> return nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß stringOk && form instanceof String)
                    (do
                        (§ ass c (ß RT.classForNameNonLoading((String) form)))
                    )
                )
                c
            )
        )

        (§ defn #_"Class" maybeSpecialTag [#_"Symbol" sym]
            (let [#_"Class" c (ß primClass(sym))]
                (cond (some? c)
                    (do
                        (§ return c)
                    )
                    (ß sym.name.equals("objects"))
                    (do
                        (§ ass c (ß Object[].class))
                    )
                    (ß sym.name.equals("ints"))
                    (do
                        (§ ass c (ß int[].class))
                    )
                    (ß sym.name.equals("longs"))
                    (do
                        (§ ass c (ß long[].class))
                    )
                    (ß sym.name.equals("floats"))
                    (do
                        (§ ass c (ß float[].class))
                    )
                    (ß sym.name.equals("doubles"))
                    (do
                        (§ ass c (ß double[].class))
                    )
                    (ß sym.name.equals("chars"))
                    (do
                        (§ ass c (ß char[].class))
                    )
                    (ß sym.name.equals("shorts"))
                    (do
                        (§ ass c (ß short[].class))
                    )
                    (ß sym.name.equals("bytes"))
                    (do
                        (§ ass c (ß byte[].class))
                    )
                    (ß sym.name.equals("booleans"))
                    (do
                        (§ ass c (ß boolean[].class))
                    )
                )
                c
            )
        )

        (§ defn #_"Class" tagToClass [#_"Object" tag]
            (let [#_"Class" c nil]
                (when (ß tag instanceof Symbol)
                    (let [#_"Symbol" sym (ß (Symbol) tag)]
                        (when (ß sym.ns == nil) ;; if ns-qualified can't be classname
                            (§ ass c (ß maybeSpecialTag(sym)))
                        )
                    )
                )
                (when (nil? c)
                    (§ ass c (ß maybeClass(tag, true)))
                )
                (when (some? c)
                    (§ return c)
                )
                (throw (IllegalArgumentException. (ß "Unable to resolve classname: " + tag)))
            )
        )
    )

    #_stateless
    #_abstract
    (class-ns FieldExpr (§ extends HostExpr)
    )

    (class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ def #_"Method" invokeNoArgInstanceMember (ß Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)")))
        (§ def #_"Method" setInstanceFieldMethod (ß Method.getMethod("Object setInstanceField(Object,String,Object)")))

        (§ init
            (§ field #_"Expr" target nil)
            (§ field #_"Class" targetClass nil)
            (§ field #_"java.lang.reflect.Field" field nil)
            (§ field #_"String" fieldName nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"Symbol" tag nil)
            (§ field #_"boolean" requireField false)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"InstanceFieldExpr" InstanceFieldExpr [#_"int" line, #_"int" column, #_"Expr" target, #_"String" fieldName, #_"Symbol" tag, #_"boolean" requireField]
            (let [this (ß super())]
                (§ ass (ß this.target) target)
                (§ ass (ß this.targetClass) (ß target.hasJavaClass() ? target.getJavaClass() :or nil))
                (§ ass (ß this.field) (ß (targetClass != nil) ? Reflector.getField(targetClass, fieldName, false) :or nil))
                (§ ass (ß this.fieldName) fieldName)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.tag) tag)
                (§ ass (ß this.requireField) requireField)

                (when (ß field == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (if (nil? targetClass)
                        (do
                            (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName))
                        )
                        (do
                            (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName()))
                        )
                    )
                )
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"InstanceFieldExpr" this]
            (ß Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"InstanceFieldExpr" this]
            (ß (targetClass != nil && field != nil && Util.isPrimitive(field.getType())))
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"InstanceFieldExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                )
                (do
                    (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"InstanceFieldExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                    (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.push(fieldName))
                    (ß gen.push(requireField))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"InstanceFieldExpr" this]
            (ß (field != nil || tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"InstanceFieldExpr" this]
            (when (nil? jc)
                (§ ass jc (ß (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType()))
            )
            jc
        )

        #_method
        (§ defn #_"Object" evalAssign [#_"InstanceFieldExpr" this, #_"Expr" val]
            (ß Reflector.setInstanceField(target.eval(), fieldName, val.eval()))
        )

        #_method
        (§ defn #_"void" emitAssign [#_"InstanceFieldExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß val.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.dupX1())
                    (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
                    (ß gen.putField(getType(targetClass), fieldName, Type.getType(field.getType())))
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.push(fieldName))
                    (ß val.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ init
            (§ field #_"String" fieldName nil)
            (§ field #_"Class" c nil)
            (§ field #_"java.lang.reflect.Field" field nil)
            (§ field #_"Symbol" tag nil)

            (§ field #_"int" line 0)
            (§ field #_"int" column 0)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"StaticFieldExpr" StaticFieldExpr [#_"int" line, #_"int" column, #_"Class" c, #_"String" fieldName, #_"Symbol" tag]
            (let [this (ß super())]
                (§ ass (ß this.fieldName) fieldName)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.c) c)
                (try
                    (§ ass field (ß c.getField(fieldName)))
                    (catch NoSuchFieldException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
                (§ ass (ß this.tag) tag)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"StaticFieldExpr" this]
            (ß Reflector.getStaticField(c, fieldName))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"StaticFieldExpr" this]
            (ß Util.isPrimitive(field.getType()))
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"StaticFieldExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"StaticFieldExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.visitLineNumber(line, gen.mark()))

            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"StaticFieldExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"StaticFieldExpr" this]
            (when (nil? jc)
                (§ ass jc (ß (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType()))
            )
            jc
        )

        #_method
        (§ defn #_"Object" evalAssign [#_"StaticFieldExpr" this, #_"Expr" val]
            (ß Reflector.setStaticField(c, fieldName, val.eval()))
        )

        #_method
        (§ defn #_"void" emitAssign [#_"StaticFieldExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.dup())
            (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
            (ß gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (§ defn #_"Class" maybePrimitiveType [#_"Expr" e]
        (when (ß e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
            (let [#_"Class" c (ß e.getJavaClass())]
                (when (ß Util.isPrimitive(c))
                    (§ return c)
                )
            )
        )
        nil
    )

    (§ defn #_"Class" maybeJavaClass [#_"Collection<Expr>" exprs]
        (let [#_"Class" match nil]
            (try
                (doseq [#_"Expr" e exprs]
                    (when (ß e instanceof ThrowExpr)
                        (§ continue )
                    )
                    (when (ß !e.hasJavaClass())
                        (§ return nil)
                    )
                    (let [#_"Class" c (ß e.getJavaClass())]
                        (cond (nil? match)
                            (do
                                (§ ass match c)
                            )
                            (ß match != c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception e
                    (§ return nil)
                )
            )
            match
        )
    )

    #_stateless
    #_abstract
    (class-ns MethodExpr (§ extends HostExpr)
        (§ defn #_"void" emitArgsAsArray [#_"IPersistentVector" args, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.push(args.count()))
            (ß gen.newArray(OBJECT_TYPE))
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                (ß gen.dup())
                (ß gen.push(i))
                (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                (ß gen.arrayStore(OBJECT_TYPE))
            )
            nil
        )

        (§ defn #_"void" emitTypedArgs [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class[]" parameterTypes, #_"IPersistentVector" args]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < parameterTypes.length) [(§ ass i (ß i + 1))]
                (let [#_"Expr" e (ß (Expr) args.nth(i))]
                    (try
                        (let [#_"Class" primc (ß maybePrimitiveType(e))]
                            (cond (ß primc == parameterTypes[i])
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                    )
                                )
                                (ß primc == int.class && parameterTypes[i] == long.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(I2L))
                                    )
                                )
                                (ß primc == long.class && parameterTypes[i] == int.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                                            (do
                                                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)")))
                                            )
                                            (do
                                                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                            )
                                        )
                                    )
                                )
                                (ß primc == float.class && parameterTypes[i] == double.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(F2D))
                                    )
                                )
                                (ß primc == double.class && parameterTypes[i] == float.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(D2F))
                                    )
                                )
                                :else
                                (do
                                    (ß e.emit(C.EXPRESSION, objx, gen))
                                    (ß HostExpr.emitUnboxArg(objx, gen, parameterTypes[i]))
                                )
                            )
                        )
                        (catch Exception e1
                            (throw (ß Util.sneakyThrow(e1)))
                        )
                    )
                )
            )
            nil
        )
    )

    (class-ns InstanceMethodExpr (§ extends MethodExpr)
        (§ def #_"Method" invokeInstanceMethodMethod (ß Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])")))

        (§ init
            (§ field #_"Expr" target nil)
            (§ field #_"String" methodName nil)
            (§ field #_"IPersistentVector" args nil)
            (§ field #_"String" source nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"Symbol" tag nil)
            (§ field #_"boolean" tailPosition false)
            (§ field #_"java.lang.reflect.Method" method nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"InstanceMethodExpr" InstanceMethodExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" target, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
            (let [this (ß super())]
                (§ ass (ß this.source) source)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.args) args)
                (§ ass (ß this.methodName) methodName)
                (§ ass (ß this.target) target)
                (§ ass (ß this.tag) tag)
                (§ ass (ß this.tailPosition) tailPosition)
                (if (ß target.hasJavaClass() && target.getJavaClass() != nil)
                    (do
                        (let [#_"List" methods (ß Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false))]
                            (if (ß methods.isEmpty())
                                (do
                                    (§ ass method nil)
                                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName()))
                                    )
                                )
                                (do
                                    (let [#_"int" methodidx 0]
                                        (when (ß methods.size() > 1)
                                            (let [#_"ArrayList<Class[]>" params (ArrayList.)]
                                                (let [#_"ArrayList<Class>" rets (ArrayList.)]
                                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < methods.size()) [(§ ass i (ß i + 1))]
                                                        (let [(§ var #_"java.lang.reflect.Method" m (ß (java.lang.reflect.Method) methods.get(i)))]
                                                            (ß params.add(m.getParameterTypes()))
                                                            (ß rets.add(m.getReturnType()))
                                                        )
                                                    )
                                                    (§ ass methodidx (ß getMatchingParams(methodName, params, args, rets)))
                                                )
                                            )
                                        )
                                        (let [(§ var #_"java.lang.reflect.Method" m (ß (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil)))]
                                            (when (ß m != nil && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                                                ;; public method of non-public class, try to find it in hierarchy
                                                (§ ass m (ß Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m)))
                                            )
                                            (§ ass method m)
                                            (when (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (do
                        (§ ass method nil)
                        (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                            (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), line, column, methodName))
                        )
                    )
                )
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"InstanceMethodExpr" this]
            (try
                (let [#_"Object" targetval (ß target.eval())]
                    (let [#_"Object[]" argvals (ß new Object[args.count()])]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                            (§ ass (ß argvals[i]) (ß ((Expr) args.nth(i)).eval()))
                        )
                        (when (some? method)
                            (let [#_"LinkedList" ms (LinkedList.)]
                                (ß ms.add(method))
                                (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)))
                            )
                        )
                        (ß Reflector.invokeInstanceMethod(targetval, methodName, argvals))
                    )
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"InstanceMethodExpr" this]
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"InstanceMethodExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (some? method)
                (do
                    (let [#_"Type" type (ß Type.getType(method.getDeclaringClass()))]
                        (ß target.emit(C.EXPRESSION, objx, gen))
                        (ß gen.checkCast(type))
                        (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                        (ß gen.visitLineNumber(line, gen.mark()))
                        (when (ß tailPosition && !objx.canBeDirect)
                            (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                (ß method.emitClearThis(gen))
                            )
                        )
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (if (ß method.getDeclaringClass().isInterface())
                                (do
                                    (ß gen.invokeInterface(type, m))
                                )
                                (do
                                    (ß gen.invokeVirtual(type, m))
                                )
                            )
                        )
                    )
                )
                (do
                    (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"InstanceMethodExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (some? method)
                (do
                    (let [#_"Type" type (ß Type.getType(method.getDeclaringClass()))]
                        (ß target.emit(C.EXPRESSION, objx, gen))
                        (ß gen.checkCast(type))
                        (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                        (ß gen.visitLineNumber(line, gen.mark()))
                        (when (ß context == C.RETURN)
                            (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                (ß method.emitClearLocals(gen))
                            )
                        )
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (if (ß method.getDeclaringClass().isInterface())
                                (do
                                    (ß gen.invokeInterface(type, m))
                                )
                                (do
                                    (ß gen.invokeVirtual(type, m))
                                )
                            )
                            (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                        )
                    )
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.push(methodName))
                    (ß emitArgsAsArray(args, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"InstanceMethodExpr" this]
            (ß (method != nil || tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"InstanceMethodExpr" this]
            (when (nil? jc)
                (§ ass jc (ß retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil)))
            )
            jc
        )
    )

    (class-ns StaticMethodExpr (§ extends MethodExpr)
        (§ def #_"Method" forNameMethod (ß Method.getMethod("Class classForName(String)")))
        (§ def #_"Method" invokeStaticMethodMethod (ß Method.getMethod("Object invokeStaticMethod(Class,String,Object[])")))
        (§ def #_"Keyword" warnOnBoxedKeyword (ß Keyword.intern("warn-on-boxed")))

        (§ init
            (§ field #_"Class" c nil)
            (§ field #_"String" methodName nil)
            (§ field #_"IPersistentVector" args nil)
            (§ field #_"String" source nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"java.lang.reflect.Method" method nil)
            (§ field #_"Symbol" tag nil)
            (§ field #_"boolean" tailPosition false)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"StaticMethodExpr" StaticMethodExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"Class" c, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
            (let [this (ß super())]
                (§ ass (ß this.c) c)
                (§ ass (ß this.methodName) methodName)
                (§ ass (ß this.args) args)
                (§ ass (ß this.source) source)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.tag) tag)
                (§ ass (ß this.tailPosition) tailPosition)

                (let [#_"List" methods (ß Reflector.getMethods(c, args.count(), methodName, true))]
                    (when (ß methods.isEmpty())
                        (throw (IllegalArgumentException. (ß "No matching method: " + methodName)))
                    )

                    (let [#_"int" methodidx 0]
                        (when (ß methods.size() > 1)
                            (let [#_"ArrayList<Class[]>" params (ArrayList.)]
                                (let [#_"ArrayList<Class>" rets (ArrayList.)]
                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < methods.size()) [(§ ass i (ß i + 1))]
                                        (let [(§ var #_"java.lang.reflect.Method" m (ß (java.lang.reflect.Method) methods.get(i)))]
                                            (ß params.add(m.getParameterTypes()))
                                            (ß rets.add(m.getReturnType()))
                                        )
                                    )
                                    (§ ass methodidx (ß getMatchingParams(methodName, params, args, rets)))
                                )
                            )
                        )
                        (§ ass method (ß (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil)))
                        (when (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                            (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args)))
                        )
                        (when (ß method != nil && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method))
                            (ß RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), line, column, method.toString()))
                        )
                        this
                    )
                )
            )
        )

        (§ defn #_"boolean" isBoxedMath [#_"java.lang.reflect.Method" m]
            (let [#_"Class" c (ß m.getDeclaringClass())]
                (when (ß c.equals(Numbers.class))
                    (let [#_"Class[]" argTypes (ß m.getParameterTypes())]
                        (doseq [#_"Class" argType argTypes]
                            (when (ß argType.equals(Object.class) || argType.equals(Number.class))
                                (§ return true)
                            )
                        )
                    )
                )
                false
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"StaticMethodExpr" this]
            (try
                (let [#_"Object[]" argvals (ß new Object[args.count()])]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                        (§ ass (ß argvals[i]) (ß ((Expr) args.nth(i)).eval()))
                    )
                    (when (some? method)
                        (let [#_"LinkedList" ms (LinkedList.)]
                            (ß ms.add(method))
                            (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, nil, argvals)))
                        )
                    )
                    (ß Reflector.invokeStaticMethod(c, methodName, argvals))
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"StaticMethodExpr" this]
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        #_method
        (§ defn #_"boolean" canEmitIntrinsicPredicate [#_"StaticMethodExpr" this]
            (ß (method != nil && RT.get(Intrinsics.preds, method.toString()) != nil))
        )

        #_method
        (§ defn #_"void" emitIntrinsicPredicate [#_"StaticMethodExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Label" falseLabel]
            (ß gen.visitLineNumber(line, gen.mark()))
            (if (some? method)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (let [#_"Object[]" predOps (ß (Object[]) RT.get(Intrinsics.preds, method.toString()))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < predOps.length - 1) [(§ ass i (ß i + 1))]
                            (ß gen.visitInsn((Integer)predOps[i]))
                        )
                        (ß gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel))
                    )
                )
                (do
                    (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"StaticMethodExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (some? method)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (let [#_"Object" ops (ß RT.get(Intrinsics.ops, method.toString()))]
                        (if (some? ops)
                            (do
                                (if (ß ops instanceof Object[])
                                    (do
                                        (doseq [#_"Object" op (ß (Object[])ops)]
                                            (ß gen.visitInsn((Integer) op))
                                        )
                                    )
                                    (do
                                        (ß gen.visitInsn((Integer) ops))
                                    )
                                )
                            )
                            (do
                                (let [#_"Type" type (ß Type.getType(c))]
                                    (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                                        (ß gen.invokeStatic(type, m))
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"StaticMethodExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (some? method)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß tailPosition && !objx.canBeDirect)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearThis(gen))
                        )
                    )
                    (let [#_"Type" type (ß Type.getType(c))]
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (ß gen.invokeStatic(type, m))
                            (let [#_"Class" retClass (ß method.getReturnType())]
                                (if (ß context == C.STATEMENT)
                                    (do
                                        (cond (ß retClass == long.class || retClass == double.class)
                                            (do
                                                (ß gen.pop2())
                                            )
                                            (ß retClass != void.class)
                                            (do
                                                (ß gen.pop())
                                            )
                                        )
                                    )
                                    (do
                                        (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.push(c.getName()))
                    (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                    (ß gen.push(methodName))
                    (ß emitArgsAsArray(args, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"StaticMethodExpr" this]
            (ß (method != nil || tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"StaticMethodExpr" this]
            (when (nil? jc)
                (§ ass jc (ß retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil)))
            )
            jc
        )
    )

    (class-ns UnresolvedVarExpr (§ implements Expr)
        (§ init
            (§ field #_"Symbol" symbol nil)
        )

        (§ constructor #_"UnresolvedVarExpr" UnresolvedVarExpr [#_"Symbol" symbol]
            (let [this (ß super())]
                (§ ass (ß this.symbol) symbol)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"UnresolvedVarExpr" this]
            false
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"UnresolvedVarExpr" this]
            (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
        )

        #_method
        (§ defn #_"void" emit [#_"UnresolvedVarExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            nil
        )

        #_method
        (§ defn #_"Object" eval [#_"UnresolvedVarExpr" this]
            (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
        )
    )

    (class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
        (§ init
            (§ field #_"Number" n nil)
            (§ field #_"int" id 0)
        )

        (§ constructor #_"NumberExpr" NumberExpr [#_"Number" n]
            (let [this (ß super())]
                (§ ass (ß this.n) n)
                (§ ass (ß this.id) (ß registerConstant(n)))
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"NumberExpr" this]
            n
        )

        #_method
        (§ defn #_"void" emit [#_"NumberExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (when (ß context != C.STATEMENT)
                (ß objx.emitConstant(gen, id))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"NumberExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"NumberExpr" this]
            (cond (ß n instanceof Integer)
                (do
                    (ß long.class)
                )
                (ß n instanceof Double)
                (do
                    (ß double.class)
                )
                (ß n instanceof Long)
                (do
                    (ß long.class)
                )
                :else
                (do
                    (throw (ß new IllegalStateException("Unsupported Number type: " + n.getClass().getName())))
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"NumberExpr" this]
            true
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"NumberExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (cond (ß n instanceof Integer)
                (do
                    (ß gen.push(n.longValue()))
                )
                (ß n instanceof Double)
                (do
                    (ß gen.push(n.doubleValue()))
                )
                (ß n instanceof Long)
                (do
                    (ß gen.push(n.longValue()))
                )
            )
            nil
        )

        (§ defn #_"Expr" parse [#_"Number" form]
            (if (ß form instanceof Integer || form instanceof Double || form instanceof Long)
                (do
                    (NumberExpr. form)
                )
                (do
                    (ConstantExpr. form)
                )
            )
        )
    )

    (class-ns ConstantExpr (§ extends LiteralExpr)
        (§ init
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            (§ field #_"Object" v nil)
            (§ field #_"int" id 0)
        )

        (§ constructor #_"ConstantExpr" ConstantExpr [#_"Object" v]
            (let [this (ß super())]
                (§ ass (ß this.v) v)
                (§ ass (ß this.id) (ß registerConstant(v)))
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"ConstantExpr" this]
            v
        )

        #_method
        (§ defn #_"void" emit [#_"ConstantExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitConstant(gen, id))

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"ConstantExpr" this]
            (ß Modifier.isPublic(v.getClass().getModifiers()))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"ConstantExpr" this]
            (cond (ß v instanceof APersistentMap)
                (do
                    (ß APersistentMap.class)
                )
                (ß v instanceof APersistentSet)
                (do
                    (ß APersistentSet.class)
                )
                (ß v instanceof APersistentVector)
                (do
                    (ß APersistentVector.class)
                )
                :else
                (do
                    (ß v.getClass())
                )
            )
        )

        #_stateless
        (class-ns ConstantExpr'Parser (§ implements IParser)
            (§ def #_"Keyword" formKey (ß Keyword.intern("form")))

            #_method
            (§ defn #_"Expr" parse [#_"ConstantExpr'Parser" this, #_"C" context, #_"Object" form]
                (let [#_"int" argCount (ß RT.count(form) - 1)]
                    (when (ß argCount != 1)
                        (let [#_"IPersistentMap" exData (ß new PersistentArrayMap(new Object[] (§ array formKey, form )))]
                            (throw (ß new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData)))
                        )
                    )
                    (let [#_"Object" v (ß RT.second(form))]
                        (cond (nil? v)
                            (do
                                (§ return NIL_EXPR)
                            )
                            (ß v == Boolean.TRUE)
                            (do
                                (§ return TRUE_EXPR)
                            )
                            (ß v == Boolean.FALSE)
                            (do
                                (§ return FALSE_EXPR)
                            )
                        )
                        (cond (ß v instanceof Number)
                            (do
                                (ß NumberExpr.parse((Number)v))
                            )
                            (ß v instanceof String)
                            (do
                                (ß new StringExpr((String) v))
                            )
                            (ß v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0)
                            (do
                                (EmptyExpr. v)
                            )
                            :else
                            (do
                                (ConstantExpr. v)
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns NilExpr (§ extends LiteralExpr)
        #_method
        (§ defn #_"Object" val [#_"NilExpr" this]
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"NilExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"NilExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"NilExpr" this]
            nil
        )
    )

    (§ def #_"NilExpr" NIL_EXPR (NilExpr.))

    (class-ns BooleanExpr (§ extends LiteralExpr)
        (§ init
            (§ field #_"boolean" val false)
        )

        (§ constructor #_"BooleanExpr" BooleanExpr [#_"boolean" val]
            (let [this (ß super())]
                (§ ass (ß this.val) val)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"BooleanExpr" this]
            (ß val ? RT.T :or RT.F)
        )

        #_method
        (§ defn #_"void" emit [#_"BooleanExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if val
                (do
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                )
                (do
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"BooleanExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"BooleanExpr" this]
            (ß Boolean.class)
        )
    )

    (§ def #_"BooleanExpr" TRUE_EXPR (BooleanExpr. true))
    (§ def #_"BooleanExpr" FALSE_EXPR (BooleanExpr. false))

    (class-ns StringExpr (§ extends LiteralExpr)
        (§ init
            (§ field #_"String" str nil)
        )

        (§ constructor #_"StringExpr" StringExpr [#_"String" str]
            (let [this (ß super())]
                (§ ass (ß this.str) str)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"StringExpr" this]
            str
        )

        #_method
        (§ defn #_"void" emit [#_"StringExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (when (ß context != C.STATEMENT)
                (ß gen.push(str))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"StringExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"StringExpr" this]
            (ß String.class)
        )
    )

    (class-ns MonitorEnterExpr (§ extends UntypedExpr)
        (§ init
            (§ field #_"Expr" target nil)
        )

        (§ constructor #_"MonitorEnterExpr" MonitorEnterExpr [#_"Expr" target]
            (let [this (ß super())]
                (§ ass (ß this.target) target)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"MonitorEnterExpr" this]
            (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
        )

        #_method
        (§ defn #_"void" emit [#_"MonitorEnterExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorEnter())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        #_stateless
        (class-ns MonitorEnterExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"MonitorEnterExpr'Parser" this, #_"C" context, #_"Object" form]
                (ß new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns MonitorExitExpr (§ extends UntypedExpr)
        (§ init
            (§ field #_"Expr" target nil)
        )

        (§ constructor #_"MonitorExitExpr" MonitorExitExpr [#_"Expr" target]
            (let [this (ß super())]
                (§ ass (ß this.target) target)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"MonitorExitExpr" this]
            (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
        )

        #_method
        (§ defn #_"void" emit [#_"MonitorExitExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorExit())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        #_stateless
        (class-ns MonitorExitExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"MonitorExitExpr'Parser" this, #_"C" context, #_"Object" form]
                (ß new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns TryExpr (§ implements Expr)
        (class-ns CatchClause
            (§ init
                (§ field #_"Class" c nil)
                (§ field #_"LocalBinding" lb nil)
                (§ field #_"Expr" handler nil)
                (§ field #_"Label" label nil)
                (§ field #_"Label" endLabel nil)
            )

            (§ constructor #_"CatchClause" CatchClause [#_"Class" c, #_"LocalBinding" lb, #_"Expr" handler]
                (let [this (ß super())]
                    (§ ass (ß this.c) c)
                    (§ ass (ß this.lb) lb)
                    (§ ass (ß this.handler) handler)
                    this
                )
            )
        )

        (§ init
            (§ field #_"Expr" tryExpr nil)
            (§ field #_"Expr" finallyExpr nil)
            (§ field #_"PersistentVector" catchExprs nil)
            (§ field #_"int" retLocal 0)
            (§ field #_"int" finallyLocal 0)
        )

        (§ constructor #_"TryExpr" TryExpr [#_"Expr" tryExpr, #_"PersistentVector" catchExprs, #_"Expr" finallyExpr, #_"int" retLocal, #_"int" finallyLocal]
            (let [this (ß super())]
                (§ ass (ß this.tryExpr) tryExpr)
                (§ ass (ß this.catchExprs) catchExprs)
                (§ ass (ß this.finallyExpr) finallyExpr)
                (§ ass (ß this.retLocal) retLocal)
                (§ ass (ß this.finallyLocal) finallyLocal)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"TryExpr" this]
            (throw (UnsupportedOperationException. "Can't eval try"))
        )

        #_method
        (§ defn #_"void" emit [#_"TryExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" startTry (ß gen.newLabel())]
                (let [#_"Label" endTry (ß gen.newLabel())]
                    (let [#_"Label" end (ß gen.newLabel())]
                        (let [#_"Label" ret (ß gen.newLabel())]
                            (let [#_"Label" finallyLabel (ß gen.newLabel())]
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < catchExprs.count()) [(§ ass i (ß i + 1))]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (§ ass (ß clause.label) (ß gen.newLabel()))
                                        (§ ass (ß clause.endLabel) (ß gen.newLabel()))
                                    )
                                )

                                (ß gen.mark(startTry))
                                (ß tryExpr.emit(context, objx, gen))
                                (when (ß context != C.STATEMENT)
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                                )
                                (ß gen.mark(endTry))
                                (when (some? finallyExpr)
                                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                )
                                (ß gen.goTo(ret))

                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < catchExprs.count()) [(§ ass i (ß i + 1))]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.mark(clause.label))
                                        ;; exception should be on stack
                                        ;; put in clause local
                                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx))
                                        (ß clause.handler.emit(context, objx, gen))
                                        (when (ß context != C.STATEMENT)
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                                        )
                                        (ß gen.mark(clause.endLabel))

                                        (when (some? finallyExpr)
                                            (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                        )
                                        (ß gen.goTo(ret))
                                    )
                                )
                                (when (some? finallyExpr)
                                    (ß gen.mark(finallyLabel))
                                    ;; exception should be on stack
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal))
                                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal))
                                    (ß gen.throwException())
                                )
                                (ß gen.mark(ret))
                                (when (ß context != C.STATEMENT)
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal))
                                )
                                (ß gen.mark(end))
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < catchExprs.count()) [(§ ass i (ß i + 1))]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace(\., \/)))
                                    )
                                )
                                (when (some? finallyExpr)
                                    (ß gen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))
                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < catchExprs.count()) [(§ ass i (ß i + 1))]
                                        (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                            (ß gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, nil))
                                        )
                                    )
                                )
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < catchExprs.count()) [(§ ass i (ß i + 1))]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", nil, clause.label, clause.endLabel, clause.lb.idx))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"TryExpr" this]
            (ß tryExpr.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"TryExpr" this]
            (ß tryExpr.getJavaClass())
        )

        #_stateless
        (class-ns TryExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"TryExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß context != C.RETURN)
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )

                    ;; (try try-expr* catch-expr* finally-expr?)
                    ;; catch-expr: (catch class sym expr*)
                    ;; finally-expr: (finally expr*)

                    (let [#_"PersistentVector" body (ß PersistentVector.EMPTY)]
                        (let [#_"PersistentVector" catches (ß PersistentVector.EMPTY)]
                            (let [#_"Expr" bodyExpr nil]
                                (let [#_"Expr" finallyExpr nil]
                                    (let [#_"boolean" caught false]
                                        (let [#_"int" retLocal (ß getAndIncLocalNum())]
                                            (let [#_"int" finallyLocal (ß getAndIncLocalNum())]
                                                (loop-when-recur [(§ var #_"ISeq" fs (ß form.next()))] (some? fs) [(§ ass fs (ß fs.next()))]
                                                    (let [#_"Object" f (ß fs.first())]
                                                        (let [#_"Object" op (ß (f instanceof ISeq) ? ((ISeq) f).first() :or nil)]
                                                            (if (ß !Util.equals(op, CATCH) && !Util.equals(op, FINALLY))
                                                                (do
                                                                    (when caught
                                                                        (throw (ß Util.runtimeException("Only catch or finally clause can follow catch in try expression")))
                                                                    )
                                                                    (§ ass body (ß body.cons(f)))
                                                                )
                                                                (do
                                                                    (when (nil? bodyExpr)
                                                                        (try
                                                                            (ß Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil)))
                                                                            (§ ass bodyExpr (ß (new BodyExpr'Parser()).parse(context, RT.seq(body))))
                                                                            (finally
                                                                                (ß Var.popThreadBindings())
                                                                            )
                                                                        )
                                                                    )

                                                                    (cond (ß Util.equals(op, CATCH))
                                                                        (do
                                                                            (let [#_"Class" c (ß HostExpr.maybeClass(RT.second(f), false))]
                                                                                (when (nil? c)
                                                                                    (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT.second(f))))
                                                                                )
                                                                                (when (ß !(RT.third(f) instanceof Symbol))
                                                                                    (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f))))
                                                                                )
                                                                                (let [#_"Symbol" sym (ß (Symbol) RT.third(f))]
                                                                                    (when (ß sym.getNamespace() != nil)
                                                                                        (throw (ß Util.runtimeException("Can't bind qualified name:" + sym)))
                                                                                    )

                                                                                    (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T))]
                                                                                        (try
                                                                                            (ß Var.pushThreadBindings(dynamicBindings))
                                                                                            (let [#_"LocalBinding" lb (ß registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or nil), nil, false))]
                                                                                                (let [#_"Expr" handler (ß (new BodyExpr'Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f)))))]
                                                                                                    (§ ass catches (ß catches.cons(new CatchClause(c, lb, handler))))
                                                                                                )
                                                                                            )
                                                                                            (finally
                                                                                                (ß Var.popThreadBindings())
                                                                                            )
                                                                                        )
                                                                                        (§ ass caught true)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        :else ;; finally
                                                                        (do
                                                                            (when (ß fs.next() != nil)
                                                                                (throw (ß Util.runtimeException("finally clause must be last in try expression")))
                                                                            )
                                                                            (try
                                                                                (ß Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T)))
                                                                                (§ ass finallyExpr (ß (new BodyExpr'Parser()).parse(C.STATEMENT, RT.next(f))))
                                                                                (finally
                                                                                    (ß Var.popThreadBindings())
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (when (nil? bodyExpr)
                                                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                                    ;; return a body expr directly
                                                    (try
                                                        (ß Var.pushThreadBindings(RT.map(NO_RECUR, true)))
                                                        (§ ass bodyExpr (ß (new BodyExpr'Parser()).parse(context, RT.seq(body))))
                                                        (finally
                                                            (ß Var.popThreadBindings())
                                                        )
                                                    )
                                                    (§ return bodyExpr)
                                                )

                                                (ß new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns ThrowExpr (§ extends UntypedExpr)
        (§ init
            (§ field #_"Expr" excExpr nil)
        )

        (§ constructor #_"ThrowExpr" ThrowExpr [#_"Expr" excExpr]
            (let [this (ß super())]
                (§ ass (ß this.excExpr) excExpr)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"ThrowExpr" this]
            (throw (ß Util.runtimeException("Can't eval throw")))
        )

        #_method
        (§ defn #_"void" emit [#_"ThrowExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß excExpr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(THROWABLE_TYPE))
            (ß gen.throwException())
            nil
        )

        #_stateless
        (class-ns ThrowExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"ThrowExpr'Parser" this, #_"C" context, #_"Object" form]
                (cond (ß context == C.EVAL)
                    (do
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )
                    (ß RT.count(form) == 1)
                    (do
                        (throw (ß Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance")))
                    )
                    (ß RT.count(form) > 2)
                    (do
                        (throw (ß Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance")))
                    )
                )
                (ß new ThrowExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (§ defn #_"boolean" subsumes [#_"Class[]" c1, #_"Class[]" c2]
        ;; presumes matching lengths
        (let [#_"Boolean" better false]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < c1.length) [(§ ass i (ß i + 1))]
                (when (ß c1[i] != c2[i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (ß !c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i]))
                        (do
                            (§ ass better true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            better
        )
    )

    (§ defn #_"String" getTypeStringForArgs [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                (let [#_"Expr" arg (ß (Expr) args.nth(i))]
                    (when (ß i > 0)
                        (ß sb.append(", "))
                    )
                    (ß sb.append((arg.hasJavaClass() && arg.getJavaClass() != nil) ? arg.getJavaClass().getName() :or "unknown"))
                )
            )
            (ß sb.toString())
        )
    )

    (§ defn #_"int" getMatchingParams [#_"String" methodName, #_"ArrayList<Class[]>" paramlists, #_"IPersistentVector" argexprs, #_"List<Class>" rets]
        ;; presumes matching lengths
        (let [#_"int" matchIdx -1]
            (let [#_"boolean" tied false]
                (let [#_"boolean" foundExact false]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < paramlists.size()) [(§ ass i (ß i + 1))]
                        (let [#_"boolean" match true]
                            (let [#_"ISeq" aseq (ß argexprs.seq())]
                                (let [#_"int" exact 0]
                                    (loop-when-recur [(§ var #_"int" p 0)] (ß match && p < argexprs.count() && aseq != nil) [(§ ass p (ß p + 1), aseq (ß aseq.next()))]
                                        (let [#_"Expr" arg (ß (Expr) aseq.first())]
                                            (let [#_"Class" aclass (ß arg.hasJavaClass() ? arg.getJavaClass() :or Object.class)]
                                                (let [#_"Class" pclass (ß paramlists.get(i)[p])]
                                                    (if (ß arg.hasJavaClass() && aclass == pclass)
                                                        (do
                                                            (§ ass exact (ß exact + 1))
                                                        )
                                                        (do
                                                            (§ ass match (ß Reflector.paramArgTypeMatch(pclass, aclass)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß exact == argexprs.count())
                                        (do
                                            (when (ß !foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                                                (§ ass matchIdx i)
                                            )
                                            (§ ass tied false)
                                            (§ ass foundExact true)
                                        )
                                        (ß match && !foundExact)
                                        (do
                                            (if (ß matchIdx == -1)
                                                (do
                                                    (§ ass matchIdx i)
                                                )
                                                (do
                                                    (cond (ß subsumes(paramlists.get(i), paramlists.get(matchIdx)))
                                                        (do
                                                            (§ ass matchIdx i)
                                                            (§ ass tied false)
                                                        )
                                                        (ß Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
                                                        (do
                                                            (when (ß rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                                                                (§ ass matchIdx i)
                                                            )
                                                        )
                                                        (ß !(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
                                                        (do
                                                            (§ ass tied true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when tied
                        (throw (IllegalArgumentException. (ß "More than one matching method found: " + methodName)))
                    )

                    matchIdx
                )
            )
        )
    )

    (class-ns NewExpr (§ implements Expr)
        (§ def #_"Method" invokeConstructorMethod (ß Method.getMethod("Object invokeConstructor(Class,Object[])")))
        (§ def #_"Method" forNameMethod (ß Method.getMethod("Class classForName(String)")))

        (§ init
            (§ field #_"IPersistentVector" args nil)
            (§ field #_"Constructor" ctor nil)
            (§ field #_"Class" c nil)
        )

        (§ constructor #_"NewExpr" NewExpr [#_"Class" c, #_"IPersistentVector" args, #_"int" line, #_"int" column]
            (let [this (ß super())]
                (§ ass (ß this.args) args)
                (§ ass (ß this.c) c)
                (let [#_"Constructor[]" allctors (ß c.getConstructors())]
                    (let [#_"ArrayList" ctors (ArrayList.)]
                        (let [#_"ArrayList<Class[]>" params (ArrayList.)]
                            (let [#_"ArrayList<Class>" rets (ArrayList.)]
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < allctors.length) [(§ ass i (ß i + 1))]
                                    (let [#_"Constructor" ctor (ß allctors[i])]
                                        (when (ß ctor.getParameterTypes().length == args.count())
                                            (ß ctors.add(ctor))
                                            (ß params.add(ctor.getParameterTypes()))
                                            (ß rets.add(c))
                                        )
                                    )
                                )
                                (when (ß ctors.isEmpty())
                                    (throw (IllegalArgumentException. (ß "No matching ctor found for " + c)))
                                )

                                (let [#_"int" ctoridx 0]
                                    (when (ß ctors.size() > 1)
                                        (§ ass ctoridx (ß getMatchingParams(c.getName(), params, args, rets)))
                                    )

                                    (§ ass (ß this.ctor) (ß (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or nil))
                                    (when (ß ctor == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), line, column, c.getName()))
                                    )
                                    this
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"NewExpr" this]
            (let [#_"Object[]" argvals (ß new Object[args.count()])]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                    (§ ass (ß argvals[i]) (ß ((Expr) args.nth(i)).eval()))
                )
                (when (ß this.ctor != nil)
                    (try
                        (§ return (ß ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))))
                        (catch Exception e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (ß Reflector.invokeConstructor(c, argvals))
            )
        )

        #_method
        (§ defn #_"void" emit [#_"NewExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß this.ctor != nil)
                (do
                    (let [#_"Type" type (ß getType(c))]
                        (ß gen.newInstance(type))
                        (ß gen.dup())
                        (ß MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args))
                        (ß gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor))))
                    )
                )
                (do
                    (ß gen.push(destubClassName(c.getName())))
                    (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                    (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"NewExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"NewExpr" this]
            c
        )

        #_stateless
        (class-ns NewExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"NewExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"int" line (ß lineDeref())]
                    (let [#_"int" column (ß columnDeref())]
                        (let [#_"ISeq" form (ß (ISeq) frm)]
                            ;; (new Classname args...)
                            (when (ß form.count() < 2)
                                (throw (ß Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)")))
                            )
                            (let [#_"Class" c (ß HostExpr.maybeClass(RT.second(form), false))]
                                (when (nil? c)
                                    (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT.second(form))))
                                )
                                (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.next(RT.next(form))))] (some? s) [(§ ass s (ß s.next()))]
                                        (§ ass args (ß args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first()))))
                                    )
                                    (ß new NewExpr(c, args, line, column))
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns MetaExpr (§ implements Expr)
        (§ def #_"Type" IOBJ_TYPE (ß Type.getType(IObj.class)))
        (§ def #_"Method" withMetaMethod (ß Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))

        (§ init
            (§ field #_"Expr" expr nil)
            (§ field #_"Expr" meta nil)
        )

        (§ constructor #_"MetaExpr" MetaExpr [#_"Expr" expr, #_"Expr" meta]
            (let [this (ß super())]
                (§ ass (ß this.expr) expr)
                (§ ass (ß this.meta) meta)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"MetaExpr" this]
            (ß ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval()))
        )

        #_method
        (§ defn #_"void" emit [#_"MetaExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IOBJ_TYPE))
            (ß meta.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
            (ß gen.invokeInterface(IOBJ_TYPE, withMetaMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"MetaExpr" this]
            (ß expr.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"MetaExpr" this]
            (ß expr.getJavaClass())
        )
    )

    (class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"Expr" testExpr nil)
            (§ field #_"Expr" thenExpr nil)
            (§ field #_"Expr" elseExpr nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
        )

        (§ constructor #_"IfExpr" IfExpr [#_"int" line, #_"int" column, #_"Expr" testExpr, #_"Expr" thenExpr, #_"Expr" elseExpr]
            (let [this (ß super())]
                (§ ass (ß this.testExpr) testExpr)
                (§ ass (ß this.thenExpr) thenExpr)
                (§ ass (ß this.elseExpr) elseExpr)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"IfExpr" this]
            (let [#_"Object" t (ß testExpr.eval())]
                (when (ß t != nil && t != Boolean.FALSE)
                    (§ return (ß thenExpr.eval()))
                )
                (ß elseExpr.eval())
            )
        )

        #_method
        (§ defn #_"void" emit [#_"IfExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, false))
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"IfExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, true))
            nil
        )

        #_method
        (§ defn #_"void" doEmit [#_"IfExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
            (let [#_"Label" nullLabel (ß gen.newLabel())]
                (let [#_"Label" falseLabel (ß gen.newLabel())]
                    (let [#_"Label" endLabel (ß gen.newLabel())]
                        (ß gen.visitLineNumber(line, gen.mark()))

                        (cond (ß testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
                            (do
                                (ß ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel))
                            )
                            (ß maybePrimitiveType(testExpr) == boolean.class)
                            (do
                                (ß ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen))
                                (ß gen.ifZCmp(gen.EQ, falseLabel))
                            )
                            :else
                            (do
                                (ß testExpr.emit(C.EXPRESSION, objx, gen))
                                (ß gen.dup())
                                (ß gen.ifNull(nullLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.visitJumpInsn(IF_ACMPEQ, falseLabel))
                            )
                        )
                        (if emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen))
                            )
                            (do
                                (ß thenExpr.emit(context, objx, gen))
                            )
                        )
                        (ß gen.goTo(endLabel))
                        (ß gen.mark(nullLabel))
                        (ß gen.pop())
                        (ß gen.mark(falseLabel))
                        (if emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen))
                            )
                            (do
                                (ß elseExpr.emit(context, objx, gen))
                            )
                        )
                        (ß gen.mark(endLabel))
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"IfExpr" this]
            (ß thenExpr.hasJavaClass()
                && elseExpr.hasJavaClass()
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                    || thenExpr.getJavaClass() == RECUR_CLASS
                    || elseExpr.getJavaClass() == RECUR_CLASS
                    || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
                    || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive())))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"IfExpr" this]
            (try
                (ß thenExpr instanceof MaybePrimitiveExpr
                    && elseExpr instanceof MaybePrimitiveExpr
                    && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                            || thenExpr.getJavaClass() == RECUR_CLASS
                            || elseExpr.getJavaClass() == RECUR_CLASS)
                    && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                    && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive())
                (catch Exception e
                    false
                )
            )
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"IfExpr" this]
            (let [#_"Class" thenClass (ß thenExpr.getJavaClass())]
                (when (ß thenClass != nil && thenClass != RECUR_CLASS)
                    (§ return thenClass)
                )
                (ß elseExpr.getJavaClass())
            )
        )

        #_stateless
        (class-ns IfExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"IfExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (if test then) or (if test then else)
                    (cond (ß form.count() > 4)
                        (do
                            (throw (ß Util.runtimeException("Too many arguments to if")))
                        )
                        (ß form.count() < 3)
                        (do
                            (throw (ß Util.runtimeException("Too few arguments to if")))
                        )
                    )
                    (let [#_"PathNode" branch (ß new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))]
                        (let [#_"Expr" testexpr (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))]
                            (let [(ß Expr thenexpr, elseexpr)]
                                (try
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                    (§ ass thenexpr (ß analyze(context, RT.third(form))))
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                                (try
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                    (§ ass elseexpr (ß analyze(context, RT.fourth(form))))
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                                (ß new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ def #_"IPersistentMap" CHAR_MAP (ß PersistentHashMap.create(
      #_map \-, "_",
      #_map \:, "_COLON_",
      #_map \+, "_PLUS_",
      #_map \>, "_GT_",
      #_map \<, "_LT_",
      #_map \=, "_EQ_",
      #_map \~, "_TILDE_",
      #_map \!, "_BANG_",
      #_map \@, "_CIRCA_",
      #_map \#, "_SHARP_",
      #_map \', "_SINGLEQUOTE_",
      #_map \", "_DOUBLEQUOTE_", ;; oops! "
      #_map \%, "_PERCENT_",
      #_map \^, "_CARET_",
      #_map \&, "_AMPERSAND_",
      #_map \*, "_STAR_",
      #_map \|, "_BAR_",
      #_map \{, "_LBRACE_",
      #_map \}, "_RBRACE_",
      #_map \[, "_LBRACK_",
      #_map \], "_RBRACK_",
      #_map \/, "_SLASH_",
      #_map \\, "_BSLASH_",
      #_map \?, "_QMARK_"
    )))

    (§ def #_"IPersistentMap" DEMUNGE_MAP nil)
    (§ def #_"Pattern" DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" m (ß RT.map("$", \/))]
            (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(CHAR_MAP)))] (some? s) [(§ ass s (ß s.next()))]
                (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                    (let [#_"Character" origCh (ß (Character) e.key())]
                        (let [#_"String" escapeStr (ß (String) e.val())]
                            (§ ass m (ß m.assoc(escapeStr, origCh)))
                        )
                    )
                )
            )
            (§ ass DEMUNGE_MAP m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired. Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" mungeStrs (ß RT.toArray(RT.keys(m)))]
                (ß Arrays.sort(mungeStrs,
                        (§ reify Comparator()
                            #_method
                            (§ defn #_"int" compare [#_"Comparator" this, #_"Object" s1, #_"Object" s2]
                                (ß ((String) s2).length() - ((String) s1).length())
                            )
                        )
                    )
                )
                (let [#_"StringBuilder" sb (StringBuilder.)]
                    (let [#_"boolean" first true]
                        (doseq [#_"Object" s mungeStrs]
                            (let [#_"String" escapeStr (ß (String) s)]
                                (when (ß !first)
                                    (ß sb.append("|"))
                                )
                                (§ ass first false)
                                (ß sb.append("\\Q"))
                                (ß sb.append(escapeStr))
                                (ß sb.append("\\E"))
                            )
                        )
                        (§ ass DEMUNGE_PATTERN (ß Pattern.compile(sb.toString())))
                    )
                )
            )
        )
    )

    (§ defn #_"String" munge [#_"String" name]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (doseq [#_"char" c (ß name.toCharArray())]
                (let [#_"String" sub (ß (String) CHAR_MAP.valAt(c))]
                    (if (some? sub)
                        (do
                            (ß sb.append(sub))
                        )
                        (do
                            (ß sb.append(c))
                        )
                    )
                )
            )
            (ß sb.toString())
        )
    )

    (§ defn #_"String" demunge [#_"String" mungedName]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (let [#_"Matcher" m (ß DEMUNGE_PATTERN.matcher(mungedName))]
                (let [#_"int" lastMatchEnd 0]
                    (while (ß m.find())
                        (let [#_"int" start (ß m.start())]
                            (let [#_"int" end (ß m.end())]
                                ;; Keep everything before the match
                                (ß sb.append(mungedName.substring(lastMatchEnd, start)))
                                (§ ass lastMatchEnd end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" origCh (ß (Character) DEMUNGE_MAP.valAt(m.group()))]
                                    (ß sb.append(origCh))
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß sb.append(mungedName.substring(lastMatchEnd)))
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns EmptyExpr (§ implements Expr)
        (§ def #_"Type" HASHMAP_TYPE (ß Type.getType(PersistentArrayMap.class)))
        (§ def #_"Type" HASHSET_TYPE (ß Type.getType(PersistentHashSet.class)))
        (§ def #_"Type" VECTOR_TYPE (ß Type.getType(PersistentVector.class)))
        (§ def #_"Type" IVECTOR_TYPE (ß Type.getType(IPersistentVector.class)))
        (§ def #_"Type" TUPLE_TYPE (ß Type.getType(Tuple.class)))
        (§ def #_"Type" LIST_TYPE (ß Type.getType(PersistentList.class)))
        (§ def #_"Type" EMPTY_LIST_TYPE (ß Type.getType(PersistentList.EmptyList.class)))

        (§ init
            (§ field #_"Object" coll nil)
        )

        (§ constructor #_"EmptyExpr" EmptyExpr [#_"Object" coll]
            (let [this (ß super())]
                (§ ass (ß this.coll) coll)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"EmptyExpr" this]
            coll
        )

        #_method
        (§ defn #_"void" emit [#_"EmptyExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (cond (ß coll instanceof IPersistentList)
                (do
                    (ß gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE))
                )
                (ß coll instanceof IPersistentVector)
                (do
                    (ß gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE))
                )
                (ß coll instanceof IPersistentMap)
                (do
                    (ß gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE))
                )
                (ß coll instanceof IPersistentSet)
                (do
                    (ß gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE))
                )
                :else
                (do
                    (throw (UnsupportedOperationException. "Unknown Collection type"))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"EmptyExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"EmptyExpr" this]
            (cond (ß coll instanceof IPersistentList)
                (do
                    (ß IPersistentList.class)
                )
                (ß coll instanceof IPersistentVector)
                (do
                    (ß IPersistentVector.class)
                )
                (ß coll instanceof IPersistentMap)
                (do
                    (ß IPersistentMap.class)
                )
                (ß coll instanceof IPersistentSet)
                (do
                    (ß IPersistentSet.class)
                )
                :else
                (do
                    (throw (UnsupportedOperationException. "Unknown Collection type"))
                )
            )
        )
    )

    (class-ns ListExpr (§ implements Expr)
        (§ def #_"Method" arrayToListMethod (ß Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])")))

        (§ init
            (§ field #_"IPersistentVector" args nil)
        )

        (§ constructor #_"ListExpr" ListExpr [#_"IPersistentVector" args]
            (let [this (ß super())]
                (§ ass (ß this.args) args)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"ListExpr" this]
            (let [#_"IPersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                    (§ ass ret (ß (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval())))
                )
                (ß ret.seq())
            )
        )

        #_method
        (§ defn #_"void" emit [#_"ListExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß MethodExpr.emitArgsAsArray(args, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, arrayToListMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"ListExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"ListExpr" this]
            (ß IPersistentList.class)
        )
    )

    (class-ns MapExpr (§ implements Expr)
        (§ def #_"Method" mapMethod (ß Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
        (§ def #_"Method" mapUniqueKeysMethod (ß Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])")))

        (§ init
            (§ field #_"IPersistentVector" keyvals nil)
        )

        (§ constructor #_"MapExpr" MapExpr [#_"IPersistentVector" keyvals]
            (let [this (ß super())]
                (§ ass (ß this.keyvals) keyvals)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"MapExpr" this]
            (let [#_"Object[]" ret (ß new Object[keyvals.count()])]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < keyvals.count()) [(§ ass i (ß i + 1))]
                    (§ ass (ß ret[i]) (ß ((Expr) keyvals.nth(i)).eval()))
                )
                (ß RT.map(ret))
            )
        )

        #_method
        (§ defn #_"void" emit [#_"MapExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"boolean" allKeysConstant true]
                (let [#_"boolean" allConstantKeysUnique true]
                    (let [#_"IPersistentSet" constantKeys (ß PersistentHashSet.EMPTY)]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < keyvals.count()) [(ß i+=2)]
                            (let [#_"Expr" k (ß (Expr) keyvals.nth(i))]
                                (if (ß k instanceof LiteralExpr)
                                    (do
                                        (let [#_"Object" kval (ß k.eval())]
                                            (if (ß constantKeys.contains(kval))
                                                (do
                                                    (§ ass allConstantKeysUnique false)
                                                )
                                                (do
                                                    (§ ass constantKeys (ß (IPersistentSet)constantKeys.cons(kval)))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (§ ass allKeysConstant false)
                                    )
                                )
                            )
                        )
                        (ß MethodExpr.emitArgsAsArray(keyvals, objx, gen))
                        (if (ß (allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2))
                            (do
                                (ß gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod))
                            )
                            (do
                                (ß gen.invokeStatic(RT_TYPE, mapMethod))
                            )
                        )
                        (when (ß context == C.STATEMENT)
                            (ß gen.pop())
                        )
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"MapExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"MapExpr" this]
            (ß IPersistentMap.class)
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"IPersistentMap" form]
            (let [#_"IPersistentVector" keyvals (ß PersistentVector.EMPTY)]
                (let [#_"boolean" keysConstant true]
                    (let [#_"boolean" valsConstant true]
                        (let [#_"boolean" allConstantKeysUnique true]
                            (let [#_"IPersistentSet" constantKeys (ß PersistentHashSet.EMPTY)]
                                (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(form)))] (some? s) [(§ ass s (ß s.next()))]
                                    (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                                        (let [#_"Expr" k (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key()))]
                                            (let [#_"Expr" v (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val()))]
                                                (§ ass keyvals (ß (IPersistentVector) keyvals.cons(k)))
                                                (§ ass keyvals (ß (IPersistentVector) keyvals.cons(v)))
                                                (if (ß k instanceof LiteralExpr)
                                                    (do
                                                        (let [#_"Object" kval (ß k.eval())]
                                                            (if (ß constantKeys.contains(kval))
                                                                (do
                                                                    (§ ass allConstantKeysUnique false)
                                                                )
                                                                (do
                                                                    (§ ass constantKeys (ß (IPersistentSet)constantKeys.cons(kval)))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (do
                                                        (§ ass keysConstant false)
                                                    )
                                                )
                                                (when (ß !(v instanceof LiteralExpr))
                                                    (§ ass valsConstant false)
                                                )
                                            )
                                        )
                                    )
                                )

                                (let [#_"Expr" ret (MapExpr. keyvals)]
                                    (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                                        (do
                                            (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                                        )
                                        keysConstant
                                        (do
                                            ;; TBD: Add more detail to exception thrown below.
                                            (when (ß !allConstantKeysUnique)
                                                (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                                            )
                                            (if valsConstant
                                                (do
                                                    (let [#_"IPersistentMap" m (ß PersistentArrayMap.EMPTY)]
                                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < keyvals.length()) [(§ ass i (ß i + 2))]
                                                            (§ ass m (ß m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val())))
                                                        )
                                                        (ConstantExpr. m)
                                                    )
                                                )
                                                (do
                                                    ret
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SetExpr (§ implements Expr)
        (§ def #_"Method" setMethod (ß Method.getMethod("cloiure.lang.IPersistentSet set(Object[])")))

        (§ init
            (§ field #_"IPersistentVector" keys nil)
        )

        (§ constructor #_"SetExpr" SetExpr [#_"IPersistentVector" keys]
            (let [this (ß super())]
                (§ ass (ß this.keys) keys)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"SetExpr" this]
            (let [#_"Object[]" ret (ß new Object[keys.count()])]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < keys.count()) [(§ ass i (ß i + 1))]
                    (§ ass (ß ret[i]) (ß ((Expr) keys.nth(i)).eval()))
                )
                (ß RT.set(ret))
            )
        )

        #_method
        (§ defn #_"void" emit [#_"SetExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß MethodExpr.emitArgsAsArray(keys, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, setMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"SetExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"SetExpr" this]
            (ß IPersistentSet.class)
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"IPersistentSet" form]
            (let [#_"IPersistentVector" keys (ß PersistentVector.EMPTY)]
                (let [#_"boolean" constant true]
                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(form)))] (some? s) [(§ ass s (ß s.next()))]
                        (let [#_"Object" e (ß s.first())]
                            (let [#_"Expr" expr (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e))]
                                (§ ass keys (ß (IPersistentVector) keys.cons(expr)))
                                (when (ß !(expr instanceof LiteralExpr))
                                    (§ ass constant false)
                                )
                            )
                        )
                    )
                    (let [#_"Expr" ret (SetExpr. keys)]
                        (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                            (do
                                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            constant
                            (do
                                (let [#_"IPersistentSet" set (ß PersistentHashSet.EMPTY)]
                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < keys.count()) [(§ ass i (ß i + 1))]
                                        (let [#_"LiteralExpr" ve (ß (LiteralExpr)keys.nth(i))]
                                            (§ ass set (ß (IPersistentSet)set.cons(ve.val())))
                                        )
                                    )
                                    (ConstantExpr. set)
                                )
                            )
                            :else
                            (do
                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorExpr (§ implements Expr)
        (§ def #_"Method" vectorMethod (ß Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))

        (§ init
            (§ field #_"IPersistentVector" args nil)
        )

        (§ constructor #_"VectorExpr" VectorExpr [#_"IPersistentVector" args]
            (let [this (ß super())]
                (§ ass (ß this.args) args)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"VectorExpr" this]
            (let [#_"IPersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                    (§ ass ret (ß (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval())))
                )
                ret
            )
        )

        #_method
        (§ defn #_"void" emit [#_"VectorExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß args.count() <= Tuple.MAX_SIZE)
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                        (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                    )
                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                )
                (do
                    (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                    (ß gen.invokeStatic(RT_TYPE, vectorMethod))
                )
            )

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"VectorExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"VectorExpr" this]
            (ß IPersistentVector.class)
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"IPersistentVector" form]
            (let [#_"boolean" constant true]
                (let [#_"IPersistentVector" args (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < form.count()) [(§ ass i (ß i + 1))]
                        (let [#_"Expr" v (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i)))]
                            (§ ass args (ß (IPersistentVector) args.cons(v)))
                            (when (ß !(v instanceof LiteralExpr))
                                (§ ass constant false)
                            )
                        )
                    )
                    (let [#_"Expr" ret (VectorExpr. args)]
                        (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                            (do
                                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            constant
                            (do
                                (let [#_"IPersistentVector" rv (ß PersistentVector.EMPTY)]
                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                                        (let [#_"LiteralExpr" ve (ß (LiteralExpr)args.nth(i))]
                                            (§ ass rv (ß rv.cons(ve.val())))
                                        )
                                    )
                                    (ConstantExpr. rv)
                                )
                            )
                            :else
                            (do
                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns KeywordInvokeExpr (§ implements Expr)
        (§ def #_"Type" ILOOKUP_TYPE (ß Type.getType(ILookup.class)))

        (§ init
            (§ field #_"KeywordExpr" kw nil)
            (§ field #_"Object" tag nil)
            (§ field #_"Expr" target nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"int" siteIndex 0)
            (§ field #_"String" source nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"KeywordInvokeExpr" KeywordInvokeExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"KeywordExpr" kw, #_"Expr" target]
            (let [this (ß super())]
                (§ ass (ß this.source) source)
                (§ ass (ß this.kw) kw)
                (§ ass (ß this.target) target)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.tag) tag)
                (§ ass (ß this.siteIndex) (ß registerKeywordCallsite(kw.k)))
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"KeywordInvokeExpr" this]
            (try
                (ß kw.k.invoke(target.eval()))
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [#_"KeywordInvokeExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" endLabel (ß gen.newLabel())]
                (let [#_"Label" faultLabel (ß gen.newLabel())]
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE))
                    (ß gen.dup()) ;; thunk, thunk
                    (ß target.emit(C.EXPRESSION, objx, gen)) ;; thunk, thunk, target
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.dupX2()) ;; target, thunk, thunk, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; target, thunk, result
                    (ß gen.dupX2()) ;; result, target, thunk, result
                    (ß gen.visitJumpInsn(IF_ACMPEQ, faultLabel)) ;; result, target
                    (ß gen.pop()) ;; result
                    (ß gen.goTo(endLabel))

                    (ß gen.mark(faultLabel)) ;; result, target
                    (ß gen.swap()) ;; target, result
                    (ß gen.pop()) ;; target
                    (ß gen.dup()) ;; target, target
                    (ß gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                    (ß gen.swap()) ;; target, site, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                    (ß gen.dup()) ;; target, new-thunk, new-thunk
                    (ß gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                    (ß gen.swap()) ;; new-thunk, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; result

                    (ß gen.mark(endLabel))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                    nil
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"KeywordInvokeExpr" this]
            (ß (tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"KeywordInvokeExpr" this]
            (when (nil? jc)
                (§ ass jc (ß HostExpr.tagToClass(tag)))
            )
            jc
        )
    )

    (class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"Expr" expr nil)
            (§ field #_"Class" c nil)
        )

        (§ constructor #_"InstanceOfExpr" InstanceOfExpr [#_"Class" c, #_"Expr" expr]
            (let [this (ß super())]
                (§ ass (ß this.expr) expr)
                (§ ass (ß this.c) c)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"InstanceOfExpr" this]
            (when (ß c.isInstance(expr.eval()))
                (§ return (ß RT.T))
            )
            (ß RT.F)
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"InstanceOfExpr" this]
            true
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"InstanceOfExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.instanceOf(getType(c)))
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"InstanceOfExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emitUnboxed(context, objx, gen))
            (ß HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"InstanceOfExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"InstanceOfExpr" this]
            (ß Boolean.TYPE)
        )
    )

    (class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"Type" target nil)
            (§ field #_"Class" retClass nil)
            (§ field #_"Class[]" paramclasses nil)
            (§ field #_"Type[]" paramtypes nil)
            (§ field #_"IPersistentVector" args nil)
            (§ field #_"boolean" variadic false)
            (§ field #_"boolean" tailPosition false)
            (§ field #_"Object" tag nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"StaticInvokeExpr" StaticInvokeExpr [#_"Type" target, #_"Class" retClass, #_"Class[]" paramclasses, #_"Type[]" paramtypes, #_"boolean" variadic, #_"IPersistentVector" args, #_"Object" tag, #_"boolean" tailPosition]
            (let [this (ß super())]
                (§ ass (ß this.target) target)
                (§ ass (ß this.retClass) retClass)
                (§ ass (ß this.paramclasses) paramclasses)
                (§ ass (ß this.paramtypes) paramtypes)
                (§ ass (ß this.args) args)
                (§ ass (ß this.variadic) variadic)
                (§ ass (ß this.tailPosition) tailPosition)
                (§ ass (ß this.tag) tag)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"StaticInvokeExpr" this]
            (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
        )

        #_method
        (§ defn #_"void" emit [#_"StaticInvokeExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emitUnboxed(context, objx, gen))
            (when (ß context != C.STATEMENT)
                (ß HostExpr.emitBoxReturn(objx, gen, retClass))
            )
            (when (ß context == C.STATEMENT)
                (if (ß retClass == long.class || retClass == double.class)
                    (do
                        (ß gen.pop2())
                    )
                    (do
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"StaticInvokeExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"StaticInvokeExpr" this]
            (when (nil? jc)
                (§ ass jc (ß retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, retClass)))
            )
            jc
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"StaticInvokeExpr" this]
            (ß retClass.isPrimitive())
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"StaticInvokeExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Method" ms (ß new Method("invokeStatic", getReturnType(), paramtypes))]
                (if variadic
                    (do
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < paramclasses.length - 1) [(§ ass i (ß i + 1))]
                            (let [#_"Expr" e (ß (Expr) args.nth(i))]
                                (if (ß maybePrimitiveType(e) == paramclasses[i])
                                    (do
                                        (ß ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen))
                                    )
                                    (do
                                        (ß e.emit(C.EXPRESSION, objx, gen))
                                        (ß HostExpr.emitUnboxArg(objx, gen, paramclasses[i]))
                                    )
                                )
                            )
                        )
                        (let [#_"IPersistentVector" restArgs (ß RT.subvec(args, paramclasses.length - 1, args.count()))]
                            (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                            (ß gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])")))
                        )
                    )
                    (do
                        (ß MethodExpr.emitTypedArgs(objx, gen, paramclasses, args))
                    )
                )

                (when (ß tailPosition && !objx.canBeDirect)
                    (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                        (ß method.emitClearThis(gen))
                    )
                )

                (ß gen.invokeStatic(target, ms))
                nil
            )
        )

        #_method
        (§ defn- #_"Type" getReturnType [#_"StaticInvokeExpr" this]
            (ß Type.getType(retClass))
        )

        (§ defn #_"Expr" parse [#_"Var" v, #_"ISeq" args, #_"Object" tag, #_"boolean" tailPosition]
            (when (ß !v.isBound() || v.get() == nil)
                (§ return nil)
            )
            (let [#_"Class" c (ß v.get().getClass())]
                (let [#_"String" cname (ß c.getName())]
                    (let [(§ var #_"java.lang.reflect.Method[]" allmethods (ß c.getMethods()))]
                        (let [#_"boolean" variadic false]
                            (let [#_"int" argcount (ß RT.count(args))]
                                (let [(§ var #_"java.lang.reflect.Method" method nil)]
                                    (doseq [#_"java.lang.reflect.Method" m allmethods]
                                        (when (ß Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic"))
                                            (let [#_"Class[]" params (ß m.getParameterTypes())]
                                                (cond (ß argcount == params.length)
                                                    (do
                                                        (§ ass method m)
                                                        (§ ass variadic (ß (argcount > 0 && params[params.length - 1] == ISeq.class)))
                                                        (§ break )
                                                    )
                                                    (ß argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class)
                                                    (do
                                                        (§ ass method m)
                                                        (§ ass variadic true)
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (when (nil? method)
                                        (§ return nil)
                                    )

                                    (let [#_"Class" retClass (ß method.getReturnType())]
                                        (let [#_"Class[]" paramClasses (ß method.getParameterTypes())]
                                            (let [#_"Type[]" paramTypes (ß new Type[paramClasses.length])]
                                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < paramClasses.length) [(§ ass i (ß i + 1))]
                                                    (§ ass (ß paramTypes[i]) (ß Type.getType(paramClasses[i])))
                                                )

                                                (let [#_"Type" target (ß Type.getType(c))]
                                                    (let [#_"PersistentVector" argv (ß PersistentVector.EMPTY)]
                                                        (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(args)))] (some? s) [(§ ass s (ß s.next()))]
                                                            (§ ass argv (ß argv.cons(analyze(C.EXPRESSION, s.first()))))
                                                        )

                                                        (ß new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns InvokeExpr (§ implements Expr)
        (§ def #_"Keyword" onKey (ß Keyword.intern("on")))
        (§ def #_"Keyword" methodMapKey (ß Keyword.intern("method-map")))

        (§ defn #_"Object" sigTag [#_"int" argcount, #_"Var" v]
            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                (let [#_"Object" sigTag nil]
                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(arglists)))] (some? s) [(§ ass s (ß s.next()))]
                        (let [#_"APersistentVector" sig (ß (APersistentVector) s.first())]
                            (let [#_"int" restOffset (ß sig.indexOf(_AMP_))]
                                (when (ß argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))
                                    (§ return (ß tagOf(sig)))
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )

        (§ init
            (§ field #_"Expr" fexpr nil)
            (§ field #_"Object" tag nil)
            (§ field #_"IPersistentVector" args nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"boolean" tailPosition false)
            (§ field #_"String" source nil)

            (§ field #_"boolean" isProtocol false)
            (§ field #_"boolean" isDirect false)
            (§ field #_"int" siteIndex -1)
            (§ field #_"Class" protocolOn nil)
            (§ field #_"java.lang.reflect.Method" onMethod nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"InvokeExpr" InvokeExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" fexpr, #_"IPersistentVector" args, #_"boolean" tailPosition]
            (let [this (ß super())]
                (§ ass (ß this.source) source)
                (§ ass (ß this.fexpr) fexpr)
                (§ ass (ß this.args) args)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.tailPosition) tailPosition)

                (when (ß fexpr instanceof VarExpr)
                    (let [#_"Var" fvar (ß ((VarExpr)fexpr).var)]
                        (let [#_"Var" pvar (ß (Var)RT.get(fvar.meta(), protocolKey))]
                            (when (ß pvar != nil && PROTOCOL_CALLSITES.isBound())
                                (§ ass (ß this.isProtocol) true)
                                (§ ass (ß this.siteIndex) (ß registerProtocolCallsite(((VarExpr)fexpr).var)))
                                (let [#_"Object" pon (ß RT.get(pvar.get(), onKey))]
                                    (§ ass (ß this.protocolOn) (ß HostExpr.maybeClass(pon, false)))
                                    (when (ß this.protocolOn != nil)
                                        (let [#_"IPersistentMap" mmap (ß (IPersistentMap) RT.get(pvar.get(), methodMapKey))]
                                            (let [#_"Keyword" mmapVal (ß (Keyword) mmap.valAt(Keyword.intern(fvar.sym)))]
                                                (when (nil? mmapVal)
                                                    (throw (ß new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)")))
                                                )
                                                (let [#_"String" mname (ß munge(mmapVal.sym.toString()))]
                                                    (let [#_"List" methods (ß Reflector.getMethods(protocolOn, args.count() - 1, mname, false))]
                                                        (when (ß methods.size() != 1)
                                                            (throw (ß new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym)))
                                                        )
                                                        (§ ass (ß this.onMethod) (ß (java.lang.reflect.Method) methods.get(0)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (cond (some? tag)
                    (do
                        (§ ass (ß this.tag) tag)
                    )
                    (ß fexpr instanceof VarExpr)
                    (do
                        (let [#_"Var" v (ß ((VarExpr) fexpr).var)]
                            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                (let [#_"Object" sigTag (ß sigTag(args.count(), v))]
                                    (§ ass (ß this.tag) (ß (sigTag == nil) ? ((VarExpr) fexpr).tag :or sigTag))
                                )
                            )
                        )
                    )
                    :else
                    (do
                        (§ ass (ß this.tag) nil)
                    )
                )
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"InvokeExpr" this]
            (try
                (let [#_"IFn" fn (ß (IFn) fexpr.eval())]
                    (let [#_"PersistentVector" argvs (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                            (§ ass argvs (ß argvs.cons(((Expr) args.nth(i)).eval())))
                        )
                        (ß fn.applyTo(RT.seq(Util.ret1(argvs, (§ ass argvs nil)))))
                    )
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [#_"InvokeExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if isProtocol
                (do
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß emitProto(context, objx, gen))
                )
                (do
                    (ß fexpr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(IFN_TYPE))
                    (ß emitArgsAndCall(0, context, objx, gen))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"void" emitProto [#_"InvokeExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" onLabel (ß gen.newLabel())]
                (let [#_"Label" callLabel (ß gen.newLabel())]
                    (let [#_"Label" endLabel (ß gen.newLabel())]
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (let [#_"Expr" e (ß (Expr) args.nth(0))]
                                (ß e.emit(C.EXPRESSION, objx, gen))
                                (ß gen.dup()) ;; target, target
                                (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
                                (ß gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target, class, cached-class
                                (ß gen.visitJumpInsn(IF_ACMPEQ, callLabel)) ;; target
                                (when (some? protocolOn)
                                    (ß gen.dup()) ;; target, target
                                    (ß gen.instanceOf(Type.getType(protocolOn)))
                                    (ß gen.ifZCmp(GeneratorAdapter.NE, onLabel))
                                )

                                (ß gen.dup()) ;; target, target
                                (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
                                (ß gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target

                                (ß gen.mark(callLabel)) ;; target
                                (ß objx.emitVar(gen, v))
                                (ß gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))) ;; target, proto-fn
                                (ß gen.swap())
                                (ß emitArgsAndCall(1, context, objx, gen))
                                (ß gen.goTo(endLabel))

                                (ß gen.mark(onLabel)) ;; target
                                (when (some? protocolOn)
                                    (ß gen.checkCast(Type.getType(protocolOn)))
                                    (ß MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count())))
                                    (when (ß context == C.RETURN)
                                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                            (ß method.emitClearLocals(gen))
                                        )
                                    )
                                    (let [#_"Method" m (ß new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod)))]
                                        (ß gen.invokeInterface(Type.getType(protocolOn), m))
                                        (ß HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType()))
                                    )
                                )
                                (ß gen.mark(endLabel))
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emitArgsAndCall [#_"InvokeExpr" this, #_"int" firstArgToEmit, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(§ var #_"int" i firstArgToEmit)] (ß i < Math.min(MAX_POSITIONAL_ARITY, args.count())) [(§ ass i (ß i + 1))]
                (let [#_"Expr" e (ß (Expr) args.nth(i))]
                    (ß e.emit(C.EXPRESSION, objx, gen))
                )
            )
            (when (ß args.count() > MAX_POSITIONAL_ARITY)
                (let [#_"PersistentVector" restArgs (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(§ var #_"int" i MAX_POSITIONAL_ARITY)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                        (§ ass restArgs (ß restArgs.cons(args.nth(i))))
                    )
                    (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                )
            )
            (ß gen.visitLineNumber(line, gen.mark()))

            (when (ß tailPosition && !objx.canBeDirect)
                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                    (ß method.emitClearThis(gen))
                )
            )

            (ß gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())])))
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"InvokeExpr" this]
            (ß (tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"InvokeExpr" this]
            (when (nil? jc)
                (§ ass jc (ß HostExpr.tagToClass(tag)))
            )
            jc
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"ISeq" form]
            (let [#_"boolean" tailPosition (ß inTailCall(context))]
                (when (ß context != C.EVAL)
                    (§ ass context (ß C.EXPRESSION))
                )
                (let [#_"Expr" fexpr (ß analyze(context, form.first()))]
                    (when (ß fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3)
                        (let [#_"Expr" sexpr (ß analyze(C.EXPRESSION, RT.second(form)))]
                            (when (ß sexpr instanceof ConstantExpr)
                                (let [#_"Object" val (ß ((ConstantExpr) sexpr).val())]
                                    (when (ß val instanceof Class)
                                        (§ return (ß new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))))
                                    )
                                )
                            )
                        )
                    )

                    (when (ß RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL)
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (when (ß !v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false)))
                                (let [#_"Symbol" formtag (ß tagOf(form))]
                                    (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                        (let [#_"int" arity (ß RT.count(form.next()))]
                                            (let [#_"Object" sigtag (ß sigTag(arity, v))]
                                                (let [#_"Object" vtag (ß RT.get(RT.meta(v), RT.TAG_KEY))]
                                                    (let [#_"Expr" ret (ß StaticInvokeExpr.parse(v, RT.next(form), (formtag != nil) ? formtag :or (sigtag != nil) ? sigtag :or vtag, tailPosition))]
                                                        (when (some? ret)
                                                            (§ return ret)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (ß fexpr instanceof VarExpr && context != C.EVAL)
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                (let [#_"int" arity (ß RT.count(form.next()))]
                                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(arglists)))] (some? s) [(§ ass s (ß s.next()))]
                                        (let [#_"IPersistentVector" args (ß (IPersistentVector) s.first())]
                                            (when (ß args.count() == arity)
                                                (let [#_"String" primc (ß FnMethod.primInterface(args))]
                                                    (when (some? primc)
                                                        (§ return (ß analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"), ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))), form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))))
                                                    )
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (ß fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound())
                        (let [#_"Expr" target (ß analyze(context, RT.second(form)))]
                            (§ return (ß new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)))
                        )
                    )
                    (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(form.next())))] (some? s) [(§ ass s (ß s.next()))]
                            (§ ass args (ß args.cons(analyze(context, s.first()))))
                        )

                        (ß new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition))
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns SourceDebugExtensionAttribute (§ extends Attribute)
        (§ constructor #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute []
            (let [this (ß super("SourceDebugExtension"))]
                this
            )
        )

        #_method
        (§ defn #_"void" writeSMAP [#_"SourceDebugExtensionAttribute" this, #_"ClassWriter" cw, #_"String" smap]
            (let [#_"ByteVector" bv (ß write(cw, nil, -1, -1, -1))]
                (ß bv.putUTF8(smap))
                nil
            )
        )
    )

    (class-ns FnExpr (§ extends ObjExpr)
        (§ def #_"Type" aFnType (ß Type.getType(AFunction.class)))
        (§ def #_"Type" restFnType (ß Type.getType(RestFn.class)))

        (§ init
            ;; if there is a variadic overload (there can only be one) it is stored here
            (§ field #_"FnMethod" variadicMethod nil)
            (§ field #_"IPersistentCollection" methods nil)
            (§ field- #_"boolean" hasPrimSigs false)
            (§ field- #_"boolean" hasMeta false)
            (§ field- #_"boolean" hasEnclosingMethod false)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"FnExpr" FnExpr [#_"Object" tag]
            (let [this (ß super(tag))]
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"FnExpr" this]
            true
        )

        #_method
        (§ defn #_"boolean" supportsMeta [#_"FnExpr" this]
            hasMeta
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"FnExpr" this]
            (when (nil? jc)
                (§ ass jc (ß (tag != nil) ? HostExpr.tagToClass(tag) :or AFunction.class))
            )
            jc
        )

        #_protected
        #_method
        (§ defn #_"void" emitMethods [#_"FnExpr" this, #_"ClassVisitor" cv]
            ;; override of invoke/doInvoke for each method
            (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(methods)))] (some? s) [(§ ass s (ß s.next()))]
                (let [#_"ObjMethod" method (ß (ObjMethod) s.first())]
                    (ß method.emit(this, cv))
                )
            )

            (when (ß isVariadic())
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), nil, nil, cv))]
                    (ß gen.visitCode())
                    (ß gen.push(variadicMethod.reqParms.count()))
                    (ß gen.returnValue())
                    (ß gen.endMethod())
                )
            )
            nil
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"ISeq" form, #_"String" name]
            (let [#_"ISeq" origForm form]
                (let [#_"FnExpr" fn (ß new FnExpr(tagOf(form)))]
                    (let [#_"Keyword" retkey (ß Keyword.intern(nil, "rettag"))]
                        (let [#_"Object" rettag (ß RT.get(RT.meta(form), retkey))]
                            (§ ass (ß fn.src) form)
                            (let [#_"ObjMethod" enclosingMethod (ß (ObjMethod) METHOD.deref())]
                                (§ ass (ß fn.hasEnclosingMethod) (ß enclosingMethod != nil))
                                (when (ß ((IMeta) form.first()).meta() != nil)
                                    (§ ass (ß fn.onceOnly) (ß RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(nil, "once")))))
                                )

                                (let [#_"String" basename (ß ((enclosingMethod != nil) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$")]
                                    (let [#_"Symbol" nm nil]
                                        (if (ß RT.second(form) instanceof Symbol)
                                            (do
                                                (§ ass nm (ß (Symbol) RT.second(form)))
                                                (§ ass name (ß nm.name + "__" + RT.nextID()))
                                            )
                                            (do
                                                (cond (nil? name)
                                                    (do
                                                        (§ ass name (ß "fn__" + RT.nextID()))
                                                    )
                                                    (some? enclosingMethod)
                                                    (do
                                                        (§ ass name (ß name + "__" + RT.nextID()))
                                                    )
                                                )
                                            )
                                        )

                                        (let [#_"String" simpleName (ß munge(name).replace(".", "_DOT_"))]
                                            (§ ass (ß fn.name) (ß basename + simpleName))
                                            (§ ass (ß fn.internalName) (ß fn.name.replace(\., \/)))
                                            (§ ass (ß fn.objtype) (ß Type.getObjectType(fn.internalName)))
                                            (let [#_"ArrayList<String>" prims (ArrayList.)]
                                                (try
                                                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                        #_map CONSTANTS, PersistentVector.EMPTY,
                                                        #_map CONSTANT_IDS, new IdentityHashMap(),
                                                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                                                        #_map VARS, PersistentHashMap.EMPTY,
                                                        #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                                                        #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                                                        #_map VAR_CALLSITES, emptyVarCallSites(),
                                                        #_map NO_RECUR, nil
                                                    )))

                                                    ;; arglist might be preceded by symbol naming this fn
                                                    (when (some? nm)
                                                        (§ ass (ß fn.thisName) (ß nm.name))
                                                        (§ ass form (ß RT.cons(FN, RT.next(RT.next(form)))))
                                                    )

                                                    ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                    ;; turn former into latter
                                                    (when (ß RT.second(form) instanceof IPersistentVector)
                                                        (§ ass form (ß RT.list(FN, RT.next(form))))
                                                    )
                                                    (§ ass (ß fn.line) (ß lineDeref()))
                                                    (§ ass (ß fn.column) (ß columnDeref()))
                                                    (let [#_"FnMethod[]" methodArray (ß new FnMethod[MAX_POSITIONAL_ARITY + 1])]
                                                        (let [#_"FnMethod" variadicMethod nil]
                                                            (let [#_"boolean" usesThis false]
                                                                (loop-when-recur [(§ var #_"ISeq" s (ß RT.next(form)))] (some? s) [(§ ass s (ß RT.next(s)))]
                                                                    (let [#_"FnMethod" f (ß FnMethod.parse(fn, (ISeq) RT.first(s), rettag))]
                                                                        (when (ß f.usesThis)
                                                                            (§ ass usesThis true)
                                                                        )
                                                                        (cond (ß f.isVariadic())
                                                                            (do
                                                                                (if (nil? variadicMethod)
                                                                                    (do
                                                                                        (§ ass variadicMethod f)
                                                                                    )
                                                                                    (do
                                                                                        (throw (ß Util.runtimeException("Can't have more than 1 variadic overload")))
                                                                                    )
                                                                                )
                                                                            )
                                                                            (ß methodArray[f.reqParms.count()] == nil)
                                                                            (do
                                                                                (§ ass (ß methodArray[f.reqParms.count()]) f)
                                                                            )
                                                                            :else
                                                                            (do
                                                                                (throw (ß Util.runtimeException("Can't have 2 overloads with same arity")))
                                                                            )
                                                                        )
                                                                        (when (ß f.prim != nil)
                                                                            (ß prims.add(f.prim))
                                                                        )
                                                                    )
                                                                )
                                                                (when (some? variadicMethod)
                                                                    (loop-when-recur [(§ var #_"int" i (ß variadicMethod.reqParms.count() + 1))] (ß i <= MAX_POSITIONAL_ARITY) [(§ ass i (ß i + 1))]
                                                                        (when (ß methodArray[i] != nil)
                                                                            (throw (ß Util.runtimeException("Can't have fixed arity function with more params than variadic function")))
                                                                        )
                                                                    )
                                                                )

                                                                (§ ass (ß fn.canBeDirect) (ß (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis)))

                                                                (let [#_"IPersistentCollection" methods nil]
                                                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < methodArray.length) [(§ ass i (ß i + 1))]
                                                                        (when (ß methodArray[i] != nil)
                                                                            (§ ass methods (ß RT.conj(methods, methodArray[i])))
                                                                        )
                                                                    )
                                                                    (when (some? variadicMethod)
                                                                        (§ ass methods (ß RT.conj(methods, variadicMethod)))
                                                                    )

                                                                    (when (ß fn.canBeDirect)
                                                                        (doseq [#_"FnMethod" fm (ß (Collection<FnMethod>)methods)]
                                                                            (when (ß fm.locals != nil)
                                                                                (doseq [#_"LocalBinding" lb (ß (Collection<LocalBinding>)RT.keys(fm.locals))]
                                                                                    (when (ß lb.isArg)
                                                                                        (§ ass (ß lb.idx) (ß lb.idx - 1))
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )

                                                                    (§ ass (ß fn.methods) methods)
                                                                    (§ ass (ß fn.variadicMethod) variadicMethod)
                                                                    (§ ass (ß fn.keywords) (ß (IPersistentMap) KEYWORDS.deref()))
                                                                    (§ ass (ß fn.vars) (ß (IPersistentMap) VARS.deref()))
                                                                    (§ ass (ß fn.constants) (ß (PersistentVector) CONSTANTS.deref()))
                                                                    (§ ass (ß fn.keywordCallsites) (ß (IPersistentVector) KEYWORD_CALLSITES.deref()))
                                                                    (§ ass (ß fn.protocolCallsites) (ß (IPersistentVector) PROTOCOL_CALLSITES.deref()))
                                                                    (§ ass (ß fn.varCallsites) (ß (IPersistentSet) VAR_CALLSITES.deref()))

                                                                    (§ ass (ß fn.constantsID) (ß RT.nextID()))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (finally
                                                        (ß Var.popThreadBindings())
                                                    )
                                                )
                                                (§ ass (ß fn.hasPrimSigs) (ß prims.size() > 0))
                                                (let [#_"IPersistentMap" fmeta (ß RT.meta(origForm))]
                                                    (when (some? fmeta)
                                                        (§ ass fmeta (ß fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey)))
                                                    )

                                                    (§ ass (ß fn.hasMeta) (ß RT.count(fmeta) > 0))

                                                    (try
                                                        (ß fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? nil :or prims.toArray(new String[prims.size()]), fn.onceOnly))
                                                        (catch IOException e
                                                            (throw (ß Util.sneakyThrow(e)))
                                                        )
                                                    )
                                                    (ß fn.getCompiledClass())

                                                    (if (ß fn.supportsMeta())
                                                        (do
                                                            (ß new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta)))
                                                        )
                                                        (do
                                                            fn
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"ObjMethod" variadicMethod [#_"FnExpr" this]
            variadicMethod
        )

        #_method
        (§ defn #_"boolean" isVariadic [#_"FnExpr" this]
            (ß (variadicMethod != nil))
        )

        #_method
        (§ defn #_"IPersistentCollection" methods [#_"FnExpr" this]
            methods
        )

        #_method
        (§ defn #_"void" emitForDefn [#_"FnExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emit(C.EXPRESSION, objx, gen))
            nil
        )
    )

    (class-ns ObjExpr (§ implements Expr)
        (§ def #_"String" CONST_PREFIX "const__")

        (§ def #_"Method" voidctor (ß Method.getMethod("void <init>()")))

        (§ def #_"Method" kwintern (ß Method.getMethod("cloiure.lang.Keyword intern(String, String)")))
        (§ def #_"Method" symintern (ß Method.getMethod("cloiure.lang.Symbol intern(String)")))
        (§ def #_"Method" varintern (ß Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)")))

        (§ def #_"Type" DYNAMIC_CLASSLOADER_TYPE (ß Type.getType(DynamicClassLoader.class)))
        (§ def #_"Method" getClassMethod (ß Method.getMethod("Class getClass()")))
        (§ def #_"Method" getClassLoaderMethod (ß Method.getMethod("ClassLoader getClassLoader()")))
        (§ def #_"Method" getConstantsMethod (ß Method.getMethod("Object[] getConstants(int)")))
        (§ def #_"Method" readStringMethod (ß Method.getMethod("Object readString(String)")))

        (§ def #_"Type" ILOOKUP_SITE_TYPE (ß Type.getType(ILookupSite.class)))
        (§ def #_"Type" ILOOKUP_THUNK_TYPE (ß Type.getType(ILookupThunk.class)))
        (§ def #_"Type" KEYWORD_LOOKUPSITE_TYPE (ß Type.getType(KeywordLookupSite.class)))

        (§ init
            (§ field #_"String" name nil)
            (§ field #_"String" internalName nil)
            (§ field #_"String" thisName nil)
            (§ field #_"Type" objtype nil)
            (§ field #_"Object" tag nil)
            ;; localbinding->itself
            (§ field #_"IPersistentMap" closes (ß PersistentHashMap.EMPTY))
            ;; localbndingexprs
            (§ field #_"IPersistentVector" closesExprs (ß PersistentVector.EMPTY))
            ;; symbols
            (§ field #_"IPersistentSet" volatiles (ß PersistentHashSet.EMPTY))

            ;; symbol->lb
            (§ field #_"IPersistentMap" fields nil)

            ;; hinted fields
            (§ field #_"IPersistentVector" hintedFields (ß PersistentVector.EMPTY))

            ;; Keyword->KeywordExpr
            (§ field #_"IPersistentMap" keywords (ß PersistentHashMap.EMPTY))
            (§ field #_"IPersistentMap" vars (ß PersistentHashMap.EMPTY))
            (§ field #_"Class" compiledClass nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"PersistentVector" constants nil)
            (§ field #_"IPersistentSet" usedConstants (ß PersistentHashSet.EMPTY))

            (§ field #_"int" constantsID 0)
            (§ field #_"int" altCtorDrops 0)

            (§ field #_"IPersistentVector" keywordCallsites nil)
            (§ field #_"IPersistentVector" protocolCallsites nil)
            (§ field #_"IPersistentSet" varCallsites nil)
            (§ field #_"boolean" onceOnly false)

            (§ field #_"Object" src nil)

            (§ field #_"IPersistentMap" opts (ß PersistentHashMap.EMPTY))

            #_protected
            (§ field #_"IPersistentMap" classMeta nil)
            #_protected
            (§ field #_"boolean" canBeDirect false)

            (§ field- #_"DynamicClassLoader" loader nil)
            (§ field- #_"byte[]" bytecode nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"ObjExpr" ObjExpr [#_"Object" tag]
            (let [this (ß super())]
                (§ ass (ß this.tag) tag)
                this
            )
        )

        #_method
        (§ defn #_"String" name [#_"ObjExpr" this]
            name
        )

        #_method
        (§ defn #_"String" internalName [#_"ObjExpr" this]
            internalName
        )

        #_method
        (§ defn #_"String" thisName [#_"ObjExpr" this]
            thisName
        )

        #_method
        (§ defn #_"Type" objtype [#_"ObjExpr" this]
            objtype
        )

        #_method
        (§ defn #_"IPersistentMap" closes [#_"ObjExpr" this]
            closes
        )

        #_method
        (§ defn #_"IPersistentMap" keywords [#_"ObjExpr" this]
            keywords
        )

        #_method
        (§ defn #_"IPersistentMap" vars [#_"ObjExpr" this]
            vars
        )

        #_method
        (§ defn #_"Class" compiledClass [#_"ObjExpr" this]
            compiledClass
        )

        #_method
        (§ defn #_"int" line [#_"ObjExpr" this]
            line
        )

        #_method
        (§ defn #_"int" column [#_"ObjExpr" this]
            column
        )

        #_method
        (§ defn #_"PersistentVector" constants [#_"ObjExpr" this]
            constants
        )

        #_method
        (§ defn #_"int" constantsID [#_"ObjExpr" this]
            constantsID
        )

        (§ defn #_"String" trimGenID [#_"String" name]
            (let [#_"int" i (ß name.lastIndexOf("__"))]
                (ß (i == -1) ? name :or name.substring(0, i))
            )
        )

        #_method
        (§ defn #_"Type[]" ctorTypes [#_"ObjExpr" this]
            (let [#_"IPersistentVector" tv (ß !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE))]
                (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(closes)))] (some? s) [(§ ass s (ß s.next()))]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                        (if (ß lb.getPrimitiveType() != nil)
                            (do
                                (§ ass tv (ß tv.cons(Type.getType(lb.getPrimitiveType()))))
                            )
                            (do
                                (§ ass tv (ß tv.cons(OBJECT_TYPE)))
                            )
                        )
                    )
                )
                (let [#_"Type[]" ret (ß new Type[tv.count()])]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < tv.count()) [(§ ass i (ß i + 1))]
                        (§ ass (ß ret[i]) (ß (Type) tv.nth(i)))
                    )
                    ret
                )
            )
        )

        #_method
        (§ defn #_"void" compile [#_"ObjExpr" this, #_"String" superName, #_"String[]" interfaceNames, #_"boolean" oneTimeUse] (§ throws IOException)
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            (let [#_"ClassWriter" cw (ClassWriter. (ß ClassWriter.COMPUTE_MAXS))]
                (let [#_"ClassVisitor" cv cw]
                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, superName, interfaceNames))
                    (let [#_"String" source (ß (String) SOURCE.deref())]
                        (let [#_"int" lineBefore (ß (Integer) LINE_BEFORE.deref())]
                            (let [#_"int" lineAfter (ß (Integer) LINE_AFTER.deref() + 1)]
                                (let [#_"int" columnBefore (ß (Integer) COLUMN_BEFORE.deref())]
                                    (let [#_"int" columnAfter (ß (Integer) COLUMN_AFTER.deref() + 1)]
                                        (when (ß source != nil && SOURCE_PATH.deref() != nil)
                                            (let [#_"String" smap
                                                    (str "SMAP\n"
                                                        (ß (source.lastIndexOf(\.) > 0) ? source.substring(0, source.lastIndexOf(\.)) :or source) ;; :or simpleName
                                                        ".java\n"
                                                        "Cloiure\n"
                                                        "*S Cloiure\n"
                                                        "*F\n"
                                                        "+ 1 " source "\n"
                                                        (ß (String) SOURCE_PATH.deref()) "\n"
                                                        "*L\n"
                                                        (ß String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore))
                                                        "*E"
                                                    )]
                                                (ß cv.visitSource(source, smap))
                                            )
                                        )
                                        (ß addAnnotation(cv, classMeta))

                                        (when (ß supportsMeta())
                                            (ß cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                        )
                                        ;; instance fields for closed-overs
                                        (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(closes)))] (some? s) [(§ ass s (ß s.next()))]
                                            (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                (if (ß isDeftype())
                                                    (do
                                                        (let [#_"int" access (ß isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL))]
                                                            (§ let [#_"FieldVisitor" fv]
                                                                (if (ß lb.getPrimitiveType() != nil)
                                                                    (do
                                                                        (§ ass fv (ß cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil)))
                                                                    )
                                                                    (do
                                                                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                        (§ ass fv (ß cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil)))
                                                                    )
                                                                )
                                                                (ß addAnnotation(fv, RT.meta(lb.sym)))
                                                            )
                                                        )
                                                    )
                                                    (do
                                                        ;; todo - only enable this non-private+writability for letfns where we need it
                                                        (if (ß lb.getPrimitiveType() != nil)
                                                            (do
                                                                (ß cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                            )
                                                            (do
                                                                (ß cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        ;; static fields for callsites and thunks
                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < protocolCallsites.count()) [(§ ass i (ß i + 1))]
                                            (ß cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), nil, nil))
                                        )

                                        ;; ctor that takes closed-overs and inits base + fields
                                        (let [#_"Method" m (ß new Method("<init>", Type.VOID_TYPE, ctorTypes()))]
                                            (let [#_"GeneratorAdapter" ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))]
                                                (let [#_"Label" start (ß ctorgen.newLabel())]
                                                    (let [#_"Label" end (ß ctorgen.newLabel())]
                                                        (ß ctorgen.visitCode())
                                                        (ß ctorgen.visitLineNumber(line, ctorgen.mark()))
                                                        (ß ctorgen.visitLabel(start))
                                                        (ß ctorgen.loadThis())
                                                        (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))

                                                        (when (ß supportsMeta())
                                                            (ß ctorgen.loadThis())
                                                            (ß ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1))
                                                            (ß ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE))
                                                        )

                                                        (let [#_"int" a (ß supportsMeta() ? 2 :or 1)]
                                                            (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(closes)))] (some? s) [(§ ass s (ß s.next()), a (ß a + 1))]
                                                                (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                                    (ß ctorgen.loadThis())
                                                                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                                        (if (some? primc)
                                                                            (do
                                                                                (ß ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a))
                                                                                (ß ctorgen.putField(objtype, lb.name, Type.getType(primc)))
                                                                                (when (ß primc == Long.TYPE || primc == Double.TYPE)
                                                                                    (§ ass a (ß a + 1))
                                                                                )
                                                                            )
                                                                            (do
                                                                                (ß ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a))
                                                                                (ß ctorgen.putField(objtype, lb.name, OBJECT_TYPE))
                                                                            )
                                                                        )
                                                                        (§ ass closesExprs (ß closesExprs.cons(new LocalBindingExpr(lb, nil))))
                                                                    )
                                                                )
                                                            )

                                                            (ß ctorgen.visitLabel(end))

                                                            (ß ctorgen.returnValue())

                                                            (ß ctorgen.endMethod())

                                                            (when (ß altCtorDrops > 0)
                                                                ;; ctor that takes closed-overs and inits base + fields
                                                                (let [#_"Type[]" ctorTypes (ß ctorTypes())]
                                                                    (let [#_"Type[]" altCtorTypes (ß new Type[ctorTypes.length-altCtorDrops])]
                                                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < altCtorTypes.length) [(§ ass i (ß i + 1))]
                                                                            (§ ass (ß altCtorTypes[i]) (ß ctorTypes[i]))
                                                                        )
                                                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes))]
                                                                            (§ ass ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.loadArgs())

                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())

                                                                            ;; alt ctor no __hash, __hasheq
                                                                            (§ ass altCtorTypes (ß new Type[ctorTypes.length-2]))
                                                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < altCtorTypes.length) [(§ ass i (ß i + 1))]
                                                                                (§ ass (ß altCtorTypes[i]) (ß ctorTypes[i]))
                                                                            )

                                                                            (§ ass alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes)))
                                                                            (§ ass ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.loadArgs())

                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())
                                                                        )
                                                                    )
                                                                )
                                                            )

                                                            (when (ß supportsMeta())
                                                                ;; ctor that takes closed-overs but not meta
                                                                (let [#_"Type[]" ctorTypes (ß ctorTypes())]
                                                                    (let [#_"Type[]" noMetaCtorTypes (ß new Type[ctorTypes.length-1])]
                                                                        (loop-when-recur [(§ var #_"int" i 1)] (ß i < ctorTypes.length) [(§ ass i (ß i + 1))]
                                                                            (§ ass (ß noMetaCtorTypes[i - 1]) (ß ctorTypes[i]))
                                                                        )
                                                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes))]
                                                                            (§ ass ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; nil meta
                                                                            (ß ctorgen.loadArgs())
                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())

                                                                            ;; meta()
                                                                            (let [#_"Method" meth (ß Method.getMethod("cloiure.lang.IPersistentMap meta()"))]
                                                                                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))]
                                                                                    (ß gen.visitCode())
                                                                                    (ß gen.loadThis())
                                                                                    (ß gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE))

                                                                                    (ß gen.returnValue())
                                                                                    (ß gen.endMethod())

                                                                                    ;; withMeta()
                                                                                    (§ ass meth (ß Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))

                                                                                    (§ ass gen (ß new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv)))
                                                                                    (ß gen.visitCode())
                                                                                    (ß gen.newInstance(objtype))
                                                                                    (ß gen.dup())
                                                                                    (ß gen.loadArg(0))

                                                                                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(closes)))] (some? s) [(§ ass s (ß s.next()), a (ß a + 1))]
                                                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                                                            (ß gen.loadThis())
                                                                                            (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                                                                (if (some? primc)
                                                                                                    (do
                                                                                                        (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                                                                                                    )
                                                                                                    (do
                                                                                                        (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )

                                                                                    (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))
                                                                                    (ß gen.returnValue())
                                                                                    (ß gen.endMethod())
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )

                                                            (ß emitStatics(cv))
                                                            (ß emitMethods(cv))

                                                            ;; static fields for constants
                                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < constants.count()) [(§ ass i (ß i + 1))]
                                                                (when (ß usedConstants.contains(i))
                                                                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), nil, nil))
                                                                )
                                                            )

                                                            ;; static fields for lookup sites
                                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < keywordCallsites.count()) [(§ ass i (ß i + 1))]
                                                                (ß cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                                (ß cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                            )

                                                            ;; static init for constants, keywords and vars
                                                            (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))]
                                                                (ß clinitgen.visitCode())
                                                                (ß clinitgen.visitLineNumber(line, clinitgen.mark()))

                                                                (when (ß constants.count() > 0)
                                                                    (ß emitConstants(clinitgen))
                                                                )

                                                                (when (ß keywordCallsites.count() > 0)
                                                                    (ß emitKeywordCallsites(clinitgen))
                                                                )

                                                                (when (ß isDeftype() && RT.booleanCast(RT.get(opts, loadNs)))
                                                                    (let [#_"String" nsname (ß ((Symbol)RT.second(src)).getNamespace())]
                                                                        (when (ß !nsname.equals("cloiure.core"))
                                                                            (ß clinitgen.push("cloiure.core"))
                                                                            (ß clinitgen.push("require"))
                                                                            (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                                                                            (ß clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")))
                                                                            (ß clinitgen.checkCast(IFN_TYPE))
                                                                            (ß clinitgen.push(nsname))
                                                                            (ß clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)")))
                                                                            (ß clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)")))
                                                                            (ß clinitgen.pop())
                                                                        )
                                                                    )
                                                                )

                                                                (ß clinitgen.returnValue())

                                                                (ß clinitgen.endMethod())

                                                                ;; end of class
                                                                (ß cv.visitEnd())

                                                                (§ ass bytecode (ß cw.toByteArray()))
                                                                (when (ß RT.booleanCast(COMPILE_FILES.deref()))
                                                                    (ß writeClassFile(internalName, bytecode))
                                                                )
                                                                nil
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"void" emitKeywordCallsites [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < keywordCallsites.count()) [(§ ass i (ß i + 1))]
                (let [#_"Keyword" k (ß (Keyword) keywordCallsites.nth(i))]
                    (ß clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE))
                    (ß clinitgen.dup())
                    (ß emitValue(k, clinitgen))
                    (ß clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)")))
                    (ß clinitgen.dup())
                    (ß clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE))
                    (ß clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE))
                )
            )
            nil
        )

        #_protected
        #_method
        (§ defn #_"void" emitStatics [#_"ObjExpr" this, #_"ClassVisitor" gen]
            nil
        )

        #_protected
        #_method
        (§ defn #_"void" emitMethods [#_"ObjExpr" this, #_"ClassVisitor" gen]
            nil
        )

        #_method
        (§ defn #_"void" emitListAsObjectArray [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
            (ß gen.push(((List) value).size()))
            (ß gen.newArray(OBJECT_TYPE))
            (let [#_"int" i 0]
                (loop-when-recur [(§ var #_"Iterator" it (ß ((List) value).iterator()))] (ß it.hasNext()) [(§ ass i (ß i + 1))]
                    (ß gen.dup())
                    (ß gen.push(i))
                    (ß emitValue(it.next(), gen))
                    (ß gen.arrayStore(OBJECT_TYPE))
                )
                nil
            )
        )

        #_method
        (§ defn #_"void" emitValue [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
            (let [#_"boolean" partial true]
                (cond (nil? value)
                    (do
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    )
                    (ß value instanceof String)
                    (do
                        (ß gen.push((String) value))
                    )
                    (ß value instanceof Boolean)
                    (do
                        (if (ß ((Boolean) value).booleanValue())
                            (do
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                            )
                            (do
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                            )
                        )
                    )
                    (ß value instanceof Integer)
                    (do
                        (ß gen.push(((Integer) value).intValue()))
                        (ß gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)")))
                    )
                    (ß value instanceof Long)
                    (do
                        (ß gen.push(((Long) value).longValue()))
                        (ß gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)")))
                    )
                    (ß value instanceof Double)
                    (do
                        (ß gen.push(((Double) value).doubleValue()))
                        (ß gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)")))
                    )
                    (ß value instanceof Character)
                    (do
                        (ß gen.push(((Character) value).charValue()))
                        (ß gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)")))
                    )
                    (ß value instanceof Class)
                    (do
                        (let [#_"Class" cc (ß (Class)value)]
                            (if (ß cc.isPrimitive())
                                (do
                                    (§ let [#_"Type" bt]
                                        (cond (ß cc == boolean.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Boolean.class)))
                                            )
                                            (ß cc == byte.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Byte.class)))
                                            )
                                            (ß cc == char.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Character.class)))
                                            )
                                            (ß cc == double.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Double.class)))
                                            )
                                            (ß cc == float.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Float.class)))
                                            )
                                            (ß cc == int.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Integer.class)))
                                            )
                                            (ß cc == long.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Long.class)))
                                            )
                                            (ß cc == short.class)
                                            (do
                                                (§ ass bt (ß Type.getType(Short.class)))
                                            )
                                            :else
                                            (do
                                                (throw (ß Util.runtimeException("Can't embed unknown primitive in code: " + value)))
                                            )
                                        )
                                        (ß gen.getStatic(bt, "TYPE", Type.getType(Class.class)))
                                    )
                                )
                                (do
                                    (ß gen.push(destubClassName(cc.getName())))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                                )
                            )
                        )
                    )
                    (ß value instanceof Symbol)
                    (do
                        (ß gen.push(((Symbol) value).ns))
                        (ß gen.push(((Symbol) value).name))
                        (ß gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)")))
                    )
                    (ß value instanceof Keyword)
                    (do
                        (ß gen.push(((Keyword) value).sym.ns))
                        (ß gen.push(((Keyword) value).sym.name))
                        (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)")))
                    )
                    (ß value instanceof Var)
                    (do
                        (let [#_"Var" var (ß (Var) value)]
                            (ß gen.push(var.ns.name.toString()))
                            (ß gen.push(var.sym.toString()))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                        )
                    )
                    (ß value instanceof IType)
                    (do
                        (let [#_"Method" ctor (ß new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0])))]
                            (ß gen.newInstance(Type.getType(value.getClass())))
                            (ß gen.dup())
                            (let [#_"IPersistentVector" fields (ß (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§ array )))]
                                (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(fields)))] (some? s) [(§ ass s (ß s.next()))]
                                    (let [#_"Symbol" field (ß (Symbol) s.first())]
                                        (let [#_"Class" k (ß tagClass(tagOf(field)))]
                                            (let [#_"Object" val (ß Reflector.getInstanceField(value, munge(field.name)))]
                                                (ß emitValue(val, gen))

                                                (when (ß k.isPrimitive())
                                                    (let [#_"Type" b (ß Type.getType(boxClass(k)))]
                                                        (let [#_"String" p (ß Type.getType(k).getDescriptor())]
                                                            (let [#_"String" n (ß k.getName())]
                                                                (ß gen.invokeVirtual(b, new Method(n+"Value", "()"+p)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (ß gen.invokeConstructor(Type.getType(value.getClass()), ctor))
                            )
                        )
                    )
                    (ß value instanceof IRecord)
                    (do
                        (let [#_"Method" createMethod (ß Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))]
                            (ß emitValue(PersistentArrayMap.create((java.util.Map) value), gen))
                            (ß gen.invokeStatic(getType(value.getClass()), createMethod))
                        )
                    )
                    (ß value instanceof IPersistentMap)
                    (do
                        (let [#_"List" entries (ArrayList.)]
                            (doseq [#_"Map.Entry" entry (ß (Set<Map.Entry>) ((Map) value).entrySet())]
                                (ß entries.add(entry.getKey()))
                                (ß entries.add(entry.getValue()))
                            )
                            (ß emitListAsObjectArray(entries, gen))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                        )
                    )
                    (ß value instanceof IPersistentVector)
                    (do
                        (let [#_"IPersistentVector" args (ß (IPersistentVector) value)]
                            (if (ß args.count() <= Tuple.MAX_SIZE)
                                (do
                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < args.count()) [(§ ass i (ß i + 1))]
                                        (ß emitValue(args.nth(i), gen))
                                    )
                                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                                )
                                (do
                                    (ß emitListAsObjectArray(value, gen))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                                )
                            )
                        )
                    )
                    (ß value instanceof PersistentHashSet)
                    (do
                        (let [#_"ISeq" vs (ß RT.seq(value))]
                            (if (nil? vs)
                                (do
                                    (ß gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class)))
                                )
                                (do
                                    (ß emitListAsObjectArray(vs, gen))
                                    (ß gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                                )
                            )
                        )
                    )
                    (ß value instanceof ISeq || value instanceof IPersistentList)
                    (do
                        (ß emitListAsObjectArray(value, gen))
                        (ß gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])")))
                        (ß gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                    )
                    (ß value instanceof Pattern)
                    (do
                        (ß emitValue(value.toString(), gen))
                        (ß gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)")))
                    )
                    :else
                    (do
                        (let [#_"String" cs nil]
                            (try
                                (§ ass cs (ß RT.printString(value)))
                                (catch Exception e
                                    (throw (ß Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value)))
                                )
                            )
                            (when (ß cs.length() == 0)
                                (throw (ß Util.runtimeException("Can't embed unreadable object in code: " + value)))
                            )

                            (when (ß cs.startsWith("#<"))
                                (throw (ß Util.runtimeException("Can't embed unreadable object in code: " + cs)))
                            )

                            (ß gen.push(cs))
                            (ß gen.invokeStatic(RT_TYPE, readStringMethod))
                            (§ ass partial false)
                        )
                    )
                )

                (when partial
                    (when (ß value instanceof IObj && RT.count(((IObj) value).meta()) > 0)
                        (ß gen.checkCast(IOBJ_TYPE))
                        (let [#_"Object" m (ß ((IObj) value).meta())]
                            (ß emitValue(elideMeta(m), gen))
                            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                            (ß gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                        )
                    )
                )
                nil
            )
        )

        #_method
        (§ defn #_"void" emitConstants [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
            (try
                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                (loop-when-recur [(§ var #_"int" i 0)] (ß i < constants.count()) [(§ ass i (ß i + 1))]
                    (when (ß usedConstants.contains(i))
                        (ß emitValue(constants.nth(i), clinitgen))
                        (ß clinitgen.checkCast(constantType(i)))
                        (ß clinitgen.putStatic(objtype, constantName(i), constantType(i)))
                    )
                )
                (finally
                    (ß Var.popThreadBindings())
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" isMutable [#_"ObjExpr" this, #_"LocalBinding" lb]
            (ß isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable"))))
        )

        #_method
        (§ defn #_"boolean" isVolatile [#_"ObjExpr" this, #_"LocalBinding" lb]
            (ß RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable"))))
        )

        #_method
        (§ defn #_"boolean" isDeftype [#_"ObjExpr" this]
            (ß (fields != nil))
        )

        #_method
        (§ defn #_"boolean" supportsMeta [#_"ObjExpr" this]
            (ß !isDeftype())
        )

        #_method
        (§ defn #_"void" emitClearCloses [#_"ObjExpr" this, #_"GeneratorAdapter" gen]
            nil
        )

        #_method
        (§ defn #_"Class" getCompiledClass [#_"ObjExpr" this]
            (§ sync this
                (when (nil? compiledClass)
                    (§ ass loader (ß (DynamicClassLoader) LOADER.deref()))
                    (§ ass compiledClass (ß loader.defineClass(name, bytecode, src)))
                )
                compiledClass
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"ObjExpr" this]
            (when (ß isDeftype())
                (§ return nil)
            )
            (try
                (ß getCompiledClass().newInstance())
                (catch Exception e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )

        #_method
        (§ defn #_"void" emitLetFnInits [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"IPersistentSet" letFnLocals]
            ;; objx arg is enclosing objx, not this
            (ß gen.checkCast(objtype))

            (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(closes)))] (some? s) [(§ ass s (ß s.next()))]
                (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                    (when (ß letFnLocals.contains(lb))
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (ß gen.dup())
                            (if (some? primc)
                                (do
                                    (ß objx.emitUnboxedLocal(gen, lb))
                                    (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                                )
                                (do
                                    (ß objx.emitLocal(gen, lb, false))
                                    (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                                )
                            )
                        )
                    )
                )
            )
            (ß gen.pop())
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"ObjExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            (if (ß isDeftype())
                (do
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                )
                (do
                    (ß gen.newInstance(objtype))
                    (ß gen.dup())
                    (when (ß supportsMeta())
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    )
                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(closesExprs)))] (some? s) [(§ ass s (ß s.next()))]
                        (let [#_"LocalBindingExpr" lbe (ß (LocalBindingExpr) s.first())]
                            (let [#_"LocalBinding" lb (ß lbe.b)]
                                (if (ß lb.getPrimitiveType() != nil)
                                    (do
                                        (ß objx.emitUnboxedLocal(gen, lb))
                                    )
                                    (do
                                        (ß objx.emitLocal(gen, lb, lbe.shouldClear))
                                    )
                                )
                            )
                        )
                    )
                    (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes())))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"ObjExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"ObjExpr" this]
            (when (nil? jc)
                (§ ass jc (ß (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr.tagToClass(tag) :or IFn.class))
            )
            jc
        )

        #_method
        (§ defn #_"void" emitAssignLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"Expr" val]
            (when (ß !isMutable(lb))
                (throw (IllegalArgumentException. (ß "Cannot assign to non-mutable: " + lb.name)))
            )
            (let [#_"Class" primc (ß lb.getPrimitiveType())]
                (ß gen.loadThis())
                (if (some? primc)
                    (do
                        (when (ß !(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive()))
                            (throw (IllegalArgumentException. (ß "Must assign primitive to primitive mutable: " + lb.name)))
                        )
                        (let [#_"MaybePrimitiveExpr" me (ß (MaybePrimitiveExpr) val)]
                            (ß me.emitUnboxed(C.EXPRESSION, this, gen))
                            (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                        )
                    )
                    (do
                        (ß val.emit(C.EXPRESSION, this, gen))
                        (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
                nil
            )
        )

        #_method
        (§ defn- #_"void" emitLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"boolean" clear]
            (if (ß closes.containsKey(lb))
                (do
                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                        (ß gen.loadThis())
                        (if (some? primc)
                            (do
                                (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                                (ß HostExpr.emitBoxReturn(this, gen, primc))
                            )
                            (do
                                (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                                (when (ß onceOnly && clear && lb.canBeCleared)
                                    (ß gen.loadThis())
                                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                    (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                                )
                            )
                        )
                    )
                )
                (do
                    (let [#_"int" argoff (ß canBeDirect ? 0 :or 1)]
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (if (ß lb.isArg)
                                (do
                                    (ß gen.loadArg(lb.idx-argoff))
                                    (cond (some? primc)
                                        (do
                                            (ß HostExpr.emitBoxReturn(this, gen, primc))
                                        )
                                        (ß clear && lb.canBeCleared)
                                        (do
                                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                            (ß gen.storeArg(lb.idx - argoff))
                                        )
                                    )
                                )
                                (do
                                    (if (some? primc)
                                        (do
                                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                                            (ß HostExpr.emitBoxReturn(this, gen, primc))
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx))
                                            (when (ß clear && lb.canBeCleared)
                                                (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitUnboxedLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb]
            (let [#_"int" argoff (ß canBeDirect ? 0 :or 1)]
                (let [#_"Class" primc (ß lb.getPrimitiveType())]
                    (cond (ß closes.containsKey(lb))
                        (do
                            (ß gen.loadThis())
                            (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                        )
                        (ß lb.isArg)
                        (do
                            (ß gen.loadArg(lb.idx-argoff))
                        )
                        :else
                        (do
                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                        )
                    )
                    nil
                )
            )
        )

        #_method
        (§ defn #_"void" emitVar [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" var]
            (let [#_"Integer" i (ß (Integer) vars.valAt(var))]
                (ß emitConstant(gen, i))
                nil
            )
        )

        (§ def #_"Method" varGetMethod (ß Method.getMethod("Object get()")))
        (§ def #_"Method" varGetRawMethod (ß Method.getMethod("Object getRawRoot()")))

        #_method
        (§ defn #_"void" emitVarValue [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" v]
            (let [#_"Integer" i (ß (Integer) vars.valAt(v))]
                (if (ß !v.isDynamic())
                    (do
                        (ß emitConstant(gen, i))
                        (ß gen.invokeVirtual(VAR_TYPE, varGetRawMethod))
                    )
                    (do
                        (ß emitConstant(gen, i))
                        (ß gen.invokeVirtual(VAR_TYPE, varGetMethod))
                    )
                )
                nil
            )
        )

        #_method
        (§ defn #_"void" emitKeyword [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Keyword" k]
            (let [#_"Integer" i (ß (Integer) keywords.valAt(k))]
                (ß emitConstant(gen, i))
                nil
            )
        )

        #_method
        (§ defn #_"void" emitConstant [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"int" id]
            (§ ass usedConstants (ß (IPersistentSet) usedConstants.cons(id)))
            (ß gen.getStatic(objtype, constantName(id), constantType(id)))
            nil
        )

        #_method
        (§ defn #_"String" constantName [#_"ObjExpr" this, #_"int" id]
            (ß CONST_PREFIX + id)
        )

        #_method
        (§ defn #_"String" siteName [#_"ObjExpr" this, #_"int" n]
            (ß "__site__" + n)
        )

        #_method
        (§ defn #_"String" siteNameStatic [#_"ObjExpr" this, #_"int" n]
            (ß siteName(n) + "__")
        )

        #_method
        (§ defn #_"String" thunkName [#_"ObjExpr" this, #_"int" n]
            (ß "__thunk__" + n)
        )

        #_method
        (§ defn #_"String" cachedClassName [#_"ObjExpr" this, #_"int" n]
            (ß "__cached_class__" + n)
        )

        #_method
        (§ defn #_"String" cachedVarName [#_"ObjExpr" this, #_"int" n]
            (ß "__cached_var__" + n)
        )

        #_method
        (§ defn #_"String" varCallsiteName [#_"ObjExpr" this, #_"int" n]
            (ß "__var__callsite__" + n)
        )

        #_method
        (§ defn #_"String" thunkNameStatic [#_"ObjExpr" this, #_"int" n]
            (ß thunkName(n) + "__")
        )

        #_method
        (§ defn #_"Type" constantType [#_"ObjExpr" this, #_"int" id]
            (let [#_"Object" o (ß constants.nth(id))]
                (let [#_"Class" c (ß cloiure.lang.Util.classOf(o))]
                    (when (ß c!= nil && Modifier.isPublic(c.getModifiers()))
                        ;; can't emit derived fn types due to visibility
                        (cond (ß LazySeq.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(ISeq.class)))
                            )
                            (ß c == Keyword.class)
                            (do
                                (§ return (ß Type.getType(Keyword.class)))
                            )
                            (ß RestFn.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(RestFn.class)))
                            )
                            (ß AFn.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(AFn.class)))
                            )
                            (ß c == Var.class)
                            (do
                                (§ return (ß Type.getType(Var.class)))
                            )
                            (ß c == String.class)
                            (do
                                (§ return (ß Type.getType(String.class)))
                            )
                        )
                    )
                    OBJECT_TYPE
                )
            )
        )
    )

    (§ enum PATHTYPE
        (§ item PATH),
        (§ item BRANCH)
    )

    (class-ns PathNode
        (§ init
            (§ field #_"PATHTYPE" type nil)
            (§ field #_"PathNode" parent nil)
        )

        (§ constructor #_"PathNode" PathNode [#_"PATHTYPE" type, #_"PathNode" parent]
            (let [this (ß super())]
                (§ ass (ß this.type) type)
                (§ ass (ß this.parent) parent)
                this
            )
        )
    )

    (§ defn #_"PathNode" clearPathRoot []
        (ß (PathNode) CLEAR_ROOT.get())
    )

    (§ enum PSTATE
        (§ item REQ),
        (§ item REST),
        (§ item DONE)
    )

    (class-ns FnMethod (§ extends ObjMethod)
        (§ init
            ;; localbinding->localbinding
            (§ field #_"PersistentVector" reqParms (ß PersistentVector.EMPTY))
            (§ field #_"LocalBinding" restParm nil)
            (§ field #_"Type[]" argtypes nil)
            (§ field #_"Class[]" argclasses nil)
            (§ field #_"Class" retClass nil)
            (§ field #_"String" prim nil)
        )

        (§ constructor #_"FnMethod" FnMethod [#_"ObjExpr" objx, #_"ObjMethod" parent]
            (let [this (ß super(objx, parent))]
                this
            )
        )

        (§ defn #_"char" classChar [#_"Object" x]
            (let [#_"Class" c nil]
                (cond (ß x instanceof Class)
                    (do
                        (§ ass c (ß (Class) x))
                    )
                    (ß x instanceof Symbol)
                    (do
                        (§ ass c (ß primClass((Symbol) x)))
                    )
                )
                (when (ß c == nil || !c.isPrimitive())
                    (§ return (ß \O))
                )
                (when (ß c == long.class)
                    (§ return (ß \L))
                )
                (when (ß c == double.class)
                    (§ return (ß \D))
                )
                (throw (IllegalArgumentException. "Only long and double primitives are supported"))
            )
        )

        (§ defn #_"String" primInterface [#_"IPersistentVector" arglist]
            (let [#_"StringBuilder" sb (StringBuilder.)]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < arglist.count()) [(§ ass i (ß i + 1))]
                    (ß sb.append(classChar(tagOf(arglist.nth(i)))))
                )
                (ß sb.append(classChar(tagOf(arglist))))
                (let [#_"String" ret (ß sb.toString())]
                    (let [#_"boolean" prim (ß ret.contains("L") || ret.contains("D"))]
                        (when (ß prim && arglist.count() > 4)
                            (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                        )
                        (when prim
                            (§ return (ß "cloiure.lang.IFn$" + ret))
                        )
                        nil
                    )
                )
            )
        )

        (§ defn #_"FnMethod" parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Object" rettag]
            ;; ([args] body...)
            (let [#_"IPersistentVector" parms (ß (IPersistentVector) RT.first(form))]
                (let [#_"ISeq" body (ß RT.next(form))]
                    (try
                        (let [#_"FnMethod" method (ß new FnMethod(objx, (ObjMethod) METHOD.deref()))]
                            (§ ass (ß method.line) (ß lineDeref()))
                            (§ ass (ß method.column) (ß columnDeref()))
                            ;; register as the current method and set up a new env frame
                            (let [#_"PathNode" pnode (ß (PathNode) CLEAR_PATH.get())]
                                (when (nil? pnode)
                                    (§ ass pnode (ß new PathNode(PATHTYPE.PATH, nil)))
                                )
                                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                    #_map METHOD, method,
                                    #_map LOCAL_ENV, LOCAL_ENV.deref(),
                                    #_map LOOP_LOCALS, nil,
                                    #_map NEXT_LOCAL_NUM, 0,
                                    #_map CLEAR_PATH, pnode,
                                    #_map CLEAR_ROOT, pnode,
                                    #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                                    #_map METHOD_RETURN_CONTEXT, RT.T
                                )))

                                (§ ass (ß method.prim) (ß primInterface(parms)))
                                (when (ß method.prim != nil)
                                    (§ ass (ß method.prim) (ß method.prim.replace(\., \/)))
                                )

                                (when (ß rettag instanceof String)
                                    (§ ass rettag (ß Symbol.intern(nil, (String) rettag)))
                                )
                                (when (ß !(rettag instanceof Symbol))
                                    (§ ass rettag nil)
                                )
                                (when (some? rettag)
                                    (let [#_"String" retstr (ß ((Symbol)rettag).getName())]
                                        (when (ß !(retstr.equals("long") || retstr.equals("double")))
                                            (§ ass rettag nil)
                                        )
                                    )
                                )
                                (§ ass (ß method.retClass) (ß tagClass((tagOf(parms) != nil) ? tagOf(parms) :or rettag)))
                                (if (ß method.retClass.isPrimitive())
                                    (do
                                        (when (ß !(method.retClass == double.class || method.retClass == long.class))
                                            (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                        )
                                    )
                                    (do
                                        (§ ass (ß method.retClass) (ß Object.class))
                                    )
                                )
                                ;; register 'this' as local 0
                                (if (ß objx.thisName != nil)
                                    (do
                                        (ß registerLocal(Symbol.intern(objx.thisName), nil, nil, false))
                                    )
                                    (do
                                        (ß getAndIncLocalNum())
                                    )
                                )
                                (let [#_"PSTATE" state (ß PSTATE.REQ)]
                                    (let [#_"PersistentVector" argLocals (ß PersistentVector.EMPTY)]
                                        (let [#_"ArrayList<Type>" argtypes (ArrayList.)]
                                            (let [#_"ArrayList<Class>" argclasses (ArrayList.)]
                                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < parms.count()) [(§ ass i (ß i + 1))]
                                                    (when (ß !(parms.nth(i) instanceof Symbol))
                                                        (throw (IllegalArgumentException. "fn params must be Symbols"))
                                                    )
                                                    (let [#_"Symbol" p (ß (Symbol) parms.nth(i))]
                                                        (when (ß p.getNamespace() != nil)
                                                            (throw (ß Util.runtimeException("Can't use qualified name as parameter: " + p)))
                                                        )
                                                        (if (ß p.equals(_AMP_))
                                                            (do
                                                                (if (ß state == PSTATE.REQ)
                                                                    (do
                                                                        (§ ass state (ß PSTATE.REST))
                                                                    )
                                                                    (do
                                                                        (throw (ß Util.runtimeException("Invalid parameter list")))
                                                                    )
                                                                )
                                                            )
                                                            (do
                                                                (let [#_"Class" pc (ß primClass(tagClass(tagOf(p))))]
                                                                    (when (ß pc.isPrimitive() && !(pc == double.class || pc == long.class))
                                                                        (throw (IllegalArgumentException. (ß "Only long and double primitives are supported: " + p)))
                                                                    )

                                                                    (when (ß state == PSTATE.REST && tagOf(p) != nil)
                                                                        (throw (ß Util.runtimeException("& arg cannot have type hint")))
                                                                    )
                                                                    (when (ß state == PSTATE.REST && method.prim != nil)
                                                                        (throw (ß Util.runtimeException("fns taking primitives cannot be variadic")))
                                                                    )

                                                                    (when (ß state == PSTATE.REST)
                                                                        (§ ass pc (ß ISeq.class))
                                                                    )
                                                                    (ß argtypes.add(Type.getType(pc)))
                                                                    (ß argclasses.add(pc))
                                                                    (let [#_"LocalBinding" lb (ß pc.isPrimitive() ? registerLocal(p, nil, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), nil, true))]
                                                                        (§ ass argLocals (ß argLocals.cons(lb)))
                                                                        (§ switch state
                                                                            (§ case REQ)
                                                                            (do
                                                                                (§ ass (ß method.reqParms) (ß method.reqParms.cons(lb)))
                                                                                (§ break )
                                                                            )
                                                                            (§ case REST)
                                                                            (do
                                                                                (§ ass (ß method.restParm) lb)
                                                                                (§ ass state (ß PSTATE.DONE))
                                                                                (§ break )
                                                                            )
                                                                            (§ default )
                                                                            (do
                                                                                (throw (ß Util.runtimeException("Unexpected parameter")))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (when (ß method.reqParms.count() > MAX_POSITIONAL_ARITY)
                                                    (throw (ß Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params")))
                                                )
                                                (ß LOOP_LOCALS.set(argLocals))
                                                (§ ass (ß method.argLocals) argLocals)
                                                (§ ass (ß method.argtypes) (ß argtypes.toArray(new Type[argtypes.size()])))
                                                (§ ass (ß method.argclasses) (ß argclasses.toArray(new Class[argtypes.size()])))
                                                (when (ß method.prim != nil)
                                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < method.argclasses.length) [(§ ass i (ß i + 1))]
                                                        (when (ß method.argclasses[i] == long.class || method.argclasses[i] == double.class)
                                                            (ß getAndIncLocalNum())
                                                        )
                                                    )
                                                )
                                                (§ ass (ß method.body) (ß (new BodyExpr'Parser()).parse(C.RETURN, body)))
                                                method
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (cond (ß fn.canBeDirect)
                (do
                    (ß doEmitStatic(fn, cv))
                )
                (some? prim)
                (do
                    (ß doEmitPrim(fn, cv))
                )
                :else
                (do
                    (ß doEmit(fn, cv))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" doEmitStatic [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (let [#_"Type" returnType (ß Type.getType(retClass))]
                (let [#_"Method" ms (ß new Method("invokeStatic", returnType, argtypes))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, ms, nil, EXCEPTION_TYPES, cv))]
                        (ß gen.visitCode())
                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                                (ß emitBody(objx, gen, retClass, body))

                                (let [#_"Label" end (ß gen.mark())]
                                    (loop-when-recur [(§ var #_"ISeq" lbs (ß argLocals.seq()))] (some? lbs) [(§ ass lbs (ß lbs.next()))]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())

                            ;; generate the regular invoke, calling the static method
                            (let [#_"Method" m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                                ;; todo don't hardwire EXCEPTION_TYPES
                                (§ ass gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv)))
                                (ß gen.visitCode())
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < argtypes.length) [(§ ass i (ß i + 1))]
                                    (ß gen.loadArg(i))
                                    (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                                    (when (ß !argclasses[i].isPrimitive())
                                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                        (ß gen.storeArg(i))
                                    )
                                )
                                (let [#_"Label" callLabel (ß gen.mark())]
                                    (ß gen.visitLineNumber(line, callLabel))
                                    (ß gen.invokeStatic(objx.objtype, ms))
                                    (ß gen.box(returnType))

                                    (ß gen.returnValue())
                                    (ß gen.endMethod())

                                    ;; generate primInvoke if prim
                                    (when (some? prim)
                                        (when (ß retClass == double.class || retClass == long.class)
                                            (§ ass returnType (ß getReturnType()))
                                        )
                                        (let [#_"else" returnType OBJECT_TYPE]
                                            (let [#_"Method" pm (ß new Method("invokePrim", returnType, argtypes))]
                                                ;; todo don't hardwire EXCEPTION_TYPES
                                                (§ ass gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, pm, nil, EXCEPTION_TYPES, cv)))
                                                (ß gen.visitCode())
                                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < argtypes.length) [(§ ass i (ß i + 1))]
                                                    (ß gen.loadArg(i))
                                                    (when (ß !argclasses[i].isPrimitive())
                                                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                                        (ß gen.storeArg(i))
                                                    )
                                                )
                                                (ß gen.invokeStatic(objx.objtype, ms))

                                                (ß gen.returnValue())
                                                (ß gen.endMethod())
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" doEmitPrim [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (§ let [#_"Type" returnType]
                (if (ß retClass == double.class || retClass == long.class)
                    (do
                        (§ ass returnType (ß getReturnType()))
                    )
                    (do
                        (§ ass returnType OBJECT_TYPE)
                    )
                )
                (let [#_"Method" ms (ß new Method("invokePrim", returnType, argtypes))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, ms, nil, EXCEPTION_TYPES, cv))]
                        (ß gen.visitCode())

                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                                (ß emitBody(objx, gen, retClass, body))

                                (let [#_"Label" end (ß gen.mark())]
                                    (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                    (loop-when-recur [(§ var #_"ISeq" lbs (ß argLocals.seq()))] (some? lbs) [(§ ass lbs (ß lbs.next()))]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())

                            ;; generate the regular invoke, calling the prim method
                            (let [#_"Method" m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                                ;; todo don't hardwire EXCEPTION_TYPES
                                (§ ass gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv)))
                                (ß gen.visitCode())
                                (ß gen.loadThis())
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < argtypes.length) [(§ ass i (ß i + 1))]
                                    (ß gen.loadArg(i))
                                    (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                                )
                                (ß gen.invokeInterface(Type.getType("L"+prim+";"), ms))
                                (ß gen.box(getReturnType()))

                                (ß gen.returnValue())
                                (ß gen.endMethod())
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" doEmit [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))]
                    (ß gen.visitCode())

                    (let [#_"Label" loopLabel (ß gen.mark())]
                        (ß gen.visitLineNumber(line, loopLabel))
                        (try
                            (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                            (ß body.emit(C.RETURN, fn, gen))
                            (let [#_"Label" end (ß gen.mark())]
                                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                (loop-when-recur [(§ var #_"ISeq" lbs (ß argLocals.seq()))] (some? lbs) [(§ ass lbs (ß lbs.next()))]
                                    (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                        (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )

                        (ß gen.returnValue())
                        (ß gen.endMethod())
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"PersistentVector" reqParms [#_"FnMethod" this]
            reqParms
        )

        #_method
        (§ defn #_"LocalBinding" restParm [#_"FnMethod" this]
            restParm
        )

        #_method
        (§ defn #_"boolean" isVariadic [#_"FnMethod" this]
            (ß (restParm != nil))
        )

        #_method
        (§ defn #_"int" numParams [#_"FnMethod" this]
            (ß reqParms.count() + (isVariadic() ? 1 :or 0))
        )

        #_method
        (§ defn #_"String" getMethodName [#_"FnMethod" this]
            (ß isVariadic() ? "doInvoke" :or "invoke")
        )

        #_method
        (§ defn #_"Type" getReturnType [#_"FnMethod" this]
            (when (some? prim) ;; objx.isStatic
                (§ return (ß Type.getType(retClass)))
            )
            OBJECT_TYPE
        )

        #_method
        (§ defn #_"Type[]" getArgTypes [#_"FnMethod" this]
            (when (ß isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
                (let [#_"Type[]" ret (ß new Type[MAX_POSITIONAL_ARITY + 1])]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < MAX_POSITIONAL_ARITY + 1) [(§ ass i (ß i + 1))]
                        (§ ass (ß ret[i]) OBJECT_TYPE)
                    )
                    (§ return ret)
                )
            )
            (ß ARG_TYPES[numParams()])
        )

        #_method
        (§ defn #_"void" emitClearLocals [#_"FnMethod" this, #_"GeneratorAdapter" gen]
            nil
        )
    )

    #_abstract
    (class-ns ObjMethod
        (§ init
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            (§ field #_"ObjMethod" parent nil)
            ;; localbinding->localbinding
            (§ field #_"IPersistentMap" locals nil)
            ;; num->localbinding
            (§ field #_"IPersistentMap" indexlocals nil)
            (§ field #_"Expr" body nil)
            (§ field #_"ObjExpr" objx nil)
            (§ field #_"PersistentVector" argLocals nil)
            (§ field #_"int" maxLocal 0)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"boolean" usesThis false)
            (§ field #_"PersistentHashSet" localsUsedInCatchFinally (ß PersistentHashSet.EMPTY))
            #_protected
            (§ field #_"IPersistentMap" methodMeta nil)
        )

        (§ constructor #_"ObjMethod" ObjMethod [#_"ObjExpr" objx, #_"ObjMethod" parent]
            (let [this (ß super())]
                (§ ass (ß this.parent) parent)
                (§ ass (ß this.objx) objx)
                this
            )
        )

        #_method
        (§ defn #_"IPersistentMap" locals [#_"ObjMethod" this]
            locals
        )

        #_method
        (§ defn #_"Expr" body [#_"ObjMethod" this]
            body
        )

        #_method
        (§ defn #_"ObjExpr" objx [#_"ObjMethod" this]
            objx
        )

        #_method
        (§ defn #_"PersistentVector" argLocals [#_"ObjMethod" this]
            argLocals
        )

        #_method
        (§ defn #_"int" maxLocal [#_"ObjMethod" this]
            maxLocal
        )

        #_method
        (§ defn #_"int" line [#_"ObjMethod" this]
            line
        )

        #_method
        (§ defn #_"int" column [#_"ObjMethod" this]
            column
        )

        (§ defn #_"void" emitBody [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" retClass, #_"Expr" body]
            (let [#_"MaybePrimitiveExpr" be (ß (MaybePrimitiveExpr) body)]
                (if (ß Util.isPrimitive(retClass) && be.canEmitPrimitive())
                    (do
                        (let [#_"Class" bc (ß maybePrimitiveType(be))]
                            (cond (ß bc == retClass)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                )
                                (ß retClass == long.class && bc == int.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(I2L))
                                )
                                (ß retClass == double.class && bc == float.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(F2D))
                                )
                                (ß retClass == int.class && bc == long.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                )
                                (ß retClass == float.class && bc == double.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(D2F))
                                )
                                :else
                                (do
                                    (throw (ß new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass())))
                                )
                            )
                        )
                    )
                    (do
                        (ß body.emit(C.RETURN, objx, gen))
                        (if (ß retClass == void.class)
                            (do
                                (ß gen.pop())
                            )
                            (do
                                (ß gen.unbox(Type.getType(retClass)))
                            )
                        )
                    )
                )
                nil
            )
        )

        #_abstract
        (§ defn #_"int" numParams [#_"ObjMethod" this])
        #_abstract
        (§ defn #_"String" getMethodName [#_"ObjMethod" this])
        #_abstract
        (§ defn #_"Type" getReturnType [#_"ObjMethod" this])
        #_abstract
        (§ defn #_"Type[]" getArgTypes [#_"ObjMethod" this])

        #_method
        (§ defn #_"void" emit [#_"ObjMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))]
                    (ß gen.visitCode())

                    (let [#_"Label" loopLabel (ß gen.mark())]
                        (ß gen.visitLineNumber(line, loopLabel))
                        (try
                            (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                            (ß body.emit(C.RETURN, fn, gen))
                            (let [#_"Label" end (ß gen.mark())]
                                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                (loop-when-recur [(§ var #_"ISeq" lbs (ß argLocals.seq()))] (some? lbs) [(§ ass lbs (ß lbs.next()))]
                                    (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                        (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )

                        (ß gen.returnValue())
                        (ß gen.endMethod())
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emitClearLocals [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
            nil
        )

        #_method
        (§ defn #_"void" emitClearLocalsOld [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < argLocals.count()) [(§ ass i (ß i + 1))]
                (let [#_"LocalBinding" lb (ß (LocalBinding) argLocals.nth(i))]
                    (when (ß !localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == nil)
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.storeArg(lb.idx - 1))
                    )
                )
            )
            (loop-when-recur [(§ var #_"int" i (ß numParams() + 1))] (ß i < maxLocal + 1) [(§ ass i (ß i + 1))]
                (when (ß !localsUsedInCatchFinally.contains(i))
                    (let [#_"LocalBinding" b (ß (LocalBinding) RT.get(indexlocals, i))]
                        (when (ß b == nil || maybePrimitiveType(b.init) == nil)
                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i))
                        )
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emitClearThis [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (ß gen.visitVarInsn(Opcodes.ASTORE, 0))
            nil
        )
    )

    (class-ns LocalBinding
        (§ init
            (§ field #_"Symbol" sym nil)
            (§ field #_"Symbol" tag nil)
            (§ field #_"Expr" init nil)
            (§ field #_"int" idx 0)
            (§ field #_"String" name nil)
            (§ field #_"boolean" isArg false)
            (§ field #_"PathNode" clearPathRoot nil)
            (§ field #_"boolean" canBeCleared (ß !RT.booleanCast(getCompilerOption(disableLocalsClearingKey))))
            (§ field #_"boolean" recurMistmatch false)
            (§ field #_"boolean" used false)

            (§ field #_"Boolean" hjc nil)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"LocalBinding" LocalBinding [#_"int" num, #_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg, #_"PathNode" clearPathRoot]
            (let [this (ß super())]
                (when (ß maybePrimitiveType(init) != nil && tag != nil)
                    (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
                )
                (§ ass (ß this.idx) num)
                (§ ass (ß this.sym) sym)
                (§ ass (ß this.tag) tag)
                (§ ass (ß this.init) init)
                (§ ass (ß this.isArg) isArg)
                (§ ass (ß this.clearPathRoot) clearPathRoot)
                (§ ass name (ß munge(sym.name)))
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"LocalBinding" this]
            (when (nil? hjc)
                (if (ß (init != nil) && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                    (do
                        (§ ass hjc false)
                    )
                    (do
                        (§ ass hjc (ß (tag != nil || (init != nil && init.hasJavaClass()))))
                    )
                )
            )
            hjc
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"LocalBinding" this]
            (when (nil? jc)
                (§ ass jc (ß (tag != nil) ? HostExpr.tagToClass(tag) :or init.getJavaClass()))
            )
            jc
        )

        #_method
        (§ defn #_"Class" getPrimitiveType [#_"LocalBinding" this]
            (ß maybePrimitiveType(init))
        )
    )

    (class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
        (§ init
            (§ field #_"LocalBinding" b nil)
            (§ field #_"Symbol" tag nil)

            (§ field #_"PathNode" clearPath nil)
            (§ field #_"PathNode" clearRoot nil)
            (§ field #_"boolean" shouldClear false)

            (§ field #_"Class" jc nil)
        )

        (§ constructor #_"LocalBindingExpr" LocalBindingExpr [#_"LocalBinding" b, #_"Symbol" tag]
            (let [this (ß super())]
                (when (ß b.getPrimitiveType() != nil && tag != nil)
                    (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
                )
                (§ ass (ß this.b) b)
                (§ ass (ß this.tag) tag)

                (§ ass (ß this.clearPath) (ß (PathNode)CLEAR_PATH.get()))
                (§ ass (ß this.clearRoot) (ß (PathNode)CLEAR_ROOT.get()))
                (let [#_"IPersistentCollection" sites (ß (IPersistentCollection) RT.get(CLEAR_SITES.get(), b))]
                    (§ ass (ß b.used) true)

                    (when (ß b.idx > 0)
                        (when (some? sites)
                            (loop-when-recur [(§ var #_"ISeq" s (ß sites.seq()))] (some? s) [(§ ass s (ß s.next()))]
                                (let [#_"LocalBindingExpr" o (ß (LocalBindingExpr) s.first())]
                                    (let [#_"PathNode" common (ß commonPath(clearPath, o.clearPath))]
                                        (when (ß common != nil && common.type == PATHTYPE.PATH)
                                            (§ ass (ß o.shouldClear) false)
                                        )
                                    )
                                )
                            )
                        )

                        (when (ß clearRoot == b.clearPathRoot)
                            (§ ass (ß this.shouldClear) true)
                            (§ ass sites (ß RT.conj(sites, this)))
                            (ß CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites)))
                        )
                    )
                    this
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"LocalBindingExpr" this]
            (throw (UnsupportedOperationException. "Can't eval locals"))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"LocalBindingExpr" this]
            (ß (b.getPrimitiveType() != nil))
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"LocalBindingExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitUnboxedLocal(gen, b))
            nil
        )

        #_method
        (§ defn #_"void" emit [#_"LocalBindingExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (when (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, shouldClear))
            )
            nil
        )

        #_method
        (§ defn #_"Object" evalAssign [#_"LocalBindingExpr" this, #_"Expr" val]
            (throw (UnsupportedOperationException. "Can't eval locals"))
        )

        #_method
        (§ defn #_"void" emitAssign [#_"LocalBindingExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (ß objx.emitAssignLocal(gen, b, val))
            (when (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, false))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"LocalBindingExpr" this]
            (ß (tag != nil || b.hasJavaClass()))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"LocalBindingExpr" this]
            (when (nil? jc)
                (if (some? tag)
                    (do
                        (§ ass jc (ß HostExpr.tagToClass(tag)))
                    )
                    (do
                        (§ ass jc (ß b.getJavaClass()))
                    )
                )
            )
            jc
        )
    )

    (class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"PersistentVector" exprs nil)
        )

        (§ constructor #_"BodyExpr" BodyExpr [#_"PersistentVector" exprs]
            (let [this (ß super())]
                (§ ass (ß this.exprs) exprs)
                this
            )
        )

        #_method
        (§ defn #_"PersistentVector" exprs [#_"BodyExpr" this]
            exprs
        )

        #_stateless
        (class-ns BodyExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"BodyExpr'Parser" this, #_"C" context, #_"Object" frms]
                (let [#_"ISeq" forms (ß (ISeq) frms)]
                    (when (ß Util.equals(RT.first(forms), DO))
                        (§ ass forms (ß RT.next(forms)))
                    )
                    (let [#_"PersistentVector" exprs (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß )] (some? forms) [(§ ass forms (ß forms.next()))]
                            (let [#_"Expr" e (ß (context != C.EVAL && (context == C.STATEMENT || forms.next() != nil)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first()))]
                                (§ ass exprs (ß exprs.cons(e)))
                            )
                        )
                        (when (ß exprs.count() == 0)
                            (§ ass exprs (ß exprs.cons(NIL_EXPR)))
                        )
                        (BodyExpr. exprs)
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"BodyExpr" this]
            (let [#_"Object" ret nil]
                (doseq [#_"Object" o exprs]
                    (let [#_"Expr" e (ß (Expr) o)]
                        (§ ass ret (ß e.eval()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"BodyExpr" this]
            (ß (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive()))
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"BodyExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < exprs.count() - 1) [(§ ass i (ß i + 1))]
                (let [#_"Expr" e (ß (Expr) exprs.nth(i))]
                    (ß e.emit(C.STATEMENT, objx, gen))
                )
            )
            (let [#_"MaybePrimitiveExpr" last (ß (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1))]
                (ß last.emitUnboxed(context, objx, gen))
                nil
            )
        )

        #_method
        (§ defn #_"void" emit [#_"BodyExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < exprs.count() - 1) [(§ ass i (ß i + 1))]
                (let [#_"Expr" e (ß (Expr) exprs.nth(i))]
                    (ß e.emit(C.STATEMENT, objx, gen))
                )
            )
            (let [#_"Expr" last (ß (Expr) exprs.nth(exprs.count() - 1))]
                (ß last.emit(context, objx, gen))
                nil
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"BodyExpr" this]
            (ß lastExpr().hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"BodyExpr" this]
            (ß lastExpr().getJavaClass())
        )

        #_method
        (§ defn- #_"Expr" lastExpr [#_"BodyExpr" this]
            (ß (Expr) exprs.nth(exprs.count() - 1))
        )
    )

    (class-ns BindingInit
        (§ init
            (§ field #_"LocalBinding" binding nil)
            (§ field #_"Expr" init nil)
        )

        (§ constructor #_"BindingInit" BindingInit [#_"LocalBinding" binding, #_"Expr" init]
            (let [this (ß super())]
                (§ ass (ß this.binding) binding)
                (§ ass (ß this.init) init)
                this
            )
        )

        #_method
        (§ defn #_"LocalBinding" binding [#_"BindingInit" this]
            binding
        )

        #_method
        (§ defn #_"Expr" init [#_"BindingInit" this]
            init
        )
    )

    (class-ns LetFnExpr (§ implements Expr)
        (§ init
            (§ field #_"PersistentVector" bindingInits nil)
            (§ field #_"Expr" body nil)
        )

        (§ constructor #_"LetFnExpr" LetFnExpr [#_"PersistentVector" bindingInits, #_"Expr" body]
            (let [this (ß super())]
                (§ ass (ß this.bindingInits) bindingInits)
                (§ ass (ß this.body) body)
                this
            )
        )

        #_stateless
        (class-ns LetFnExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"LetFnExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (letfns* [var (fn [args] body) ...] body...)
                    (when (ß !(RT.second(form) instanceof IPersistentVector))
                        (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                    )

                    (let [#_"IPersistentVector" bindings (ß (IPersistentVector) RT.second(form))]
                        (when (ß (bindings.count() % 2) != 0)
                            (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                        )

                        (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                            (when (ß context == C.EVAL)
                                (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                            )

                            (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                (try
                                    (ß Var.pushThreadBindings(dynamicBindings))

                                    ;; pre-seed env (like Lisp labels)
                                    (let [#_"PersistentVector" lbs (ß PersistentVector.EMPTY)]
                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindings.count()) [(§ ass i (ß i + 2))]
                                            (when (ß !(bindings.nth(i) instanceof Symbol))
                                                (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))))
                                            )
                                            (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                (when (ß sym.getNamespace() != nil)
                                                    (throw (ß Util.runtimeException("Can't let qualified name: " + sym)))
                                                )
                                                (let [#_"LocalBinding" lb (ß registerLocal(sym, tagOf(sym), nil, false))]
                                                    (§ ass (ß lb.canBeCleared) false)
                                                    (§ ass lbs (ß lbs.cons(lb)))
                                                )
                                            )
                                        )
                                        (let [#_"PersistentVector" bindingInits (ß PersistentVector.EMPTY)]
                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindings.count()) [(§ ass i (ß i + 2))]
                                                (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                    (let [#_"Expr" init (ß analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))]
                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.nth(i / 2))]
                                                            (§ ass (ß lb.init) init)
                                                            (let [#_"BindingInit" bi (ß new BindingInit(lb, init))]
                                                                (§ ass bindingInits (ß bindingInits.cons(bi)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (ß new LetFnExpr(bindingInits, (new BodyExpr'Parser()).parse(context, body)))
                                        )
                                    )
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"LetFnExpr" this]
            (throw (UnsupportedOperationException. "Can't eval letfns"))
        )

        #_method
        (§ defn #_"void" emit [#_"LetFnExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindingInits.count()) [(§ ass i (ß i + 1))]
                (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                )
            )

            (let [#_"IPersistentSet" lbset (ß PersistentHashSet.EMPTY)]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindingInits.count()) [(§ ass i (ß i + 1))]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (§ ass lbset (ß (IPersistentSet) lbset.cons(bi.binding)))
                        (ß bi.init.emit(C.EXPRESSION, objx, gen))
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                    )
                )

                (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindingInits.count()) [(§ ass i (ß i + 1))]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (let [#_"ObjExpr" fe (ß (ObjExpr) bi.init)]
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx))
                            (ß fe.emitLetFnInits(gen, objx, lbset))
                        )
                    )
                )

                (let [#_"Label" loopLabel (ß gen.mark())]
                    (ß body.emit(context, objx, gen))

                    (let [#_"Label" end (ß gen.mark())]
                        (loop-when-recur [(§ var #_"ISeq" bis (ß bindingInits.seq()))] (some? bis) [(§ ass bis (ß bis.next()))]
                            (let [#_"BindingInit" bi (ß (BindingInit) bis.first())]
                                (let [#_"String" lname (ß bi.binding.name)]
                                    (when (ß lname.endsWith("__auto__"))
                                        (§ ass lname (ß lname + RT.nextID()))
                                    )
                                    (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                                        (if (some? primc)
                                            (do
                                                (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, loopLabel, end, bi.binding.idx))
                                            )
                                            (do
                                                (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, loopLabel, end, bi.binding.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"LetFnExpr" this]
            (ß body.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"LetFnExpr" this]
            (ß body.getJavaClass())
        )
    )

    (class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"PersistentVector" bindingInits nil)
            (§ field #_"Expr" body nil)
            (§ field #_"boolean" isLoop false)
        )

        (§ constructor #_"LetExpr" LetExpr [#_"PersistentVector" bindingInits, #_"Expr" body, #_"boolean" isLoop]
            (let [this (ß super())]
                (§ ass (ß this.bindingInits) bindingInits)
                (§ ass (ß this.body) body)
                (§ ass (ß this.isLoop) isLoop)
                this
            )
        )

        #_stateless
        (class-ns LetExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"LetExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (let [var val var2 val2 ...] body...)
                    (let [#_"boolean" isLoop (ß RT.first(form).equals(LOOP))]
                        (when (ß !(RT.second(form) instanceof IPersistentVector))
                            (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                        )

                        (let [#_"IPersistentVector" bindings (ß (IPersistentVector) RT.second(form))]
                            (when (ß (bindings.count() % 2) != 0)
                                (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                            )

                            (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                                (when (ß context == C.EVAL || (context == C.EXPRESSION && isLoop))
                                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                                )

                                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                    (let [#_"IPersistentMap" backupMethodLocals (ß method.locals)]
                                        (let [#_"IPersistentMap" backupMethodIndexLocals (ß method.indexlocals)]
                                            (let [#_"IPersistentVector" recurMismatches (ß PersistentVector.EMPTY)]
                                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindings.count() / 2) [(§ ass i (ß i + 1))]
                                                    (§ ass recurMismatches (ß recurMismatches.cons(RT.F)))
                                                )

                                                ;; may repeat once for each binding with a mismatch, return breaks
                                                (while true
                                                    (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                                        (§ ass (ß method.locals) backupMethodLocals)
                                                        (§ ass (ß method.indexlocals) backupMethodIndexLocals)

                                                        (let [#_"PathNode" looproot (ß new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))]
                                                            (let [#_"PathNode" clearroot (ß new PathNode(PATHTYPE.PATH, looproot))]
                                                                (let [#_"PathNode" clearpath (ß new PathNode(PATHTYPE.PATH, looproot))]
                                                                    (when isLoop
                                                                        (§ ass dynamicBindings (ß dynamicBindings.assoc(LOOP_LOCALS, nil)))
                                                                    )

                                                                    (try
                                                                        (ß Var.pushThreadBindings(dynamicBindings))

                                                                        (let [#_"PersistentVector" bindingInits (ß PersistentVector.EMPTY)]
                                                                            (let [#_"PersistentVector" loopLocals (ß PersistentVector.EMPTY)]
                                                                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindings.count()) [(§ ass i (ß i + 2))]
                                                                                    (when (ß !(bindings.nth(i) instanceof Symbol))
                                                                                        (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))))
                                                                                    )
                                                                                    (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                                                        (when (ß sym.getNamespace() != nil)
                                                                                            (throw (ß Util.runtimeException("Can't let qualified name: " + sym)))
                                                                                        )
                                                                                        (let [#_"Expr" init (ß analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))]
                                                                                            (when isLoop
                                                                                                (cond (ß recurMismatches != nil && RT.booleanCast(recurMismatches.nth(i / 2)))
                                                                                                    (do
                                                                                                        (§ ass init (ß new StaticMethodExpr("", 0, 0, nil, RT.class, "box", RT.vector(init), false)))
                                                                                                        (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                                                                            (ß RT.errPrintWriter().println("Auto-boxing loop arg: " + sym))
                                                                                                        )
                                                                                                    )
                                                                                                    (ß maybePrimitiveType(init) == int.class)
                                                                                                    (do
                                                                                                        (§ ass init (ß new StaticMethodExpr("", 0, 0, nil, RT.class, "longCast", RT.vector(init), false)))
                                                                                                    )
                                                                                                    (ß maybePrimitiveType(init) == float.class)
                                                                                                    (do
                                                                                                        (§ ass init (ß new StaticMethodExpr("", 0, 0, nil, RT.class, "doubleCast", RT.vector(init), false)))
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                            ;; sequential enhancement of env (like Lisp let*)
                                                                                            (try
                                                                                                (when isLoop
                                                                                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, nil)))
                                                                                                )
                                                                                                (let [#_"LocalBinding" lb (ß registerLocal(sym, tagOf(sym), init, false))]
                                                                                                    (let [#_"BindingInit" bi (ß new BindingInit(lb, init))]
                                                                                                        (§ ass bindingInits (ß bindingInits.cons(bi)))
                                                                                                        (when isLoop
                                                                                                            (§ ass loopLocals (ß loopLocals.cons(lb)))
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                                (finally
                                                                                                    (when isLoop
                                                                                                        (ß Var.popThreadBindings())
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when isLoop
                                                                                    (ß LOOP_LOCALS.set(loopLocals))
                                                                                )
                                                                                (§ let [#_"Expr" bodyExpr]
                                                                                    (let [#_"boolean" moreMismatches false]
                                                                                        (try
                                                                                            (when isLoop
                                                                                                (let [#_"Object" methodReturnContext (ß (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil)]
                                                                                                    (ß Var.pushThreadBindings(RT.map(
                                                                                                        #_map CLEAR_PATH, clearpath,
                                                                                                        #_map CLEAR_ROOT, clearroot,
                                                                                                        #_map NO_RECUR, nil,
                                                                                                        #_map METHOD_RETURN_CONTEXT, methodReturnContext
                                                                                                    )))
                                                                                                )
                                                                                            )
                                                                                            (§ ass bodyExpr (ß (new BodyExpr'Parser()).parse(isLoop ? C.RETURN :or context, body)))
                                                                                            (finally
                                                                                                (when isLoop
                                                                                                    (ß Var.popThreadBindings())
                                                                                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < loopLocals.count()) [(§ ass i (ß i + 1))]
                                                                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                                                                                                            (when (ß lb.recurMistmatch)
                                                                                                                (§ ass recurMismatches (ß (IPersistentVector)recurMismatches.assoc(i, RT.T)))
                                                                                                                (§ ass moreMismatches true)
                                                                                                            )
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (when (ß !moreMismatches)
                                                                                            (§ return (ß new LetExpr(bindingInits, bodyExpr, isLoop)))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (finally
                                                                            (ß Var.popThreadBindings())
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"LetExpr" this]
            (throw (UnsupportedOperationException. "Can't eval let/loop"))
        )

        #_method
        (§ defn #_"void" emit [#_"LetExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, false))
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"LetExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, true))
            nil
        )

        #_method
        (§ defn #_"void" doEmit [#_"LetExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
            (let [#_"HashMap<BindingInit, Label>" bindingLabels (HashMap.)]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < bindingInits.count()) [(§ ass i (ß i + 1))]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                            (if (some? primc)
                                (do
                                    (ß ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen))
                                    (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx))
                                )
                                (do
                                    (ß bi.init.emit(C.EXPRESSION, objx, gen))
                                    (if (ß !bi.binding.used && bi.binding.canBeCleared)
                                        (do
                                            (ß gen.pop())
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                                        )
                                    )
                                )
                            )
                            (ß bindingLabels.put(bi, gen.mark()))
                        )
                    )
                )
                (let [#_"Label" loopLabel (ß gen.mark())]
                    (if isLoop
                        (do
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel)))
                                (if emitUnboxed
                                    (do
                                        (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                                    )
                                    (do
                                        (ß body.emit(context, objx, gen))
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )
                        )
                        (do
                            (if emitUnboxed
                                (do
                                    (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                                )
                                (do
                                    (ß body.emit(context, objx, gen))
                                )
                            )
                        )
                    )
                    (let [#_"Label" end (ß gen.mark())]
                        (loop-when-recur [(§ var #_"ISeq" bis (ß bindingInits.seq()))] (some? bis) [(§ ass bis (ß bis.next()))]
                            (let [#_"BindingInit" bi (ß (BindingInit) bis.first())]
                                (let [#_"String" lname (ß bi.binding.name)]
                                    (when (ß lname.endsWith("__auto__"))
                                        (§ ass lname (ß lname + RT.nextID()))
                                    )
                                    (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                                        (if (some? primc)
                                            (do
                                                (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, bindingLabels.get(bi), end, bi.binding.idx))
                                            )
                                            (do
                                                (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, bindingLabels.get(bi), end, bi.binding.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"LetExpr" this]
            (ß body.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"LetExpr" this]
            (ß body.getJavaClass())
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"LetExpr" this]
            (ß (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive()))
        )
    )

    (class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"IPersistentVector" args nil)
            (§ field #_"IPersistentVector" loopLocals nil)

            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
            (§ field #_"String" source nil)
        )

        (§ constructor #_"RecurExpr" RecurExpr [#_"IPersistentVector" loopLocals, #_"IPersistentVector" args, #_"int" line, #_"int" column, #_"String" source]
            (let [this (ß super())]
                (§ ass (ß this.loopLocals) loopLocals)
                (§ ass (ß this.args) args)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (§ ass (ß this.source) source)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"RecurExpr" this]
            (throw (UnsupportedOperationException. "Can't eval recur"))
        )

        #_method
        (§ defn #_"void" emit [#_"RecurExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" loopLabel (ß (Label) LOOP_LABEL.deref())]
                (when (nil? loopLabel)
                    (throw (IllegalStateException.))
                )
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < loopLocals.count()) [(§ ass i (ß i + 1))]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                        (let [#_"Expr" arg (ß (Expr) args.nth(i))]
                            (if (ß lb.getPrimitiveType() != nil)
                                (do
                                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                        (let [#_"Class" pc (ß maybePrimitiveType(arg))]
                                            (cond (ß pc == primc)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                )
                                                (ß primc == long.class && pc == int.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(I2L))
                                                )
                                                (ß primc == double.class && pc == float.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(F2D))
                                                )
                                                (ß primc == int.class && pc == long.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                                )
                                                (ß primc == float.class && pc == double.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(D2F))
                                                )
                                                :else
                                                (do
                                                    (throw (ß new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName())))
                                                )
                                            )
                                        )
                                    )
                                )
                                (do
                                    (ß arg.emit(C.EXPRESSION, objx, gen))
                                )
                            )
                        )
                    )
                )

                (loop-when-recur [(§ var #_"int" i (ß loopLocals.count() - 1))] (ß i >= 0) [(§ ass i (ß i - 1))]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (if (ß lb.isArg)
                                (do
                                    (ß gen.storeArg(lb.idx - (objx.canBeDirect ? 0 :or 1)))
                                )
                                (do
                                    (if (some? primc)
                                        (do
                                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx))
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (ß gen.goTo(loopLabel))
                nil
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"RecurExpr" this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"RecurExpr" this]
            RECUR_CLASS
        )

        #_stateless
        (class-ns RecurExpr'Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"RecurExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"int" line (ß lineDeref())]
                    (let [#_"int" column (ß columnDeref())]
                        (let [#_"String" source (ß (String) SOURCE.deref())]
                            (let [#_"ISeq" form (ß (ISeq) frm)]
                                (let [#_"IPersistentVector" loopLocals (ß (IPersistentVector) LOOP_LOCALS.deref())]
                                    (when (ß context != C.RETURN || loopLocals == nil)
                                        (throw (UnsupportedOperationException. "Can only recur from tail position"))
                                    )
                                    (when (ß NO_RECUR.deref() != nil)
                                        (throw (UnsupportedOperationException. "Cannot recur across try"))
                                    )
                                    (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                        (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(form.next())))] (some? s) [(§ ass s (ß s.next()))]
                                            (§ ass args (ß args.cons(analyze(C.EXPRESSION, s.first()))))
                                        )
                                        (when (ß args.count() != loopLocals.count())
                                            (throw (ß new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count()))))
                                        )
                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < loopLocals.count()) [(§ ass i (ß i + 1))]
                                            (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                                                (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                    (when (some? primc)
                                                        (let [#_"boolean" mismatch false]
                                                            (let [#_"Class" pc (ß maybePrimitiveType((Expr) args.nth(i)))]
                                                                (cond (ß primc == long.class)
                                                                    (do
                                                                        (when (ß !(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class))
                                                                            (§ ass mismatch true)
                                                                        )
                                                                    )
                                                                    (ß primc == double.class)
                                                                    (do
                                                                        (when (ß !(pc == double.class || pc == float.class))
                                                                            (§ ass mismatch true)
                                                                        )
                                                                    )
                                                                )
                                                                (when mismatch
                                                                    (§ ass (ß lb.recurMistmatch) true)
                                                                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                                        (ß RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + ((pc != nil) ? pc.getName() :or "Object") + ", needed: " + primc.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (ß new RecurExpr(loopLocals, args, line, column, source))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"RecurExpr" this]
            true
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"RecurExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emit(context, objx, gen))
            nil
        )
    )

    (§ defn- #_"LocalBinding" registerLocal [#_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg]
        (let [#_"int" num (ß getAndIncLocalNum())]
            (let [#_"LocalBinding" b (ß new LocalBinding(num, sym, tag, init, isArg, clearPathRoot()))]
                (let [#_"IPersistentMap" localsMap (ß (IPersistentMap) LOCAL_ENV.deref())]
                    (ß LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b)))
                    (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                        (§ ass (ß method.locals) (ß (IPersistentMap) RT.assoc(method.locals, b, b)))
                        (§ ass (ß method.indexlocals) (ß (IPersistentMap) RT.assoc(method.indexlocals, num, b)))
                        b
                    )
                )
            )
        )
    )

    (§ defn- #_"int" getAndIncLocalNum []
        (let [#_"int" num (ß ((Number) NEXT_LOCAL_NUM.deref()).intValue())]
            (let [#_"ObjMethod" m (ß (ObjMethod) METHOD.deref())]
                (when (ß num > m.maxLocal)
                    (§ ass (ß m.maxLocal) num)
                )
                (ß NEXT_LOCAL_NUM.set(num + 1))
                num
            )
        )
    )

    (§ defn #_"Expr" analyze [#_"C" context, #_"Object" form]
        (ß analyze(context, form, nil))
    )

    (§ defn- #_"Expr" analyze [#_"C" context, #_"Object" form, #_"String" name]
        ;; todo symbol macro expansion?
        (try
            (when (ß form instanceof LazySeq)
                (let [#_"Object" mform form]
                    (§ ass form (ß RT.seq(form)))
                    (when (nil? form)
                        (§ ass form (ß PersistentList.EMPTY))
                    )
                    (§ ass form (ß ((IObj)form).withMeta(RT.meta(mform))))
                )
            )
            (cond (nil? form)
                (do
                    (§ return NIL_EXPR)
                )
                (ß form == Boolean.TRUE)
                (do
                    (§ return TRUE_EXPR)
                )
                (ß form == Boolean.FALSE)
                (do
                    (§ return FALSE_EXPR)
                )
            )
            (let [#_"Class" fclass (ß form.getClass())]
                (cond (ß fclass == Symbol.class)
                    (do
                        (§ return (ß analyzeSymbol((Symbol) form)))
                    )
                    (ß fclass == Keyword.class)
                    (do
                        (§ return (ß registerKeyword((Keyword) form)))
                    )
                    (ß form instanceof Number)
                    (do
                        (§ return (ß NumberExpr.parse((Number) form)))
                    )
                    (ß fclass == String.class)
                    (do
                        (§ return (ß new StringExpr(((String) form).intern())))
                    )
                    (ß form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0)
                    (do
                        (let [#_"Expr" ret (EmptyExpr. form)]
                            (when (ß RT.meta(form) != nil)
                                (§ ass ret (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
                            )
                            (§ return ret)
                        )
                    )
                    (ß form instanceof ISeq)
                    (do
                        (§ return (ß analyzeSeq(context, (ISeq) form, name)))
                    )
                    (ß form instanceof IPersistentVector)
                    (do
                        (§ return (ß VectorExpr.parse(context, (IPersistentVector) form)))
                    )
                    (ß form instanceof IRecord)
                    (do
                        (§ return (ConstantExpr. form))
                    )
                    (ß form instanceof IType)
                    (do
                        (§ return (ConstantExpr. form))
                    )
                    (ß form instanceof IPersistentMap)
                    (do
                        (§ return (ß MapExpr.parse(context, (IPersistentMap) form)))
                    )
                    (ß form instanceof IPersistentSet)
                    (do
                        (§ return (ß SetExpr.parse(context, (IPersistentSet) form)))
                    )
                )

                (ConstantExpr. form)
            )
            (catch Throwable e
                (if (ß !(e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                    )
                    (do
                        (throw (ß (CompilerException) e))
                    )
                )
            )
        )
    )

    (class-ns CompilerException (§ extends RuntimeException)
        (§ init
            (§ field #_"String" source nil)
            (§ field #_"int" line 0)
        )

        (§ constructor #_"CompilerException" CompilerException [#_"String" source, #_"int" line, #_"int" column, #_"Throwable" cause]
            (let [this (ß super(errorMsg(source, line, column, cause.toString()), cause))]
                (§ ass (ß this.source) source)
                (§ ass (ß this.line) line)
                this
            )
        )

        #_method
        (§ defn #_"String" toString [#_"CompilerException" this]
            (ß getMessage())
        )
    )

    (§ defn #_"Var" isMacro [#_"Object" op]
        ;; no local macros for now
        (when (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (when (ß op instanceof Symbol || op instanceof Var)
            (let [#_"Var" v (ß (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false))]
                (when (ß v != nil && v.isMacro())
                    (when (ß v.ns != currentNS() && !v.isPublic())
                        (throw (IllegalStateException. (ß "var: " + v + " is not public")))
                    )
                    (§ return v)
                )
            )
        )
        nil
    )

    (§ defn #_"IFn" isInline [#_"Object" op, #_"int" arity]
        ;; no local inlines for now
        (when (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (when (ß op instanceof Symbol || op instanceof Var)
            (let [#_"Var" v (ß (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false))]
                (when (some? v)
                    (when (ß v.ns != currentNS() && !v.isPublic())
                        (throw (IllegalStateException. (ß "var: " + v + " is not public")))
                    )
                    (let [#_"IFn" ret (ß (IFn) RT.get(v.meta(), inlineKey))]
                        (when (some? ret)
                            (let [#_"IFn" arityPred (ß (IFn) RT.get(v.meta(), inlineAritiesKey))]
                                (when (ß arityPred == nil || RT.booleanCast(arityPred.invoke(arity)))
                                    (§ return ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"boolean" namesStaticMember [#_"Symbol" sym]
        (ß (sym.ns != nil && namespaceFor(sym) == nil))
    )

    (§ defn #_"Object" preserveTag [#_"ISeq" src, #_"Object" dst]
        (let [#_"Symbol" tag (ß tagOf(src))]
            (when (ß tag != nil && dst instanceof IObj)
                (let [#_"IPersistentMap" meta (ß RT.meta(dst))]
                    (§ return (ß ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))))
                )
            )
            dst
        )
    )

    #_volatile
    (§ def- #_"Var" MACRO_CHECK nil)
    #_volatile
    (§ def- #_"boolean" MACRO_CHECK_LOADING false)
    (§ def- #_"Object" MACRO_CHECK_LOCK (Object.))

    (§ defn- #_"Var" ensureMacroCheck [] (§ throws ClassNotFoundException, IOException)
        (when (nil? MACRO_CHECK)
            (§ sync MACRO_CHECK_LOCK
                (when (nil? MACRO_CHECK)
                    (§ ass MACRO_CHECK_LOADING true)
                    (ß RT.load("cloiure/spec/alpha"))
                    (ß RT.load("cloiure/core/specs/alpha"))
                    (§ ass MACRO_CHECK (ß Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check"))))
                    (§ ass MACRO_CHECK_LOADING false)
                )
            )
        )
        MACRO_CHECK
    )

    (§ defn #_"void" checkSpecs [#_"Var" v, #_"ISeq" form]
        (when (ß RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
            (try
                (ß ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next()))))
                (catch Exception e
                    (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                )
            )
        )
        nil
    )

    (§ defn #_"Object" macroexpand1 [#_"Object" x]
        (when (ß x instanceof ISeq)
            (let [#_"ISeq" form (ß (ISeq) x)]
                (let [#_"Object" op (ß RT.first(form))]
                    (when (ß isSpecial(op))
                        (§ return x)
                    )
                    ;; macro expansion
                    (let [#_"Var" v (ß isMacro(op))]
                        (if (some? v)
                            (do
                                (ß checkSpecs(v, form))

                                (try
                                    (let [#_"ISeq" args (ß RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next())))]
                                        (§ return (ß v.applyTo(args)))
                                    )
                                    (catch ArityException e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß new ArityException(e.actual - 2, e.name)))
                                    )
                                )
                            )
                            (do
                                (when (ß op instanceof Symbol)
                                    (let [#_"Symbol" sym (ß (Symbol) op)]
                                        (let [#_"String" sname (ß sym.name)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß sym.name.charAt(0) == \.)
                                                (do
                                                    (when (ß RT.length(form) < 2)
                                                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (.member target ...)")))
                                                    )
                                                    (let [#_"Symbol" meth (ß Symbol.intern(sname.substring(1)))]
                                                        (let [#_"Object" target (ß RT.second(form))]
                                                            (when (ß HostExpr.maybeClass(target, false) != nil)
                                                                (§ ass target (ß ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS))))
                                                            )
                                                            (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))))
                                                        )
                                                    )
                                                )
                                                (ß namesStaticMember(sym))
                                                (do
                                                    (let [#_"Symbol" target (ß Symbol.intern(sym.ns))]
                                                        (let [#_"Class" c (ß HostExpr.maybeClass(target, false))]
                                                            (when (some? c)
                                                                (let [#_"Symbol" meth (ß Symbol.intern(sym.name))]
                                                                    (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next()))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" idx (ß sname.lastIndexOf(\.))]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß idx == sname.length() - 1)
                                                            (§ return (ß RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn #_"Object" macroexpand [#_"Object" form]
        (let [#_"Object" exf (ß macroexpand1(form))]
            (when (ß exf != form)
                (§ return (ß macroexpand(exf)))
            )
            form
        )
    )

    (§ defn- #_"Expr" analyzeSeq [#_"C" context, #_"ISeq" form, #_"String" name]
        (let [#_"Object" line (ß lineDeref())]
            (let [#_"Object" column (ß columnDeref())]
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                    (§ ass line (ß RT.meta(form).valAt(RT.LINE_KEY)))
                )
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                    (§ ass column (ß RT.meta(form).valAt(RT.COLUMN_KEY)))
                )
                (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
                (try
                    (let [#_"Object" me (ß macroexpand1(form))]
                        (when (ß me != form)
                            (§ return (ß analyze(context, me, name)))
                        )

                        (let [#_"Object" op (ß RT.first(form))]
                            (when (nil? op)
                                (throw (ß new IllegalArgumentException("Can't call nil, form: " + form)))
                            )
                            (let [#_"IFn" inline (ß isInline(op, RT.count(RT.next(form))))]
                                (when (some? inline)
                                    (§ return (ß analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))))
                                )
                                (§ let [#_"IParser" p]
                                    (cond (ß op.equals(FN))
                                        (do
                                            (ß FnExpr.parse(context, form, name))
                                        )
                                        (some? (§ ass p (ß (IParser) specials.valAt(op))))
                                        (do
                                            (ß p.parse(context, form))
                                        )
                                        :else
                                        (do
                                            (ß InvokeExpr.parse(context, form))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable e
                        (if (ß !(e instanceof CompilerException))
                            (do
                                (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                            )
                            (do
                                (throw (ß (CompilerException) e))
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn #_"String" errorMsg [#_"String" source, #_"int" line, #_"int" column, #_"String" s]
        (ß String.format("%s, compiling:(%s:%d:%d)", s, source, line, column))
    )

    (§ defn #_"Object" eval [#_"Object" form]
        (ß eval(form, true))
    )

    (§ defn #_"Object" eval [#_"Object" form, #_"boolean" freshLoader]
        (let [#_"boolean" createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader())))
                (§ ass createdLoader true)
            )
            (try
                (let [#_"Object" line (ß lineDeref())]
                    (let [#_"Object" column (ß columnDeref())]
                        (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                            (§ ass line (ß RT.meta(form).valAt(RT.LINE_KEY)))
                        )
                        (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                            (§ ass column (ß RT.meta(form).valAt(RT.COLUMN_KEY)))
                        )
                        (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
                        (try
                            (§ ass form (ß macroexpand(form)))
                            (cond (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                                (do
                                    (let [#_"ISeq" s (ß RT.next(form))]
                                        (loop-when-recur [(ß )] (ß RT.next(s) != nil) [(§ ass s (ß RT.next(s)))]
                                            (ß eval(RT.first(s), false))
                                        )
                                        (ß eval(RT.first(s), false))
                                    )
                                )
                                (ß (form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def"))))
                                (do
                                    (let [#_"ObjExpr" fexpr (ß (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID()))]
                                        (let [#_"IFn" fn (ß (IFn) fexpr.eval())]
                                            (ß fn.invoke())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" expr (ß analyze(C.EVAL, form))]
                                        (ß expr.eval())
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
                (finally
                    (when createdLoader
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn- #_"int" registerConstant [#_"Object" o]
        (when (ß !CONSTANTS.isBound())
            (§ return -1)
        )
        (let [#_"PersistentVector" v (ß (PersistentVector) CONSTANTS.deref())]
            (let [#_"IdentityHashMap<Object, Integer>" ids (ß (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref())]
                (let [#_"Integer" i (ß ids.get(o))]
                    (when (some? i)
                        (§ return i)
                    )
                    (ß CONSTANTS.set(RT.conj(v, o)))
                    (ß ids.put(o, v.count()))
                    (ß v.count())
                )
            )
        )
    )

    (§ defn- #_"KeywordExpr" registerKeyword [#_"Keyword" keyword]
        (when (ß !KEYWORDS.isBound())
            (§ return (KeywordExpr. keyword))
        )

        (let [#_"IPersistentMap" keywordsMap (ß (IPersistentMap) KEYWORDS.deref())]
            (let [#_"Object" id (ß RT.get(keywordsMap, keyword))]
                (when (nil? id)
                    (ß KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword))))
                )
                (KeywordExpr. keyword)
            )
        )
    )

    (§ defn- #_"int" registerKeywordCallsite [#_"Keyword" keyword]
        (when (ß !KEYWORD_CALLSITES.isBound())
            (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" keywordCallsites (ß (IPersistentVector) KEYWORD_CALLSITES.deref())]
            (§ ass keywordCallsites (ß keywordCallsites.cons(keyword)))
            (ß KEYWORD_CALLSITES.set(keywordCallsites))
            (ß keywordCallsites.count() - 1)
        )
    )

    (§ defn- #_"int" registerProtocolCallsite [#_"Var" v]
        (when (ß !PROTOCOL_CALLSITES.isBound())
            (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" protocolCallsites (ß (IPersistentVector) PROTOCOL_CALLSITES.deref())]
            (§ ass protocolCallsites (ß protocolCallsites.cons(v)))
            (ß PROTOCOL_CALLSITES.set(protocolCallsites))
            (ß protocolCallsites.count() - 1)
        )
    )

    (§ defn- #_"void" registerVarCallsite [#_"Var" v]
        (when (ß !VAR_CALLSITES.isBound())
            (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
        )

        (let [#_"IPersistentCollection" varCallsites (ß (IPersistentCollection) VAR_CALLSITES.deref())]
            (§ ass varCallsites (ß varCallsites.cons(v)))
            (ß VAR_CALLSITES.set(varCallsites))
            nil
        )
    )

    (§ defn #_"ISeq" fwdPath [#_"PathNode" p1]
        (let [#_"ISeq" ret nil]
            (loop-when-recur [(ß )] (some? p1) [(§ ass p1 (ß p1.parent))]
                (§ ass ret (ß RT.cons(p1, ret)))
            )
            ret
        )
    )

    (§ defn #_"PathNode" commonPath [#_"PathNode" n1, #_"PathNode" n2]
        (let [#_"ISeq" xp (ß fwdPath(n1))]
            (let [#_"ISeq" yp (ß fwdPath(n2))]
                (when (ß RT.first(xp) != RT.first(yp))
                    (§ return nil)
                )
                (while (ß RT.second(xp) != nil && RT.second(xp) == RT.second(yp))
                    (§ ass xp (ß xp.next()))
                    (§ ass yp (ß yp.next()))
                )
                (ß (PathNode) RT.first(xp))
            )
        )
    )

    (§ defn #_"void" addAnnotation [#_"Object" visitor, #_"IPersistentMap" meta]
        (when (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta))
        )
        nil
    )

    (§ defn #_"void" addParameterAnnotation [#_"Object" visitor, #_"IPersistentMap" meta, #_"int" i]
        (when (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta, i))
        )
        nil
    )

    (§ defn- #_"Expr" analyzeSymbol [#_"Symbol" sym]
        (let [#_"Symbol" tag (ß tagOf(sym))]
            (cond (ß sym.ns == nil) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" b (ß referenceLocal(sym))]
                        (when (some? b)
                            (§ return (ß new LocalBindingExpr(b, tag)))
                        )
                    )
                )
                (ß namespaceFor(sym) == nil)
                (do
                    (let [#_"Symbol" nsSym (ß Symbol.intern(sym.ns))]
                        (let [#_"Class" c (ß HostExpr.maybeClass(nsSym, false))]
                            (when (some? c)
                                (when (ß Reflector.getField(c, sym.name, true) != nil)
                                    (§ return (ß new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)))
                                )
                                (throw (ß Util.runtimeException("Unable to find static field: " + sym.name + " in " + c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" o (ß resolve(sym))]
                (cond (ß o instanceof Var)
                    (do
                        (let [#_"Var" v (ß (Var) o)]
                            (when (ß isMacro(v) != nil)
                                (throw (ß Util.runtimeException("Can't take value of a macro: " + v)))
                            )
                            (when (ß RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
                                (§ return (ß analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))))
                            )
                            (ß registerVar(v))
                            (§ return (ß new VarExpr(v, tag)))
                        )
                    )
                    (ß o instanceof Class)
                    (do
                        (§ return (ConstantExpr. o))
                    )
                    (ß o instanceof Symbol)
                    (do
                        (§ return (ß new UnresolvedVarExpr((Symbol) o)))
                    )
                )

                (throw (ß Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")))
            )
        )
    )

    (§ defn #_"String" destubClassName [#_"String" className]
        ;; skip over prefix + '.' or '/'
        (when (ß className.startsWith(COMPILE_STUB_PREFIX))
            (§ return (ß className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        className
    )

    (§ defn #_"Type" getType [#_"Class" c]
        (let [#_"String" descriptor (ß Type.getType(c).getDescriptor())]
            (when (ß descriptor.startsWith("L"))
                (§ ass descriptor (ß "L" + destubClassName(descriptor.substring(1))))
            )
            (ß Type.getType(descriptor))
        )
    )

    (§ defn #_"Object" resolve [#_"Symbol" sym, #_"boolean" allowPrivate]
        (ß resolveIn(currentNS(), sym, allowPrivate))
    )

    (§ defn #_"Object" resolve [#_"Symbol" sym]
        (ß resolveIn(currentNS(), sym, false))
    )

    (§ defn #_"Namespace" namespaceFor [#_"Symbol" sym]
        (ß namespaceFor(currentNS(), sym))
    )

    (§ defn #_"Namespace" namespaceFor [#_"Namespace" inns, #_"Symbol" sym]
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" nsSym (ß Symbol.intern(sym.ns))]
            (let [#_"Namespace" ns (ß inns.lookupAlias(nsSym))]
                (when (nil? ns)
                    ;; ...otherwise check the Namespaces map.
                    (§ ass ns (ß Namespace.find(nsSym)))
                )
                ns
            )
        )
    )

    (§ defn #_"Object" resolveIn [#_"Namespace" n, #_"Symbol" sym, #_"boolean" allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond (ß sym.ns != nil)
            (do
                (let [#_"Namespace" ns (ß namespaceFor(n, sym))]
                    (when (nil? ns)
                        (throw (ß Util.runtimeException("No such namespace: " + sym.ns)))
                    )

                    (let [#_"Var" v (ß ns.findInternedVar(Symbol.intern(sym.name)))]
                        (cond (nil? v)
                            (do
                                (throw (ß Util.runtimeException("No such var: " + sym)))
                            )
                            (ß v.ns != currentNS() && !v.isPublic() && !allowPrivate)
                            (do
                                (throw (IllegalStateException. (ß "var: " + sym + " is not public")))
                            )
                        )
                        v
                    )
                )
            )
            (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
            (do
                (ß RT.classForName(sym.name))
            )
            (ß sym.equals(NS))
            (do
                (ß RT.NS_VAR)
            )
            (ß sym.equals(IN_NS))
            (do
                (ß RT.IN_NS_VAR)
            )
            :else
            (do
                (when (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                    (§ return (ß COMPILE_STUB_CLASS.get()))
                )
                (let [#_"Object" o (ß n.getMapping(sym))]
                    (when (nil? o)
                        (if (ß RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return sym)
                            )
                            (do
                                (throw (ß Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")))
                            )
                        )
                    )
                    o
                )
            )
        )
    )

    (§ defn #_"Object" maybeResolveIn [#_"Namespace" n, #_"Symbol" sym]
        ;; note - ns-qualified vars must already exist
        (cond (ß sym.ns != nil)
            (do
                (let [#_"Namespace" ns (ß namespaceFor(n, sym))]
                    (when (nil? ns)
                        (§ return nil)
                    )
                    (let [#_"Var" v (ß ns.findInternedVar(Symbol.intern(sym.name)))]
                        (when (nil? v)
                            (§ return nil)
                        )
                        v
                    )
                )
            )
            (ß sym.name.indexOf(\.) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == \[)
            (do
                (ß RT.classForName(sym.name))
            )
            (ß sym.equals(NS))
            (do
                (ß RT.NS_VAR)
            )
            (ß sym.equals(IN_NS))
            (do
                (ß RT.IN_NS_VAR)
            )
            :else
            (do
                (let [#_"Object" o (ß n.getMapping(sym))]
                    o
                )
            )
        )
    )

    (§ defn #_"Var" lookupVar [#_"Symbol" sym, #_"boolean" internNew, #_"boolean" registerMacro]
        (let [#_"Var" var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß sym.ns != nil)
                (do
                    (let [#_"Namespace" ns (ß namespaceFor(sym))]
                        (when (nil? ns)
                            (§ return nil)
                        )
                        (let [#_"Symbol" name (ß Symbol.intern(sym.name))]
                            (if (ß internNew && ns == currentNS())
                                (do
                                    (§ ass var (ß currentNS().intern(name)))
                                )
                                (do
                                    (§ ass var (ß ns.findInternedVar(name)))
                                )
                            )
                        )
                    )
                )
                (ß sym.equals(NS))
                (do
                    (§ ass var (ß RT.NS_VAR))
                )
                (ß sym.equals(IN_NS))
                (do
                    (§ ass var (ß RT.IN_NS_VAR))
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" o (ß currentNS().getMapping(sym))]
                        (cond (nil? o)
                            (do
                                ;; introduce a new var in the current ns
                                (when internNew
                                    (§ ass var (ß currentNS().intern(Symbol.intern(sym.name))))
                                )
                            )
                            (ß o instanceof Var)
                            (do
                                (§ ass var (ß (Var) o))
                            )
                            :else
                            (do
                                (throw (ß Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o)))
                            )
                        )
                    )
                )
            )
            (when (ß var != nil && (!var.isMacro() || registerMacro))
                (ß registerVar(var))
            )
            var
        )
    )

    (§ defn #_"Var" lookupVar [#_"Symbol" sym, #_"boolean" internNew]
        (ß lookupVar(sym, internNew, true))
    )

    (§ defn- #_"void" registerVar [#_"Var" var]
        (when (ß !VARS.isBound())
            (§ return nil)
        )
        (let [#_"IPersistentMap" varsMap (ß (IPersistentMap) VARS.deref())]
            (let [#_"Object" id (ß RT.get(varsMap, var))]
                (when (nil? id)
                    (ß VARS.set(RT.assoc(varsMap, var, registerConstant(var))))
                )
                nil
            )
        )
    )

    (§ defn #_"Namespace" currentNS []
        (ß (Namespace) RT.CURRENT_NS.deref())
    )

    (§ defn #_"void" closeOver [#_"LocalBinding" b, #_"ObjMethod" method]
        (when (ß b != nil && method != nil)
            (let [#_"LocalBinding" lb (ß (LocalBinding) RT.get(method.locals, b))]
                (if (nil? lb)
                    (do
                        (§ ass (ß method.objx.closes) (ß (IPersistentMap) RT.assoc(method.objx.closes, b, b)))
                        (ß closeOver(b, method.parent))
                    )
                    (do
                        (when (ß lb.idx == 0)
                            (§ ass (ß method.usesThis) true)
                        )
                        (when (ß IN_CATCH_FINALLY.deref() != nil)
                            (§ ass (ß method.localsUsedInCatchFinally) (ß (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx)))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"LocalBinding" referenceLocal [#_"Symbol" sym]
        (when (ß !LOCAL_ENV.isBound())
            (§ return nil)
        )
        (let [#_"LocalBinding" b (ß (LocalBinding) RT.get(LOCAL_ENV.deref(), sym))]
            (when (some? b)
                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                    (when (ß b.idx == 0)
                        (§ ass (ß method.usesThis) true)
                    )
                    (ß closeOver(b, method))
                )
            )
            b
        )
    )

    (§ defn- #_"Symbol" tagOf [#_"Object" o]
        (let [#_"Object" tag (ß RT.get(RT.meta(o), RT.TAG_KEY))]
            (cond (ß tag instanceof Symbol)
                (do
                    (§ return (ß (Symbol) tag))
                )
                (ß tag instanceof String)
                (do
                    (§ return (ß Symbol.intern(nil, (String) tag)))
                )
            )
            nil
        )
    )

    (§ defn #_"Object" loadFile [#_"String" file] (§ throws IOException)
        (let [#_"FileInputStream" f (FileInputStream. file)]
            (try
                (ß load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName()))
                (finally
                    (ß f.close())
                )
            )
        )
    )

    (§ defn #_"Object" load [#_"Reader" rdr]
        (ß load(rdr, nil, "NO_SOURCE_FILE"))
    )

    (§ defn #_"void" consumeWhitespaces [#_"LineNumberingPushbackReader" pushbackReader]
        (let [#_"int" ch (ß LispReader.read1(pushbackReader))]
            (while (ß LispReader.isWhitespace(ch))
                (§ ass ch (ß LispReader.read1(pushbackReader)))
            )
            (ß LispReader.unread(pushbackReader, ch))
            nil
        )
    )

    (§ def- #_"Object" OPTS_COND_ALLOWED (ß RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW)))

    (§ defn- #_"Object" readerOpts [#_"String" sourceName]
        (if (ß sourceName != nil && sourceName.endsWith(".clic"))
            (do
                OPTS_COND_ALLOWED
            )
            (do
                nil
            )
        )
    )

    (§ defn #_"Object" load [#_"Reader" rdr, #_"String" sourcePath, #_"String" sourceName]
        (let [(§ var #_"Object" EOF (Object.))]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (ß (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))]
                    (ß consumeWhitespaces(pushbackReader))
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                        #_map LOADER, RT.makeClassLoader(),
                        #_map SOURCE_PATH, sourcePath,
                        #_map SOURCE, sourceName,
                        #_map METHOD, nil,
                        #_map LOCAL_ENV, nil,
                        #_map LOOP_LOCALS, nil,
                        #_map NEXT_LOCAL_NUM, 0,
                        #_map RT.READEVAL, RT.T,
                        #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                        #_map LINE_BEFORE, pushbackReader.getLineNumber(),
                        #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                        #_map LINE_AFTER, pushbackReader.getLineNumber(),
                        #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
                        #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                        #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                        #_map RT.DATA_READERS, RT.DATA_READERS.deref()
                    )))

                    (let [#_"Object" readerOpts (ß readerOpts(sourceName))]
                        (try
                            (loop-when-recur [(§ var #_"Object" r (ß LispReader.read(pushbackReader, false, EOF, false, readerOpts)))] (ß r != EOF) [(§ ass r (ß LispReader.read(pushbackReader, false, EOF, false, readerOpts)))]
                                (ß consumeWhitespaces(pushbackReader))
                                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                                (§ ass ret (ß eval(r, false)))
                                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
                            )
                            (catch (ß LispReader'ReaderException) e
                                (throw (ß new CompilerException(sourcePath, e.line, e.column, e.getCause())))
                            )
                            (catch Throwable e
                                (if (ß !(e instanceof CompilerException))
                                    (do
                                        (throw (ß new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e)))
                                    )
                                    (do
                                        (throw (ß (CompilerException) e))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                        ret
                    )
                )
            )
        )
    )

    (§ defn #_"void" writeClassFile [#_"String" internalName, #_"byte[]" bytecode] (§ throws IOException)
        (let [#_"String" genPath (ß (String) COMPILE_PATH.deref())]
            (when (nil? genPath)
                (throw (ß Util.runtimeException("*compile-path* not set")))
            )
            (let [#_"String[]" dirs (ß internalName.split("/"))]
                (let [#_"String" p genPath]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < dirs.length - 1) [(§ ass i (ß i + 1))]
                        (§ ass p (ß p + File.separator + dirs[i]))
                        (ß (new File(p)).mkdir())
                    )
                    (let [#_"String" path (ß genPath + File.separator + internalName + ".class")]
                        (let [#_"File" cf (File. path)]
                            (ß cf.createNewFile())
                            (let [#_"FileOutputStream" cfs (FileOutputStream. cf)]
                                (try
                                    (ß cfs.write(bytecode))
                                    (ß cfs.flush())
                                    (finally
                                        (ß cfs.close())
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" pushNS []
        (ß Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil)))
        nil
    )

    (§ defn #_"void" pushNSandLoader [#_"ClassLoader" loader]
        (ß Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T)))
        nil
    )

    (§ defn #_"ILookupThunk" getLookupThunk [#_"Object" target, #_"Keyword" k]
        nil
    )

    (§ defn #_"void" compile1 [#_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"Object" form]
        (let [#_"Object" line (ß lineDeref())]
            (let [#_"Object" column (ß columnDeref())]
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                    (§ ass line (ß RT.meta(form).valAt(RT.LINE_KEY)))
                )
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                    (§ ass column (ß RT.meta(form).valAt(RT.COLUMN_KEY)))
                )
                (ß Var.pushThreadBindings(RT.map(
                    #_map LINE, line, COLUMN, column,
                    #_map LOADER, RT.makeClassLoader()
                )))
                (try
                    (§ ass form (ß macroexpand(form)))
                    (if (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                        (do
                            (loop-when-recur [(§ var #_"ISeq" s (ß RT.next(form)))] (some? s) [(§ ass s (ß RT.next(s)))]
                                (ß compile1(gen, objx, RT.first(s)))
                            )
                        )
                        (do
                            (let [#_"Expr" expr (ß analyze(C.EVAL, form))]
                                (§ ass (ß objx.keywords) (ß (IPersistentMap) KEYWORDS.deref()))
                                (§ ass (ß objx.vars) (ß (IPersistentMap) VARS.deref()))
                                (§ ass (ß objx.constants) (ß (PersistentVector) CONSTANTS.deref()))
                                (ß expr.emit(C.EXPRESSION, objx, gen))
                                (ß expr.eval())
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
                nil
            )
        )
    )

    (§ defn #_"Object" compile [#_"Reader" rdr, #_"String" sourcePath, #_"String" sourceName] (§ throws IOException)
        (when (ß COMPILE_PATH.deref() == nil)
            (throw (ß Util.runtimeException("*compile-path* not set")))
        )

        (let [(§ var #_"Object" EOF (Object.))]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (ß (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))]
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                        #_map SOURCE_PATH, sourcePath,
                        #_map SOURCE, sourceName,
                        #_map METHOD, nil,
                        #_map LOCAL_ENV, nil,
                        #_map LOOP_LOCALS, nil,
                        #_map NEXT_LOCAL_NUM, 0,
                        #_map RT.READEVAL, RT.T,
                        #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                        #_map LINE_BEFORE, pushbackReader.getLineNumber(),
                        #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                        #_map LINE_AFTER, pushbackReader.getLineNumber(),
                        #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
                        #_map CONSTANTS, PersistentVector.EMPTY,
                        #_map CONSTANT_IDS, new IdentityHashMap(),
                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                        #_map VARS, PersistentHashMap.EMPTY,
                        #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                        #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                        #_map RT.DATA_READERS, RT.DATA_READERS.deref()
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" objx (ObjExpr. nil)]
                            (§ ass (ß objx.internalName) (ß sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf(\.)) + RT.LOADER_SUFFIX))

                            (§ ass (ß objx.objtype) (ß Type.getObjectType(objx.internalName)))
                            (let [#_"ClassWriter" cw (ClassWriter. (ß ClassWriter.COMPUTE_MAXS))]
                                (let [#_"ClassVisitor" cv cw]
                                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), nil, nil, cv))]
                                        (ß gen.visitCode())

                                        (let [#_"Object" readerOpts (ß readerOpts(sourceName))]
                                            (loop-when-recur [(§ var #_"Object" r (ß LispReader.read(pushbackReader, false, EOF, false, readerOpts)))] (ß r != EOF) [(§ ass r (ß LispReader.read(pushbackReader, false, EOF, false, readerOpts)))]
                                                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                                                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                                                (ß compile1(gen, objx, r))
                                                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                                                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
                                            )
                                            ;; end of load
                                            (ß gen.returnValue())
                                            (ß gen.endMethod())

                                            ;; static fields for constants
                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < objx.constants.count()) [(§ ass i (ß i + 1))]
                                                (when (ß objx.usedConstants.contains(i))
                                                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [(§ var #_"int" INITS_PER 100)]
                                                (let [#_"int" numInits (ß objx.constants.count() / INITS_PER)]
                                                    (when (ß objx.constants.count() % INITS_PER != 0)
                                                        (§ ass numInits (ß numInits + 1))
                                                    )

                                                    (loop-when-recur [(§ var #_"int" n 0)] (ß n < numInits) [(§ ass n (ß n + 1))]
                                                        (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), nil, nil, cv))]
                                                            (ß clinitgen.visitCode())
                                                            (try
                                                                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                                                                (loop-when-recur [(§ var #_"int" i (ß n * INITS_PER))] (ß i < objx.constants.count() && i < (n + 1) * INITS_PER) [(§ ass i (ß i + 1))]
                                                                    (when (ß objx.usedConstants.contains(i))
                                                                        (ß objx.emitValue(objx.constants.nth(i), clinitgen))
                                                                        (ß clinitgen.checkCast(objx.constantType(i)))
                                                                        (ß clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var.popThreadBindings())
                                                                )
                                                            )
                                                            (ß clinitgen.returnValue())
                                                            (ß clinitgen.endMethod())
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))]
                                                        (ß clinitgen.visitCode())
                                                        (let [#_"Label" startTry (ß clinitgen.newLabel())]
                                                            (let [#_"Label" endTry (ß clinitgen.newLabel())]
                                                                (let [#_"Label" end (ß clinitgen.newLabel())]
                                                                    (let [#_"Label" finallyLabel (ß clinitgen.newLabel())]
                                                                        (loop-when-recur [(§ var #_"int" n 0)] (ß n < numInits) [(§ ass n (ß n + 1))]
                                                                            (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()")))
                                                                        )

                                                                        (ß clinitgen.push(objx.internalName.replace(\/, \.)))
                                                                        (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                                                                        (ß clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()")))
                                                                        (ß clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (ß clinitgen.mark(startTry))
                                                                        (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()")))
                                                                        (ß clinitgen.mark(endTry))
                                                                        (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
                                                                        (ß clinitgen.goTo(end))

                                                                        (ß clinitgen.mark(finallyLabel))
                                                                        ;; exception should be on stack
                                                                        (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
                                                                        (ß clinitgen.throwException())
                                                                        (ß clinitgen.mark(end))
                                                                        (ß clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))

                                                                        ;; end of static init
                                                                        (ß clinitgen.returnValue())
                                                                        (ß clinitgen.endMethod())

                                                                        ;; end of class
                                                                        (ß cv.visitEnd())

                                                                        (ß writeClassFile(objx.internalName, cw.toByteArray()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (catch (ß LispReader'ReaderException) e
                            (throw (ß new CompilerException(sourcePath, e.line, e.column, e.getCause())))
                        )
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                    ret
                )
            )
        )
    )

    (class-ns NewInstanceExpr (§ extends ObjExpr)
        (§ init
            (§ field #_"IPersistentCollection" methods nil)

            (§ field #_"Map<IPersistentVector, java.lang.reflect.Method>" mmap nil)
            (§ field #_"Map<IPersistentVector, Set<Class>>" covariants nil)
        )

        (§ constructor #_"NewInstanceExpr" NewInstanceExpr [#_"Object" tag]
            (let [this (ß super(tag))]
                this
            )
        )

        #_stateless
        (class-ns DeftypeParser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"DeftypeParser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" rform (ß (ISeq) frm)]
                    ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                    (§ ass rform (ß RT.next(rform)))
                    (let [#_"String" tagname (ß ((Symbol) rform.first()).getName())]
                        (§ ass rform (ß rform.next()))
                        (let [#_"Symbol" classname (ß (Symbol) rform.first())]
                            (§ ass rform (ß rform.next()))
                            (let [#_"IPersistentVector" fields (ß (IPersistentVector) rform.first())]
                                (§ ass rform (ß rform.next()))
                                (let [#_"IPersistentMap" opts (ß PersistentHashMap.EMPTY)]
                                    (while (ß rform != nil && rform.first() instanceof Keyword)
                                        (§ ass opts (ß opts.assoc(rform.first(), RT.second(rform))))
                                        (§ ass rform (ß rform.next().next()))
                                    )

                                    (let [#_"ObjExpr" ret (ß build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, nil, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts))]
                                        ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_stateless
        (class-ns ReifyParser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [#_"ReifyParser" this, #_"C" context, #_"Object" frm]
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (let [#_"ObjMethod" enclosingMethod (ß (ObjMethod) METHOD.deref())]
                        (let [#_"String" basename (ß (enclosingMethod != nil) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$"))]
                            (let [#_"String" simpleName (ß "reify__" + RT.nextID())]
                                (let [#_"String" classname (ß basename + simpleName)]
                                    (let [#_"ISeq" rform (ß RT.next(form))]
                                        (let [#_"IPersistentVector" interfaces (ß ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj")))]
                                            (§ ass rform (ß RT.next(rform)))

                                            (let [#_"ObjExpr" ret (ß build(interfaces, nil, nil, classname, Symbol.intern(classname), nil, rform, frm, nil))]
                                                (if (ß frm instanceof IObj && ((IObj) frm).meta() != nil)
                                                    (do
                                                        (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta())))
                                                    )
                                                    (do
                                                        ret
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn #_"ObjExpr" build [#_"IPersistentVector" interfaceSyms, #_"IPersistentVector" fieldSyms, #_"Symbol" thisSym, #_"String" tagName, #_"Symbol" className, #_"Symbol" typeTag, #_"ISeq" methodForms, #_"Object" frm, #_"IPersistentMap" opts]
            (let [#_"NewInstanceExpr" ret (NewInstanceExpr. nil)]
                (§ ass (ß ret.src) frm)
                (§ ass (ß ret.name) (ß className.toString()))
                (§ ass (ß ret.classMeta) (ß RT.meta(className)))
                (§ ass (ß ret.internalName) (ß ret.name.replace(\., \/)))
                (§ ass (ß ret.objtype) (ß Type.getObjectType(ret.internalName)))
                (§ ass (ß ret.opts) opts)

                (when (some? thisSym)
                    (§ ass (ß ret.thisName) (ß thisSym.name))
                )

                (when (some? fieldSyms)
                    (let [#_"IPersistentMap" fmap (ß PersistentHashMap.EMPTY)]
                        (let [#_"Object[]" closesvec (ß new Object[2 * fieldSyms.count()])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < fieldSyms.count()) [(§ ass i (ß i + 1))]
                                (let [#_"Symbol" sym (ß (Symbol) fieldSyms.nth(i))]
                                    (let [#_"LocalBinding" lb (ß new LocalBinding(-1, sym, nil, new MethodParamExpr(tagClass(tagOf(sym))), false, nil))]
                                        (§ ass fmap (ß fmap.assoc(sym, lb)))
                                        (§ ass (ß closesvec[i * 2]) lb)
                                        (§ ass (ß closesvec[i * 2 + 1]) lb)
                                    )
                                )
                            )

                            ;; todo - inject __meta et al into closes - when?
                            ;; use array map to preserve ctor order
                            (§ ass (ß ret.closes) (PersistentArrayMap. closesvec))
                            (§ ass (ß ret.fields) fmap)
                            (loop-when-recur [(§ var #_"int" i (ß fieldSyms.count() - 1))] (ß i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq"))) [(§ ass i (ß i - 1))]
                                (§ ass (ß ret.altCtorDrops) (ß ret.altCtorDrops + 1))
                            )
                        )
                    )
                )

                (let [#_"PersistentVector" interfaces (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(interfaceSyms)))] (some? s) [(§ ass s (ß s.next()))]
                        (let [#_"Class" c (ß (Class) resolve((Symbol) s.first()))]
                            (when (ß !c.isInterface())
                                (throw (ß new IllegalArgumentException("only interfaces are supported, had: " + c.getName())))
                            )
                            (§ ass interfaces (ß interfaces.cons(c)))
                        )
                    )
                    (let [#_"Class" superClass (ß Object.class)]
                        (let [#_"Map[]" mc (ß gatherMethods(superClass, RT.seq(interfaces)))]
                            (let [#_"Map" overrideables (ß mc[0])]
                                (let [#_"Map" covariants (ß mc[1])]
                                    (§ ass (ß ret.mmap) overrideables)
                                    (§ ass (ß ret.covariants) covariants)

                                    (let [#_"String[]" inames (ß interfaceNames(interfaces))]
                                        (let [#_"Class" stub (ß compileStub(slashname(superClass), ret, inames, frm))]
                                            (let [#_"Symbol" thistag (ß Symbol.intern(nil, stub.getName()))]
                                                (try
                                                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                        #_map CONSTANTS, PersistentVector.EMPTY,
                                                        #_map CONSTANT_IDS, new IdentityHashMap(),
                                                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                                                        #_map VARS, PersistentHashMap.EMPTY,
                                                        #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                                                        #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                                                        #_map VAR_CALLSITES, emptyVarCallSites(),
                                                        #_map NO_RECUR, nil
                                                    )))
                                                    (when (ß ret.isDeftype())
                                                        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                            #_map METHOD, nil,
                                                            #_map LOCAL_ENV, ret.fields,
                                                            #_map COMPILE_STUB_SYM, Symbol.intern(nil, tagName),
                                                            #_map COMPILE_STUB_CLASS, stub
                                                        )))

                                                        (§ ass (ß ret.hintedFields) (ß RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops)))
                                                    )

                                                    ;; now (methodname [args] body)*
                                                    (§ ass (ß ret.line) (ß lineDeref()))
                                                    (§ ass (ß ret.column) (ß columnDeref()))
                                                    (let [#_"IPersistentCollection" methods nil]
                                                        (loop-when-recur [(§ var #_"ISeq" s methodForms)] (some? s) [(§ ass s (ß RT.next(s)))]
                                                            (let [#_"NewInstanceMethod" m (ß NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables))]
                                                                (§ ass methods (ß RT.conj(methods, m)))
                                                            )
                                                        )

                                                        (§ ass (ß ret.methods) methods)
                                                        (§ ass (ß ret.keywords) (ß (IPersistentMap) KEYWORDS.deref()))
                                                        (§ ass (ß ret.vars) (ß (IPersistentMap) VARS.deref()))
                                                        (§ ass (ß ret.constants) (ß (PersistentVector) CONSTANTS.deref()))
                                                        (§ ass (ß ret.constantsID) (ß RT.nextID()))
                                                        (§ ass (ß ret.keywordCallsites) (ß (IPersistentVector) KEYWORD_CALLSITES.deref()))
                                                        (§ ass (ß ret.protocolCallsites) (ß (IPersistentVector) PROTOCOL_CALLSITES.deref()))
                                                        (§ ass (ß ret.varCallsites) (ß (IPersistentSet) VAR_CALLSITES.deref()))
                                                    )
                                                    (finally
                                                        (when (ß ret.isDeftype())
                                                            (ß Var.popThreadBindings())
                                                        )
                                                        (ß Var.popThreadBindings())
                                                    )
                                                )

                                                (try
                                                    (ß ret.compile(slashname(superClass), inames, false))
                                                    (catch IOException e
                                                        (throw (ß Util.sneakyThrow(e)))
                                                    )
                                                )
                                                (ß ret.getCompiledClass())
                                                ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        ;;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;;
        (§ defn #_"Class" compileStub [#_"String" superName, #_"NewInstanceExpr" ret, #_"String[]" interfaceNames, #_"Object" frm]
            (let [#_"ClassWriter" cw (ClassWriter. (ß ClassWriter.COMPUTE_MAXS))]
                (let [#_"ClassVisitor" cv cw]
                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, nil, superName, interfaceNames))

                    ;; instance fields for closed-overs
                    (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(ret.closes)))] (some? s) [(§ ass s (ß s.next()))]
                        (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                            (let [#_"int" access (ß ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL))]
                                (if (ß lb.getPrimitiveType() != nil)
                                    (do
                                        (ß cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                    )
                                    (do
                                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                        (ß cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                    )
                                )
                            )
                        )
                    )

                    ;; ctor that takes closed-overs and does nothing
                    (let [#_"Method" m (ß new Method("<init>", Type.VOID_TYPE, ret.ctorTypes()))]
                        (let [#_"GeneratorAdapter" ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))]
                            (ß ctorgen.visitCode())
                            (ß ctorgen.loadThis())
                            (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))
                            (ß ctorgen.returnValue())
                            (ß ctorgen.endMethod())

                            (when (ß ret.altCtorDrops > 0)
                                (let [#_"Type[]" ctorTypes (ß ret.ctorTypes())]
                                    (let [#_"Type[]" altCtorTypes (ß new Type[ctorTypes.length-ret.altCtorDrops])]
                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < altCtorTypes.length) [(§ ass i (ß i + 1))]
                                            (§ ass (ß altCtorTypes[i]) (ß ctorTypes[i]))
                                        )
                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes))]
                                            (§ ass ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)))
                                            (ß ctorgen.visitCode())
                                            (ß ctorgen.loadThis())
                                            (ß ctorgen.loadArgs())

                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                            (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                            (ß ctorgen.returnValue())
                                            (ß ctorgen.endMethod())

                                            ;; alt ctor no __hash, __hasheq
                                            (§ ass altCtorTypes (ß new Type[ctorTypes.length-2]))
                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < altCtorTypes.length) [(§ ass i (ß i + 1))]
                                                (§ ass (ß altCtorTypes[i]) (ß ctorTypes[i]))
                                            )

                                            (§ ass alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes)))
                                            (§ ass ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)))
                                            (ß ctorgen.visitCode())
                                            (ß ctorgen.loadThis())
                                            (ß ctorgen.loadArgs())

                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                            (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                            (ß ctorgen.returnValue())
                                            (ß ctorgen.endMethod())
                                        )
                                    )
                                )
                            )
                            ;; end of class
                            (ß cv.visitEnd())

                            (let [#_"byte[]" bytecode (ß cw.toByteArray())]
                                (let [#_"DynamicClassLoader" loader (ß (DynamicClassLoader) LOADER.deref())]
                                    (ß loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm))
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn #_"String[]" interfaceNames [#_"IPersistentVector" interfaces]
            (let [#_"int" icnt (ß interfaces.count())]
                (let [#_"String[]" inames (ß (icnt > 0) ? new String[icnt] :or nil)]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < icnt) [(§ ass i (ß i + 1))]
                        (§ ass (ß inames[i]) (ß slashname((Class) interfaces.nth(i))))
                    )
                    inames
                )
            )
        )

        (§ defn #_"String" slashname [#_"Class" c]
            (ß c.getName().replace(\., \/))
        )

        #_protected
        #_method
        (§ defn #_"void" emitStatics [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
            (when (ß this.isDeftype())
                ;; getBasis()
                (let [#_"Method" meth (ß Method.getMethod("cloiure.lang.IPersistentVector getBasis()"))]
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, nil, nil, cv))]
                        (ß emitValue(hintedFields, gen))
                        (ß gen.returnValue())
                        (ß gen.endMethod())

                        (when (ß this.isDeftype() && this.fields.count() > this.hintedFields.count())
                            ;; create(IPersistentMap)
                            (let [#_"String" className (ß name.replace(\., \/))]
                                (let [#_"int" i 1]
                                    (let [#_"int" fieldCount (ß hintedFields.count())]
                                        (let [#_"MethodVisitor" mv (ß cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", nil, nil))]
                                            (ß mv.visitCode())

                                            (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(hintedFields)))] (some? s) [(§ ass s (ß s.next()), i (ß i + 1))]
                                                (let [#_"String" bName (ß ((Symbol)s.first()).name)]
                                                    (let [#_"Class" k (ß tagClass(tagOf(s.first())))]
                                                        (ß mv.visitVarInsn(ALOAD, 0))
                                                        (ß mv.visitLdcInsn(bName))
                                                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                        (ß mv.visitInsn(ACONST_NULL))
                                                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                                                        (when (ß k.isPrimitive())
                                                            (ß mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName()))
                                                        )
                                                        (ß mv.visitVarInsn(ASTORE, i))
                                                        (ß mv.visitVarInsn(ALOAD, 0))
                                                        (ß mv.visitLdcInsn(bName))
                                                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                                                        (ß mv.visitVarInsn(ASTORE, 0))
                                                    )
                                                )
                                            )

                                            (ß mv.visitTypeInsn(Opcodes.NEW, className))
                                            (ß mv.visitInsn(DUP))

                                            (let [#_"Method" ctor (ß new Method("<init>", Type.VOID_TYPE, ctorTypes()))]
                                                (when (ß hintedFields.count() > 0)
                                                    (loop-when-recur [(§ ass i 1)] (ß i <= fieldCount) [(§ ass i (ß i + 1))]
                                                        (ß mv.visitVarInsn(ALOAD, i))
                                                        (let [#_"Class" k (ß tagClass(tagOf(hintedFields.nth(i - 1))))]
                                                            (when (ß k.isPrimitive())
                                                                (let [#_"String" b (ß Type.getType(boxClass(k)).getInternalName())]
                                                                    (let [#_"String" p (ß Type.getType(k).getDescriptor())]
                                                                        (let [#_"String" n (ß k.getName())]
                                                                            (ß mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )

                                                (ß mv.visitInsn(ACONST_NULL)) ;; __meta
                                                (ß mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                                                (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                                                (ß mv.visitInsn(ICONST_0)) ;; __hash
                                                (ß mv.visitInsn(ICONST_0)) ;; __hasheq
                                                (ß mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor()))
                                                (ß mv.visitInsn(ARETURN))
                                                (ß mv.visitMaxs(4 + fieldCount, 1 + fieldCount))
                                                (ß mv.visitEnd())
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        #_protected
        #_method
        (§ defn #_"void" emitMethods [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
            (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(methods)))] (some? s) [(§ ass s (ß s.next()))]
                (let [#_"ObjMethod" method (ß (ObjMethod) s.first())]
                    (ß method.emit(this, cv))
                )
            )
            ;; emit bridge methods
            (doseq [#_"Map.Entry<IPersistentVector, Set<Class>>" (ß e covariants.entrySet())]
                (let [(§ var #_"java.lang.reflect.Method" m (ß mmap.get(e.getKey())))]
                    (let [#_"Class[]" params (ß m.getParameterTypes())]
                        (let [#_"Type[]" argTypes (ß new Type[params.length])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < params.length) [(§ ass i (ß i + 1))]
                                (§ ass (ß argTypes[i]) (ß Type.getType(params[i])))
                            )

                            (let [#_"Method" target (ß new Method(m.getName(), Type.getType(m.getReturnType()), argTypes))]
                                (doseq [#_"Class" retType (ß e.getValue())]
                                    (let [#_"Method" meth (ß new Method(m.getName(), Type.getType(retType), argTypes))]
                                        ;; todo don't hardwire EXCEPTION_TYPES
                                        (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE, meth, nil, EXCEPTION_TYPES, cv))]
                                            (ß gen.visitCode())
                                            (ß gen.loadThis())
                                            (ß gen.loadArgs())
                                            (ß gen.invokeInterface(Type.getType(m.getDeclaringClass()), target))
                                            (ß gen.returnValue())
                                            (ß gen.endMethod())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn #_"IPersistentVector" msig [#_"java.lang.reflect.Method" m]
            (ß RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType()))
        )

        (§ defn #_"void" considerMethod [#_"java.lang.reflect.Method" m, #_"Map" mm]
            (let [#_"IPersistentVector" mk (ß msig(m))]
                (let [#_"int" mods (ß m.getModifiers())]
                    (when (ß !(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods)))
                        (ß mm.put(mk, m))
                    )
                    nil
                )
            )
        )

        (§ defn #_"void" gatherMethods [#_"Class" c, #_"Map" mm]
            (loop-when-recur [(ß )] (some? c) [(§ ass c (ß c.getSuperclass()))]
                (doseq [#_"java.lang.reflect.Method" m (ß c.getDeclaredMethods())]
                    (ß considerMethod(m, mm))
                )
                (doseq [#_"java.lang.reflect.Method" m (ß c.getMethods())]
                    (ß considerMethod(m, mm))
                )
            )
            nil
        )

        (§ defn #_"Map[]" gatherMethods [#_"Class" sc, #_"ISeq" interfaces]
            (let [#_"Map" allm (HashMap.)]
                (ß gatherMethods(sc, allm))
                (loop-when-recur [(ß )] (some? interfaces) [(§ ass interfaces (ß interfaces.next()))]
                    (ß gatherMethods((Class) interfaces.first(), allm))
                )

                (let [#_"Map<IPersistentVector, java.lang.reflect.Method>" mm (ß new HashMap<IPersistentVector, java.lang.reflect.Method>())]
                    (let [#_"Map<IPersistentVector, Set<Class>>" covariants (ß new HashMap<IPersistentVector, Set<Class>>())]
                        (doseq [#_"Object" o (ß allm.entrySet())]
                            (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                                (let [#_"IPersistentVector" mk (ß (IPersistentVector) e.getKey())]
                                    (§ ass mk (ß (IPersistentVector) mk.pop()))
                                    (let [(§ var #_"java.lang.reflect.Method" m (ß (java.lang.reflect.Method) e.getValue()))]
                                        (if (ß mm.containsKey(mk)) ;; covariant return
                                            (do
                                                (let [#_"Set<Class>" cvs (ß covariants.get(mk))]
                                                    (when (nil? cvs)
                                                        (§ ass cvs (ß new HashSet<Class>()))
                                                        (ß covariants.put(mk, cvs))
                                                    )
                                                    (let [(§ var #_"java.lang.reflect.Method" om (ß mm.get(mk)))]
                                                        (if (ß om.getReturnType().isAssignableFrom(m.getReturnType()))
                                                            (do
                                                                (ß cvs.add(om.getReturnType()))
                                                                (ß mm.put(mk, m))
                                                            )
                                                            (do
                                                                (ß cvs.add(m.getReturnType()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (do
                                                (ß mm.put(mk, m))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß new Map[] (§ array mm, covariants ))
                    )
                )
            )
        )
    )

    (class-ns NewInstanceMethod (§ extends ObjMethod)
        (§ def #_"Symbol" dummyThis (ß Symbol.intern(nil, "dummy_this_dlskjsdfower")))

        (§ init
            (§ field #_"String" name nil)
            (§ field #_"Type[]" argTypes nil)
            (§ field #_"Type" retType nil)
            (§ field #_"Class" retClass nil)
            (§ field #_"Class[]" exclasses nil)

            (§ field- #_"IPersistentVector" parms nil)
        )

        (§ constructor #_"NewInstanceMethod" NewInstanceMethod [#_"ObjExpr" objx, #_"ObjMethod" parent]
            (let [this (ß super(objx, parent))]
                this
            )
        )

        #_method
        (§ defn #_"int" numParams [#_"NewInstanceMethod" this]
            (ß argLocals.count())
        )

        #_method
        (§ defn #_"String" getMethodName [#_"NewInstanceMethod" this]
            name
        )

        #_method
        (§ defn #_"Type" getReturnType [#_"NewInstanceMethod" this]
            retType
        )

        #_method
        (§ defn #_"Type[]" getArgTypes [#_"NewInstanceMethod" this]
            argTypes
        )

        (§ defn #_"IPersistentVector" msig [#_"String" name, #_"Class[]" paramTypes]
            (ß RT.vector(name, RT.seq(paramTypes)))
        )

        (§ defn #_"NewInstanceMethod" parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Symbol" thistag, #_"Map" overrideables]
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            (let [#_"NewInstanceMethod" method (ß new NewInstanceMethod(objx, (ObjMethod) METHOD.deref()))]
                (let [#_"Symbol" dotname (ß (Symbol)RT.first(form))]
                    (let [#_"Symbol" name (ß (Symbol) Symbol.intern(nil, munge(dotname.name)).withMeta(RT.meta(dotname)))]
                        (let [#_"IPersistentVector" parms (ß (IPersistentVector) RT.second(form))]
                            (when (ß parms.count() == 0)
                                (throw (IllegalArgumentException. (ß "Must supply at least one argument for 'this' in: " + dotname)))
                            )
                            (let [#_"Symbol" thisName (ß (Symbol) parms.nth(0))]
                                (§ ass parms (ß RT.subvec(parms, 1, parms.count())))
                                (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                                    (try
                                        (§ ass (ß method.line) (ß lineDeref()))
                                        (§ ass (ß method.column) (ß columnDeref()))
                                        ;; register as the current method and set up a new env frame
                                        (let [#_"PathNode" pnode (ß new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))]
                                            (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                #_map METHOD, method,
                                                #_map LOCAL_ENV, LOCAL_ENV.deref(),
                                                #_map LOOP_LOCALS, nil,
                                                #_map NEXT_LOCAL_NUM, 0,
                                                #_map CLEAR_PATH, pnode,
                                                #_map CLEAR_ROOT, pnode,
                                                #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                                                #_map METHOD_RETURN_CONTEXT, RT.T
                                            )))

                                            ;; register 'this' as local 0
                                            (if (some? thisName)
                                                (do
                                                    (ß registerLocal((thisName == nil) ? dummyThis:thisName, thistag, nil, false))
                                                )
                                                (do
                                                    (ß getAndIncLocalNum())
                                                )
                                            )

                                            (let [#_"PersistentVector" argLocals (ß PersistentVector.EMPTY)]
                                                (§ ass (ß method.retClass) (ß tagClass(tagOf(name))))
                                                (§ ass (ß method.argTypes) (ß new Type[parms.count()]))
                                                (let [#_"boolean" hinted (ß tagOf(name) != nil)]
                                                    (let [#_"Class[]" pclasses (ß new Class[parms.count()])]
                                                        (let [#_"Symbol[]" psyms (ß new Symbol[parms.count()])]
                                                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < parms.count()) [(§ ass i (ß i + 1))]
                                                                (when (ß !(parms.nth(i) instanceof Symbol))
                                                                    (throw (IllegalArgumentException. "params must be Symbols"))
                                                                )
                                                                (let [#_"Symbol" p (ß (Symbol) parms.nth(i))]
                                                                    (let [#_"Object" tag (ß tagOf(p))]
                                                                        (when (some? tag)
                                                                            (§ ass hinted true)
                                                                        )
                                                                        (when (ß p.getNamespace() != nil)
                                                                            (§ ass p (ß Symbol.intern(p.name)))
                                                                        )
                                                                        (let [#_"Class" pclass (ß tagClass(tag))]
                                                                            (§ ass (ß pclasses[i]) pclass)
                                                                            (§ ass (ß psyms[i]) p)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (let [#_"Map" matches (ß findMethodsWithNameAndArity(name.name, parms.count(), overrideables))]
                                                                (let [#_"Object" mk (ß msig(name.name, pclasses))]
                                                                    (let [(§ var #_"java.lang.reflect.Method" m nil)]
                                                                        (if (ß matches.size() > 0)
                                                                            (do
                                                                                ;; multiple methods
                                                                                (cond (ß matches.size() > 1)
                                                                                    (do
                                                                                        ;; must be hinted and match one method
                                                                                        (when (ß !hinted)
                                                                                            (throw (IllegalArgumentException. (ß "Must hint overloaded method: " + name.name)))
                                                                                        )
                                                                                        (§ ass m (ß (java.lang.reflect.Method) matches.get(mk)))
                                                                                        (when (nil? m)
                                                                                            (throw (IllegalArgumentException. (ß "Can't find matching overloaded method: " + name.name)))
                                                                                        )
                                                                                        (when (ß m.getReturnType() != method.retClass)
                                                                                            (throw (ß new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName() + ", had: " + method.retClass.getName())))
                                                                                        )
                                                                                    )
                                                                                    :else ;; one match
                                                                                    (do
                                                                                        ;; if hinted, validate match
                                                                                        (cond hinted
                                                                                            (do
                                                                                                (§ ass m (ß (java.lang.reflect.Method) matches.get(mk)))
                                                                                                (when (nil? m)
                                                                                                    (throw (ß new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match.")))
                                                                                                )
                                                                                                (when (ß m.getReturnType() != method.retClass)
                                                                                                    (throw (ß new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName() + ", had: " + method.retClass.getName())))
                                                                                                )
                                                                                            )
                                                                                            :else ;; adopt found method sig
                                                                                            (do
                                                                                                (§ ass m (ß (java.lang.reflect.Method) matches.values().iterator().next()))
                                                                                                (§ ass (ß method.retClass) (ß m.getReturnType()))
                                                                                                (§ ass pclasses (ß m.getParameterTypes()))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                            (do
                                                                                (throw (IllegalArgumentException. (ß "Can't define method not in interfaces: " + name.name)))
                                                                            )
                                                                        )

                                                                        ;; validate unque name+arity among additional methods

                                                                        (§ ass (ß method.retType) (ß Type.getType(method.retClass)))
                                                                        (§ ass (ß method.exclasses) (ß m.getExceptionTypes()))

                                                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < parms.count()) [(§ ass i (ß i + 1))]
                                                                            (let [#_"LocalBinding" lb (ß registerLocal(psyms[i], nil, new MethodParamExpr(pclasses[i]), true))]
                                                                                (§ ass argLocals (ß argLocals.assocN(i, lb)))
                                                                                (§ ass (ß method.argTypes[i]) (ß Type.getType(pclasses[i])))
                                                                            )
                                                                        )
                                                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < parms.count()) [(§ ass i (ß i + 1))]
                                                                            (when (ß pclasses[i] == long.class || pclasses[i] == double.class)
                                                                                (ß getAndIncLocalNum())
                                                                            )
                                                                        )
                                                                        (ß LOOP_LOCALS.set(argLocals))
                                                                        (§ ass (ß method.name) (ß name.name))
                                                                        (§ ass (ß method.methodMeta) (ß RT.meta(name)))
                                                                        (§ ass (ß method.parms) parms)
                                                                        (§ ass (ß method.argLocals) argLocals)
                                                                        (§ ass (ß method.body) (ß (new BodyExpr'Parser()).parse(C.RETURN, body)))
                                                                        method
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (finally
                                            (ß Var.popThreadBindings())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn- #_"Map" findMethodsWithNameAndArity [#_"String" name, #_"int" arity, #_"Map" mm]
            (let [#_"Map" ret (HashMap.)]
                (doseq [#_"Object" o (ß mm.entrySet())]
                    (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                        (let [(§ var #_"java.lang.reflect.Method" m (ß (java.lang.reflect.Method) e.getValue()))]
                            (when (ß name.equals(m.getName()) && m.getParameterTypes().length == arity)
                                (ß ret.put(e.getKey(), e.getValue()))
                            )
                        )
                    )
                )
                ret
            )
        )

        (§ defn- #_"Map" findMethodsWithName [#_"String" name, #_"Map" mm]
            (let [#_"Map" ret (HashMap.)]
                (doseq [#_"Object" o (ß mm.entrySet())]
                    (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                        (let [(§ var #_"java.lang.reflect.Method" m (ß (java.lang.reflect.Method) e.getValue()))]
                            (when (ß name.equals(m.getName()))
                                (ß ret.put(e.getKey(), e.getValue()))
                            )
                        )
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"void" emit [#_"NewInstanceMethod" this, #_"ObjExpr" obj, #_"ClassVisitor" cv]
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                (let [#_"Type[]" extypes nil]
                    (when (ß exclasses.length > 0)
                        (§ ass extypes (ß new Type[exclasses.length]))
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < exclasses.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß extypes[i]) (ß Type.getType(exclasses[i])))
                        )
                    )
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, extypes, cv))]
                        (ß addAnnotation(gen, methodMeta))
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < parms.count()) [(§ ass i (ß i + 1))]
                            (let [#_"IPersistentMap" meta (ß RT.meta(parms.nth(i)))]
                                (ß addParameterAnnotation(gen, meta, i))
                            )
                        )
                        (ß gen.visitCode())

                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                                (ß emitBody(objx, gen, retClass, body))
                                (let [#_"Label" end (ß gen.mark())]
                                    (ß gen.visitLocalVariable("this", obj.objtype.getDescriptor(), nil, loopLabel, end, 0))
                                    (loop-when-recur [(§ var #_"ISeq" lbs (ß argLocals.seq()))] (some? lbs) [(§ ass lbs (ß lbs.next()))]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())
                            nil
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" inty [#_"Class" c]
        (ß (c == int.class || c == short.class || c == byte.class || c == char.class))
    )

    (§ defn #_"Class" retType [#_"Class" tc, #_"Class" ret]
        (when (nil? tc)
            (§ return ret)
        )
        (when (nil? ret)
            (§ return tc)
        )
        (when (ß ret.isPrimitive() && tc.isPrimitive())
            (when (ß (inty(ret) && inty(tc)) || (ret == tc))
                (§ return tc)
            )
            (throw (ß new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead")))
        )
        tc
    )

    (§ defn #_"Class" primClass [#_"Symbol" sym]
        (when (nil? sym)
            (§ return nil)
        )
        (let [#_"Class" c nil]
            (cond (ß sym.name.equals("int"))
                (do
                    (§ ass c (ß int.class))
                )
                (ß sym.name.equals("long"))
                (do
                    (§ ass c (ß long.class))
                )
                (ß sym.name.equals("float"))
                (do
                    (§ ass c (ß float.class))
                )
                (ß sym.name.equals("double"))
                (do
                    (§ ass c (ß double.class))
                )
                (ß sym.name.equals("char"))
                (do
                    (§ ass c (ß char.class))
                )
                (ß sym.name.equals("short"))
                (do
                    (§ ass c (ß short.class))
                )
                (ß sym.name.equals("byte"))
                (do
                    (§ ass c (ß byte.class))
                )
                (ß sym.name.equals("boolean"))
                (do
                    (§ ass c (ß boolean.class))
                )
                (ß sym.name.equals("void"))
                (do
                    (§ ass c (ß void.class))
                )
            )
            c
        )
    )

    (§ defn #_"Class" tagClass [#_"Object" tag]
        (when (nil? tag)
            (§ return (ß Object.class))
        )
        (let [#_"Class" c nil]
            (when (ß tag instanceof Symbol)
                (§ ass c (ß primClass((Symbol) tag)))
            )
            (when (nil? c)
                (§ ass c (ß HostExpr.tagToClass(tag)))
            )
            c
        )
    )

    (§ defn #_"Class" primClass [#_"Class" c]
        (ß c.isPrimitive() ? c :or Object.class)
    )

    (§ defn #_"Class" boxClass [#_"Class" p]
        (when (ß !p.isPrimitive())
            (§ return p)
        )

        (let [#_"Class" c nil]
            (cond (ß p == Integer.TYPE)
                (do
                    (§ ass c (ß Integer.class))
                )
                (ß p == Long.TYPE)
                (do
                    (§ ass c (ß Long.class))
                )
                (ß p == Float.TYPE)
                (do
                    (§ ass c (ß Float.class))
                )
                (ß p == Double.TYPE)
                (do
                    (§ ass c (ß Double.class))
                )
                (ß p == Character.TYPE)
                (do
                    (§ ass c (ß Character.class))
                )
                (ß p == Short.TYPE)
                (do
                    (§ ass c (ß Short.class))
                )
                (ß p == Byte.TYPE)
                (do
                    (§ ass c (ß Byte.class))
                )
                (ß p == Boolean.TYPE)
                (do
                    (§ ass c (ß Boolean.class))
                )
            )

            c
        )
    )

    (class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ init
            (§ field #_"Class" c nil)
        )

        (§ constructor #_"MethodParamExpr" MethodParamExpr [#_"Class" c]
            (let [this (ß super())]
                (§ ass (ß this.c) c)
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [#_"MethodParamExpr" this]
            (throw (ß Util.runtimeException("Can't eval")))
        )

        #_method
        (§ defn #_"void" emit [#_"MethodParamExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (throw (ß Util.runtimeException("Can't emit")))
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"MethodParamExpr" this]
            (ß (c != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"MethodParamExpr" this]
            c
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"MethodParamExpr" this]
            (ß Util.isPrimitive(c))
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"MethodParamExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (throw (ß Util.runtimeException("Can't emit")))
        )
    )

    (class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ def #_"Type" NUMBER_TYPE (ß Type.getType(Number.class)))
        (§ def #_"Method" intValueMethod (ß Method.getMethod("int intValue()")))

        (§ def #_"Method" hashMethod (ß Method.getMethod("int hash(Object)")))
        (§ def #_"Method" hashCodeMethod (ß Method.getMethod("int hashCode()")))
        (§ def #_"Method" equivMethod (ß Method.getMethod("boolean equiv(Object, Object)")))
        (§ def #_"Keyword" compactKey (ß Keyword.intern(nil, "compact")))
        (§ def #_"Keyword" sparseKey (ß Keyword.intern(nil, "sparse")))
        (§ def #_"Keyword" hashIdentityKey (ß Keyword.intern(nil, "hash-identity")))
        (§ def #_"Keyword" hashEquivKey (ß Keyword.intern(nil, "hash-equiv")))
        (§ def #_"Keyword" intKey (ß Keyword.intern(nil, "int")))

        (§ init
            (§ field #_"LocalBindingExpr" expr nil)
            (§ field #_"int" shift 0)
            (§ field #_"int" mask 0)
            (§ field #_"int" low 0)
            (§ field #_"int" high 0)
            (§ field #_"Expr" defaultExpr nil)
            (§ field #_"SortedMap<Integer, Expr>" tests nil)
            (§ field #_"HashMap<Integer, Expr>" thens nil)
            (§ field #_"Keyword" switchType nil)
            (§ field #_"Keyword" testType nil)
            (§ field #_"Set<Integer>" skipCheck nil)
            (§ field #_"Class" returnType nil)
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
        )

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        (§ constructor #_"CaseExpr" CaseExpr [#_"int" line, #_"int" column, #_"LocalBindingExpr" expr, #_"int" shift, #_"int" mask, #_"int" low, #_"int" high, #_"Expr" defaultExpr, #_"SortedMap<Integer, Expr>" tests, #_"HashMap<Integer, Expr>" thens, #_"Keyword" switchType, #_"Keyword" testType, #_"Set<Integer>" skipCheck]
            (let [this (ß super())]
                (§ ass (ß this.expr) expr)
                (§ ass (ß this.shift) shift)
                (§ ass (ß this.mask) mask)
                (§ ass (ß this.low) low)
                (§ ass (ß this.high) high)
                (§ ass (ß this.defaultExpr) defaultExpr)
                (§ ass (ß this.tests) tests)
                (§ ass (ß this.thens) thens)
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                (when (ß switchType != compactKey && switchType != sparseKey)
                    (throw (IllegalArgumentException. (ß "Unexpected switch type: "+switchType)))
                )
                (§ ass (ß this.switchType) switchType)
                (when (ß testType != intKey && testType != hashEquivKey && testType != hashIdentityKey)
                    (throw (IllegalArgumentException. (ß "Unexpected test type: "+switchType)))
                )
                (§ ass (ß this.testType) testType)
                (§ ass (ß this.skipCheck) skipCheck)
                (let [#_"Collection<Expr>" returns (ß new ArrayList(thens.values()))]
                    (ß returns.add(defaultExpr))
                    (§ ass (ß this.returnType) (ß maybeJavaClass(returns)))
                    (when (ß RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), line, column))
                    )
                    this
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [#_"CaseExpr" this]
            (ß (returnType != nil))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [#_"CaseExpr" this]
            (ß Util.isPrimitive(returnType))
        )

        #_method
        (§ defn #_"Class" getJavaClass [#_"CaseExpr" this]
            returnType
        )

        #_method
        (§ defn #_"Object" eval [#_"CaseExpr" this]
            (throw (UnsupportedOperationException. "Can't eval case"))
        )

        #_method
        (§ defn #_"void" emit [#_"CaseExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, false))
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [#_"CaseExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, true))
            nil
        )

        #_method
        (§ defn #_"void" doEmit [#_"CaseExpr" this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
            (let [#_"Label" defaultLabel (ß gen.newLabel())]
                (let [#_"Label" endLabel (ß gen.newLabel())]
                    (let [#_"SortedMap<Integer, Label>" labels (TreeMap.)]
                        (doseq [#_"Integer" i (ß tests.keySet())]
                            (ß labels.put(i, gen.newLabel()))
                        )

                        (ß gen.visitLineNumber(line, gen.mark()))

                        (let [#_"Class" primExprClass (ß maybePrimitiveType(expr))]
                            (let [#_"Type" primExprType (ß (primExprClass == nil) ? nil :or Type.getType(primExprClass))]
                                (if (ß testType == intKey)
                                    (do
                                        (ß emitExprForInts(objx, gen, primExprType, defaultLabel))
                                    )
                                    (do
                                        (ß emitExprForHashes(objx, gen))
                                    )
                                )

                                (if (ß switchType == sparseKey)
                                    (do
                                        (let [#_"Label[]" la (ß new Label[labels.size()])]
                                            (§ ass la (ß labels.values().toArray(la)))
                                            (let [#_"int[]" ints (ß Numbers.int_array(tests.keySet()))]
                                                (ß gen.visitLookupSwitchInsn(defaultLabel, ints, la))
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Label[]" la (ß new Label[(high - low) + 1])]
                                            (loop-when-recur [(§ var #_"int" i low)] (ß i <= high) [(§ ass i (ß i + 1))]
                                                (§ ass (ß la[i - low]) (ß labels.containsKey(i) ? labels.get(i) :or defaultLabel))
                                            )
                                            (ß gen.visitTableSwitchInsn(low, high, defaultLabel, la))
                                        )
                                    )
                                )

                                (doseq [#_"Integer" i (ß labels.keySet())]
                                    (ß gen.mark(labels.get(i)))
                                    (cond (ß testType == intKey)
                                        (do
                                            (ß emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                                        )
                                        (ß RT.contains(skipCheck, i) == RT.T)
                                        (do
                                            (ß emitExpr(objx, gen, thens.get(i), emitUnboxed))
                                        )
                                        :else
                                        (do
                                            (ß emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                                        )
                                    )
                                    (ß gen.goTo(endLabel))
                                )

                                (ß gen.mark(defaultLabel))
                                (ß emitExpr(objx, gen, defaultExpr, emitUnboxed))
                                (ß gen.mark(endLabel))
                                (when (ß context == C.STATEMENT)
                                    (ß gen.pop())
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"boolean" isShiftMasked [#_"CaseExpr" this]
            (ß (mask != 0))
        )

        #_method
        (§ defn- #_"void" emitShiftMask [#_"CaseExpr" this, #_"GeneratorAdapter" gen]
            (when (ß isShiftMasked())
                (ß gen.push(shift))
                (ß gen.visitInsn(ISHR))
                (ß gen.push(mask))
                (ß gen.visitInsn(IAND))
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitExprForInts [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Label" defaultLabel]
            (cond (nil? exprType)
                (do
                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column))
                    )
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.instanceOf(NUMBER_TYPE))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(NUMBER_TYPE))
                    (ß gen.invokeVirtual(NUMBER_TYPE, intValueMethod))
                    (ß emitShiftMask(gen))
                )
                (ß exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (do
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.cast(exprType, Type.INT_TYPE))
                    (ß emitShiftMask(gen))
                )
                :else
                (do
                    (ß gen.goTo(defaultLabel))
                )
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitThenForInts [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
            (cond (nil? exprType)
                (do
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß test.emit(C.EXPRESSION, objx, gen))
                    (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                (ß exprType == Type.LONG_TYPE)
                (do
                    (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                (ß exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (do
                    (when (ß isShiftMasked())
                        (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.cast(exprType, Type.LONG_TYPE))
                        (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                    )
                    ;; else direct match
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                :else
                (do
                    (ß gen.goTo(defaultLabel))
                )
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitExprForHashes [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeStatic(UTIL_TYPE, hashMethod))
            (ß emitShiftMask(gen))
            nil
        )

        #_method
        (§ defn- #_"void" emitThenForHashes [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß test.emit(C.EXPRESSION, objx, gen))
            (if (ß testType == hashIdentityKey)
                (do
                    (ß gen.visitJumpInsn(IF_ACMPNE, defaultLabel))
                )
                (do
                    (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                )
            )
            (ß emitExpr(objx, gen, then, emitUnboxed))
            nil
        )

        (§ defn- #_"void" emitExpr [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" expr, #_"boolean" emitUnboxed]
            (if (ß emitUnboxed && expr instanceof MaybePrimitiveExpr)
                (do
                    (ß ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen))
                )
                (do
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                )
            )
            nil
        )

        #_stateless
        (class-ns CaseExpr'Parser (§ implements IParser)
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            #_method
            (§ defn #_"Expr" parse [#_"CaseExpr'Parser" this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß context == C.EVAL)
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )
                    (let [#_"IPersistentVector" args (ß LazilyPersistentVector.create(form.next()))]
                        (let [#_"Object" exprForm (ß args.nth(0))]
                            (let [#_"int" shift (ß ((Number)args.nth(1)).intValue())]
                                (let [#_"int" mask (ß ((Number)args.nth(2)).intValue())]
                                    (let [#_"Object" defaultForm (ß args.nth(3))]
                                        (let [#_"Map" caseMap (ß (Map)args.nth(4))]
                                            (let [#_"Keyword" switchType (ß ((Keyword)args.nth(5)))]
                                                (let [#_"Keyword" testType (ß ((Keyword)args.nth(6)))]
                                                    (let [#_"Set" skipCheck (ß (RT.count(args) < 8) ? nil :or (Set)args.nth(7))]
                                                        (let [#_"ISeq" keys (ß RT.keys(caseMap))]
                                                            (let [#_"int" low (ß ((Number)RT.first(keys)).intValue())]
                                                                (let [#_"int" high (ß ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue())]
                                                                    (let [#_"LocalBindingExpr" testexpr (ß (LocalBindingExpr) analyze(C.EXPRESSION, exprForm))]
                                                                        (§ ass (ß testexpr.shouldClear) false)

                                                                        (let [#_"SortedMap<Integer, Expr>" tests (TreeMap.)]
                                                                            (let [#_"HashMap<Integer, Expr>" thens (HashMap.)]
                                                                                (let [#_"PathNode" branch (ß new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))]
                                                                                    (doseq [#_"Object" o (ß caseMap.entrySet())]
                                                                                        (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                                                                                            (let [#_"Integer" minhash (ß ((Number)e.getKey()).intValue())]
                                                                                                (let [#_"Object" pair (ß e.getValue())] ;; [test-val then-expr]
                                                                                                    (let [#_"Expr" testExpr (ß (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair)))]
                                                                                                        (ß tests.put(minhash, testExpr))

                                                                                                        (§ let [#_"Expr" thenExpr]
                                                                                                            (try
                                                                                                                (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                                                                                                (§ ass thenExpr (ß analyze(context, RT.second(pair))))
                                                                                                                (finally
                                                                                                                    (ß Var.popThreadBindings())
                                                                                                                )
                                                                                                            )
                                                                                                            (ß thens.put(minhash, thenExpr))
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )

                                                                                    (§ let [#_"Expr" defaultExpr]
                                                                                        (try
                                                                                            (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                                                                            (§ ass defaultExpr (ß analyze(context, args.nth(3))))
                                                                                            (finally
                                                                                                (ß Var.popThreadBindings())
                                                                                            )
                                                                                        )

                                                                                        (let [#_"int" line (ß ((Number)LINE.deref()).intValue())]
                                                                                            (let [#_"int" column (ß ((Number)COLUMN.deref()).intValue())]
                                                                                                (ß new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"IPersistentCollection" emptyVarCallSites []
        (ß PersistentHashSet.EMPTY)
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (§ init
        (§ field- #_"Object" _first nil)
        (§ field- #_"ISeq" _more nil)
    )

    (§ constructor #_"Cons" Cons [#_"Object" first, #_"ISeq" _more]
        (let [this (ß super())]
            (§ ass (ß this._first) first)
            (§ ass (ß this._more) (ß _more))
            this
        )
    )

    (§ constructor #_"Cons" Cons [#_"IPersistentMap" meta, #_"Object" _first, #_"ISeq" _more]
        (let [this (ß super(meta))]
            (§ ass (ß this._first) (ß _first))
            (§ ass (ß this._more) (ß _more))
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"Cons" this]
        (ß _first)
    )

    #_method
    (§ defn #_"ISeq" next [#_"Cons" this]
        (ß more().seq())
    )

    #_method
    (§ defn #_"ISeq" more [#_"Cons" this]
        (when (nil? _more)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    #_method
    (§ defn #_"int" count [#_"Cons" this]
        (ß 1 + RT.count(_more))
    )

    #_method
    (§ defn #_"Cons" withMeta [#_"Cons" this, #_"IPersistentMap" meta]
        (ß new Cons(meta, _first, _more))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ interface Counted
    #_abstract
    (#_"int" count [#_"Counted" this])
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (§ init
        (§ field- #_"ISeq" all nil) ;; never nil
        (§ field- #_"ISeq" prev nil)
        #_volatile
        (§ field- #_"ISeq" _current nil) ;; lazily realized
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Cycle" Cycle [#_"ISeq" all, #_"ISeq" prev, #_"ISeq" current]
        (let [this (ß super())]
            (§ ass (ß this.all) all)
            (§ ass (ß this.prev) prev)
            (§ ass (ß this._current) current)
            this
        )
    )

    (§ constructor- #_"Cycle" Cycle [#_"IPersistentMap" meta, #_"ISeq" all, #_"ISeq" prev, #_"ISeq" current, #_"ISeq" next]
        (let [this (ß super(meta))]
            (§ ass (ß this.all) all)
            (§ ass (ß this.prev) prev)
            (§ ass (ß this._current) current)
            (§ ass (ß this._next) next)
            this
        )
    )

    (§ defn #_"ISeq" create [#_"ISeq" vals]
        (when (nil? vals)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Cycle(vals, nil, vals))
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" current [#_"Cycle" this]
        (when (nil? _current)
            (let [#_"ISeq" current (ß prev.next())]
                (§ ass _current (ß (current == nil) ? all :or current))
            )
        )
        (ß _current)
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Cycle" this]
        (ß (_current != nil))
    )

    #_method
    (§ defn #_"Object" first [#_"Cycle" this]
        (ß current().first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"Cycle" this]
        (when (nil? _next)
            (§ ass _next (ß new Cycle(all, current(), nil)))
        )
        (ß _next)
    )

    #_method
    (§ defn #_"Cycle" withMeta [#_"Cycle" this, #_"IPersistentMap" meta]
        (ß new Cycle(meta, all, prev, _current, _next))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Cycle" this, #_"IFn" f]
        (let [#_"ISeq" s (ß current())]
            (let [#_"Object" ret (ß s.first())]
                (while true
                    (§ ass s (ß s.next()))
                    (when (nil? s)
                        (§ ass s all)
                    )
                    (§ ass ret (ß f.invoke(ret, s.first())))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Cycle" this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret start]
            (let [#_"ISeq" s (ß current())]
                (while true
                    (§ ass ret (ß f.invoke(ret, s.first())))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass s (ß s.next()))
                    (when (nil? s)
                        (§ ass s all)
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
        #_volatile
        (§ field #_"Throwable" exception nil)
        #_volatile
        (§ field #_"IFn" fn nil)
    )

    (§ constructor #_"Delay" Delay [#_"IFn" fn]
        (let [this (ß super())]
            (§ ass (ß this.fn) fn)
            (§ ass (ß this.val) nil)
            (§ ass (ß this.exception) nil)
            this
        )
    )

    (§ defn #_"Object" force [#_"Object" x]
        (ß (x instanceof Delay) ? ((Delay) x).deref() :or x)
    )

    #_method
    (§ defn #_"Object" deref [#_"Delay" this]
        (when (some? fn)
            (§ sync this
                ;; double check
                (when (some? fn)
                    (try
                        (§ ass val (ß fn.invoke()))
                        (catch Throwable t
                            (§ ass exception t)
                        )
                    )
                    (§ ass fn nil)
                )
            )
        )
        (when (some? exception)
            (throw (ß Util.sneakyThrow(exception)))
        )
        val
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Delay" this]
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (§ def #_"ConcurrentHashMap<String, Reference<Class>>" classCache (ß new ConcurrentHashMap<String, Reference<Class>>()))

    (§ def #_"URL[]" EMPTY_URLS (ß new URL[] (§ array )))

    (§ def #_"ReferenceQueue" rq (ReferenceQueue.))

    (§ init
        (§ field #_"HashMap<Integer, Object[]>" constantVals (ß new HashMap<Integer, Object[]>()))
    )

    (§ constructor #_"DynamicClassLoader" DynamicClassLoader []
        (let [this (ß super())]
            ;; pseudo test in lieu of hasContextClassLoader()
            (§ super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == nil || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader()))
            this
        )
    )

    (§ constructor #_"DynamicClassLoader" DynamicClassLoader [#_"ClassLoader" parent]
        (let [this (ß super(EMPTY_URLS, parent))]
            this
        )
    )

    #_method
    (§ defn #_"Class" defineClass [#_"DynamicClassLoader" this, #_"String" name, #_"byte[]" bytes, #_"Object" srcForm]
        (ß Util.clearCache(rq, classCache))
        (let [#_"Class" c (ß defineClass(name, bytes, 0, bytes.length))]
            (ß classCache.put(name, new SoftReference(c, rq)))
            c
        )
    )

    (§ defn #_"Class<?>" findInMemoryClass [#_"String" name]
        (let [#_"Reference<Class>" cr (ß classCache.get(name))]
            (when (some? cr)
                (let [#_"Class" c (ß cr.get())]
                    (if (some? c)
                        (do
                            (§ return c)
                        )
                        (do
                            (ß classCache.remove(name, cr))
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" findClass [#_"DynamicClassLoader" this, #_"String" name] (§ throws ClassNotFoundException)
        (let [#_"Class" c (ß findInMemoryClass(name))]
            (if (some? c)
                (do
                    c
                )
                (do
                    (ß super.findClass(name))
                )
            )
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" loadClass [#_"DynamicClassLoader" this, #_"String" name, #_"boolean" resolve] (§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" c (ß findLoadedClass(name))]
                (when (nil? c)
                    (§ ass c (ß findInMemoryClass(name)))
                    (when (nil? c)
                        (§ ass c (ß super.loadClass(name, false)))
                    )
                )
                (when resolve
                    (ß resolveClass(c))
                )
                c
            )
        )
    )

    #_method
    (§ defn #_"void" registerConstants [#_"DynamicClassLoader" this, #_"int" id, #_"Object[]" val]
        (ß constantVals.put(id, val))
        nil
    )

    #_method
    (§ defn #_"Object[]" getConstants [#_"DynamicClassLoader" this, #_"int" id]
        (ß constantVals.get(id))
    )

    #_method
    (§ defn #_"void" addURL [#_"DynamicClassLoader" this, #_"URL" url]
        (ß super.addURL(url))
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

#_stateless
(class-ns EdnReader
    (§ def #_"IFn[]" macros (ß new IFn[256]))
    (§ def #_"IFn[]" dispatchMacros (ß new IFn[256]))
    (§ def #_"Pattern" symbolPat (ß Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")))
    (§ def #_"Pattern" intPat (ß Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")))
    (§ def #_"Pattern" ratioPat (ß Pattern.compile("([-+]?[0-9]+)/([0-9]+)")))
    (§ def #_"Pattern" floatPat (ß Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")))

    (§ def #_"IFn" taggedReader (TaggedReader.))

    (§ static
        (§ ass (ß macros[\"]) (EdnReader'StringReader.)) ;; oops! "
        (§ ass (ß macros[\;]) (EdnReader'CommentReader.))
        (§ ass (ß macros[\^]) (EdnReader'MetaReader.))
        (§ ass (ß macros[\(]) (EdnReader'ListReader.))
        (§ ass (ß macros[\)]) (EdnReader'UnmatchedDelimiterReader.))
        (§ ass (ß macros[\[]) (EdnReader'VectorReader.))
        (§ ass (ß macros[\]]) (EdnReader'UnmatchedDelimiterReader.))
        (§ ass (ß macros[\{]) (EdnReader'MapReader.))
        (§ ass (ß macros[\}]) (EdnReader'UnmatchedDelimiterReader.))
        (§ ass (ß macros[\\]) (EdnReader'CharacterReader.))
        (§ ass (ß macros[\#]) (EdnReader'DispatchReader.))

        (§ ass (ß dispatchMacros[\#]) (EdnReader'SymbolicValueReader.))
        (§ ass (ß dispatchMacros[\^]) (EdnReader'MetaReader.))
        (§ ass (ß dispatchMacros[\{]) (EdnReader'SetReader.))
        (§ ass (ß dispatchMacros[\<]) (EdnReader'UnreadableReader.))
        (§ ass (ß dispatchMacros[\_]) (EdnReader'DiscardReader.))
        (§ ass (ß dispatchMacros[\:]) (EdnReader'NamespaceMapReader.))
    )

    (§ defn #_"boolean" nonConstituent [#_"int" ch]
        (ß (ch == \@ || ch == \` || ch == \~))
    )

    (§ defn #_"Object" readString [#_"String" s, #_"IPersistentMap" opts]
        (let [#_"PushbackReader" r (ß new PushbackReader(new java.io.StringReader(s)))]
            (ß read(r, opts))
        )
    )

    (§ defn #_"boolean" isWhitespace [#_"int" ch]
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn #_"void" unread [#_"PushbackReader" r, #_"int" ch]
        (when (ß ch != -1)
            (try
                (ß r.unread(ch))
                (catch IOException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )
        nil
    )

    (class-ns EdnReader'ReaderException (§ extends RuntimeException)
        (§ init
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
        )

        (§ constructor #_"EdnReader'ReaderException" EdnReader'ReaderException [#_"int" line, #_"int" column, #_"Throwable" cause]
            (let [this (ß super(cause))]
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                this
            )
        )
    )

    (§ defn #_"int" read1 [#_"Reader" r]
        (try
            (ß r.read())
            (catch IOException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ def #_"Keyword" EOF (ß Keyword.intern(nil, "eof")))

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"IPersistentMap" opts]
        (ß read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts))
    )

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" opts]
        (try
            (while true
                (let [#_"int" ch (ß read1(r))]
                    (while (ß isWhitespace(ch))
                        (§ ass ch (ß read1(r)))
                    )

                    (when (ß ch == -1)
                        (when eofIsError
                            (throw (ß Util.runtimeException("EOF while reading")))
                        )
                        (§ return eofValue)
                    )

                    (when (ß Character.isDigit(ch))
                        (let [#_"Object" n (ß readNumber(r, (char) ch))]
                            (when (ß RT.suppressRead())
                                (§ return nil)
                            )
                            (§ return n)
                        )
                    )

                    (let [#_"IFn" macroFn (ß getMacro(ch))]
                        (when (some? macroFn)
                            (let [#_"Object" ret (ß macroFn.invoke(r, (char) ch, opts))]
                                (when (ß RT.suppressRead())
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (ß ret == r)
                                    (§ continue )
                                )
                                (§ return ret)
                            )
                        )

                        (when (ß ch == \+ || ch == \-)
                            (let [#_"int" ch2 (ß read1(r))]
                                (when (ß Character.isDigit(ch2))
                                    (ß unread(r, ch2))
                                    (let [#_"Object" n (ß readNumber(r, (char) ch))]
                                        (when (ß RT.suppressRead())
                                            (§ return nil)
                                        )
                                        (§ return n)
                                    )
                                )
                                (ß unread(r, ch2))
                            )
                        )

                        (let [#_"String" token (ß readToken(r, (char) ch, true))]
                            (when (ß RT.suppressRead())
                                (§ return nil)
                            )
                            (§ return (ß interpretToken(token)))
                        )
                    )
                )
            )
            (catch Exception e
                (when (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                    (throw (ß Util.sneakyThrow(e)))
                )
                (let [#_"LineNumberingPushbackReader" rdr (ß (LineNumberingPushbackReader) r)]
                    (throw (ß new EdnReader'ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)))
                )
            )
        )
    )

    (§ defn- #_"String" readToken [#_"PushbackReader" r, #_"char" initch, #_"boolean" leadConstituent]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (when (ß leadConstituent && nonConstituent(initch))
                (throw (ß Util.runtimeException("Invalid leading character: " + (char)initch)))
            )

            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (cond (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (do
                            (ß unread(r, ch))
                            (§ return (ß sb.toString()))
                        )
                        (ß nonConstituent(ch))
                        (do
                            (throw (ß Util.runtimeException("Invalid constituent character: " + (char)ch)))
                        )
                    )
                    (ß sb.append((char) ch))
                )
            )
        )
    )

    (§ defn- #_"Object" readNumber [#_"PushbackReader" r, #_"char" initch]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                        (ß unread(r, ch))
                        (§ break )
                    )
                    (ß sb.append((char) ch))
                )
            )

            (let [#_"String" s (ß sb.toString())]
                (let [#_"Object" n (ß matchNumber(s))]
                    (when (nil? n)
                        (throw (NumberFormatException. (ß "Invalid number: " + s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"String" token, #_"int" offset, #_"int" length, #_"int" base]
        (when (ß token.length() != offset + length)
            (throw (IllegalArgumentException. (ß "Invalid unicode character: \\" + token)))
        )
        (let [#_"int" uc 0]
            (loop-when-recur [(§ var #_"int" i offset)] (ß i < offset + length) [(§ ass i (ß i + 1))]
                (let [#_"int" d (ß Character.digit(token.charAt(i), base))]
                    (when (ß d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + token.charAt(i))))
                    )
                    (§ ass uc (ß uc * base + d))
                )
            )
            (ß (char) uc)
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"PushbackReader" r, #_"int" initch, #_"int" base, #_"int" length, #_"boolean" exact]
        (let [#_"int" uc (ß Character.digit(initch, base))]
            (when (ß uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) initch)))
            )
            (let [#_"int" i 1]
                (loop-when-recur [(ß )] (ß i < length) [(§ ass i (ß i + 1))]
                    (let [#_"int" ch (ß read1(r))]
                        (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                            (ß unread(r, ch))
                            (§ break )
                        )
                        (let [#_"int" d (ß Character.digit(ch, base))]
                            (when (ß d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ch)))
                            )
                            (§ ass uc (ß uc * base + d))
                        )
                    )
                )
                (when (ß i != length && exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)))
                )
                uc
            )
        )
    )

    (§ defn- #_"Object" interpretToken [#_"String" s]
        (cond (ß s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß s.equals("true"))
            (do
                (§ return (ß RT.T))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß RT.F))
            )
        )

        (let [#_"Object" ret nil]
            (§ ass ret (ß matchSymbol(s)))
            (when (some? ret)
                (§ return ret)
            )

            (throw (ß Util.runtimeException("Invalid token: " + s)))
        )
    )

    (§ defn- #_"Object" matchSymbol [#_"String" s]
        (let [#_"Matcher" m (ß symbolPat.matcher(s))]
            (when (ß m.matches())
                (let [#_"int" gc (ß m.groupCount())]
                    (let [#_"String" ns (ß m.group(1))]
                        (let [#_"String" name (ß m.group(2))]
                            (when (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß s.startsWith("::"))
                                (§ return nil)
                            )
                            (let [#_"boolean" isKeyword (ß s.charAt(0) == \:)]
                                (let [#_"Symbol" sym (ß Symbol.intern(s.substring(isKeyword ? 1 :or 0)))]
                                    (when isKeyword
                                        (§ return (ß Keyword.intern(sym)))
                                    )
                                    (§ return sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- #_"Object" matchNumber [#_"String" s]
        (let [#_"Matcher" m (ß intPat.matcher(s))]
            (when (ß m.matches())
                (when (ß m.group(2) != nil)
                    (when (ß m.group(8) != nil)
                        (§ return (ß BigInt.ZERO))
                    )
                    (§ return (ß Numbers.num(0)))
                )
                (let [#_"boolean" negate (ß m.group(1).equals("-"))]
                    (§ let [#_"String" n]
                        (let [#_"int" radix 10]
                            (cond (some? (§ ass n (ß m.group(3))))
                                (do
                                    (§ ass radix 10)
                                )
                                (some? (§ ass n (ß m.group(4))))
                                (do
                                    (§ ass radix 16)
                                )
                                (some? (§ ass n (ß m.group(5))))
                                (do
                                    (§ ass radix 8)
                                )
                                (some? (§ ass n (ß m.group(7))))
                                (do
                                    (§ ass radix (ß Integer.parseInt(m.group(6))))
                                )
                            )
                            (when (nil? n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" bn (ß new BigInteger(n, radix))]
                                (when negate
                                    (§ ass bn (ß bn.negate()))
                                )
                                (when (ß m.group(8) != nil)
                                    (§ return (ß BigInt.fromBigInteger(bn)))
                                )
                                (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
                            )
                        )
                    )
                )
            )
            (§ ass m (ß floatPat.matcher(s)))
            (when (ß m.matches())
                (when (ß m.group(4) != nil)
                    (§ return (ß new BigDecimal(m.group(1))))
                )
                (§ return (ß Double.parseDouble(s)))
            )
            (§ ass m (ß ratioPat.matcher(s)))
            (when (ß m.matches())
                (let [#_"String" numerator (ß m.group(1))]
                    (when (ß numerator.startsWith("+"))
                        (§ ass numerator (ß numerator.substring(1)))
                    )

                    (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- #_"IFn" getMacro [#_"int" ch]
        (when (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- #_"boolean" isMacro [#_"int" ch]
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- #_"boolean" isTerminatingMacro [#_"int" ch]
        (ß (ch != \# && ch != \' && isMacro(ch)))
    )

    #_stateless
    (class-ns EdnReader'StringReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'StringReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" opts]
            (let [#_"StringBuilder" sb (StringBuilder.)]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(§ var #_"int" ch (ß read1(r)))] (ß ch != \") [(§ ass ch (ß read1(r)))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading string")))
                        )
                        (when (ß ch == \\) ;; escape
                            (§ ass ch (ß read1(r)))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading string")))
                            )
                            (§ switch ch
                                (§ case \t)
                                (do
                                    (§ ass ch (ß \tab))
                                    (§ break )
                                )
                                (§ case \r)
                                (do
                                    (§ ass ch (ß \return))
                                    (§ break )
                                )
                                (§ case \n)
                                (do
                                    (§ ass ch (ß \newline))
                                    (§ break )
                                )
                                (§ case \\)
                                (do
                                    (§ break )
                                )
                                (§ case \") ;; oops! "
                                (do
                                    (§ break )
                                )
                                (§ case \b)
                                (do
                                    (§ ass ch (ß \backspace))
                                    (§ break )
                                )
                                (§ case \f)
                                (do
                                    (§ ass ch (ß \formfeed))
                                    (§ break )
                                )
                                (§ case \u)
                                (do
                                    (§ ass ch (ß read1(r)))
                                    (when (ß Character.digit(ch, 16) == -1)
                                        (throw (ß Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)))
                                    )
                                    (§ ass ch (ß readUnicodeChar((PushbackReader) r, ch, 16, 4, true)))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (if (ß Character.isDigit(ch))
                                        (do
                                            (§ ass ch (ß readUnicodeChar((PushbackReader) r, ch, 8, 3, false)))
                                            (when (ß ch > 0377)
                                                (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                            )
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Unsupported escape character: \\" + (char) ch)))
                                        )
                                    )
                                    (§ break )
                                )
                            )
                        )
                        (ß sb.append((char) ch))
                    )
                    (ß sb.toString())
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'CommentReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'CommentReader" this, #_"Object" reader, #_"Object" semicolon, #_"Object" opts]
            (let [#_"Reader" r (ß (Reader) reader)]
                (§ let [#_"int" ch]
                    (§ loop
                        (§ ass ch (ß read1(r)))
                        (§ recur-if (ch != -1 && ch != \newline && ch != \return))
                    )
                    r
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'DiscardReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'DiscardReader" this, #_"Object" reader, #_"Object" underscore, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß read(r, true, nil, true, opts))
                r
            )
        )
    )

    #_stateless
    (class-ns EdnReader'NamespaceMapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'NamespaceMapReader" this, #_"Object" reader, #_"Object" colon, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                ;; Read ns symbol
                (let [#_"Object" sym (ß read(r, true, nil, false, opts))]
                    (when (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                        (throw (RuntimeException. (ß "Namespaced map must specify a valid namespace: " + sym)))
                    )
                    (let [#_"String" ns (ß ((Symbol)sym).getName())]
                        ;; Read map
                        (let [#_"int" nextChar (ß read1(r))]
                            (while (ß isWhitespace(nextChar))
                                (§ ass nextChar (ß read1(r)))
                            )
                            (when (ß \{ != nextChar)
                                (throw (RuntimeException. "Namespaced map must specify a map"))
                            )
                            (let [#_"List" kvs (ß readDelimitedList(\}, r, true, opts))]
                                (when (ß (kvs.size() & 1) == 1)
                                    (throw (ß Util.runtimeException("Namespaced map literal must contain an even number of forms")))
                                )

                                ;; Construct output map
                                (let [#_"Object[]" a (ß new Object[kvs.size()])]
                                    (let [#_"Iterator" iter (ß kvs.iterator())]
                                        (loop-when-recur [(§ var #_"int" i 0)] (ß iter.hasNext()) [(§ ass i (ß i + 2))]
                                            (let [#_"Object" key (ß iter.next())]
                                                (let [#_"Object" val (ß iter.next())]
                                                    (cond (ß key instanceof Keyword)
                                                        (do
                                                            (let [#_"Keyword" kw (ß (Keyword) key)]
                                                                (cond (ß kw.getNamespace() == nil)
                                                                    (do
                                                                        (§ ass key (ß Keyword.intern(ns, kw.getName())))
                                                                    )
                                                                    (ß kw.getNamespace().equals("_"))
                                                                    (do
                                                                        (§ ass key (ß Keyword.intern(nil, kw.getName())))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (ß key instanceof Symbol)
                                                        (do
                                                            (let [#_"Symbol" s (ß (Symbol) key)]
                                                                (cond (ß s.getNamespace() == nil)
                                                                    (do
                                                                        (§ ass key (ß Symbol.intern(ns, s.getName())))
                                                                    )
                                                                    (ß s.getNamespace().equals("_"))
                                                                    (do
                                                                        (§ ass key (ß Symbol.intern(nil, s.getName())))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (§ ass (ß a[i]) key)
                                                    (§ ass (ß a[i + 1]) val)
                                                )
                                            )
                                        )
                                        (ß RT.map(a))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'DispatchReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'DispatchReader" this, #_"Object" reader, #_"Object" hash, #_"Object" opts]
            (let [#_"int" ch (ß read1((Reader) reader))]
                (when (ß ch == -1)
                    (throw (ß Util.runtimeException("EOF while reading character")))
                )
                (let [#_"IFn" fn (ß dispatchMacros[ch])]
                    (when (nil? fn)
                        ;; try tagged reader
                        (when (ß Character.isLetter(ch))
                            (ß unread((PushbackReader) reader, ch))
                            (§ return (ß taggedReader.invoke(reader, ch, opts)))
                        )

                        (throw (ß Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))))
                    )
                    (ß fn.invoke(reader, ch, opts))
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'MetaReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'MetaReader" this, #_"Object" reader, #_"Object" caret, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (§ ass line (ß ((LineNumberingPushbackReader) r).getLineNumber()))
                            (§ ass column (ß ((LineNumberingPushbackReader) r).getColumnNumber()-1))
                        )
                        (let [#_"Object" meta (ß read(r, true, nil, true, opts))]
                            (cond (ß meta instanceof Symbol || meta instanceof String)
                                (do
                                    (§ ass meta (ß RT.map(RT.TAG_KEY, meta)))
                                )
                                (ß meta instanceof Keyword)
                                (do
                                    (§ ass meta (ß RT.map(meta, RT.T)))
                                )
                                (ß !(meta instanceof IPersistentMap))
                                (do
                                    (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                                )
                            )

                            (let [#_"Object" o (ß read(r, true, nil, true, opts))]
                                (if (ß o instanceof IMeta)
                                    (do
                                        (when (ß line != -1 && o instanceof ISeq)
                                            (§ ass meta (ß ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column)))
                                        )
                                        (when (ß o instanceof IReference)
                                            (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                                            (§ return o)
                                        )
                                        (let [#_"Object" ometa (ß RT.meta(o))]
                                            (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(meta)))] (some? s) [(§ ass s (ß s.next()))]
                                                (let [#_"IMapEntry" kv (ß (IMapEntry) s.first())]
                                                    (§ ass ometa (ß RT.assoc(ometa, kv.getKey(), kv.getValue())))
                                                )
                                            )
                                            (ß ((IObj) o).withMeta((IPersistentMap) ometa))
                                        )
                                    )
                                    (do
                                        (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'CharacterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'CharacterReader" this, #_"Object" reader, #_"Object" backslash, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (let [#_"String" token (ß readToken(r, (char) ch, false))]
                        (cond (ß token.length() == 1)
                            (do
                                (§ return (ß Character.valueOf(token.charAt(0))))
                            )
                            (ß token.equals("newline"))
                            (do
                                (§ return (ß \newline))
                            )
                            (ß token.equals("space"))
                            (do
                                (§ return (ß \space))
                            )
                            (ß token.equals("tab"))
                            (do
                                (§ return (ß \tab))
                            )
                            (ß token.equals("backspace"))
                            (do
                                (§ return (ß \backspace))
                            )
                            (ß token.equals("formfeed"))
                            (do
                                (§ return (ß \formfeed))
                            )
                            (ß token.equals("return"))
                            (do
                                (§ return (ß \return))
                            )
                            (ß token.startsWith("u"))
                            (do
                                (let [#_"char" c (ß (char) readUnicodeChar(token, 1, 4, 16))]
                                    (when (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                                        (throw (ß Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))))
                                    )
                                    (§ return c)
                                )
                            )
                            (ß token.startsWith("o"))
                            (do
                                (let [#_"int" len (ß token.length() - 1)]
                                    (when (ß len > 3)
                                        (throw (ß Util.runtimeException("Invalid octal escape sequence length: " + len)))
                                    )
                                    (let [#_"int" uc (ß readUnicodeChar(token, 1, len, 8))]
                                        (when (ß uc > 0377)
                                            (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                        (§ return (ß (char) uc))
                                    )
                                )
                            )
                        )
                        (throw (ß Util.runtimeException("Unsupported character: \\" + token)))
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'ListReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'ListReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (§ ass line (ß ((LineNumberingPushbackReader) r).getLineNumber()))
                            (§ ass column (ß ((LineNumberingPushbackReader) r).getColumnNumber()-1))
                        )
                        (let [#_"List" list (ß readDelimitedList(\), r, true, opts))]
                            (when (ß list.isEmpty())
                                (§ return (ß PersistentList.EMPTY))
                            )
                            (let [#_"IObj" s (ß (IObj) PersistentList.create(list))]
                                s
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'VectorReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'VectorReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts)))
            )
        )
    )

    #_stateless
    (class-ns EdnReader'MapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'MapReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object[]" a (ß readDelimitedList(\}, r, true, opts).toArray())]
                    (when (ß (a.length & 1) == 1)
                        (throw (ß Util.runtimeException("Map literal must contain an even number of forms")))
                    )
                    (ß RT.map(a))
                )
            )
        )
    )

    #_stateless
    (class-ns EdnReader'SetReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'SetReader" this, #_"Object" reader, #_"Object" leftbracket, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts)))
            )
        )
    )

    #_stateless
    (class-ns EdnReader'UnmatchedDelimiterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'UnmatchedDelimiterReader" this, #_"Object" reader, #_"Object" rightdelim, #_"Object" opts]
            (throw (ß Util.runtimeException("Unmatched delimiter: " + rightdelim)))
        )
    )

    #_stateless
    (class-ns EdnReader'UnreadableReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'UnreadableReader" this, #_"Object" reader, #_"Object" leftangle, #_"Object" opts]
            (throw (ß Util.runtimeException("Unreadable form")))
        )
    )

    #_stateless
    (class-ns EdnReader'SymbolicValueReader (§ extends AFn)
        (§ def #_"IPersistentMap" specials (ß PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        )))

        #_method
        (§ defn #_"Object" invoke [#_"EdnReader'SymbolicValueReader" this, #_"Object" reader, #_"Object" quote, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts))]
                    (when (ß !(o instanceof Symbol))
                        (throw (ß Util.runtimeException("Invalid token: ##" + o)))
                    )
                    (when (ß !(specials.containsKey(o)))
                        (throw (ß Util.runtimeException("Unknown symbolic value: ##" + o)))
                    )

                    (ß specials.valAt(o))
                )
            )
        )
    )

    (§ defn #_"List" readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" opts]
        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
            (let [#_"ArrayList" a (ArrayList.)]
                (while true
                    (let [#_"int" ch (ß read1(r))]
                        (while (ß isWhitespace(ch))
                            (§ ass ch (ß read1(r)))
                        )

                        (when (ß ch == -1)
                            (if (ß firstline < 0)
                                (do
                                    (throw (ß Util.runtimeException("EOF while reading")))
                                )
                                (do
                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                )
                            )
                        )

                        (when (ß ch == delim)
                            (§ break )
                        )

                        (let [#_"IFn" macroFn (ß getMacro(ch))]
                            (if (some? macroFn)
                                (do
                                    (let [#_"Object" mret (ß macroFn.invoke(r, (char) ch, opts))]
                                        ;; no op macros return the reader
                                        (when (ß mret != r)
                                            (ß a.add(mret))
                                        )
                                    )
                                )
                                (do
                                    (ß unread(r, ch))

                                    (let [#_"Object" o (ß read(r, true, nil, isRecursive, opts))]
                                        (when (ß o != r)
                                            (ß a.add(o))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                a
            )
        )
    )

    #_stateless
    (class-ns TaggedReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"TaggedReader" this, #_"Object" reader, #_"Object" firstChar, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" name (ß read(r, true, nil, false, opts))]
                    (when (ß !(name instanceof Symbol))
                        (throw (RuntimeException. "Reader tag must be a symbol"))
                    )
                    (let [#_"Symbol" sym (ß (Symbol)name)]
                        (ß readTagged(r, sym, (IPersistentMap) opts))
                    )
                )
            )
        )

        (§ def #_"Keyword" READERS (ß Keyword.intern(nil, "readers")))
        (§ def #_"Keyword" DEFAULT (ß Keyword.intern(nil, "default")))

        #_method
        (§ defn- #_"Object" readTagged [#_"TaggedReader" this, #_"PushbackReader" reader, #_"Symbol" tag, #_"IPersistentMap" opts]
            (let [#_"Object" o (ß read(reader, true, nil, true, opts))]
                (let [#_"ILookup" readers (ß (ILookup)RT.get(opts, READERS))]
                    (let [#_"IFn" dataReader (ß (IFn)RT.get(readers, tag))]
                        (when (nil? dataReader)
                            (§ ass dataReader (ß (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag)))
                        )
                        (if (nil? dataReader)
                            (do
                                (let [#_"IFn" defaultReader (ß (IFn)RT.get(opts, DEFAULT))]
                                    (if (some? defaultReader)
                                        (do
                                            (ß defaultReader.invoke(tag, o))
                                        )
                                        (do
                                            (throw (ß new RuntimeException("No reader function for tag " + tag.toString())))
                                        )
                                    )
                                )
                            )
                            (do
                                (ß dataReader.invoke(o))
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeq (§ extends ASeq)
    (class-ns EnumerationSeq'State
        (§ init
            #_volatile
            (§ field #_"Object" val nil)
            #_volatile
            (§ field #_"Object" _rest nil)
        )
    )

    (§ defn #_"EnumerationSeq" create [#_"Enumeration" iter]
        (when (ß iter.hasMoreElements())
            (§ return (EnumerationSeq. iter))
        )
        nil
    )

    (§ init
        (§ field #_"Enumeration" iter nil)
        (§ field #_"EnumerationSeq'State" state nil)
    )

    (§ constructor #_"EnumerationSeq" EnumerationSeq [#_"Enumeration" iter]
        (let [this (ß super())]
            (§ ass (ß this.iter) iter)
            (§ ass state (EnumerationSeq'State.))
            (§ ass (ß this.state.val) state)
            (§ ass (ß this.state._rest) state)
            this
        )
    )

    (§ constructor #_"EnumerationSeq" EnumerationSeq [#_"IPersistentMap" meta, #_"Enumeration" iter, #_"EnumerationSeq'State" state]
        (let [this (ß super(meta))]
            (§ ass (ß this.iter) iter)
            (§ ass (ß this.state) state)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"EnumerationSeq" this]
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (§ ass (ß state.val) (ß iter.nextElement()))
                )
            )
        )
        (ß state.val)
    )

    #_method
    (§ defn #_"ISeq" next [#_"EnumerationSeq" this]
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (§ ass (ß state._rest) (ß create(iter)))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    #_method
    (§ defn #_"EnumerationSeq" withMeta [#_"EnumerationSeq" this, #_"IPersistentMap" meta]
        (ß new EnumerationSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (§ init
        (§ field #_"IPersistentMap" data nil)
    )

    (§ constructor #_"ExceptionInfo" ExceptionInfo [#_"String" s, #_"IPersistentMap" data]
        (let [this (ß this(s, data, nil))]
            this
        )
    )

    (§ constructor #_"ExceptionInfo" ExceptionInfo [#_"String" s, #_"IPersistentMap" data, #_"Throwable" throwable]
        (let [this (ß super())]
            ;; nil cause is equivalent to not passing a cause
            (§ super(s, throwable))
            (if (some? data)
                (do
                    (§ ass (ß this.data) data)
                )
                (do
                    (throw (IllegalArgumentException. "Additional data must be non-nil."))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getData [#_"ExceptionInfo" this]
        data
    )

    #_method
    (§ defn #_"String" toString [#_"ExceptionInfo" this]
        (ß "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString())
    )
)
)

(java-ns cloiure.lang.Fn

(§ interface Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (§ init
        (§ field #_"Var" v nil)
        (§ field #_"ClassLoader" loader nil)
        (§ field #_"String" fnClassName nil)
        (§ field #_"IFn" fn nil)
    )

    (§ constructor #_"FnLoaderThunk" FnLoaderThunk [#_"Var" v, #_"String" fnClassName]
        (let [this (ß super())]
            (§ ass (ß this.v) v)
            (§ ass (ß this.loader) (ß (ClassLoader) RT.FN_LOADER_VAR.get()))
            (§ ass (ß this.fnClassName) fnClassName)
            (§ ass fn nil)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" arg1]
        (ß load())
        (ß fn.invoke(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" arg1, #_"Object" arg2]
        (ß load())
        (ß fn.invoke(arg1, arg2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß load())
        (ß fn.invoke(arg1, arg2, arg3))
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"FnLoaderThunk" this, #_"Object" args]
        (ß load())
        (ß fn.applyTo((ISeq) args))
    )

    #_method
    (§ defn- #_"void" load [#_"FnLoaderThunk" this]
        (when (nil? fn)
            (try
                (§ ass fn (ß (IFn) Class.forName(fnClassName, true, loader).newInstance()))
                (catch Exception e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
            (§ ass (ß v.root) fn)
        )
        nil
    )

    #_method
    (§ defn #_"int" getRequiredArity [#_"FnLoaderThunk" this]
        0
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"FnLoaderThunk" this, #_"IPersistentMap" meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ interface IAtom
    #_abstract
    (#_"Object" swap [#_"IAtom" this, #_"IFn" f])
    #_abstract
    (#_"Object" swap [#_"IAtom" this, #_"IFn" f, #_"Object" arg])
    #_abstract
    (#_"Object" swap [#_"IAtom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"Object" swap [#_"IAtom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
    #_abstract
    (#_"boolean" compareAndSet [#_"IAtom" this, #_"Object" oldv, #_"Object" newv])
    #_abstract
    (#_"Object" reset [#_"IAtom" this, #_"Object" newval])
)
)

(java-ns cloiure.lang.IAtom2

(§ interface IAtom2 (§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f])
    #_abstract
    (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f, #_"Object" arg])
    #_abstract
    (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"IPersistentVector" swapVals [#_"IAtom2" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
    #_abstract
    (#_"IPersistentVector" resetVals [#_"IAtom2" this, #_"Object" newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ interface IBlockingDeref
    #_abstract
    (#_"Object" deref [#_"IBlockingDeref" this, #_"long" ms, #_"Object" timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(§ interface IChunk (§ extends Indexed)
    #_abstract
    (#_"IChunk" dropFirst [#_"IChunk" this])
    #_abstract
    (#_"Object" reduce [#_"IChunk" this, #_"IFn" f, #_"Object" start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ interface IChunkedSeq (§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" chunkedFirst [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" chunkedNext [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" chunkedMore [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(§ interface IDeref
    #_abstract
    (#_"Object" deref [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(§ interface IEditableCollection
    #_abstract
    (#_"ITransientCollection" asTransient [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ interface IExceptionInfo
    #_abstract
    (#_"IPersistentMap" getData [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ interface IFn (§ extends Callable, Runnable)
    #_abstract
    (#_"Object" invoke [#_"IFn" this])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7])
    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
    (#_"Object" invoke [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args])

    #_abstract
    (#_"Object" applyTo [#_"IFn" this, #_"ISeq" arglist])

    (§ interface L
        #_abstract
        (#_"long" invokePrim [#_"L" this])
    )

    (§ interface D
        #_abstract
        (#_"double" invokePrim [#_"D" this])
    )

    (§ interface OL
        #_abstract
        (#_"long" invokePrim [#_"OL" this, #_"Object" arg0])
    )

    (§ interface OD
        #_abstract
        (#_"double" invokePrim [#_"OD" this, #_"Object" arg0])
    )

    (§ interface LO
        #_abstract
        (#_"Object" invokePrim [#_"LO" this, #_"long" arg0])
    )

    (§ interface LL
        #_abstract
        (#_"long" invokePrim [#_"LL" this, #_"long" arg0])
    )

    (§ interface LD
        #_abstract
        (#_"double" invokePrim [#_"LD" this, #_"long" arg0])
    )

    (§ interface DO
        #_abstract
        (#_"Object" invokePrim [#_"DO" this, #_"double" arg0])
    )

    (§ interface DL
        #_abstract
        (#_"long" invokePrim [#_"DL" this, #_"double" arg0])
    )

    (§ interface DD
        #_abstract
        (#_"double" invokePrim [#_"DD" this, #_"double" arg0])
    )

    (§ interface OOL
        #_abstract
        (#_"long" invokePrim [#_"OOL" this, #_"Object" arg0, #_"Object" arg1])
    )

    (§ interface OOD
        #_abstract
        (#_"double" invokePrim [#_"OOD" this, #_"Object" arg0, #_"Object" arg1])
    )

    (§ interface OLO
        #_abstract
        (#_"Object" invokePrim [#_"OLO" this, #_"Object" arg0, #_"long" arg1])
    )

    (§ interface OLL
        #_abstract
        (#_"long" invokePrim [#_"OLL" this, #_"Object" arg0, #_"long" arg1])
    )

    (§ interface OLD
        #_abstract
        (#_"double" invokePrim [#_"OLD" this, #_"Object" arg0, #_"long" arg1])
    )

    (§ interface ODO
        #_abstract
        (#_"Object" invokePrim [#_"ODO" this, #_"Object" arg0, #_"double" arg1])
    )

    (§ interface ODL
        #_abstract
        (#_"long" invokePrim [#_"ODL" this, #_"Object" arg0, #_"double" arg1])
    )

    (§ interface ODD
        #_abstract
        (#_"double" invokePrim [#_"ODD" this, #_"Object" arg0, #_"double" arg1])
    )

    (§ interface LOO
        #_abstract
        (#_"Object" invokePrim [#_"LOO" this, #_"long" arg0, #_"Object" arg1])
    )

    (§ interface LOL
        #_abstract
        (#_"long" invokePrim [#_"LOL" this, #_"long" arg0, #_"Object" arg1])
    )

    (§ interface LOD
        #_abstract
        (#_"double" invokePrim [#_"LOD" this, #_"long" arg0, #_"Object" arg1])
    )

    (§ interface LLO
        #_abstract
        (#_"Object" invokePrim [#_"LLO" this, #_"long" arg0, #_"long" arg1])
    )

    (§ interface LLL
        #_abstract
        (#_"long" invokePrim [#_"LLL" this, #_"long" arg0, #_"long" arg1])
    )

    (§ interface LLD
        #_abstract
        (#_"double" invokePrim [#_"LLD" this, #_"long" arg0, #_"long" arg1])
    )

    (§ interface LDO
        #_abstract
        (#_"Object" invokePrim [#_"LDO" this, #_"long" arg0, #_"double" arg1])
    )

    (§ interface LDL
        #_abstract
        (#_"long" invokePrim [#_"LDL" this, #_"long" arg0, #_"double" arg1])
    )

    (§ interface LDD
        #_abstract
        (#_"double" invokePrim [#_"LDD" this, #_"long" arg0, #_"double" arg1])
    )

    (§ interface DOO
        #_abstract
        (#_"Object" invokePrim [#_"DOO" this, #_"double" arg0, #_"Object" arg1])
    )

    (§ interface DOL
        #_abstract
        (#_"long" invokePrim [#_"DOL" this, #_"double" arg0, #_"Object" arg1])
    )

    (§ interface DOD
        #_abstract
        (#_"double" invokePrim [#_"DOD" this, #_"double" arg0, #_"Object" arg1])
    )

    (§ interface DLO
        #_abstract
        (#_"Object" invokePrim [#_"DLO" this, #_"double" arg0, #_"long" arg1])
    )

    (§ interface DLL
        #_abstract
        (#_"long" invokePrim [#_"DLL" this, #_"double" arg0, #_"long" arg1])
    )

    (§ interface DLD
        #_abstract
        (#_"double" invokePrim [#_"DLD" this, #_"double" arg0, #_"long" arg1])
    )

    (§ interface DDO
        #_abstract
        (#_"Object" invokePrim [#_"DDO" this, #_"double" arg0, #_"double" arg1])
    )

    (§ interface DDL
        #_abstract
        (#_"long" invokePrim [#_"DDL" this, #_"double" arg0, #_"double" arg1])
    )

    (§ interface DDD
        #_abstract
        (#_"double" invokePrim [#_"DDD" this, #_"double" arg0, #_"double" arg1])
    )

    (§ interface OOOL
        #_abstract
        (#_"long" invokePrim [#_"OOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface OOOD
        #_abstract
        (#_"double" invokePrim [#_"OOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface OOLO
        #_abstract
        (#_"Object" invokePrim [#_"OOLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface OOLL
        #_abstract
        (#_"long" invokePrim [#_"OOLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface OOLD
        #_abstract
        (#_"double" invokePrim [#_"OOLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface OODO
        #_abstract
        (#_"Object" invokePrim [#_"OODO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface OODL
        #_abstract
        (#_"long" invokePrim [#_"OODL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface OODD
        #_abstract
        (#_"double" invokePrim [#_"OODD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface OLOO
        #_abstract
        (#_"Object" invokePrim [#_"OLOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface OLOL
        #_abstract
        (#_"long" invokePrim [#_"OLOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface OLOD
        #_abstract
        (#_"double" invokePrim [#_"OLOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface OLLO
        #_abstract
        (#_"Object" invokePrim [#_"OLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface OLLL
        #_abstract
        (#_"long" invokePrim [#_"OLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface OLLD
        #_abstract
        (#_"double" invokePrim [#_"OLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface OLDO
        #_abstract
        (#_"Object" invokePrim [#_"OLDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface OLDL
        #_abstract
        (#_"long" invokePrim [#_"OLDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface OLDD
        #_abstract
        (#_"double" invokePrim [#_"OLDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface ODOO
        #_abstract
        (#_"Object" invokePrim [#_"ODOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface ODOL
        #_abstract
        (#_"long" invokePrim [#_"ODOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface ODOD
        #_abstract
        (#_"double" invokePrim [#_"ODOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface ODLO
        #_abstract
        (#_"Object" invokePrim [#_"ODLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface ODLL
        #_abstract
        (#_"long" invokePrim [#_"ODLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface ODLD
        #_abstract
        (#_"double" invokePrim [#_"ODLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface ODDO
        #_abstract
        (#_"Object" invokePrim [#_"ODDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface ODDL
        #_abstract
        (#_"long" invokePrim [#_"ODDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface ODDD
        #_abstract
        (#_"double" invokePrim [#_"ODDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface LOOO
        #_abstract
        (#_"Object" invokePrim [#_"LOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface LOOL
        #_abstract
        (#_"long" invokePrim [#_"LOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface LOOD
        #_abstract
        (#_"double" invokePrim [#_"LOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface LOLO
        #_abstract
        (#_"Object" invokePrim [#_"LOLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface LOLL
        #_abstract
        (#_"long" invokePrim [#_"LOLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface LOLD
        #_abstract
        (#_"double" invokePrim [#_"LOLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface LODO
        #_abstract
        (#_"Object" invokePrim [#_"LODO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface LODL
        #_abstract
        (#_"long" invokePrim [#_"LODL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface LODD
        #_abstract
        (#_"double" invokePrim [#_"LODD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface LLOO
        #_abstract
        (#_"Object" invokePrim [#_"LLOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface LLOL
        #_abstract
        (#_"long" invokePrim [#_"LLOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface LLOD
        #_abstract
        (#_"double" invokePrim [#_"LLOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface LLLO
        #_abstract
        (#_"Object" invokePrim [#_"LLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface LLLL
        #_abstract
        (#_"long" invokePrim [#_"LLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface LLLD
        #_abstract
        (#_"double" invokePrim [#_"LLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface LLDO
        #_abstract
        (#_"Object" invokePrim [#_"LLDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface LLDL
        #_abstract
        (#_"long" invokePrim [#_"LLDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface LLDD
        #_abstract
        (#_"double" invokePrim [#_"LLDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface LDOO
        #_abstract
        (#_"Object" invokePrim [#_"LDOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface LDOL
        #_abstract
        (#_"long" invokePrim [#_"LDOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface LDOD
        #_abstract
        (#_"double" invokePrim [#_"LDOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface LDLO
        #_abstract
        (#_"Object" invokePrim [#_"LDLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface LDLL
        #_abstract
        (#_"long" invokePrim [#_"LDLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface LDLD
        #_abstract
        (#_"double" invokePrim [#_"LDLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface LDDO
        #_abstract
        (#_"Object" invokePrim [#_"LDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface LDDL
        #_abstract
        (#_"long" invokePrim [#_"LDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface LDDD
        #_abstract
        (#_"double" invokePrim [#_"LDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface DOOO
        #_abstract
        (#_"Object" invokePrim [#_"DOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface DOOL
        #_abstract
        (#_"long" invokePrim [#_"DOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface DOOD
        #_abstract
        (#_"double" invokePrim [#_"DOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
    )

    (§ interface DOLO
        #_abstract
        (#_"Object" invokePrim [#_"DOLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface DOLL
        #_abstract
        (#_"long" invokePrim [#_"DOLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface DOLD
        #_abstract
        (#_"double" invokePrim [#_"DOLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
    )

    (§ interface DODO
        #_abstract
        (#_"Object" invokePrim [#_"DODO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface DODL
        #_abstract
        (#_"long" invokePrim [#_"DODL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface DODD
        #_abstract
        (#_"double" invokePrim [#_"DODD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
    )

    (§ interface DLOO
        #_abstract
        (#_"Object" invokePrim [#_"DLOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface DLOL
        #_abstract
        (#_"long" invokePrim [#_"DLOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface DLOD
        #_abstract
        (#_"double" invokePrim [#_"DLOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
    )

    (§ interface DLLO
        #_abstract
        (#_"Object" invokePrim [#_"DLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface DLLL
        #_abstract
        (#_"long" invokePrim [#_"DLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface DLLD
        #_abstract
        (#_"double" invokePrim [#_"DLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
    )

    (§ interface DLDO
        #_abstract
        (#_"Object" invokePrim [#_"DLDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface DLDL
        #_abstract
        (#_"long" invokePrim [#_"DLDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface DLDD
        #_abstract
        (#_"double" invokePrim [#_"DLDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
    )

    (§ interface DDOO
        #_abstract
        (#_"Object" invokePrim [#_"DDOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface DDOL
        #_abstract
        (#_"long" invokePrim [#_"DDOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface DDOD
        #_abstract
        (#_"double" invokePrim [#_"DDOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
    )

    (§ interface DDLO
        #_abstract
        (#_"Object" invokePrim [#_"DDLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface DDLL
        #_abstract
        (#_"long" invokePrim [#_"DDLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface DDLD
        #_abstract
        (#_"double" invokePrim [#_"DDLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
    )

    (§ interface DDDO
        #_abstract
        (#_"Object" invokePrim [#_"DDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface DDDL
        #_abstract
        (#_"long" invokePrim [#_"DDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface DDDD
        #_abstract
        (#_"double" invokePrim [#_"DDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
    )

    (§ interface OOOOL
        #_abstract
        (#_"long" invokePrim [#_"OOOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface OOOOD
        #_abstract
        (#_"double" invokePrim [#_"OOOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface OOOLO
        #_abstract
        (#_"Object" invokePrim [#_"OOOLO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface OOOLL
        #_abstract
        (#_"long" invokePrim [#_"OOOLL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface OOOLD
        #_abstract
        (#_"double" invokePrim [#_"OOOLD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface OOODO
        #_abstract
        (#_"Object" invokePrim [#_"OOODO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface OOODL
        #_abstract
        (#_"long" invokePrim [#_"OOODL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface OOODD
        #_abstract
        (#_"double" invokePrim [#_"OOODD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface OOLOO
        #_abstract
        (#_"Object" invokePrim [#_"OOLOO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface OOLOL
        #_abstract
        (#_"long" invokePrim [#_"OOLOL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface OOLOD
        #_abstract
        (#_"double" invokePrim [#_"OOLOD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface OOLLO
        #_abstract
        (#_"Object" invokePrim [#_"OOLLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface OOLLL
        #_abstract
        (#_"long" invokePrim [#_"OOLLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface OOLLD
        #_abstract
        (#_"double" invokePrim [#_"OOLLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface OOLDO
        #_abstract
        (#_"Object" invokePrim [#_"OOLDO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface OOLDL
        #_abstract
        (#_"long" invokePrim [#_"OOLDL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface OOLDD
        #_abstract
        (#_"double" invokePrim [#_"OOLDD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface OODOO
        #_abstract
        (#_"Object" invokePrim [#_"OODOO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface OODOL
        #_abstract
        (#_"long" invokePrim [#_"OODOL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface OODOD
        #_abstract
        (#_"double" invokePrim [#_"OODOD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface OODLO
        #_abstract
        (#_"Object" invokePrim [#_"OODLO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface OODLL
        #_abstract
        (#_"long" invokePrim [#_"OODLL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface OODLD
        #_abstract
        (#_"double" invokePrim [#_"OODLD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface OODDO
        #_abstract
        (#_"Object" invokePrim [#_"OODDO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface OODDL
        #_abstract
        (#_"long" invokePrim [#_"OODDL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface OODDD
        #_abstract
        (#_"double" invokePrim [#_"OODDD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface OLOOO
        #_abstract
        (#_"Object" invokePrim [#_"OLOOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface OLOOL
        #_abstract
        (#_"long" invokePrim [#_"OLOOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface OLOOD
        #_abstract
        (#_"double" invokePrim [#_"OLOOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface OLOLO
        #_abstract
        (#_"Object" invokePrim [#_"OLOLO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface OLOLL
        #_abstract
        (#_"long" invokePrim [#_"OLOLL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface OLOLD
        #_abstract
        (#_"double" invokePrim [#_"OLOLD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface OLODO
        #_abstract
        (#_"Object" invokePrim [#_"OLODO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface OLODL
        #_abstract
        (#_"long" invokePrim [#_"OLODL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface OLODD
        #_abstract
        (#_"double" invokePrim [#_"OLODD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface OLLOO
        #_abstract
        (#_"Object" invokePrim [#_"OLLOO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface OLLOL
        #_abstract
        (#_"long" invokePrim [#_"OLLOL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface OLLOD
        #_abstract
        (#_"double" invokePrim [#_"OLLOD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface OLLLO
        #_abstract
        (#_"Object" invokePrim [#_"OLLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface OLLLL
        #_abstract
        (#_"long" invokePrim [#_"OLLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface OLLLD
        #_abstract
        (#_"double" invokePrim [#_"OLLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface OLLDO
        #_abstract
        (#_"Object" invokePrim [#_"OLLDO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface OLLDL
        #_abstract
        (#_"long" invokePrim [#_"OLLDL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface OLLDD
        #_abstract
        (#_"double" invokePrim [#_"OLLDD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface OLDOO
        #_abstract
        (#_"Object" invokePrim [#_"OLDOO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface OLDOL
        #_abstract
        (#_"long" invokePrim [#_"OLDOL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface OLDOD
        #_abstract
        (#_"double" invokePrim [#_"OLDOD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface OLDLO
        #_abstract
        (#_"Object" invokePrim [#_"OLDLO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface OLDLL
        #_abstract
        (#_"long" invokePrim [#_"OLDLL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface OLDLD
        #_abstract
        (#_"double" invokePrim [#_"OLDLD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface OLDDO
        #_abstract
        (#_"Object" invokePrim [#_"OLDDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface OLDDL
        #_abstract
        (#_"long" invokePrim [#_"OLDDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface OLDDD
        #_abstract
        (#_"double" invokePrim [#_"OLDDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface ODOOO
        #_abstract
        (#_"Object" invokePrim [#_"ODOOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface ODOOL
        #_abstract
        (#_"long" invokePrim [#_"ODOOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface ODOOD
        #_abstract
        (#_"double" invokePrim [#_"ODOOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface ODOLO
        #_abstract
        (#_"Object" invokePrim [#_"ODOLO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface ODOLL
        #_abstract
        (#_"long" invokePrim [#_"ODOLL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface ODOLD
        #_abstract
        (#_"double" invokePrim [#_"ODOLD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface ODODO
        #_abstract
        (#_"Object" invokePrim [#_"ODODO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface ODODL
        #_abstract
        (#_"long" invokePrim [#_"ODODL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface ODODD
        #_abstract
        (#_"double" invokePrim [#_"ODODD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface ODLOO
        #_abstract
        (#_"Object" invokePrim [#_"ODLOO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface ODLOL
        #_abstract
        (#_"long" invokePrim [#_"ODLOL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface ODLOD
        #_abstract
        (#_"double" invokePrim [#_"ODLOD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface ODLLO
        #_abstract
        (#_"Object" invokePrim [#_"ODLLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface ODLLL
        #_abstract
        (#_"long" invokePrim [#_"ODLLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface ODLLD
        #_abstract
        (#_"double" invokePrim [#_"ODLLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface ODLDO
        #_abstract
        (#_"Object" invokePrim [#_"ODLDO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface ODLDL
        #_abstract
        (#_"long" invokePrim [#_"ODLDL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface ODLDD
        #_abstract
        (#_"double" invokePrim [#_"ODLDD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface ODDOO
        #_abstract
        (#_"Object" invokePrim [#_"ODDOO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface ODDOL
        #_abstract
        (#_"long" invokePrim [#_"ODDOL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface ODDOD
        #_abstract
        (#_"double" invokePrim [#_"ODDOD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface ODDLO
        #_abstract
        (#_"Object" invokePrim [#_"ODDLO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface ODDLL
        #_abstract
        (#_"long" invokePrim [#_"ODDLL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface ODDLD
        #_abstract
        (#_"double" invokePrim [#_"ODDLD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface ODDDO
        #_abstract
        (#_"Object" invokePrim [#_"ODDDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface ODDDL
        #_abstract
        (#_"long" invokePrim [#_"ODDDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface ODDDD
        #_abstract
        (#_"double" invokePrim [#_"ODDDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LOOOO
        #_abstract
        (#_"Object" invokePrim [#_"LOOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LOOOL
        #_abstract
        (#_"long" invokePrim [#_"LOOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LOOOD
        #_abstract
        (#_"double" invokePrim [#_"LOOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LOOLO
        #_abstract
        (#_"Object" invokePrim [#_"LOOLO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LOOLL
        #_abstract
        (#_"long" invokePrim [#_"LOOLL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LOOLD
        #_abstract
        (#_"double" invokePrim [#_"LOOLD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LOODO
        #_abstract
        (#_"Object" invokePrim [#_"LOODO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LOODL
        #_abstract
        (#_"long" invokePrim [#_"LOODL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LOODD
        #_abstract
        (#_"double" invokePrim [#_"LOODD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LOLOO
        #_abstract
        (#_"Object" invokePrim [#_"LOLOO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LOLOL
        #_abstract
        (#_"long" invokePrim [#_"LOLOL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LOLOD
        #_abstract
        (#_"double" invokePrim [#_"LOLOD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LOLLO
        #_abstract
        (#_"Object" invokePrim [#_"LOLLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LOLLL
        #_abstract
        (#_"long" invokePrim [#_"LOLLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LOLLD
        #_abstract
        (#_"double" invokePrim [#_"LOLLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LOLDO
        #_abstract
        (#_"Object" invokePrim [#_"LOLDO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LOLDL
        #_abstract
        (#_"long" invokePrim [#_"LOLDL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LOLDD
        #_abstract
        (#_"double" invokePrim [#_"LOLDD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LODOO
        #_abstract
        (#_"Object" invokePrim [#_"LODOO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LODOL
        #_abstract
        (#_"long" invokePrim [#_"LODOL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LODOD
        #_abstract
        (#_"double" invokePrim [#_"LODOD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LODLO
        #_abstract
        (#_"Object" invokePrim [#_"LODLO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LODLL
        #_abstract
        (#_"long" invokePrim [#_"LODLL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LODLD
        #_abstract
        (#_"double" invokePrim [#_"LODLD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LODDO
        #_abstract
        (#_"Object" invokePrim [#_"LODDO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LODDL
        #_abstract
        (#_"long" invokePrim [#_"LODDL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LODDD
        #_abstract
        (#_"double" invokePrim [#_"LODDD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LLOOO
        #_abstract
        (#_"Object" invokePrim [#_"LLOOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LLOOL
        #_abstract
        (#_"long" invokePrim [#_"LLOOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LLOOD
        #_abstract
        (#_"double" invokePrim [#_"LLOOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LLOLO
        #_abstract
        (#_"Object" invokePrim [#_"LLOLO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LLOLL
        #_abstract
        (#_"long" invokePrim [#_"LLOLL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LLOLD
        #_abstract
        (#_"double" invokePrim [#_"LLOLD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LLODO
        #_abstract
        (#_"Object" invokePrim [#_"LLODO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LLODL
        #_abstract
        (#_"long" invokePrim [#_"LLODL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LLODD
        #_abstract
        (#_"double" invokePrim [#_"LLODD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LLLOO
        #_abstract
        (#_"Object" invokePrim [#_"LLLOO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LLLOL
        #_abstract
        (#_"long" invokePrim [#_"LLLOL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LLLOD
        #_abstract
        (#_"double" invokePrim [#_"LLLOD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LLLLO
        #_abstract
        (#_"Object" invokePrim [#_"LLLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LLLLL
        #_abstract
        (#_"long" invokePrim [#_"LLLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LLLLD
        #_abstract
        (#_"double" invokePrim [#_"LLLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LLLDO
        #_abstract
        (#_"Object" invokePrim [#_"LLLDO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LLLDL
        #_abstract
        (#_"long" invokePrim [#_"LLLDL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LLLDD
        #_abstract
        (#_"double" invokePrim [#_"LLLDD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LLDOO
        #_abstract
        (#_"Object" invokePrim [#_"LLDOO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LLDOL
        #_abstract
        (#_"long" invokePrim [#_"LLDOL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LLDOD
        #_abstract
        (#_"double" invokePrim [#_"LLDOD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LLDLO
        #_abstract
        (#_"Object" invokePrim [#_"LLDLO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LLDLL
        #_abstract
        (#_"long" invokePrim [#_"LLDLL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LLDLD
        #_abstract
        (#_"double" invokePrim [#_"LLDLD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LLDDO
        #_abstract
        (#_"Object" invokePrim [#_"LLDDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LLDDL
        #_abstract
        (#_"long" invokePrim [#_"LLDDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LLDDD
        #_abstract
        (#_"double" invokePrim [#_"LLDDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LDOOO
        #_abstract
        (#_"Object" invokePrim [#_"LDOOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LDOOL
        #_abstract
        (#_"long" invokePrim [#_"LDOOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LDOOD
        #_abstract
        (#_"double" invokePrim [#_"LDOOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface LDOLO
        #_abstract
        (#_"Object" invokePrim [#_"LDOLO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LDOLL
        #_abstract
        (#_"long" invokePrim [#_"LDOLL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LDOLD
        #_abstract
        (#_"double" invokePrim [#_"LDOLD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface LDODO
        #_abstract
        (#_"Object" invokePrim [#_"LDODO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LDODL
        #_abstract
        (#_"long" invokePrim [#_"LDODL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LDODD
        #_abstract
        (#_"double" invokePrim [#_"LDODD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface LDLOO
        #_abstract
        (#_"Object" invokePrim [#_"LDLOO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LDLOL
        #_abstract
        (#_"long" invokePrim [#_"LDLOL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LDLOD
        #_abstract
        (#_"double" invokePrim [#_"LDLOD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface LDLLO
        #_abstract
        (#_"Object" invokePrim [#_"LDLLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LDLLL
        #_abstract
        (#_"long" invokePrim [#_"LDLLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LDLLD
        #_abstract
        (#_"double" invokePrim [#_"LDLLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface LDLDO
        #_abstract
        (#_"Object" invokePrim [#_"LDLDO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LDLDL
        #_abstract
        (#_"long" invokePrim [#_"LDLDL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LDLDD
        #_abstract
        (#_"double" invokePrim [#_"LDLDD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface LDDOO
        #_abstract
        (#_"Object" invokePrim [#_"LDDOO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LDDOL
        #_abstract
        (#_"long" invokePrim [#_"LDDOL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LDDOD
        #_abstract
        (#_"double" invokePrim [#_"LDDOD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface LDDLO
        #_abstract
        (#_"Object" invokePrim [#_"LDDLO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LDDLL
        #_abstract
        (#_"long" invokePrim [#_"LDDLL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LDDLD
        #_abstract
        (#_"double" invokePrim [#_"LDDLD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface LDDDO
        #_abstract
        (#_"Object" invokePrim [#_"LDDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LDDDL
        #_abstract
        (#_"long" invokePrim [#_"LDDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface LDDDD
        #_abstract
        (#_"double" invokePrim [#_"LDDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DOOOO
        #_abstract
        (#_"Object" invokePrim [#_"DOOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DOOOL
        #_abstract
        (#_"long" invokePrim [#_"DOOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DOOOD
        #_abstract
        (#_"double" invokePrim [#_"DOOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DOOLO
        #_abstract
        (#_"Object" invokePrim [#_"DOOLO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DOOLL
        #_abstract
        (#_"long" invokePrim [#_"DOOLL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DOOLD
        #_abstract
        (#_"double" invokePrim [#_"DOOLD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DOODO
        #_abstract
        (#_"Object" invokePrim [#_"DOODO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DOODL
        #_abstract
        (#_"long" invokePrim [#_"DOODL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DOODD
        #_abstract
        (#_"double" invokePrim [#_"DOODD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DOLOO
        #_abstract
        (#_"Object" invokePrim [#_"DOLOO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DOLOL
        #_abstract
        (#_"long" invokePrim [#_"DOLOL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DOLOD
        #_abstract
        (#_"double" invokePrim [#_"DOLOD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DOLLO
        #_abstract
        (#_"Object" invokePrim [#_"DOLLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DOLLL
        #_abstract
        (#_"long" invokePrim [#_"DOLLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DOLLD
        #_abstract
        (#_"double" invokePrim [#_"DOLLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DOLDO
        #_abstract
        (#_"Object" invokePrim [#_"DOLDO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DOLDL
        #_abstract
        (#_"long" invokePrim [#_"DOLDL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DOLDD
        #_abstract
        (#_"double" invokePrim [#_"DOLDD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DODOO
        #_abstract
        (#_"Object" invokePrim [#_"DODOO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DODOL
        #_abstract
        (#_"long" invokePrim [#_"DODOL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DODOD
        #_abstract
        (#_"double" invokePrim [#_"DODOD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DODLO
        #_abstract
        (#_"Object" invokePrim [#_"DODLO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DODLL
        #_abstract
        (#_"long" invokePrim [#_"DODLL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DODLD
        #_abstract
        (#_"double" invokePrim [#_"DODLD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DODDO
        #_abstract
        (#_"Object" invokePrim [#_"DODDO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DODDL
        #_abstract
        (#_"long" invokePrim [#_"DODDL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DODDD
        #_abstract
        (#_"double" invokePrim [#_"DODDD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DLOOO
        #_abstract
        (#_"Object" invokePrim [#_"DLOOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DLOOL
        #_abstract
        (#_"long" invokePrim [#_"DLOOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DLOOD
        #_abstract
        (#_"double" invokePrim [#_"DLOOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DLOLO
        #_abstract
        (#_"Object" invokePrim [#_"DLOLO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DLOLL
        #_abstract
        (#_"long" invokePrim [#_"DLOLL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DLOLD
        #_abstract
        (#_"double" invokePrim [#_"DLOLD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DLODO
        #_abstract
        (#_"Object" invokePrim [#_"DLODO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DLODL
        #_abstract
        (#_"long" invokePrim [#_"DLODL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DLODD
        #_abstract
        (#_"double" invokePrim [#_"DLODD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DLLOO
        #_abstract
        (#_"Object" invokePrim [#_"DLLOO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DLLOL
        #_abstract
        (#_"long" invokePrim [#_"DLLOL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DLLOD
        #_abstract
        (#_"double" invokePrim [#_"DLLOD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DLLLO
        #_abstract
        (#_"Object" invokePrim [#_"DLLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DLLLL
        #_abstract
        (#_"long" invokePrim [#_"DLLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DLLLD
        #_abstract
        (#_"double" invokePrim [#_"DLLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DLLDO
        #_abstract
        (#_"Object" invokePrim [#_"DLLDO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DLLDL
        #_abstract
        (#_"long" invokePrim [#_"DLLDL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DLLDD
        #_abstract
        (#_"double" invokePrim [#_"DLLDD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DLDOO
        #_abstract
        (#_"Object" invokePrim [#_"DLDOO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DLDOL
        #_abstract
        (#_"long" invokePrim [#_"DLDOL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DLDOD
        #_abstract
        (#_"double" invokePrim [#_"DLDOD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DLDLO
        #_abstract
        (#_"Object" invokePrim [#_"DLDLO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DLDLL
        #_abstract
        (#_"long" invokePrim [#_"DLDLL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DLDLD
        #_abstract
        (#_"double" invokePrim [#_"DLDLD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DLDDO
        #_abstract
        (#_"Object" invokePrim [#_"DLDDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DLDDL
        #_abstract
        (#_"long" invokePrim [#_"DLDDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DLDDD
        #_abstract
        (#_"double" invokePrim [#_"DLDDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DDOOO
        #_abstract
        (#_"Object" invokePrim [#_"DDOOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DDOOL
        #_abstract
        (#_"long" invokePrim [#_"DDOOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DDOOD
        #_abstract
        (#_"double" invokePrim [#_"DDOOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
    )

    (§ interface DDOLO
        #_abstract
        (#_"Object" invokePrim [#_"DDOLO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DDOLL
        #_abstract
        (#_"long" invokePrim [#_"DDOLL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DDOLD
        #_abstract
        (#_"double" invokePrim [#_"DDOLD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
    )

    (§ interface DDODO
        #_abstract
        (#_"Object" invokePrim [#_"DDODO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DDODL
        #_abstract
        (#_"long" invokePrim [#_"DDODL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DDODD
        #_abstract
        (#_"double" invokePrim [#_"DDODD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
    )

    (§ interface DDLOO
        #_abstract
        (#_"Object" invokePrim [#_"DDLOO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DDLOL
        #_abstract
        (#_"long" invokePrim [#_"DDLOL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DDLOD
        #_abstract
        (#_"double" invokePrim [#_"DDLOD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
    )

    (§ interface DDLLO
        #_abstract
        (#_"Object" invokePrim [#_"DDLLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DDLLL
        #_abstract
        (#_"long" invokePrim [#_"DDLLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DDLLD
        #_abstract
        (#_"double" invokePrim [#_"DDLLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
    )

    (§ interface DDLDO
        #_abstract
        (#_"Object" invokePrim [#_"DDLDO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DDLDL
        #_abstract
        (#_"long" invokePrim [#_"DDLDL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DDLDD
        #_abstract
        (#_"double" invokePrim [#_"DDLDD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
    )

    (§ interface DDDOO
        #_abstract
        (#_"Object" invokePrim [#_"DDDOO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DDDOL
        #_abstract
        (#_"long" invokePrim [#_"DDDOL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DDDOD
        #_abstract
        (#_"double" invokePrim [#_"DDDOD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
    )

    (§ interface DDDLO
        #_abstract
        (#_"Object" invokePrim [#_"DDDLO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DDDLL
        #_abstract
        (#_"long" invokePrim [#_"DDDLL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DDDLD
        #_abstract
        (#_"double" invokePrim [#_"DDDLD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
    )

    (§ interface DDDDO
        #_abstract
        (#_"Object" invokePrim [#_"DDDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DDDDL
        #_abstract
        (#_"long" invokePrim [#_"DDDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )

    (§ interface DDDDD
        #_abstract
        (#_"double" invokePrim [#_"DDDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
    )
)
)

(java-ns cloiure.lang.IHashEq

(§ interface IHashEq
    #_abstract
    (#_"int" hasheq [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ interface IKeywordLookup
    #_abstract
    (#_"ILookupThunk" getLookupThunk [#_"IKeywordLookup" this, #_"Keyword" k])
)
)

(java-ns cloiure.lang.IKVReduce

(§ interface IKVReduce
    #_abstract
    (#_"Object" kvreduce [#_"IKVReduce" this, #_"IFn" f, #_"Object" init])
)
)

(java-ns cloiure.lang.ILookup

(§ interface ILookup
    #_abstract
    (#_"Object" valAt [#_"ILookup" this, #_"Object" key])
    #_abstract
    (#_"Object" valAt [#_"ILookup" this, #_"Object" key, #_"Object" notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(§ interface ILookupSite
    #_abstract
    (#_"ILookupThunk" fault [#_"ILookupSite" this, #_"Object" target])
)
)

(java-ns cloiure.lang.ILookupThunk

(§ interface ILookupThunk
    #_abstract
    (#_"Object" get [#_"ILookupThunk" this, #_"Object" target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ interface IMapEntry (§ extends Map.Entry)
    #_abstract
    (#_"Object" key [#_"IMapEntry" this])
    #_abstract
    (#_"Object" val [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ interface IMapIterable
    #_abstract
    (#_"Iterator" keyIterator [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" valIterator [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(§ interface IMeta
    #_abstract
    (#_"IPersistentMap" meta [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(§ interface Indexed (§ extends Counted)
    #_abstract
    (#_"Object" nth [#_"Indexed" this, #_"int" i])
    #_abstract
    (#_"Object" nth [#_"Indexed" this, #_"int" i, #_"Object" notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(§ interface IndexedSeq (§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" index [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (§ defn- #_"Object[]" oa [#_"Object..." arr]
        arr
    )

    (§ def #_"IPersistentMap" ops (ß RT.map(
      #_map "public static double cloiure.lang.Numbers.add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.and(long,long)", LAND,
      #_map "public static long cloiure.lang.Numbers.or(long,long)", LOR,
      #_map "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
      #_map "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
      #_map "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
      #_map "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
      #_map "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
      #_map "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
      #_map "public static double cloiure.lang.Numbers.minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
      #_map "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
      #_map "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
      #_map "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
      #_map "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
      #_map "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
      #_map "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
      #_map "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
      #_map "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
      #_map "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

      #_map "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
      #_map "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
      #_map "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
      #_map "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
      #_map "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
      #_map "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
      #_map "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
      #_map "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
      #_map "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
      #_map "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

      #_map "public static double cloiure.lang.RT.doubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.doubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.doubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.doubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
      #_map "public static long cloiure.lang.RT.longCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.longCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(int)", I2L,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    )))

    ;; map to instructions terminated with comparator for branch to false
    (§ def #_"IPersistentMap" preds (ß RT.map(
      #_map "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
      #_map "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
      #_map "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
      #_map "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

      #_map "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    )))
)
)

(java-ns cloiure.lang.IObj

(§ interface IObj (§ extends IMeta)
    #_abstract
    (#_"IObj" withMeta [#_"IObj" this, #_"IPersistentMap" meta])
)
)

(java-ns cloiure.lang.IPending

(§ interface IPending
    #_abstract
    (#_"boolean" isRealized [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ interface IPersistentCollection (§ extends Seqable)
    #_abstract
    (#_"int" count [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" cons [#_"IPersistentCollection" this, #_"Object" o])
    #_abstract
    (#_"IPersistentCollection" empty [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" equiv [#_"IPersistentCollection" this, #_"Object" o])
)
)

(java-ns cloiure.lang.IPersistentList

(§ interface IPersistentList (§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ interface IPersistentMap (§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" assoc [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"IPersistentMap" assocEx [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"IPersistentMap" without [#_"IPersistentMap" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IPersistentSet

(§ interface IPersistentSet (§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" disjoin [#_"IPersistentSet" this, #_"Object" key])
    #_abstract
    (#_"boolean" contains [#_"IPersistentSet" this, #_"Object" key])
    #_abstract
    (#_"Object" get [#_"IPersistentSet" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IPersistentStack

(§ interface IPersistentStack (§ extends IPersistentCollection)
    #_abstract
    (#_"Object" peek [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" pop [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(§ interface IPersistentVector (§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" length [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" assocN [#_"IPersistentVector" this, #_"int" i, #_"Object" val])
    #_abstract
    (#_"IPersistentVector" cons [#_"IPersistentVector" this, #_"Object" o])
)
)

(java-ns cloiure.lang.IProxy

(§ interface IProxy
    #_abstract
    (#_"void" __initCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" m])
    #_abstract
    (#_"void" __updateCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" m])
    #_abstract
    (#_"IPersistentMap" __getCloiureFnMappings [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(§ interface IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ interface IReduce (§ extends IReduceInit)
    #_abstract
    (#_"Object" reduce [#_"IReduce" this, #_"IFn" f])
)
)

(java-ns cloiure.lang.IReduceInit

(§ interface IReduceInit
    #_abstract
    (#_"Object" reduce [#_"IReduceInit" this, #_"IFn" f, #_"Object" start])
)
)

(java-ns cloiure.lang.IRef

(§ interface IRef (§ extends IDeref)
    #_abstract
    (#_"void" setValidator [#_"IRef" this, #_"IFn" vf])
    #_abstract
    (#_"IFn" getValidator [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" getWatches [#_"IRef" this])
    #_abstract
    (#_"IRef" addWatch [#_"IRef" this, #_"Object" key, #_"IFn" callback])
    #_abstract
    (#_"IRef" removeWatch [#_"IRef" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IReference

(§ interface IReference (§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" alterMeta [#_"IReference" this, #_"IFn" alter, #_"ISeq" args])
    #_abstract
    (#_"IPersistentMap" resetMeta [#_"IReference" this, #_"IPersistentMap" m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ interface ISeq (§ extends IPersistentCollection)
    #_abstract
    (#_"Object" first [#_"ISeq" this])
    #_abstract
    (#_"ISeq" next [#_"ISeq" this])
    #_abstract
    (#_"ISeq" more [#_"ISeq" this])
    #_abstract
    (#_"ISeq" cons [#_"ISeq" this, #_"Object" o])
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (§ def- #_"Object" UNREALIZED_SEED (Object.))

    (§ init
        (§ field- #_"IFn" f nil) ;; never nil
        (§ field- #_"Object" prevSeed nil)
        #_volatile
        (§ field- #_"Object" _seed nil) ;; lazily realized
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Iterate" Iterate [#_"IFn" f, #_"Object" prevSeed, #_"Object" seed]
        (let [this (ß super())]
            (§ ass (ß this.f) f)
            (§ ass (ß this.prevSeed) prevSeed)
            (§ ass (ß this._seed) seed)
            this
        )
    )

    (§ constructor- #_"Iterate" Iterate [#_"IPersistentMap" meta, #_"IFn" f, #_"Object" prevSeed, #_"Object" seed, #_"ISeq" next]
        (let [this (ß super(meta))]
            (§ ass (ß this.f) f)
            (§ ass (ß this.prevSeed) prevSeed)
            (§ ass (ß this._seed) seed)
            (§ ass (ß this._next) next)
            this
        )
    )

    (§ defn #_"ISeq" create [#_"IFn" f, #_"Object" seed]
        (ß new Iterate(f, nil, seed))
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Iterate" this]
        (ß (_seed != UNREALIZED_SEED))
    )

    #_method
    (§ defn #_"Object" first [#_"Iterate" this]
        (when (ß _seed == UNREALIZED_SEED)
            (§ ass _seed (ß f.invoke(prevSeed)))
        )
        (ß _seed)
    )

    #_method
    (§ defn #_"ISeq" next [#_"Iterate" this]
        (when (nil? _next)
            (§ ass _next (ß new Iterate(f, first(), UNREALIZED_SEED)))
        )
        (ß _next)
    )

    #_method
    (§ defn #_"Iterate" withMeta [#_"Iterate" this, #_"IPersistentMap" meta]
        (ß new Iterate(meta, f, prevSeed, _seed, _next))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Iterate" this, #_"IFn" rf]
        (let [#_"Object" first (ß first())]
            (let [#_"Object" ret first]
                (let [#_"Object" v (ß f.invoke(first))]
                    (while true
                        (§ ass ret (ß rf.invoke(ret, v)))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                        (§ ass v (ß f.invoke(v)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Iterate" this, #_"IFn" rf, #_"Object" start]
        (let [#_"Object" ret start]
            (let [#_"Object" v (ß first())]
                (while true
                    (§ ass ret (ß rf.invoke(ret, v)))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (§ ass v (ß f.invoke(v)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeq (§ extends ASeq)
    (class-ns IteratorSeq'State
        (§ init
            #_volatile
            (§ field #_"Object" val nil)
            #_volatile
            (§ field #_"Object" _rest nil)
        )
    )

    (§ defn #_"IteratorSeq" create [#_"Iterator" iter]
        (when (ß iter.hasNext())
            (§ return (IteratorSeq. iter))
        )
        nil
    )

    (§ init
        (§ field #_"Iterator" iter nil)
        (§ field #_"IteratorSeq'State" state nil)
    )

    (§ constructor #_"IteratorSeq" IteratorSeq [#_"Iterator" iter]
        (let [this (ß super())]
            (§ ass (ß this.iter) iter)
            (§ ass state (IteratorSeq'State.))
            (§ ass (ß this.state.val) state)
            (§ ass (ß this.state._rest) state)
            this
        )
    )

    (§ constructor #_"IteratorSeq" IteratorSeq [#_"IPersistentMap" meta, #_"Iterator" iter, #_"IteratorSeq'State" state]
        (let [this (ß super(meta))]
            (§ ass (ß this.iter) iter)
            (§ ass (ß this.state) state)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"IteratorSeq" this]
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (§ ass (ß state.val) (ß iter.next()))
                )
            )
        )
        (ß state.val)
    )

    #_method
    (§ defn #_"ISeq" next [#_"IteratorSeq" this]
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (§ ass (ß state._rest) (ß create(iter)))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    #_method
    (§ defn #_"IteratorSeq" withMeta [#_"IteratorSeq" this, #_"IPersistentMap" meta]
        (ß new IteratorSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ interface ITransientAssociative (§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" assoc [#_"ITransientAssociative" this, #_"Object" key, #_"Object" val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ interface ITransientAssociative2 (§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" containsKey [#_"ITransientAssociative2" this, #_"Object" key])
    #_abstract
    (#_"IMapEntry" entryAt [#_"ITransientAssociative2" this, #_"Object" key])
)
)

(java-ns cloiure.lang.ITransientCollection

(§ interface ITransientCollection
    #_abstract
    (#_"ITransientCollection" conj [#_"ITransientCollection" this, #_"Object" val])
    #_abstract
    (#_"IPersistentCollection" persistent [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(§ interface ITransientMap (§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" assoc [#_"ITransientMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"ITransientMap" without [#_"ITransientMap" this, #_"Object" key])
    #_abstract
    (#_"IPersistentMap" persistent [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(§ interface ITransientSet (§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" disjoin [#_"ITransientSet" this, #_"Object" key])
    #_abstract
    (#_"boolean" contains [#_"ITransientSet" this, #_"Object" key])
    #_abstract
    (#_"Object" get [#_"ITransientSet" this, #_"Object" key])
)
)

(java-ns cloiure.lang.ITransientVector

(§ interface ITransientVector (§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" assocN [#_"ITransientVector" this, #_"int" i, #_"Object" val])
    #_abstract
    (#_"ITransientVector" pop [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(§ interface IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (§ def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" table (ConcurrentHashMap.))

    (§ def #_"ReferenceQueue" rq (ReferenceQueue.))

    (§ defn #_"Keyword" intern [#_"Symbol" sym]
        (let [#_"Keyword" k nil]
            (let [#_"Reference<Keyword>" existingRef (ß table.get(sym))]
                (when (nil? existingRef)
                    (ß Util.clearCache(rq, table))
                    (when (ß sym.meta() != nil)
                        (§ ass sym (ß (Symbol) sym.withMeta(nil)))
                    )
                    (§ ass k (Keyword. sym))
                    (§ ass existingRef (ß table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq))))
                )
                (when (nil? existingRef)
                    (§ return k)
                )
                (let [#_"Keyword" existingk (ß existingRef.get())]
                    (when (some? existingk)
                        (§ return existingk)
                    )
                    ;; entry died in the interim, do over
                    (ß table.remove(sym, existingRef))
                    (ß intern(sym))
                )
            )
        )
    )

    (§ defn #_"Keyword" intern [#_"String" ns, #_"String" name]
        (ß intern(Symbol.intern(ns, name)))
    )

    (§ defn #_"Keyword" intern [#_"String" nsname]
        (ß intern(Symbol.intern(nsname)))
    )

    (§ init
        (§ field #_"Symbol" sym nil)
        (§ field #_"int" hasheq 0)
        #_transient
        (§ field #_"String" _str nil)
    )

    (§ constructor- #_"Keyword" Keyword [#_"Symbol" sym]
        (let [this (ß super())]
            (§ ass (ß this.sym) sym)
            (§ ass hasheq (ß sym.hasheq() + 0x9e3779b9))
            this
        )
    )

    (§ defn #_"Keyword" find [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" ref (ß table.get(sym))]
            (if (some? ref)
                (do
                    (ß ref.get())
                )
                (do
                    nil
                )
            )
        )
    )

    (§ defn #_"Keyword" find [#_"String" ns, #_"String" name]
        (ß find(Symbol.intern(ns, name)))
    )

    (§ defn #_"Keyword" find [#_"String" nsname]
        (ß find(Symbol.intern(nsname)))
    )

    #_method
    (§ defn #_"int" hashCode [#_"Keyword" this]
        (ß sym.hashCode() + 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" hasheq [#_"Keyword" this]
        hasheq
    )

    #_method
    (§ defn #_"String" toString [#_"Keyword" this]
        (when (nil? _str)
            (§ ass _str (ß (":" + sym)))
        )
        (ß _str)
    )

    #_method
    (§ defn #_"Object" throwArity [#_"Keyword" this]
        (throw (ß new IllegalArgumentException("Wrong number of args passed to keyword: " + toString())))
    )

    #_method
    (§ defn #_"Object" call [#_"Keyword" this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"void" run [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"int" compareTo [#_"Keyword" this, #_"Object" o]
        (ß sym.compareTo(((Keyword) o).sym))
    )

    #_method
    (§ defn #_"String" getNamespace [#_"Keyword" this]
        (ß sym.getNamespace())
    )

    #_method
    (§ defn #_"String" getName [#_"Keyword" this]
        (ß sym.getName())
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" obj]
        (when (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this)))
        )
        (ß RT.get(obj, this))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" obj, #_"Object" notFound]
        (when (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this, notFound)))
        )
        (ß RT.get(obj, this, notFound))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Keyword" this, #_"ISeq" arglist]
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (§ init
        (§ field #_"Keyword" k nil)
    )

    (§ constructor #_"KeywordLookupSite" KeywordLookupSite [#_"Keyword" k]
        (let [this (ß super())]
            (§ ass (ß this.k) k)
            this
        )
    )

    #_method
    (§ defn #_"ILookupThunk" fault [#_"KeywordLookupSite" this, #_"Object" target]
        (cond (ß target instanceof IKeywordLookup)
            (do
                (§ return (ß install(target)))
            )
            (ß target instanceof ILookup)
            (do
                (§ return (ß ilookupThunk(target.getClass())))
            )
        )
        this
    )

    #_method
    (§ defn #_"Object" get [#_"KeywordLookupSite" this, #_"Object" target]
        (when (ß target instanceof IKeywordLookup || target instanceof ILookup)
            (§ return this)
        )
        (ß RT.get(target, k))
    )

    #_method
    (§ defn- #_"ILookupThunk" ilookupThunk [#_"KeywordLookupSite" this, #_"Class" c]
        (§ reify ILookupThunk()
            #_method
            (§ defn #_"Object" get [#_"ILookupThunk" this, #_"Object" target]
                (when (ß target != nil && target.getClass() == c)
                    (§ return (ß ((ILookup) target).valAt(k)))
                )
                this
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" install [#_"KeywordLookupSite" this, #_"Object" target]
        (let [#_"ILookupThunk" t (ß ((IKeywordLookup)target).getLookupThunk(k))]
            (when (some? t)
                (§ return t)
            )
            (ß ilookupThunk(target.getClass()))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (§ defn #_"IPersistentVector" createOwning [#_"Object..." items]
        (when (ß items.length <= 32)
            (§ return (ß new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)))
        )
        (ß PersistentVector.create(items))
    )

    (§ defn #_"int" fcount [#_"Object" c]
        (when (ß c instanceof Counted)
            (§ return (ß ((Counted) c).count()))
        )
        (ß ((Collection)c).size())
    )

    (§ defn #_"IPersistentVector" create [#_"Object" obj]
        (cond (ß obj instanceof IReduceInit)
            (do
                (ß PersistentVector.create((IReduceInit) obj))
            )
            (ß obj instanceof ISeq)
            (do
                (ß PersistentVector.create(RT.seq(obj)))
            )
            (ß obj instanceof Iterable)
            (do
                (ß PersistentVector.create((Iterable)obj))
            )
            :else
            (do
                (ß createOwning(RT.toArray(obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (§ init
        (§ field- #_"IFn" fn nil)
        (§ field- #_"Object" sv nil)
        (§ field- #_"ISeq" s nil)
    )

    (§ constructor #_"LazySeq" LazySeq [#_"IFn" fn]
        (let [this (ß super())]
            (§ ass (ß this.fn) fn)
            this
        )
    )

    (§ constructor- #_"LazySeq" LazySeq [#_"IPersistentMap" meta, #_"ISeq" s]
        (let [this (ß super(meta))]
            (§ ass (ß this.fn) nil)
            (§ ass (ß this.s) s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"LazySeq" this, #_"IPersistentMap" meta]
        (ß new LazySeq(meta, seq()))
    )

    #_method
    (§ defn #_"Object" sval [#_"LazySeq" this]
        (§ sync this
            (when (some? fn)
                (§ ass sv (ß fn.invoke()))
                (§ ass fn nil)
            )
            (when (some? sv)
                (§ return sv)
            )
            s
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"LazySeq" this]
        (§ sync this
            (ß sval())
            (when (some? sv)
                (let [#_"Object" ls sv]
                    (§ ass sv nil)
                    (while (ß ls instanceof LazySeq)
                        (§ ass ls (ß ((LazySeq)ls).sval()))
                    )
                    (§ ass s (ß RT.seq(ls)))
                )
            )
            s
        )
    )

    #_method
    (§ defn #_"int" count [#_"LazySeq" this]
        (let [#_"int" c 0]
            (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
                (§ ass c (ß c + 1))
            )
            c
        )
    )

    #_method
    (§ defn #_"Object" first [#_"LazySeq" this]
        (ß seq())
        (when (nil? s)
            (§ return nil)
        )
        (ß s.first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"LazySeq" this]
        (ß seq())
        (when (nil? s)
            (§ return nil)
        )
        (ß s.next())
    )

    #_method
    (§ defn #_"ISeq" more [#_"LazySeq" this]
        (ß seq())
        (when (nil? s)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß s.more())
    )

    #_method
    (§ defn #_"ISeq" cons [#_"LazySeq" this, #_"Object" o]
        (ß RT.cons(o, seq()))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"LazySeq" this]
        (ß PersistentList.EMPTY)
    )

    #_method
    (§ defn #_"boolean" equiv [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (if (some? s)
                (do
                    (ß s.equiv(o))
                )
                (do
                    (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"LazySeq" this]
        (let [#_"ISeq" s (ß seq())]
            (when (nil? s)
                (§ return 1)
            )
            (ß Util.hash(s))
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"LazySeq" this]
        (ß Murmur3.hashOrdered(this))
    )

    #_method
    (§ defn #_"boolean" equals [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (if (some? s)
                (do
                    (ß s.equals(o))
                )
                (do
                    (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"LazySeq" this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"LazySeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"LazySeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"LazySeq" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"LazySeq" this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [#_"LazySeq" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"LazySeq" this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [#_"LazySeq" this, #_"Object" o]
        (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"LazySeq" this]
        (SeqIterator. this)
    )

    #_method
    (§ defn- #_"List" reify [#_"LazySeq" this]
        (ArrayList. this)
    )

    #_method
    (§ defn #_"List" subList [#_"LazySeq" this, #_"int" fromIndex, #_"int" toIndex]
        (ß reify().subList(fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"LazySeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"LazySeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (loop-when-recur [(§ var #_"int" i 0)] (some? s) [(§ ass s (ß s.next()), i (ß i + 1))]
                (when (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"LazySeq" this, #_"Object" o]
        (ß reify().lastIndexOf(o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this, #_"int" index]
        (ß reify().listIterator(index))
    )

    #_method
    (§ defn #_"Object" get [#_"LazySeq" this, #_"int" index]
        (ß RT.nth(this, index))
    )

    #_method
    (§ defn #_"void" add [#_"LazySeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"LazySeq" this]
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (§ def- #_"int" newline (ß (int) \newline))

    (§ init
        (§ field- #_"boolean" _atLineStart true)
        (§ field- #_"boolean" _prev false)
        (§ field- #_"int" _columnNumber 1)
    )

    (§ constructor #_"LineNumberingPushbackReader" LineNumberingPushbackReader [#_"Reader" r]
        (let [this (ß super(new LineNumberReader(r)))]
            this
        )
    )

    (§ constructor #_"LineNumberingPushbackReader" LineNumberingPushbackReader [#_"Reader" r, #_"int" size]
        (let [this (ß super(new LineNumberReader(r, size)))]
            this
        )
    )

    #_method
    (§ defn #_"int" getLineNumber [#_"LineNumberingPushbackReader" this]
        (ß ((LineNumberReader) in).getLineNumber() + 1)
    )

    #_method
    (§ defn #_"void" setLineNumber [#_"LineNumberingPushbackReader" this, #_"int" line]
        (ß ((LineNumberReader) in).setLineNumber(line - 1))
        nil
    )

    #_method
    (§ defn #_"int" getColumnNumber [#_"LineNumberingPushbackReader" this]
        (ß _columnNumber)
    )

    #_method
    (§ defn #_"int" read [#_"LineNumberingPushbackReader" this] (§ throws IOException)
        (let [#_"int" c (ß super.read())]
            (§ ass _prev (ß _atLineStart))
            (if (ß (c == newline) || (c == -1))
                (do
                    (§ ass _atLineStart true)
                    (§ ass _columnNumber 1)
                )
                (do
                    (§ ass _atLineStart false)
                    (§ ass _columnNumber (ß _columnNumber + 1))
                )
            )
            c
        )
    )

    #_method
    (§ defn #_"void" unread [#_"LineNumberingPushbackReader" this, #_"int" c] (§ throws IOException)
        (ß super.unread(c))
        (§ ass _atLineStart (ß _prev))
        (§ ass _columnNumber (ß _columnNumber - 1))
        nil
    )

    #_method
    (§ defn #_"String" readLine [#_"LineNumberingPushbackReader" this] (§ throws IOException)
        (let [#_"int" c (ß read())]
            (§ let [#_"String" line]
                (§ switch c
                    (§ case -1)
                    (do
                        (§ ass line nil)
                        (§ break )
                    )
                    (§ case newline)
                    (do
                        (§ ass line "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" first (ß String.valueOf((char) c))]
                            (let [#_"String" rest (ß ((LineNumberReader)in).readLine())]
                                (§ ass line (ß (rest == nil) ? first :or first + rest))
                                (§ ass _prev false)
                                (§ ass _atLineStart true)
                                (§ ass _columnNumber 1)
                                (§ break )
                            )
                        )
                    )
                )
                line
            )
        )
    )

    #_method
    (§ defn #_"boolean" atLineStart [#_"LineNumberingPushbackReader" this]
        (ß _atLineStart)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" QUOTE (ß Symbol.intern("quote")))
    (§ def #_"Symbol" THE_VAR (ß Symbol.intern("var")))

    (§ def #_"Symbol" UNQUOTE (ß Symbol.intern("cloiure.core", "unquote")))
    (§ def #_"Symbol" UNQUOTE_SPLICING (ß Symbol.intern("cloiure.core", "unquote-splicing")))
    (§ def #_"Symbol" CONCAT (ß Symbol.intern("cloiure.core", "concat")))
    (§ def #_"Symbol" SEQ (ß Symbol.intern("cloiure.core", "seq")))
    (§ def #_"Symbol" LIST (ß Symbol.intern("cloiure.core", "list")))
    (§ def #_"Symbol" APPLY (ß Symbol.intern("cloiure.core", "apply")))
    (§ def #_"Symbol" HASHMAP (ß Symbol.intern("cloiure.core", "hash-map")))
    (§ def #_"Symbol" HASHSET (ß Symbol.intern("cloiure.core", "hash-set")))
    (§ def #_"Symbol" VECTOR (ß Symbol.intern("cloiure.core", "vector")))
    (§ def #_"Symbol" WITH_META (ß Symbol.intern("cloiure.core", "with-meta")))
    (§ def #_"Symbol" META (ß Symbol.intern("cloiure.core", "meta")))
    (§ def #_"Symbol" DEREF (ß Symbol.intern("cloiure.core", "deref")))
    (§ def #_"Symbol" READ_COND (ß Symbol.intern("cloiure.core", "read-cond")))
    (§ def #_"Symbol" READ_COND_SPLICING (ß Symbol.intern("cloiure.core", "read-cond-splicing")))
    (§ def #_"Keyword" UNKNOWN (ß Keyword.intern(nil, "unknown")))

    (§ def #_"IFn[]" macros (ß new IFn[256]))
    (§ def #_"IFn[]" dispatchMacros (ß new IFn[256]))

    (§ def #_"Pattern" symbolPat (ß Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")))
    (§ def #_"Pattern" intPat (ß Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")))
    (§ def #_"Pattern" ratioPat (ß Pattern.compile("([-+]?[0-9]+)/([0-9]+)")))
    (§ def #_"Pattern" floatPat (ß Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")))

    ;; symbol->gensymbol
    (§ def #_"Var" GENSYM_ENV (ß Var.create(nil).setDynamic()))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" ARG_ENV (ß Var.create(nil).setDynamic()))
    (§ def #_"IFn" ctorReader (CtorReader.))

    ;; Dynamic var set to true in a read-cond context
    (§ def #_"Var" READ_COND_ENV (ß Var.create(nil).setDynamic()))

    (§ static
        (§ ass (ß macros[\"]) (LispReader'StringReader.)) ;; oops! "
        (§ ass (ß macros[\;]) (LispReader'CommentReader.))
        (§ ass (ß macros[\']) (WrappingReader. QUOTE))
        (§ ass (ß macros[\@]) (WrappingReader. DEREF))
        (§ ass (ß macros[\^]) (LispReader'MetaReader.))
        (§ ass (ß macros[\`]) (SyntaxQuoteReader.))
        (§ ass (ß macros[\~]) (UnquoteReader.))
        (§ ass (ß macros[\(]) (LispReader'ListReader.))
        (§ ass (ß macros[\)]) (LispReader'UnmatchedDelimiterReader.))
        (§ ass (ß macros[\[]) (LispReader'VectorReader.))
        (§ ass (ß macros[\]]) (LispReader'UnmatchedDelimiterReader.))
        (§ ass (ß macros[\{]) (LispReader'MapReader.))
        (§ ass (ß macros[\}]) (LispReader'UnmatchedDelimiterReader.))
        (§ ass (ß macros[\\]) (LispReader'CharacterReader.))
        (§ ass (ß macros[\%]) (ArgReader.))
        (§ ass (ß macros[\#]) (LispReader'DispatchReader.))

        (§ ass (ß dispatchMacros[\^]) (LispReader'MetaReader.))
        (§ ass (ß dispatchMacros[\#]) (LispReader'SymbolicValueReader.))
        (§ ass (ß dispatchMacros[\']) (VarReader.))
        (§ ass (ß dispatchMacros[\"]) (RegexReader.)) ;; oops! "
        (§ ass (ß dispatchMacros[\(]) (FnReader.))
        (§ ass (ß dispatchMacros[\{]) (LispReader'SetReader.))
        (§ ass (ß dispatchMacros[\=]) (EvalReader.))
        (§ ass (ß dispatchMacros[\!]) (LispReader'CommentReader.))
        (§ ass (ß dispatchMacros[\<]) (LispReader'UnreadableReader.))
        (§ ass (ß dispatchMacros[\_]) (LispReader'DiscardReader.))
        (§ ass (ß dispatchMacros[\?]) (ConditionalReader.))
        (§ ass (ß dispatchMacros[\:]) (LispReader'NamespaceMapReader.))
    )

    (§ interface Resolver
        #_abstract
        (#_"Symbol" currentNS [#_"Resolver" this])
        #_abstract
        (#_"Symbol" resolveClass [#_"Resolver" this, #_"Symbol" sym])
        #_abstract
        (#_"Symbol" resolveAlias [#_"Resolver" this, #_"Symbol" sym])
        #_abstract
        (#_"Symbol" resolveVar [#_"Resolver" this, #_"Symbol" sym])
    )

    (§ defn #_"boolean" isWhitespace [#_"int" ch]
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn #_"void" unread [#_"PushbackReader" r, #_"int" ch]
        (when (ß ch != -1)
            (try
                (ß r.unread(ch))
                (catch IOException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )
        nil
    )

    (class-ns LispReader'ReaderException (§ extends RuntimeException)
        (§ init
            (§ field #_"int" line 0)
            (§ field #_"int" column 0)
        )

        (§ constructor #_"LispReader'ReaderException" LispReader'ReaderException [#_"int" line, #_"int" column, #_"Throwable" cause]
            (let [this (ß super(cause))]
                (§ ass (ß this.line) line)
                (§ ass (ß this.column) column)
                this
            )
        )
    )

    (§ defn #_"int" read1 [#_"Reader" r]
        (try
            (ß r.read())
            (catch IOException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" OPT_EOF (ß Keyword.intern(nil, "eof")))
    (§ def #_"Keyword" OPT_FEATURES (ß Keyword.intern(nil, "features")))
    (§ def #_"Keyword" OPT_READ_COND (ß Keyword.intern(nil, "read-cond")))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" EOFTHROW (ß Keyword.intern(nil, "eofthrow")))

    ;; Platform features - always installed
    (§ def- #_"Keyword" PLATFORM_KEY (ß Keyword.intern(nil, "cli")))
    (§ def- #_"Object" PLATFORM_FEATURES (ß PersistentHashSet.create(PLATFORM_KEY)))

    ;; Reader conditional options - use with :read-cond
    (§ def #_"Keyword" COND_ALLOW (ß Keyword.intern(nil, "allow")))
    (§ def #_"Keyword" COND_PRESERVE (ß Keyword.intern(nil, "preserve")))

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"Object" opts]
        (let [#_"boolean" eofIsError true]
            (let [#_"Object" eofValue nil]
                (when (ß opts != nil && opts instanceof IPersistentMap)
                    (let [#_"Object" eof (ß ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW))]
                        (when (ß !EOFTHROW.equals(eof))
                            (§ ass eofIsError false)
                            (§ ass eofValue eof)
                        )
                    )
                )
                (ß read(r, eofIsError, eofValue, false, opts))
            )
        )
    )

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive]
        (ß read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY))
    )

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" opts]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, nil, (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" opts, #_"Object" pendingForms]
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- #_"Object" ensurePending [#_"Object" pendingForms]
        (if (nil? pendingForms)
            (do
                (LinkedList.)
            )
            (do
                pendingForms
            )
        )
    )

    (§ defn- #_"Object" installPlatformFeature [#_"Object" opts]
        (if (nil? opts)
            (do
                (ß RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
            )
            (do
                (let [#_"IPersistentMap" mopts (ß (IPersistentMap) opts)]
                    (let [#_"Object" features (ß mopts.valAt(OPT_FEATURES))]
                        (if (nil? features)
                            (do
                                (ß mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
                            )
                            (do
                                (ß mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"Character" returnOn, #_"Object" returnOnValue, #_"boolean" isRecursive, #_"Object" opts, #_"Object" pendingForms, #_"Resolver" resolver]
        (when (ß RT.READEVAL.deref() == UNKNOWN)
            (throw (ß Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown")))
        )

        (§ ass opts (ß installPlatformFeature(opts)))

        (try
            (while true
                (when (ß pendingForms instanceof List && !((List)pendingForms).isEmpty())
                    (§ return (ß ((List)pendingForms).remove(0)))
                )

                (let [#_"int" ch (ß read1(r))]
                    (while (ß isWhitespace(ch))
                        (§ ass ch (ß read1(r)))
                    )

                    (when (ß ch == -1)
                        (when eofIsError
                            (throw (ß Util.runtimeException("EOF while reading")))
                        )
                        (§ return eofValue)
                    )

                    (when (ß returnOn != nil && (returnOn.charValue() == ch))
                        (§ return returnOnValue)
                    )

                    (when (ß Character.isDigit(ch))
                        (let [#_"Object" n (ß readNumber(r, (char) ch))]
                            (§ return n)
                        )
                    )

                    (let [#_"IFn" macroFn (ß getMacro(ch))]
                        (when (some? macroFn)
                            (let [#_"Object" ret (ß macroFn.invoke(r, (char) ch, opts, pendingForms))]
                                ;; no op macros return the reader
                                (when (ß ret == r)
                                    (§ continue )
                                )
                                (§ return ret)
                            )
                        )

                        (when (ß ch == \+ || ch == \-)
                            (let [#_"int" ch2 (ß read1(r))]
                                (when (ß Character.isDigit(ch2))
                                    (ß unread(r, ch2))
                                    (let [#_"Object" n (ß readNumber(r, (char) ch))]
                                        (§ return n)
                                    )
                                )
                                (ß unread(r, ch2))
                            )
                        )

                        (let [#_"String" token (ß readToken(r, (char) ch))]
                            (§ return (ß interpretToken(token, resolver)))
                        )
                    )
                )
            )
            (catch Exception e
                (when (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                    (throw (ß Util.sneakyThrow(e)))
                )
                (let [#_"LineNumberingPushbackReader" rdr (ß (LineNumberingPushbackReader) r)]
                    (throw (ß new LispReader'ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)))
                )
            )
        )
    )

    (§ defn- #_"String" readToken [#_"PushbackReader" r, #_"char" initch]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (ß unread(r, ch))
                        (§ return (ß sb.toString()))
                    )
                    (ß sb.append((char) ch))
                )
            )
        )
    )

    (§ defn- #_"Object" readNumber [#_"PushbackReader" r, #_"char" initch]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                        (ß unread(r, ch))
                        (§ break )
                    )
                    (ß sb.append((char) ch))
                )
            )

            (let [#_"String" s (ß sb.toString())]
                (let [#_"Object" n (ß matchNumber(s))]
                    (when (nil? n)
                        (throw (NumberFormatException. (ß "Invalid number: " + s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"String" token, #_"int" offset, #_"int" length, #_"int" base]
        (when (ß token.length() != offset + length)
            (throw (IllegalArgumentException. (ß "Invalid unicode character: \\" + token)))
        )
        (let [#_"int" uc 0]
            (loop-when-recur [(§ var #_"int" i offset)] (ß i < offset + length) [(§ ass i (ß i + 1))]
                (let [#_"int" d (ß Character.digit(token.charAt(i), base))]
                    (when (ß d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + token.charAt(i))))
                    )
                    (§ ass uc (ß uc * base + d))
                )
            )
            (ß (char) uc)
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"PushbackReader" r, #_"int" initch, #_"int" base, #_"int" length, #_"boolean" exact]
        (let [#_"int" uc (ß Character.digit(initch, base))]
            (when (ß uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) initch)))
            )
            (let [#_"int" i 1]
                (loop-when-recur [(ß )] (ß i < length) [(§ ass i (ß i + 1))]
                    (let [#_"int" ch (ß read1(r))]
                        (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                            (ß unread(r, ch))
                            (§ break )
                        )
                        (let [#_"int" d (ß Character.digit(ch, base))]
                            (when (ß d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ch)))
                            )
                            (§ ass uc (ß uc * base + d))
                        )
                    )
                )
                (when (ß i != length && exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)))
                )
                uc
            )
        )
    )

    (§ defn- #_"Object" interpretToken [#_"String" s, #_"Resolver" resolver]
        (cond (ß s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß s.equals("true"))
            (do
                (§ return (ß RT.T))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß RT.F))
            )
        )
        (let [#_"Object" ret nil]
            (§ ass ret (ß matchSymbol(s, resolver)))
            (when (some? ret)
                (§ return ret)
            )

            (throw (ß Util.runtimeException("Invalid token: " + s)))
        )
    )

    (§ defn- #_"Object" matchSymbol [#_"String" s, #_"Resolver" resolver]
        (let [#_"Matcher" m (ß symbolPat.matcher(s))]
            (when (ß m.matches())
                (let [#_"int" gc (ß m.groupCount())]
                    (let [#_"String" ns (ß m.group(1))]
                        (let [#_"String" name (ß m.group(2))]
                            (when (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß s.startsWith("::"))
                                (let [#_"Symbol" ks (ß Symbol.intern(s.substring(2)))]
                                    (if (some? resolver)
                                        (do
                                            (§ let [#_"Symbol" nsym]
                                                (if (ß ks.ns != nil)
                                                    (do
                                                        (§ ass nsym (ß resolver.resolveAlias(Symbol.intern(ks.ns))))
                                                    )
                                                    (do
                                                        (§ ass nsym (ß resolver.currentNS()))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? nsym)
                                                    (do
                                                        (§ return (ß Keyword.intern(nsym.name, ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" kns]
                                                (if (ß ks.ns != nil)
                                                    (do
                                                        (§ ass kns (ß Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns))))
                                                    )
                                                    (do
                                                        (§ ass kns (ß Compiler.currentNS()))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? kns)
                                                    (do
                                                        (§ return (ß Keyword.intern(kns.name.name, ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" isKeyword (ß (s.charAt(0) == \:))]
                                (let [#_"Symbol" sym (ß Symbol.intern(s.substring(isKeyword ? 1 :or 0)))]
                                    (when isKeyword
                                        (§ return (ß Keyword.intern(sym)))
                                    )
                                    (§ return sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- #_"Object" matchNumber [#_"String" s]
        (let [#_"Matcher" m (ß intPat.matcher(s))]
            (when (ß m.matches())
                (when (ß m.group(2) != nil)
                    (when (ß m.group(8) != nil)
                        (§ return (ß BigInt.ZERO))
                    )
                    (§ return (ß Numbers.num(0)))
                )
                (let [#_"boolean" negate (ß m.group(1).equals("-"))]
                    (§ let [#_"String" n]
                        (let [#_"int" radix 10]
                            (cond (some? (§ ass n (ß m.group(3))))
                                (do
                                    (§ ass radix 10)
                                )
                                (some? (§ ass n (ß m.group(4))))
                                (do
                                    (§ ass radix 16)
                                )
                                (some? (§ ass n (ß m.group(5))))
                                (do
                                    (§ ass radix 8)
                                )
                                (some? (§ ass n (ß m.group(7))))
                                (do
                                    (§ ass radix (ß Integer.parseInt(m.group(6))))
                                )
                            )
                            (when (nil? n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" bn (ß new BigInteger(n, radix))]
                                (when negate
                                    (§ ass bn (ß bn.negate()))
                                )
                                (when (ß m.group(8) != nil)
                                    (§ return (ß BigInt.fromBigInteger(bn)))
                                )
                                (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
                            )
                        )
                    )
                )
            )
            (§ ass m (ß floatPat.matcher(s)))
            (when (ß m.matches())
                (when (ß m.group(4) != nil)
                    (§ return (ß new BigDecimal(m.group(1))))
                )
                (§ return (ß Double.parseDouble(s)))
            )
            (§ ass m (ß ratioPat.matcher(s)))
            (when (ß m.matches())
                (let [#_"String" numerator (ß m.group(1))]
                    (when (ß numerator.startsWith("+"))
                        (§ ass numerator (ß numerator.substring(1)))
                    )
                    (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- #_"IFn" getMacro [#_"int" ch]
        (when (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- #_"boolean" isMacro [#_"int" ch]
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- #_"boolean" isTerminatingMacro [#_"int" ch]
        (ß (ch != \# && ch != \' && ch != \% && isMacro(ch)))
    )

    #_stateless
    (class-ns RegexReader (§ extends AFn)
        (§ def #_"LispReader'StringReader" stringrdr (LispReader'StringReader.))

        #_method
        (§ defn #_"Object" invoke [#_"RegexReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"StringBuilder" sb (StringBuilder.)]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(§ var #_"int" ch (ß read1(r)))] (ß ch != \") [(§ ass ch (ß read1(r)))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading regex")))
                        )
                        (ß sb.append((char) ch))
                        (when (ß ch == \\) ;; escape
                            (§ ass ch (ß read1(r)))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading regex")))
                            )
                            (ß sb.append((char) ch))
                        )
                    )
                    (ß Pattern.compile(sb.toString()))
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'StringReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'StringReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"StringBuilder" sb (StringBuilder.)]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(§ var #_"int" ch (ß read1(r)))] (ß ch != \") [(§ ass ch (ß read1(r)))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading string")))
                        )
                        (when (ß ch == \\) ;; escape
                            (§ ass ch (ß read1(r)))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading string")))
                            )
                            (§ switch ch
                                (§ case \t)
                                (do
                                    (§ ass ch (ß \tab))
                                    (§ break )
                                )
                                (§ case \r)
                                (do
                                    (§ ass ch (ß \return))
                                    (§ break )
                                )
                                (§ case \n)
                                (do
                                    (§ ass ch (ß \newline))
                                    (§ break )
                                )
                                (§ case \\)
                                (do
                                    (§ break )
                                )
                                (§ case \") ;; oops! "
                                (do
                                    (§ break )
                                )
                                (§ case \b)
                                (do
                                    (§ ass ch (ß \backspace))
                                    (§ break )
                                )
                                (§ case \f)
                                (do
                                    (§ ass ch (ß \formfeed))
                                    (§ break )
                                )
                                (§ case \u)
                                (do
                                    (§ ass ch (ß read1(r)))
                                    (when (ß Character.digit(ch, 16) == -1)
                                        (throw (ß Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)))
                                    )
                                    (§ ass ch (ß readUnicodeChar((PushbackReader) r, ch, 16, 4, true)))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (if (ß Character.isDigit(ch))
                                        (do
                                            (§ ass ch (ß readUnicodeChar((PushbackReader) r, ch, 8, 3, false)))
                                            (when (ß ch > 0377)
                                                (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                            )
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Unsupported escape character: \\" + (char) ch)))
                                        )
                                    )
                                    (§ break )
                                )
                            )
                        )
                        (ß sb.append((char) ch))
                    )
                    (ß sb.toString())
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'CommentReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'CommentReader" this, #_"Object" reader, #_"Object" semicolon, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"Reader" r (ß (Reader) reader)]
                (§ let [#_"int" ch]
                    (§ loop
                        (§ ass ch (ß read1(r)))
                        (§ recur-if (ch != -1 && ch != \newline && ch != \return))
                    )
                    r
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'DiscardReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'DiscardReader" this, #_"Object" reader, #_"Object" underscore, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))
                r
            )
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    #_stateless
    (class-ns LispReader'NamespaceMapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'NamespaceMapReader" this, #_"Object" reader, #_"Object" colon, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"boolean" auto false]
                    (let [#_"int" autoChar (ß read1(r))]
                        (if (ß autoChar == \:)
                            (do
                                (§ ass auto true)
                            )
                            (do
                                (ß unread(r, autoChar))
                            )
                        )

                        (let [#_"Object" sym nil]
                            (let [#_"int" nextChar (ß read1(r))]
                                (cond (ß isWhitespace(nextChar)) ;; the #:: { } case or an error
                                    (do
                                        (if auto
                                            (do
                                                (while (ß isWhitespace(nextChar))
                                                    (§ ass nextChar (ß read1(r)))
                                                )
                                                (when (ß nextChar != \{)
                                                    (ß unread(r, nextChar))
                                                    (throw (ß Util.runtimeException("Namespaced map must specify a namespace")))
                                                )
                                            )
                                            (do
                                                (ß unread(r, nextChar))
                                                (throw (ß Util.runtimeException("Namespaced map must specify a namespace")))
                                            )
                                        )
                                    )
                                    (ß nextChar != \{) ;; #:foo { } or #::foo { }
                                    (do
                                        (ß unread(r, nextChar))
                                        (§ ass sym (ß read(r, true, nil, false, opts, pendingForms)))
                                        (§ ass nextChar (ß read1(r)))
                                        (while (ß isWhitespace(nextChar))
                                            (§ ass nextChar (ß read1(r)))
                                        )
                                    )
                                )
                                (when (ß nextChar != \{)
                                    (throw (ß Util.runtimeException("Namespaced map must specify a map")))
                                )

                                ;; Resolve autoresolved ns
                                (§ let [#_"String" ns]
                                    (cond auto
                                        (do
                                            (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                                                (cond (nil? sym)
                                                    (do
                                                        (if (some? resolver)
                                                            (do
                                                                (§ ass ns (ß resolver.currentNS().name))
                                                            )
                                                            (do
                                                                (§ ass ns (ß Compiler.currentNS().getName().getName()))
                                                            )
                                                        )
                                                    )
                                                    (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                                                    (do
                                                        (throw (ß Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)))
                                                    )
                                                    :else
                                                    (do
                                                        (§ let [#_"Symbol" resolvedNS]
                                                            (if (some? resolver)
                                                                (do
                                                                    (§ ass resolvedNS (ß resolver.resolveAlias((Symbol) sym)))
                                                                )
                                                                (do
                                                                    (let [#_"Namespace" rns (ß Compiler.currentNS().lookupAlias((Symbol)sym))]
                                                                        (§ ass resolvedNS (ß (rns != nil) ? rns.getName() :or nil))
                                                                    )
                                                                )
                                                            )

                                                            (if (nil? resolvedNS)
                                                                (do
                                                                    (throw (ß Util.runtimeException("Unknown auto-resolved namespace alias: " + sym)))
                                                                )
                                                                (do
                                                                    (§ ass ns (ß resolvedNS.getName()))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                                        (do
                                            (throw (ß Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)))
                                        )
                                        :else
                                        (do
                                            (§ ass ns (ß ((Symbol)sym).getName()))
                                        )
                                    )

                                    ;; Read map
                                    (let [#_"List" kvs (ß readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))]
                                        (when (ß (kvs.size() & 1) == 1)
                                            (throw (ß Util.runtimeException("Namespaced map literal must contain an even number of forms")))
                                        )

                                        ;; Construct output map
                                        (let [#_"Object[]" a (ß new Object[kvs.size()])]
                                            (let [#_"Iterator" iter (ß kvs.iterator())]
                                                (loop-when-recur [(§ var #_"int" i 0)] (ß iter.hasNext()) [(§ ass i (ß i + 2))]
                                                    (let [#_"Object" key (ß iter.next())]
                                                        (let [#_"Object" val (ß iter.next())]
                                                            (cond (ß key instanceof Keyword)
                                                                (do
                                                                    (let [#_"Keyword" kw (ß (Keyword) key)]
                                                                        (cond (ß kw.getNamespace() == nil)
                                                                            (do
                                                                                (§ ass key (ß Keyword.intern(ns, kw.getName())))
                                                                            )
                                                                            (ß kw.getNamespace().equals("_"))
                                                                            (do
                                                                                (§ ass key (ß Keyword.intern(nil, kw.getName())))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (ß key instanceof Symbol)
                                                                (do
                                                                    (let [#_"Symbol" s (ß (Symbol) key)]
                                                                        (cond (ß s.getNamespace() == nil)
                                                                            (do
                                                                                (§ ass key (ß Symbol.intern(ns, s.getName())))
                                                                            )
                                                                            (ß s.getNamespace().equals("_"))
                                                                            (do
                                                                                (§ ass key (ß Symbol.intern(nil, s.getName())))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (§ ass (ß a[i]) key)
                                                            (§ ass (ß a[i + 1]) val)
                                                        )
                                                    )
                                                )
                                                (ß RT.map(a))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'SymbolicValueReader (§ extends AFn)
        (§ def #_"IPersistentMap" specials (ß PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        )))

        #_method
        (§ defn #_"Object" invoke [#_"LispReader'SymbolicValueReader" this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (when (ß !(o instanceof Symbol))
                        (throw (ß Util.runtimeException("Invalid token: ##" + o)))
                    )
                    (when (ß !(specials.containsKey(o)))
                        (throw (ß Util.runtimeException("Unknown symbolic value: ##" + o)))
                    )

                    (ß specials.valAt(o))
                )
            )
        )
    )

    (class-ns WrappingReader (§ extends AFn)
        (§ init
            (§ field #_"Symbol" sym nil)
        )

        (§ constructor #_"WrappingReader" WrappingReader [#_"Symbol" sym]
            (let [this (ß super())]
                (§ ass (ß this.sym) sym)
                this
            )
        )

        #_method
        (§ defn #_"Object" invoke [#_"WrappingReader" this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(sym, o))
                )
            )
        )
    )

    (class-ns DeprecatedWrappingReader (§ extends AFn)
        (§ init
            (§ field #_"Symbol" sym nil)
            (§ field #_"String" macro nil)
        )

        (§ constructor #_"DeprecatedWrappingReader" DeprecatedWrappingReader [#_"Symbol" sym, #_"String" macro]
            (let [this (ß super())]
                (§ ass (ß this.sym) sym)
                (§ ass (ß this.macro) macro)
                this
            )
        )

        #_method
        (§ defn #_"Object" invoke [#_"DeprecatedWrappingReader" this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (ß System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead"))
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(sym, o))
                )
            )
        )
    )

    #_stateless
    (class-ns VarReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"VarReader" this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(THE_VAR, o))
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'DispatchReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'DispatchReader" this, #_"Object" reader, #_"Object" hash, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"int" ch (ß read1((Reader) reader))]
                (when (ß ch == -1)
                    (throw (ß Util.runtimeException("EOF while reading character")))
                )
                (let [#_"IFn" fn (ß dispatchMacros[ch])]
                    ;; Try the ctor reader first
                    (when (nil? fn)
                        (ß unread((PushbackReader) reader, ch))
                        (§ ass pendingForms (ß ensurePending(pendingForms)))
                        (let [#_"Object" result (ß ctorReader.invoke(reader, ch, opts, pendingForms))]
                            (if (some? result)
                                (do
                                    (§ return result)
                                )
                                (do
                                    (throw (ß Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))))
                                )
                            )
                        )
                    )
                    (ß fn.invoke(reader, ch, opts, pendingForms))
                )
            )
        )
    )

    (§ defn #_"Symbol" garg [#_"int" n]
        (ß Symbol.intern(nil, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#"))
    )

    #_stateless
    (class-ns FnReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"FnReader" this, #_"Object" reader, #_"Object" lparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (when (ß ARG_ENV.deref() != nil)
                    (throw (ß new IllegalStateException("Nested #()s are not allowed")))
                )
                (try
                    (ß Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY)))
                    (ß unread(r, \())
                    (let [#_"Object" form (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                            (let [#_"PersistentTreeMap" argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
                                (let [#_"ISeq" rargs (ß argsyms.rseq())]
                                    (when (some? rargs)
                                        (let [#_"int" higharg (ß (Integer) ((Map.Entry) rargs.first()).getKey())]
                                            (when (ß higharg > 0)
                                                (loop-when-recur [(§ var #_"int" i 1)] (ß i <= higharg) [(§ ass i (ß i + 1))]
                                                    (let [#_"Object" sym (ß argsyms.valAt(i))]
                                                        (when (nil? sym)
                                                            (§ ass sym (ß garg(i)))
                                                        )
                                                        (§ ass args (ß args.cons(sym)))
                                                    )
                                                )
                                            )
                                            (let [#_"Object" restsym (ß argsyms.valAt(-1))]
                                                (when (some? restsym)
                                                    (§ ass args (ß args.cons(Compiler._AMP_)))
                                                    (§ ass args (ß args.cons(restsym)))
                                                )
                                            )
                                        )
                                    )
                                    (ß RT.list(Compiler.FN, args, form))
                                )
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn #_"Symbol" registerArg [#_"int" n]
        (let [#_"PersistentTreeMap" argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
            (when (nil? argsyms)
                (throw (ß new IllegalStateException("arg literal not in #()")))
            )
            (let [#_"Symbol" ret (ß (Symbol) argsyms.valAt(n))]
                (when (nil? ret)
                    (§ ass ret (ß garg(n)))
                    (ß ARG_ENV.set(argsyms.assoc(n, ret)))
                )
                ret
            )
        )
    )

    #_stateless
    (class-ns ArgReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"ArgReader" this, #_"Object" reader, #_"Object" pct, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (when (ß ARG_ENV.deref() == nil)
                    (§ return (ß interpretToken(readToken(r, \%), nil)))
                )
                (let [#_"int" ch (ß read1(r))]
                    (ß unread(r, ch))
                    ;; % alone is first arg
                    (when (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (§ return (ß registerArg(1)))
                    )
                    (let [#_"Object" n (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (when (ß n.equals(Compiler._AMP_))
                            (§ return (ß registerArg(-1)))
                        )
                        (when (ß !(n instanceof Number))
                            (throw (ß new IllegalStateException("arg literal must be %, %& or %integer")))
                        )
                        (ß registerArg(((Number) n).intValue()))
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'MetaReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'MetaReader" this, #_"Object" reader, #_"Object" caret, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (§ ass line (ß ((LineNumberingPushbackReader) r).getLineNumber()))
                            (§ ass column (ß ((LineNumberingPushbackReader) r).getColumnNumber()-1))
                        )
                        (§ ass pendingForms (ß ensurePending(pendingForms)))
                        (let [#_"Object" meta (ß read(r, true, nil, true, opts, pendingForms))]
                            (cond (ß meta instanceof Symbol || meta instanceof String)
                                (do
                                    (§ ass meta (ß RT.map(RT.TAG_KEY, meta)))
                                )
                                (ß meta instanceof Keyword)
                                (do
                                    (§ ass meta (ß RT.map(meta, RT.T)))
                                )
                                (ß !(meta instanceof IPersistentMap))
                                (do
                                    (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                                )
                            )

                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (if (ß o instanceof IMeta)
                                    (do
                                        (when (ß line != -1 && o instanceof ISeq)
                                            (§ ass meta (ß ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column)))
                                        )
                                        (when (ß o instanceof IReference)
                                            (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                                            (§ return o)
                                        )
                                        (let [#_"Object" ometa (ß RT.meta(o))]
                                            (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(meta)))] (some? s) [(§ ass s (ß s.next()))]
                                                (let [#_"IMapEntry" kv (ß (IMapEntry) s.first())]
                                                    (§ ass ometa (ß RT.assoc(ometa, kv.getKey(), kv.getValue())))
                                                )
                                            )
                                            (ß ((IObj) o).withMeta((IPersistentMap) ometa))
                                        )
                                    )
                                    (do
                                        (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns SyntaxQuoteReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"SyntaxQuoteReader" this, #_"Object" reader, #_"Object" backquote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (try
                    (ß Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY)))

                    (let [#_"Object" form (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (ß syntaxQuote(form))
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )

        (§ defn #_"Object" syntaxQuote [#_"Object" form]
            (§ let [#_"Object" ret]
                (cond (ß Compiler.isSpecial(form))
                    (do
                        (§ ass ret (ß RT.list(Compiler.QUOTE, form)))
                    )
                    (ß form instanceof Symbol)
                    (do
                        (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                            (let [#_"Symbol" sym (ß (Symbol) form)]
                                (cond (ß sym.ns == nil && sym.name.endsWith("#"))
                                    (do
                                        (let [#_"IPersistentMap" gmap (ß (IPersistentMap) GENSYM_ENV.deref())]
                                            (when (nil? gmap)
                                                (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                            )
                                            (let [#_"Symbol" gs (ß (Symbol) gmap.valAt(sym))]
                                                (when (nil? gs)
                                                    (ß GENSYM_ENV.set(gmap.assoc(sym, (§ ass gs (ß Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__"))))))
                                                )
                                                (§ ass sym gs)
                                            )
                                        )
                                    )
                                    (ß sym.ns == nil && sym.name.endsWith("."))
                                    (do
                                        (let [#_"Symbol" csym (ß Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1)))]
                                            (if (some? resolver)
                                                (do
                                                    (let [#_"Symbol" rc (ß resolver.resolveClass(csym))]
                                                        (when (some? rc)
                                                            (§ ass csym rc)
                                                        )
                                                    )
                                                )
                                                (do
                                                    (§ ass csym (ß Compiler.resolveSymbol(csym)))
                                                )
                                            )
                                            (§ ass sym (ß Symbol.intern(nil, csym.name.concat("."))))
                                        )
                                    )
                                    (ß sym.ns == nil && sym.name.startsWith("."))
                                    (do
                                        ;; Simply quote method names.
                                    )
                                    (some? resolver)
                                    (do
                                        (let [#_"Symbol" nsym nil]
                                            (when (ß sym.ns != nil)
                                                (let [#_"Symbol" alias (ß Symbol.intern(nil, sym.ns))]
                                                    (§ ass nsym (ß resolver.resolveClass(alias)))
                                                    (when (nil? nsym)
                                                        (§ ass nsym (ß resolver.resolveAlias(alias)))
                                                    )
                                                )
                                            )
                                            (cond (some? nsym)
                                                (do
                                                    ;; Classname/foo -> package.qualified.Classname/foo
                                                    (§ ass sym (ß Symbol.intern(nsym.name, sym.name)))
                                                )
                                                (ß sym.ns == nil)
                                                (do
                                                    (let [#_"Symbol" rsym (ß resolver.resolveClass(sym))]
                                                        (when (nil? rsym)
                                                            (§ ass rsym (ß resolver.resolveVar(sym)))
                                                        )
                                                        (if (some? rsym)
                                                            (do
                                                                (§ ass sym rsym)
                                                            )
                                                            (do
                                                                (§ ass sym (ß Symbol.intern(resolver.currentNS().name, sym.name)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            ;; leave alone if qualified
                                        )
                                    )
                                    :else
                                    (do
                                        (let [#_"Object" maybeClass nil]
                                            (when (ß sym.ns != nil)
                                                (§ ass maybeClass (ß Compiler.currentNS().getMapping(Symbol.intern(nil, sym.ns))))
                                            )
                                            (if (ß maybeClass instanceof Class)
                                                (do
                                                    ;; Classname/foo -> package.qualified.Classname/foo
                                                    (§ ass sym (ß Symbol.intern(((Class)maybeClass).getName(), sym.name)))
                                                )
                                                (do
                                                    (§ ass sym (ß Compiler.resolveSymbol(sym)))
                                                )
                                            )
                                        )
                                    )
                                )
                                (§ ass ret (ß RT.list(Compiler.QUOTE, sym)))
                            )
                        )
                    )
                    (ß isUnquote(form))
                    (do
                        (§ return (ß RT.second(form)))
                    )
                    (ß isUnquoteSplicing(form))
                    (do
                        (throw (IllegalStateException. "splice not in list"))
                    )
                    (ß form instanceof IPersistentCollection)
                    (do
                        (cond (ß form instanceof IRecord)
                            (do
                                (§ ass ret form)
                            )
                            (ß form instanceof IPersistentMap)
                            (do
                                (let [#_"IPersistentVector" keyvals (ß flattenMap(form))]
                                    (§ ass ret (ß RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq()))))))
                                )
                            )
                            (ß form instanceof IPersistentVector)
                            (do
                                (§ ass ret (ß RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq()))))))
                            )
                            (ß form instanceof IPersistentSet)
                            (do
                                (§ ass ret (ß RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq()))))))
                            )
                            (ß form instanceof ISeq || form instanceof IPersistentList)
                            (do
                                (let [#_"ISeq" seq (ß RT.seq(form))]
                                    (if (nil? seq)
                                        (do
                                            (§ ass ret (ß RT.cons(LIST, nil)))
                                        )
                                        (do
                                            (§ ass ret (ß RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq)))))
                                        )
                                    )
                                )
                            )
                            :else
                            (do
                                (throw (UnsupportedOperationException. "Unknown Collection type"))
                            )
                        )
                    )
                    (ß form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String)
                    (do
                        (§ ass ret form)
                    )
                    :else
                    (do
                        (§ ass ret (ß RT.list(Compiler.QUOTE, form)))
                    )
                )

                (when (ß form instanceof IObj && RT.meta(form) != nil)
                    ;; filter line and column numbers
                    (let [#_"IPersistentMap" newMeta (ß ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY))]
                        (when (ß newMeta.count() > 0)
                            (§ return (ß RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))))
                        )
                    )
                )
                ret
            )
        )

        (§ defn- #_"ISeq" sqExpandList [#_"ISeq" seq]
            (let [#_"PersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß )] (some? seq) [(§ ass seq (ß seq.next()))]
                    (let [#_"Object" item (ß seq.first())]
                        (cond (ß isUnquote(item))
                            (do
                                (§ ass ret (ß ret.cons(RT.list(LIST, RT.second(item)))))
                            )
                            (ß isUnquoteSplicing(item))
                            (do
                                (§ ass ret (ß ret.cons(RT.second(item))))
                            )
                            :else
                            (do
                                (§ ass ret (ß ret.cons(RT.list(LIST, syntaxQuote(item)))))
                            )
                        )
                    )
                )
                (ß ret.seq())
            )
        )

        (§ defn- #_"IPersistentVector" flattenMap [#_"Object" form]
            (let [#_"IPersistentVector" keyvals (ß PersistentVector.EMPTY)]
                (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(form)))] (some? s) [(§ ass s (ß s.next()))]
                    (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                        (§ ass keyvals (ß (IPersistentVector) keyvals.cons(e.key())))
                        (§ ass keyvals (ß (IPersistentVector) keyvals.cons(e.val())))
                    )
                )
                keyvals
            )
        )
    )

    (§ defn #_"boolean" isUnquoteSplicing [#_"Object" form]
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING))
    )

    (§ defn #_"boolean" isUnquote [#_"Object" form]
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE))
    )

    #_stateless
    (class-ns UnquoteReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"UnquoteReader" this, #_"Object" reader, #_"Object" comma, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (§ ass pendingForms (ß ensurePending(pendingForms)))
                    (if (ß ch == \@)
                        (do
                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (ß RT.list(UNQUOTE_SPLICING, o))
                            )
                        )
                        (do
                            (ß unread(r, ch))
                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (ß RT.list(UNQUOTE, o))
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'CharacterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'CharacterReader" this, #_"Object" reader, #_"Object" backslash, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (let [#_"String" token (ß readToken(r, (char) ch))]
                        (cond (ß token.length() == 1)
                            (do
                                (§ return (ß Character.valueOf(token.charAt(0))))
                            )
                            (ß token.equals("newline"))
                            (do
                                (§ return (ß \newline))
                            )
                            (ß token.equals("space"))
                            (do
                                (§ return (ß \space))
                            )
                            (ß token.equals("tab"))
                            (do
                                (§ return (ß \tab))
                            )
                            (ß token.equals("backspace"))
                            (do
                                (§ return (ß \backspace))
                            )
                            (ß token.equals("formfeed"))
                            (do
                                (§ return (ß \formfeed))
                            )
                            (ß token.equals("return"))
                            (do
                                (§ return (ß \return))
                            )
                            (ß token.startsWith("u"))
                            (do
                                (let [#_"char" c (ß (char) readUnicodeChar(token, 1, 4, 16))]
                                    (when (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                                        (throw (ß Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))))
                                    )
                                    (§ return c)
                                )
                            )
                            (ß token.startsWith("o"))
                            (do
                                (let [#_"int" len (ß token.length() - 1)]
                                    (when (ß len > 3)
                                        (throw (ß Util.runtimeException("Invalid octal escape sequence length: " + len)))
                                    )
                                    (let [#_"int" uc (ß readUnicodeChar(token, 1, len, 8))]
                                        (when (ß uc > 0377)
                                            (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                        (§ return (ß (char) uc))
                                    )
                                )
                            )
                        )
                        (throw (ß Util.runtimeException("Unsupported character: \\" + token)))
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'ListReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'ListReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (§ ass line (ß ((LineNumberingPushbackReader) r).getLineNumber()))
                            (§ ass column (ß ((LineNumberingPushbackReader) r).getColumnNumber()-1))
                        )
                        (let [#_"List" list (ß readDelimitedList(\), r, true, opts, ensurePending(pendingForms)))]
                            (when (ß list.isEmpty())
                                (§ return (ß PersistentList.EMPTY))
                            )
                            (let [#_"IObj" s (ß (IObj) PersistentList.create(list))]
                                (if (ß line != -1)
                                    (do
                                        (ß s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column)))
                                    )
                                    (do
                                        s
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns EvalReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"EvalReader" this, #_"Object" reader, #_"Object" eq, #_"Object" opts, #_"Object" pendingForms]
            (when (ß !RT.booleanCast(RT.READEVAL.deref()))
                (throw (ß Util.runtimeException("EvalReader not allowed when *read-eval* is false.")))
            )

            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (cond (ß o instanceof Symbol)
                        (do
                            (ß RT.classForName(o.toString()))
                        )
                        (ß o instanceof IPersistentList)
                        (do
                            (let [#_"Symbol" fs (ß (Symbol) RT.first(o))]
                                (when (ß fs.equals(THE_VAR))
                                    (let [#_"Symbol" vs (ß (Symbol) RT.second(o))]
                                        (§ return (ß RT.var(vs.ns, vs.name)))
                                    )
                                )
                                (when (ß fs.name.endsWith("."))
                                    (let [#_"Object[]" args (ß RT.toArray(RT.next(o)))]
                                        (§ return (ß Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)))
                                    )
                                )
                                (when (ß Compiler.namesStaticMember(fs))
                                    (let [#_"Object[]" args (ß RT.toArray(RT.next(o)))]
                                        (§ return (ß Reflector.invokeStaticMethod(fs.ns, fs.name, args)))
                                    )
                                )
                                (let [#_"Object" v (ß Compiler.maybeResolveIn(Compiler.currentNS(), fs))]
                                    (when (ß v instanceof Var)
                                        (§ return (ß ((IFn) v).applyTo(RT.next(o))))
                                    )
                                    (throw (ß Util.runtimeException("Can't resolve " + fs)))
                                )
                            )
                        )
                        :else
                        (do
                            (throw (IllegalArgumentException. "Unsupported #= form"))
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'VectorReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'VectorReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts, ensurePending(pendingForms))))
            )
        )
    )

    #_stateless
    (class-ns LispReader'MapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'MapReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object[]" a (ß readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)).toArray())]
                    (when (ß (a.length & 1) == 1)
                        (throw (ß Util.runtimeException("Map literal must contain an even number of forms")))
                    )
                    (ß RT.map(a))
                )
            )
        )
    )

    #_stateless
    (class-ns LispReader'SetReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'SetReader" this, #_"Object" reader, #_"Object" leftbracket, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts, ensurePending(pendingForms))))
            )
        )
    )

    #_stateless
    (class-ns LispReader'UnmatchedDelimiterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'UnmatchedDelimiterReader" this, #_"Object" reader, #_"Object" rightdelim, #_"Object" opts, #_"Object" pendingForms]
            (throw (ß Util.runtimeException("Unmatched delimiter: " + rightdelim)))
        )
    )

    #_stateless
    (class-ns LispReader'UnreadableReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"LispReader'UnreadableReader" this, #_"Object" reader, #_"Object" leftangle, #_"Object" opts, #_"Object" pendingForms]
            (throw (ß Util.runtimeException("Unreadable form")))
        )
    )

    ;; Sentinel values for reading lists
    (§ def- #_"Object" READ_EOF (Object.))
    (§ def- #_"Object" READ_FINISHED (Object.))

    (§ defn #_"List" readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" opts, #_"Object" pendingForms]
        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
            (let [#_"ArrayList" a (ArrayList.)]
                (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                    (while true
                        (let [#_"Object" form (ß read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver))]
                            (cond (ß form == READ_EOF)
                                (do
                                    (if (ß firstline < 0)
                                        (do
                                            (throw (ß Util.runtimeException("EOF while reading")))
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                        )
                                    )
                                )
                                (ß form == READ_FINISHED)
                                (do
                                    (§ return a)
                                )
                            )

                            (ß a.add(form))
                        )
                    )
                )
            )
        )
    )

    #_stateless
    (class-ns CtorReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [#_"CtorReader" this, #_"Object" reader, #_"Object" firstChar, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (§ ass pendingForms (ß ensurePending(pendingForms)))
                (let [#_"Object" name (ß read(r, true, nil, false, opts, pendingForms))]
                    (when (ß !(name instanceof Symbol))
                        (throw (RuntimeException. "Reader tag must be a symbol"))
                    )
                    (let [#_"Symbol" sym (ß (Symbol)name)]
                        (let [#_"Object" form (ß read(r, true, nil, true, opts, pendingForms))]
                            (if (ß isPreserveReadCond(opts) || RT.suppressRead())
                                (do
                                    (ß TaggedLiteral.create(sym, form))
                                )
                                (do
                                    (ß sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms))
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"Object" readTagged [#_"CtorReader" this, #_"Object" o, #_"Symbol" tag, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"ILookup" data_readers (ß (ILookup)RT.DATA_READERS.deref())]
                (let [#_"IFn" data_reader (ß (IFn)RT.get(data_readers, tag))]
                    (when (nil? data_reader)
                        (§ ass data_readers (ß (ILookup)RT.DEFAULT_DATA_READERS.deref()))
                        (§ ass data_reader (ß (IFn)RT.get(data_readers, tag)))
                        (when (nil? data_reader)
                            (let [#_"IFn" default_reader (ß (IFn)RT.DEFAULT_DATA_READER_FN.deref())]
                                (if (some? default_reader)
                                    (do
                                        (§ return (ß default_reader.invoke(tag, o)))
                                    )
                                    (do
                                        (throw (ß new RuntimeException("No reader function for tag " + tag.toString())))
                                    )
                                )
                            )
                        )
                    )

                    (ß data_reader.invoke(o))
                )
            )
        )

        #_method
        (§ defn- #_"Object" readRecord [#_"CtorReader" this, #_"Object" form, #_"Symbol" recordName, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"boolean" readeval (ß RT.booleanCast(RT.READEVAL.deref()))]
                (when (ß !readeval)
                    (throw (ß Util.runtimeException("Record construction syntax can only be used when *read-eval* == true")))
                )

                (let [#_"Class" recordClass (ß RT.classForNameNonLoading(recordName.toString()))]
                    (let [#_"boolean" shortForm true]
                        (cond (ß form instanceof IPersistentMap)
                            (do
                                (§ ass shortForm false)
                            )
                            (ß form instanceof IPersistentVector)
                            (do
                                (§ ass shortForm true)
                            )
                            :else
                            (do
                                (throw (ß Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\"")))
                            )
                        )

                        (let [#_"Object" ret nil]
                            (let [#_"Constructor[]" allctors (ß ((Class)recordClass).getConstructors())]
                                (if shortForm
                                    (do
                                        (let [#_"IPersistentVector" recordEntries (ß (IPersistentVector)form)]
                                            (let [#_"boolean" ctorFound false]
                                                (doseq [#_"Constructor" ctor allctors]
                                                    (when (ß ctor.getParameterTypes().length == recordEntries.count())
                                                        (§ ass ctorFound true)
                                                    )
                                                )

                                                (when (ß !ctorFound)
                                                    (throw (ß Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count())))
                                                )

                                                (§ ass ret (ß Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries))))
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"IPersistentMap" vals (ß (IPersistentMap)form)]
                                            (loop-when-recur [(§ var #_"ISeq" s (ß RT.keys(vals)))] (some? s) [(§ ass s (ß s.next()))]
                                                (when (ß !(s.first() instanceof Keyword))
                                                    (throw (ß Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString())))
                                                )
                                            )
                                            (§ ass ret (ß Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ array vals ))))
                                        )
                                    )
                                )

                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" isPreserveReadCond [#_"Object" opts]
        (if (ß RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap)
            (do
                (let [#_"Object" readCond (ß ((IPersistentMap) opts).valAt(OPT_READ_COND))]
                    (ß COND_PRESERVE.equals(readCond))
                )
            )
            (do
                false
            )
        )
    )

    #_stateless
    (class-ns ConditionalReader (§ extends AFn)
        (§ def- #_"Object" READ_STARTED (Object.))
        (§ def #_"Keyword" DEFAULT_FEATURE (ß Keyword.intern(nil, "default")))
        (§ def #_"IPersistentSet" RESERVED_FEATURES (ß RT.set(Keyword.intern(nil, "else"), Keyword.intern(nil, "none"))))

        (§ defn #_"boolean" hasFeature [#_"Object" feature, #_"Object" opts]
            (when (ß !(feature instanceof Keyword))
                (throw (ß Util.runtimeException("Feature should be a keyword: " + feature)))
            )

            (when (ß DEFAULT_FEATURE.equals(feature))
                (§ return true)
            )

            (let [#_"IPersistentSet" custom (ß (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES))]
                (ß (custom != nil && custom.contains(feature)))
            )
        )

        (§ defn #_"Object" readCondDelimited [#_"PushbackReader" r, #_"boolean" splicing, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"Object" result READ_STARTED]
                (§ let [#_"Object" form] ;; The most recently ready form
                    (let [#_"boolean" toplevel (ß (pendingForms == nil))]
                        (§ ass pendingForms (ß ensurePending(pendingForms)))

                        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
                            (while true
                                (when (ß result == READ_STARTED)
                                    ;; Read the next feature
                                    (§ ass form (ß read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, nil)))

                                    (cond (ß form == READ_EOF)
                                        (do
                                            (if (ß firstline < 0)
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                )
                                            )
                                        )
                                        (ß form == READ_FINISHED)
                                        (do
                                            (§ break ) ;; read-cond form is done
                                        )
                                    )

                                    (when (ß RESERVED_FEATURES.contains(form))
                                        (throw (ß Util.runtimeException("Feature name " + form + " is reserved.")))
                                    )

                                    (when (ß hasFeature(form, opts))
                                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                        (§ ass form (ß read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref())))

                                        (cond (ß form == READ_EOF)
                                            (do
                                                (if (ß firstline < 0)
                                                    (do
                                                        (throw (ß Util.runtimeException("EOF while reading")))
                                                    )
                                                    (do
                                                        (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                    )
                                                )
                                            )
                                            (ß form == READ_FINISHED)
                                            (do
                                                (if (ß firstline < 0)
                                                    (do
                                                        (throw (ß Util.runtimeException("read-cond requires an even number of forms.")))
                                                    )
                                                    (do
                                                        (throw (ß Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms")))
                                                    )
                                                )
                                            )
                                            :else
                                            (do
                                                (§ ass result form)
                                            )
                                        )
                                    )
                                )

                                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                                (try
                                    (ß Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T)))
                                    (§ ass form (ß read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref())))

                                    (cond (ß form == READ_EOF)
                                        (do
                                            (if (ß firstline < 0)
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                )
                                            )
                                        )
                                        (ß form == READ_FINISHED)
                                        (do
                                            (§ break )
                                        )
                                    )
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                            )

                            (when (ß result == READ_STARTED) ;; no features matched
                                (§ return r)
                            )

                            (if splicing
                                (do
                                    (when (ß !(result instanceof List))
                                        (throw (ß Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List")))
                                    )

                                    (when toplevel
                                        (throw (ß Util.runtimeException("Reader conditional splicing not allowed at the top level.")))
                                    )

                                    (ß ((List)pendingForms).addAll(0, (List)result))

                                    r
                                )
                                (do
                                    result
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn- #_"void" checkConditionalAllowed [#_"Object" opts]
            (let [#_"IPersistentMap" mopts (ß (IPersistentMap)opts)]
                (when (ß !(opts != nil && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND)))))
                    (throw (ß Util.runtimeException("Conditional read not allowed")))
                )
                nil
            )
        )

        #_method
        (§ defn #_"Object" invoke [#_"ConditionalReader" this, #_"Object" reader, #_"Object" mode, #_"Object" opts, #_"Object" pendingForms]
            (ß checkConditionalAllowed(opts))

            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )

                    (let [#_"boolean" splicing false]
                        (when (ß ch == \@)
                            (§ ass splicing true)
                            (§ ass ch (ß read1(r)))
                        )

                        (while (ß isWhitespace(ch))
                            (§ ass ch (ß read1(r)))
                        )

                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading character")))
                        )

                        (when (ß ch != \()
                            (throw (ß Util.runtimeException("read-cond body must be a list")))
                        )

                        (try
                            (ß Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T)))

                            (if (ß isPreserveReadCond(opts))
                                (do
                                    (let [#_"IFn" listReader (ß getMacro(ch))] ;; should always be a list
                                        (let [#_"Object" form (ß listReader.invoke(r, ch, opts, ensurePending(pendingForms)))]
                                            (ß ReaderConditional.create(form, splicing))
                                        )
                                    )
                                )
                                (do
                                    (ß readCondDelimited(r, splicing, opts, pendingForms))
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(class-ns LockingTransaction
    (§ def #_"int" RETRY_LIMIT 10000)
    (§ def #_"int" LOCK_WAIT_MSECS 100)
    (§ def #_"long" BARGE_WAIT_NANOS (ß 10 * 1000000))

    (§ def #_"int" RUNNING 0)
    (§ def #_"int" COMMITTING 1)
    (§ def #_"int" RETRY 2)
    (§ def #_"int" KILLED 3)
    (§ def #_"int" COMMITTED 4)

    (§ def #_"ThreadLocal<LockingTransaction>" transaction (ß new ThreadLocal<LockingTransaction>()))

    #_stateless
    (class-ns RetryEx (§ extends Error)
    )

    #_stateless
    (class-ns AbortException (§ extends Exception)
    )

    (class-ns Info
        (§ init
            (§ field #_"AtomicInteger" status nil)
            (§ field #_"long" startPoint 0)
            (§ field #_"CountDownLatch" latch nil)
        )

        (§ constructor #_"Info" Info [#_"int" status, #_"long" startPoint]
            (let [this (ß super())]
                (§ ass (ß this.status) (AtomicInteger. status))
                (§ ass (ß this.startPoint) startPoint)
                (§ ass (ß this.latch) (CountDownLatch. 1))
                this
            )
        )

        #_method
        (§ defn #_"boolean" running [#_"Info" this]
            (let [#_"int" s (ß status.get())]
                (ß (s == RUNNING || s == COMMITTING))
            )
        )
    )

    (class-ns CFn
        (§ init
            (§ field #_"IFn" fn nil)
            (§ field #_"ISeq" args nil)
        )

        (§ constructor #_"CFn" CFn [#_"IFn" fn, #_"ISeq" args]
            (let [this (ß super())]
                (§ ass (ß this.fn) fn)
                (§ ass (ß this.args) args)
                this
            )
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (§ def- #_"AtomicLong" lastPoint (AtomicLong.))

    (§ init
        (§ field #_"Info" info nil)
        (§ field #_"long" readPoint 0)
        (§ field #_"long" startPoint 0)
        (§ field #_"long" startTime 0)

        (§ field #_"RetryEx" retryex (RetryEx.))
        (§ field #_"ArrayList<Agent.Action>" actions (ß new ArrayList<Agent.Action>()))
        (§ field #_"HashMap<Ref, Object>" vals (ß new HashMap<Ref, Object>()))
        (§ field #_"HashSet<Ref>" sets (ß new HashSet<Ref>()))
        (§ field #_"TreeMap<Ref, ArrayList<CFn>>" commutes (ß new TreeMap<Ref, ArrayList<CFn>>()))

        (§ field #_"HashSet<Ref>" ensures (ß new HashSet<Ref>())) ;; all hold readLock
    )

    #_method
    (§ defn #_"void" getReadPoint [#_"LockingTransaction" this]
        (§ ass readPoint (ß lastPoint.incrementAndGet()))
        nil
    )

    #_method
    (§ defn #_"long" getCommitPoint [#_"LockingTransaction" this]
        (ß lastPoint.incrementAndGet())
    )

    #_method
    (§ defn #_"void" stop [#_"LockingTransaction" this, #_"int" status]
        (when (some? info)
            (§ sync info
                (ß info.status.set(status))
                (ß info.latch.countDown())
            )
            (§ ass info nil)
            (ß vals.clear())
            (ß sets.clear())
            (ß commutes.clear())
        )
        nil
    )

    #_method
    (§ defn #_"void" tryWriteLock [#_"LockingTransaction" this, #_"Ref" ref]
        (try
            (when (ß !ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
                (throw retryex)
            )
            (catch InterruptedException e
                (throw retryex)
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" lock [#_"LockingTransaction" this, #_"Ref" ref]
        ;; can't upgrade readLock, so release it
        (ß releaseIfEnsured(ref))

        (let [#_"boolean" unlocked true]
            (try
                (ß tryWriteLock(ref))
                (§ ass unlocked false)

                (when (ß ref.tvals != nil && ref.tvals.point > readPoint)
                    (throw retryex)
                )
                (let [#_"Info" refinfo (ß ref.tinfo)]
                    ;; write lock conflict
                    (when (ß refinfo != nil && refinfo != info && refinfo.running())
                        (when (ß !barge(refinfo))
                            (ß ref.lock.writeLock().unlock())
                            (§ ass unlocked true)
                            (§ return (ß blockAndBail(refinfo)))
                        )
                    )
                    (§ ass (ß ref.tinfo) info)
                    (ß (ref.tvals == nil) ? nil :or ref.tvals.val)
                )
                (finally
                    (when (ß !unlocked)
                        (ß ref.lock.writeLock().unlock())
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" blockAndBail [#_"LockingTransaction" this, #_"Info" refinfo]
        ;; stop prior to blocking
        (ß stop(RETRY))
        (try
            (ß refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
            (catch InterruptedException e
                ;; ignore
            )
        )
        (throw retryex)
    )

    #_method
    (§ defn- #_"void" releaseIfEnsured [#_"LockingTransaction" this, #_"Ref" ref]
        (when (ß ensures.contains(ref))
            (ß ensures.remove(ref))
            (ß ref.lock.readLock().unlock())
        )
        nil
    )

    #_method
    (§ defn #_"void" abort [#_"LockingTransaction" this] (§ throws AbortException)
        (ß stop(KILLED))
        (throw (AbortException.))
    )

    #_method
    (§ defn- #_"boolean" bargeTimeElapsed [#_"LockingTransaction" this]
        (ß (System.nanoTime() - startTime > BARGE_WAIT_NANOS))
    )

    #_method
    (§ defn- #_"boolean" barge [#_"LockingTransaction" this, #_"Info" refinfo]
        (let [#_"boolean" barged false]
            ;; if this transaction is older, try to abort the other
            (when (ß bargeTimeElapsed() && startPoint < refinfo.startPoint)
                (§ ass barged (ß refinfo.status.compareAndSet(RUNNING, KILLED)))
                (when barged
                    (ß refinfo.latch.countDown())
                )
            )
            barged
        )
    )

    (§ defn #_"LockingTransaction" getEx []
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (when (ß t == nil || t.info == nil)
                (throw (IllegalStateException. "No transaction running"))
            )
            t
        )
    )

    (§ defn #_"boolean" isRunning []
        (ß (getRunning() != nil))
    )

    (§ defn #_"LockingTransaction" getRunning []
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (when (ß t == nil || t.info == nil)
                (§ return nil)
            )
            t
        )
    )

    (§ defn #_"Object" runInTransaction [#_"Callable" fn] (§ throws Exception)
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (§ let [#_"Object" ret]
                (if (nil? t)
                    (do
                        (ß transaction.set(§ ass t (LockingTransaction.)))
                        (try
                            (§ ass ret (ß t.run(fn)))
                            (finally
                                (ß transaction.remove())
                            )
                        )
                    )
                    (do
                        (if (ß t.info != nil)
                            (do
                                (§ ass ret (ß fn.call()))
                            )
                            (do
                                (§ ass ret (ß t.run(fn)))
                            )
                        )
                    )
                )

                ret
            )
        )
    )

    (class-ns Notify
        (§ init
            (§ field #_"Ref" ref nil)
            (§ field #_"Object" oldval nil)
            (§ field #_"Object" newval nil)
        )

        (§ constructor #_"Notify" Notify [#_"Ref" ref, #_"Object" oldval, #_"Object" newval]
            (let [this (ß super())]
                (§ ass (ß this.ref) ref)
                (§ ass (ß this.oldval) oldval)
                (§ ass (ß this.newval) newval)
                this
            )
        )
    )

    #_method
    (§ defn #_"Object" run [#_"LockingTransaction" this, #_"Callable" fn] (§ throws Exception)
        (let [#_"boolean" done false]
            (let [#_"Object" ret nil]
                (let [#_"ArrayList<Ref>" locked (ß new ArrayList<Ref>())]
                    (let [#_"ArrayList<Notify>" notify (ß new ArrayList<Notify>())]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß !done && i < RETRY_LIMIT) [(§ ass i (ß i + 1))]
                            (try
                                (ß getReadPoint())
                                (when (ß i == 0)
                                    (§ ass startPoint readPoint)
                                    (§ ass startTime (ß System.nanoTime()))
                                )
                                (§ ass info (ß new Info(RUNNING, startPoint)))
                                (§ ass ret (ß fn.call()))
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß info.status.compareAndSet(RUNNING, COMMITTING))
                                    (doseq [#_"Map.Entry<Ref, ArrayList<CFn>>" (ß e commutes.entrySet())]
                                        (let [#_"Ref" ref (ß e.getKey())]
                                            (when (ß sets.contains(ref))
                                                (§ continue )
                                            )

                                            (let [#_"boolean" wasEnsured (ß ensures.contains(ref))]
                                                ;; can't upgrade readLock, so release it
                                                (ß releaseIfEnsured(ref))
                                                (ß tryWriteLock(ref))
                                                (ß locked.add(ref))
                                                (when (ß wasEnsured && ref.tvals != nil && ref.tvals.point > readPoint)
                                                    (throw retryex)
                                                )

                                                (let [#_"Info" refinfo (ß ref.tinfo)]
                                                    (when (ß refinfo != nil && refinfo != info && refinfo.running())
                                                        (when (ß !barge(refinfo))
                                                            (throw retryex)
                                                        )
                                                    )
                                                    (let [#_"Object" val (ß (ref.tvals == nil) ? nil :or ref.tvals.val)]
                                                        (ß vals.put(ref, val))
                                                        (doseq [#_"CFn" f (ß e.getValue())]
                                                            (ß vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ref sets]
                                        (ß tryWriteLock(ref))
                                        (ß locked.add(ref))
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                                        (let [#_"Ref" ref (ß e.getKey())]
                                            (ß ref.validate(ref.getValidator(), e.getValue()))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" commitPoint (ß getCommitPoint())]
                                        (doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                                            (let [#_"Ref" ref (ß e.getKey())]
                                                (let [#_"Object" oldval (ß (ref.tvals == nil) ? nil :or ref.tvals.val)]
                                                    (let [#_"Object" newval (ß e.getValue())]
                                                        (let [#_"int" hcount (ß ref.histCount())]
                                                            (cond (ß ref.tvals == nil)
                                                                (do
                                                                    (§ ass (ß ref.tvals) (ß new Ref.TVal(newval, commitPoint)))
                                                                )
                                                                (ß (ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory)
                                                                (do
                                                                    (§ ass (ß ref.tvals) (ß new Ref.TVal(newval, commitPoint, ref.tvals)))
                                                                    (ß ref.faults.set(0))
                                                                )
                                                                :else
                                                                (do
                                                                    (§ ass (ß ref.tvals) (ß ref.tvals.next))
                                                                    (§ ass (ß ref.tvals.val) newval)
                                                                    (§ ass (ß ref.tvals.point) commitPoint)
                                                                )
                                                            )
                                                            (when (ß ref.getWatches().count() > 0)
                                                                (ß notify.add(new Notify(ref, oldval, newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (§ ass done true)
                                        (ß info.status.set(COMMITTED))
                                    )
                                )
                                (catch RetryEx retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [(§ var #_"int" k (ß locked.size() - 1))] (ß k >= 0) [(§ ass k (ß k - 1))]
                                        (ß locked.get(k).lock.writeLock().unlock())
                                    )
                                    (ß locked.clear())
                                    (doseq [#_"Ref" r ensures]
                                        (ß r.lock.readLock().unlock())
                                    )
                                    (ß ensures.clear())
                                    (ß stop(done ? COMMITTED :or RETRY))
                                    (try
                                        (when done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" n notify]
                                                (ß n.ref.notifyWatches(n.oldval, n.newval))
                                            )
                                            (doseq [#_"Agent.Action" action actions]
                                                (ß Agent.dispatchAction(action))
                                            )
                                        )
                                        (finally
                                            (ß notify.clear())
                                            (ß actions.clear())
                                        )
                                    )
                                )
                            )
                        )
                        (when (ß !done)
                            (throw (ß Util.runtimeException("Transaction failed after reaching retry limit")))
                        )
                        ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" enqueue [#_"LockingTransaction" this, #_"Agent.Action" action]
        (ß actions.add(action))
        nil
    )

    #_method
    (§ defn #_"Object" doGet [#_"LockingTransaction" this, #_"Ref" ref]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß vals.containsKey(ref))
            (§ return (ß vals.get(ref)))
        )
        (try
            (ß ref.lock.readLock().lock())
            (when (ß ref.tvals == nil)
                (throw (ß new IllegalStateException(ref.toString() + " is unbound.")))
            )
            (let [(§ var #_"Ref.TVal" ver (ß ref.tvals))]
                (§ loop
                    (when (ß ver.point <= readPoint)
                        (§ return (ß ver.val))
                    )
                    (§ recur-if ((§ ass ver (ß ver.prior)) != ref.tvals))
                )
            )
            (finally
                (ß ref.lock.readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (ß ref.faults.incrementAndGet())
        (throw retryex)
    )

    #_method
    (§ defn #_"Object" doSet [#_"LockingTransaction" this, #_"Ref" ref, #_"Object" val]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß commutes.containsKey(ref))
            (throw (IllegalStateException. "Can't set after commute"))
        )
        (when (ß !sets.contains(ref))
            (ß sets.add(ref))
            (ß lock(ref))
        )
        (ß vals.put(ref, val))
        val
    )

    #_method
    (§ defn #_"void" doEnsure [#_"LockingTransaction" this, #_"Ref" ref]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß ensures.contains(ref))
            (§ return nil)
        )
        (ß ref.lock.readLock().lock())

        ;; someone completed a write after our snapshot
        (when (ß ref.tvals != nil && ref.tvals.point > readPoint)
            (ß ref.lock.readLock().unlock())
            (throw retryex)
        )

        (let [#_"Info" refinfo (ß ref.tinfo)]
            ;; writer exists
            (if (ß refinfo != nil && refinfo.running())
                (do
                    (ß ref.lock.readLock().unlock())

                    (when (ß refinfo != info) ;; not us, ensure is doomed
                        (ß blockAndBail(refinfo))
                    )
                )
                (do
                    (ß ensures.add(ref))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" doCommute [#_"LockingTransaction" this, #_"Ref" ref, #_"IFn" fn, #_"ISeq" args]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß !vals.containsKey(ref))
            (let [#_"Object" val nil]
                (try
                    (ß ref.lock.readLock().lock())
                    (§ ass val (ß (ref.tvals == nil) ? nil :or ref.tvals.val))
                    (finally
                        (ß ref.lock.readLock().unlock())
                    )
                )
                (ß vals.put(ref, val))
            )
        )
        (let [#_"ArrayList<CFn>" fns (ß commutes.get(ref))]
            (when (nil? fns)
                (ß commutes.put(ref, (§ ass fns (ß new ArrayList<CFn>()))))
            )
            (ß fns.add(new CFn(fn, args)))
            (let [#_"Object" ret (ß fn.applyTo(RT.cons(vals.get(ref), args)))]
                (ß vals.put(ref, ret))
                ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (§ def- #_"int" CHUNK_SIZE 32)

    #_private
    (§ interface LongRange'BoundsCheck
        #_abstract
        (#_"boolean" exceededBounds [#_"LongRange'BoundsCheck" this, #_"long" val])
    )

    (§ defn- #_"LongRange'BoundsCheck" positiveStep [#_"long" end]
        (§ reify LongRange'BoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"LongRange'BoundsCheck" this, #_"long" val]
                (ß (val >= end))
            )
        )
    )

    (§ defn- #_"LongRange'BoundsCheck" negativeStep [#_"long" end]
        (§ reify LongRange'BoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"LongRange'BoundsCheck" this, #_"long" val]
                (ß (val <= end))
            )
        )
    )

    (§ init
        ;; Invariants guarantee this is never an empty or infinite seq
        (§ field #_"long" start 0)
        (§ field #_"long" end 0)
        (§ field #_"long" step 0)
        (§ field #_"LongRange'BoundsCheck" boundsCheck nil)

        #_volatile
        (§ field- #_"LongChunk" _chunk nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _chunkNext nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"LongRange" LongRange [#_"long" start, #_"long" end, #_"long" step, #_"LongRange'BoundsCheck" boundsCheck]
        (let [this (ß super())]
            (§ ass (ß this.start) start)
            (§ ass (ß this.end) end)
            (§ ass (ß this.step) step)
            (§ ass (ß this.boundsCheck) boundsCheck)
            this
        )
    )

    (§ constructor- #_"LongRange" LongRange [#_"long" start, #_"long" end, #_"long" step, #_"LongRange'BoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (ß super())]
            (§ ass (ß this.start) start)
            (§ ass (ß this.end) end)
            (§ ass (ß this.step) step)
            (§ ass (ß this.boundsCheck) boundsCheck)
            (§ ass (ß this._chunk) chunk)
            (§ ass (ß this._chunkNext) chunkNext)
            this
        )
    )

    (§ constructor- #_"LongRange" LongRange [#_"IPersistentMap" meta, #_"long" start, #_"long" end, #_"long" step, #_"LongRange'BoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (ß super(meta))]
            (§ ass (ß this.start) start)
            (§ ass (ß this.end) end)
            (§ ass (ß this.step) step)
            (§ ass (ß this.boundsCheck) boundsCheck)
            (§ ass (ß this._chunk) chunk)
            (§ ass (ß this._chunkNext) chunkNext)
            this
        )
    )

    (§ defn #_"ISeq" create [#_"long" end]
        (when (ß end > 0)
            (§ return (ß new LongRange(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn #_"ISeq" create [#_"long" start, #_"long" end]
        (when (ß start >= end)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new LongRange(start, end, 1, positiveStep(end)))
    )

    (§ defn #_"ISeq" create [#_"long" start, #_"long" end, #_"long" step]
        (cond (ß step > 0)
            (do
                (when (ß end <= start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß new LongRange(start, end, step, positiveStep(end)))
            )
            (ß step < 0)
            (do
                (when (ß end >= start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß new LongRange(start, end, step, negativeStep(end)))
            )
            :else
            (do
                (when (ß end == start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß Repeat.create(start))
            )
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"LongRange" this, #_"IPersistentMap" meta]
        (when (ß meta == _meta)
            (§ return this)
        )
        (ß new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext))
    )

    #_method
    (§ defn #_"Object" first [#_"LongRange" this]
        start
    )

    #_method
    (§ defn #_"void" forceChunk [#_"LongRange" this]
        (when (some? _chunk)
            (§ return nil)
        )

        (§ let [#_"long" count]
            (try
                (§ ass count (ß rangeCount(start, end, step)))
                (catch ArithmeticException e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (§ ass count (ß steppingCount(start, end, step)))
                )
            )

            (cond (ß count > CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" nextStart (ß start + (step * CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass _chunkNext (ß new LongRange(nextStart, end, step, boundsCheck)))
                        (§ ass _chunk (ß new LongChunk(start, step, CHUNK_SIZE)))
                    )
                )
                :else ;; last chunk
                (do
                    (§ ass _chunk (ß new LongChunk(start, step, (int) count))) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"ISeq" next [#_"LongRange" this]
        (when (some? _next)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"LongChunk" smallerChunk (ß _chunk.dropFirst())]
                (§ ass _next (ß new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext)))
                (§ return (ß _next))
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"LongRange" this]
        (ß forceChunk())
        (ß _chunk)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"LongRange" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"LongRange" this]
        (ß forceChunk())
        (when (nil? _chunkNext)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" steppingCount [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        (let [#_"long" count 1]
            (let [#_"long" s start]
                (while (ß count <= CHUNK_SIZE)
                    (try
                        (§ ass s (ß Numbers.add(s, step)))
                        (if (ß boundsCheck.exceededBounds(s))
                            (do
                                (§ break )
                            )
                            (do
                                (§ ass count (ß count + 1))
                            )
                        )
                        (catch ArithmeticException e
                            (§ break )
                        )
                    )
                )
                count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" rangeCount [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (ß Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step)
    )

    #_method
    (§ defn #_"int" count [#_"LongRange" this]
        (try
            (let [#_"long" c (ß rangeCount(start, end, step))]
                (if (ß c > Integer.MAX_VALUE)
                    (do
                        (ß Numbers.throwIntOverflow())
                    )
                    (do
                        (ß (int) c)
                    )
                )
            )
            (catch ArithmeticException e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" iter (ß this.iterator())]
                    (let [#_"long" count 0]
                        (while (ß iter.hasNext())
                            (ß iter.next())
                            (§ ass count (ß count + 1))
                        )

                        (if (ß count > Integer.MAX_VALUE)
                            (do
                                (ß Numbers.throwIntOverflow())
                            )
                            (do
                                (ß (int)count)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongRange" this, #_"IFn" f]
        (let [#_"Object" acc start]
            (let [#_"long" i (ß start + step)]
                (while (ß !boundsCheck.exceededBounds(i))
                    (§ ass acc (ß f.invoke(acc, i)))
                    (when (ß acc instanceof Reduced)
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (§ ass i (ß i + step))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongRange" this, #_"IFn" f, #_"Object" val]
        (let [#_"Object" acc val]
            (let [#_"long" i start]
                (§ loop
                    (§ ass acc (ß f.invoke(acc, i)))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (§ ass i (ß i + step))
                    (§ recur-if (!boundsCheck.exceededBounds(i)))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"LongRange" this]
        (LongRangeIterator.)
    )

    #_non-static
    (class-ns LongRangeIterator (§ implements Iterator)
        (§ init
            (§ field- #_"long" next 0)
            (§ field- #_"boolean" hasNext false)
        )

        (§ constructor #_"LongRangeIterator" LongRangeIterator []
            (let [this (ß super())]
                (§ ass (ß this.next) start)
                (§ ass (ß this.hasNext) true)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"LongRangeIterator" this]
            hasNext
        )

        #_method
        (§ defn #_"Object" next [#_"LongRangeIterator" this]
            (if hasNext
                (do
                    (let [#_"long" ret next]
                        (try
                            (§ ass next (ß Numbers.add(next, step)))
                            (§ ass hasNext (ß !boundsCheck.exceededBounds(next)))
                            (catch ArithmeticException e
                                (§ ass hasNext false)
                            )
                        )
                        ret
                    )
                )
                (do
                    (throw (NoSuchElementException.))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [#_"LongRangeIterator" this]
            (throw (UnsupportedOperationException.))
        )
    )

    #_private
    (class-ns LongChunk (§ implements IChunk)
        (§ init
            (§ field #_"long" start 0)
            (§ field #_"long" step 0)
            (§ field #_"int" count 0)
        )

        (§ constructor #_"LongChunk" LongChunk [#_"long" start, #_"long" step, #_"int" count]
            (let [this (ß super())]
                (§ ass (ß this.start) start)
                (§ ass (ß this.step) step)
                (§ ass (ß this.count) count)
                this
            )
        )

        #_method
        (§ defn #_"long" first [#_"LongChunk" this]
            start
        )

        #_method
        (§ defn #_"Object" nth [#_"LongChunk" this, #_"int" i]
            (ß start + (i * step))
        )

        #_method
        (§ defn #_"Object" nth [#_"LongChunk" this, #_"int" i, #_"Object" notFound]
            (when (ß i >= 0 && i < count)
                (§ return (ß start + (i * step)))
            )
            notFound
        )

        #_method
        (§ defn #_"int" count [#_"LongChunk" this]
            count
        )

        #_method
        (§ defn #_"LongChunk" dropFirst [#_"LongChunk" this]
            (when (ß count <= 1)
                (throw (IllegalStateException. "dropFirst of empty chunk"))
            )
            (ß new LongChunk(start + step, step, count - 1))
        )

        #_method
        (§ defn #_"Object" reduce [#_"LongChunk" this, #_"IFn" f, #_"Object" init]
            (let [#_"long" x start]
                (let [#_"Object" ret init]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < count) [(§ ass i (ß i + 1))]
                        (§ ass ret (ß f.invoke(ret, x)))
                        (when (ß RT.isReduced(ret))
                            (§ return ret)
                        )
                        (§ ass x (ß x + step))
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (§ defn #_"MapEntry" create [#_"Object" key, #_"Object" val]
        (ß new MapEntry(key, val))
    )

    (§ init
        (§ field #_"Object" _key nil)
        (§ field #_"Object" _val nil)
    )

    (§ constructor #_"MapEntry" MapEntry [#_"Object" key, #_"Object" val]
        (let [this (ß super())]
            (§ ass (ß this._key) key)
            (§ ass (ß this._val) val)
            this
        )
    )

    #_method
    (§ defn #_"Object" key [#_"MapEntry" this]
        (ß _key)
    )

    #_method
    (§ defn #_"Object" val [#_"MapEntry" this]
        (ß _val)
    )

    #_method
    (§ defn #_"Object" getKey [#_"MapEntry" this]
        (ß key())
    )

    #_method
    (§ defn #_"Object" getValue [#_"MapEntry" this]
        (ß val())
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ interface MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns MethodImplCache
    (class-ns Entry
        (§ init
            (§ field #_"Class" c nil)
            (§ field #_"IFn" fn nil)
        )

        (§ constructor #_"Entry" Entry [#_"Class" c, #_"IFn" fn]
            (let [this (ß super())]
                (§ ass (ß this.c) c)
                (§ ass (ß this.fn) fn)
                this
            )
        )
    )

    (§ init
        (§ field #_"IPersistentMap" protocol nil)
        (§ field #_"Keyword" methodk nil)
        (§ field #_"int" shift 0)
        (§ field #_"int" mask 0)
        (§ field #_"Object[]" table nil) ;; [class, entry. class, entry ...]
        (§ field #_"Map" map nil)

        (§ field #_"Entry" mre nil)
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" protocol, #_"Keyword" methodk]
        (let [this (ß this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY))]
            this
        )
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"int" shift, #_"int" mask, #_"Object[]" table]
        (let [this (ß super())]
            (§ ass (ß this.protocol) protocol)
            (§ ass (ß this.methodk) methodk)
            (§ ass (ß this.shift) shift)
            (§ ass (ß this.mask) mask)
            (§ ass (ß this.table) table)
            (§ ass (ß this.map) nil)
            this
        )
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"Map" map]
        (let [this (ß super())]
            (§ ass (ß this.protocol) protocol)
            (§ ass (ß this.methodk) methodk)
            (§ ass (ß this.shift) 0)
            (§ ass (ß this.mask) 0)
            (§ ass (ß this.table) nil)
            (§ ass (ß this.map) map)
            this
        )
    )

    #_method
    (§ defn #_"IFn" fnFor [#_"MethodImplCache" this, #_"Class" c]
        (let [#_"Entry" last mre]
            (when (ß last != nil && last.c == c)
                (§ return (ß last.fn))
            )
            (ß findFnFor(c))
        )
    )

    #_method
    (§ defn #_"IFn" findFnFor [#_"MethodImplCache" this, #_"Class" c]
        (if (some? map)
            (do
                (let [#_"Entry" e (ß (Entry) map.get(c))]
                    (§ ass mre e)
                    (ß (e != nil) ? e.fn :or nil)
                )
            )
            (do
                (let [#_"int" idx (ß ((Util.hash(c) >> shift) & mask) << 1)]
                    (when (ß idx < table.length && table[idx] == c)
                        (let [#_"Entry" e (ß ((Entry) table[idx + 1]))]
                            (§ ass mre e)
                            (§ return (ß (e != nil) ? e.fn :or nil))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" assoc (ß RT.var("cloiure.core", "assoc")))
    (§ def #_"Var" dissoc (ß RT.var("cloiure.core", "dissoc")))
    (§ def #_"Var" isa (ß RT.var("cloiure.core", "isa?")))
    (§ def #_"Var" parents (ß RT.var("cloiure.core", "parents")))

    (§ init
        (§ field #_"IFn" dispatchFn nil)
        (§ field #_"Object" defaultDispatchVal nil)
        (§ field #_"IRef" hierarchy nil)
        (§ field #_"String" name nil)
        (§ field #_"ReentrantReadWriteLock" rw nil)

        #_volatile
        (§ field #_"IPersistentMap" methodTable nil)
        #_volatile
        (§ field #_"IPersistentMap" preferTable nil)
        #_volatile
        (§ field #_"IPersistentMap" methodCache nil)
        #_volatile
        (§ field #_"Object" cachedHierarchy nil)
    )

    (§ constructor #_"MultiFn" MultiFn [#_"String" name, #_"IFn" dispatchFn, #_"Object" defaultDispatchVal, #_"IRef" hierarchy]
        (let [this (ß super())]
            (§ ass (ß this.rw) (ReentrantReadWriteLock.))
            (§ ass (ß this.name) name)
            (§ ass (ß this.dispatchFn) dispatchFn)
            (§ ass (ß this.defaultDispatchVal) defaultDispatchVal)
            (§ ass (ß this.methodTable) (ß PersistentHashMap.EMPTY))
            (§ ass (ß this.methodCache) (ß getMethodTable()))
            (§ ass (ß this.preferTable) (ß PersistentHashMap.EMPTY))
            (§ ass (ß this.hierarchy) hierarchy)
            (§ ass cachedHierarchy nil)
            this
        )
    )

    #_method
    (§ defn #_"MultiFn" reset [#_"MultiFn" this]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodTable (§ ass methodCache (§ ass preferTable (ß PersistentHashMap.EMPTY))))
            (§ ass cachedHierarchy nil)
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" addMethod [#_"MultiFn" this, #_"Object" dispatchVal, #_"IFn" method]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodTable (ß getMethodTable().assoc(dispatchVal, method)))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" removeMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodTable (ß getMethodTable().without(dispatchVal)))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" preferMethod [#_"MultiFn" this, #_"Object" dispatchValX, #_"Object" dispatchValY]
        (ß rw.writeLock().lock())
        (try
            (when (ß prefers(dispatchValY, dispatchValX))
                (throw (ß new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX))))
            )
            (§ ass preferTable (ß getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY))))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn- #_"boolean" prefers [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (let [#_"IPersistentSet" xprefs (ß (IPersistentSet) getPreferTable().valAt(x))]
            (when (ß xprefs != nil && xprefs.contains(y))
                (§ return true)
            )
            (loop-when-recur [(§ var #_"ISeq" ps (ß RT.seq(parents.invoke(y))))] (some? ps) [(§ ass ps (ß ps.next()))]
                (when (ß prefers(x, ps.first()))
                    (§ return true)
                )
            )
            (loop-when-recur [(§ var #_"ISeq" ps (ß RT.seq(parents.invoke(x))))] (some? ps) [(§ ass ps (ß ps.next()))]
                (when (ß prefers(ps.first(), y))
                    (§ return true)
                )
            )
            false
        )
    )

    #_method
    (§ defn- #_"boolean" isA [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (ß RT.booleanCast(isa.invoke(hierarchy.deref(), x, y)))
    )

    #_method
    (§ defn- #_"boolean" dominates [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (ß prefers(x, y) || isA(x, y))
    )

    #_method
    (§ defn- #_"IPersistentMap" resetCache [#_"MultiFn" this]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodCache (ß getMethodTable()))
            (§ ass cachedHierarchy (ß hierarchy.deref()))
            methodCache
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"IFn" getMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (when (ß cachedHierarchy != hierarchy.deref())
            (ß resetCache())
        )
        (let [#_"IFn" targetFn (ß (IFn) methodCache.valAt(dispatchVal))]
            (when (some? targetFn)
                (§ return targetFn)
            )
            (ß findAndCacheBestMethod(dispatchVal))
        )
    )

    #_method
    (§ defn- #_"IFn" getFn [#_"MultiFn" this, #_"Object" dispatchVal]
        (let [#_"IFn" targetFn (ß getMethod(dispatchVal))]
            (when (nil? targetFn)
                (throw (ß new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal))))
            )
            targetFn
        )
    )

    #_method
    (§ defn- #_"IFn" findAndCacheBestMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (ß rw.readLock().lock())
        (§ let [#_"Object" bestValue]
            (let [#_"IPersistentMap" mt methodTable]
                (let [#_"IPersistentMap" pt preferTable]
                    (let [#_"Object" ch cachedHierarchy]
                        (try
                            (let [(§ var #_"Map.Entry" bestEntry nil)]
                                (doseq [#_"Object" o (ß getMethodTable())]
                                    (let [(§ var #_"Map.Entry" e (ß (Map.Entry) o))]
                                        (when (ß isA(dispatchVal, e.getKey()))
                                            (when (ß bestEntry == nil || dominates(e.getKey(), bestEntry.getKey()))
                                                (§ ass bestEntry e)
                                            )
                                            (when (ß !dominates(bestEntry.getKey(), e.getKey()))
                                                (throw (ß new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey()))))
                                            )
                                        )
                                    )
                                )
                                (if (nil? bestEntry)
                                    (do
                                        (§ ass bestValue (ß methodTable.valAt(defaultDispatchVal)))
                                        (when (nil? bestValue)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (§ ass bestValue (ß bestEntry.getValue()))
                                    )
                                )
                            )
                            (finally
                                (ß rw.readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß rw.writeLock().lock())
                        (try
                            (if (ß mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
                                (do
                                    ;; place in cache
                                    (§ ass methodCache (ß methodCache.assoc(dispatchVal, bestValue)))
                                    (ß (IFn) bestValue)
                                )
                                (do
                                    (ß resetCache())
                                    (ß findAndCacheBestMethod(dispatchVal))
                                )
                            )
                            (finally
                                (ß rw.writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this]
        (ß getFn(dispatchFn.invoke()).invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1]
        (ß getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, (§ ass arg1 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2]
        (ß getFn(dispatchFn.invoke(arg1, arg2)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)), Util.ret1(arg2, (§ ass arg2 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)), Util.ret1(arg2, (§ ass arg2 nil)), Util.ret1(arg3, (§ ass arg3 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)),
                    Util.ret1(arg20, (§ ass arg20 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20, args)).
            invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)),
                    Util.ret1(arg20, (§ ass arg20 nil)),
                    args))
    )

    #_method
    (§ defn #_"IPersistentMap" getMethodTable [#_"MultiFn" this]
        methodTable
    )

    #_method
    (§ defn #_"IPersistentMap" getPreferTable [#_"MultiFn" this]
        preferTable
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (§ def- #_"int" seed 0)
    (§ def- #_"int" C1 0xcc9e2d51)
    (§ def- #_"int" C2 0x1b873593)

    (§ defn #_"int" hashInt [#_"int" input]
        (when (ß input == 0)
            (§ return 0)
        )
        (let [#_"int" k1 (ß mixK1(input))]
            (let [#_"int" h1 (ß mixH1(seed, k1))]
                (ß fmix(h1, 4))
            )
        )
    )

    (§ defn #_"int" hashLong [#_"long" input]
        (when (ß input == 0)
            (§ return 0)
        )
        (let [#_"int" low (ß (int) input)]
            (let [#_"int" high (ß (int) (input >>> 32))]
                (let [#_"int" k1 (ß mixK1(low))]
                    (let [#_"int" h1 (ß mixH1(seed, k1))]
                        (§ ass k1 (ß mixK1(high)))
                        (§ ass h1 (ß mixH1(h1, k1)))

                        (ß fmix(h1, 8))
                    )
                )
            )
        )
    )

    (§ defn #_"int" hashUnencodedChars [#_"CharSequence" input]
        (let [#_"int" h1 seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [(§ var #_"int" i 1)] (ß i < input.length()) [(§ ass i (ß i + 2))]
                (let [#_"int" k1 (ß input.charAt(i - 1) | (input.charAt(i) << 16))]
                    (§ ass k1 (ß mixK1(k1)))
                    (§ ass h1 (ß mixH1(h1, k1)))
                )
            )

            ;; deal with any remaining characters
            (when (ß (input.length() & 1) == 1)
                (let [#_"int" k1 (ß input.charAt(input.length() - 1))]
                    (§ ass k1 (ß mixK1(k1)))
                    (§ ass h1 (ß h1 :xor k1))
                )
            )

            (ß fmix(h1, 2 * input.length()))
        )
    )

    (§ defn #_"int" mixCollHash [#_"int" hash, #_"int" count]
        (let [#_"int" h1 seed]
            (let [#_"int" k1 (ß mixK1(hash))]
                (§ ass h1 (ß mixH1(h1, k1)))
                (ß fmix(h1, count))
            )
        )
    )

    (§ defn #_"int" hashOrdered [#_"Iterable" xs]
        (let [#_"int" n 0]
            (let [#_"int" hash 1]
                (doseq [#_"Object" x xs]
                    (§ ass hash (ß 31 * hash + Util.hasheq(x)))
                    (§ ass n (ß n + 1))
                )

                (ß mixCollHash(hash, n))
            )
        )
    )

    (§ defn #_"int" hashUnordered [#_"Iterable" xs]
        (let [#_"int" hash 0]
            (let [#_"int" n 0]
                (doseq [#_"Object" x xs]
                    (§ ass hash (ß hash + Util.hasheq(x)))
                    (§ ass n (ß n + 1))
                )

                (ß mixCollHash(hash, n))
            )
        )
    )

    (§ defn- #_"int" mixK1 [#_"int" k1]
        (§ ass k1 (ß k1 * C1))
        (§ ass k1 (ß Integer.rotateLeft(k1, 15)))
        (§ ass k1 (ß k1 * C2))
        k1
    )

    (§ defn- #_"int" mixH1 [#_"int" h1, #_"int" k1]
        (§ ass h1 (ß h1 :xor k1))
        (§ ass h1 (ß Integer.rotateLeft(h1, 13)))
        (§ ass h1 (ß h1 * 5 + 0xe6546b64))
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (§ defn- #_"int" fmix [#_"int" h1, #_"int" length]
        (§ ass h1 (ß h1 :xor length))
        (§ ass h1 (ß h1 :xor (h1 >>> 16)))
        (§ ass h1 (ß h1 * 0x85ebca6b))
        (§ ass h1 (ß h1 :xor (h1 >>> 13)))
        (§ ass h1 (ß h1 * 0xc2b2ae35))
        (§ ass h1 (ß h1 :xor (h1 >>> 16)))
        h1
    )
)
)

(java-ns cloiure.lang.Named

(§ interface Named
    #_abstract
    (#_"String" getNamespace [#_"Named" this])
    #_abstract
    (#_"String" getName [#_"Named" this])
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (§ def #_"ConcurrentHashMap<Symbol, Namespace>" namespaces (ß new ConcurrentHashMap<Symbol, Namespace>()))

    (§ init
        (§ field #_"Symbol" name nil)

        #_transient
        (§ field #_"AtomicReference<IPersistentMap>" mappings (ß new AtomicReference<IPersistentMap>()))
        #_transient
        (§ field #_"AtomicReference<IPersistentMap>" aliases (ß new AtomicReference<IPersistentMap>()))
    )

    (§ constructor #_"Namespace" Namespace [#_"Symbol" name]
        (let [this (ß super(name.meta()))]
            (§ ass (ß this.name) name)
            (ß mappings.set(RT.DEFAULT_IMPORTS))
            (ß aliases.set(RT.map()))
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Namespace" this]
        (ß name.toString())
    )

    (§ defn #_"ISeq" all []
        (ß RT.seq(namespaces.values()))
    )

    #_method
    (§ defn #_"Symbol" getName [#_"Namespace" this]
        name
    )

    #_method
    (§ defn #_"IPersistentMap" getMappings [#_"Namespace" this]
        (ß mappings.get())
    )

    #_method
    (§ defn #_"Var" intern [#_"Namespace" this, #_"Symbol" sym]
        (when (ß sym.ns != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (§ let [#_"Object" o]
                (let [#_"Var" v nil]
                    (while (nil? (§ ass o (ß map.valAt(sym))))
                        (when (nil? v)
                            (§ ass v (ß new Var(this, sym)))
                        )
                        (let [#_"IPersistentMap" newMap (ß map.assoc(sym, v))]
                            (ß mappings.compareAndSet(map, newMap))
                            (§ ass map (ß getMappings()))
                        )
                    )
                    (when (ß o instanceof Var && ((Var) o).ns == this)
                        (§ return (ß (Var) o))
                    )

                    (when (nil? v)
                        (§ ass v (ß new Var(this, sym)))
                    )

                    (ß warnOrFailOnReplace(sym, o, v))

                    (while (ß !mappings.compareAndSet(map, map.assoc(sym, v)))
                        (§ ass map (ß getMappings()))
                    )

                    v
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" warnOrFailOnReplace [#_"Namespace" this, #_"Symbol" sym, #_"Object" o, #_"Object" v]
        (when (ß o instanceof Var)
            (let [#_"Namespace" ns (ß ((Var)o).ns)]
                (when (ß ns == this || (v instanceof Var && ((Var)v).ns == RT.CLOIURE_NS))
                    (§ return nil)
                )
                (when (ß ns != RT.CLOIURE_NS)
                    (throw (IllegalStateException. (ß sym + " already refers to: " + o + " in namespace: " + name)))
                )
            )
        )
        (ß RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v))
        nil
    )

    #_method
    (§ defn #_"Object" reference [#_"Namespace" this, #_"Symbol" sym, #_"Object" val]
        (when (ß sym.ns != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (§ let [#_"Object" o]
                (while (nil? (§ ass o (ß map.valAt(sym))))
                    (let [#_"IPersistentMap" newMap (ß map.assoc(sym, val))]
                        (ß mappings.compareAndSet(map, newMap))
                        (§ ass map (ß getMappings()))
                    )
                )
                (when (ß o == val)
                    (§ return o)
                )

                (ß warnOrFailOnReplace(sym, o, val))

                (while (ß !mappings.compareAndSet(map, map.assoc(sym, val)))
                    (§ ass map (ß getMappings()))
                )

                val
            )
        )
    )

    (§ defn #_"boolean" areDifferentInstancesOfSameClassName [#_"Class" cls1, #_"Class" cls2]
        (ß (cls1 != cls2) && (cls1.getName().equals(cls2.getName())))
    )

    #_method
    (§ defn #_"Class" referenceClass [#_"Namespace" this, #_"Symbol" sym, #_"Class" val]
        (when (ß sym.ns != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (let [#_"Class" c (ß (Class) map.valAt(sym))]
                (while (ß (c == nil) || (areDifferentInstancesOfSameClassName(c, val)))
                    (let [#_"IPersistentMap" newMap (ß map.assoc(sym, val))]
                        (ß mappings.compareAndSet(map, newMap))
                        (§ ass map (ß getMappings()))
                        (§ ass c (ß (Class) map.valAt(sym)))
                    )
                )
                (when (ß c == val)
                    (§ return c)
                )

                (throw (IllegalStateException. (ß sym + " already refers to: " + c + " in namespace: " + name)))
            )
        )
    )

    #_method
    (§ defn #_"void" unmap [#_"Namespace" this, #_"Symbol" sym]
        (when (ß sym.ns != nil)
            (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (while (ß map.containsKey(sym))
                (let [#_"IPersistentMap" newMap (ß map.without(sym))]
                    (ß mappings.compareAndSet(map, newMap))
                    (§ ass map (ß getMappings()))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Class" importClass [#_"Namespace" this, #_"Symbol" sym, #_"Class" c]
        (ß referenceClass(sym, c))
    )

    #_method
    (§ defn #_"Class" importClass [#_"Namespace" this, #_"Class" c]
        (let [#_"String" n (ß c.getName())]
            (ß importClass(Symbol.intern(n.substring(n.lastIndexOf(\.) + 1)), c))
        )
    )

    #_method
    (§ defn #_"Var" refer [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (ß (Var) reference(sym, var))
    )

    (§ defn #_"Namespace" findOrCreate [#_"Symbol" name]
        (let [#_"Namespace" ns (ß namespaces.get(name))]
            (when (some? ns)
                (§ return ns)
            )
            (let [#_"Namespace" newns (Namespace. name)]
                (§ ass ns (ß namespaces.putIfAbsent(name, newns)))
                (ß (ns == nil) ? newns :or ns)
            )
        )
    )

    (§ defn #_"Namespace" remove [#_"Symbol" name]
        (when (ß name.equals(RT.CLOIURE_NS.name))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (ß namespaces.remove(name))
    )

    (§ defn #_"Namespace" find [#_"Symbol" name]
        (ß namespaces.get(name))
    )

    #_method
    (§ defn #_"Object" getMapping [#_"Namespace" this, #_"Symbol" name]
        (ß mappings.get().valAt(name))
    )

    #_method
    (§ defn #_"Var" findInternedVar [#_"Namespace" this, #_"Symbol" symbol]
        (let [#_"Object" o (ß mappings.get().valAt(symbol))]
            (when (ß o != nil && o instanceof Var && ((Var) o).ns == this)
                (§ return (ß (Var) o))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getAliases [#_"Namespace" this]
        (ß aliases.get())
    )

    #_method
    (§ defn #_"Namespace" lookupAlias [#_"Namespace" this, #_"Symbol" alias]
        (let [#_"IPersistentMap" map (ß getAliases())]
            (ß (Namespace) map.valAt(alias))
        )
    )

    #_method
    (§ defn #_"void" addAlias [#_"Namespace" this, #_"Symbol" alias, #_"Namespace" ns]
        (when (ß alias == nil || ns == nil)
            (throw (NullPointerException. "Expecting Symbol + Namespace"))
        )
        (let [#_"IPersistentMap" map (ß getAliases())]
            (while (ß !map.containsKey(alias))
                (let [#_"IPersistentMap" newMap (ß map.assoc(alias, ns))]
                    (ß aliases.compareAndSet(map, newMap))
                    (§ ass map (ß getAliases()))
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (ß !map.valAt(alias).equals(ns))
                (throw (ß new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" removeAlias [#_"Namespace" this, #_"Symbol" alias]
        (let [#_"IPersistentMap" map (ß getAliases())]
            (while (ß map.containsKey(alias))
                (let [#_"IPersistentMap" newMap (ß map.without(alias))]
                    (ß aliases.compareAndSet(map, newMap))
                    (§ ass map (ß getAliases()))
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

#_stateless
(class-ns Numbers
    (§ interface Ops
        #_abstract
        (#_"Ops" combine [#_"Ops" this, #_"Ops" y])
        #_abstract
        (#_"Ops" opsWith [#_"Ops" this, #_"LongOps" x])
        #_abstract
        (#_"Ops" opsWith [#_"Ops" this, #_"DoubleOps" x])
        #_abstract
        (#_"Ops" opsWith [#_"Ops" this, #_"RatioOps" x])
        #_abstract
        (#_"Ops" opsWith [#_"Ops" this, #_"BigIntOps" x])
        #_abstract
        (#_"Ops" opsWith [#_"Ops" this, #_"BigDecimalOps" x])
        #_abstract
        (#_"boolean" isZero [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"boolean" isPos [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"boolean" isNeg [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" add [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" addP [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" multiply [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" multiplyP [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" divide [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" quotient [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" remainder [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" equiv [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" lt [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" lte [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"boolean" gte [#_"Ops" this, #_"Number" x, #_"Number" y])
        #_abstract
        (#_"Number" negate [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" negateP [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" inc [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" incP [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" dec [#_"Ops" this, #_"Number" x])
        #_abstract
        (#_"Number" decP [#_"Ops" this, #_"Number" x])
    )

    #_stateless
    #_abstract
    (class-ns OpsP (§ implements Ops)
        #_method
        (§ defn #_"Number" addP [#_"OpsP" this, #_"Number" x, #_"Number" y]
            (ß add(x, y))
        )

        #_method
        (§ defn #_"Number" multiplyP [#_"OpsP" this, #_"Number" x, #_"Number" y]
            (ß multiply(x, y))
        )

        #_method
        (§ defn #_"Number" negateP [#_"OpsP" this, #_"Number" x]
            (ß negate(x))
        )

        #_method
        (§ defn #_"Number" incP [#_"OpsP" this, #_"Number" x]
            (ß inc(x))
        )

        #_method
        (§ defn #_"Number" decP [#_"OpsP" this, #_"Number" x]
            (ß dec(x))
        )
    )

    (§ defn #_"boolean" isZero [#_"Object" x]
        (ß ops(x).isZero((Number)x))
    )

    (§ defn #_"boolean" isPos [#_"Object" x]
        (ß ops(x).isPos((Number)x))
    )

    (§ defn #_"boolean" isNeg [#_"Object" x]
        (ß ops(x).isNeg((Number)x))
    )

    (§ defn #_"Number" minus [#_"Object" x]
        (ß ops(x).negate((Number)x))
    )

    (§ defn #_"Number" minusP [#_"Object" x]
        (ß ops(x).negateP((Number)x))
    )

    (§ defn #_"Number" inc [#_"Object" x]
        (ß ops(x).inc((Number)x))
    )

    (§ defn #_"Number" incP [#_"Object" x]
        (ß ops(x).incP((Number)x))
    )

    (§ defn #_"Number" dec [#_"Object" x]
        (ß ops(x).dec((Number)x))
    )

    (§ defn #_"Number" decP [#_"Object" x]
        (ß ops(x).decP((Number)x))
    )

    (§ defn #_"Number" add [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).add((Number)x, (Number)y))
    )

    (§ defn #_"Number" addP [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).addP((Number)x, (Number)y))
    )

    (§ defn #_"Number" minus [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (ß ops(x).combine(yops).add((Number)x, yops.negate((Number)y)))
        )
    )

    (§ defn #_"Number" minusP [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (let [#_"Number" negativeY (ß yops.negateP((Number) y))]
                (let [#_"Ops" negativeYOps (ß ops(negativeY))]
                    (ß ops(x).combine(negativeYOps).addP((Number)x, negativeY))
                )
            )
        )
    )

    (§ defn #_"Number" multiply [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).multiply((Number)x, (Number)y))
    )

    (§ defn #_"Number" multiplyP [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y))
    )

    (§ defn #_"Number" divide [#_"Object" x, #_"Object" y]
        (cond (ß isNaN(x))
            (do
                (§ return (ß (Number)x))
            )
            (ß isNaN(y))
            (do
                (§ return (ß (Number)y))
            )
        )
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number)y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(x).combine(yops).divide((Number)x, (Number)y))
        )
    )

    (§ defn #_"Number" quotient [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number) y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(x).combine(yops).quotient((Number)x, (Number)y))
        )
    )

    (§ defn #_"Number" remainder [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number) y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(x).combine(yops).remainder((Number)x, (Number)y))
        )
    )

    (§ defn #_"double" quotient [#_"double" n, #_"double" d]
        (when (ß d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (ß n / d)]
            (cond (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
                (do
                    (ß (double)(long) q)
                )
                :else ;; bigint quotient
                (do
                    (ß new BigDecimal(q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (§ defn #_"double" remainder [#_"double" n, #_"double" d]
        (when (ß d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (ß n / d)]
            (cond (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
                (do
                    (ß (n - ((long) q) * d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" bq (ß new BigDecimal(q).toBigInteger())]
                        (ß (n - bq.doubleValue() * d))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" equiv [#_"Object" x, #_"Object" y]
        (ß equiv((Number) x, (Number) y))
    )

    (§ defn #_"boolean" equiv [#_"Number" x, #_"Number" y]
        (ß ops(x).combine(ops(y)).equiv(x, y))
    )

    (§ defn #_"boolean" equal [#_"Number" x, #_"Number" y]
        (ß (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y)))
    )

    (§ defn #_"boolean" lt [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).lt((Number)x, (Number)y))
    )

    (§ defn #_"boolean" lte [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).lte((Number)x, (Number)y))
    )

    (§ defn #_"boolean" gt [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).lt((Number)y, (Number)x))
    )

    (§ defn #_"boolean" gte [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).gte((Number)x, (Number)y))
    )

    (§ defn #_"int" compare [#_"Number" x, #_"Number" y]
        (let [#_"Ops" ops (ß ops(x).combine(ops(y)))]
            (cond (ß ops.lt(x, y))
                (do
                    (§ return -1)
                )
                (ß ops.lt(y, x))
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (§ defn #_"BigInt" toBigInt [#_"Object" x]
        (when (ß x instanceof BigInt)
            (§ return (ß (BigInt) x))
        )
        (if (ß x instanceof BigInteger)
            (do
                (ß BigInt.fromBigInteger((BigInteger) x))
            )
            (do
                (ß BigInt.fromLong(((Number) x).longValue()))
            )
        )
    )

    (§ defn #_"BigInteger" toBigInteger [#_"Object" x]
        (cond (ß x instanceof BigInteger)
            (do
                (ß (BigInteger) x)
            )
            (ß x instanceof BigInt)
            (do
                (ß ((BigInt) x).toBigInteger())
            )
            :else
            (do
                (ß BigInteger.valueOf(((Number) x).longValue()))
            )
        )
    )

    (§ defn #_"BigDecimal" toBigDecimal [#_"Object" x]
        (cond (ß x instanceof BigDecimal)
            (do
                (ß (BigDecimal) x)
            )
            (ß x instanceof BigInt)
            (do
                (let [#_"BigInt" bi (ß (BigInt) x)]
                    (if (ß bi.bipart == nil)
                        (do
                            (ß BigDecimal.valueOf(bi.lpart))
                        )
                        (do
                            (BigDecimal. (ß bi.bipart))
                        )
                    )
                )
            )
            (ß x instanceof BigInteger)
            (do
                (ß new BigDecimal((BigInteger) x))
            )
            (ß x instanceof Double)
            (do
                (ß new BigDecimal(((Number) x).doubleValue()))
            )
            (ß x instanceof Float)
            (do
                (ß new BigDecimal(((Number) x).doubleValue()))
            )
            (ß x instanceof Ratio)
            (do
                (let [#_"Ratio" r (ß (Ratio)x)]
                    (ß (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator))
                )
            )
            :else
            (do
                (ß BigDecimal.valueOf(((Number) x).longValue()))
            )
        )
    )

    (§ defn #_"Ratio" toRatio [#_"Object" x]
        (cond (ß x instanceof Ratio)
            (do
                (§ return (ß (Ratio) x))
            )
            (ß x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (let [#_"BigInteger" bv (ß bx.unscaledValue())]
                        (let [#_"int" scale (ß bx.scale())]
                            (if (ß scale < 0)
                                (do
                                    (§ return (ß new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)))
                                )
                                (do
                                    (§ return (ß new Ratio(bv, BigInteger.TEN.pow(scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (ß new Ratio(toBigInteger(x), BigInteger.ONE))
    )

    (§ defn #_"Number" rationalize [#_"Number" x]
        (cond (ß x instanceof Float || x instanceof Double)
            (do
                (§ return (ß rationalize(BigDecimal.valueOf(x.doubleValue()))))
            )
            (ß x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (let [#_"BigInteger" bv (ß bx.unscaledValue())]
                        (let [#_"int" scale (ß bx.scale())]
                            (if (ß scale < 0)
                                (do
                                    (§ return (ß BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß divide(bv, BigInteger.TEN.pow(scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn #_"Number" reduceBigInt [#_"BigInt" val]
        (if (ß val.bipart == nil)
            (do
                (ß num(val.lpart))
            )
            (do
                (ß val.bipart)
            )
        )
    )

    (§ defn #_"Number" divide [#_"BigInteger" n, #_"BigInteger" d]
        (when (ß d.equals(BigInteger.ZERO))
            (throw (ArithmeticException. "Divide by zero"))
        )
        (let [#_"BigInteger" gcd (ß n.gcd(d))]
            (when (ß gcd.equals(BigInteger.ZERO))
                (§ return (ß BigInt.ZERO))
            )
            (§ ass n (ß n.divide(gcd)))
            (§ ass d (ß d.divide(gcd)))
            (cond (ß d.equals(BigInteger.ONE))
                (do
                    (§ return (ß BigInt.fromBigInteger(n)))
                )
                (ß d.equals(BigInteger.ONE.negate()))
                (do
                    (§ return (ß BigInt.fromBigInteger(n.negate())))
                )
            )
            (ß new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d)))
        )
    )

    (§ defn #_"int" shiftLeftInt [#_"int" x, #_"int" n]
        (ß x << n)
    )

    (§ defn #_"long" shiftLeft [#_"Object" x, #_"Object" y]
        (ß shiftLeft(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn #_"long" shiftLeft [#_"Object" x, #_"long" y]
        (ß shiftLeft(bitOpsCast(x), y))
    )
    (§ defn #_"long" shiftLeft [#_"long" x, #_"Object" y]
        (ß shiftLeft(x, bitOpsCast(y)))
    )
    (§ defn #_"long" shiftLeft [#_"long" x, #_"long" n]
        (ß x << n)
    )

    (§ defn #_"int" shiftRightInt [#_"int" x, #_"int" n]
        (ß x >> n)
    )

    (§ defn #_"long" shiftRight [#_"Object" x, #_"Object" y]
        (ß shiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn #_"long" shiftRight [#_"Object" x, #_"long" y]
        (ß shiftRight(bitOpsCast(x), y))
    )
    (§ defn #_"long" shiftRight [#_"long" x, #_"Object" y]
        (ß shiftRight(x, bitOpsCast(y)))
    )
    (§ defn #_"long" shiftRight [#_"long" x, #_"long" n]
        (ß x >> n)
    )

    (§ defn #_"int" unsignedShiftRightInt [#_"int" x, #_"int" n]
        (ß x >>> n)
    )

    (§ defn #_"long" unsignedShiftRight [#_"Object" x, #_"Object" y]
        (ß unsignedShiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn #_"long" unsignedShiftRight [#_"Object" x, #_"long" y]
        (ß unsignedShiftRight(bitOpsCast(x), y))
    )
    (§ defn #_"long" unsignedShiftRight [#_"long" x, #_"Object" y]
        (ß unsignedShiftRight(x, bitOpsCast(y)))
    )
    (§ defn #_"long" unsignedShiftRight [#_"long" x, #_"long" n]
        (ß x >>> n)
    )

    #_stateless
    (class-ns LongOps (§ implements Ops)
        #_method
        (§ defn #_"Ops" combine [#_"LongOps" this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"DoubleOps" x]
            DOUBLE_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"RatioOps" x]
            RATIO_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"BigIntOps" x]
            BIGINT_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"BigDecimalOps" x]
            BIGDECIMAL_OPS
        )

        #_method
        (§ defn #_"boolean" isZero [#_"LongOps" this, #_"Number" x]
            (ß (x.longValue() == 0))
        )

        #_method
        (§ defn #_"boolean" isPos [#_"LongOps" this, #_"Number" x]
            (ß (x.longValue() > 0))
        )

        #_method
        (§ defn #_"boolean" isNeg [#_"LongOps" this, #_"Number" x]
            (ß (x.longValue() < 0))
        )

        #_method
        (§ defn #_"Number" add [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß num(Numbers.add(x.longValue(), y.longValue())))
        )

        #_method
        (§ defn #_"Number" addP [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (let [#_"long" lx (ß x.longValue()) #_"long" ly (ß y.longValue())]
                (let [#_"long" ret (ß lx + ly)]
                    (when (ß (ret :xor lx) < 0 && (ret :xor ly) < 0)
                        (§ return (ß BIGINT_OPS.add(x, y)))
                    )
                    (ß num(ret))
                )
            )
        )

        #_method
        (§ defn #_"Number" multiply [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß num(Numbers.multiply(x.longValue(), y.longValue())))
        )

        #_method
        (§ defn #_"Number" multiplyP [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (let [#_"long" lx (ß x.longValue()) #_"long" ly (ß y.longValue())]
                (when (ß lx == Long.MIN_VALUE && ly < 0)
                    (§ return (ß BIGINT_OPS.multiply(x, y)))
                )
                (let [#_"long" ret (ß lx * ly)]
                    (when (ß ly != 0 && ret / ly != lx)
                        (§ return (ß BIGINT_OPS.multiply(x, y)))
                    )
                    (ß num(ret))
                )
            )
        )

        (§ defn #_"long" gcd [#_"long" u, #_"long" v]
            (while (ß v != 0)
                (let [#_"long" r (ß u % v)]
                    (§ ass u v)
                    (§ ass v r)
                )
            )
            u
        )

        #_method
        (§ defn #_"Number" divide [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (let [#_"long" n (ß x.longValue())]
                (let [#_"long" val (ß y.longValue())]
                    (let [#_"long" gcd (ß gcd(n, val))]
                        (when (ß gcd == 0)
                            (§ return (ß num(0)))
                        )

                        (§ ass n (ß n / gcd))
                        (let [#_"long" d (ß val / gcd)]
                            (when (ß d == 1)
                                (§ return (ß num(n)))
                            )
                            (when (ß d < 0)
                                (§ ass n (ß -n))
                                (§ ass d (ß -d))
                            )
                            (ß new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d)))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" quotient [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß num(x.longValue() / y.longValue()))
        )

        #_method
        (§ defn #_"Number" remainder [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß num(x.longValue() % y.longValue()))
        )

        #_method
        (§ defn #_"boolean" equiv [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() == y.longValue()))
        )

        #_method
        (§ defn #_"boolean" lt [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() < y.longValue()))
        )

        #_method
        (§ defn #_"boolean" lte [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() <= y.longValue()))
        )

        #_method
        (§ defn #_"boolean" gte [#_"LongOps" this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() >= y.longValue()))
        )

        #_method
        (§ defn #_"Number" negate [#_"LongOps" this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.minus(val)))
            )
        )

        #_method
        (§ defn #_"Number" negateP [#_"LongOps" this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (when (ß val > Long.MIN_VALUE)
                    (§ return (ß num(-val)))
                )
                (ß BigInt.fromBigInteger(BigInteger.valueOf(val).negate()))
            )
        )

        #_method
        (§ defn #_"Number" inc [#_"LongOps" this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.inc(val)))
            )
        )

        #_method
        (§ defn #_"Number" incP [#_"LongOps" this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (when (ß val < Long.MAX_VALUE)
                    (§ return (ß num(val + 1)))
                )
                (ß BIGINT_OPS.inc(x))
            )
        )

        #_method
        (§ defn #_"Number" dec [#_"LongOps" this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.dec(val)))
            )
        )

        #_method
        (§ defn #_"Number" decP [#_"LongOps" this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (when (ß val > Long.MIN_VALUE)
                    (§ return (ß num(val - 1)))
                )
                (ß BIGINT_OPS.dec(x))
            )
        )
    )

    #_stateless
    (class-ns DoubleOps (§ extends OpsP)
        #_method
        (§ defn #_"Ops" combine [#_"DoubleOps" this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"DoubleOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"RatioOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"BigDecimalOps" x]
            this
        )

        #_method
        (§ defn #_"boolean" isZero [#_"DoubleOps" this, #_"Number" x]
            (ß (x.doubleValue() == 0))
        )

        #_method
        (§ defn #_"boolean" isPos [#_"DoubleOps" this, #_"Number" x]
            (ß (x.doubleValue() > 0))
        )

        #_method
        (§ defn #_"boolean" isNeg [#_"DoubleOps" this, #_"Number" x]
            (ß (x.doubleValue() < 0))
        )

        #_method
        (§ defn #_"Number" add [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß Double.valueOf(x.doubleValue() + y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" multiply [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß Double.valueOf(x.doubleValue() * y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" divide [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß Double.valueOf(x.doubleValue() / y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" quotient [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß Numbers.quotient(x.doubleValue(), y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" remainder [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß Numbers.remainder(x.doubleValue(), y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" equiv [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() == y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" lt [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() < y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" lte [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() <= y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" gte [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() >= y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" negate [#_"DoubleOps" this, #_"Number" x]
            (ß Double.valueOf(-x.doubleValue()))
        )

        #_method
        (§ defn #_"Number" inc [#_"DoubleOps" this, #_"Number" x]
            (ß Double.valueOf(x.doubleValue() + 1))
        )

        #_method
        (§ defn #_"Number" dec [#_"DoubleOps" this, #_"Number" x]
            (ß Double.valueOf(x.doubleValue() - 1))
        )
    )

    #_stateless
    (class-ns RatioOps (§ extends OpsP)
        #_method
        (§ defn #_"Ops" combine [#_"RatioOps" this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"DoubleOps" x]
            DOUBLE_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"RatioOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"BigDecimalOps" x]
            BIGDECIMAL_OPS
        )

        #_method
        (§ defn #_"boolean" isZero [#_"RatioOps" this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() == 0))
            )
        )

        #_method
        (§ defn #_"boolean" isPos [#_"RatioOps" this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() > 0))
            )
        )

        #_method
        (§ defn #_"boolean" isNeg [#_"RatioOps" this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() < 0))
            )
        )

        (§ defn #_"Number" normalizeRet [#_"Number" ret, #_"Number" x, #_"Number" y]
            ret
        )

        #_method
        (§ defn #_"Number" add [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" multiply [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" divide [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" quotient [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"BigInteger" q (ß rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))]
                        (ß normalizeRet(BigInt.fromBigInteger(q), x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" remainder [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"BigInteger" q (ß rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))]
                        (let [#_"Number" ret (ß Numbers.minus(x, Numbers.multiply(q, y)))]
                            (ß normalizeRet(ret, x, y))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" equiv [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"boolean" lt [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"boolean" lte [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"boolean" gte [#_"RatioOps" this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"Number" negate [#_"RatioOps" this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß new Ratio(r.numerator.negate(), r.denominator))
            )
        )

        #_method
        (§ defn #_"Number" inc [#_"RatioOps" this, #_"Number" x]
            (ß Numbers.add(x, 1))
        )

        #_method
        (§ defn #_"Number" dec [#_"RatioOps" this, #_"Number" x]
            (ß Numbers.add(x, -1))
        )
    )

    #_stateless
    (class-ns BigIntOps (§ extends OpsP)
        #_method
        (§ defn #_"Ops" combine [#_"BigIntOps" this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"DoubleOps" x]
            DOUBLE_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"RatioOps" x]
            RATIO_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"BigDecimalOps" x]
            BIGDECIMAL_OPS
        )

        #_method
        (§ defn #_"boolean" isZero [#_"BigIntOps" this, #_"Number" x]
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart == 0)))
                )
                (ß (bx.bipart.signum() == 0))
            )
        )

        #_method
        (§ defn #_"boolean" isPos [#_"BigIntOps" this, #_"Number" x]
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart > 0)))
                )
                (ß (bx.bipart.signum() > 0))
            )
        )

        #_method
        (§ defn #_"boolean" isNeg [#_"BigIntOps" this, #_"Number" x]
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart < 0)))
                )
                (ß (bx.bipart.signum() < 0))
            )
        )

        #_method
        (§ defn #_"Number" add [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).add(toBigInt(y)))
        )

        #_method
        (§ defn #_"Number" multiply [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).multiply(toBigInt(y)))
        )

        #_method
        (§ defn #_"Number" divide [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß Numbers.divide(toBigInteger(x), toBigInteger(y)))
        )

        #_method
        (§ defn #_"Number" quotient [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).quotient(toBigInt(y)))
        )

        #_method
        (§ defn #_"Number" remainder [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).remainder(toBigInt(y)))
        )

        #_method
        (§ defn #_"boolean" equiv [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).equals(toBigInt(y)))
        )

        #_method
        (§ defn #_"boolean" lt [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).lt(toBigInt(y)))
        )

        #_method
        (§ defn #_"boolean" lte [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) <= 0))
        )

        #_method
        (§ defn #_"boolean" gte [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) >= 0))
        )

        #_method
        (§ defn #_"Number" negate [#_"BigIntOps" this, #_"Number" x]
            (ß BigInt.fromBigInteger(toBigInteger(x).negate()))
        )

        #_method
        (§ defn #_"Number" inc [#_"BigIntOps" this, #_"Number" x]
            (let [#_"BigInteger" bx (ß toBigInteger(x))]
                (ß BigInt.fromBigInteger(bx.add(BigInteger.ONE)))
            )
        )

        #_method
        (§ defn #_"Number" dec [#_"BigIntOps" this, #_"Number" x]
            (let [#_"BigInteger" bx (ß toBigInteger(x))]
                (ß BigInt.fromBigInteger(bx.subtract(BigInteger.ONE)))
            )
        )
    )

    #_stateless
    (class-ns BigDecimalOps (§ extends OpsP)
        (§ def #_"Var" MATH_CONTEXT (ß RT.MATH_CONTEXT))

        #_method
        (§ defn #_"Ops" combine [#_"BigDecimalOps" this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"DoubleOps" x]
            DOUBLE_OPS
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"RatioOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"BigDecimalOps" x]
            this
        )

        #_method
        (§ defn #_"boolean" isZero [#_"BigDecimalOps" this, #_"Number" x]
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() == 0))
            )
        )

        #_method
        (§ defn #_"boolean" isPos [#_"BigDecimalOps" this, #_"Number" x]
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() > 0))
            )
        )

        #_method
        (§ defn #_"boolean" isNeg [#_"BigDecimalOps" this, #_"Number" x]
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() < 0))
            )
        )

        #_method
        (§ defn #_"Number" add [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" multiply [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" divide [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" quotient [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" remainder [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"boolean" equiv [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0))
        )

        #_method
        (§ defn #_"boolean" lt [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0))
        )

        #_method
        (§ defn #_"boolean" lte [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0))
        )

        #_method
        (§ defn #_"boolean" gte [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0))
        )

        #_method
        (§ defn #_"Number" negate [#_"BigDecimalOps" this, #_"Number" x]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc))
            )
        )

        #_method
        (§ defn #_"Number" inc [#_"BigDecimalOps" this, #_"Number" x]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (ß (mc == nil) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc))
                )
            )
        )

        #_method
        (§ defn #_"Number" dec [#_"BigDecimalOps" this, #_"Number" x]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (ß (mc == nil) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc))
                )
            )
        )
    )

    (§ def #_"LongOps" LONG_OPS (LongOps.))
    (§ def #_"DoubleOps" DOUBLE_OPS (DoubleOps.))
    (§ def #_"RatioOps" RATIO_OPS (RatioOps.))
    (§ def #_"BigIntOps" BIGINT_OPS (BigIntOps.))
    (§ def #_"BigDecimalOps" BIGDECIMAL_OPS (BigDecimalOps.))

    (§ enum Category
        (§ item INTEGER),
        (§ item FLOATING),
        (§ item DECIMAL),
        (§ item RATIO)
    )

    (§ defn #_"Ops" ops [#_"Object" x]
        (let [#_"Class" xc (ß x.getClass())]
            (cond (ß xc == Long.class)
                (do
                    LONG_OPS
                )
                (ß xc == Double.class)
                (do
                    DOUBLE_OPS
                )
                (ß xc == Integer.class)
                (do
                    LONG_OPS
                )
                (ß xc == Float.class)
                (do
                    DOUBLE_OPS
                )
                (ß xc == BigInt.class)
                (do
                    BIGINT_OPS
                )
                (ß xc == BigInteger.class)
                (do
                    BIGINT_OPS
                )
                (ß xc == Ratio.class)
                (do
                    RATIO_OPS
                )
                (ß xc == BigDecimal.class)
                (do
                    BIGDECIMAL_OPS
                )
                :else
                (do
                    LONG_OPS
                )
            )
        )
    )

    (§ defn #_"int" hasheqFrom [#_"Number" x, #_"Class" xc]
        (when (ß xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE)))
            (let [#_"long" lpart (ß x.longValue())]
                (§ return (ß Murmur3.hashLong(lpart)))
            )
        )
        (when (ß xc == BigDecimal.class)
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode. Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (ß isZero(x))
                (do
                    (§ return (ß BigDecimal.ZERO.hashCode()))
                )
                (do
                    (§ return (ß ((BigDecimal) x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (ß xc == Float.class && x.equals((float) -0.0))
            (§ return 0) ;; match 0.0f
        )
        (ß x.hashCode())
    )

    (§ defn #_"int" hasheq [#_"Number" x]
        (let [#_"Class" xc (ß x.getClass())]
            (when (ß xc == Long.class)
                (let [#_"long" lpart (ß x.longValue())]
                    (§ return (ß Murmur3.hashLong(lpart)))
                )
            )
            (when (ß xc == Double.class)
                (when (ß x.equals(-0.0))
                    (§ return 0) ;; match 0.0
                )
                (§ return (ß x.hashCode()))
            )
            (ß hasheqFrom(x, xc))
        )
    )

    (§ defn #_"Category" category [#_"Object" x]
        (let [#_"Class" xc (ß x.getClass())]
            (cond (ß xc == Integer.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Double.class)
                (do
                    (ß Category.FLOATING)
                )
                (ß xc == Long.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Float.class)
                (do
                    (ß Category.FLOATING)
                )
                (ß xc == BigInt.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Ratio.class)
                (do
                    (ß Category.RATIO)
                )
                (ß xc == BigDecimal.class)
                (do
                    (ß Category.DECIMAL)
                )
                :else
                (do
                    (ß Category.INTEGER)
                )
            )
        )
    )

    (§ defn #_"long" bitOpsCast [#_"Object" x]
        (let [#_"Class" xc (ß x.getClass())]
            (when (ß xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
                (§ return (ß RT.longCast(x)))
            )
            ;; no bignums, no decimals
            (throw (IllegalArgumentException. (ß "bit operation not supported for: " + xc)))
        )
    )

    (§ defn #_"float[]" float_array [#_"int" size, #_"Object" init]
        (let [#_"float[]" ret (ß new float[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"float" f (ß ((Number) init).floatValue())]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß ((Number) s.first()).floatValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"float[]" float_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new float[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"float[]" ret (ß new float[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß ((Number) s.first()).floatValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"double[]" double_array [#_"int" size, #_"Object" init]
        (let [#_"double[]" ret (ß new double[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"double" f (ß ((Number) init).doubleValue())]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß ((Number) s.first()).doubleValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"double[]" double_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new double[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"double[]" ret (ß new double[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß ((Number) s.first()).doubleValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"int[]" int_array [#_"int" size, #_"Object" init]
        (let [#_"int[]" ret (ß new int[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"int" f (ß ((Number) init).intValue())]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß ((Number) s.first()).intValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"int[]" int_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new int[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"int[]" ret (ß new int[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß ((Number) s.first()).intValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"long[]" long_array [#_"int" size, #_"Object" init]
        (let [#_"long[]" ret (ß new long[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"long" f (ß ((Number) init).longValue())]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß ((Number) s.first()).longValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"long[]" long_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new long[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"long[]" ret (ß new long[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß ((Number) s.first()).longValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"short[]" short_array [#_"int" size, #_"Object" init]
        (let [#_"short[]" ret (ß new short[size])]
            (if (ß init instanceof Short)
                (do
                    (let [#_"short" s (ß (Short) init)]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß ((Number) s.first()).shortValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"short[]" short_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new short[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"short[]" ret (ß new short[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß ((Number) s.first()).shortValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"char[]" char_array [#_"int" size, #_"Object" init]
        (let [#_"char[]" ret (ß new char[size])]
            (if (ß init instanceof Character)
                (do
                    (let [#_"char" c (ß (Character) init)]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß (Character) s.first()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"char[]" char_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new char[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"char[]" ret (ß new char[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß (Character) s.first()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"byte[]" byte_array [#_"int" size, #_"Object" init]
        (let [#_"byte[]" ret (ß new byte[size])]
            (if (ß init instanceof Byte)
                (do
                    (let [#_"byte" b (ß (Byte) init)]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß ((Number) s.first()).byteValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"byte[]" byte_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new byte[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"byte[]" ret (ß new byte[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß ((Number) s.first()).byteValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean[]" boolean_array [#_"int" size, #_"Object" init]
        (let [#_"boolean[]" ret (ß new boolean[size])]
            (if (ß init instanceof Boolean)
                (do
                    (let [#_"boolean" b (ß (Boolean) init)]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß (Boolean)s.first()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"boolean[]" boolean_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new boolean[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"boolean[]" ret (ß new boolean[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß (Boolean)s.first()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean[]" booleans [#_"Object" array]
        (ß (boolean[]) array)
    )

    (§ defn #_"byte[]" bytes [#_"Object" array]
        (ß (byte[]) array)
    )

    (§ defn #_"char[]" chars [#_"Object" array]
        (ß (char[]) array)
    )

    (§ defn #_"short[]" shorts [#_"Object" array]
        (ß (short[]) array)
    )

    (§ defn #_"float[]" floats [#_"Object" array]
        (ß (float[]) array)
    )

    (§ defn #_"double[]" doubles [#_"Object" array]
        (ß (double[]) array)
    )

    (§ defn #_"int[]" ints [#_"Object" array]
        (ß (int[]) array)
    )

    (§ defn #_"long[]" longs [#_"Object" array]
        (ß (long[]) array)
    )

    (§ defn #_"Number" num [#_"Object" x]
        (ß (Number) x)
    )

    (§ defn #_"Number" num [#_"float" x]
        (ß Float.valueOf(x))
    )

    (§ defn #_"Number" num [#_"double" x]
        (ß Double.valueOf(x))
    )

    (§ defn #_"double" add [#_"double" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"double" addP [#_"double" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"double" minus [#_"double" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"double" minusP [#_"double" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"double" minus [#_"double" x]
        (ß -x)
    )

    (§ defn #_"double" minusP [#_"double" x]
        (ß -x)
    )

    (§ defn #_"double" inc [#_"double" x]
        (ß x + 1)
    )

    (§ defn #_"double" incP [#_"double" x]
        (ß x + 1)
    )

    (§ defn #_"double" dec [#_"double" x]
        (ß x - 1)
    )

    (§ defn #_"double" decP [#_"double" x]
        (ß x - 1)
    )

    (§ defn #_"double" multiply [#_"double" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"double" multiplyP [#_"double" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"double" divide [#_"double" x, #_"double" y]
        (ß x / y)
    )

    (§ defn #_"boolean" equiv [#_"double" x, #_"double" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" lt [#_"double" x, #_"double" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lte [#_"double" x, #_"double" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" gt [#_"double" x, #_"double" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gte [#_"double" x, #_"double" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" isPos [#_"double" x]
        (ß (x > 0))
    )

    (§ defn #_"boolean" isNeg [#_"double" x]
        (ß (x < 0))
    )

    (§ defn #_"boolean" isZero [#_"double" x]
        (ß (x == 0))
    )

    (§ defn #_"int" throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (§ defn #_"int" unchecked_int_add [#_"int" x, #_"int" y]
        (ß x + y)
    )

    (§ defn #_"int" unchecked_int_subtract [#_"int" x, #_"int" y]
        (ß x - y)
    )

    (§ defn #_"int" unchecked_int_negate [#_"int" x]
        (ß -x)
    )

    (§ defn #_"int" unchecked_int_inc [#_"int" x]
        (ß x + 1)
    )

    (§ defn #_"int" unchecked_int_dec [#_"int" x]
        (ß x - 1)
    )

    (§ defn #_"int" unchecked_int_multiply [#_"int" x, #_"int" y]
        (ß x * y)
    )

    (§ defn #_"long" not [#_"Object" x]
        (ß not(bitOpsCast(x)))
    )

    (§ defn #_"long" not [#_"long" x]
        (ß ~x)
    )

    (§ defn #_"long" and [#_"Object" x, #_"Object" y]
        (ß and(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" and [#_"Object" x, #_"long" y]
        (ß and(bitOpsCast(x), y))
    )

    (§ defn #_"long" and [#_"long" x, #_"Object" y]
        (ß and(x, bitOpsCast(y)))
    )

    (§ defn #_"long" and [#_"long" x, #_"long" y]
        (ß x & y)
    )

    (§ defn #_"long" or [#_"Object" x, #_"Object" y]
        (ß or(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" or [#_"Object" x, #_"long" y]
        (ß or(bitOpsCast(x), y))
    )

    (§ defn #_"long" or [#_"long" x, #_"Object" y]
        (ß or(x, bitOpsCast(y)))
    )

    (§ defn #_"long" or [#_"long" x, #_"long" y]
        (ß x | y)
    )

    (§ defn #_"long" xor [#_"Object" x, #_"Object" y]
        (ß xor(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" xor [#_"Object" x, #_"long" y]
        (ß xor(bitOpsCast(x), y))
    )

    (§ defn #_"long" xor [#_"long" x, #_"Object" y]
        (ß xor(x, bitOpsCast(y)))
    )

    (§ defn #_"long" xor [#_"long" x, #_"long" y]
        (ß x :xor y)
    )

    (§ defn #_"long" andNot [#_"Object" x, #_"Object" y]
        (ß andNot(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" andNot [#_"Object" x, #_"long" y]
        (ß andNot(bitOpsCast(x), y))
    )

    (§ defn #_"long" andNot [#_"long" x, #_"Object" y]
        (ß andNot(x, bitOpsCast(y)))
    )

    (§ defn #_"long" andNot [#_"long" x, #_"long" y]
        (ß x & ~y)
    )

    (§ defn #_"long" clearBit [#_"Object" x, #_"Object" y]
        (ß clearBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" clearBit [#_"Object" x, #_"long" y]
        (ß clearBit(bitOpsCast(x), y))
    )

    (§ defn #_"long" clearBit [#_"long" x, #_"Object" y]
        (ß clearBit(x, bitOpsCast(y)))
    )

    (§ defn #_"long" clearBit [#_"long" x, #_"long" n]
        (ß x & ~(1 << n))
    )

    (§ defn #_"long" setBit [#_"Object" x, #_"Object" y]
        (ß setBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" setBit [#_"Object" x, #_"long" y]
        (ß setBit(bitOpsCast(x), y))
    )

    (§ defn #_"long" setBit [#_"long" x, #_"Object" y]
        (ß setBit(x, bitOpsCast(y)))
    )

    (§ defn #_"long" setBit [#_"long" x, #_"long" n]
        (ß x | (1 << n))
    )

    (§ defn #_"long" flipBit [#_"Object" x, #_"Object" y]
        (ß flipBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" flipBit [#_"Object" x, #_"long" y]
        (ß flipBit(bitOpsCast(x), y))
    )

    (§ defn #_"long" flipBit [#_"long" x, #_"Object" y]
        (ß flipBit(x, bitOpsCast(y)))
    )

    (§ defn #_"long" flipBit [#_"long" x, #_"long" n]
        (ß x :xor (1 << n))
    )

    (§ defn #_"boolean" testBit [#_"Object" x, #_"Object" y]
        (ß testBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"boolean" testBit [#_"Object" x, #_"long" y]
        (ß testBit(bitOpsCast(x), y))
    )

    (§ defn #_"boolean" testBit [#_"long" x, #_"Object" y]
        (ß testBit(x, bitOpsCast(y)))
    )

    (§ defn #_"boolean" testBit [#_"long" x, #_"long" n]
        (ß ((x & (1 << n)) != 0))
    )

    (§ defn #_"int" unchecked_int_divide [#_"int" x, #_"int" y]
        (ß x / y)
    )

    (§ defn #_"int" unchecked_int_remainder [#_"int" x, #_"int" y]
        (ß x % y)
    )

    (§ defn #_"Number" num [#_"long" x]
        (ß Long.valueOf(x))
    )

    (§ defn #_"long" unchecked_add [#_"long" x, #_"long" y]
        (ß x + y)
    )

    (§ defn #_"long" unchecked_minus [#_"long" x, #_"long" y]
        (ß x - y)
    )

    (§ defn #_"long" unchecked_multiply [#_"long" x, #_"long" y]
        (ß x * y)
    )

    (§ defn #_"long" unchecked_minus [#_"long" x]
        (ß -x)
    )

    (§ defn #_"long" unchecked_inc [#_"long" x]
        (ß x + 1)
    )

    (§ defn #_"long" unchecked_dec [#_"long" x]
        (ß x - 1)
    )

    (§ defn #_"Number" unchecked_add [#_"Object" x, #_"Object" y]
        (ß add(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"Object" x, #_"Object" y]
        (ß minus(x, y))
    )

    (§ defn #_"Number" unchecked_multiply [#_"Object" x, #_"Object" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"Object" x]
        (ß minus(x))
    )

    (§ defn #_"Number" unchecked_inc [#_"Object" x]
        (ß inc(x))
    )

    (§ defn #_"Number" unchecked_dec [#_"Object" x]
        (ß dec(x))
    )

    (§ defn #_"double" unchecked_add [#_"double" x, #_"double" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x, #_"double" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"double" x, #_"double" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x]
        (ß minus(x))
    )

    (§ defn #_"double" unchecked_inc [#_"double" x]
        (ß inc(x))
    )

    (§ defn #_"double" unchecked_dec [#_"double" x]
        (ß dec(x))
    )

    (§ defn #_"double" unchecked_add [#_"double" x, #_"Object" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x, #_"Object" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"double" x, #_"Object" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_add [#_"Object" x, #_"double" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"Object" x, #_"double" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"Object" x, #_"double" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_add [#_"double" x, #_"long" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x, #_"long" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"double" x, #_"long" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_add [#_"long" x, #_"double" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"long" x, #_"double" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"long" x, #_"double" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" unchecked_add [#_"long" x, #_"Object" y]
        (ß add(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"long" x, #_"Object" y]
        (ß minus(x, y))
    )

    (§ defn #_"Number" unchecked_multiply [#_"long" x, #_"Object" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" unchecked_add [#_"Object" x, #_"long" y]
        (ß add(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"Object" x, #_"long" y]
        (ß minus(x, y))
    )

    (§ defn #_"Number" unchecked_multiply [#_"Object" x, #_"long" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" quotient [#_"double" x, #_"Object" y]
        (ß quotient((Object)x, y))
    )

    (§ defn #_"Number" quotient [#_"Object" x, #_"double" y]
        (ß quotient(x, (Object)y))
    )

    (§ defn #_"Number" quotient [#_"long" x, #_"Object" y]
        (ß quotient((Object)x, y))
    )

    (§ defn #_"Number" quotient [#_"Object" x, #_"long" y]
        (ß quotient(x, (Object)y))
    )

    (§ defn #_"double" quotient [#_"double" x, #_"long" y]
        (ß quotient(x, (double)y))
    )

    (§ defn #_"double" quotient [#_"long" x, #_"double" y]
        (ß quotient((double)x, y))
    )

    (§ defn #_"Number" remainder [#_"double" x, #_"Object" y]
        (ß remainder((Object)x, y))
    )

    (§ defn #_"Number" remainder [#_"Object" x, #_"double" y]
        (ß remainder(x, (Object)y))
    )

    (§ defn #_"Number" remainder [#_"long" x, #_"Object" y]
        (ß remainder((Object)x, y))
    )

    (§ defn #_"Number" remainder [#_"Object" x, #_"long" y]
        (ß remainder(x, (Object)y))
    )

    (§ defn #_"double" remainder [#_"double" x, #_"long" y]
        (ß remainder(x, (double)y))
    )

    (§ defn #_"double" remainder [#_"long" x, #_"double" y]
        (ß remainder((double)x, y))
    )

    (§ defn #_"long" add [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x + y)]
            (when (ß (ret :xor x) < 0 && (ret :xor y) < 0)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" addP [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x + y)]
            (when (ß (ret :xor x) < 0 && (ret :xor y) < 0)
                (§ return (ß addP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn #_"long" minus [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x - y)]
            (when (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" minusP [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x - y)]
            (when (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
                (§ return (ß minusP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn #_"long" minus [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß -x)
    )

    (§ defn #_"Number" minusP [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß BigInt.fromBigInteger(BigInteger.valueOf(x).negate())))
        )
        (ß num(-x))
    )

    (§ defn #_"long" inc [#_"long" x]
        (when (ß x == Long.MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x + 1)
    )

    (§ defn #_"Number" incP [#_"long" x]
        (when (ß x == Long.MAX_VALUE)
            (§ return (ß BIGINT_OPS.inc(x)))
        )
        (ß num(x + 1))
    )

    (§ defn #_"long" dec [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x - 1)
    )

    (§ defn #_"Number" decP [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß BIGINT_OPS.dec(x)))
        )
        (ß num(x - 1))
    )

    (§ defn #_"long" multiply [#_"long" x, #_"long" y]
        (when (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (let [#_"long" ret (ß x * y)]
            (when (ß y != 0 && ret / y != x)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" multiplyP [#_"long" x, #_"long" y]
        (when (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß multiplyP((Number)x, (Number)y)))
        )
        (let [#_"long" ret (ß x * y)]
            (when (ß y != 0 && ret / y != x)
                (§ return (ß multiplyP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn #_"long" quotient [#_"long" x, #_"long" y]
        (ß x / y)
    )

    (§ defn #_"long" remainder [#_"long" x, #_"long" y]
        (ß x % y)
    )

    (§ defn #_"boolean" equiv [#_"long" x, #_"long" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" lt [#_"long" x, #_"long" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lte [#_"long" x, #_"long" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" gt [#_"long" x, #_"long" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gte [#_"long" x, #_"long" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" isPos [#_"long" x]
        (ß (x > 0))
    )

    (§ defn #_"boolean" isNeg [#_"long" x]
        (ß (x < 0))
    )

    (§ defn #_"boolean" isZero [#_"long" x]
        (ß (x == 0))
    )

    ;; overload resolution

    (§ defn #_"Number" add [#_"long" x, #_"Object" y]
        (ß add((Object)x, y))
    )

    (§ defn #_"Number" add [#_"Object" x, #_"long" y]
        (ß add(x, (Object)y))
    )

    (§ defn #_"Number" addP [#_"long" x, #_"Object" y]
        (ß addP((Object)x, y))
    )

    (§ defn #_"Number" addP [#_"Object" x, #_"long" y]
        (ß addP(x, (Object)y))
    )

    (§ defn #_"double" add [#_"double" x, #_"Object" y]
        (ß add(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" add [#_"Object" x, #_"double" y]
        (ß add(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" add [#_"double" x, #_"long" y]
        (ß x + y)
    )

    (§ defn #_"double" add [#_"long" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"double" addP [#_"double" x, #_"Object" y]
        (ß addP(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" addP [#_"Object" x, #_"double" y]
        (ß addP(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" addP [#_"double" x, #_"long" y]
        (ß x + y)
    )

    (§ defn #_"double" addP [#_"long" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"Number" minus [#_"long" x, #_"Object" y]
        (ß minus((Object)x, y))
    )

    (§ defn #_"Number" minus [#_"Object" x, #_"long" y]
        (ß minus(x, (Object)y))
    )

    (§ defn #_"Number" minusP [#_"long" x, #_"Object" y]
        (ß minusP((Object)x, y))
    )

    (§ defn #_"Number" minusP [#_"Object" x, #_"long" y]
        (ß minusP(x, (Object)y))
    )

    (§ defn #_"double" minus [#_"double" x, #_"Object" y]
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" minus [#_"Object" x, #_"double" y]
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" minus [#_"double" x, #_"long" y]
        (ß x - y)
    )

    (§ defn #_"double" minus [#_"long" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"double" minusP [#_"double" x, #_"Object" y]
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" minusP [#_"Object" x, #_"double" y]
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" minusP [#_"double" x, #_"long" y]
        (ß x - y)
    )

    (§ defn #_"double" minusP [#_"long" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"Number" multiply [#_"long" x, #_"Object" y]
        (ß multiply((Object)x, y))
    )

    (§ defn #_"Number" multiply [#_"Object" x, #_"long" y]
        (ß multiply(x, (Object)y))
    )

    (§ defn #_"Number" multiplyP [#_"long" x, #_"Object" y]
        (ß multiplyP((Object)x, y))
    )

    (§ defn #_"Number" multiplyP [#_"Object" x, #_"long" y]
        (ß multiplyP(x, (Object)y))
    )

    (§ defn #_"double" multiply [#_"double" x, #_"Object" y]
        (ß multiply(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" multiply [#_"Object" x, #_"double" y]
        (ß multiply(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" multiply [#_"double" x, #_"long" y]
        (ß x * y)
    )

    (§ defn #_"double" multiply [#_"long" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"double" multiplyP [#_"double" x, #_"Object" y]
        (ß multiplyP(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" multiplyP [#_"Object" x, #_"double" y]
        (ß multiplyP(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" multiplyP [#_"double" x, #_"long" y]
        (ß x * y)
    )

    (§ defn #_"double" multiplyP [#_"long" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"Number" divide [#_"long" x, #_"Object" y]
        (ß divide((Object)x, y))
    )

    (§ defn #_"Number" divide [#_"Object" x, #_"long" y]
        (ß divide(x, (Object)y))
    )

    (§ defn #_"double" divide [#_"double" x, #_"Object" y]
        (ß x / ((Number)y).doubleValue())
    )

    (§ defn #_"double" divide [#_"Object" x, #_"double" y]
        (ß ((Number)x).doubleValue() / y)
    )

    (§ defn #_"double" divide [#_"double" x, #_"long" y]
        (ß x / y)
    )

    (§ defn #_"double" divide [#_"long" x, #_"double" y]
        (ß x / y)
    )

    (§ defn #_"Number" divide [#_"long" x, #_"long" y]
        (ß divide((Number)x, (Number)y))
    )

    (§ defn #_"boolean" lt [#_"long" x, #_"Object" y]
        (ß lt((Object)x, y))
    )

    (§ defn #_"boolean" lt [#_"Object" x, #_"long" y]
        (ß lt(x, (Object)y))
    )

    (§ defn #_"boolean" lt [#_"double" x, #_"Object" y]
        (ß (x < ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" lt [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() < y))
    )

    (§ defn #_"boolean" lt [#_"double" x, #_"long" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lt [#_"long" x, #_"double" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lte [#_"long" x, #_"Object" y]
        (ß lte((Object)x, y))
    )

    (§ defn #_"boolean" lte [#_"Object" x, #_"long" y]
        (ß lte(x, (Object)y))
    )

    (§ defn #_"boolean" lte [#_"double" x, #_"Object" y]
        (ß (x <= ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" lte [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() <= y))
    )

    (§ defn #_"boolean" lte [#_"double" x, #_"long" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" lte [#_"long" x, #_"double" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" gt [#_"long" x, #_"Object" y]
        (ß gt((Object)x, y))
    )

    (§ defn #_"boolean" gt [#_"Object" x, #_"long" y]
        (ß gt(x, (Object)y))
    )

    (§ defn #_"boolean" gt [#_"double" x, #_"Object" y]
        (ß (x > ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" gt [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() > y))
    )

    (§ defn #_"boolean" gt [#_"double" x, #_"long" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gt [#_"long" x, #_"double" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gte [#_"long" x, #_"Object" y]
        (ß gte((Object)x, y))
    )

    (§ defn #_"boolean" gte [#_"Object" x, #_"long" y]
        (ß gte(x, (Object)y))
    )

    (§ defn #_"boolean" gte [#_"double" x, #_"Object" y]
        (ß (x >= ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" gte [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() >= y))
    )

    (§ defn #_"boolean" gte [#_"double" x, #_"long" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" gte [#_"long" x, #_"double" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" equiv [#_"long" x, #_"Object" y]
        (ß equiv((Object)x, y))
    )

    (§ defn #_"boolean" equiv [#_"Object" x, #_"long" y]
        (ß equiv(x, (Object)y))
    )

    (§ defn #_"boolean" equiv [#_"double" x, #_"Object" y]
        (ß (x == ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" equiv [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() == y))
    )

    (§ defn #_"boolean" equiv [#_"double" x, #_"long" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" equiv [#_"long" x, #_"double" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" isNaN [#_"Object" x]
        (ß (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN())
    )

    (§ defn #_"double" max [#_"double" x, #_"double" y]
        (ß Math.max(x, y))
    )

    (§ defn #_"Object" max [#_"double" x, #_"long" y]
        (when (ß Double.isNaN(x))
            (§ return x)
        )
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"double" x, #_"Object" y]
        (cond (ß Double.isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß x > ((Number)y).doubleValue())
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"long" x, #_"double" y]
        (when (ß Double.isNaN(y))
            (§ return y)
        )
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"long" max [#_"long" x, #_"long" y]
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"long" x, #_"Object" y]
        (when (ß isNaN(y))
            (§ return y)
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"Object" x, #_"long" y]
        (when (ß isNaN(x))
            (§ return x)
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"Object" x, #_"double" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß Double.isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß ((Number)x).doubleValue() > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"Object" x, #_"Object" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"double" min [#_"double" x, #_"double" y]
        (ß Math.min(x, y))
    )

    (§ defn #_"Object" min [#_"double" x, #_"long" y]
        (when (ß Double.isNaN(x))
            (§ return x)
        )
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"double" x, #_"Object" y]
        (cond (ß Double.isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß x < ((Number)y).doubleValue())
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"long" x, #_"double" y]
        (when (ß Double.isNaN(y))
            (§ return y)
        )
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"long" min [#_"long" x, #_"long" y]
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"long" x, #_"Object" y]
        (when (ß isNaN(y))
            (§ return y)
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"Object" x, #_"long" y]
        (when (ß isNaN(x))
            (§ return x)
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"Object" x, #_"double" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß Double.isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß ((Number)x).doubleValue() < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"Object" x, #_"Object" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (§ init
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"Obj" Obj [#_"IPersistentMap" meta]
        (let [this (ß super())]
            (§ ass (ß this._meta) meta)
            this
        )
    )

    (§ constructor #_"Obj" Obj []
        (let [this (ß super())]
            (§ ass _meta nil)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Obj" this]
        (ß _meta)
    )

    #_abstract
    (§ defn #_"Obj" withMeta [#_"Obj" this, #_"IPersistentMap" meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" EMPTY (PersistentArrayMap.))
    (§ def #_"int" HASHTABLE_THRESHOLD 16)

    (§ defn #_"IPersistentMap" create [#_"Map" other]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(§ var #_"Map.Entry" e (ß (Entry) o))]
                    (§ ass ret (ß ret.assoc(e.getKey(), e.getValue())))
                )
            )
            (ß ret.persistent())
        )
    )

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field- #_"IPersistentMap" _meta nil)
    )

    #_protected
    (§ constructor #_"PersistentArrayMap" PersistentArrayMap []
        (let [this (ß super())]
            (§ ass (ß this.array) (ß new Object[] (§ array )))
            (§ ass (ß this._meta) nil)
            this
        )
    )

    #_method
    (§ defn #_"PersistentArrayMap" withMeta [#_"PersistentArrayMap" this, #_"IPersistentMap" meta]
        (ß new PersistentArrayMap(meta, array))
    )

    #_method
    (§ defn #_"PersistentArrayMap" create [#_"PersistentArrayMap" this, #_"Object..." init]
        (ß new PersistentArrayMap(meta(), init))
    )

    #_method
    (§ defn #_"IPersistentMap" createHT [#_"PersistentArrayMap" this, #_"Object[]" init]
        (ß PersistentHashMap.create(meta(), init))
    )

    (§ defn #_"PersistentArrayMap" createWithCheck [#_"Object[]" init]
        (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 2))]
            (loop-when-recur [(§ var #_"int" j (ß i + 2))] (ß j < init.length) [(§ ass j (ß j + 2))]
                (when (ß equalKey(init[i], init[j]))
                    (throw (IllegalArgumentException. (ß "Duplicate key: " + init[i])))
                )
            )
        )
        (PersistentArrayMap. init)
    )

    (§ defn #_"PersistentArrayMap" createAsIfByAssoc [#_"Object[]" init]
        (when (ß (init.length & 1) == 1)
            (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1]))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" n 0]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 2))]
                (let [#_"boolean" duplicateKey false]
                    (loop-when-recur [(§ var #_"int" j 0)] (ß j < i) [(§ ass j (ß j + 2))]
                        (when (ß equalKey(init[i], init[j]))
                            (§ ass duplicateKey true)
                            (§ break )
                        )
                    )
                    (when (ß !duplicateKey)
                        (§ ass n (ß n + 2))
                    )
                )
            )
            (when (ß n < init.length)
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key. To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" nodups (ß new Object[n])]
                    (let [#_"int" m 0]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 2))]
                            (let [#_"boolean" duplicateKey false]
                                (loop-when-recur [(§ var #_"int" j 0)] (ß j < m) [(§ ass j (ß j + 2))]
                                    (when (ß equalKey(init[i], nodups[j]))
                                        (§ ass duplicateKey true)
                                        (§ break )
                                    )
                                )
                                (when (ß !duplicateKey)
                                    (§ let [#_"int" j]
                                        (loop-when-recur [(§ ass j (ß init.length - 2))] (ß j >= i) [(§ ass j (ß j - 2))]
                                            (when (ß equalKey(init[i], init[j]))
                                                (§ break )
                                            )
                                        )
                                        (§ ass (ß nodups[m]) (ß init[i]))
                                        (§ ass (ß nodups[m + 1]) (ß init[j + 1]))
                                        (§ ass m (ß m + 2))
                                    )
                                )
                            )
                        )
                        (when (ß m != n)
                            (throw (IllegalArgumentException. (ß "Internal error: m=" + m)))
                        )
                        (§ ass init nodups)
                    )
                )
            )
            (PersistentArrayMap. init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ constructor #_"PersistentArrayMap" PersistentArrayMap [#_"Object[]" init]
        (let [this (ß super())]
            (§ ass (ß this.array) init)
            (§ ass (ß this._meta) nil)
            this
        )
    )

    (§ constructor #_"PersistentArrayMap" PersistentArrayMap [#_"IPersistentMap" meta, #_"Object[]" init]
        (let [this (ß super())]
            (§ ass (ß this._meta) meta)
            (§ ass (ß this.array) init)
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentArrayMap" this]
        (ß array.length / 2)
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentArrayMap" this, #_"Object" key]
        (ß (indexOf(key) >= 0))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"PersistentArrayMap" this, #_"Object" key]
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0)
                (§ return (ß (IMapEntry) MapEntry.create(array[i], array[i + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (ß indexOf(key))]
            (§ let [#_"Object[]" newArray]
                (cond (ß i >= 0)
                    (do
                        (throw (ß Util.runtimeException("Key already present")))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assocEx(key, val)))
                        )
                        (§ ass newArray (ß new Object[array.length + 2]))
                        (when (ß array.length > 0)
                            (ß System.arraycopy(array, 0, newArray, 2, array.length))
                        )
                        (§ ass (ß newArray[0]) key)
                        (§ ass (ß newArray[1]) val)
                    )
                )
                (ß create(newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (ß indexOf(key))]
            (§ let [#_"Object[]" newArray]
                (cond (ß i >= 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß array[i + 1] == val) ;; no change, no op
                            (§ return this)
                        )
                        (§ ass newArray (ß array.clone()))
                        (§ ass (ß newArray[i + 1]) val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assoc(key, val)))
                        )
                        (§ ass newArray (ß new Object[array.length + 2]))
                        (when (ß array.length > 0)
                            (ß System.arraycopy(array, 0, newArray, 0, array.length))
                        )
                        (§ ass (ß newArray[newArray.length - 2]) key)
                        (§ ass (ß newArray[newArray.length - 1]) val)
                    )
                )
                (ß create(newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" without [#_"PersistentArrayMap" this, #_"Object" key]
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0) ;; have key, will remove
                (let [#_"int" newlen (ß array.length - 2)]
                    (when (ß newlen == 0)
                        (§ return (ß empty()))
                    )
                    (let [#_"Object[]" newArray (ß new Object[newlen])]
                        (ß System.arraycopy(array, 0, newArray, 0, i))
                        (ß System.arraycopy(array, i + 2, newArray, i, newlen - i))
                        (§ return (ß create(newArray)))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" empty [#_"PersistentArrayMap" this]
        (ß (IPersistentMap) EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0)
                (§ return (ß array[i + 1]))
            )
            notFound
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentArrayMap" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"int" capacity [#_"PersistentArrayMap" this]
        (ß count())
    )

    #_method
    (§ defn- #_"int" indexOfObject [#_"PersistentArrayMap" this, #_"Object" key]
        (let [(§ var #_"Util.EquivPred" ep (ß Util.equivPred(key)))]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < array.length) [(§ ass i (ß i + 2))]
                (when (ß ep.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn- #_"int" indexOf [#_"PersistentArrayMap" this, #_"Object" key]
        (if (ß key instanceof Keyword)
            (do
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < array.length) [(§ ass i (ß i + 2))]
                    (when (ß key == array[i])
                        (§ return i)
                    )
                )
                -1
            )
            (do
                (ß indexOfObject(key))
            )
        )
    )

    (§ defn #_"boolean" equalKey [#_"Object" k1, #_"Object" k2]
        (when (ß k1 instanceof Keyword)
            (§ return (ß (k1 == k2)))
        )
        (ß Util.equiv(k1, k2))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentArrayMap" this]
        (ß new PersistentArrayMap'Iter(array, APersistentMap.MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [#_"PersistentArrayMap" this]
        (ß new PersistentArrayMap'Iter(array, APersistentMap.MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [#_"PersistentArrayMap" this]
        (ß new PersistentArrayMap'Iter(array, APersistentMap.MAKE_VAL))
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentArrayMap" this]
        (when (ß array.length > 0)
            (§ return (ß new PersistentArrayMap'Seq(array, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentArrayMap" this]
        (ß _meta)
    )

    (class-ns PersistentArrayMap'Seq (§ extends ASeq) (§ implements Counted)
        (§ init
            (§ field #_"Object[]" array nil)
            (§ field #_"int" i 0)
        )

        (§ constructor #_"PersistentArrayMap'Seq" PersistentArrayMap'Seq [#_"Object[]" array, #_"int" i]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        (§ constructor #_"PersistentArrayMap'Seq" PersistentArrayMap'Seq [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"PersistentArrayMap'Seq" this]
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        #_method
        (§ defn #_"ISeq" next [#_"PersistentArrayMap'Seq" this]
            (when (ß i + 2 < array.length)
                (§ return (ß new PersistentArrayMap'Seq(array, i + 2)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [#_"PersistentArrayMap'Seq" this]
            (ß (array.length - i) / 2)
        )

        #_method
        (§ defn #_"Obj" withMeta [#_"PersistentArrayMap'Seq" this, #_"IPersistentMap" meta]
            (ß new PersistentArrayMap'Seq(meta, array, i))
        )
    )

    (class-ns PersistentArrayMap'Iter (§ implements Iterator)
        (§ init
            (§ field #_"IFn" f nil)
            (§ field #_"Object[]" array nil)
            (§ field #_"int" i 0)
        )

        ;; for iterator
        (§ constructor #_"PersistentArrayMap'Iter" PersistentArrayMap'Iter [#_"Object[]" array, #_"IFn" f]
            (let [this (ß this(array, -2, f))]
                this
            )
        )

        ;; for entryAt
        (§ constructor #_"PersistentArrayMap'Iter" PersistentArrayMap'Iter [#_"Object[]" array, #_"int" i, #_"IFn" f]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                (§ ass (ß this.f) f)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"PersistentArrayMap'Iter" this]
            (ß (i < array.length - 2))
        )

        #_method
        (§ defn #_"Object" next [#_"PersistentArrayMap'Iter" this]
            (try
                (§ ass i (ß i + 2))
                (ß f.invoke(array[i], array[i + 1]))
                (catch IndexOutOfBoundsException e
                    (throw (NoSuchElementException.))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [#_"PersistentArrayMap'Iter" this]
            (throw (UnsupportedOperationException.))
        )
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentArrayMap" this, #_"IFn" f, #_"Object" init]
        (loop-when-recur [(§ var #_"int" i 0)] (ß i < array.length) [(§ ass i (ß i + 2))]
            (§ ass init (ß f.invoke(init, array[i], array[i + 1])))
            (when (ß RT.isReduced(init))
                (§ return (ß ((IDeref)init).deref()))
            )
        )
        init
    )

    #_method
    (§ defn #_"ITransientMap" asTransient [#_"PersistentArrayMap" this]
        (TransientArrayMap. array)
    )

    (class-ns TransientArrayMap (§ extends ATransientMap)
        (§ init
            #_volatile
            (§ field #_"int" len 0)
            (§ field #_"Object[]" array nil)
            #_volatile
            (§ field #_"Thread" owner nil)
        )

        (§ constructor #_"TransientArrayMap" TransientArrayMap [#_"Object[]" array]
            (let [this (ß super())]
                (§ ass (ß this.owner) (ß Thread.currentThread()))
                (§ ass (ß this.array) (ß new Object[Math.max(HASHTABLE_THRESHOLD, array.length)]))
                (ß System.arraycopy(array, 0, this.array, 0, array.length))
                (§ ass (ß this.len) (ß array.length))
                this
            )
        )

        #_method
        (§ defn- #_"int" indexOf [#_"TransientArrayMap" this, #_"Object" key]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < len) [(§ ass i (ß i + 2))]
                (when (ß equalKey(array[i], key))
                    (§ return i)
                )
            )
            -1
        )

        #_method
        (§ defn #_"ITransientMap" doAssoc [#_"TransientArrayMap" this, #_"Object" key, #_"Object" val]
            (let [#_"int" i (ß indexOf(key))]
                (cond (ß i >= 0) ;; already have key,
                    (do
                        (when (ß array[i + 1] != val) ;; no change, no op
                            (§ ass (ß array[i + 1]) val)
                        )
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß len >= array.length)
                            (§ return (ß PersistentHashMap.create(array).asTransient().assoc(key, val)))
                        )
                        (§ ass (ß array[len]) key)
                        (§ ass len (ß len + 1))
                        (§ ass (ß array[len]) val)
                        (§ ass len (ß len + 1))
                    )
                )
                this
            )
        )

        #_method
        (§ defn #_"ITransientMap" doWithout [#_"TransientArrayMap" this, #_"Object" key]
            (let [#_"int" i (ß indexOf(key))]
                (when (ß i >= 0) ;; have key, will remove
                    (when (ß len >= 2)
                        (§ ass (ß array[i]) (ß array[len - 2]))
                        (§ ass (ß array[i + 1]) (ß array[len - 1]))
                    )
                    (§ ass len (ß len - 2))
                )
                this
            )
        )

        #_method
        (§ defn #_"Object" doValAt [#_"TransientArrayMap" this, #_"Object" key, #_"Object" notFound]
            (let [#_"int" i (ß indexOf(key))]
                (when (ß i >= 0)
                    (§ return (ß array[i + 1]))
                )
                notFound
            )
        )

        #_method
        (§ defn #_"int" doCount [#_"TransientArrayMap" this]
            (ß len / 2)
        )

        #_method
        (§ defn #_"IPersistentMap" doPersistent [#_"TransientArrayMap" this]
            (ß ensureEditable())
            (§ ass owner nil)
            (let [#_"Object[]" a (ß new Object[len])]
                (ß System.arraycopy(array, 0, a, 0, len))
                (PersistentArrayMap. a)
            )
        )

        #_method
        (§ defn #_"void" ensureEditable [#_"TransientArrayMap" this]
            (when (nil? owner)
                (throw (IllegalAccessError. "Transient used after persistent! call"))
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" EMPTY (ß new PersistentHashMap(0, nil, false, nil)))
    (§ def- #_"Object" NOT_FOUND (Object.))

    (§ defn #_"IPersistentMap" create [#_"Map" other]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(§ var #_"Map.Entry" e (ß (Entry) o))]
                    (§ ass ret (ß ret.assoc(e.getKey(), e.getValue())))
                )
            )
            (ß ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn #_"PersistentHashMap" create [#_"Object..." init]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 2))]
                (§ ass ret (ß ret.assoc(init[i], init[i + 1])))
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" createWithCheck [#_"Object..." init]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 2))]
                (§ ass ret (ß ret.assoc(init[i], init[i + 1])))
                (when (ß ret.count() != i / 2 + 1)
                    (throw (IllegalArgumentException. (ß "Duplicate key: " + init[i])))
                )
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" create [#_"ISeq" items]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next().next()))]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (§ ass ret (ß ret.assoc(items.first(), RT.second(items))))
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" createWithCheck [#_"ISeq" items]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" i 0)] (some? items) [(§ ass items (ß items.next().next()), i (ß i + 1))]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (§ ass ret (ß ret.assoc(items.first(), RT.second(items))))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + items.first())))
                )
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn #_"PersistentHashMap" create [#_"IPersistentMap" meta, #_"Object..." init]
        (ß create(init).withMeta(meta))
    )

    (§ init
        (§ field #_"int" count 0)
        (§ field #_"INode" root nil)
        (§ field #_"boolean" hasNull false)
        (§ field #_"Object" nullValue nil)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentHashMap" PersistentHashMap [#_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (ß super())]
            (§ ass (ß this.count) count)
            (§ ass (ß this.root) root)
            (§ ass (ß this.hasNull) hasNull)
            (§ ass (ß this.nullValue) nullValue)
            (§ ass (ß this._meta) nil)
            this
        )
    )

    (§ constructor #_"PersistentHashMap" PersistentHashMap [#_"IPersistentMap" meta, #_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (ß super())]
            (§ ass (ß this._meta) meta)
            (§ ass (ß this.count) count)
            (§ ass (ß this.root) root)
            (§ ass (ß this.hasNull) hasNull)
            (§ ass (ß this.nullValue) nullValue)
            this
        )
    )

    (§ defn #_"int" hash [#_"Object" k]
        (ß Util.hasheq(k))
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentHashMap" this, #_"Object" key]
        (when (nil? key)
            (§ return hasNull)
        )
        (ß (root != nil) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false)
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"PersistentHashMap" this, #_"Object" key]
        (when (nil? key)
            (§ return (ß hasNull ? (IMapEntry) MapEntry.create(nil, nullValue) :or nil))
        )
        (ß (root != nil) ? root.find(0, hash(key), key) :or nil)
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (when (nil? key)
            (when (ß hasNull && val == nullValue)
                (§ return this)
            )
            (§ return (ß new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)))
        )
        (let [#_"Box" addedLeaf (Box. nil)]
            (let [#_"INode" newroot (ß ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf))]
                (when (ß newroot == root)
                    (§ return this)
                )
                (ß new PersistentHashMap(meta(), (addedLeaf.val == nil) ? count :or count + 1, newroot, hasNull, nullValue))
            )
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentHashMap" this, #_"Object" key, #_"Object" notFound]
        (when (nil? key)
            (§ return (ß hasNull ? nullValue :or notFound))
        )
        (ß (root != nil) ? root.find(0, hash(key), key, notFound) :or notFound)
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentHashMap" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (when (ß containsKey(key))
            (throw (ß Util.runtimeException("Key already present")))
        )
        (ß assoc(key, val))
    )

    #_method
    (§ defn #_"IPersistentMap" without [#_"PersistentHashMap" this, #_"Object" key]
        (when (nil? key)
            (§ return (ß hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        (when (nil? root)
            (§ return this)
        )
        (let [#_"INode" newroot (ß root.without(0, hash(key), key))]
            (when (ß newroot == root)
                (§ return this)
            )
            (ß new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue))
        )
    )

    (§ def #_"Iterator" EMPTY_ITER
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn- #_"Iterator" iterator [#_"PersistentHashMap" this, #_"IFn" f]
        (let [#_"Iterator" rootIter (ß (root == nil) ? EMPTY_ITER :or root.iterator(f))]
            (if hasNull
                (do
                    (§ reify Iterator()
                        (§ init
                            (§ field- #_"boolean" seen false)
                        )

                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (if (ß !seen)
                                (do
                                    true
                                )
                                (do
                                    (ß rootIter.hasNext())
                                )
                            )
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (if (ß !seen)
                                (do
                                    (§ ass seen true)
                                    (ß f.invoke(nil, nullValue))
                                )
                                (do
                                    (ß rootIter.next())
                                )
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
                (do
                    rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap.MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap.MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap.MAKE_VAL))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentHashMap" this, #_"IFn" f, #_"Object" init]
        (§ ass init (ß hasNull ? f.invoke(init, nil, nullValue) :or init))
        (when (ß RT.isReduced(init))
            (§ return (ß ((IDeref)init).deref()))
        )
        (when (some? root)
            (§ ass init (ß root.kvreduce(f, init)))
            (if (ß RT.isReduced(init))
                (do
                    (§ return (ß ((IDeref)init).deref()))
                )
                (do
                    (§ return init)
                )
            )
        )
        init
    )

    #_method
    (§ defn #_"Object" fold [#_"PersistentHashMap" this, #_"long" n, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjinvoke, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" top
                (§ reify Callable()
                    #_method
                    (§ defn #_"Object" call [#_"Callable" this] (§ throws Exception)
                        (let [#_"Object" ret (ß combinef.invoke())]
                            (when (some? root)
                                (§ ass ret (ß combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin))))
                            )
                            (ß hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), nil, nullValue)) :or ret)
                        )
                    )
                )]
            (ß fjinvoke.invoke(top))
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentHashMap" this]
        count
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentHashMap" this]
        (let [#_"ISeq" s (ß (root != nil) ? root.nodeSeq() :or nil)]
            (ß hasNull ? new Cons(MapEntry.create(nil, nullValue), s) :or s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentHashMap" this]
        (ß EMPTY.withMeta(meta()))
    )

    (§ defn #_"int" mask [#_"int" hash, #_"int" shift]
        (ß (hash >>> shift) & 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" withMeta [#_"PersistentHashMap" this, #_"IPersistentMap" meta]
        (ß new PersistentHashMap(meta, count, root, hasNull, nullValue))
    )

    #_method
    (§ defn #_"TransientHashMap" asTransient [#_"PersistentHashMap" this]
        (TransientHashMap. this)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentHashMap" this]
        (ß _meta)
    )

    (class-ns TransientHashMap (§ extends ATransientMap)
        (§ init
            (§ field #_"AtomicReference<Thread>" edit nil)
            #_volatile
            (§ field #_"INode" root nil)
            #_volatile
            (§ field #_"int" count 0)
            #_volatile
            (§ field #_"boolean" hasNull false)
            #_volatile
            (§ field #_"Object" nullValue nil)
            (§ field #_"Box" leafFlag (Box. nil))
        )

        (§ constructor #_"TransientHashMap" TransientHashMap [#_"PersistentHashMap" m]
            (let [this (ß this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue))]
                this
            )
        )

        (§ constructor #_"TransientHashMap" TransientHashMap [#_"AtomicReference<Thread>" edit, #_"INode" root, #_"int" count, #_"boolean" hasNull, #_"Object" nullValue]
            (let [this (ß super())]
                (§ ass (ß this.edit) edit)
                (§ ass (ß this.root) root)
                (§ ass (ß this.count) count)
                (§ ass (ß this.hasNull) hasNull)
                (§ ass (ß this.nullValue) nullValue)
                this
            )
        )

        #_method
        (§ defn #_"ITransientMap" doAssoc [#_"TransientHashMap" this, #_"Object" key, #_"Object" val]
            (when (nil? key)
                (when (ß this.nullValue != val)
                    (§ ass (ß this.nullValue) val)
                )
                (when (ß !hasNull)
                    (§ ass (ß this.count) (ß this.count + 1))
                    (§ ass (ß this.hasNull) true)
                )
                (§ return this)
            )
            (§ ass (ß leafFlag.val) nil)
            (let [#_"INode" n (ß ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag))]
                (when (ß n != this.root)
                    (§ ass (ß this.root) n)
                )
                (when (ß leafFlag.val != nil)
                    (§ ass (ß this.count) (ß this.count + 1))
                )
                this
            )
        )

        #_method
        (§ defn #_"ITransientMap" doWithout [#_"TransientHashMap" this, #_"Object" key]
            (when (nil? key)
                (when (ß !hasNull)
                    (§ return this)
                )
                (§ ass hasNull false)
                (§ ass nullValue nil)
                (§ ass (ß this.count) (ß this.count - 1))
                (§ return this)
            )
            (when (nil? root)
                (§ return this)
            )
            (§ ass (ß leafFlag.val) nil)
            (let [#_"INode" n (ß root.without(edit, 0, hash(key), key, leafFlag))]
                (when (ß n != root)
                    (§ ass (ß this.root) n)
                )
                (when (ß leafFlag.val != nil)
                    (§ ass (ß this.count) (ß this.count - 1))
                )
                this
            )
        )

        #_method
        (§ defn #_"IPersistentMap" doPersistent [#_"TransientHashMap" this]
            (ß edit.set(nil))
            (ß new PersistentHashMap(count, root, hasNull, nullValue))
        )

        #_method
        (§ defn #_"Object" doValAt [#_"TransientHashMap" this, #_"Object" key, #_"Object" notFound]
            (when (nil? key)
                (if hasNull
                    (do
                        (§ return nullValue)
                    )
                    (do
                        (§ return notFound)
                    )
                )
            )
            (when (nil? root)
                (§ return notFound)
            )
            (ß root.find(0, hash(key), key, notFound))
        )

        #_method
        (§ defn #_"int" doCount [#_"TransientHashMap" this]
            count
        )

        #_method
        (§ defn #_"void" ensureEditable [#_"TransientHashMap" this]
            (when (ß edit.get() == nil)
                (throw (IllegalAccessError. "Transient used after persistent! call"))
            )
            nil
        )
    )

    (§ interface INode
        #_abstract
        (#_"INode" assoc [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
        #_abstract
        (#_"INode" without [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
        #_abstract
        (#_"IMapEntry" find [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
        #_abstract
        (#_"Object" find [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound])
        #_abstract
        (#_"ISeq" nodeSeq [#_"INode" this])
        #_abstract
        (#_"INode" assoc [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
        #_abstract
        (#_"INode" without [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf])
        #_abstract
        (#_"Object" kvreduce [#_"INode" this, #_"IFn" f, #_"Object" init])
        #_abstract
        (#_"Object" fold [#_"INode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin])
        ;; returns the result of (f [k v]) for each iterated element
        #_abstract
        (#_"Iterator" iterator [#_"INode" this, #_"IFn" f])
    )

    (class-ns ArrayNode (§ implements INode)
        (§ init
            (§ field #_"int" count 0)
            (§ field #_"INode[]" array nil)
            (§ field #_"AtomicReference<Thread>" edit nil)
        )

        (§ constructor #_"ArrayNode" ArrayNode [#_"AtomicReference<Thread>" edit, #_"int" count, #_"INode[]" array]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.edit) edit)
                (§ ass (ß this.count) count)
                this
            )
        )

        #_method
        (§ defn #_"INode" assoc [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (nil? node)
                        (§ return (ß new ArrayNode(nil, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))))
                    )
                    (let [#_"INode" n (ß node.assoc(shift + 5, hash, key, val, addedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (nil? node)
                        (§ return this)
                    )
                    (let [#_"INode" n (ß node.without(shift + 5, hash, key))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (if (nil? n)
                            (do
                                (when (ß count <= 8) ;; shrink
                                    (§ return (ß pack(nil, idx)))
                                )
                                (ß new ArrayNode(nil, count - 1, cloneAndSet(array, idx, n)))
                            )
                            (do
                                (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"IMapEntry" find [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (nil? node)
                        (§ return nil)
                    )
                    (ß node.find(shift + 5, hash, key))
                )
            )
        )

        #_method
        (§ defn #_"Object" find [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (nil? node)
                        (§ return notFound)
                    )
                    (ß node.find(shift + 5, hash, key, notFound))
                )
            )
        )

        #_method
        (§ defn #_"ISeq" nodeSeq [#_"ArrayNode" this]
            (ß PersistentHashMap'Seq.create(array))
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"ArrayNode" this, #_"IFn" f]
            (ß new PersistentHashMap'Iter(array, f))
        )

        #_method
        (§ defn #_"Object" kvreduce [#_"ArrayNode" this, #_"IFn" f, #_"Object" init]
            (doseq [#_"INode" node array]
                (when (some? node)
                    (§ ass init (ß node.kvreduce(f, init)))
                    (when (ß RT.isReduced(init))
                        (§ return init)
                    )
                )
            )
            init
        )

        #_method
        (§ defn #_"Object" fold [#_"ArrayNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (let [#_"List<Callable>" tasks (ArrayList.)]
                (doseq [#_"INode" node array]
                    (when (some? node)
                        (ß tasks.add(
                                (§ reify Callable()
                                    #_method
                                    (§ defn #_"Object" call [#_"Callable" this] (§ throws Exception)
                                        (ß node.fold(combinef, reducef, fjtask, fjfork, fjjoin))
                                    )
                                )
                            )
                        )
                    )
                )

                (ß foldTasks(tasks, combinef, fjtask, fjfork, fjjoin))
            )
        )

        (§ defn #_"Object" foldTasks [#_"List<Callable>" tasks, #_"IFn" combinef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (when (ß tasks.isEmpty())
                (§ return (ß combinef.invoke()))
            )

            (when (ß tasks.size() == 1)
                (let [#_"Object" ret nil]
                    (try
                        (§ return (ß tasks.get(0).call()))
                        (catch Exception e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
            )

            (let [#_"List<Callable>" t1 (ß tasks.subList(0, tasks.size() / 2))]
                (let [#_"List<Callable>" t2 (ß tasks.subList(tasks.size() / 2, tasks.size()))]
                    (let [#_"Object" forked
                            (ß fjfork.invoke(fjtask.invoke(
                                    (§ reify Callable()
                                        #_method
                                        (§ defn #_"Object" call [#_"Callable" this] (§ throws Exception)
                                            (ß foldTasks(t2, combinef, fjtask, fjfork, fjjoin))
                                        )
                                    )
                                ))
                            )]
                        (ß combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked)))
                    )
                )
            )
        )

        #_method
        (§ defn- #_"ArrayNode" ensureEditable [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit]
            (when (ß this.edit == edit)
                (§ return this)
            )
            (ß new ArrayNode(edit, count, this.array.clone()))
        )

        #_method
        (§ defn- #_"ArrayNode" editAndSet [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"INode" n]
            (let [#_"ArrayNode" editable (ß ensureEditable(edit))]
                (§ ass (ß editable.array[i]) n)
                editable
            )
        )

        #_method
        (§ defn- #_"INode" pack [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" idx]
            (let [#_"Object[]" newArray (ß new Object[2 * (count - 1)])]
                (let [#_"int" j 1]
                    (let [#_"int" bitmap 0]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < idx) [(§ ass i (ß i + 1))]
                            (when (ß array[i] != nil)
                                (§ ass (ß newArray[j]) (ß array[i]))
                                (§ ass bitmap (ß bitmap | (1 << i)))
                                (§ ass j (ß j + 2))
                            )
                        )
                        (loop-when-recur [(§ var #_"int" i (ß idx + 1))] (ß i < array.length) [(§ ass i (ß i + 1))]
                            (when (ß array[i] != nil)
                                (§ ass (ß newArray[j]) (ß array[i]))
                                (§ ass bitmap (ß bitmap | (1 << i)))
                                (§ ass j (ß j + 2))
                            )
                        )
                        (ß new BitmapIndexedNode(edit, bitmap, newArray))
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" assoc [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (nil? node)
                        (let [#_"ArrayNode" editable (ß editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)))]
                            (§ ass (ß editable.count) (ß editable.count + 1))
                            (§ return editable)
                        )
                    )
                    (let [#_"INode" n (ß node.assoc(edit, shift + 5, hash, key, val, addedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (ß editAndSet(edit, idx, n))
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (nil? node)
                        (§ return this)
                    )
                    (let [#_"INode" n (ß node.without(edit, shift + 5, hash, key, removedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (when (nil? n)
                            (when (ß count <= 8) ;; shrink
                                (§ return (ß pack(edit, idx)))
                            )
                            (let [#_"ArrayNode" editable (ß editAndSet(edit, idx, n))]
                                (§ ass (ß editable.count) (ß editable.count - 1))
                                (§ return editable)
                            )
                        )
                        (ß editAndSet(edit, idx, n))
                    )
                )
            )
        )

        (class-ns PersistentHashMap'Seq (§ extends ASeq)
            (§ defn #_"ISeq" create [#_"INode[]" nodes]
                (ß create(nil, nodes, 0, nil))
            )

            (§ defn- #_"ISeq" create [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
                (when (some? s)
                    (§ return (ß new PersistentHashMap'Seq(meta, nodes, i, s)))
                )
                (loop-when-recur [(§ var #_"int" j i)] (ß j < nodes.length) [(§ ass j (ß j + 1))]
                    (when (ß nodes[j] != nil)
                        (let [#_"ISeq" ns (ß nodes[j].nodeSeq())]
                            (when (some? ns)
                                (§ return (ß new PersistentHashMap'Seq(meta, nodes, j + 1, ns)))
                            )
                        )
                    )
                )
                nil
            )

            (§ init
                (§ field #_"INode[]" nodes nil)
                (§ field #_"int" i 0)
                (§ field #_"ISeq" s nil)
            )

            (§ constructor- #_"PersistentHashMap'Seq" PersistentHashMap'Seq [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
                (let [this (ß super(meta))]
                    (§ ass (ß this.nodes) nodes)
                    (§ ass (ß this.i) i)
                    (§ ass (ß this.s) s)
                    this
                )
            )

            #_method
            (§ defn #_"Obj" withMeta [#_"PersistentHashMap'Seq" this, #_"IPersistentMap" meta]
                (ß new PersistentHashMap'Seq(meta, nodes, i, s))
            )

            #_method
            (§ defn #_"Object" first [#_"PersistentHashMap'Seq" this]
                (ß s.first())
            )

            #_method
            (§ defn #_"ISeq" next [#_"PersistentHashMap'Seq" this]
                (ß create(nil, nodes, i, s.next()))
            )
        )

        (class-ns PersistentHashMap'Iter (§ implements Iterator)
            (§ init
                (§ field- #_"INode[]" array nil)
                (§ field- #_"IFn" f nil)
                (§ field- #_"int" i 0)
                (§ field- #_"Iterator" nestedIter nil)
            )

            (§ constructor- #_"PersistentHashMap'Iter" PersistentHashMap'Iter [#_"INode[]" array, #_"IFn" f]
                (let [this (ß super())]
                    (§ ass (ß this.array) array)
                    (§ ass (ß this.f) f)
                    this
                )
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"PersistentHashMap'Iter" this]
                (while true
                    (when (some? nestedIter)
                        (if (ß nestedIter.hasNext())
                            (do
                                (§ return true)
                            )
                            (do
                                (§ ass nestedIter nil)
                            )
                        )
                    )

                    (if (ß i < array.length)
                        (do
                            (let [#_"INode" node (ß array[i])]
                                (§ ass i (ß i + 1))
                                (when (some? node)
                                    (§ ass nestedIter (ß node.iterator(f)))
                                )
                            )
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )

            #_method
            (§ defn #_"Object" next [#_"PersistentHashMap'Iter" this]
                (if (ß hasNext())
                    (do
                        (ß nestedIter.next())
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"PersistentHashMap'Iter" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    (class-ns BitmapIndexedNode (§ implements INode)
        (§ def #_"BitmapIndexedNode" EMPTY (ß new BitmapIndexedNode(nil, 0, new Object[0])))

        (§ init
            (§ field #_"int" bitmap 0)
            (§ field #_"Object[]" array nil)
            (§ field #_"AtomicReference<Thread>" edit nil)
        )

        (§ constructor #_"BitmapIndexedNode" BitmapIndexedNode [#_"AtomicReference<Thread>" edit, #_"int" bitmap, #_"Object[]" array]
            (let [this (ß super())]
                (§ ass (ß this.bitmap) bitmap)
                (§ ass (ß this.array) array)
                (§ ass (ß this.edit) edit)
                this
            )
        )

        #_method
        (§ defn #_"int" index [#_"BitmapIndexedNode" this, #_"int" bit]
            (ß Integer.bitCount(bitmap & (bit - 1)))
        )

        #_method
        (§ defn #_"INode" assoc [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (let [#_"int" idx (ß index(bit))]
                    (if (ß (bitmap & bit) != 0)
                        (do
                            (let [#_"Object" keyOrNull (ß array[2 * idx])]
                                (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                                    (when (nil? keyOrNull)
                                        (let [#_"INode" n (ß ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf))]
                                            (when (ß n == valOrNode)
                                                (§ return this)
                                            )
                                            (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                                        )
                                    )
                                    (when (ß Util.equiv(key, keyOrNull))
                                        (when (ß val == valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, val))))
                                    )
                                    (§ ass (ß addedLeaf.val) addedLeaf)
                                    (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx, nil, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val))))
                                )
                            )
                        )
                        (do
                            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                                (if (ß n >= 16)
                                    (do
                                        (let [#_"INode[]" nodes (ß new INode[32])]
                                            (let [#_"int" jdx (ß mask(hash, shift))]
                                                (§ ass (ß nodes[jdx]) (ß EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))
                                                (let [#_"int" j 0]
                                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < 32) [(§ ass i (ß i + 1))]
                                                        (when (ß ((bitmap >>> i) & 1) != 0)
                                                            (if (ß array[j] == nil)
                                                                (do
                                                                    (§ ass (ß nodes[i]) (ß (INode) array[j + 1]))
                                                                )
                                                                (do
                                                                    (§ ass (ß nodes[i]) (ß EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf)))
                                                                )
                                                            )
                                                            (§ ass j (ß j + 2))
                                                        )
                                                    )
                                                    (ß new ArrayNode(nil, n + 1, nodes))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Object[]" newArray (ß new Object[2 * (n + 1)])]
                                            (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                                            (§ ass (ß newArray[2 * idx]) key)
                                            (§ ass (ß addedLeaf.val) addedLeaf)
                                            (§ ass (ß newArray[2 * idx + 1]) val)
                                            (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                                            (ß new BitmapIndexedNode(nil, bitmap | bit, newArray))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return this)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (nil? keyOrNull)
                                (let [#_"INode" n (ß ((INode) valOrNode).without(shift + 5, hash, key))]
                                    (when (ß n == valOrNode)
                                        (§ return this)
                                    )
                                    (when (some? n)
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                                    )
                                    (when (ß bitmap == bit)
                                        (§ return nil)
                                    )
                                    (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
                                )
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                ;; TODO: collapse
                                (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
                            )
                            this
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"IMapEntry" find [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return nil)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (nil? keyOrNull)
                                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key)))
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ return (ß (IMapEntry) MapEntry.create(keyOrNull, valOrNode)))
                            )
                            nil
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" find [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return notFound)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (nil? keyOrNull)
                                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key, notFound)))
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ return valOrNode)
                            )
                            notFound
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"ISeq" nodeSeq [#_"BitmapIndexedNode" this]
            (ß NodeSeq.create(array))
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"BitmapIndexedNode" this, #_"IFn" f]
            (ß new NodeIter(array, f))
        )

        #_method
        (§ defn #_"Object" kvreduce [#_"BitmapIndexedNode" this, #_"IFn" f, #_"Object" init]
            (ß NodeSeq.kvreduce(array, f, init))
        )

        #_method
        (§ defn #_"Object" fold [#_"BitmapIndexedNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" ensureEditable [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit]
            (when (ß this.edit == edit)
                (§ return this)
            )
            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                (let [#_"Object[]" newArray (ß new Object[(n >= 0) ? 2 * (n + 1) :or 4])] ;; make room for next assoc
                    (ß System.arraycopy(array, 0, newArray, 0, 2 * n))
                    (ß new BitmapIndexedNode(edit, bitmap, newArray))
                )
            )
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (§ ass (ß editable.array[i]) a)
                editable
            )
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (§ ass (ß editable.array[i]) a)
                (§ ass (ß editable.array[j]) b)
                editable
            )
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" editAndRemovePair [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" bit, #_"int" i]
            (when (ß bitmap == bit)
                (§ return nil)
            )
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (§ ass (ß editable.bitmap) (ß editable.bitmap :xor bit))
                (ß System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1)))
                (§ ass (ß editable.array[editable.array.length - 2]) nil)
                (§ ass (ß editable.array[editable.array.length - 1]) nil)
                editable
            )
        )

        #_method
        (§ defn #_"INode" assoc [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (let [#_"int" idx (ß index(bit))]
                    (if (ß (bitmap & bit) != 0)
                        (do
                            (let [#_"Object" keyOrNull (ß array[2 * idx])]
                                (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                                    (when (nil? keyOrNull)
                                        (let [#_"INode" n (ß ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf))]
                                            (when (ß n == valOrNode)
                                                (§ return this)
                                            )
                                            (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                                        )
                                    )
                                    (when (ß Util.equiv(key, keyOrNull))
                                        (when (ß val == valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß editAndSet(edit, 2 * idx + 1, val)))
                                    )
                                    (§ ass (ß addedLeaf.val) addedLeaf)
                                    (ß editAndSet(edit, 2 * idx, nil, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val)))
                                )
                            )
                        )
                        (do
                            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                                (when (ß n * 2 < array.length)
                                    (§ ass (ß addedLeaf.val) addedLeaf)
                                    (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                                        (ß System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx)))
                                        (§ ass (ß editable.array[2 * idx]) key)
                                        (§ ass (ß editable.array[2 * idx + 1]) val)
                                        (§ ass (ß editable.bitmap) (ß editable.bitmap | bit))
                                        (§ return editable)
                                    )
                                )
                                (if (ß n >= 16)
                                    (do
                                        (let [#_"INode[]" nodes (ß new INode[32])]
                                            (let [#_"int" jdx (ß mask(hash, shift))]
                                                (§ ass (ß nodes[jdx]) (ß EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)))
                                                (let [#_"int" j 0]
                                                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < 32) [(§ ass i (ß i + 1))]
                                                        (when (ß ((bitmap >>> i) & 1) != 0)
                                                            (if (ß array[j] == nil)
                                                                (do
                                                                    (§ ass (ß nodes[i]) (ß (INode) array[j + 1]))
                                                                )
                                                                (do
                                                                    (§ ass (ß nodes[i]) (ß EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf)))
                                                                )
                                                            )
                                                            (§ ass j (ß j + 2))
                                                        )
                                                    )
                                                    (ß new ArrayNode(edit, n + 1, nodes))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Object[]" newArray (ß new Object[2 * (n + 4)])]
                                            (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                                            (§ ass (ß newArray[2 * idx]) key)
                                            (§ ass (ß addedLeaf.val) addedLeaf)
                                            (§ ass (ß newArray[2 * idx + 1]) val)
                                            (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                                            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                                                (§ ass (ß editable.array) newArray)
                                                (§ ass (ß editable.bitmap) (ß editable.bitmap | bit))
                                                editable
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return this)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (nil? keyOrNull)
                                (let [#_"INode" n (ß ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf))]
                                    (when (ß n == valOrNode)
                                        (§ return this)
                                    )
                                    (when (some? n)
                                        (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                                    )
                                    (when (ß bitmap == bit)
                                        (§ return nil)
                                    )
                                    (§ return (ß editAndRemovePair(edit, bit, idx)))
                                )
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ ass (ß removedLeaf.val) removedLeaf)
                                ;; TODO: collapse
                                (§ return (ß editAndRemovePair(edit, bit, idx)))
                            )
                            this
                        )
                    )
                )
            )
        )
    )

    (class-ns HashCollisionNode (§ implements INode)
        (§ init
            (§ field #_"int" hash 0)
            (§ field #_"int" count 0)
            (§ field #_"Object[]" array nil)
            (§ field #_"AtomicReference<Thread>" edit nil)
        )

        (§ constructor #_"HashCollisionNode" HashCollisionNode [#_"AtomicReference<Thread>" edit, #_"int" hash, #_"int" count, #_"Object..." array]
            (let [this (ß super())]
                (§ ass (ß this.edit) edit)
                (§ ass (ß this.hash) hash)
                (§ ass (ß this.count) count)
                (§ ass (ß this.array) array)
                this
            )
        )

        #_method
        (§ defn #_"INode" assoc [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (when (ß hash == this.hash)
                (let [#_"int" idx (ß findIndex(key))]
                    (when (ß idx != -1)
                        (when (ß array[idx + 1] == val)
                            (§ return this)
                        )
                        (§ return (ß new HashCollisionNode(nil, hash, count, cloneAndSet(array, idx + 1, val))))
                    )
                    (let [#_"Object[]" newArray (ß new Object[2 * (count + 1)])]
                        (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                        (§ ass (ß newArray[2 * count]) key)
                        (§ ass (ß newArray[2 * count + 1]) val)
                        (§ ass (ß addedLeaf.val) addedLeaf)
                        (§ return (ß new HashCollisionNode(edit, hash, count + 1, newArray)))
                    )
                )
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(nil, bitpos(this.hash, shift), new Object[] (§ array nil, this )).assoc(shift, hash, key, val, addedLeaf))
        )

        #_method
        (§ defn #_"INode" without [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx == -1)
                    (§ return this)
                )
                (when (ß count == 1)
                    (§ return nil)
                )
                (ß new HashCollisionNode(nil, hash, count - 1, removePair(array, idx / 2)))
            )
        )

        #_method
        (§ defn #_"IMapEntry" find [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx < 0)
                    (§ return nil)
                )
                (when (ß Util.equiv(key, array[idx]))
                    (§ return (ß (IMapEntry) MapEntry.create(array[idx], array[idx + 1])))
                )
                nil
            )
        )

        #_method
        (§ defn #_"Object" find [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx < 0)
                    (§ return notFound)
                )
                (when (ß Util.equiv(key, array[idx]))
                    (§ return (ß array[idx + 1]))
                )
                notFound
            )
        )

        #_method
        (§ defn #_"ISeq" nodeSeq [#_"HashCollisionNode" this]
            (ß NodeSeq.create(array))
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"HashCollisionNode" this, #_"IFn" f]
            (ß new NodeIter(array, f))
        )

        #_method
        (§ defn #_"Object" kvreduce [#_"HashCollisionNode" this, #_"IFn" f, #_"Object" init]
            (ß NodeSeq.kvreduce(array, f, init))
        )

        #_method
        (§ defn #_"Object" fold [#_"HashCollisionNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        #_method
        (§ defn #_"int" findIndex [#_"HashCollisionNode" this, #_"Object" key]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < 2 * count) [(§ ass i (ß i + 2))]
                (when (ß Util.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )

        #_method
        (§ defn- #_"HashCollisionNode" ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit]
            (when (ß this.edit == edit)
                (§ return this)
            )
            (let [#_"Object[]" newArray (ß new Object[2 * (count + 1)])] ;; make room for next assoc
                (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                (ß new HashCollisionNode(edit, hash, count, newArray))
            )
        )

        #_method
        (§ defn- #_"HashCollisionNode" ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" count, #_"Object[]" array]
            (when (ß this.edit == edit)
                (§ ass (ß this.array) array)
                (§ ass (ß this.count) count)
                (§ return this)
            )
            (ß new HashCollisionNode(edit, hash, count, array))
        )

        #_method
        (§ defn- #_"HashCollisionNode" editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
            (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                (§ ass (ß editable.array[i]) a)
                editable
            )
        )

        #_method
        (§ defn- #_"HashCollisionNode" editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
            (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                (§ ass (ß editable.array[i]) a)
                (§ ass (ß editable.array[j]) b)
                editable
            )
        )

        #_method
        (§ defn #_"INode" assoc [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (when (ß hash == this.hash)
                (let [#_"int" idx (ß findIndex(key))]
                    (when (ß idx != -1)
                        (when (ß array[idx + 1] == val)
                            (§ return this)
                        )
                        (§ return (ß editAndSet(edit, idx + 1, val)))
                    )
                    (when (ß array.length > 2 * count)
                        (§ ass (ß addedLeaf.val) addedLeaf)
                        (let [#_"HashCollisionNode" editable (ß editAndSet(edit, 2 * count, key, 2 * count + 1, val))]
                            (§ ass (ß editable.count) (ß editable.count + 1))
                            (§ return editable)
                        )
                    )
                    (let [#_"Object[]" newArray (ß new Object[array.length + 2])]
                        (ß System.arraycopy(array, 0, newArray, 0, array.length))
                        (§ ass (ß newArray[array.length]) key)
                        (§ ass (ß newArray[array.length + 1]) val)
                        (§ ass (ß addedLeaf.val) addedLeaf)
                        (§ return (ß ensureEditable(edit, count + 1, newArray)))
                    )
                )
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ array nil, this, nil, nil )).assoc(edit, shift, hash, key, val, addedLeaf))
        )

        #_method
        (§ defn #_"INode" without [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx == -1)
                    (§ return this)
                )
                (§ ass (ß removedLeaf.val) removedLeaf)
                (when (ß count == 1)
                    (§ return nil)
                )
                (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                    (§ ass (ß editable.array[idx]) (ß editable.array[2 * count - 2]))
                    (§ ass (ß editable.array[idx + 1]) (ß editable.array[2 * count - 1]))
                    (§ ass (ß editable.array[2 * count - 2]) (§ ass (ß editable.array[2 * count - 1]) nil))
                    (§ ass (ß editable.count) (ß editable.count - 1))
                    editable
                )
            )
        )
    )

    (§ defn- #_"INode[]" cloneAndSet [#_"INode[]" array, #_"int" i, #_"INode" a]
        (let [#_"INode[]" clone (ß array.clone())]
            (§ ass (ß clone[i]) a)
            clone
        )
    )

    (§ defn- #_"Object[]" cloneAndSet [#_"Object[]" array, #_"int" i, #_"Object" a]
        (let [#_"Object[]" clone (ß array.clone())]
            (§ ass (ß clone[i]) a)
            clone
        )
    )

    (§ defn- #_"Object[]" cloneAndSet [#_"Object[]" array, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
        (let [#_"Object[]" clone (ß array.clone())]
            (§ ass (ß clone[i]) a)
            (§ ass (ß clone[j]) b)
            clone
        )
    )

    (§ defn- #_"Object[]" removePair [#_"Object[]" array, #_"int" i]
        (let [#_"Object[]" newArray (ß new Object[array.length - 2])]
            (ß System.arraycopy(array, 0, newArray, 0, 2 * i))
            (ß System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i))
            newArray
        )
    )

    (§ defn- #_"INode" createNode [#_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (ß hash(key1))]
            (when (ß key1hash == key2hash)
                (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ array key1, val1, key2, val2 ))))
            )
            (let [#_"Box" addedLeaf (Box. nil)]
                (let [#_"AtomicReference<Thread>" edit (ß new AtomicReference<Thread>())]
                    (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
                )
            )
        )
    )

    (§ defn- #_"INode" createNode [#_"AtomicReference<Thread>" edit, #_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (ß hash(key1))]
            (when (ß key1hash == key2hash)
                (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ array key1, val1, key2, val2 ))))
            )
            (let [#_"Box" addedLeaf (Box. nil)]
                (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
            )
        )
    )

    (§ defn- #_"int" bitpos [#_"int" hash, #_"int" shift]
        (ß 1 << mask(hash, shift))
    )

    (class-ns NodeIter (§ implements Iterator)
        (§ def- #_"Object" NULL (Object.))

        (§ init
            (§ field #_"Object[]" array nil)
            (§ field #_"IFn" f nil)
            (§ field- #_"int" i 0)
            (§ field- #_"Object" nextEntry NULL)
            (§ field- #_"Iterator" nextIter nil)
        )

        (§ constructor #_"NodeIter" NodeIter [#_"Object[]" array, #_"IFn" f]
            (let [this (ß super())]
                (§ ass (ß this.array) array)
                (§ ass (ß this.f) f)
                this
            )
        )

        #_method
        (§ defn- #_"boolean" advance [#_"NodeIter" this]
            (while (ß i < array.length)
                (let [#_"Object" key (ß array[i])]
                    (let [#_"Object" nodeOrVal (ß array[i + 1])]
                        (§ ass i (ß i + 2))
                        (cond (some? key)
                            (do
                                (§ ass nextEntry (ß f.invoke(key, nodeOrVal)))
                                (§ return true)
                            )
                            (some? nodeOrVal)
                            (do
                                (let [#_"Iterator" iter (ß ((INode) nodeOrVal).iterator(f))]
                                    (when (ß iter != nil && iter.hasNext())
                                        (§ ass nextIter iter)
                                        (§ return true)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            false
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"NodeIter" this]
            (when (ß nextEntry != NULL || nextIter != nil)
                (§ return true)
            )
            (ß advance())
        )

        #_method
        (§ defn #_"Object" next [#_"NodeIter" this]
            (let [#_"Object" ret nextEntry]
                (cond (ß ret != NULL)
                    (do
                        (§ ass nextEntry NULL)
                        (§ return ret)
                    )
                    (some? nextIter)
                    (do
                        (§ ass ret (ß nextIter.next()))
                        (when (ß !nextIter.hasNext())
                            (§ ass nextIter nil)
                        )
                        (§ return ret)
                    )
                    (ß advance())
                    (do
                        (§ return (ß next()))
                    )
                )
                (throw (NoSuchElementException.))
            )
        )

        #_method
        (§ defn #_"void" remove [#_"NodeIter" this]
            (throw (UnsupportedOperationException.))
        )
    )

    (class-ns NodeSeq (§ extends ASeq)
        (§ init
            (§ field #_"Object[]" array nil)
            (§ field #_"int" i 0)
            (§ field #_"ISeq" s nil)
        )

        (§ constructor #_"NodeSeq" NodeSeq [#_"Object[]" array, #_"int" i]
            (let [this (ß this(nil, array, i, nil))]
                this
            )
        )

        (§ defn #_"ISeq" create [#_"Object[]" array]
            (ß create(array, 0, nil))
        )

        (§ defn #_"Object" kvreduce [#_"Object[]" array, #_"IFn" f, #_"Object" init]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < array.length) [(§ ass i (ß i + 2))]
                (if (ß array[i] != nil)
                    (do
                        (§ ass init (ß f.invoke(init, array[i], array[i + 1])))
                    )
                    (do
                        (let [#_"INode" node (ß (INode) array[i + 1])]
                            (when (some? node)
                                (§ ass init (ß node.kvreduce(f, init)))
                            )
                        )
                    )
                )
                (when (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            init
        )

        (§ defn- #_"ISeq" create [#_"Object[]" array, #_"int" i, #_"ISeq" s]
            (when (some? s)
                (§ return (ß new NodeSeq(nil, array, i, s)))
            )
            (loop-when-recur [(§ var #_"int" j i)] (ß j < array.length) [(ß j+=2)]
                (when (ß array[j] != nil)
                    (§ return (ß new NodeSeq(nil, array, j, nil)))
                )
                (let [#_"INode" node (ß (INode) array[j + 1])]
                    (when (some? node)
                        (let [#_"ISeq" nodeSeq (ß node.nodeSeq())]
                            (when (some? nodeSeq)
                                (§ return (ß new NodeSeq(nil, array, j + 2, nodeSeq)))
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ constructor #_"NodeSeq" NodeSeq [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i, #_"ISeq" s]
            (let [this (ß super(meta))]
                (§ ass (ß this.array) array)
                (§ ass (ß this.i) i)
                (§ ass (ß this.s) s)
                this
            )
        )

        #_method
        (§ defn #_"Obj" withMeta [#_"NodeSeq" this, #_"IPersistentMap" meta]
            (ß new NodeSeq(meta, array, i, s))
        )

        #_method
        (§ defn #_"Object" first [#_"NodeSeq" this]
            (when (some? s)
                (§ return (ß s.first()))
            )
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        #_method
        (§ defn #_"ISeq" next [#_"NodeSeq" this]
            (when (some? s)
                (§ return (ß create(array, i, s.next())))
            )
            (ß create(array, i + 2, nil))
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" EMPTY (ß new PersistentHashSet(nil, PersistentHashMap.EMPTY)))

    (§ defn #_"PersistentHashSet" create [#_"Object..." init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 1))]
                (§ ass ret (ß (ITransientSet)ret.conj(init[i])))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" create [#_"List" init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (doseq [#_"Object" key init]
                (§ ass ret (ß (ITransientSet) ret.conj(key)))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" create [#_"ISeq" items]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next()))]
                (§ ass ret (ß (ITransientSet) ret.conj(items.first())))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" createWithCheck [#_"Object..." init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < init.length) [(§ ass i (ß i + 1))]
                (§ ass ret (ß (ITransientSet) ret.conj(init[i])))
                (when (ß ret.count() != i + 1)
                    (throw (IllegalArgumentException. (ß "Duplicate key: " + init[i])))
                )
            )
            (ß (PersistentHashSet) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" createWithCheck [#_"List" init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (let [#_"int" i 0]
                (doseq [#_"Object" key init]
                    (§ ass ret (ß (ITransientSet) ret.conj(key)))
                    (when (ß ret.count() != i + 1)
                        (throw (IllegalArgumentException. (ß "Duplicate key: " + key)))
                    )
                    (§ ass i (ß i + 1))
                )
                (ß (PersistentHashSet) ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentHashSet" createWithCheck [#_"ISeq" items]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" i 0)] (some? items) [(§ ass items (ß items.next()), i (ß i + 1))]
                (§ ass ret (ß (ITransientSet) ret.conj(items.first())))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + items.first())))
                )
            )
            (ß (PersistentHashSet) ret.persistent())
        )
    )

    (§ init
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentHashSet" PersistentHashSet [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (ß super(impl))]
            (§ ass (ß this._meta) meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [#_"PersistentHashSet" this, #_"Object" key]
        (when (ß contains(key))
            (§ return (ß new PersistentHashSet(meta(), impl.without(key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [#_"PersistentHashSet" this, #_"Object" o]
        (when (ß contains(o))
            (§ return this)
        )
        (ß new PersistentHashSet(meta(), impl.assoc(o, o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentHashSet" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentHashSet" withMeta [#_"PersistentHashSet" this, #_"IPersistentMap" meta]
        (ß new PersistentHashSet(meta, impl))
    )

    #_method
    (§ defn #_"ITransientCollection" asTransient [#_"PersistentHashSet" this]
        (ß new TransientHashSet(((PersistentHashMap) impl).asTransient()))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentHashSet" this]
        (ß _meta)
    )

    #_stateless
    (class-ns TransientHashSet (§ extends ATransientSet)
        (§ constructor #_"TransientHashSet" TransientHashSet [#_"ITransientMap" impl]
            (let [this (ß super(impl))]
                this
            )
        )

        #_method
        (§ defn #_"IPersistentCollection" persistent [#_"TransientHashSet" this]
            (ß new PersistentHashSet(nil, impl.persistent()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    #_stateless
    (class-ns Primordial (§ extends RestFn)
        #_method
        (§ defn #_"int" getRequiredArity [#_"Primordial" this]
            0
        )

        #_protected
        #_method
        (§ defn #_"Object" doInvoke [#_"Primordial" this, #_"Object" args]
            (when (ß args instanceof ArraySeq)
                (let [#_"Object[]" argsarray (ß ((ArraySeq) args).array)]
                    (let [#_"IPersistentList" ret EMPTY]
                        (loop-when-recur [(§ var #_"int" i (ß argsarray.length - 1))] (ß i >= ((ArraySeq)args).i) [(§ ass i (ß i - 1))]
                            (§ ass ret (ß (IPersistentList) ret.cons(argsarray[i])))
                        )
                        (§ return ret)
                    )
                )
            )
            (let [#_"LinkedList" list (LinkedList.)]
                (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(args)))] (some? s) [(§ ass s (ß s.next()))]
                    (ß list.add(s.first()))
                )
                (ß create(list))
            )
        )

        (§ defn #_"Object" invokeStatic [#_"ISeq" args]
            (when (ß args instanceof ArraySeq)
                (let [#_"Object[]" argsarray (ß ((ArraySeq) args).array)]
                    (let [#_"IPersistentList" ret EMPTY]
                        (loop-when-recur [(§ var #_"int" i (ß argsarray.length - 1))] (ß i >= 0) [(§ ass i (ß i - 1))]
                            (§ ass ret (ß (IPersistentList) ret.cons(argsarray[i])))
                        )
                        (§ return ret)
                    )
                )
            )
            (let [#_"LinkedList" list (LinkedList.)]
                (loop-when-recur [(§ var #_"ISeq" s (ß RT.seq(args)))] (some? s) [(§ ass s (ß s.next()))]
                    (ß list.add(s.first()))
                )
                (ß create(list))
            )
        )

        #_method
        (§ defn #_"IObj" withMeta [#_"Primordial" this, #_"IPersistentMap" meta]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"IPersistentMap" meta [#_"Primordial" this]
            nil
        )
    )

    (§ def #_"IFn" creator (Primordial.))

    (§ def #_"EmptyList" EMPTY (EmptyList. nil))

    (§ init
        (§ field- #_"Object" _first nil)
        (§ field- #_"IPersistentList" _rest nil)
        (§ field- #_"int" _count 0)
    )

    (§ constructor #_"PersistentList" PersistentList [#_"Object" first]
        (let [this (ß super())]
            (§ ass (ß this._first) first)
            (§ ass (ß this._rest) nil)

            (§ ass (ß this._count) 1)
            this
        )
    )

    (§ constructor #_"PersistentList" PersistentList [#_"IPersistentMap" meta, #_"Object" _first, #_"IPersistentList" _rest, #_"int" _count]
        (let [this (ß super(meta))]
            (§ ass (ß this._first) (ß _first))
            (§ ass (ß this._rest) (ß _rest))
            (§ ass (ß this._count) (ß _count))
            this
        )
    )

    (§ defn #_"IPersistentList" create [#_"List" init]
        (let [#_"IPersistentList" ret EMPTY]
            (loop-when-recur [(§ var #_"ListIterator" i (ß init.listIterator(init.size())))] (ß i.hasPrevious()) [(ß )]
                (§ ass ret (ß (IPersistentList) ret.cons(i.previous())))
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" first [#_"PersistentList" this]
        (ß _first)
    )

    #_method
    (§ defn #_"ISeq" next [#_"PersistentList" this]
        (when (ß _count == 1)
            (§ return nil)
        )
        (ß (ISeq) _rest)
    )

    #_method
    (§ defn #_"Object" peek [#_"PersistentList" this]
        (ß first())
    )

    #_method
    (§ defn #_"IPersistentList" pop [#_"PersistentList" this]
        (when (nil? _rest)
            (§ return (ß EMPTY.withMeta(_meta)))
        )
        (ß _rest)
    )

    #_method
    (§ defn #_"int" count [#_"PersistentList" this]
        (ß _count)
    )

    #_method
    (§ defn #_"PersistentList" cons [#_"PersistentList" this, #_"Object" o]
        (ß new PersistentList(meta(), o, this, _count + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentList" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentList" withMeta [#_"PersistentList" this, #_"IPersistentMap" meta]
        (when (ß meta != _meta)
            (§ return (ß new PersistentList(meta, _first, _rest, _count)))
        )
        this
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentList" this, #_"IFn" f]
        (let [#_"Object" ret (ß first())]
            (loop-when-recur [(§ var #_"ISeq" s (ß next()))] (some? s) [(§ ass s (ß s.next()))]
                (§ ass ret (ß f.invoke(ret, s.first())))
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentList" this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret (ß f.invoke(start, first()))]
            (loop-when-recur [(§ var #_"ISeq" s (ß next()))] (some? s) [(§ ass s (ß s.next()))]
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (§ ass ret (ß f.invoke(ret, s.first())))
            )
            (when (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )
    )

    #_stateless
    (class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
        (§ def #_"int" hasheq (ß Murmur3.hashOrdered(Collections.EMPTY_LIST)))

        (§ constructor #_"EmptyList" EmptyList [#_"IPersistentMap" meta]
            (let [this (ß super(meta))]
                this
            )
        )

        #_method
        (§ defn #_"int" hashCode [#_"EmptyList" this]
            1
        )

        #_method
        (§ defn #_"int" hasheq [#_"EmptyList" this]
            hasheq
        )

        #_method
        (§ defn #_"String" toString [#_"EmptyList" this]
            "()"
        )

        #_method
        (§ defn #_"boolean" equals [#_"EmptyList" this, #_"Object" o]
            (ß ((o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )

        #_method
        (§ defn #_"boolean" equiv [#_"EmptyList" this, #_"Object" o]
            (ß equals(o))
        )

        #_method
        (§ defn #_"Object" first [#_"EmptyList" this]
            nil
        )

        #_method
        (§ defn #_"ISeq" next [#_"EmptyList" this]
            nil
        )

        #_method
        (§ defn #_"ISeq" more [#_"EmptyList" this]
            this
        )

        #_method
        (§ defn #_"PersistentList" cons [#_"EmptyList" this, #_"Object" o]
            (ß new PersistentList(meta(), o, nil, 1))
        )

        #_method
        (§ defn #_"IPersistentCollection" empty [#_"EmptyList" this]
            this
        )

        #_method
        (§ defn #_"EmptyList" withMeta [#_"EmptyList" this, #_"IPersistentMap" meta]
            (when (ß meta != meta())
                (§ return (EmptyList. meta))
            )
            this
        )

        #_method
        (§ defn #_"Object" peek [#_"EmptyList" this]
            nil
        )

        #_method
        (§ defn #_"IPersistentList" pop [#_"EmptyList" this]
            (throw (IllegalStateException. "Can't pop empty list"))
        )

        #_method
        (§ defn #_"int" count [#_"EmptyList" this]
            0
        )

        #_method
        (§ defn #_"ISeq" seq [#_"EmptyList" this]
            nil
        )

        #_method
        (§ defn #_"int" size [#_"EmptyList" this]
            0
        )

        #_method
        (§ defn #_"boolean" isEmpty [#_"EmptyList" this]
            true
        )

        #_method
        (§ defn #_"boolean" contains [#_"EmptyList" this, #_"Object" o]
            false
        )

        #_method
        (§ defn #_"Iterator" iterator [#_"EmptyList" this]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    false
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (throw (NoSuchElementException.))
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )

        #_method
        (§ defn #_"Object[]" toArray [#_"EmptyList" this]
            (ß RT.EMPTY_ARRAY)
        )

        #_method
        (§ defn #_"boolean" add [#_"EmptyList" this, #_"Object" o]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"boolean" remove [#_"EmptyList" this, #_"Object" o]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"Collection" collection]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"void" clear [#_"EmptyList" this]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"boolean" retainAll [#_"EmptyList" this, #_"Collection" collection]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"boolean" removeAll [#_"EmptyList" this, #_"Collection" collection]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"boolean" containsAll [#_"EmptyList" this, #_"Collection" collection]
            (ß collection.isEmpty())
        )

        #_method
        (§ defn #_"Object[]" toArray [#_"EmptyList" this, #_"Object[]" objects]
            (when (ß objects.length > 0)
                (§ ass (ß objects[0]) nil)
            )
            objects
        )

        #_method
        (§ defn- #_"List" reify [#_"EmptyList" this]
            (ß Collections.unmodifiableList(new ArrayList(this)))
        )

        #_method
        (§ defn #_"List" subList [#_"EmptyList" this, #_"int" fromIndex, #_"int" toIndex]
            (ß reify().subList(fromIndex, toIndex))
        )

        #_method
        (§ defn #_"Object" set [#_"EmptyList" this, #_"int" index, #_"Object" element]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"Object" remove [#_"EmptyList" this, #_"int" index]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"int" indexOf [#_"EmptyList" this, #_"Object" o]
            (let [#_"ISeq" s (ß seq())]
                (loop-when-recur [(§ var #_"int" i 0)] (some? s) [(§ ass s (ß s.next()), i (ß i + 1))]
                    (when (ß Util.equiv(s.first(), o))
                        (§ return i)
                    )
                )
                -1
            )
        )

        #_method
        (§ defn #_"int" lastIndexOf [#_"EmptyList" this, #_"Object" o]
            (ß reify().lastIndexOf(o))
        )

        #_method
        (§ defn #_"ListIterator" listIterator [#_"EmptyList" this]
            (ß reify().listIterator())
        )

        #_method
        (§ defn #_"ListIterator" listIterator [#_"EmptyList" this, #_"int" index]
            (ß reify().listIterator(index))
        )

        #_method
        (§ defn #_"Object" get [#_"EmptyList" this, #_"int" index]
            (ß RT.nth(this, index))
        )

        #_method
        (§ defn #_"void" add [#_"EmptyList" this, #_"int" index, #_"Object" element]
            (throw (UnsupportedOperationException.))
        )

        #_method
        (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"int" index, #_"Collection" c]
            (throw (UnsupportedOperationException.))
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" EMPTY (ß new PersistentQueue(nil, 0, nil, nil)))

    (§ init
        (§ field #_"int" cnt 0)
        (§ field #_"ISeq" f nil)
        (§ field #_"PersistentVector" r nil)
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
    )

    (§ constructor #_"PersistentQueue" PersistentQueue [#_"IPersistentMap" meta, #_"int" cnt, #_"ISeq" f, #_"PersistentVector" r]
        (let [this (ß super(meta))]
            (§ ass (ß this.cnt) cnt)
            (§ ass (ß this.f) f)
            (§ ass (ß this.r) r)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentQueue" this, #_"Object" obj]
        (when (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()), ms (ß ms.next()))]
                (when (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentQueue" this, #_"Object" obj]
        (when (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()), ms (ß ms.next()))]
                (when (ß ms == nil || !Util.equals(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"PersistentQueue" this]
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (§ ass hash 1)
                (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
                    (§ ass hash (ß 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode())))
                )
                (§ ass (ß this._hash) hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"PersistentQueue" this]
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (§ ass (ß this._hasheq) (§ ass cached (ß Murmur3.hashOrdered(this))))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object" peek [#_"PersistentQueue" this]
        (ß RT.first(f))
    )

    #_method
    (§ defn #_"PersistentQueue" pop [#_"PersistentQueue" this]
        (when (nil? f) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" f1 (ß f.next())]
            (let [#_"PersistentVector" r1 r]
                (when (nil? f1)
                    (§ ass f1 (ß RT.seq(r)))
                    (§ ass r1 nil)
                )
                (ß new PersistentQueue(meta(), cnt - 1, f1, r1))
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentQueue" this]
        cnt
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentQueue" this]
        (when (nil? f)
            (§ return nil)
        )
        (ß new PersistentQueue'Seq(f, RT.seq(r)))
    )

    #_method
    (§ defn #_"PersistentQueue" cons [#_"PersistentQueue" this, #_"Object" o]
        (if (nil? f) ;; empty
            (do
                (ß new PersistentQueue(meta(), cnt + 1, RT.list(o), nil))
            )
            (do
                (ß new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector.EMPTY).cons(o)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentQueue" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentQueue" withMeta [#_"PersistentQueue" this, #_"IPersistentMap" meta]
        (ß new PersistentQueue(meta, cnt, f, r))
    )

    (class-ns PersistentQueue'Seq (§ extends ASeq)
        (§ init
            (§ field #_"ISeq" f nil)
            (§ field #_"ISeq" rseq nil)
        )

        (§ constructor #_"PersistentQueue'Seq" PersistentQueue'Seq [#_"ISeq" f, #_"ISeq" rseq]
            (let [this (ß super())]
                (§ ass (ß this.f) f)
                (§ ass (ß this.rseq) rseq)
                this
            )
        )

        (§ constructor #_"PersistentQueue'Seq" PersistentQueue'Seq [#_"IPersistentMap" meta, #_"ISeq" f, #_"ISeq" rseq]
            (let [this (ß super(meta))]
                (§ ass (ß this.f) f)
                (§ ass (ß this.rseq) rseq)
                this
            )
        )

        #_method
        (§ defn #_"Object" first [#_"PersistentQueue'Seq" this]
            (ß f.first())
        )

        #_method
        (§ defn #_"ISeq" next [#_"PersistentQueue'Seq" this]
            (let [#_"ISeq" f1 (ß f.next())]
                (let [#_"ISeq" r1 rseq]
                    (when (nil? f1)
                        (when (nil? rseq)
                            (§ return nil)
                        )
                        (§ ass f1 rseq)
                        (§ ass r1 nil)
                    )
                    (ß new PersistentQueue'Seq(f1, r1))
                )
            )
        )

        #_method
        (§ defn #_"int" count [#_"PersistentQueue'Seq" this]
            (ß RT.count(f) + RT.count(rseq))
        )

        #_method
        (§ defn #_"PersistentQueue'Seq" withMeta [#_"PersistentQueue'Seq" this, #_"IPersistentMap" meta]
            (ß new PersistentQueue'Seq(meta, f, rseq))
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"PersistentQueue" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"PersistentQueue" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"PersistentQueue" this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß contains(o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [#_"PersistentQueue" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"PersistentQueue" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [#_"PersistentQueue" this, #_"Object" o]
        (loop-when-recur [(§ var #_"ISeq" s (ß seq()))] (some? s) [(§ ass s (ß s.next()))]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (§ field- #_"ISeq" fseq f)
                (§ field- #_"Iterator" riter (ß (r != nil) ? r.iterator() :or nil))
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (ß ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext())))
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (cond (some? fseq)
                    (do
                        (let [#_"Object" ret (ß fseq.first())]
                            (§ ass fseq (ß fseq.next()))
                            ret
                        )
                    )
                    (ß riter != nil && riter.hasNext())
                    (do
                        (ß riter.next())
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" EMPTY (PersistentTreeMap.))

    (§ defn #_"IPersistentMap" create [#_"Map" other]
        (let [#_"IPersistentMap" ret EMPTY]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(§ var #_"Map.Entry" e (ß (Entry) o))]
                    (§ ass ret (ß ret.assoc(e.getKey(), e.getValue())))
                )
            )
            ret
        )
    )

    (§ init
        (§ field #_"Comparator" comp nil)
        (§ field #_"PersistentTreeMap'Node" tree nil)
        (§ field #_"int" _count 0)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap []
        (let [this (ß this(RT.DEFAULT_COMPARATOR))]
            this
        )
    )

    (§ constructor- #_"PersistentTreeMap" PersistentTreeMap [#_"Comparator" comp]
        (let [this (ß this(nil, comp))]
            this
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"IPersistentMap" meta, #_"Comparator" comp]
        (let [this (ß super())]
            (§ ass (ß this.comp) comp)
            (§ ass (ß this._meta) meta)
            (§ ass tree nil)
            (§ ass _count 0)
            this
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"IPersistentMap" meta, #_"Comparator" comp, #_"PersistentTreeMap'Node" tree, #_"int" _count]
        (let [this (ß super())]
            (§ ass (ß this._meta) meta)
            (§ ass (ß this.comp) comp)
            (§ ass (ß this.tree) tree)
            (§ ass (ß this._count) (ß _count))
            this
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" withMeta [#_"PersistentTreeMap" this, #_"IPersistentMap" meta]
        (ß new PersistentTreeMap(meta, comp, tree, _count))
    )

    (§ defn #_"PersistentTreeMap" create [#_"ISeq" items]
        (let [#_"IPersistentMap" ret EMPTY]
            (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next().next()))]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (§ ass ret (ß ret.assoc(items.first(), RT.second(items))))
            )
            (ß (PersistentTreeMap) ret)
        )
    )

    (§ defn #_"PersistentTreeMap" create [#_"Comparator" comp, #_"ISeq" items]
        (let [#_"IPersistentMap" ret (PersistentTreeMap. comp)]
            (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next().next()))]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (§ ass ret (ß ret.assoc(items.first(), RT.second(items))))
            )
            (ß (PersistentTreeMap) ret)
        )
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentTreeMap" this, #_"Object" key]
        (ß (entryAt(key) != nil))
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (ß super.equals(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (ß super.equiv(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assocEx [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box. nil)]
            (let [#_"PersistentTreeMap'Node" t (ß add(tree, key, val, found))]
                (when (nil? t) ;; nil == already contains key
                    (throw (ß Util.runtimeException("Key already present")))
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assoc [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box. nil)]
            (let [#_"PersistentTreeMap'Node" t (ß add(tree, key, val, found))]
                (when (nil? t) ;; nil == already contains key
                    (let [#_"PersistentTreeMap'Node" foundNode (ß (PersistentTreeMap'Node) found.val)]
                        (when (ß foundNode.val() == val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())))
                    )
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" without [#_"PersistentTreeMap" this, #_"Object" key]
        (let [#_"Box" found (Box. nil)]
            (let [#_"PersistentTreeMap'Node" t (ß remove(tree, key, found))]
                (when (nil? t)
                    (when (ß found.val == nil) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß new PersistentTreeMap(meta(), comp)))
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count - 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeMap" this]
        (when (ß _count > 0)
            (§ return (ß PersistentTreeMap'Seq.create(tree, true, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentTreeMap" this]
        (ß new PersistentTreeMap(meta(), comp))
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"PersistentTreeMap" this]
        (when (ß _count > 0)
            (§ return (ß PersistentTreeMap'Seq.create(tree, false, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"Comparator" comparator [#_"PersistentTreeMap" this]
        comp
    )

    #_method
    (§ defn #_"Object" entryKey [#_"PersistentTreeMap" this, #_"Object" entry]
        (ß ((IMapEntry) entry).key())
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeMap" this, #_"boolean" ascending]
        (when (ß _count > 0)
            (§ return (ß PersistentTreeMap'Seq.create(tree, ascending, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" seqFrom [#_"PersistentTreeMap" this, #_"Object" key, #_"boolean" ascending]
        (when (ß _count > 0)
            (let [#_"ISeq" stack nil]
                (let [#_"PersistentTreeMap'Node" t tree]
                    (while (some? t)
                        (let [#_"int" c (ß doCompare(key, t.key))]
                            (cond (ß c == 0)
                                (do
                                    (§ ass stack (ß RT.cons(t, stack)))
                                    (§ return (ß new PersistentTreeMap'Seq(stack, ascending)))
                                )
                                ascending
                                (do
                                    (if (ß c < 0)
                                        (do
                                            (§ ass stack (ß RT.cons(t, stack)))
                                            (§ ass t (ß t.left()))
                                        )
                                        (do
                                            (§ ass t (ß t.right()))
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (ß c > 0)
                                        (do
                                            (§ ass stack (ß RT.cons(t, stack)))
                                            (§ ass t (ß t.right()))
                                        )
                                        (do
                                            (§ ass t (ß t.left()))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (some? stack)
                        (§ return (ß new PersistentTreeMap'Seq(stack, ascending)))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"NodeIterator" iterator [#_"PersistentTreeMap" this]
        (ß new NodeIterator(tree, true))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentTreeMap" this, #_"IFn" f, #_"Object" init]
        (when (some? tree)
            (§ ass init (ß tree.kvreduce(f, init)))
        )
        (when (ß RT.isReduced(init))
            (§ ass init (ß ((IDeref)init).deref()))
        )
        init
    )

    #_method
    (§ defn #_"NodeIterator" reverseIterator [#_"PersistentTreeMap" this]
        (ß new NodeIterator(tree, false))
    )

    #_method
    (§ defn #_"Iterator" keys [#_"PersistentTreeMap" this]
        (ß keys(iterator()))
    )

    #_method
    (§ defn #_"Iterator" vals [#_"PersistentTreeMap" this]
        (ß vals(iterator()))
    )

    #_method
    (§ defn #_"Iterator" keys [#_"PersistentTreeMap" this, #_"NodeIterator" it]
        (KeyIterator. it)
    )

    #_method
    (§ defn #_"Iterator" vals [#_"PersistentTreeMap" this, #_"NodeIterator" it]
        (ValIterator. it)
    )

    #_method
    (§ defn #_"Object" minKey [#_"PersistentTreeMap" this]
        (let [#_"PersistentTreeMap'Node" t (ß min())]
            (ß (t != nil) ? t.key :or nil)
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap'Node" min [#_"PersistentTreeMap" this]
        (let [#_"PersistentTreeMap'Node" t tree]
            (when (some? t)
                (while (ß t.left() != nil)
                    (§ ass t (ß t.left()))
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"Object" maxKey [#_"PersistentTreeMap" this]
        (let [#_"PersistentTreeMap'Node" t (ß max())]
            (ß (t != nil) ? t.key :or nil)
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap'Node" max [#_"PersistentTreeMap" this]
        (let [#_"PersistentTreeMap'Node" t tree]
            (when (some? t)
                (while (ß t.right() != nil)
                    (§ ass t (ß t.right()))
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" depth [#_"PersistentTreeMap" this]
        (ß depth(tree))
    )

    #_method
    (§ defn #_"int" depth [#_"PersistentTreeMap" this, #_"PersistentTreeMap'Node" t]
        (when (nil? t)
            (§ return 0)
        )
        (ß 1 + Math.max(depth(t.left()), depth(t.right())))
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"PersistentTreeMap'Node" n (ß entryAt(key))]
            (ß (n != nil) ? n.val() :or notFound)
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentTreeMap" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"int" capacity [#_"PersistentTreeMap" this]
        (ß _count)
    )

    #_method
    (§ defn #_"int" count [#_"PersistentTreeMap" this]
        (ß _count)
    )

    #_method
    (§ defn #_"PersistentTreeMap'Node" entryAt [#_"PersistentTreeMap" this, #_"Object" key]
        (let [#_"PersistentTreeMap'Node" t tree]
            (while (some? t)
                (let [#_"int" c (ß doCompare(key, t.key))]
                    (cond (ß c == 0)
                        (do
                            (§ return t)
                        )
                        (ß c < 0)
                        (do
                            (§ ass t (ß t.left()))
                        )
                        :else
                        (do
                            (§ ass t (ß t.right()))
                        )
                    )
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" doCompare [#_"PersistentTreeMap" this, #_"Object" k1, #_"Object" k2]
        (ß comp.compare(k1, k2))
    )

    #_method
    (§ defn #_"PersistentTreeMap'Node" add [#_"PersistentTreeMap" this, #_"PersistentTreeMap'Node" t, #_"Object" key, #_"Object" val, #_"Box" found]
        (when (nil? t)
            (when (nil? val)
                (§ return (Red. key))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (let [#_"int" c (ß doCompare(key, t.key))]
            (when (ß c == 0)
                (§ ass (ß found.val) t)
                (§ return nil)
            )
            (let [#_"PersistentTreeMap'Node" ins (ß (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found))]
                (when (nil? ins) ;; found below
                    (§ return nil)
                )
                (when (ß c < 0)
                    (§ return (ß t.addLeft(ins)))
                )
                (ß t.addRight(ins))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap'Node" remove [#_"PersistentTreeMap" this, #_"PersistentTreeMap'Node" t, #_"Object" key, #_"Box" found]
        (when (nil? t)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" c (ß doCompare(key, t.key))]
            (when (ß c == 0)
                (§ ass (ß found.val) t)
                (§ return (ß append(t.left(), t.right())))
            )
            (let [#_"PersistentTreeMap'Node" del (ß (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found))]
                (when (ß del == nil && found.val == nil) ;; not found below
                    (§ return nil)
                )
                (when (ß c < 0)
                    (if (ß t.left() instanceof Black)
                        (do
                            (§ return (ß balanceLeftDel(t.key, t.val(), del, t.right())))
                        )
                        (do
                            (§ return (ß red(t.key, t.val(), del, t.right())))
                        )
                    )
                )
                (when (ß t.right() instanceof Black)
                    (§ return (ß balanceRightDel(t.key, t.val(), t.left(), del)))
                )
                (ß red(t.key, t.val(), t.left(), del))
            )
        )
    )

    (§ defn #_"PersistentTreeMap'Node" append [#_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
        (cond (nil? left)
            (do
                right
            )
            (nil? right)
            (do
                left
            )
            (ß left instanceof Red)
            (do
                (if (ß right instanceof Red)
                    (do
                        (let [#_"PersistentTreeMap'Node" app (ß append(left.right(), right.left()))]
                            (if (ß app instanceof Red)
                                (do
                                    (ß red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right())))
                                )
                                (do
                                    (ß red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right())))
                                )
                            )
                        )
                    )
                    (do
                        (ß red(left.key, left.val(), left.left(), append(left.right(), right)))
                    )
                )
            )
            (ß right instanceof Red)
            (do
                (ß red(right.key, right.val(), append(left, right.left()), right.right()))
            )
            :else ;; black/black
            (do
                (let [#_"PersistentTreeMap'Node" app (ß append(left.right(), right.left()))]
                    (if (ß app instanceof Red)
                        (do
                            (ß red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right())))
                        )
                        (do
                            (ß balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right())))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"PersistentTreeMap'Node" balanceLeftDel [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" del, #_"PersistentTreeMap'Node" right]
        (cond (ß del instanceof Red)
            (do
                (ß red(key, val, del.blacken(), right))
            )
            (ß right instanceof Black)
            (do
                (ß rightBalance(key, val, del, right.redden()))
            )
            (ß right instanceof Red && right.left() instanceof Black)
            (do
                (ß red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden())))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (§ defn #_"PersistentTreeMap'Node" balanceRightDel [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" del]
        (cond (ß del instanceof Red)
            (do
                (ß red(key, val, left, del.blacken()))
            )
            (ß left instanceof Black)
            (do
                (ß leftBalance(key, val, left.redden(), del))
            )
            (ß left instanceof Red && left.right() instanceof Black)
            (do
                (ß red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del)))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (§ defn #_"PersistentTreeMap'Node" leftBalance [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" ins, #_"PersistentTreeMap'Node" right]
        (cond (ß ins instanceof Red && ins.left() instanceof Red)
            (do
                (ß red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right)))
            )
            (ß ins instanceof Red && ins.right() instanceof Red)
            (do
                (ß red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right)))
            )
            :else
            (do
                (ß black(key, val, ins, right))
            )
        )
    )

    (§ defn #_"PersistentTreeMap'Node" rightBalance [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" ins]
        (cond (ß ins instanceof Red && ins.right() instanceof Red)
            (do
                (ß red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken()))
            )
            (ß ins instanceof Red && ins.left() instanceof Red)
            (do
                (ß red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right())))
            )
            :else
            (do
                (ß black(key, val, left, ins))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap'Node" replace [#_"PersistentTreeMap" this, #_"PersistentTreeMap'Node" t, #_"Object" key, #_"Object" val]
        (let [#_"int" c (ß doCompare(key, t.key))]
            (ß t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right()))
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"Comparator" comp, #_"PersistentTreeMap'Node" tree, #_"int" count, #_"IPersistentMap" meta]
        (let [this (ß super())]
            (§ ass (ß this._meta) meta)
            (§ ass (ß this.comp) comp)
            (§ ass (ß this.tree) tree)
            (§ ass (ß this._count) count)
            this
        )
    )

    (§ defn #_"Red" red [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
        (when (ß left == nil && right == nil)
            (when (nil? val)
                (§ return (Red. key))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (when (nil? val)
            (§ return (ß new RedBranch(key, left, right)))
        )
        (ß new RedBranchVal(key, val, left, right))
    )

    (§ defn #_"Black" black [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
        (when (ß left == nil && right == nil)
            (when (nil? val)
                (§ return (Black. key))
            )
            (§ return (ß new BlackVal(key, val)))
        )
        (when (nil? val)
            (§ return (ß new BlackBranch(key, left, right)))
        )
        (ß new BlackBranchVal(key, val, left, right))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentTreeMap" this]
        (ß _meta)
    )

    #_abstract
    (class-ns PersistentTreeMap'Node (§ extends AMapEntry)
        (§ init
            (§ field #_"Object" key nil)
        )

        (§ constructor #_"PersistentTreeMap'Node" PersistentTreeMap'Node [#_"Object" key]
            (let [this (ß super())]
                (§ ass (ß this.key) key)
                this
            )
        )

        #_method
        (§ defn #_"Object" key [#_"PersistentTreeMap'Node" this]
            key
        )

        #_method
        (§ defn #_"Object" val [#_"PersistentTreeMap'Node" this]
            nil
        )

        #_method
        (§ defn #_"Object" getKey [#_"PersistentTreeMap'Node" this]
            (ß key())
        )

        #_method
        (§ defn #_"Object" getValue [#_"PersistentTreeMap'Node" this]
            (ß val())
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" left [#_"PersistentTreeMap'Node" this]
            nil
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" right [#_"PersistentTreeMap'Node" this]
            nil
        )

        #_abstract
        (§ defn #_"PersistentTreeMap'Node" addLeft [#_"PersistentTreeMap'Node" this, #_"PersistentTreeMap'Node" ins])
        #_abstract
        (§ defn #_"PersistentTreeMap'Node" addRight [#_"PersistentTreeMap'Node" this, #_"PersistentTreeMap'Node" ins])
        #_abstract
        (§ defn #_"PersistentTreeMap'Node" removeLeft [#_"PersistentTreeMap'Node" this, #_"PersistentTreeMap'Node" del])
        #_abstract
        (§ defn #_"PersistentTreeMap'Node" removeRight [#_"PersistentTreeMap'Node" this, #_"PersistentTreeMap'Node" del])
        #_abstract
        (§ defn #_"PersistentTreeMap'Node" blacken [#_"PersistentTreeMap'Node" this])
        #_abstract
        (§ defn #_"PersistentTreeMap'Node" redden [#_"PersistentTreeMap'Node" this])

        #_method
        (§ defn #_"PersistentTreeMap'Node" balanceLeft [#_"PersistentTreeMap'Node" this, #_"PersistentTreeMap'Node" parent]
            (ß black(parent.key, parent.val(), this, parent.right()))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" balanceRight [#_"PersistentTreeMap'Node" this, #_"PersistentTreeMap'Node" parent]
            (ß black(parent.key, parent.val(), parent.left(), this))
        )

        #_abstract
        (§ defn #_"PersistentTreeMap'Node" replace [#_"PersistentTreeMap'Node" this, #_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right])

        #_method
        (§ defn #_"Object" kvreduce [#_"PersistentTreeMap'Node" this, #_"IFn" f, #_"Object" init]
            (when (ß left() != nil)
                (§ ass init (ß left().kvreduce(f, init)))
                (when (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            (§ ass init (ß f.invoke(init, key(), val())))
            (when (ß RT.isReduced(init))
                (§ return init)
            )

            (when (ß right() != nil)
                (§ ass init (ß right().kvreduce(f, init)))
            )
            init
        )
    )

    #_stateless
    (class-ns Black (§ extends PersistentTreeMap'Node)
        (§ constructor #_"Black" Black [#_"Object" key]
            (let [this (ß super(key))]
                this
            )
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" addLeft [#_"Black" this, #_"PersistentTreeMap'Node" ins]
            (ß ins.balanceLeft(this))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" addRight [#_"Black" this, #_"PersistentTreeMap'Node" ins]
            (ß ins.balanceRight(this))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" removeLeft [#_"Black" this, #_"PersistentTreeMap'Node" del]
            (ß balanceLeftDel(key, val(), del, right()))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" removeRight [#_"Black" this, #_"PersistentTreeMap'Node" del]
            (ß balanceRightDel(key, val(), left(), del))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" blacken [#_"Black" this]
            this
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" redden [#_"Black" this]
            (Red. key)
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" replace [#_"Black" this, #_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
            (ß black(key, val, left, right))
        )
    )

    (class-ns BlackVal (§ extends Black)
        (§ init
            (§ field #_"Object" val nil)
        )

        (§ constructor #_"BlackVal" BlackVal [#_"Object" key, #_"Object" val]
            (let [this (ß super(key))]
                (§ ass (ß this.val) val)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"BlackVal" this]
            val
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" redden [#_"BlackVal" this]
            (ß new RedVal(key, val))
        )
    )

    (class-ns BlackBranch (§ extends Black)
        (§ init
            (§ field #_"PersistentTreeMap'Node" left nil)
            (§ field #_"PersistentTreeMap'Node" right nil)
        )

        (§ constructor #_"BlackBranch" BlackBranch [#_"Object" key, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
            (let [this (ß super(key))]
                (§ ass (ß this.left) left)
                (§ ass (ß this.right) right)
                this
            )
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" left [#_"BlackBranch" this]
            left
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" right [#_"BlackBranch" this]
            right
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" redden [#_"BlackBranch" this]
            (ß new RedBranch(key, left, right))
        )
    )

    (class-ns BlackBranchVal (§ extends BlackBranch)
        (§ init
            (§ field #_"Object" val nil)
        )

        (§ constructor #_"BlackBranchVal" BlackBranchVal [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
            (let [this (ß super(key, left, right))]
                (§ ass (ß this.val) val)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"BlackBranchVal" this]
            val
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" redden [#_"BlackBranchVal" this]
            (ß new RedBranchVal(key, val, left, right))
        )
    )

    #_stateless
    (class-ns Red (§ extends PersistentTreeMap'Node)
        (§ constructor #_"Red" Red [#_"Object" key]
            (let [this (ß super(key))]
                this
            )
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" addLeft [#_"Red" this, #_"PersistentTreeMap'Node" ins]
            (ß red(key, val(), ins, right()))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" addRight [#_"Red" this, #_"PersistentTreeMap'Node" ins]
            (ß red(key, val(), left(), ins))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" removeLeft [#_"Red" this, #_"PersistentTreeMap'Node" del]
            (ß red(key, val(), del, right()))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" removeRight [#_"Red" this, #_"PersistentTreeMap'Node" del]
            (ß red(key, val(), left(), del))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" blacken [#_"Red" this]
            (Black. key)
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" redden [#_"Red" this]
            (throw (UnsupportedOperationException. "Invariant violation"))
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" replace [#_"Red" this, #_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
            (ß red(key, val, left, right))
        )
    )

    (class-ns RedVal (§ extends Red)
        (§ init
            (§ field #_"Object" val nil)
        )

        (§ constructor #_"RedVal" RedVal [#_"Object" key, #_"Object" val]
            (let [this (ß super(key))]
                (§ ass (ß this.val) val)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"RedVal" this]
            val
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" blacken [#_"RedVal" this]
            (ß new BlackVal(key, val))
        )
    )

    (class-ns RedBranch (§ extends Red)
        (§ init
            (§ field #_"PersistentTreeMap'Node" left nil)
            (§ field #_"PersistentTreeMap'Node" right nil)
        )

        (§ constructor #_"RedBranch" RedBranch [#_"Object" key, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
            (let [this (ß super(key))]
                (§ ass (ß this.left) left)
                (§ ass (ß this.right) right)
                this
            )
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" left [#_"RedBranch" this]
            left
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" right [#_"RedBranch" this]
            right
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" balanceLeft [#_"RedBranch" this, #_"PersistentTreeMap'Node" parent]
            (cond (ß left instanceof Red)
                (do
                    (ß red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right())))
                )
                (ß right instanceof Red)
                (do
                    (ß red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right())))
                )
                :else
                (do
                    (ß super.balanceLeft(parent))
                )
            )
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" balanceRight [#_"RedBranch" this, #_"PersistentTreeMap'Node" parent]
            (cond (ß right instanceof Red)
                (do
                    (ß red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken()))
                )
                (ß left instanceof Red)
                (do
                    (ß red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right)))
                )
                :else
                (do
                    (ß super.balanceRight(parent))
                )
            )
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" blacken [#_"RedBranch" this]
            (ß new BlackBranch(key, left, right))
        )
    )

    (class-ns RedBranchVal (§ extends RedBranch)
        (§ init
            (§ field #_"Object" val nil)
        )

        (§ constructor #_"RedBranchVal" RedBranchVal [#_"Object" key, #_"Object" val, #_"PersistentTreeMap'Node" left, #_"PersistentTreeMap'Node" right]
            (let [this (ß super(key, left, right))]
                (§ ass (ß this.val) val)
                this
            )
        )

        #_method
        (§ defn #_"Object" val [#_"RedBranchVal" this]
            val
        )

        #_method
        (§ defn #_"PersistentTreeMap'Node" blacken [#_"RedBranchVal" this]
            (ß new BlackBranchVal(key, val, left, right))
        )
    )

    (class-ns PersistentTreeMap'Seq (§ extends ASeq)
        (§ init
            (§ field #_"ISeq" stack nil)
            (§ field #_"boolean" asc false)
            (§ field #_"int" cnt 0)
        )

        (§ constructor #_"PersistentTreeMap'Seq" PersistentTreeMap'Seq [#_"ISeq" stack, #_"boolean" asc]
            (let [this (ß super())]
                (§ ass (ß this.stack) stack)
                (§ ass (ß this.asc) asc)
                (§ ass (ß this.cnt) -1)
                this
            )
        )

        (§ constructor #_"PersistentTreeMap'Seq" PersistentTreeMap'Seq [#_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
            (let [this (ß super())]
                (§ ass (ß this.stack) stack)
                (§ ass (ß this.asc) asc)
                (§ ass (ß this.cnt) cnt)
                this
            )
        )

        (§ constructor #_"PersistentTreeMap'Seq" PersistentTreeMap'Seq [#_"IPersistentMap" meta, #_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
            (let [this (ß super(meta))]
                (§ ass (ß this.stack) stack)
                (§ ass (ß this.asc) asc)
                (§ ass (ß this.cnt) cnt)
                this
            )
        )

        (§ defn #_"PersistentTreeMap'Seq" create [#_"PersistentTreeMap'Node" t, #_"boolean" asc, #_"int" cnt]
            (ß new PersistentTreeMap'Seq(push(t, nil, asc), asc, cnt))
        )

        (§ defn #_"ISeq" push [#_"PersistentTreeMap'Node" t, #_"ISeq" stack, #_"boolean" asc]
            (while (some? t)
                (§ ass stack (ß RT.cons(t, stack)))
                (§ ass t (ß asc ? t.left() :or t.right()))
            )
            stack
        )

        #_method
        (§ defn #_"Object" first [#_"PersistentTreeMap'Seq" this]
            (ß stack.first())
        )

        #_method
        (§ defn #_"ISeq" next [#_"PersistentTreeMap'Seq" this]
            (let [#_"PersistentTreeMap'Node" t (ß (PersistentTreeMap'Node) stack.first())]
                (let [#_"ISeq" nextstack (ß push(asc ? t.right() :or t.left(), stack.next(), asc))]
                    (when (some? nextstack)
                        (§ return (ß new PersistentTreeMap'Seq(nextstack, asc, cnt - 1)))
                    )
                    nil
                )
            )
        )

        #_method
        (§ defn #_"int" count [#_"PersistentTreeMap'Seq" this]
            (when (ß cnt < 0)
                (§ return (ß super.count()))
            )
            cnt
        )

        #_method
        (§ defn #_"Obj" withMeta [#_"PersistentTreeMap'Seq" this, #_"IPersistentMap" meta]
            (ß new PersistentTreeMap'Seq(meta, stack, asc, cnt))
        )
    )

    (class-ns NodeIterator (§ implements Iterator)
        (§ init
            (§ field #_"Stack" stack (Stack.))
            (§ field #_"boolean" asc false)
        )

        (§ constructor #_"NodeIterator" NodeIterator [#_"PersistentTreeMap'Node" t, #_"boolean" asc]
            (let [this (ß super())]
                (§ ass (ß this.asc) asc)
                (ß push(t))
                this
            )
        )

        #_method
        (§ defn #_"void" push [#_"NodeIterator" this, #_"PersistentTreeMap'Node" t]
            (while (some? t)
                (ß stack.push(t))
                (§ ass t (ß asc ? t.left() :or t.right()))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"NodeIterator" this]
            (ß !stack.isEmpty())
        )

        #_method
        (§ defn #_"Object" next [#_"NodeIterator" this]
            (try
                (let [#_"PersistentTreeMap'Node" t (ß (PersistentTreeMap'Node) stack.pop())]
                    (ß push(asc ? t.right() :or t.left()))
                    t
                )
                (catch EmptyStackException e
                    (throw (NoSuchElementException.))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [#_"NodeIterator" this]
            (throw (UnsupportedOperationException.))
        )
    )

    (class-ns KeyIterator (§ implements Iterator)
        (§ init
            (§ field #_"NodeIterator" it nil)
        )

        (§ constructor #_"KeyIterator" KeyIterator [#_"NodeIterator" it]
            (let [this (ß super())]
                (§ ass (ß this.it) it)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"KeyIterator" this]
            (ß it.hasNext())
        )

        #_method
        (§ defn #_"Object" next [#_"KeyIterator" this]
            (ß ((PersistentTreeMap'Node) it.next()).key)
        )

        #_method
        (§ defn #_"void" remove [#_"KeyIterator" this]
            (throw (UnsupportedOperationException.))
        )
    )

    (class-ns ValIterator (§ implements Iterator)
        (§ init
            (§ field #_"NodeIterator" it nil)
        )

        (§ constructor #_"ValIterator" ValIterator [#_"NodeIterator" it]
            (let [this (ß super())]
                (§ ass (ß this.it) it)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"ValIterator" this]
            (ß it.hasNext())
        )

        #_method
        (§ defn #_"Object" next [#_"ValIterator" this]
            (ß ((PersistentTreeMap'Node) it.next()).val())
        )

        #_method
        (§ defn #_"void" remove [#_"ValIterator" this]
            (throw (UnsupportedOperationException.))
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" EMPTY (ß new PersistentTreeSet(nil, PersistentTreeMap.EMPTY)))

    (§ defn #_"PersistentTreeSet" create [#_"ISeq" items]
        (let [#_"PersistentTreeSet" ret EMPTY]
            (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next()))]
                (§ ass ret (ß (PersistentTreeSet) ret.cons(items.first())))
            )
            ret
        )
    )

    (§ defn #_"PersistentTreeSet" create [#_"Comparator" comp, #_"ISeq" items]
        (let [#_"PersistentTreeSet" ret (ß new PersistentTreeSet(nil, new PersistentTreeMap(nil, comp)))]
            (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next()))]
                (§ ass ret (ß (PersistentTreeSet) ret.cons(items.first())))
            )
            ret
        )
    )

    (§ init
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentTreeSet" PersistentTreeSet [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (ß super(impl))]
            (§ ass (ß this._meta) meta)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (ß super.equals(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (ß super.equiv(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [#_"PersistentTreeSet" this, #_"Object" key]
        (when (ß contains(key))
            (§ return (ß new PersistentTreeSet(meta(), impl.without(key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [#_"PersistentTreeSet" this, #_"Object" o]
        (when (ß contains(o))
            (§ return this)
        )
        (ß new PersistentTreeSet(meta(), impl.assoc(o, o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentTreeSet" this]
        (ß new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty()))
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"PersistentTreeSet" this]
        (ß APersistentMap.KeySeq.create(((Reversible) impl).rseq()))
    )

    #_method
    (§ defn #_"PersistentTreeSet" withMeta [#_"PersistentTreeSet" this, #_"IPersistentMap" meta]
        (ß new PersistentTreeSet(meta, impl))
    )

    #_method
    (§ defn #_"Comparator" comparator [#_"PersistentTreeSet" this]
        (ß ((Sorted)impl).comparator())
    )

    #_method
    (§ defn #_"Object" entryKey [#_"PersistentTreeSet" this, #_"Object" entry]
        entry
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeSet" this, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (ß (PersistentTreeMap) impl)]
            (ß RT.keys(m.seq(ascending)))
        )
    )

    #_method
    (§ defn #_"ISeq" seqFrom [#_"PersistentTreeSet" this, #_"Object" key, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (ß (PersistentTreeMap) impl)]
            (ß RT.keys(m.seqFrom(key, ascending)))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentTreeSet" this]
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (class-ns PersistentVector'Node
        (§ init
            #_transient
            (§ field #_"AtomicReference<Thread>" edit nil)
            (§ field #_"Object[]" array nil)
        )

        (§ constructor #_"PersistentVector'Node" PersistentVector'Node [#_"AtomicReference<Thread>" edit, #_"Object[]" array]
            (let [this (ß super())]
                (§ ass (ß this.edit) edit)
                (§ ass (ß this.array) array)
                this
            )
        )

        (§ constructor #_"PersistentVector'Node" PersistentVector'Node [#_"AtomicReference<Thread>" edit]
            (let [this (ß super())]
                (§ ass (ß this.edit) edit)
                (§ ass (ß this.array) (ß new Object[32]))
                this
            )
        )
    )

    (§ def #_"AtomicReference<Thread>" NOEDIT (ß new AtomicReference<Thread>(nil)))
    (§ def #_"PersistentVector'Node" EMPTY_NODE (ß new PersistentVector'Node(NOEDIT, new Object[32])))

    (§ def #_"PersistentVector" EMPTY (ß new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§ array ))))

    (§ def- #_"IFn" TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" coll, #_"Object" val]
                (ß ((ITransientVector)coll).conj(val))
            )
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" coll]
                coll
            )
        )
    )

    (§ defn #_"PersistentVector" adopt [#_"Object[]" items]
        (ß new PersistentVector(items.length, 5, EMPTY_NODE, items))
    )

    (§ defn #_"PersistentVector" create [#_"IReduceInit" items]
        (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
            (ß items.reduce(TRANSIENT_VECTOR_CONJ, ret))
            (ß ret.persistent())
        )
    )

    (§ defn #_"PersistentVector" create [#_"ISeq" items]
        (let [#_"Object[]" arr (ß new Object[32])]
            (let [#_"int" i 0]
                (loop-when-recur [(ß )] (ß items != nil && i < 32) [(§ ass items (ß items.next()))]
                    (§ ass (ß arr[i]) (ß items.first()))
                    (§ ass i (ß i + 1))
                )

                (cond (some? items) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" start (ß new PersistentVector(32, 5, EMPTY_NODE, arr))]
                            (let [#_"TransientVector" ret (ß start.asTransient())]
                                (loop-when-recur [(ß )] (some? items) [(§ ass items (ß items.next()))]
                                    (§ ass ret (ß ret.conj(items.first())))
                                )
                                (ß ret.persistent())
                            )
                        )
                    )
                    (ß i == 32) ;; exactly 32, skip copy
                    (do
                        (ß new PersistentVector(32, 5, EMPTY_NODE, arr))
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" arr2 (ß new Object[i])]
                            (ß System.arraycopy(arr, 0, arr2, 0, i))
                            (ß new PersistentVector(i, 5, EMPTY_NODE, arr2))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"PersistentVector" create [#_"List" list]
        (let [#_"int" size (ß list.size())]
            (when (ß size <= 32)
                (§ return (ß new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())))
            )

            (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < size) [(§ ass i (ß i + 1))]
                    (§ ass ret (ß ret.conj(list.get(i))))
                )
                (ß ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentVector" create [#_"Iterable" items]
        ;; optimize common case
        (when (ß items instanceof ArrayList)
            (§ return (ß create((ArrayList)items)))
        )

        (let [#_"Iterator" iter (ß items.iterator())]
            (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
                (while (ß iter.hasNext())
                    (§ ass ret (ß ret.conj(iter.next())))
                )
                (ß ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentVector" create [#_"Object..." items]
        (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" item items]
                (§ ass ret (ß ret.conj(item)))
            )
            (ß ret.persistent())
        )
    )

    (§ init
        (§ field #_"int" cnt 0)
        (§ field #_"int" shift 0)
        (§ field #_"PersistentVector'Node" root nil)
        (§ field #_"Object[]" tail nil)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentVector" PersistentVector [#_"int" cnt, #_"int" shift, #_"PersistentVector'Node" root, #_"Object[]" tail]
        (let [this (ß super())]
            (§ ass (ß this._meta) nil)
            (§ ass (ß this.cnt) cnt)
            (§ ass (ß this.shift) shift)
            (§ ass (ß this.root) root)
            (§ ass (ß this.tail) tail)
            this
        )
    )

    (§ constructor #_"PersistentVector" PersistentVector [#_"IPersistentMap" meta, #_"int" cnt, #_"int" shift, #_"PersistentVector'Node" root, #_"Object[]" tail]
        (let [this (ß super())]
            (§ ass (ß this._meta) meta)
            (§ ass (ß this.cnt) cnt)
            (§ ass (ß this.shift) shift)
            (§ ass (ß this.root) root)
            (§ ass (ß this.tail) tail)
            this
        )
    )

    #_method
    (§ defn #_"TransientVector" asTransient [#_"PersistentVector" this]
        (TransientVector. this)
    )

    #_method
    (§ defn #_"int" tailoff [#_"PersistentVector" this]
        (when (ß cnt < 32)
            (§ return 0)
        )
        (ß ((cnt - 1) >>> 5) << 5)
    )

    #_method
    (§ defn #_"Object[]" arrayFor [#_"PersistentVector" this, #_"int" i]
        (when (ß i >= 0 && i < cnt)
            (when (ß i >= tailoff())
                (§ return tail)
            )
            (let [#_"PersistentVector'Node" node root]
                (loop-when-recur [(§ var #_"int" level shift)] (ß level > 0) [(§ ass level (ß level - 5))]
                    (§ ass node (ß (PersistentVector'Node) node.array[(i >>> level) & 0x01f]))
                )
                (§ return (ß node.array))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" nth [#_"PersistentVector" this, #_"int" i]
        (let [#_"Object[]" node (ß arrayFor(i))]
            (ß node[i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"PersistentVector" this, #_"int" i, #_"Object" notFound]
        (when (ß i >= 0 && i < cnt)
            (§ return (ß nth(i)))
        )
        notFound
    )

    #_method
    (§ defn #_"PersistentVector" assocN [#_"PersistentVector" this, #_"int" i, #_"Object" val]
        (when (ß i >= 0 && i < cnt)
            (when (ß i >= tailoff())
                (let [#_"Object[]" newTail (ß new Object[tail.length])]
                    (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                    (§ ass (ß newTail[i & 0x01f]) val)

                    (§ return (ß new PersistentVector(meta(), cnt, shift, root, newTail)))
                )
            )

            (§ return (ß new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)))
        )
        (when (ß i == cnt)
            (§ return (ß cons(val)))
        )
        (throw (IndexOutOfBoundsException.))
    )

    (§ defn- #_"PersistentVector'Node" doAssoc [#_"int" level, #_"PersistentVector'Node" node, #_"int" i, #_"Object" val]
        (let [#_"PersistentVector'Node" ret (ß new PersistentVector'Node(node.edit, node.array.clone()))]
            (if (ß level == 0)
                (do
                    (§ ass (ß ret.array[i & 0x01f]) val)
                )
                (do
                    (let [#_"int" subidx (ß (i >>> level) & 0x01f)]
                        (§ ass (ß ret.array[subidx]) (ß doAssoc(level - 5, (PersistentVector'Node) node.array[subidx], i, val)))
                    )
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentVector" this]
        cnt
    )

    #_method
    (§ defn #_"PersistentVector" withMeta [#_"PersistentVector" this, #_"IPersistentMap" meta]
        (ß new PersistentVector(meta, cnt, shift, root, tail))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentVector" this]
        (ß _meta)
    )

    #_method
    (§ defn #_"PersistentVector" cons [#_"PersistentVector" this, #_"Object" val]
        ;; room in tail?
        (when (ß cnt - tailoff() < 32)
            (let [#_"Object[]" newTail (ß new Object[tail.length + 1])]
                (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                (§ ass (ß newTail[tail.length]) val)
                (§ return (ß new PersistentVector(meta(), cnt + 1, shift, root, newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"PersistentVector'Node" newroot]
            (let [#_"PersistentVector'Node" tailnode (ß new PersistentVector'Node(root.edit, tail))]
                (let [#_"int" newshift shift]
                    ;; overflow root?
                    (if (ß (cnt >>> 5) > (1 << shift))
                        (do
                            (§ ass newroot (PersistentVector'Node. (ß root.edit)))
                            (§ ass (ß newroot.array[0]) root)
                            (§ ass (ß newroot.array[1]) (ß newPath(root.edit, shift, tailnode)))
                            (§ ass newshift (ß newshift + 5))
                        )
                        (do
                            (§ ass newroot (ß pushTail(shift, root, tailnode)))
                        )
                    )
                    (ß new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ array val )))
                )
            )
        )
    )

    #_method
    (§ defn- #_"PersistentVector'Node" pushTail [#_"PersistentVector" this, #_"int" level, #_"PersistentVector'Node" parent, #_"PersistentVector'Node" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" subidx (ß ((cnt - 1) >>> level) & 0x01f)]
            (let [#_"PersistentVector'Node" ret (ß new PersistentVector'Node(parent.edit, parent.array.clone()))]
                (§ let [#_"PersistentVector'Node" nodeToInsert]
                    (if (ß level == 5)
                        (do
                            (§ ass nodeToInsert tailnode)
                        )
                        (do
                            (let [#_"PersistentVector'Node" child (ß (PersistentVector'Node) parent.array[subidx])]
                                (§ ass nodeToInsert (ß (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode)))
                            )
                        )
                    )
                    (§ ass (ß ret.array[subidx]) nodeToInsert)
                    ret
                )
            )
        )
    )

    (§ defn- #_"PersistentVector'Node" newPath [#_"AtomicReference<Thread>" edit, #_"int" level, #_"PersistentVector'Node" node]
        (when (ß level == 0)
            (§ return node)
        )
        (let [#_"PersistentVector'Node" ret (PersistentVector'Node. edit)]
            (§ ass (ß ret.array[0]) (ß newPath(edit, level - 5, node)))
            ret
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" chunkedSeq [#_"PersistentVector" this]
        (when (ß count() == 0)
            (§ return nil)
        )
        (ß new ChunkedSeq(this, 0, 0))
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentVector" this]
        (ß chunkedSeq())
    )

    #_override
    #_method
    (§ defn #_"Iterator" rangedIterator [#_"PersistentVector" this, #_"int" start, #_"int" end]
        (§ reify Iterator()
            (§ init
                (§ field #_"int" i start)
                (§ field #_"int" base (ß i - (i%32)))
                (§ field #_"Object[]" array (ß (start < count()) ? arrayFor(i) :or nil))
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (ß (i < end))
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (if (ß i < end)
                    (do
                        (when (ß i - base == 32)
                            (§ ass array (ß arrayFor(i)))
                            (§ ass base (ß base + 32))
                        )
                        (let [_ (ß array[i & 0x01f])]
                            (§ ass i (ß i + 1))
                            _
                        )
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentVector" this]
        (ß rangedIterator(0, count()))
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentVector" this, #_"IFn" f]
        (§ let [#_"Object" init]
            (if (ß cnt > 0)
                (do
                    (§ ass init (ß arrayFor(0)[0]))
                )
                (do
                    (§ return (ß f.invoke()))
                )
            )
            (let [#_"int" step 0]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < cnt) [(§ ass i (ß i + step))]
                    (let [#_"Object[]" array (ß arrayFor(i))]
                        (loop-when-recur [(§ var #_"int" j (ß (i == 0) ? 1 :or 0))] (ß j < array.length) [(§ ass j (ß j + 1))]
                            (§ ass init (ß f.invoke(init, array[j])))
                            (when (ß RT.isReduced(init))
                                (§ return (ß ((IDeref)init).deref()))
                            )
                        )
                        (§ ass step (ß array.length))
                    )
                )
                init
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentVector" this, #_"IFn" f, #_"Object" init]
        (let [#_"int" step 0]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < cnt) [(§ ass i (ß i + step))]
                (let [#_"Object[]" array (ß arrayFor(i))]
                    (loop-when-recur [(§ var #_"int" j 0)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (§ ass init (ß f.invoke(init, array[j])))
                        (when (ß RT.isReduced(init))
                            (§ return (ß ((IDeref)init).deref()))
                        )
                    )
                    (§ ass step (ß array.length))
                )
            )
            init
        )
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentVector" this, #_"IFn" f, #_"Object" init]
        (let [#_"int" step 0]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < cnt) [(§ ass i (ß i + step))]
                (let [#_"Object[]" array (ß arrayFor(i))]
                    (loop-when-recur [(§ var #_"int" j 0)] (ß j < array.length) [(§ ass j (ß j + 1))]
                        (§ ass init (ß f.invoke(init, j + i, array[j])))
                        (when (ß RT.isReduced(init))
                            (§ return (ß ((IDeref)init).deref()))
                        )
                    )
                    (§ ass step (ß array.length))
                )
            )
            init
        )
    )

    (class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
        (§ init
            (§ field #_"PersistentVector" vec nil)
            (§ field #_"Object[]" node nil)
            (§ field #_"int" i 0)
            (§ field #_"int" offset 0)
        )

        (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"PersistentVector" vec, #_"int" i, #_"int" offset]
            (let [this (ß super())]
                (§ ass (ß this.vec) vec)
                (§ ass (ß this.i) i)
                (§ ass (ß this.offset) offset)
                (§ ass (ß this.node) (ß vec.arrayFor(i)))
                this
            )
        )

        (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"IPersistentMap" meta, #_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
            (let [this (ß super(meta))]
                (§ ass (ß this.vec) vec)
                (§ ass (ß this.node) node)
                (§ ass (ß this.i) i)
                (§ ass (ß this.offset) offset)
                this
            )
        )

        (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
            (let [this (ß super())]
                (§ ass (ß this.vec) vec)
                (§ ass (ß this.node) node)
                (§ ass (ß this.i) i)
                (§ ass (ß this.offset) offset)
                this
            )
        )

        #_method
        (§ defn #_"IChunk" chunkedFirst [#_"ChunkedSeq" this]
            (ß new ArrayChunk(node, offset))
        )

        #_method
        (§ defn #_"ISeq" chunkedNext [#_"ChunkedSeq" this]
            (when (ß i + node.length < vec.cnt)
                (§ return (ß new ChunkedSeq(vec, i + node.length, 0)))
            )
            nil
        )

        #_method
        (§ defn #_"ISeq" chunkedMore [#_"ChunkedSeq" this]
            (let [#_"ISeq" s (ß chunkedNext())]
                (when (nil? s)
                    (§ return (ß PersistentList.EMPTY))
                )
                s
            )
        )

        #_method
        (§ defn #_"Obj" withMeta [#_"ChunkedSeq" this, #_"IPersistentMap" meta]
            (when (ß meta == this._meta)
                (§ return this)
            )
            (ß new ChunkedSeq(meta, vec, node, i, offset))
        )

        #_method
        (§ defn #_"Object" first [#_"ChunkedSeq" this]
            (ß node[offset])
        )

        #_method
        (§ defn #_"ISeq" next [#_"ChunkedSeq" this]
            (when (ß offset + 1 < node.length)
                (§ return (ß new ChunkedSeq(vec, node, i, offset + 1)))
            )
            (ß chunkedNext())
        )

        #_method
        (§ defn #_"int" count [#_"ChunkedSeq" this]
            (ß vec.cnt - (i + offset))
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentVector" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentVector" pop [#_"PersistentVector" this]
        (when (ß cnt == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß cnt == 1)
            (§ return (ß EMPTY.withMeta(meta())))
        )
        (when (ß cnt - tailoff() > 1)
            (let [#_"Object[]" newTail (ß new Object[tail.length - 1])]
                (ß System.arraycopy(tail, 0, newTail, 0, newTail.length))
                (§ return (ß new PersistentVector(meta(), cnt - 1, shift, root, newTail)))
            )
        )
        (let [#_"Object[]" newtail (ß arrayFor(cnt - 2))]
            (let [#_"PersistentVector'Node" newroot (ß popTail(shift, root))]
                (let [#_"int" newshift shift]
                    (when (nil? newroot)
                        (§ ass newroot EMPTY_NODE)
                    )
                    (when (ß shift > 5 && newroot.array[1] == nil)
                        (§ ass newroot (ß (PersistentVector'Node) newroot.array[0]))
                        (§ ass newshift (ß newshift - 5))
                    )
                    (ß new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail))
                )
            )
        )
    )

    #_method
    (§ defn- #_"PersistentVector'Node" popTail [#_"PersistentVector" this, #_"int" level, #_"PersistentVector'Node" node]
        (let [#_"int" subidx (ß ((cnt - 2) >>> level) & 0x01f)]
            (cond (ß level > 5)
                (do
                    (let [#_"PersistentVector'Node" newchild (ß popTail(level - 5, (PersistentVector'Node) node.array[subidx]))]
                        (if (ß newchild == nil && subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"PersistentVector'Node" ret (ß new PersistentVector'Node(root.edit, node.array.clone()))]
                                    (§ ass (ß ret.array[subidx]) newchild)
                                    ret
                                )
                            )
                        )
                    )
                )
                (ß subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"PersistentVector'Node" ret (ß new PersistentVector'Node(root.edit, node.array.clone()))]
                        (§ ass (ß ret.array[subidx]) nil)
                        ret
                    )
                )
            )
        )
    )

    (class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
        (§ init
            #_volatile
            (§ field #_"int" cnt 0)
            #_volatile
            (§ field #_"int" shift 0)
            #_volatile
            (§ field #_"PersistentVector'Node" root nil)
            #_volatile
            (§ field #_"Object[]" tail nil)
        )

        (§ constructor #_"TransientVector" TransientVector [#_"int" cnt, #_"int" shift, #_"PersistentVector'Node" root, #_"Object[]" tail]
            (let [this (ß super())]
                (§ ass (ß this.cnt) cnt)
                (§ ass (ß this.shift) shift)
                (§ ass (ß this.root) root)
                (§ ass (ß this.tail) tail)
                this
            )
        )

        (§ constructor #_"TransientVector" TransientVector [#_"PersistentVector" v]
            (let [this (ß this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail)))]
                this
            )
        )

        #_method
        (§ defn #_"int" count [#_"TransientVector" this]
            (ß ensureEditable())
            cnt
        )

        #_method
        (§ defn #_"PersistentVector'Node" ensureEditable [#_"TransientVector" this, #_"PersistentVector'Node" node]
            (when (ß node.edit == root.edit)
                (§ return node)
            )
            (ß new PersistentVector'Node(root.edit, node.array.clone()))
        )

        #_method
        (§ defn #_"void" ensureEditable [#_"TransientVector" this]
            (when (ß root.edit.get() == nil)
                (throw (IllegalAccessError. "Transient used after persistent! call"))
            )
            nil
        )

        (§ defn #_"PersistentVector'Node" editableRoot [#_"PersistentVector'Node" node]
            (ß new PersistentVector'Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone()))
        )

        #_method
        (§ defn #_"PersistentVector" persistent [#_"TransientVector" this]
            (ß ensureEditable())
            (ß root.edit.set(nil))
            (let [#_"Object[]" trimmedTail (ß new Object[cnt - tailoff()])]
                (ß System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length))
                (ß new PersistentVector(cnt, shift, root, trimmedTail))
            )
        )

        (§ defn #_"Object[]" editableTail [#_"Object[]" tl]
            (let [#_"Object[]" ret (ß new Object[32])]
                (ß System.arraycopy(tl, 0, ret, 0, tl.length))
                ret
            )
        )

        #_method
        (§ defn #_"TransientVector" conj [#_"TransientVector" this, #_"Object" val]
            (ß ensureEditable())
            (let [#_"int" i cnt]
                ;; room in tail?
                (when (ß i - tailoff() < 32)
                    (§ ass (ß tail[i & 0x01f]) val)
                    (§ ass cnt (ß cnt + 1))
                    (§ return this)
                )
                ;; full tail, push into tree
                (§ let [#_"PersistentVector'Node" newroot]
                    (let [#_"PersistentVector'Node" tailnode (ß new PersistentVector'Node(root.edit, tail))]
                        (§ ass tail (ß new Object[32]))
                        (§ ass (ß tail[0]) val)
                        (let [#_"int" newshift shift]
                            ;; overflow root?
                            (if (ß (cnt >>> 5) > (1 << shift))
                                (do
                                    (§ ass newroot (PersistentVector'Node. (ß root.edit)))
                                    (§ ass (ß newroot.array[0]) root)
                                    (§ ass (ß newroot.array[1]) (ß newPath(root.edit, shift, tailnode)))
                                    (§ ass newshift (ß newshift + 5))
                                )
                                (do
                                    (§ ass newroot (ß pushTail(shift, root, tailnode)))
                                )
                            )
                            (§ ass root newroot)
                            (§ ass shift newshift)
                            (§ ass cnt (ß cnt + 1))
                            this
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"PersistentVector'Node" pushTail [#_"TransientVector" this, #_"int" level, #_"PersistentVector'Node" parent, #_"PersistentVector'Node" tailnode]
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            (§ ass parent (ß ensureEditable(parent)))
            (let [#_"int" subidx (ß ((cnt - 1) >>> level) & 0x01f)]
                (let [#_"PersistentVector'Node" ret parent]
                    (§ let [#_"PersistentVector'Node" nodeToInsert]
                        (if (ß level == 5)
                            (do
                                (§ ass nodeToInsert tailnode)
                            )
                            (do
                                (let [#_"PersistentVector'Node" child (ß (PersistentVector'Node) parent.array[subidx])]
                                    (§ ass nodeToInsert (ß (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode)))
                                )
                            )
                        )
                        (§ ass (ß ret.array[subidx]) nodeToInsert)
                        ret
                    )
                )
            )
        )

        #_method
        (§ defn- #_"int" tailoff [#_"TransientVector" this]
            (when (ß cnt < 32)
                (§ return 0)
            )
            (ß ((cnt - 1) >>> 5) << 5)
        )

        #_method
        (§ defn- #_"Object[]" arrayFor [#_"TransientVector" this, #_"int" i]
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ return tail)
                )
                (let [#_"PersistentVector'Node" node root]
                    (loop-when-recur [(§ var #_"int" level shift)] (ß level > 0) [(§ ass level (ß level - 5))]
                        (§ ass node (ß (PersistentVector'Node) node.array[(i >>> level) & 0x01f]))
                    )
                    (§ return (ß node.array))
                )
            )
            (throw (IndexOutOfBoundsException.))
        )

        #_method
        (§ defn- #_"Object[]" editableArrayFor [#_"TransientVector" this, #_"int" i]
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ return tail)
                )
                (let [#_"PersistentVector'Node" node root]
                    (loop-when-recur [(§ var #_"int" level shift)] (ß level > 0) [(§ ass level (ß level - 5))]
                        (§ ass node (ß ensureEditable((PersistentVector'Node) node.array[(i >>> level) & 0x01f])))
                    )
                    (§ return (ß node.array))
                )
            )
            (throw (IndexOutOfBoundsException.))
        )

        #_method
        (§ defn #_"Object" valAt [#_"TransientVector" this, #_"Object" key]
            ;; note - relies on ensureEditable in 2-arg valAt
            (ß valAt(key, nil))
        )

        #_method
        (§ defn #_"Object" valAt [#_"TransientVector" this, #_"Object" key, #_"Object" notFound]
            (ß ensureEditable())
            (when (ß Util.isInteger(key))
                (let [#_"int" i (ß ((Number) key).intValue())]
                    (when (ß i >= 0 && i < cnt)
                        (§ return (ß nth(i)))
                    )
                )
            )
            notFound
        )

        (§ def- #_"Object" NOT_FOUND (Object.))

        #_method
        (§ defn #_"boolean" containsKey [#_"TransientVector" this, #_"Object" key]
            (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
        )

        #_method
        (§ defn #_"IMapEntry" entryAt [#_"TransientVector" this, #_"Object" key]
            (let [#_"Object" v (ß valAt(key, NOT_FOUND))]
                (when (ß v != NOT_FOUND)
                    (§ return (ß MapEntry.create(key, v)))
                )
                nil
            )
        )

        #_method
        (§ defn #_"Object" invoke [#_"TransientVector" this, #_"Object" arg1]
            ;; note - relies on ensureEditable in nth
            (when (ß Util.isInteger(arg1))
                (§ return (ß nth(((Number) arg1).intValue())))
            )
            (throw (IllegalArgumentException. "Key must be integer"))
        )

        #_method
        (§ defn #_"Object" nth [#_"TransientVector" this, #_"int" i]
            (ß ensureEditable())
            (let [#_"Object[]" node (ß arrayFor(i))]
                (ß node[i & 0x01f])
            )
        )

        #_method
        (§ defn #_"Object" nth [#_"TransientVector" this, #_"int" i, #_"Object" notFound]
            (when (ß i >= 0 && i < count())
                (§ return (ß nth(i)))
            )
            notFound
        )

        #_method
        (§ defn #_"TransientVector" assocN [#_"TransientVector" this, #_"int" i, #_"Object" val]
            (ß ensureEditable())
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ ass (ß tail[i & 0x01f]) val)
                    (§ return this)
                )

                (§ ass root (ß doAssoc(shift, root, i, val)))
                (§ return this)
            )
            (when (ß i == cnt)
                (§ return (ß conj(val)))
            )
            (throw (IndexOutOfBoundsException.))
        )

        #_method
        (§ defn #_"TransientVector" assoc [#_"TransientVector" this, #_"Object" key, #_"Object" val]
            ;; note - relies on ensureEditable in assocN
            (when (ß Util.isInteger(key))
                (let [#_"int" i (ß ((Number) key).intValue())]
                    (§ return (ß assocN(i, val)))
                )
            )
            (throw (IllegalArgumentException. "Key must be integer"))
        )

        #_method
        (§ defn- #_"PersistentVector'Node" doAssoc [#_"TransientVector" this, #_"int" level, #_"PersistentVector'Node" node, #_"int" i, #_"Object" val]
            (§ ass node (ß ensureEditable(node)))
            (let [#_"PersistentVector'Node" ret node]
                (if (ß level == 0)
                    (do
                        (§ ass (ß ret.array[i & 0x01f]) val)
                    )
                    (do
                        (let [#_"int" subidx (ß (i >>> level) & 0x01f)]
                            (§ ass (ß ret.array[subidx]) (ß doAssoc(level - 5, (PersistentVector'Node) node.array[subidx], i, val)))
                        )
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"TransientVector" pop [#_"TransientVector" this]
            (ß ensureEditable())
            (when (ß cnt == 0)
                (throw (IllegalStateException. "Can't pop empty vector"))
            )
            (when (ß cnt == 1)
                (§ ass cnt 0)
                (§ return this)
            )
            (let [#_"int" i (ß cnt - 1)]
                ;; pop in tail?
                (when (ß (i & 0x01f) > 0)
                    (§ ass cnt (ß cnt - 1))
                    (§ return this)
                )

                (let [#_"Object[]" newtail (ß editableArrayFor(cnt - 2))]
                    (let [#_"PersistentVector'Node" newroot (ß popTail(shift, root))]
                        (let [#_"int" newshift shift]
                            (when (nil? newroot)
                                (§ ass newroot (PersistentVector'Node. (ß root.edit)))
                            )
                            (when (ß shift > 5 && newroot.array[1] == nil)
                                (§ ass newroot (ß ensureEditable((PersistentVector'Node) newroot.array[0])))
                                (§ ass newshift (ß newshift - 5))
                            )
                            (§ ass root newroot)
                            (§ ass shift newshift)
                            (§ ass cnt (ß cnt - 1))
                            (§ ass tail newtail)
                            this
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"PersistentVector'Node" popTail [#_"TransientVector" this, #_"int" level, #_"PersistentVector'Node" node]
            (§ ass node (ß ensureEditable(node)))
            (let [#_"int" subidx (ß ((cnt - 2) >>> level) & 0x01f)]
                (cond (ß level > 5)
                    (do
                        (let [#_"PersistentVector'Node" newchild (ß popTail(level - 5, (PersistentVector'Node) node.array[subidx]))]
                            (if (ß newchild == nil && subidx == 0)
                                (do
                                    nil
                                )
                                (do
                                    (let [#_"PersistentVector'Node" ret node]
                                        (§ ass (ß ret.array[subidx]) newchild)
                                        ret
                                    )
                                )
                            )
                        )
                    )
                    (ß subidx == 0)
                    (do
                        nil
                    )
                    :else
                    (do
                        (let [#_"PersistentVector'Node" ret node]
                            (§ ass (ß ret.array[subidx]) nil)
                            ret
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (§ init
        ;; method-name-string->fn
        (§ field #_"IPersistentMap" fns nil)
    )

    (§ constructor #_"ProxyHandler" ProxyHandler [#_"IPersistentMap" fns]
        (let [this (ß super())]
            (§ ass (ß this.fns) fns)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ProxyHandler" this, #_"Object" proxy, #_"Method" method, #_"Object[]" args] (§ throws Throwable)
        (let [#_"Class" rt (ß method.getReturnType())]
            (let [#_"IFn" fn (ß (IFn) fns.valAt(method.getName()))]
                (when (nil? fn)
                    (cond (ß rt == Void.TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß method.getName().equals("equals"))
                        (do
                            (§ return (ß (proxy == args[0])))
                        )
                        (ß method.getName().equals("hashCode"))
                        (do
                            (§ return (ß System.identityHashCode(proxy)))
                        )
                        (ß method.getName().equals("toString"))
                        (do
                            (§ return (ß "Proxy: " + System.identityHashCode(proxy)))
                        )
                    )
                    (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ret (ß fn.applyTo(ArraySeq.create(args)))]
                    (cond (ß rt == Void.TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß rt.isPrimitive())
                        (do
                            (cond (ß rt == Character.TYPE)
                                (do
                                    (§ return ret)
                                )
                                (ß rt == Integer.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).intValue()))
                                )
                                (ß rt == Long.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).longValue()))
                                )
                                (ß rt == Float.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).floatValue()))
                                )
                                (ß rt == Double.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).doubleValue()))
                                )
                                (ß rt == Boolean.TYPE && !(ret instanceof Boolean))
                                (do
                                    (§ return (ß (ret == nil) ? Boolean.FALSE :or Boolean.TRUE))
                                )
                                (ß rt == Byte.TYPE)
                                (do
                                    (§ return (ß (byte) ((Number) ret).intValue()))
                                )
                                (ß rt == Short.TYPE)
                                (do
                                    (§ return (ß (short) ((Number) ret).intValue()))
                                )
                            )
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (§ def- #_"int" CHUNK_SIZE 32)

    #_private
    (§ interface Range'BoundsCheck
        #_abstract
        (#_"boolean" exceededBounds [#_"Range'BoundsCheck" this, #_"Object" val])
    )

    (§ defn- #_"Range'BoundsCheck" positiveStep [#_"Object" end]
        (§ reify Range'BoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"Range'BoundsCheck" this, #_"Object" val]
                (ß Numbers.gte(val, end))
            )
        )
    )

    (§ defn- #_"Range'BoundsCheck" negativeStep [#_"Object" end]
        (§ reify Range'BoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"Range'BoundsCheck" this, #_"Object" val]
                (ß Numbers.lte(val, end))
            )
        )
    )

    (§ init
        ;; Invariants guarantee this is never an "empty" seq
        (§ field #_"Object" end nil)
        (§ field #_"Object" start nil)
        (§ field #_"Object" step nil)
        (§ field #_"Range'BoundsCheck" boundsCheck nil)

        #_volatile
        (§ field- #_"IChunk" _chunk nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _chunkNext nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Range" Range [#_"Object" start, #_"Object" end, #_"Object" step, #_"Range'BoundsCheck" boundsCheck]
        (let [this (ß super())]
            (§ ass (ß this.end) end)
            (§ ass (ß this.start) start)
            (§ ass (ß this.step) step)
            (§ ass (ß this.boundsCheck) boundsCheck)
            this
        )
    )

    (§ constructor- #_"Range" Range [#_"Object" start, #_"Object" end, #_"Object" step, #_"Range'BoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (ß super())]
            (§ ass (ß this.end) end)
            (§ ass (ß this.start) start)
            (§ ass (ß this.step) step)
            (§ ass (ß this.boundsCheck) boundsCheck)
            (§ ass (ß this._chunk) chunk)
            (§ ass (ß this._chunkNext) chunkNext)
            this
        )
    )

    (§ constructor- #_"Range" Range [#_"IPersistentMap" meta, #_"Object" start, #_"Object" end, #_"Object" step, #_"Range'BoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (ß super(meta))]
            (§ ass (ß this.end) end)
            (§ ass (ß this.start) start)
            (§ ass (ß this.step) step)
            (§ ass (ß this.boundsCheck) boundsCheck)
            (§ ass (ß this._chunk) chunk)
            (§ ass (ß this._chunkNext) chunkNext)
            this
        )
    )

    (§ defn #_"ISeq" create [#_"Object" end]
        (when (ß Numbers.isPos(end))
            (§ return (ß new Range(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn #_"ISeq" create [#_"Object" start, #_"Object" end]
        (ß create(start, end, 1))
    )

    (§ defn #_"ISeq" create [#_"Object" start, #_"Object" end, #_"Object" step]
        (when (ß (Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end))
            (§ return (ß PersistentList.EMPTY))
        )
        (when (ß Numbers.isZero(step))
            (§ return (ß Repeat.create(start)))
        )
        (ß new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end)))
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"Range" this, #_"IPersistentMap" meta]
        (when (ß meta == _meta)
            (§ return this)
        )
        (ß new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext))
    )

    #_method
    (§ defn #_"Object" first [#_"Range" this]
        start
    )

    #_method
    (§ defn #_"void" forceChunk [#_"Range" this]
        (when (some? _chunk)
            (§ return nil)
        )

        (let [#_"Object[]" arr (ß new Object[CHUNK_SIZE])]
            (let [#_"int" n 0]
                (let [#_"Object" val start]
                    (while (ß n < CHUNK_SIZE)
                        (§ ass (ß arr[n]) val)
                        (§ ass n (ß n + 1))
                        (§ ass val (ß Numbers.addP(val, step)))
                        (when (ß boundsCheck.exceededBounds(val))
                            ;; partial last chunk
                            (§ ass _chunk (ß new ArrayChunk(arr, 0, n)))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (ß boundsCheck.exceededBounds(val))
                        (§ ass _chunk (ß new ArrayChunk(arr, 0, CHUNK_SIZE)))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (§ ass _chunk (ß new ArrayChunk(arr, 0, CHUNK_SIZE)))
                    (§ ass _chunkNext (ß new Range(val, end, step, boundsCheck)))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" next [#_"Range" this]
        (when (some? _next)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"IChunk" smallerChunk (ß _chunk.dropFirst())]
                (§ ass _next (ß new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext)))
                (§ return (ß _next))
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"Range" this]
        (ß forceChunk())
        (ß _chunk)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"Range" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"Range" this]
        (ß forceChunk())
        (when (nil? _chunkNext)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    #_method
    (§ defn #_"Object" reduce [#_"Range" this, #_"IFn" f]
        (let [#_"Object" acc start]
            (let [#_"Number" i (ß Numbers.addP(start, step))]
                (while (ß !boundsCheck.exceededBounds(i))
                    (§ ass acc (ß f.invoke(acc, i)))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (§ ass i (ß Numbers.addP(i, step)))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Range" this, #_"IFn" f, #_"Object" val]
        (let [#_"Object" acc val]
            (let [#_"Object" i start]
                (while (ß !boundsCheck.exceededBounds(i))
                    (§ ass acc (ß f.invoke(acc, i)))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (§ ass i (ß Numbers.addP(i, step)))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"Range" this]
        (RangeIterator.)
    )

    #_private
    #_non-static
    (class-ns RangeIterator (§ implements Iterator)
        (§ init
            (§ field- #_"Object" next nil)
        )

        (§ constructor #_"RangeIterator" RangeIterator []
            (let [this (ß super())]
                (§ ass (ß this.next) start)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"RangeIterator" this]
            (ß (!boundsCheck.exceededBounds(next)))
        )

        #_method
        (§ defn #_"Object" next [#_"RangeIterator" this]
            (if (ß hasNext())
                (do
                    (let [#_"Object" ret next]
                        (§ ass next (ß Numbers.addP(next, step)))
                        ret
                    )
                )
                (do
                    (throw (NoSuchElementException.))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [#_"RangeIterator" this]
            (throw (UnsupportedOperationException.))
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (§ init
        (§ field #_"BigInteger" numerator nil)
        (§ field #_"BigInteger" denominator nil)
    )

    (§ constructor #_"Ratio" Ratio [#_"BigInteger" numerator, #_"BigInteger" denominator]
        (let [this (ß super())]
            (§ ass (ß this.numerator) numerator)
            (§ ass (ß this.denominator) denominator)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"Ratio" this, #_"Object" arg0]
        (ß (arg0 != nil && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator)))
    )

    #_method
    (§ defn #_"int" hashCode [#_"Ratio" this]
        (ß numerator.hashCode() :xor denominator.hashCode())
    )

    #_method
    (§ defn #_"String" toString [#_"Ratio" this]
        (ß numerator.toString() + "/" + denominator.toString())
    )

    #_method
    (§ defn #_"int" intValue [#_"Ratio" this]
        (ß (int) doubleValue())
    )

    #_method
    (§ defn #_"long" longValue [#_"Ratio" this]
        (ß bigIntegerValue().longValue())
    )

    #_method
    (§ defn #_"float" floatValue [#_"Ratio" this]
        (ß (float)doubleValue())
    )

    #_method
    (§ defn #_"double" doubleValue [#_"Ratio" this]
        (ß decimalValue(MathContext.DECIMAL64).doubleValue())
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [#_"Ratio" this]
        (ß decimalValue(MathContext.UNLIMITED))
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [#_"Ratio" this, #_"MathContext" mc]
        (let [#_"BigDecimal" numerator (BigDecimal. (ß this.numerator))]
            (let [#_"BigDecimal" denominator (BigDecimal. (ß this.denominator))]
                (ß numerator.divide(denominator, mc))
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" bigIntegerValue [#_"Ratio" this]
        (ß numerator.divide(denominator))
    )

    #_method
    (§ defn #_"int" compareTo [#_"Ratio" this, #_"Object" o]
        (let [#_"Number" other (ß (Number)o)]
            (ß Numbers.compare(this, other))
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def #_"Keyword" FORM_KW (ß Keyword.intern("form")))
    (§ def #_"Keyword" SPLICING_KW (ß Keyword.intern("splicing?")))

    (§ defn #_"ReaderConditional" create [#_"Object" form, #_"boolean" splicing]
        (ß new ReaderConditional(form, splicing))
    )

    (§ init
        (§ field #_"Object" form nil)
        (§ field #_"Boolean" splicing nil)
    )

    (§ constructor- #_"ReaderConditional" ReaderConditional [#_"Object" form, #_"boolean" splicing]
        (let [this (ß super())]
            (§ ass (ß this.form) form)
            (§ ass (ß this.splicing) splicing)
            this
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"ReaderConditional" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"ReaderConditional" this, #_"Object" key, #_"Object" notFound]
        (cond (ß FORM_KW.equals(key))
            (do
                (ß this.form)
            )
            (ß SPLICING_KW.equals(key))
            (do
                (ß this.splicing)
            )
            :else
            (do
                notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" equals [#_"ReaderConditional" this, #_"Object" o]
        (when (ß this == o)
            (§ return true)
        )
        (when (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (let [#_"ReaderConditional" that (ß (ReaderConditional) o)]
            (when (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
                (§ return false)
            )
            (when (ß (splicing != nil) ? !splicing.equals(that.splicing) :or that.splicing != nil)
                (§ return false)
            )
            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" hashCode [#_"ReaderConditional" this]
        (let [#_"int" result (ß Util.hash(form))]
            (§ ass result (ß 31 * result + Util.hash(splicing)))
            result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (§ init
        (§ field #_"int" i 0)
        (§ field #_"int" basecnt 0)
        (§ field #_"ILookup" rec nil)
        (§ field #_"IPersistentVector" basefields nil)
        (§ field #_"Iterator" extmap nil)
    )

    (§ constructor #_"RecordIterator" RecordIterator [#_"ILookup" rec, #_"IPersistentVector" basefields, #_"Iterator" extmap]
        (let [this (ß super())]
            (§ ass (ß this.rec) rec)
            (§ ass (ß this.basefields) basefields)
            (§ ass (ß this.basecnt) (ß basefields.count()))
            (§ ass (ß this.extmap) extmap)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"RecordIterator" this]
        (if (ß i < basecnt)
            (do
                true
            )
            (do
                (ß extmap.hasNext())
            )
        )
    )

    #_method
    (§ defn #_"Object" next [#_"RecordIterator" this]
        (if (ß i < basecnt)
            (do
                (let [#_"Object" k (ß basefields.nth(i))]
                    (§ ass i (ß i + 1))
                    (ß MapEntry.create(k, rec.valAt(k)))
                )
            )
            (do
                (ß extmap.next())
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"Reduced" Reduced [#_"Object" val]
        (let [this (ß super())]
            (§ ass (ß this.val) val)
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Reduced" this]
        val
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (class-ns TVal
        (§ init
            (§ field #_"Object" val nil)
            (§ field #_"long" point 0)
            (§ field #_"TVal" prior nil)
            (§ field #_"TVal" next nil)
        )

        (§ constructor #_"TVal" TVal [#_"Object" val, #_"long" point, #_"TVal" prior]
            (let [this (ß super())]
                (§ ass (ß this.val) val)
                (§ ass (ß this.point) point)
                (§ ass (ß this.prior) prior)
                (§ ass (ß this.next) (ß prior.next))
                (§ ass (ß this.prior.next) this)
                (§ ass (ß this.next.prior) this)
                this
            )
        )

        (§ constructor #_"TVal" TVal [#_"Object" val, #_"long" point]
            (let [this (ß super())]
                (§ ass (ß this.val) val)
                (§ ass (ß this.point) point)
                (§ ass (ß this.next) this)
                (§ ass (ß this.prior) this)
                this
            )
        )
    )

    (§ def #_"AtomicLong" ids (AtomicLong.))

    (§ init
        (§ field #_"TVal" tvals nil)
        (§ field #_"AtomicInteger" faults nil)
        (§ field #_"ReentrantReadWriteLock" lock nil)
        (§ field #_"LockingTransaction.Info" tinfo nil)
        (§ field #_"long" id 0)

        #_volatile
        (§ field #_"int" minHistory 0)
        #_volatile
        (§ field #_"int" maxHistory 10)
    )

    (§ constructor #_"Ref" Ref [#_"Object" initVal]
        (let [this (ß this(initVal, nil))]
            this
        )
    )

    (§ constructor #_"Ref" Ref [#_"Object" initVal, #_"IPersistentMap" meta]
        (let [this (ß super(meta))]
            (§ ass (ß this.id) (ß ids.getAndIncrement()))
            (§ ass (ß this.faults) (AtomicInteger.))
            (§ ass (ß this.lock) (ReentrantReadWriteLock.))
            (§ ass tvals (ß new TVal(initVal, 0)))
            this
        )
    )

    #_method
    (§ defn #_"int" compareTo [#_"Ref" this, #_"Ref" ref]
        (cond (ß this.id == ref.id)
            (do
                0
            )
            (ß this.id < ref.id)
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    #_method
    (§ defn #_"int" getMinHistory [#_"Ref" this]
        minHistory
    )

    #_method
    (§ defn #_"Ref" setMinHistory [#_"Ref" this, #_"int" minHistory]
        (§ ass (ß this.minHistory) minHistory)
        this
    )

    #_method
    (§ defn #_"int" getMaxHistory [#_"Ref" this]
        maxHistory
    )

    #_method
    (§ defn #_"Ref" setMaxHistory [#_"Ref" this, #_"int" maxHistory]
        (§ ass (ß this.maxHistory) maxHistory)
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" currentVal [#_"Ref" this]
        (try
            (ß lock.readLock().lock())
            (when (some? tvals)
                (§ return (ß tvals.val))
            )
            (throw (ß new IllegalStateException(this.toString() + " is unbound.")))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Ref" this]
        (let [#_"LockingTransaction" t (ß LockingTransaction.getRunning())]
            (when (nil? t)
                (§ return (ß currentVal()))
            )
            (ß t.doGet(this))
        )
    )

    #_method
    (§ defn #_"Object" set [#_"Ref" this, #_"Object" val]
        (ß LockingTransaction.getEx().doSet(this, val))
    )

    #_method
    (§ defn #_"Object" commute [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (ß LockingTransaction.getEx().doCommute(this, fn, args))
    )

    #_method
    (§ defn #_"Object" alter [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (let [#_"LockingTransaction" t (ß LockingTransaction.getEx())]
            (ß t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args))))
        )
    )

    #_method
    (§ defn #_"void" touch [#_"Ref" this]
        (ß LockingTransaction.getEx().doEnsure(this))
        nil
    )

    #_method
    (§ defn #_"boolean" isBound [#_"Ref" this]
        (try
            (ß lock.readLock().lock())
            (ß (tvals != nil))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"void" trimHistory [#_"Ref" this]
        (try
            (ß lock.writeLock().lock())
            (when (some? tvals)
                (§ ass (ß tvals.next) tvals)
                (§ ass (ß tvals.prior) tvals)
            )
            (finally
                (ß lock.writeLock().unlock())
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" getHistoryCount [#_"Ref" this]
        (try
            (ß lock.writeLock().lock())
            (ß histCount())
            (finally
                (ß lock.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"int" histCount [#_"Ref" this]
        (if (nil? tvals)
            (do
                0
            )
            (do
                (let [#_"int" count 0]
                    (loop-when-recur [(§ var #_"TVal" tv (ß tvals.next))] (ß tv != tvals) [(§ ass tv (ß tv.next))]
                        (§ ass count (ß count + 1))
                    )
                    count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" fn [#_"Ref" this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [#_"Ref" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"Ref" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1]
        (ß fn().invoke(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2]
        (ß fn().invoke(arg1, arg2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß fn().invoke(arg1, arg2, arg3))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß fn().invoke(arg1, arg2, arg3, arg4))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Ref" this, #_"ISeq" arglist]
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (§ defn #_"Object" invokeInstanceMethod [#_"Object" target, #_"String" methodName, #_"Object[]" args]
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"List" methods (ß getMethods(c, args.length, methodName, false))]
                (ß invokeMatchingMethod(methodName, methods, target, args))
            )
        )
    )

    (§ defn- #_"Throwable" getCauseOrElse [#_"Exception" e]
        (when (ß e.getCause() != nil)
            (§ return (ß e.getCause()))
        )
        e
    )

    (§ defn- #_"RuntimeException" throwCauseOrElseException [#_"Exception" e]
        (when (ß e.getCause() != nil)
            (throw (ß Util.sneakyThrow(e.getCause())))
        )
        (throw (ß Util.sneakyThrow(e)))
    )

    (§ defn- #_"String" noMethodReport [#_"String" methodName, #_"Object" target]
        (ß "No matching method found: " + methodName + ((target == nil) ? "" :or " for " + target.getClass()))
    )

    (§ defn #_"Object" invokeMatchingMethod [#_"String" methodName, #_"List" methods, #_"Object" target, #_"Object[]" args]
        (let [#_"Method" m nil]
            (let [#_"Object[]" boxedArgs nil]
                (cond (ß methods.isEmpty())
                    (do
                        (throw (ß new IllegalArgumentException(noMethodReport(methodName, target))))
                    )
                    (ß methods.size() == 1)
                    (do
                        (§ ass m (ß (Method) methods.get(0)))
                        (§ ass boxedArgs (ß boxArgs(m.getParameterTypes(), args)))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"Method" foundm nil]
                            (loop-when-recur [(§ var #_"Iterator" i (ß methods.iterator()))] (ß i.hasNext()) [(ß )]
                                (§ ass m (ß (Method) i.next()))

                                (let [#_"Class[]" params (ß m.getParameterTypes())]
                                    (when (ß isCongruent(params, args))
                                        (when (ß foundm == nil || Compiler.subsumes(params, foundm.getParameterTypes()))
                                            (§ ass foundm m)
                                            (§ ass boxedArgs (ß boxArgs(params, args)))
                                        )
                                    )
                                )
                            )
                            (§ ass m foundm)
                        )
                    )
                )
                (when (nil? m)
                    (throw (ß new IllegalArgumentException(noMethodReport(methodName, target))))
                )

                (when (ß !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"Method" oldm m]
                        (§ ass m (ß getAsMethodOfPublicBase(target.getClass(), m)))
                        (when (nil? m)
                            (throw (ß new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString())))
                        )
                    )
                )
                (try
                    (ß prepRet(m.getReturnType(), m.invoke(target, boxedArgs)))
                    (catch Exception e
                        (throw (ß Util.sneakyThrow(getCauseOrElse(e))))
                    )
                )
            )
        )
    )

    (§ defn #_"Method" getAsMethodOfPublicBase [#_"Class" c, #_"Method" m]
        (doseq [#_"Class" iface (ß c.getInterfaces())]
            (doseq [#_"Method" im (ß iface.getMethods())]
                (when (ß isMatch(im, m))
                    (§ return im)
                )
            )
        )
        (let [#_"Class" sc (ß c.getSuperclass())]
            (when (nil? sc)
                (§ return nil)
            )
            (doseq [#_"Method" scm (ß sc.getMethods())]
                (when (ß isMatch(scm, m))
                    (§ return scm)
                )
            )
            (ß getAsMethodOfPublicBase(sc, m))
        )
    )

    (§ defn #_"boolean" isMatch [#_"Method" lhs, #_"Method" rhs]
        (when (ß !lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers()))
            (§ return false)
        )

        (let [#_"Class[]" types1 (ß lhs.getParameterTypes())]
            (let [#_"Class[]" types2 (ß rhs.getParameterTypes())]
                (when (ß types1.length != types2.length)
                    (§ return false)
                )

                (let [#_"boolean" match true]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < types1.length) [(§ ass i (ß i + 1))]
                        (when (ß !types1[i].isAssignableFrom(types2[i]))
                            (§ ass match false)
                            (§ break )
                        )
                    )
                    match
                )
            )
        )
    )

    (§ defn #_"Object" invokeConstructor [#_"Class" c, #_"Object[]" args]
        (try
            (let [#_"Constructor[]" allctors (ß c.getConstructors())]
                (let [#_"ArrayList" ctors (ArrayList.)]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < allctors.length) [(§ ass i (ß i + 1))]
                        (let [#_"Constructor" ctor (ß allctors[i])]
                            (when (ß ctor.getParameterTypes().length == args.length)
                                (ß ctors.add(ctor))
                            )
                        )
                    )
                    (cond (ß ctors.isEmpty())
                        (do
                            (throw (IllegalArgumentException. (ß "No matching ctor found for " + c)))
                        )
                        (ß ctors.size() == 1)
                        (do
                            (let [#_"Constructor" ctor (ß (Constructor) ctors.get(0))]
                                (ß ctor.newInstance(boxArgs(ctor.getParameterTypes(), args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [(§ var #_"Iterator" iterator (ß ctors.iterator()))] (ß iterator.hasNext()) [(ß )]
                                (let [#_"Constructor" ctor (ß (Constructor) iterator.next())]
                                    (let [#_"Class[]" params (ß ctor.getParameterTypes())]
                                        (when (ß isCongruent(params, args))
                                            (let [#_"Object[]" boxedArgs (ß boxArgs(params, args))]
                                                (§ return (ß ctor.newInstance(boxedArgs)))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (IllegalArgumentException. (ß "No matching ctor found for " + c)))
                        )
                    )
                )
            )
            (catch Exception e
                (throw (ß Util.sneakyThrow(getCauseOrElse(e))))
            )
        )
    )

    (§ defn #_"Object" invokeStaticMethodVariadic [#_"String" className, #_"String" methodName, #_"Object..." args]
        (ß invokeStaticMethod(className, methodName, args))
    )

    (§ defn #_"Object" invokeStaticMethod [#_"String" className, #_"String" methodName, #_"Object[]" args]
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß invokeStaticMethod(c, methodName, args))
        )
    )

    (§ defn #_"Object" invokeStaticMethod [#_"Class" c, #_"String" methodName, #_"Object[]" args]
        (when (ß methodName.equals("new"))
            (§ return (ß invokeConstructor(c, args)))
        )
        (let [#_"List" methods (ß getMethods(c, args.length, methodName, true))]
            (ß invokeMatchingMethod(methodName, methods, nil, args))
        )
    )

    (§ defn #_"Object" getStaticField [#_"String" className, #_"String" fieldName]
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß getStaticField(c, fieldName))
        )
    )

    (§ defn #_"Object" getStaticField [#_"Class" c, #_"String" fieldName]
        (let [#_"Field" f (ß getField(c, fieldName, true))]
            (when (some? f)
                (try
                    (§ return (ß prepRet(f.getType(), f.get(nil))))
                    (catch IllegalAccessException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
            )
            (throw (IllegalArgumentException. (ß "No matching field found: " + fieldName + " for " + c)))
        )
    )

    (§ defn #_"Object" setStaticField [#_"String" className, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß setStaticField(c, fieldName, val))
        )
    )

    (§ defn #_"Object" setStaticField [#_"Class" c, #_"String" fieldName, #_"Object" val]
        (let [#_"Field" f (ß getField(c, fieldName, true))]
            (when (some? f)
                (try
                    (ß f.set(nil, boxArg(f.getType(), val)))
                    (catch IllegalAccessException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
                (§ return val)
            )
            (throw (IllegalArgumentException. (ß "No matching field found: " + fieldName + " for " + c)))
        )
    )

    (§ defn #_"Object" getInstanceField [#_"Object" target, #_"String" fieldName]
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, fieldName, false))]
                (when (some? f)
                    (try
                        (§ return (ß prepRet(f.getType(), f.get(target))))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())))
            )
        )
    )

    (§ defn #_"Object" setInstanceField [#_"Object" target, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, fieldName, false))]
                (when (some? f)
                    (try
                        (ß f.set(target, boxArg(f.getType(), val)))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                    (§ return val)
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (§ defn #_"Object" invokeNoArgInstanceMember [#_"Object" target, #_"String" name]
        (ß invokeNoArgInstanceMember(target, name, false))
    )

    (§ defn #_"Object" invokeNoArgInstanceMember [#_"Object" target, #_"String" name, #_"boolean" requireField]
        (let [#_"Class" c (ß target.getClass())]
            (if requireField
                (do
                    (let [#_"Field" f (ß getField(c, name, false))]
                        (if (some? f)
                            (do
                                (ß getInstanceField(target, name))
                            )
                            (do
                                (throw (ß new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass())))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" meths (ß getMethods(c, 0, name, false))]
                        (if (ß meths.size() > 0)
                            (do
                                (ß invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY))
                            )
                            (do
                                (ß getInstanceField(target, name))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Object" invokeInstanceMember [#_"Object" target, #_"String" name]
        ;; check for field first
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, name, false))]
                (when (some? f) ;; field get
                    (try
                        (§ return (ß prepRet(f.getType(), f.get(target))))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (ß invokeInstanceMethod(target, name, RT.EMPTY_ARRAY))
            )
        )
    )

    (§ defn #_"Object" invokeInstanceMember [#_"String" name, #_"Object" target, #_"Object" arg1]
        ;; check for field first
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, name, false))]
                (when (some? f) ;; field set
                    (try
                        (ß f.set(target, boxArg(f.getType(), arg1)))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                    (§ return arg1)
                )
                (ß invokeInstanceMethod(target, name, new Object[] (§ array arg1 )))
            )
        )
    )

    (§ defn #_"Object" invokeInstanceMember [#_"String" name, #_"Object" target, #_"Object..." args]
        (ß invokeInstanceMethod(target, name, args))
    )

    (§ defn #_"Field" getField [#_"Class" c, #_"String" name, #_"boolean" getStatics]
        (let [#_"Field[]" allfields (ß c.getFields())]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < allfields.length) [(§ ass i (ß i + 1))]
                (when (ß name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
                    (§ return (ß allfields[i]))
                )
            )
            nil
        )
    )

    (§ defn #_"List" getMethods [#_"Class" c, #_"int" arity, #_"String" name, #_"boolean" getStatics]
        (let [#_"Method[]" allmethods (ß c.getMethods())]
            (let [#_"ArrayList" methods (ArrayList.)]
                (let [#_"ArrayList" bridgeMethods (ArrayList.)]
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i < allmethods.length) [(§ ass i (ß i + 1))]
                        (let [#_"Method" method (ß allmethods[i])]
                            (when (ß name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity)
                                (try
                                    (if (ß method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method))
                                        (do
                                            (ß bridgeMethods.add(method))
                                        )
                                        (do
                                            (ß methods.add(method))
                                        )
                                    )
                                    (catch NoSuchMethodException e
                                    )
                                )
                            )
                        )
                    )

                    (when (ß methods.isEmpty())
                        (ß methods.addAll(bridgeMethods))
                    )
                    (when (ß !getStatics && c.isInterface())
                        (§ ass allmethods (ß Object.class.getMethods()))
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < allmethods.length) [(§ ass i (ß i + 1))]
                            (when (ß name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity)
                                (ß methods.add(allmethods[i]))
                            )
                        )
                    )
                    methods
                )
            )
        )
    )

    (§ defn #_"Object" boxArg [#_"Class" paramType, #_"Object" arg]
        (cond (ß !paramType.isPrimitive())
            (do
                (§ return (ß paramType.cast(arg)))
            )
            (ß paramType == boolean.class)
            (do
                (§ return (ß Boolean.class.cast(arg)))
            )
            (ß paramType == char.class)
            (do
                (§ return (ß Character.class.cast(arg)))
            )
            (ß arg instanceof Number)
            (do
                (let [#_"Number" n (ß (Number) arg)]
                    (cond (ß paramType == int.class)
                        (do
                            (§ return (ß n.intValue()))
                        )
                        (ß paramType == float.class)
                        (do
                            (§ return (ß n.floatValue()))
                        )
                        (ß paramType == double.class)
                        (do
                            (§ return (ß n.doubleValue()))
                        )
                        (ß paramType == long.class)
                        (do
                            (§ return (ß n.longValue()))
                        )
                        (ß paramType == short.class)
                        (do
                            (§ return (ß n.shortValue()))
                        )
                        (ß paramType == byte.class)
                        (do
                            (§ return (ß n.byteValue()))
                        )
                    )
                )
            )
        )
        (throw (ß new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName())))
    )

    (§ defn #_"Object[]" boxArgs [#_"Class[]" params, #_"Object[]" args]
        (when (ß params.length == 0)
            (§ return nil)
        )
        (let [#_"Object[]" ret (ß new Object[params.length])]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < params.length) [(§ ass i (ß i + 1))]
                (let [#_"Object" arg (ß args[i])]
                    (let [#_"Class" paramType (ß params[i])]
                        (§ ass (ß ret[i]) (ß boxArg(paramType, arg)))
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"boolean" paramArgTypeMatch [#_"Class" paramType, #_"Class" argType]
        (when (nil? argType)
            (§ return (ß !paramType.isPrimitive()))
        )
        (when (ß paramType == argType || paramType.isAssignableFrom(argType))
            (§ return true)
        )
        (cond (ß paramType == int.class)
            (do
                (§ return (ß argType == Integer.class
                    || argType == long.class
                    || argType == Long.class
                    || argType == short.class
                    || argType == byte.class))
            )
            (ß paramType == float.class)
            (do
                (§ return (ß argType == Float.class
                    || argType == double.class))
            )
            (ß paramType == double.class)
            (do
                (§ return (ß argType == Double.class
                    || argType == float.class))
            )
            (ß paramType == long.class)
            (do
                (§ return (ß argType == Long.class
                    || argType == int.class
                    || argType == short.class
                    || argType == byte.class))
            )
            (ß paramType == char.class)
            (do
                (§ return (ß argType == Character.class))
            )
            (ß paramType == short.class)
            (do
                (§ return (ß argType == Short.class))
            )
            (ß paramType == byte.class)
            (do
                (§ return (ß argType == Byte.class))
            )
            (ß paramType == boolean.class)
            (do
                (§ return (ß argType == Boolean.class))
            )
        )
        false
    )

    (§ defn #_"boolean" isCongruent [#_"Class[]" params, #_"Object[]" args]
        (let [#_"boolean" ret false]
            (when (nil? args)
                (§ return (ß (params.length == 0)))
            )
            (when (ß params.length == args.length)
                (§ ass ret true)
                (loop-when-recur [(§ var #_"int" i 0)] (ß ret && i < params.length) [(§ ass i (ß i + 1))]
                    (let [#_"Object" arg (ß args[i])]
                        (let [#_"Class" argType (ß (arg == nil) ? nil :or arg.getClass())]
                            (let [#_"Class" paramType (ß params[i])]
                                (§ ass ret (ß paramArgTypeMatch(paramType, argType)))
                            )
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"Object" prepRet [#_"Class" c, #_"Object" x]
        (when (ß !(c.isPrimitive() || c == Boolean.class))
            (§ return x)
        )
        (when (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE))
        )
        x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (§ def- #_"long" INFINITE -1)

    (§ init
        (§ field- #_"long" count 0) ;; always INFINITE or >0
        (§ field- #_"Object" val nil)
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Repeat" Repeat [#_"long" count, #_"Object" val]
        (let [this (ß super())]
            (§ ass (ß this.count) count)
            (§ ass (ß this.val) val)
            this
        )
    )

    (§ constructor- #_"Repeat" Repeat [#_"IPersistentMap" meta, #_"long" count, #_"Object" val]
        (let [this (ß super(meta))]
            (§ ass (ß this.count) count)
            (§ ass (ß this.val) val)
            this
        )
    )

    (§ defn #_"Repeat" create [#_"Object" val]
        (ß new Repeat(INFINITE, val))
    )

    (§ defn #_"ISeq" create [#_"long" count, #_"Object" val]
        (when (ß count <= 0)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Repeat(count, val))
    )

    #_method
    (§ defn #_"Object" first [#_"Repeat" this]
        val
    )

    #_method
    (§ defn #_"ISeq" next [#_"Repeat" this]
        (when (nil? _next)
            (cond (ß count > 1)
                (do
                    (§ ass _next (ß new Repeat(count - 1, val)))
                )
                (ß count == INFINITE)
                (do
                    (§ ass _next this)
                )
            )
        )
        (ß _next)
    )

    #_method
    (§ defn #_"Repeat" withMeta [#_"Repeat" this, #_"IPersistentMap" meta]
        (ß new Repeat(meta, count, val))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Repeat" this, #_"IFn" f]
        (let [#_"Object" ret val]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (§ ass ret (ß f.invoke(ret, val)))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(§ var #_"long" i 1)] (ß i < count) [(§ ass i (ß i + 1))]
                        (§ ass ret (ß f.invoke(ret, val)))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                    ret
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Repeat" this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret start]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (§ ass ret (ß f.invoke(ret, val)))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(§ var #_"long" i 0)] (ß i < count) [(§ ass i (ß i + 1))]
                        (§ ass ret (ß f.invoke(ret, val)))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_abstract
    (§ defn #_"int" getRequiredArity [#_"RestFn" this])

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object" args]
        nil
    )

    #_method
    (§ defn #_"Object" applyTo [#_"RestFn" this, #_"ISeq" args]
        (when (ß RT.boundedLength(args, getRequiredArity()) <= getRequiredArity())
            (§ return (ß AFn.applyToHelper(this, Util.ret1(args, (§ ass args nil)))))
        )
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (§ return (ß doInvoke(Util.ret1(args, (§ ass args nil)))))
            )
            (§ case 1)
            (do
                (§ return (ß doInvoke(args.first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 2)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 3)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 4)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 5)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 6)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 7)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 8)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 9)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 10)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 11)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 12)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 13)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 14)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 15)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 16)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 17)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 18)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 19)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
            (§ case 20)
            (do
                (§ return (ß doInvoke(args.first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        (§ ass args (ß args.next())).first(),
                        Util.ret1(args.next(), (§ ass args nil)))))
            )
        )
        (ß throwArity(-1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(nil))
            )
            (§ default )
            (do
                (ß throwArity(0))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(ArraySeq.create(Util.ret1(arg1, (§ ass arg1 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(Util.ret1(arg1, (§ ass arg1 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(1))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(2))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    ArraySeq.create(
                        Util.ret1(arg3, (§ ass arg3 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(3))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    ArraySeq.create(
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    ArraySeq.create(
                        Util.ret1(arg4, (§ ass arg4 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(4))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(5))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(6))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(7))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(8))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(9))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    ArraySeq.create(
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(10))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(11))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(12))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(13))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(14))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ArraySeq.create(
                            Util.ret1(arg15, (§ ass arg15 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(15))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)),
                        Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ArraySeq.create(
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                        ArraySeq.create(
                            Util.ret1(arg16, (§ ass arg16 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(16))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)),
                        Util.ret1(arg16, (§ ass arg16 nil)),
                        Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ArraySeq.create(
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                        ArraySeq.create(
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                        ArraySeq.create(
                            Util.ret1(arg17, (§ ass arg17 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(17))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)),
                        Util.ret1(arg16, (§ ass arg16 nil)),
                        Util.ret1(arg17, (§ ass arg17 nil)),
                        Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ArraySeq.create(
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                        ArraySeq.create(
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                        ArraySeq.create(
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                        ArraySeq.create(
                            Util.ret1(arg18, (§ ass arg18 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(18))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)),
                        Util.ret1(arg16, (§ ass arg16 nil)),
                        Util.ret1(arg17, (§ ass arg17 nil)),
                        Util.ret1(arg18, (§ ass arg18 nil)),
                        Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ArraySeq.create(
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                        ArraySeq.create(
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                        ArraySeq.create(
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                        ArraySeq.create(
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                        ArraySeq.create(
                            Util.ret1(arg19, (§ ass arg19 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(19))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)),
                        Util.ret1(arg16, (§ ass arg16 nil)),
                        Util.ret1(arg17, (§ ass arg17 nil)),
                        Util.ret1(arg18, (§ ass arg18 nil)),
                        Util.ret1(arg19, (§ ass arg19 nil)),
                        Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ArraySeq.create(
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ArraySeq.create(
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ArraySeq.create(
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ArraySeq.create(
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ArraySeq.create(
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ArraySeq.create(
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ArraySeq.create(
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ArraySeq.create(
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ArraySeq.create(
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ArraySeq.create(
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ArraySeq.create(
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ArraySeq.create(
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ArraySeq.create(
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ArraySeq.create(
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                        ArraySeq.create(
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                        ArraySeq.create(
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                        ArraySeq.create(
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                        ArraySeq.create(
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)),
                        ArraySeq.create(
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)),
                    Util.ret1(arg20, (§ ass arg20 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(20))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ontoArrayPrepend(args,
                        Util.ret1(arg1, (§ ass arg1 nil)),
                        Util.ret1(arg2, (§ ass arg2 nil)),
                        Util.ret1(arg3, (§ ass arg3 nil)),
                        Util.ret1(arg4, (§ ass arg4 nil)),
                        Util.ret1(arg5, (§ ass arg5 nil)),
                        Util.ret1(arg6, (§ ass arg6 nil)),
                        Util.ret1(arg7, (§ ass arg7 nil)),
                        Util.ret1(arg8, (§ ass arg8 nil)),
                        Util.ret1(arg9, (§ ass arg9 nil)),
                        Util.ret1(arg10, (§ ass arg10 nil)),
                        Util.ret1(arg11, (§ ass arg11 nil)),
                        Util.ret1(arg12, (§ ass arg12 nil)),
                        Util.ret1(arg13, (§ ass arg13 nil)),
                        Util.ret1(arg14, (§ ass arg14 nil)),
                        Util.ret1(arg15, (§ ass arg15 nil)),
                        Util.ret1(arg16, (§ ass arg16 nil)),
                        Util.ret1(arg17, (§ ass arg17 nil)),
                        Util.ret1(arg18, (§ ass arg18 nil)),
                        Util.ret1(arg19, (§ ass arg19 nil)),
                        Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg2, (§ ass arg2 nil)),
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg3, (§ ass arg3 nil)),
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg4, (§ ass arg4 nil)),
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg5, (§ ass arg5 nil)),
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg6, (§ ass arg6 nil)),
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg7, (§ ass arg7 nil)),
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg8, (§ ass arg8 nil)),
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg9, (§ ass arg9 nil)),
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg10, (§ ass arg10 nil)),
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg11, (§ ass arg11 nil)),
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg12, (§ ass arg12 nil)),
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg13, (§ ass arg13 nil)),
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg14, (§ ass arg14 nil)),
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg15, (§ ass arg15 nil)),
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg16, (§ ass arg16 nil)),
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg17, (§ ass arg17 nil)),
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg18, (§ ass arg18 nil)),
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg19, (§ ass arg19 nil)),
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)),
                        ontoArrayPrepend(args,
                            Util.ret1(arg20, (§ ass arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, (§ ass arg1 nil)),
                    Util.ret1(arg2, (§ ass arg2 nil)),
                    Util.ret1(arg3, (§ ass arg3 nil)),
                    Util.ret1(arg4, (§ ass arg4 nil)),
                    Util.ret1(arg5, (§ ass arg5 nil)),
                    Util.ret1(arg6, (§ ass arg6 nil)),
                    Util.ret1(arg7, (§ ass arg7 nil)),
                    Util.ret1(arg8, (§ ass arg8 nil)),
                    Util.ret1(arg9, (§ ass arg9 nil)),
                    Util.ret1(arg10, (§ ass arg10 nil)),
                    Util.ret1(arg11, (§ ass arg11 nil)),
                    Util.ret1(arg12, (§ ass arg12 nil)),
                    Util.ret1(arg13, (§ ass arg13 nil)),
                    Util.ret1(arg14, (§ ass arg14 nil)),
                    Util.ret1(arg15, (§ ass arg15 nil)),
                    Util.ret1(arg16, (§ ass arg16 nil)),
                    Util.ret1(arg17, (§ ass arg17 nil)),
                    Util.ret1(arg18, (§ ass arg18 nil)),
                    Util.ret1(arg19, (§ ass arg19 nil)),
                    Util.ret1(arg20, (§ ass arg20 nil)),
                        ArraySeq.create(args)))
            )
            (§ default )
            (do
                (ß throwArity(21))
            )
        )
    )

    #_protected
    (§ defn #_"ISeq" ontoArrayPrepend [#_"Object[]" array, #_"Object..." args]
        (let [#_"ISeq" ret (ß ArraySeq.create(array))]
            (loop-when-recur [(§ var #_"int" i (ß args.length - 1))] (ß i >= 0) [(§ ass i (ß i - 1))]
                (§ ass ret (ß RT.cons(args[i], ret)))
            )
            ret
        )
    )

    #_protected
    (§ defn #_"ISeq" findKey [#_"Object" key, #_"ISeq" args]
        (while (some? args)
            (when (ß key == args.first())
                (§ return (ß args.next()))
            )
            (§ ass args (ß RT.next(args)))
            (§ ass args (ß RT.next(args)))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(§ interface Reversible
    #_abstract
    (#_"ISeq" rseq [#_"Reversible" this])
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_stateless
(class-ns RT
    (§ def #_"Boolean" T (ß Boolean.TRUE))
    (§ def #_"Boolean" F (ß Boolean.FALSE))
    (§ def #_"String" LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (§ def #_"IPersistentMap" DEFAULT_IMPORTS (ß map(
      #_map Symbol.intern("Boolean"), Boolean.class,
      #_map Symbol.intern("Byte"), Byte.class,
      #_map Symbol.intern("Character"), Character.class,
      #_map Symbol.intern("Class"), Class.class,
      #_map Symbol.intern("ClassLoader"), ClassLoader.class,
      #_map Symbol.intern("Compiler"), Compiler.class,
      #_map Symbol.intern("Double"), Double.class,
      #_map Symbol.intern("Enum"), Enum.class,
      #_map Symbol.intern("Float"), Float.class,
      #_map Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
      #_map Symbol.intern("Integer"), Integer.class,
      #_map Symbol.intern("Long"), Long.class,
      #_map Symbol.intern("Math"), Math.class,
      #_map Symbol.intern("Number"), Number.class,
      #_map Symbol.intern("Object"), Object.class,
      #_map Symbol.intern("Package"), Package.class,
      #_map Symbol.intern("Process"), Process.class,
      #_map Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
      #_map Symbol.intern("Runtime"), Runtime.class,
      #_map Symbol.intern("RuntimePermission"), RuntimePermission.class,
      #_map Symbol.intern("SecurityManager"), SecurityManager.class,
      #_map Symbol.intern("Short"), Short.class,
      #_map Symbol.intern("StackTraceElement"), StackTraceElement.class,
      #_map Symbol.intern("StrictMath"), StrictMath.class,
      #_map Symbol.intern("String"), String.class,
      #_map Symbol.intern("StringBuffer"), StringBuffer.class,
      #_map Symbol.intern("StringBuilder"), StringBuilder.class,
      #_map Symbol.intern("System"), System.class,
      #_map Symbol.intern("Thread"), Thread.class,
      #_map Symbol.intern("ThreadGroup"), ThreadGroup.class,
      #_map Symbol.intern("ThreadLocal"), ThreadLocal.class,
      #_map Symbol.intern("Throwable"), Throwable.class,
      #_map Symbol.intern("Void"), Void.class,
      #_map Symbol.intern("Appendable"), Appendable.class,
      #_map Symbol.intern("CharSequence"), CharSequence.class,
      #_map Symbol.intern("Cloneable"), Cloneable.class,
      #_map Symbol.intern("Comparable"), Comparable.class,
      #_map Symbol.intern("Iterable"), Iterable.class,
      #_map Symbol.intern("Readable"), Readable.class,
      #_map Symbol.intern("Runnable"), Runnable.class,
      #_map Symbol.intern("Callable"), Callable.class,
      #_map Symbol.intern("BigInteger"), BigInteger.class,
      #_map Symbol.intern("BigDecimal"), BigDecimal.class,
      #_map Symbol.intern("ArithmeticException"), ArithmeticException.class,
      #_map Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
      #_map Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
      #_map Symbol.intern("ClassCastException"), ClassCastException.class,
      #_map Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
      #_map Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
      #_map Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
      #_map Symbol.intern("Exception"), Exception.class,
      #_map Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
      #_map Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
      #_map Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
      #_map Symbol.intern("IllegalStateException"), IllegalStateException.class,
      #_map Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
      #_map Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
      #_map Symbol.intern("InstantiationException"), InstantiationException.class,
      #_map Symbol.intern("InterruptedException"), InterruptedException.class,
      #_map Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
      #_map Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
      #_map Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
      #_map Symbol.intern("NullPointerException"), NullPointerException.class,
      #_map Symbol.intern("NumberFormatException"), NumberFormatException.class,
      #_map Symbol.intern("RuntimeException"), RuntimeException.class,
      #_map Symbol.intern("SecurityException"), SecurityException.class,
      #_map Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
      #_map Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
      #_map Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
      #_map Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
      #_map Symbol.intern("AssertionError"), AssertionError.class,
      #_map Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
      #_map Symbol.intern("ClassFormatError"), ClassFormatError.class,
      #_map Symbol.intern("Error"), Error.class,
      #_map Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
      #_map Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
      #_map Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
      #_map Symbol.intern("InstantiationError"), InstantiationError.class,
      #_map Symbol.intern("InternalError"), InternalError.class,
      #_map Symbol.intern("LinkageError"), LinkageError.class,
      #_map Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
      #_map Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
      #_map Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
      #_map Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
      #_map Symbol.intern("StackOverflowError"), StackOverflowError.class,
      #_map Symbol.intern("ThreadDeath"), ThreadDeath.class,
      #_map Symbol.intern("UnknownError"), UnknownError.class,
      #_map Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
      #_map Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
      #_map Symbol.intern("VerifyError"), VerifyError.class,
      #_map Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
      #_map Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
      #_map Symbol.intern("Thread$State"), Thread.State.class,
      #_map Symbol.intern("Deprecated"), Deprecated.class,
      #_map Symbol.intern("Override"), Override.class,
      #_map Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    )))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (§ def #_"Charset" UTF8 (ß Charset.forName("UTF-8")))

    (§ defn #_"Object" readTrueFalseUnknown [#_"String" s]
        (cond (ß s.equals("true"))
            (do
                (§ return (ß Boolean.TRUE))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß Boolean.FALSE))
            )
        )
        (ß Keyword.intern(nil, "unknown"))
    )

    (§ def #_"Namespace" CLOIURE_NS (ß Namespace.findOrCreate(Symbol.intern("cloiure.core"))))
    (§ def #_"Var" OUT (ß Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic()))
    (§ def #_"Var" IN (ß Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic()))
    (§ def #_"Var" ERR (ß Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic()))
    (§ def #_"Keyword" TAG_KEY (ß Keyword.intern(nil, "tag")))
    (§ def #_"Keyword" CONST_KEY (ß Keyword.intern(nil, "const")))
    (§ def #_"Var" AGENT (ß Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), nil).setDynamic()))
    (§ def #_"Object" readeval (ß readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true"))))
    (§ def #_"Var" READEVAL (ß Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"), readeval).setDynamic()))
    (§ def #_"Var" DATA_READERS (ß Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic()))
    (§ def #_"Var" DEFAULT_DATA_READER_FN (ß Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic()))
    (§ def #_"Var" DEFAULT_DATA_READERS (ß Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map())))
    (§ def #_"Var" SUPPRESS_READ (ß Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), nil).setDynamic()))
    (§ def #_"Var" ASSERT (ß Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic()))
    (§ def #_"Var" MATH_CONTEXT (ß Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), nil).setDynamic()))
    (§ def #_"Keyword" LINE_KEY (ß Keyword.intern(nil, "line")))
    (§ def #_"Keyword" COLUMN_KEY (ß Keyword.intern(nil, "column")))
    (§ def #_"Keyword" FILE_KEY (ß Keyword.intern(nil, "file")))
    (§ def #_"Keyword" DECLARED_KEY (ß Keyword.intern(nil, "declared")))
    (§ def #_"Keyword" DOC_KEY (ß Keyword.intern(nil, "doc")))
    (§ def #_"Var" USE_CONTEXT_CLASSLOADER (ß Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic()))
    ;; boolean
    (§ def #_"Var" UNCHECKED_MATH (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic()))

    (§ def #_"Symbol" LOAD_FILE (ß Symbol.intern("load-file")))
    (§ def #_"Symbol" IN_NAMESPACE (ß Symbol.intern("in-ns")))
    (§ def #_"Symbol" NAMESPACE (ß Symbol.intern("ns")))
    (§ def #_"Symbol" IDENTICAL (ß Symbol.intern("identical?")))
    (§ def #_"Var" CMD_LINE_ARGS (ß Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), nil).setDynamic()))
    ;; symbol
    (§ def #_"Var" CURRENT_NS (ß Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic()))

    (§ def #_"Var" FLUSH_ON_NEWLINE (ß Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic()))
    (§ def #_"Var" PRINT_META (ß Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic()))
    (§ def #_"Var" PRINT_READABLY (ß Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic()))
    (§ def #_"Var" PRINT_DUP (ß Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic()))
    (§ def #_"Var" WARN_ON_REFLECTION (ß Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic()))
    (§ def #_"Var" ALLOW_UNRESOLVED_VARS (ß Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic()))
    (§ def #_"Var" READER_RESOLVER (ß Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), nil).setDynamic()))

    (§ def #_"Var" IN_NS_VAR (ß Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F)))
    (§ def #_"Var" NS_VAR (ß Var.intern(CLOIURE_NS, Symbol.intern("ns"), F)))
    (§ def #_"Var" FN_LOADER_VAR (ß Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), nil).setDynamic()))
    (§ def #_"Var" PRINT_INITIALIZED (ß Var.intern(CLOIURE_NS, Symbol.intern("print-initialized"))))
    (§ def #_"Var" PR_ON (ß Var.intern(CLOIURE_NS, Symbol.intern("pr-on"))))

    (§ def #_"IFn" inNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1]
                (let [#_"Symbol" nsname (ß (Symbol) arg1)]
                    (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsname))]
                        (ß CURRENT_NS.set(ns))
                        ns
                    )
                )
            )
        )
    )

    (§ def #_"IFn" bootNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" __form, #_"Object" __env, #_"Object" arg1]
                (let [#_"Symbol" nsname (ß (Symbol) arg1)]
                    (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsname))]
                        (ß CURRENT_NS.set(ns))
                        ns
                    )
                )
            )
        )
    )

    (§ defn #_"List<String>" processCommandLine [#_"String[]" args]
        (let [#_"List<String>" arglist (ß Arrays.asList(args))]
            (let [#_"int" split (ß arglist.indexOf("--"))]
                (when (ß split >= 0)
                    (ß CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length))))
                    (§ return (ß arglist.subList(0, split)))
                )
                arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (§ defn #_"PrintWriter" errPrintWriter []
        (let [#_"Writer" w (ß (Writer) ERR.deref())]
            (if (ß w instanceof PrintWriter)
                (do
                    (ß (PrintWriter) w)
                )
                (do
                    (PrintWriter. w)
                )
            )
        )
    )

    (§ def #_"Object[]" EMPTY_ARRAY (ß new Object[] (§ array )))
    (§ def #_"Comparator" DEFAULT_COMPARATOR (DefaultComparator.))

    #_private
    #_stateless
    (class-ns DefaultComparator (§ implements Comparator)
        #_method
        (§ defn #_"int" compare [#_"DefaultComparator" this, #_"Object" o1, #_"Object" o2]
            (ß Util.compare(o1, o2))
        )
    )

    (§ def #_"AtomicInteger" id (AtomicInteger. 1))

    (§ defn #_"void" addURL [#_"Object" url] (§ throws MalformedURLException)
        (let [#_"URL" u (ß (url instanceof String) ? (new URL((String) url)) :or (URL) url)]
            (let [#_"ClassLoader" ccl (ß Thread.currentThread().getContextClassLoader())]
                (if (ß ccl instanceof DynamicClassLoader)
                    (do
                        (ß ((DynamicClassLoader)ccl).addURL(u))
                    )
                    (do
                        (throw (IllegalAccessError. "Context classloader is not a DynamicClassLoader"))
                    )
                )
                nil
            )
        )
    )

    (§ def #_"boolean" checkSpecAsserts (ß Boolean.getBoolean("cloiure.spec.check-asserts")))
    (§ def #_"boolean" instrumentMacros (ß ! Boolean.getBoolean("cloiure.spec.skip-macros")))
    #_volatile
    (§ def #_"boolean" CHECK_SPECS false)

    (§ static
        (let [#_"Keyword" arglistskw (ß Keyword.intern(nil, "arglists"))]
            (let [#_"Symbol" namesym (ß Symbol.intern("name"))]
                (ß OUT.setTag(Symbol.intern("java.io.Writer")))
                (ß CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace")))
                (ß AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß AGENT.setTag(Symbol.intern("cloiure.lang.Agent")))
                (ß MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext")))
                (let [#_"Var" nv (ß Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace))]
                    (ß nv.setMacro())
                    (§ let [#_"Var" v]
                        (§ ass v (ß Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace)))
                        (ß v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym)))))
                        (§ ass v (ß Var.intern(CLOIURE_NS, LOAD_FILE,
                                (§ reify AFn()
                                    #_method
                                    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" arg1]
                                        (try
                                            (ß Compiler.loadFile((String) arg1))
                                            (catch IOException e
                                                (throw (ß Util.sneakyThrow(e)))
                                            )
                                        )
                                    )
                                )
                            ))
                        )
                        (ß v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym)))))
                        (try
                            (ß doInit())
                            (catch Exception e
                                (throw (ß Util.sneakyThrow(e)))
                            )
                        )

                        (§ ass CHECK_SPECS (ß RT.instrumentMacros))
                    )
                )
            )
        )
    )

    (§ defn #_"Keyword" keyword [#_"String" ns, #_"String" name]
        (ß Keyword.intern((Symbol.intern(ns, name))))
    )

    (§ defn #_"Var" var [#_"String" ns, #_"String" name]
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name)))
    )

    (§ defn #_"Var" var [#_"String" ns, #_"String" name, #_"Object" init]
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name), init))
    )

    (§ defn #_"void" loadResourceScript [#_"String" name] (§ throws IOException)
        (ß loadResourceScript(name, true))
        nil
    )

    (§ defn #_"void" maybeLoadResourceScript [#_"String" name] (§ throws IOException)
        (ß loadResourceScript(name, false))
        nil
    )

    (§ defn #_"void" loadResourceScript [#_"String" name, #_"boolean" failIfNotFound] (§ throws IOException)
        (ß loadResourceScript(RT.class, name, failIfNotFound))
        nil
    )

    (§ defn #_"void" loadResourceScript [#_"Class" c, #_"String" name] (§ throws IOException)
        (ß loadResourceScript(c, name, true))
        nil
    )

    (§ defn #_"void" loadResourceScript [#_"Class" c, #_"String" name, #_"boolean" failIfNotFound] (§ throws IOException)
        (let [#_"int" slash (ß name.lastIndexOf(\/))]
            (let [#_"String" file (ß (slash >= 0) ? name.substring(slash + 1) :or name)]
                (let [#_"InputStream" ins (ß resourceAsStream(baseLoader(), name))]
                    (cond (some? ins)
                        (do
                            (try
                                (ß Compiler.load(new InputStreamReader(ins, UTF8), name, file))
                                (finally
                                    (ß ins.close())
                                )
                            )
                        )
                        failIfNotFound
                        (do
                            (throw (FileNotFoundException. (ß "Could not locate Cloiure resource on classpath: " + name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (§ defn #_"long" lastModified [#_"URL" url, #_"String" libfile] (§ throws IOException)
        (let [#_"URLConnection" connection (ß url.openConnection())]
            (try
                (if (ß url.getProtocol().equals("jar"))
                    (do
                        (ß ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime())
                    )
                    (do
                        (ß connection.getLastModified())
                    )
                )
                (finally
                    (let [#_"InputStream" ins (ß connection.getInputStream())]
                        (when (some? ins)
                            (ß ins.close())
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" compile [#_"String" cljfile] (§ throws IOException)
        (let [#_"InputStream" ins (ß resourceAsStream(baseLoader(), cljfile))]
            (if (some? ins)
                (do
                    (try
                        (ß Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/"))))
                        (finally
                            (ß ins.close())
                        )
                    )
                )
                (do
                    (throw (FileNotFoundException. (ß "Could not locate Cloiure resource on classpath: " + cljfile)))
                )
            )
            nil
        )
    )

    (§ defn #_"void" load [#_"String" scriptbase] (§ throws IOException, ClassNotFoundException)
        (ß load(scriptbase, true))
        nil
    )

    (§ defn #_"void" load [#_"String" scriptbase, #_"boolean" failIfNotFound] (§ throws IOException, ClassNotFoundException)
        (let [#_"String" classfile (ß scriptbase + LOADER_SUFFIX + ".class")]
            (let [#_"String" cljfile (ß scriptbase + ".cli")]
                (let [#_"String" scriptfile cljfile]
                    (let [#_"URL" classURL (ß getResource(baseLoader(), classfile))]
                        (let [#_"URL" cljURL (ß getResource(baseLoader(), scriptfile))]
                            (when (nil? cljURL)
                                (§ ass scriptfile (ß scriptbase + ".clic"))
                                (§ ass cljURL (ß getResource(baseLoader(), scriptfile)))
                            )
                            (let [#_"boolean" loaded false]
                                (when (ß (classURL != nil && (cljURL == nil || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == nil)
                                    (try
                                        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                            #_map CURRENT_NS, CURRENT_NS.deref(),
                                            #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                                            #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                                        )))
                                        (§ ass loaded (ß (loadClassForName(scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil)))
                                        (finally
                                            (ß Var.popThreadBindings())
                                        )
                                    )
                                )
                                (cond (ß !loaded && cljURL != nil)
                                    (do
                                        (if (ß booleanCast(Compiler.COMPILE_FILES.deref()))
                                            (do
                                                (ß compile(scriptfile))
                                            )
                                            (do
                                                (ß loadResourceScript(RT.class, scriptfile))
                                            )
                                        )
                                    )
                                    (ß !loaded && failIfNotFound)
                                    (do
                                        (throw (ß new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile, scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or ""))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" doInit [] (§ throws ClassNotFoundException, IOException)
        (ß load("cloiure/core"))

        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map CURRENT_NS, CURRENT_NS.deref(),
              #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        )))
        (try
            (let [(§ var #_"Symbol" USER (ß Symbol.intern("user")))]
                (let [(§ var #_"Symbol" CLOIURE (ß Symbol.intern("cloiure.core")))]
                    (let [#_"Var" in_ns (ß var("cloiure.core", "in-ns"))]
                        (let [#_"Var" refer (ß var("cloiure.core", "refer"))]
                            (ß in_ns.invoke(USER))
                            (ß refer.invoke(CLOIURE))
                            (ß maybeLoadResourceScript("user.cli"))

                            ;; start socket servers
                            (let [#_"Var" require (ß var("cloiure.core", "require"))]
                                (let [(§ var #_"Symbol" SERVER (ß Symbol.intern("cloiure.core.server")))]
                                    (ß require.invoke(SERVER))
                                    (let [#_"Var" start_servers (ß var("cloiure.core.server", "start-servers"))]
                                        (ß start_servers.invoke(System.getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (ß Var.popThreadBindings())
            )
        )
        nil
    )

    (§ defn #_"int" nextID []
        (ß id.getAndIncrement())
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (§ defn #_"void" loadLibrary [#_"String" libname]
        (ß System.loadLibrary(libname))
        nil
    )

    (§ def- #_"int" CHUNK_SIZE 32)

    (§ defn #_"ISeq" chunkIteratorSeq [#_"Iterator" iter]
        (when (ß iter.hasNext())
            (§ return (ß new LazySeq(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this]
                            (let [#_"Object[]" arr (ß new Object[CHUNK_SIZE])]
                                (let [#_"int" n 0]
                                    (while (ß iter.hasNext() && n < CHUNK_SIZE)
                                        (§ ass (ß arr[n]) (ß iter.next()))
                                        (§ ass n (ß n + 1))
                                    )
                                    (ß new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter)))
                                )
                            )
                        )
                    )
                ))
            )
        )
        nil
    )

    (§ defn #_"ISeq" seq [#_"Object" coll]
        (cond (ß coll instanceof ASeq)
            (do
                (ß (ASeq) coll)
            )
            (ß coll instanceof LazySeq)
            (do
                (ß ((LazySeq) coll).seq())
            )
            :else
            (do
                (ß seqFrom(coll))
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (§ defn #_"ISeq" seqFrom [#_"Object" coll]
        (cond (ß coll instanceof Seqable)
            (do
                (ß ((Seqable) coll).seq())
            )
            (nil? coll)
            (do
                nil
            )
            (ß coll instanceof Iterable)
            (do
                (ß chunkIteratorSeq(((Iterable) coll).iterator()))
            )
            (ß coll.getClass().isArray())
            (do
                (ß ArraySeq.createFromObject(coll))
            )
            (ß coll instanceof CharSequence)
            (do
                (ß StringSeq.create((CharSequence) coll))
            )
            (ß coll instanceof Map)
            (do
                (ß seq(((Map) coll).entrySet()))
            )
            :else
            (do
                (let [#_"Class" c (ß coll.getClass())]
                    (let [#_"Class" sc (ß c.getSuperclass())]
                        (throw (ß new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName())))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" canSeq [#_"Object" coll]
        (ß coll instanceof ISeq
            || coll instanceof Seqable
            || coll == nil
            || coll instanceof Iterable
            || coll.getClass().isArray()
            || coll instanceof CharSequence
            || coll instanceof Map)
    )

    (§ defn #_"Iterator" iter [#_"Object" coll]
        (cond (ß coll instanceof Iterable)
            (do
                (ß ((Iterable)coll).iterator())
            )
            (nil? coll)
            (do
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
            (ß coll instanceof Map)
            (do
                (ß ((Map)coll).entrySet().iterator())
            )
            (ß coll instanceof String)
            (do
                (let [#_"String" s (ß (String) coll)]
                    (§ reify Iterator()
                        (let [#_"int" i 0]
                            #_method
                            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                                (ß (i < s.length()))
                            )

                            #_method
                            (§ defn #_"Object" next [#_"Iterator" this]
                                (let [_ (ß s.charAt(i))]
                                    (§ ass i (ß i + 1))
                                    _
                                )
                            )

                            #_method
                            (§ defn #_"void" remove [#_"Iterator" this]
                                (throw (UnsupportedOperationException.))
                            )
                        )
                    )
                )
            )
            (ß coll.getClass().isArray())
            (do
                (ß ArrayIter.createFromObject(coll))
            )
            :else
            (do
                (ß iter(seq(coll)))
            )
        )
    )

    (§ defn #_"Object" seqOrElse [#_"Object" o]
        (ß (seq(o) == nil) ? nil :or o)
    )

    (§ defn #_"ISeq" keys [#_"Object" coll]
        (if (ß coll instanceof IPersistentMap)
            (do
                (ß APersistentMap.KeySeq.createFromMap((IPersistentMap)coll))
            )
            (do
                (ß APersistentMap.KeySeq.create(seq(coll)))
            )
        )
    )

    (§ defn #_"ISeq" vals [#_"Object" coll]
        (if (ß coll instanceof IPersistentMap)
            (do
                (ß APersistentMap.ValSeq.createFromMap((IPersistentMap)coll))
            )
            (do
                (ß APersistentMap.ValSeq.create(seq(coll)))
            )
        )
    )

    (§ defn #_"IPersistentMap" meta [#_"Object" x]
        (when (ß x instanceof IMeta)
            (§ return (ß ((IMeta) x).meta()))
        )
        nil
    )

    (§ defn #_"int" count [#_"Object" o]
        (when (ß o instanceof Counted)
            (§ return (ß ((Counted) o).count()))
        )
        (ß countFrom(Util.ret1(o, (§ ass o nil))))
    )

    (§ defn #_"int" countFrom [#_"Object" o]
        (cond (nil? o)
            (do
                (§ return 0)
            )
            (ß o instanceof IPersistentCollection)
            (do
                (let [#_"ISeq" s (ß seq(o))]
                    (§ ass o nil)
                    (let [#_"int" i 0]
                        (loop-when-recur [(ß )] (some? s) [(§ ass s (ß s.next()))]
                            (when (ß s instanceof Counted)
                                (§ return (ß i + s.count()))
                            )
                            (§ ass i (ß i + 1))
                        )
                        (§ return i)
                    )
                )
            )
            (ß o instanceof CharSequence)
            (do
                (§ return (ß ((CharSequence) o).length()))
            )
            (ß o instanceof Collection)
            (do
                (§ return (ß ((Collection) o).size()))
            )
            (ß o instanceof Map)
            (do
                (§ return (ß ((Map) o).size()))
            )
            (ß o instanceof Map.Entry)
            (do
                (§ return 2)
            )
            (ß o.getClass().isArray())
            (do
                (§ return (ß Array.getLength(o)))
            )
        )

        (throw (ß new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName())))
    )

    (§ defn #_"IPersistentCollection" conj [#_"IPersistentCollection" coll, #_"Object" x]
        (when (nil? coll)
            (§ return (PersistentList. x))
        )
        (ß coll.cons(x))
    )

    (§ defn #_"ISeq" cons [#_"Object" x, #_"Object" coll]
        (cond (nil? coll)
            (do
                (PersistentList. x)
            )
            (ß coll instanceof ISeq)
            (do
                (ß new Cons(x, (ISeq) coll))
            )
            :else
            (do
                (ß new Cons(x, seq(coll)))
            )
        )
    )

    (§ defn #_"Object" first [#_"Object" x]
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).first()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (nil? seq)
                (§ return nil)
            )
            (ß seq.first())
        )
    )

    (§ defn #_"Object" second [#_"Object" x]
        (ß first(next(x)))
    )

    (§ defn #_"Object" third [#_"Object" x]
        (ß first(next(next(x))))
    )

    (§ defn #_"Object" fourth [#_"Object" x]
        (ß first(next(next(next(x)))))
    )

    (§ defn #_"ISeq" next [#_"Object" x]
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).next()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (nil? seq)
                (§ return nil)
            )
            (ß seq.next())
        )
    )

    (§ defn #_"ISeq" more [#_"Object" x]
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).more()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (nil? seq)
                (§ return (ß PersistentList.EMPTY))
            )
            (ß seq.more())
        )
    )

    (§ defn #_"Object" peek [#_"Object" x]
        (when (nil? x)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).peek())
    )

    (§ defn #_"Object" pop [#_"Object" x]
        (when (nil? x)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).pop())
    )

    (§ defn #_"Object" get [#_"Object" coll, #_"Object" key]
        (when (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key)))
        )
        (ß getFrom(coll, key))
    )

    (§ defn #_"Object" getFrom [#_"Object" coll, #_"Object" key]
        (cond (nil? coll)
            (do
                (§ return nil)
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (§ return (ß m.get(key)))
                )
            )
            (ß coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" set (ß (IPersistentSet) coll)]
                    (§ return (ß set.get(key)))
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (when (ß n >= 0 && n < count(coll))
                        (§ return (ß nth(coll, n)))
                    )
                    (§ return nil)
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" set (ß (ITransientSet) coll)]
                    (§ return (ß set.get(key)))
                )
            )
        )

        nil
    )

    (§ defn #_"Object" get [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (when (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key, notFound)))
        )
        (ß getFrom(coll, key, notFound))
    )

    (§ defn #_"Object" getFrom [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (cond (nil? coll)
            (do
                (§ return notFound)
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (when (ß m.containsKey(key))
                        (§ return (ß m.get(key)))
                    )
                    (§ return notFound)
                )
            )
            (ß coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" set (ß (IPersistentSet) coll)]
                    (when (ß set.contains(key))
                        (§ return (ß set.get(key)))
                    )
                    (§ return notFound)
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (§ return (ß (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound))
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" set (ß (ITransientSet) coll)]
                    (when (ß set.contains(key))
                        (§ return (ß set.get(key)))
                    )
                    (§ return notFound)
                )
            )
        )
        notFound
    )

    (§ defn #_"Associative" assoc [#_"Object" coll, #_"Object" key, #_"Object" val]
        (when (nil? coll)
            (§ return (ß new PersistentArrayMap(new Object[] (§ array key, val ))))
        )
        (ß ((Associative) coll).assoc(key, val))
    )

    (§ defn #_"Object" contains [#_"Object" coll, #_"Object" key]
        (cond (nil? coll)
            (do
                (§ return F)
            )
            (ß coll instanceof Associative)
            (do
                (§ return (ß ((Associative) coll).containsKey(key) ? T :or F))
            )
            (ß coll instanceof IPersistentSet)
            (do
                (§ return (ß ((IPersistentSet) coll).contains(key) ? T :or F))
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (§ return (ß m.containsKey(key) ? T :or F))
                )
            )
            (ß coll instanceof Set)
            (do
                (let [#_"Set" s (ß (Set) coll)]
                    (§ return (ß s.contains(key) ? T :or F))
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (§ return (ß (n >= 0 && n < count(coll)) ? T :or F))
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (§ return (ß ((ITransientSet)coll).contains(key) ? T :or F))
            )
            (ß coll instanceof ITransientAssociative2)
            (do
                (§ return (ß (((ITransientAssociative2)coll).containsKey(key)) ? T :or F))
            )
        )
        (throw (ß new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName())))
    )

    (§ defn #_"Object" find [#_"Object" coll, #_"Object" key]
        (cond (nil? coll)
            (do
                (§ return nil)
            )
            (ß coll instanceof Associative)
            (do
                (§ return (ß ((Associative) coll).entryAt(key)))
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (when (ß m.containsKey(key))
                        (§ return (ß MapEntry.create(key, m.get(key))))
                    )
                    (§ return nil)
                )
            )
            (ß coll instanceof ITransientAssociative2)
            (do
                (§ return (ß ((ITransientAssociative2) coll).entryAt(key)))
            )
        )
        (throw (ß new IllegalArgumentException("find not supported on type: " + coll.getClass().getName())))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (§ defn #_"ISeq" findKey [#_"Keyword" key, #_"ISeq" keyvals]
        (while (some? keyvals)
            (let [#_"ISeq" r (ß keyvals.next())]
                (when (nil? r)
                    (throw (ß Util.runtimeException("Malformed keyword argslist")))
                )
                (when (ß keyvals.first() == key)
                    (§ return r)
                )
                (§ ass keyvals (ß r.next()))
            )
        )
        nil
    )

    (§ defn #_"Object" dissoc [#_"Object" coll, #_"Object" key]
        (when (nil? coll)
            (§ return nil)
        )
        (ß ((IPersistentMap) coll).without(key))
    )

    (§ defn #_"Object" nth [#_"Object" coll, #_"int" n]
        (when (ß coll instanceof Indexed)
            (§ return (ß ((Indexed) coll).nth(n)))
        )
        (ß nthFrom(Util.ret1(coll, (§ ass coll nil)), n))
    )

    (§ defn #_"Object" nthFrom [#_"Object" coll, #_"int" n]
        (cond (nil? coll)
            (do
                nil
            )
            (ß coll instanceof CharSequence)
            (do
                (ß Character.valueOf(((CharSequence) coll).charAt(n)))
            )
            (ß coll.getClass().isArray())
            (do
                (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n)))
            )
            (ß coll instanceof RandomAccess)
            (do
                (ß ((List) coll).get(n))
            )
            (ß coll instanceof Matcher)
            (do
                (ß ((Matcher) coll).group(n))
            )
            (ß coll instanceof Map.Entry)
            (do
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) coll))]
                    (cond (ß n == 0)
                        (do
                            (§ return (ß e.getKey()))
                        )
                        (ß n == 1)
                        (do
                            (§ return (ß e.getValue()))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            (ß coll instanceof Sequential)
            (do
                (let [#_"ISeq" seq (ß RT.seq(coll))]
                    (§ ass coll nil)
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i <= n && seq != nil) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (when (ß i == n)
                            (§ return (ß seq.first()))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn #_"Object" nth [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (when (ß coll instanceof Indexed)
            (let [#_"Indexed" v (ß (Indexed) coll)]
                (§ return (ß v.nth(n, notFound)))
            )
        )
        (ß nthFrom(coll, n, notFound))
    )

    (§ defn #_"Object" nthFrom [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (cond (nil? coll)
            (do
                notFound
            )
            (ß n < 0)
            (do
                notFound
            )
            (ß coll instanceof CharSequence)
            (do
                (let [#_"CharSequence" s (ß (CharSequence) coll)]
                    (when (ß n < s.length())
                        (§ return (ß Character.valueOf(s.charAt(n))))
                    )
                    notFound
                )
            )
            (ß coll.getClass().isArray())
            (do
                (when (ß n < Array.getLength(coll))
                    (§ return (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
                )
                notFound
            )
            (ß coll instanceof RandomAccess)
            (do
                (let [#_"List" list (ß (List) coll)]
                    (when (ß n < list.size())
                        (§ return (ß list.get(n)))
                    )
                    notFound
                )
            )
            (ß coll instanceof Matcher)
            (do
                (let [#_"Matcher" m (ß (Matcher) coll)]
                    (when (ß n < m.groupCount())
                        (§ return (ß m.group(n)))
                    )
                    notFound
                )
            )
            (ß coll instanceof Map.Entry)
            (do
                (let [(§ var #_"Map.Entry" e (ß (Map.Entry) coll))]
                    (cond (ß n == 0)
                        (do
                            (§ return (ß e.getKey()))
                        )
                        (ß n == 1)
                        (do
                            (§ return (ß e.getValue()))
                        )
                    )
                    notFound
                )
            )
            (ß coll instanceof Sequential)
            (do
                (let [#_"ISeq" seq (ß RT.seq(coll))]
                    (§ ass coll nil)
                    (loop-when-recur [(§ var #_"int" i 0)] (ß i <= n && seq != nil) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (when (ß i == n)
                            (§ return (ß seq.first()))
                        )
                    )
                    notFound
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn #_"Object" assocN [#_"int" n, #_"Object" val, #_"Object" coll]
        (cond (nil? coll)
            (do
                nil
            )
            (ß coll instanceof IPersistentVector)
            (do
                (ß ((IPersistentVector) coll).assocN(n, val))
            )
            (ß coll instanceof Object[])
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" array (ß ((Object[]) coll))]
                    (§ ass (ß array[n]) val)
                    array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (§ defn #_"boolean" hasTag [#_"Object" o, #_"Object" tag]
        (ß Util.equals(tag, RT.get(RT.meta(o), TAG_KEY)))
    )

    (§ defn #_"Object" box [#_"Object" x]
        x
    )

    (§ defn #_"Character" box [#_"char" x]
        (ß Character.valueOf(x))
    )

    (§ defn #_"Object" box [#_"boolean" x]
        (ß x ? T :or F)
    )

    (§ defn #_"Object" box [#_"Boolean" x]
        x
    )

    (§ defn #_"Number" box [#_"byte" x]
        x
    )

    (§ defn #_"Number" box [#_"short" x]
        x
    )

    (§ defn #_"Number" box [#_"int" x]
        x
    )

    (§ defn #_"Number" box [#_"long" x]
        x
    )

    (§ defn #_"Number" box [#_"float" x]
        x
    )

    (§ defn #_"Number" box [#_"double" x]
        x
    )

    (§ defn #_"char" charCast [#_"Object" x]
        (when (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (let [#_"long" n (ß ((Number) x).longValue())]
            (when (ß n < Character.MIN_VALUE || n > Character.MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
            )
            (ß (char) n)
        )
    )

    (§ defn #_"char" charCast [#_"byte" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"short" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"char" x]
        x
    )

    (§ defn #_"char" charCast [#_"int" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"long" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"float" x]
        (when (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
    )

    (§ defn #_"char" charCast [#_"double" x]
        (when (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for char: " + x)))
    )

    (§ defn #_"boolean" booleanCast [#_"Object" x]
        (when (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x).booleanValue()))
        )
        (ß (x != nil))
    )

    (§ defn #_"boolean" booleanCast [#_"boolean" x]
        x
    )

    (§ defn #_"byte" byteCast [#_"Object" x]
        (when (ß x instanceof Byte)
            (§ return (ß ((Byte) x).byteValue()))
        )
        (let [#_"long" n (ß longCast(x))]
            (when (ß n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + x)))
            )
            (ß (byte) n)
        )
    )

    (§ defn #_"byte" byteCast [#_"byte" x]
        x
    )

    (§ defn #_"byte" byteCast [#_"short" x]
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn #_"byte" byteCast [#_"int" x]
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn #_"byte" byteCast [#_"long" x]
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn #_"byte" byteCast [#_"float" x]
        (when (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for byte: " + x)))
    )

    (§ defn #_"byte" byteCast [#_"double" x]
        (when (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for byte: " + x)))
    )

    (§ defn #_"short" shortCast [#_"Object" x]
        (when (ß x instanceof Short)
            (§ return (ß ((Short) x).shortValue()))
        )
        (let [#_"long" n (ß longCast(x))]
            (when (ß n < Short.MIN_VALUE || n > Short.MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for short: " + x)))
            )
            (ß (short) n)
        )
    )

    (§ defn #_"short" shortCast [#_"byte" x]
        x
    )

    (§ defn #_"short" shortCast [#_"short" x]
        x
    )

    (§ defn #_"short" shortCast [#_"int" x]
        (let [#_"short" i (ß (short) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for short: " + x)))
            )
            i
        )
    )

    (§ defn #_"short" shortCast [#_"long" x]
        (let [#_"short" i (ß (short) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for short: " + x)))
            )
            i
        )
    )

    (§ defn #_"short" shortCast [#_"float" x]
        (when (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for short: " + x)))
    )

    (§ defn #_"short" shortCast [#_"double" x]
        (when (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for short: " + x)))
    )

    (§ defn #_"int" intCast [#_"Object" x]
        (when (ß x instanceof Integer)
            (§ return (ß ((Integer)x).intValue()))
        )
        (when (ß x instanceof Number)
            (let [#_"long" n (ß longCast(x))]
                (§ return (ß intCast(n)))
            )
        )
        (ß ((Character) x).charValue())
    )

    (§ defn #_"int" intCast [#_"char" x]
        x
    )

    (§ defn #_"int" intCast [#_"byte" x]
        x
    )

    (§ defn #_"int" intCast [#_"short" x]
        x
    )

    (§ defn #_"int" intCast [#_"int" x]
        x
    )

    (§ defn #_"int" intCast [#_"float" x]
        (when (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for int: " + x)))
        )
        (ß (int) x)
    )

    (§ defn #_"int" intCast [#_"long" x]
        (let [#_"int" i (ß (int) x)]
            (when (ß i != x)
                (throw (IllegalArgumentException. (ß "Value out of range for int: " + x)))
            )
            i
        )
    )

    (§ defn #_"int" intCast [#_"double" x]
        (when (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for int: " + x)))
        )
        (ß (int) x)
    )

    (§ defn #_"long" longCast [#_"Object" x]
        (cond (ß x instanceof Integer || x instanceof Long)
            (do
                (ß ((Number) x).longValue())
            )
            (ß x instanceof BigInt)
            (do
                (let [#_"BigInt" bi (ß (BigInt) x)]
                    (if (ß bi.bipart == nil)
                        (do
                            (ß bi.lpart)
                        )
                        (do
                            (throw (IllegalArgumentException. (ß "Value out of range for long: " + x)))
                        )
                    )
                )
            )
            (ß x instanceof BigInteger)
            (do
                (let [#_"BigInteger" bi (ß (BigInteger) x)]
                    (if (ß bi.bitLength() < 64)
                        (do
                            (ß bi.longValue())
                        )
                        (do
                            (throw (IllegalArgumentException. (ß "Value out of range for long: " + x)))
                        )
                    )
                )
            )
            (ß x instanceof Byte || x instanceof Short)
            (do
                (ß ((Number) x).longValue())
            )
            (ß x instanceof Ratio)
            (do
                (ß longCast(((Ratio)x).bigIntegerValue()))
            )
            (ß x instanceof Character)
            (do
                (ß longCast(((Character) x).charValue()))
            )
            :else
            (do
                (ß longCast(((Number)x).doubleValue()))
            )
        )
    )

    (§ defn #_"long" longCast [#_"byte" x]
        x
    )

    (§ defn #_"long" longCast [#_"short" x]
        x
    )

    (§ defn #_"long" longCast [#_"int" x]
        x
    )

    (§ defn #_"long" longCast [#_"float" x]
        (when (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for long: " + x)))
        )
        (ß (long) x)
    )

    (§ defn #_"long" longCast [#_"long" x]
        x
    )

    (§ defn #_"long" longCast [#_"double" x]
        (when (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for long: " + x)))
        )
        (ß (long) x)
    )

    (§ defn #_"float" floatCast [#_"Object" x]
        (when (ß x instanceof Float)
            (§ return (ß ((Float) x).floatValue()))
        )
        (let [#_"double" n (ß ((Number) x).doubleValue())]
            (when (ß n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for float: " + x)))
            )
            (ß (float) n)
        )
    )

    (§ defn #_"float" floatCast [#_"byte" x]
        x
    )

    (§ defn #_"float" floatCast [#_"short" x]
        x
    )

    (§ defn #_"float" floatCast [#_"int" x]
        x
    )

    (§ defn #_"float" floatCast [#_"float" x]
        x
    )

    (§ defn #_"float" floatCast [#_"long" x]
        x
    )

    (§ defn #_"float" floatCast [#_"double" x]
        (when (ß x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for float: " + x)))
        )
        (ß (float) x)
    )

    (§ defn #_"double" doubleCast [#_"Object" x]
        (ß ((Number) x).doubleValue())
    )

    (§ defn #_"double" doubleCast [#_"byte" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"short" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"int" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"float" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"long" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"double" x]
        x
    )

    (§ defn #_"byte" uncheckedByteCast [#_"Object" x]
        (ß ((Number) x).byteValue())
    )

    (§ defn #_"byte" uncheckedByteCast [#_"byte" x]
        x
    )

    (§ defn #_"byte" uncheckedByteCast [#_"short" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"int" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"long" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"float" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"double" x]
        (ß (byte) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"Object" x]
        (ß ((Number) x).shortValue())
    )

    (§ defn #_"short" uncheckedShortCast [#_"byte" x]
        x
    )

    (§ defn #_"short" uncheckedShortCast [#_"short" x]
        x
    )

    (§ defn #_"short" uncheckedShortCast [#_"int" x]
        (ß (short) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"long" x]
        (ß (short) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"float" x]
        (ß (short) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"double" x]
        (ß (short) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"Object" x]
        (when (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (ß (char) ((Number) x).longValue())
    )

    (§ defn #_"char" uncheckedCharCast [#_"byte" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"short" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"char" x]
        x
    )

    (§ defn #_"char" uncheckedCharCast [#_"int" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"long" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"float" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"double" x]
        (ß (char) x)
    )

    (§ defn #_"int" uncheckedIntCast [#_"Object" x]
        (when (ß x instanceof Number)
            (§ return (ß ((Number)x).intValue()))
        )
        (ß ((Character) x).charValue())
    )

    (§ defn #_"int" uncheckedIntCast [#_"byte" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"short" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"char" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"int" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"long" x]
        (ß (int) x)
    )

    (§ defn #_"int" uncheckedIntCast [#_"float" x]
        (ß (int) x)
    )

    (§ defn #_"int" uncheckedIntCast [#_"double" x]
        (ß (int) x)
    )

    (§ defn #_"long" uncheckedLongCast [#_"Object" x]
        (ß ((Number) x).longValue())
    )

    (§ defn #_"long" uncheckedLongCast [#_"byte" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"short" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"int" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"long" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"float" x]
        (ß (long) x)
    )

    (§ defn #_"long" uncheckedLongCast [#_"double" x]
        (ß (long) x)
    )

    (§ defn #_"float" uncheckedFloatCast [#_"Object" x]
        (ß ((Number) x).floatValue())
    )

    (§ defn #_"float" uncheckedFloatCast [#_"byte" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"short" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"int" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"long" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"float" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"double" x]
        (ß (float) x)
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"Object" x]
        (ß ((Number) x).doubleValue())
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"byte" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"short" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"int" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"long" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"float" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"double" x]
        x
    )

    (§ defn #_"IPersistentMap" map [#_"Object..." init]
        (cond (nil? init)
            (do
                (§ return (ß PersistentArrayMap.EMPTY))
            )
            (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (do
                (§ return (ß PersistentArrayMap.createWithCheck(init)))
            )
        )
        (ß PersistentHashMap.createWithCheck(init))
    )

    (§ defn #_"IPersistentMap" mapUniqueKeys [#_"Object..." init]
        (cond (nil? init)
            (do
                (§ return (ß PersistentArrayMap.EMPTY))
            )
            (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap. init))
            )
        )
        (ß PersistentHashMap.create(init))
    )

    (§ defn #_"IPersistentSet" set [#_"Object..." init]
        (ß PersistentHashSet.createWithCheck(init))
    )

    (§ defn #_"IPersistentVector" vector [#_"Object..." init]
        (ß LazilyPersistentVector.createOwning(init))
    )

    (§ defn #_"IPersistentVector" subvec [#_"IPersistentVector" v, #_"int" start, #_"int" end]
        (when (ß end < start || start < 0 || end > v.count())
            (throw (IndexOutOfBoundsException.))
        )
        (when (ß start == end)
            (§ return (ß PersistentVector.EMPTY))
        )
        (ß new APersistentVector.SubVector(nil, v, start, end))
    )

    (§ defn #_"ISeq" list []
        nil
    )

    (§ defn #_"ISeq" list [#_"Object" arg1]
        (PersistentList. arg1)
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2]
        (ß listStar(arg1, arg2, nil))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß listStar(arg1, arg2, arg3, nil))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß listStar(arg1, arg2, arg3, arg4, nil))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß listStar(arg1, arg2, arg3, arg4, arg5, nil))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, rest))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, rest)))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, rest))))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest)))))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest))))))
    )

    (§ defn #_"ISeq" arrayToList [#_"Object[]" a]
        (let [#_"ISeq" ret nil]
            (loop-when-recur [(§ var #_"int" i (ß a.length - 1))] (ß i >= 0) [(§ ass i (ß i - 1))]
                (§ ass ret (ß (ISeq) cons(a[i], ret)))
            )
            ret
        )
    )

    (§ defn #_"Object[]" object_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new Object[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"Object[]" ret (ß new Object[size])]
                            (loop-when-recur [(§ var #_"int" i 0)] (ß i < size && s != nil) [(§ ass i (ß i + 1), s (ß s.next()))]
                                (§ ass (ß ret[i]) (ß s.first()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Object[]" toArray [#_"Object" coll]
        (cond (nil? coll)
            (do
                EMPTY_ARRAY
            )
            (ß coll instanceof Object[])
            (do
                (ß (Object[]) coll)
            )
            (ß coll instanceof Collection)
            (do
                (ß ((Collection) coll).toArray())
            )
            (ß coll instanceof Iterable)
            (do
                (let [#_"ArrayList" ret (ArrayList.)]
                    (doseq [#_"Object" o (ß (Iterable)coll)]
                        (ß ret.add(o))
                    )
                    (ß ret.toArray())
                )
            )
            (ß coll instanceof Map)
            (do
                (ß ((Map) coll).entrySet().toArray())
            )
            (ß coll instanceof String)
            (do
                (let [#_"char[]" chars (ß ((String) coll).toCharArray())]
                    (let [#_"Object[]" ret (ß new Object[chars.length])]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < chars.length) [(§ ass i (ß i + 1))]
                            (§ ass (ß ret[i]) (ß chars[i]))
                        )
                        ret
                    )
                )
            )
            (ß coll.getClass().isArray())
            (do
                (let [#_"ISeq" s (ß (seq(coll)))]
                    (let [#_"Object[]" ret (ß new Object[count(s)])]
                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < ret.length) [(§ ass i (ß i + 1), s (ß s.next()))]
                            (§ ass (ß ret[i]) (ß s.first()))
                        )
                        ret
                    )
                )
            )
            :else
            (do
                (throw (ß Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]")))
            )
        )
    )

    (§ defn #_"Object[]" seqToArray [#_"ISeq" seq]
        (let [#_"int" len (ß length(seq))]
            (let [#_"Object[]" ret (ß new Object[len])]
                (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                    (§ ass (ß ret[i]) (ß seq.first()))
                )
                ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (§ defn #_"Object[]" seqToPassedArray [#_"ISeq" seq, #_"Object[]" passed]
        (let [#_"Object[]" dest passed]
            (let [#_"int" len (ß count(seq))]
                (when (ß len > dest.length)
                    (§ ass dest (ß (Object[]) Array.newInstance(passed.getClass().getComponentType(), len)))
                )
                (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                    (§ ass (ß dest[i]) (ß seq.first()))
                )
                (when (ß len < passed.length)
                    (§ ass (ß dest[len]) nil)
                )
                dest
            )
        )
    )

    (§ defn #_"Object" seqToTypedArray [#_"ISeq" seq]
        (let [#_"Class" type (ß (seq != nil && seq.first() != nil) ? seq.first().getClass() :or Object.class)]
            (ß seqToTypedArray(type, seq))
        )
    )

    (§ defn #_"Object" seqToTypedArray [#_"Class" type, #_"ISeq" seq]
        (let [#_"Object" ret (ß Array.newInstance(type, length(seq)))]
            (cond (ß type == Integer.TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (ß Array.set(ret, i, intCast(seq.first())))
                    )
                )
                (ß type == Byte.TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (ß Array.set(ret, i, byteCast(seq.first())))
                    )
                )
                (ß type == Float.TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (ß Array.set(ret, i, floatCast(seq.first())))
                    )
                )
                (ß type == Short.TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (ß Array.set(ret, i, shortCast(seq.first())))
                    )
                )
                (ß type == Character.TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (ß Array.set(ret, i, charCast(seq.first())))
                    )
                )
                :else
                (do
                    (loop-when-recur [(§ var #_"int" i 0)] (some? seq) [(§ ass i (ß i + 1), seq (ß seq.next()))]
                        (ß Array.set(ret, i, seq.first()))
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"int" length [#_"ISeq" list]
        (let [#_"int" i 0]
            (loop-when-recur [(§ var #_"ISeq" c list)] (some? c) [(§ ass c (ß c.next()))]
                (§ ass i (ß i + 1))
            )
            i
        )
    )

    (§ defn #_"int" boundedLength [#_"ISeq" list, #_"int" limit]
        (let [#_"int" i 0]
            (loop-when-recur [(§ var #_"ISeq" c list)] (ß c != nil && i <= limit) [(§ ass c (ß c.next()))]
                (§ ass i (ß i + 1))
            )
            i
        )
    )

    (§ defn #_"Character" readRet [#_"int" ret]
        (when (ß ret == -1)
            (§ return nil)
        )
        (ß box((char) ret))
    )

    (§ defn #_"Character" readChar [#_"Reader" r] (§ throws IOException)
        (let [#_"int" ret (ß r.read())]
            (ß readRet(ret))
        )
    )

    (§ defn #_"Character" peekChar [#_"Reader" r] (§ throws IOException)
        (§ let [#_"int" ret]
            (if (ß r instanceof PushbackReader)
                (do
                    (§ ass ret (ß r.read()))
                    (ß ((PushbackReader) r).unread(ret))
                )
                (do
                    (ß r.mark(1))
                    (§ ass ret (ß r.read()))
                    (ß r.reset())
                )
            )

            (ß readRet(ret))
        )
    )

    (§ defn #_"int" getLineNumber [#_"Reader" r]
        (when (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getLineNumber()))
        )
        0
    )

    (§ defn #_"int" getColumnNumber [#_"Reader" r]
        (when (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getColumnNumber()))
        )
        0
    )

    (§ defn #_"LineNumberingPushbackReader" getLineNumberingReader [#_"Reader" r]
        (when (ß isLineNumberingReader(r))
            (§ return (ß (LineNumberingPushbackReader) r))
        )
        (LineNumberingPushbackReader. r)
    )

    (§ defn #_"boolean" isLineNumberingReader [#_"Reader" r]
        (ß (r instanceof LineNumberingPushbackReader))
    )

    (§ defn #_"boolean" isReduced [#_"Object" r]
        (ß (r instanceof Reduced))
    )

    (§ defn #_"String" resolveClassNameInContext [#_"String" className]
        ;; todo - look up in context var
        className
    )

    (§ defn #_"boolean" suppressRead []
        (ß booleanCast(SUPPRESS_READ.deref()))
    )

    (§ defn #_"String" printString [#_"Object" x]
        (try
            (let [#_"StringWriter" sw (StringWriter.)]
                (ß print(x, sw))
                (ß sw.toString())
            )
            (catch Exception e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ defn #_"Object" readString [#_"String" s]
        (ß readString(s, nil))
    )

    (§ defn #_"Object" readString [#_"String" s, #_"Object" opts]
        (let [#_"PushbackReader" r (ß new PushbackReader(new StringReader(s)))]
            (ß LispReader.read(r, opts))
        )
    )

    (§ defn #_"void" print [#_"Object" x, #_"Writer" w] (§ throws IOException)
        ;; call multimethod
        (if (ß PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref()))
            (do
                (ß PR_ON.invoke(x, w))
            )
            (do
                (let [#_"boolean" readably (ß booleanCast(PRINT_READABLY.deref()))]
                    (when (ß x instanceof Obj)
                        (let [#_"Obj" o (ß (Obj) x)]
                            (when (ß RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                                (let [#_"IPersistentMap" meta (ß o.meta())]
                                    (ß w.write("#^"))
                                    (if (ß meta.count() == 1 && meta.containsKey(TAG_KEY))
                                        (do
                                            (ß print(meta.valAt(TAG_KEY), w))
                                        )
                                        (do
                                            (ß print(meta, w))
                                        )
                                    )
                                    (ß w.write(\space))
                                )
                            )
                        )
                    )
                    (cond (nil? x)
                        (do
                            (ß w.write("nil"))
                        )
                        (ß x instanceof ISeq || x instanceof IPersistentList)
                        (do
                            (ß w.write(\())
                            (ß printInnerSeq(seq(x), w))
                            (ß w.write(\)))
                        )
                        (ß x instanceof String)
                        (do
                            (let [#_"String" s (ß (String) x)]
                                (if (ß !readably)
                                    (do
                                        (ß w.write(s))
                                    )
                                    (do
                                        (ß w.write(\")) ;; oops! "
                                        (loop-when-recur [(§ var #_"int" i 0)] (ß i < s.length()) [(§ ass i (ß i + 1))]
                                            (let [#_"char" c (ß s.charAt(i))]
                                                (§ switch c
                                                    (§ case \newline)
                                                    (do
                                                        (ß w.write("\\n"))
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (ß w.write("\\t"))
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (ß w.write("\\r"))
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (ß w.write("\\\\"))
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (ß w.write("\\f"))
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (ß w.write("\\b"))
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (ß w.write(c))
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (ß x instanceof IPersistentMap)
                        (do
                            (ß w.write(\{))
                            (loop-when-recur [(§ var #_"ISeq" s (ß seq(x)))] (some? s) [(§ ass s (ß s.next()))]
                                (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                                    (ß print(e.key(), w))
                                    (ß w.write(\space))
                                    (ß print(e.val(), w))
                                    (when (ß s.next() != nil)
                                        (ß w.write(", "))
                                    )
                                )
                            )
                            (ß w.write(\}))
                        )
                        (ß x instanceof IPersistentVector)
                        (do
                            (let [#_"IPersistentVector" a (ß (IPersistentVector) x)]
                                (ß w.write(\[))
                                (loop-when-recur [(§ var #_"int" i 0)] (ß i < a.count()) [(§ ass i (ß i + 1))]
                                    (ß print(a.nth(i), w))
                                    (when (ß i < a.count() - 1)
                                        (ß w.write(\space))
                                    )
                                )
                                (ß w.write(\]))
                            )
                        )
                        (ß x instanceof IPersistentSet)
                        (do
                            (ß w.write("#{"))
                            (loop-when-recur [(§ var #_"ISeq" s (ß seq(x)))] (some? s) [(§ ass s (ß s.next()))]
                                (ß print(s.first(), w))
                                (when (ß s.next() != nil)
                                    (ß w.write(" "))
                                )
                            )
                            (ß w.write(\}))
                        )
                        (ß x instanceof Character)
                        (do
                            (let [#_"char" c (ß ((Character) x).charValue())]
                                (if (ß !readably)
                                    (do
                                        (ß w.write(c))
                                    )
                                    (do
                                        (ß w.write(\\))
                                        (§ switch c
                                            (§ case \newline)
                                            (do
                                                (ß w.write("newline"))
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (ß w.write("tab"))
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (ß w.write("space"))
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (ß w.write("backspace"))
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (ß w.write("formfeed"))
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (ß w.write("return"))
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (ß w.write(c))
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß x instanceof Class)
                        (do
                            (ß w.write("#="))
                            (ß w.write(((Class) x).getName()))
                        )
                        (ß x instanceof BigDecimal && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write(\M))
                        )
                        (ß x instanceof BigInt && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write(\N))
                        )
                        (ß x instanceof BigInteger && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write("BIGINT"))
                        )
                        (ß x instanceof Var)
                        (do
                            (let [#_"Var" v (ß (Var) x)]
                                (ß w.write("#=(var " + v.ns.name + "/" + v.sym + ")"))
                            )
                        )
                        (ß x instanceof Pattern)
                        (do
                            (let [#_"Pattern" p (ß (Pattern) x)]
                                (ß w.write("#\"" + p.pattern() + "\""))
                            )
                        )
                        :else
                        (do
                            (ß w.write(x.toString()))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" printInnerSeq [#_"ISeq" x, #_"Writer" w] (§ throws IOException)
        (loop-when-recur [(§ var #_"ISeq" s x)] (some? s) [(§ ass s (ß s.next()))]
            (ß print(s.first(), w))
            (when (ß s.next() != nil)
                (ß w.write(\space))
            )
        )
        nil
    )

    (§ defn #_"void" formatAesthetic [#_"Writer" w, #_"Object" obj] (§ throws IOException)
        (if (nil? obj)
            (do
                (ß w.write("nil"))
            )
            (do
                (ß w.write(obj.toString()))
            )
        )
        nil
    )

    (§ defn #_"void" formatStandard [#_"Writer" w, #_"Object" obj] (§ throws IOException)
        (cond (nil? obj)
            (do
                (ß w.write("nil"))
            )
            (ß obj instanceof String)
            (do
                (ß w.write(\")) ;; oops! "
                (ß w.write((String) obj))
                (ß w.write(\")) ;; oops! "
            )
            (ß obj instanceof Character)
            (do
                (ß w.write(\\))
                (let [#_"char" c (ß ((Character) obj).charValue())]
                    (§ switch c
                        (§ case \newline)
                        (do
                            (ß w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (ß w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (ß w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (ß w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (ß w.write("formfeed"))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (ß w.write(c))
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (ß w.write(obj.toString()))
            )
        )
        nil
    )

    (§ defn #_"Object" format [#_"Object" o, #_"String" s, #_"Object..." args] (§ throws IOException)
        (§ let [#_"Writer" w]
            (cond (nil? o)
                (do
                    (§ ass w (StringWriter.))
                )
                (ß Util.equals(o, T))
                (do
                    (§ ass w (ß (Writer) OUT.deref()))
                )
                :else
                (do
                    (§ ass w (ß (Writer) o))
                )
            )
            (ß doFormat(w, s, ArraySeq.create(args)))
            (when (nil? o)
                (§ return (ß w.toString()))
            )
            nil
        )
    )

    (§ defn #_"ISeq" doFormat [#_"Writer" w, #_"String" s, #_"ISeq" args] (§ throws IOException)
        (loop-when-recur [(§ var #_"int" i 0)] (ß i < s.length()) [(ß )]
            (let [#_"char" c (ß s.charAt(i))]
                (§ ass i (ß i + 1))
                (§ switch (ß Character.toLowerCase(c))
                    (§ case \~)
                    (do
                        (let [#_"char" d (ß s.charAt(i))]
                            (§ ass i (ß i + 1))
                            (§ switch (ß Character.toLowerCase(d))
                                (§ case \%)
                                (do
                                    (ß w.write(\newline))
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (ß w.write(\tab))
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (nil? args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT.formatAesthetic(w, RT.first(args)))
                                    (§ ass args (ß RT.next(args)))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (nil? args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT.formatStandard(w, RT.first(args)))
                                    (§ ass args (ß RT.next(args)))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" j (ß s.indexOf("~}", i))] ;; note - does not nest
                                        (when (ß j == -1)
                                            (throw (IllegalArgumentException. "Missing ~}"))
                                        )
                                        (let [#_"String" subs (ß s.substring(i, j))]
                                            (loop-when-recur [(§ var #_"ISeq" sargs (ß RT.seq(RT.first(args))))] (some? sargs) [(ß )]
                                                (§ ass sargs (ß doFormat(w, subs, sargs)))
                                            )
                                            (§ ass args (ß RT.next(args)))
                                            (§ ass i (ß j + 2)) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (nil? args)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (IllegalArgumentException. (ß "Unsupported ~ directive: " + d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (ß w.write(c))
                        (§ break )
                    )
                )
            )
        )
        args
    )

    (§ defn #_"Object[]" setValues [#_"Object..." vals]
        (when (ß vals.length > 0)
            (§ return vals)
        )
        nil
    )

    (§ defn #_"ClassLoader" makeClassLoader []
        (ß (ClassLoader) AccessController.doPrivileged(
                (§ reify PrivilegedAction()
                    #_method
                    (§ defn #_"Object" run [#_"PrivilegedAction" this]
                        (try
                            (ß Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T)))
                            (ß new DynamicClassLoader(baseLoader()))
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"ClassLoader" baseLoader []
        (cond (ß Compiler.LOADER.isBound())
            (do
                (§ return (ß (ClassLoader) Compiler.LOADER.deref()))
            )
            (ß booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread.currentThread().getContextClassLoader()))
            )
        )
        (ß Compiler.class.getClassLoader())
    )

    (§ defn #_"InputStream" resourceAsStream [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (do
                (ß ClassLoader.getSystemResourceAsStream(name))
            )
            (do
                (ß loader.getResourceAsStream(name))
            )
        )
    )

    (§ defn #_"URL" getResource [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (do
                (ß ClassLoader.getSystemResource(name))
            )
            (do
                (ß loader.getResource(name))
            )
        )
    )

    (§ defn #_"Class" classForName [#_"String" name, #_"boolean" load, #_"ClassLoader" loader]
        (try
            (let [#_"Class" c nil]
                (when (ß !(loader instanceof DynamicClassLoader))
                    (§ ass c (ß DynamicClassLoader.findInMemoryClass(name)))
                )
                (when (some? c)
                    (§ return c)
                )
                (ß Class.forName(name, load, loader))
            )
            (catch ClassNotFoundException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ defn #_"Class" classForName [#_"String" name]
        (ß classForName(name, true, baseLoader()))
    )

    (§ defn #_"Class" classForNameNonLoading [#_"String" name]
        (ß classForName(name, false, baseLoader()))
    )

    (§ defn #_"Class" loadClassForName [#_"String" name]
        (try
            (ß classForNameNonLoading(name))
            (catch Exception e
                (if (ß e instanceof ClassNotFoundException)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
            )
        )
        (ß classForName(name))
    )

    (§ defn #_"float" aget [#_"float[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"float" aset [#_"float[]" xs, #_"int" i, #_"float" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"float[]" xs]
        (ß xs.length)
    )

    (§ defn #_"float[]" aclone [#_"float[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"double" aget [#_"double[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"double" aset [#_"double[]" xs, #_"int" i, #_"double" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"double[]" xs]
        (ß xs.length)
    )

    (§ defn #_"double[]" aclone [#_"double[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"int" aget [#_"int[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"int" aset [#_"int[]" xs, #_"int" i, #_"int" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"int[]" xs]
        (ß xs.length)
    )

    (§ defn #_"int[]" aclone [#_"int[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"long" aget [#_"long[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"long" aset [#_"long[]" xs, #_"int" i, #_"long" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"long[]" xs]
        (ß xs.length)
    )

    (§ defn #_"long[]" aclone [#_"long[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"char" aget [#_"char[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"char" aset [#_"char[]" xs, #_"int" i, #_"char" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"char[]" xs]
        (ß xs.length)
    )

    (§ defn #_"char[]" aclone [#_"char[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"byte" aget [#_"byte[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"byte" aset [#_"byte[]" xs, #_"int" i, #_"byte" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"byte[]" xs]
        (ß xs.length)
    )

    (§ defn #_"byte[]" aclone [#_"byte[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"short" aget [#_"short[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"short" aset [#_"short[]" xs, #_"int" i, #_"short" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"short[]" xs]
        (ß xs.length)
    )

    (§ defn #_"short[]" aclone [#_"short[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"boolean" aget [#_"boolean[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"boolean" aset [#_"boolean[]" xs, #_"int" i, #_"boolean" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"boolean[]" xs]
        (ß xs.length)
    )

    (§ defn #_"boolean[]" aclone [#_"boolean[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"Object" aget [#_"Object[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"Object" aset [#_"Object[]" xs, #_"int" i, #_"Object" v]
        (§ ass (ß xs[i]) v)
        v
    )

    (§ defn #_"int" alength [#_"Object[]" xs]
        (ß xs.length)
    )

    (§ defn #_"Object[]" aclone [#_"Object[]" xs]
        (ß xs.clone())
    )
)
)

(java-ns cloiure.lang.Seqable

(§ interface Seqable
    #_abstract
    (#_"ISeq" seq [#_"Seqable" this])
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (§ init
        (§ field #_"ISeq" seq nil)
    )

    (§ constructor #_"SeqEnumeration" SeqEnumeration [#_"ISeq" seq]
        (let [this (ß super())]
            (§ ass (ß this.seq) seq)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasMoreElements [#_"SeqEnumeration" this]
        (ß (seq != nil))
    )

    #_method
    (§ defn #_"Object" nextElement [#_"SeqEnumeration" this]
        (let [#_"Object" ret (ß RT.first(seq))]
            (§ ass seq (ß RT.next(seq)))
            ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (§ def #_"Object" START (Object.))

    (§ init
        (§ field #_"Object" seq nil)
        (§ field #_"Object" next nil)
    )

    (§ constructor #_"SeqIterator" SeqIterator [#_"Object" o]
        (let [this (ß super())]
            (§ ass seq START)
            (§ ass next o)
            this
        )
    )

    ;; preserved for binary compatibility
    (§ constructor #_"SeqIterator" SeqIterator [#_"ISeq" o]
        (let [this (ß super())]
            (§ ass seq START)
            (§ ass next o)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"SeqIterator" this]
        (cond (ß seq == START)
            (do
                (§ ass seq nil)
                (§ ass next (ß RT.seq(next)))
            )
            (ß seq == next)
            (do
                (§ ass next (ß RT.next(seq)))
            )
        )
        (ß (next != nil))
    )

    #_method
    (§ defn #_"Object" next [#_"SeqIterator" this] (§ throws NoSuchElementException)
        (when (ß !hasNext())
            (throw (NoSuchElementException.))
        )
        (§ ass seq next)
        (ß RT.first(next))
    )

    #_method
    (§ defn #_"void" remove [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Sequential

(§ interface Sequential
)
)

(java-ns cloiure.lang.Settable

(§ interface Settable
    #_abstract
    (#_"Object" doSet [#_"Settable" this, #_"Object" val])
    #_abstract
    (#_"Object" doReset [#_"Settable" this, #_"Object" val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ interface Sorted
    #_abstract
    (#_"Comparator" comparator [#_"Sorted" this])
    #_abstract
    (#_"Object" entryKey [#_"Sorted" this, #_"Object" entry])
    #_abstract
    (#_"ISeq" seq [#_"Sorted" this, #_"boolean" ascending])
    #_abstract
    (#_"ISeq" seqFrom [#_"Sorted" this, #_"Object" key, #_"boolean" ascending])
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (§ defn #_"StringSeq" create [#_"CharSequence" s]
        (when (ß s.length() == 0)
            (§ return nil)
        )
        (ß new StringSeq(nil, s, 0))
    )

    (§ init
        (§ field #_"CharSequence" s nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"StringSeq" StringSeq [#_"IPersistentMap" meta, #_"CharSequence" s, #_"int" i]
        (let [this (ß super(meta))]
            (§ ass (ß this.s) s)
            (§ ass (ß this.i) i)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"StringSeq" this, #_"IPersistentMap" meta]
        (when (ß meta == meta())
            (§ return this)
        )
        (ß new StringSeq(meta, s, i))
    )

    #_method
    (§ defn #_"Object" first [#_"StringSeq" this]
        (ß Character.valueOf(s.charAt(i)))
    )

    #_method
    (§ defn #_"ISeq" next [#_"StringSeq" this]
        (when (ß i + 1 < s.length())
            (§ return (ß new StringSeq(_meta, s, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"StringSeq" this]
        i
    )

    #_method
    (§ defn #_"int" count [#_"StringSeq" this]
        (ß s.length() - i)
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (§ defn #_"Symbol" create [#_"String" ns, #_"String" name]
        (ß Symbol.intern(ns, name))
    )

    (§ defn #_"Symbol" create [#_"String" nsname]
        (ß Symbol.intern(nsname))
    )

    (§ defn #_"Symbol" intern [#_"String" ns, #_"String" name]
        (ß new Symbol(ns, name))
    )

    (§ defn #_"Symbol" intern [#_"String" nsname]
        (let [#_"int" i (ß nsname.indexOf(\/))]
            (if (ß i == -1 || nsname.equals("/"))
                (do
                    (ß new Symbol(nil, nsname))
                )
                (do
                    (ß new Symbol(nsname.substring(0, i), nsname.substring(i + 1)))
                )
            )
        )
    )

    (§ init
        (§ field #_"String" ns nil)
        (§ field #_"String" name nil)
        (§ field- #_"int" _hasheq 0)
        (§ field #_"IPersistentMap" _meta nil)
        #_transient
        (§ field #_"String" _str nil)
    )

    (§ constructor- #_"Symbol" Symbol [#_"String" ns_interned, #_"String" name_interned]
        (let [this (ß super())]
            (§ ass (ß this.name) name_interned)
            (§ ass (ß this.ns) ns_interned)
            (§ ass (ß this._meta) nil)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Symbol" this]
        (when (nil? _str)
            (if (some? ns)
                (do
                    (§ ass _str (ß (ns + "/" + name)))
                )
                (do
                    (§ ass _str name)
                )
            )
        )
        (ß _str)
    )

    #_method
    (§ defn #_"String" getNamespace [#_"Symbol" this]
        ns
    )

    #_method
    (§ defn #_"String" getName [#_"Symbol" this]
        name
    )

    #_method
    (§ defn #_"boolean" equals [#_"Symbol" this, #_"Object" o]
        (when (ß this == o)
            (§ return true)
        )
        (when (ß !(o instanceof Symbol))
            (§ return false)
        )

        (let [#_"Symbol" symbol (ß (Symbol) o)]
            (ß Util.equals(ns, symbol.ns) && name.equals(symbol.name))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"Symbol" this]
        (ß Util.hashCombine(name.hashCode(), Util.hash(ns)))
    )

    #_method
    (§ defn #_"int" hasheq [#_"Symbol" this]
        (when (ß _hasheq == 0)
            (§ ass _hasheq (ß Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns))))
        )
        (ß _hasheq)
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"Symbol" this, #_"IPersistentMap" meta]
        (ß new Symbol(meta, ns, name))
    )

    (§ constructor- #_"Symbol" Symbol [#_"IPersistentMap" meta, #_"String" ns, #_"String" name]
        (let [this (ß super())]
            (§ ass (ß this.name) name)
            (§ ass (ß this.ns) ns)
            (§ ass (ß this._meta) meta)
            this
        )
    )

    #_method
    (§ defn #_"int" compareTo [#_"Symbol" this, #_"Object" o]
        (let [#_"Symbol" s (ß (Symbol) o)]
            (when (ß this.equals(o))
                (§ return 0)
            )
            (when (ß this.ns == nil && s.ns != nil)
                (§ return -1)
            )
            (when (ß this.ns != nil)
                (when (ß s.ns == nil)
                    (§ return 1)
                )
                (let [#_"int" nsc (ß this.ns.compareTo(s.ns))]
                    (when (ß nsc != 0)
                        (§ return nsc)
                    )
                )
            )
            (ß this.name.compareTo(s.name))
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"Symbol" this, #_"Object" obj]
        (ß RT.get(obj, this))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Symbol" this, #_"Object" obj, #_"Object" notFound]
        (ß RT.get(obj, this, notFound))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Symbol" this]
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def #_"Keyword" TAG_KW (ß Keyword.intern("tag")))
    (§ def #_"Keyword" FORM_KW (ß Keyword.intern("form")))

    (§ defn #_"TaggedLiteral" create [#_"Symbol" tag, #_"Object" form]
        (ß new TaggedLiteral(tag, form))
    )

    (§ init
        (§ field #_"Symbol" tag nil)
        (§ field #_"Object" form nil)
    )

    (§ constructor- #_"TaggedLiteral" TaggedLiteral [#_"Symbol" tag, #_"Object" form]
        (let [this (ß super())]
            (§ ass (ß this.tag) tag)
            (§ ass (ß this.form) form)
            this
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"TaggedLiteral" this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TaggedLiteral" this, #_"Object" key, #_"Object" notFound]
        (cond (ß FORM_KW.equals(key))
            (do
                (ß this.form)
            )
            (ß TAG_KW.equals(key))
            (do
                (ß this.tag)
            )
            :else
            (do
                notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" equals [#_"TaggedLiteral" this, #_"Object" o]
        (when (ß this == o)
            (§ return true)
        )
        (when (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (let [#_"TaggedLiteral" that (ß (TaggedLiteral) o)]
            (when (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
                (§ return false)
            )
            (when (ß (tag != nil) ? !tag.equals(that.tag) :or that.tag != nil)
                (§ return false)
            )

            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" hashCode [#_"TaggedLiteral" this]
        (let [#_"int" result (ß Util.hash(tag))]
            (§ ass result (ß 31 * result + Util.hash(form)))
            result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (§ init
        (§ field #_"Ref[]" bins nil)
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap []
        (let [this (ß this(421))]
            this
        )
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap [#_"int" nBins]
        (let [this (ß super())]
            (§ ass bins (ß new Ref[nBins]))
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < nBins) [(§ ass i (ß i + 1))]
                (§ ass (ß bins[i]) (Ref. (ß PersistentHashMap.EMPTY)))
            )
            this
        )
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap [#_"Map<? extends K, ? extends V>" m]
        (let [this (ß this(m.size()))]
            (ß putAll(m))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" mapAt [#_"TransactionalHashMap" this, #_"int" bin]
        (ß (IPersistentMap) bins[bin].deref())
    )

    #_method
    (§ defn #_"int" binFor [#_"TransactionalHashMap" this, #_"Object" k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" h (ß k.hashCode())]
            (§ ass h (ß h :xor ((h >>> 20) :xor (h >>> 12))))
            (§ ass h (ß h :xor ((h >>> 7) :xor (h >>> 4))))
            (ß h % bins.length)
        )
    )

    #_method
    (§ defn #_"Entry" entryAt [#_"TransactionalHashMap" this, #_"Object" k]
        (ß mapAt(binFor(k)).entryAt(k))
    )

    #_method
    (§ defn #_"int" size [#_"TransactionalHashMap" this]
        (let [#_"int" n 0]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < bins.length) [(§ ass i (ß i + 1))]
                (§ ass n (ß n + mapAt(i).count()))
            )
            n
        )
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"TransactionalHashMap" this]
        (ß (size() == 0))
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"TransactionalHashMap" this, #_"Object" k]
        (ß (entryAt(k) != nil))
    )

    #_method
    (§ defn #_"V" get [#_"TransactionalHashMap" this, #_"Object" k]
        (let [#_"Entry" e (ß entryAt(k))]
            (when (some? e)
                (§ return (ß (V) e.getValue()))
            )
            nil
        )
    )

    #_method
    (§ defn #_"V" put [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Object" ret (ß map.valAt(k))]
                    (ß r.set(map.assoc(k, v)))
                    (ß (V) ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" remove [#_"TransactionalHashMap" this, #_"Object" k]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Object" ret (ß map.valAt(k))]
                    (ß r.set(map.without(k)))
                    (ß (V) ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" putAll [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" map]
        (loop-when-recur [(§ var #_"Iterator" i (ß map.entrySet().iterator()))] (ß i.hasNext()) [(ß )]
            (let [#_"Entry<K, V>" e (ß (Entry) i.next())]
                (ß put(e.getKey(), e.getValue()))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" clear [#_"TransactionalHashMap" this]
        (loop-when-recur [(§ var #_"int" i 0)] (ß i < bins.length) [(§ ass i (ß i + 1))]
            (let [#_"Ref" r (ß bins[i])]
                (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                    (when (ß map.count() > 0)
                        (ß r.set(PersistentHashMap.EMPTY))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" entrySet [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map.Entry<K, V>>" entries (ArrayList. (ß bins.length))]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < bins.length) [(§ ass i (ß i + 1))]
                (let [#_"IPersistentMap" map (ß mapAt(i))]
                    (when (ß map.count() > 0)
                        (ß entries.addAll((Collection) RT.seq(map)))
                    )
                )
            )
            (§ reify AbstractSet<Entry<K, V>>()
                #_method
                (§ defn #_"Iterator" iterator [#_"AbstractSet<Entry<K, V>>" this]
                    (ß Collections.unmodifiableList(entries).iterator())
                )

                #_method
                (§ defn #_"int" size [#_"AbstractSet<Entry<K, V>>" this]
                    (ß entries.size())
                )
            )
        )
    )

    #_method
    (§ defn #_"V" putIfAbsent [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (if (nil? e)
                        (do
                            (ß r.set(map.assoc(k, v)))
                            nil
                        )
                        (do
                            (ß (V) e.getValue())
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" remove [#_"TransactionalHashMap" this, #_"Object" k, #_"Object" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil && e.getValue().equals(v))
                        (ß r.set(map.without(k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" replace [#_"TransactionalHashMap" this, #_"K" k, #_"V" oldv, #_"V" newv]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil && e.getValue().equals(oldv))
                        (ß r.set(map.assoc(k, newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"V" replace [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (some? e)
                        (ß r.set(map.assoc(k, v)))
                        (§ return (ß (V) e.getValue()))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

(class-ns TransformerIterator (§ implements Iterator)
    (§ def- #_"Buffer" EMPTY (Empty.))
    (§ def- #_"Object" NONE (Object.))

    (§ init
        ;; Source
        (§ field- #_"Iterator" sourceIter nil)
        (§ field- #_"IFn" xf nil)
        (§ field- #_"boolean" multi false)

        ;; Iteration state
        #_volatile
        (§ field- #_"Buffer" buffer EMPTY)
        #_volatile
        (§ field- #_"Object" next NONE)
        #_volatile
        (§ field- #_"boolean" completed false)
    )

    (§ constructor- #_"TransformerIterator" TransformerIterator [#_"IFn" xform, #_"Iterator" sourceIter, #_"boolean" multi]
        (let [this (ß super())]
            (§ ass (ß this.sourceIter) sourceIter)
            (§ ass (ß this.xf) (ß (IFn) xform.invoke(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this]
                            nil
                        )

                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" acc]
                            acc
                        )

                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" acc, #_"Object" o]
                            (§ ass buffer (ß buffer.add(o)))
                            acc
                        )
                    )
                )
            ))
            (§ ass (ß this.multi) multi)
            this
        )
    )

    (§ defn #_"Iterator" create [#_"IFn" xform, #_"Iterator" source]
        (ß new TransformerIterator(xform, source, false))
    )

    (§ defn #_"Iterator" createMulti [#_"IFn" xform, #_"List" sources]
        (let [#_"Iterator[]" iters (ß new Iterator[sources.size()])]
            (loop-when-recur [(§ var #_"int" i 0)] (ß i < sources.size()) [(§ ass i (ß i + 1))]
                (§ ass (ß iters[i]) (ß (Iterator)sources.get(i)))
            )
            (ß new TransformerIterator(xform, new MultiIterator(iters), true))
        )
    )

    #_method
    (§ defn- #_"boolean" step [#_"TransformerIterator" this]
        (when (ß next != NONE)
            (§ return true)
        )

        (while (ß next == NONE)
            (if (ß buffer.isEmpty())
                (do
                    (cond completed
                        (do
                            (§ return false)
                        )
                        (ß sourceIter.hasNext())
                        (do
                            (let [#_"Object" iter nil]
                                (if multi
                                    (do
                                        (§ ass iter (ß xf.applyTo(RT.cons(nil, sourceIter.next()))))
                                    )
                                    (do
                                        (§ ass iter (ß xf.invoke(nil, sourceIter.next())))
                                    )
                                )

                                (when (ß RT.isReduced(iter))
                                    (ß xf.invoke(nil))
                                    (§ ass completed true)
                                )
                            )
                        )
                        :else
                        (do
                            (ß xf.invoke(nil))
                            (§ ass completed true)
                        )
                    )
                )
                (do
                    (§ ass next (ß buffer.remove()))
                )
            )
        )
        true
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"TransformerIterator" this]
        (ß step())
    )

    #_method
    (§ defn #_"Object" next [#_"TransformerIterator" this]
        (when (ß hasNext())
            (let [#_"Object" ret next]
                (§ ass next NONE)
                (§ return ret)
            )
        )
        (throw (NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )

    #_private
    (§ interface Buffer
        #_abstract
        (#_"Buffer" add [#_"Buffer" this, #_"Object" o])
        #_abstract
        (#_"Object" remove [#_"Buffer" this])
        #_abstract
        (#_"boolean" isEmpty [#_"Buffer" this])
    )

    #_private
    #_stateless
    (class-ns Empty (§ implements Buffer)
        #_method
        (§ defn #_"Buffer" add [#_"Empty" this, #_"Object" o]
            (Single. o)
        )

        #_method
        (§ defn #_"Object" remove [#_"Empty" this]
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )

        #_method
        (§ defn #_"boolean" isEmpty [#_"Empty" this]
            true
        )

        #_method
        (§ defn #_"String" toString [#_"Empty" this]
            "Empty"
        )
    )

    #_private
    (class-ns Single (§ implements Buffer)
        (§ init
            #_volatile
            (§ field- #_"Object" val nil)
        )

        (§ constructor #_"Single" Single [#_"Object" o]
            (let [this (ß super())]
                (§ ass (ß this.val) o)
                this
            )
        )

        #_method
        (§ defn #_"Buffer" add [#_"Single" this, #_"Object" o]
            (if (ß val == NONE)
                (do
                    (§ ass val o)
                    this
                )
                (do
                    (ß new Many(val, o))
                )
            )
        )

        #_method
        (§ defn #_"Object" remove [#_"Single" this]
            (when (ß val == NONE)
                (throw (IllegalStateException. "Removing object from empty buffer"))
            )
            (let [#_"Object" ret val]
                (§ ass val NONE)
                ret
            )
        )

        #_method
        (§ defn #_"boolean" isEmpty [#_"Single" this]
            (ß (val == NONE))
        )

        #_method
        (§ defn #_"String" toString [#_"Single" this]
            (ß "Single: " + val)
        )
    )

    #_private
    (class-ns Many (§ implements Buffer)
        (§ init
            (§ field- #_"Queue" vals (LinkedList.))
        )

        (§ constructor #_"Many" Many [#_"Object" o1, #_"Object" o2]
            (let [this (ß super())]
                (ß vals.add(o1))
                (ß vals.add(o2))
                this
            )
        )

        #_method
        (§ defn #_"Buffer" add [#_"Many" this, #_"Object" o]
            (ß vals.add(o))
            this
        )

        #_method
        (§ defn #_"Object" remove [#_"Many" this]
            (ß vals.remove())
        )

        #_method
        (§ defn #_"boolean" isEmpty [#_"Many" this]
            (ß vals.isEmpty())
        )

        #_method
        (§ defn #_"String" toString [#_"Many" this]
            (ß "Many: " + vals.toString())
        )
    )

    #_private
    (class-ns MultiIterator (§ implements Iterator)
        (§ init
            (§ field- #_"Iterator[]" iters nil)
        )

        (§ constructor #_"MultiIterator" MultiIterator [#_"Iterator[]" iters]
            (let [this (ß super())]
                (§ ass (ß this.iters) iters)
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasNext [#_"MultiIterator" this]
            (doseq [#_"Iterator" iter iters]
                (when (ß !iter.hasNext())
                    (§ return false)
                )
            )
            true
        )

        #_method
        (§ defn #_"Object" next [#_"MultiIterator" this]
            (let [#_"Object[]" nexts (ß new Object[iters.length])]
                (loop-when-recur [(§ var #_"int" i 0)] (ß i < iters.length) [(§ ass i (ß i + 1))]
                    (§ ass (ß nexts[i]) (ß iters[i].next()))
                )
                (ß new ArraySeq(nexts, 0))
            )
        )

        #_method
        (§ defn #_"void" remove [#_"MultiIterator" this]
            (throw (UnsupportedOperationException.))
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns Tuple
    (§ def #_"int" MAX_SIZE 6)

    (§ defn #_"IPersistentVector" create []
        (ß PersistentVector.EMPTY)
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0]
        (ß RT.vector(v0))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1]
        (ß RT.vector(v0, v1))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2]
        (ß RT.vector(v0, v1, v2))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3]
        (ß RT.vector(v0, v1, v2, v3))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4]
        (ß RT.vector(v0, v1, v2, v3, v4))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4, #_"Object" v5]
        (ß RT.vector(v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

#_stateless
(class-ns Util
    (§ defn #_"boolean" equiv [#_"Object" k1, #_"Object" k2]
        (when (ß k1 == k2)
            (§ return true)
        )
        (when (some? k1)
            (cond (ß k1 instanceof Number && k2 instanceof Number)
                (do
                    (§ return (ß Numbers.equal((Number)k1, (Number)k2)))
                )
                (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                (do
                    (§ return (ß pcequiv(k1, k2)))
                )
            )
            (§ return (ß k1.equals(k2)))
        )
        false
    )

    (§ interface EquivPred
        #_abstract
        (#_"boolean" equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2])
    )

    (§ def #_"EquivPred" equivNull
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (ß (k2 == nil))
            )
        )
    )

    (§ def #_"EquivPred" equivEquals
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (ß k1.equals(k2))
            )
        )
    )

    (§ def #_"EquivPred" equivNumber
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (when (ß k2 instanceof Number)
                    (§ return (ß Numbers.equal((Number) k1, (Number) k2)))
                )
                false
            )
        )
    )

    (§ def #_"EquivPred" equivColl
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (when (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(k1, k2)))
                )
                (ß k1.equals(k2))
            )
        )
    )

    (§ defn #_"EquivPred" equivPred [#_"Object" k1]
        (cond (nil? k1)
            (do
                (§ return equivNull)
            )
            (ß k1 instanceof Number)
            (do
                (§ return equivNumber)
            )
            (ß k1 instanceof String || k1 instanceof Symbol)
            (do
                (§ return equivEquals)
            )
            (ß k1 instanceof Collection || k1 instanceof Map)
            (do
                (§ return equivColl)
            )
        )
        equivEquals
    )

    (§ defn #_"boolean" equiv [#_"long" k1, #_"long" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"boolean" equiv [#_"Object" k1, #_"long" k2]
        (ß equiv(k1, (Object)k2))
    )

    (§ defn #_"boolean" equiv [#_"long" k1, #_"Object" k2]
        (ß equiv((Object)k1, k2))
    )

    (§ defn #_"boolean" equiv [#_"double" k1, #_"double" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"boolean" equiv [#_"Object" k1, #_"double" k2]
        (ß equiv(k1, (Object)k2))
    )

    (§ defn #_"boolean" equiv [#_"double" k1, #_"Object" k2]
        (ß equiv((Object)k1, k2))
    )

    (§ defn #_"boolean" equiv [#_"boolean" k1, #_"boolean" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"boolean" equiv [#_"Object" k1, #_"boolean" k2]
        (ß equiv(k1, (Object)k2))
    )

    (§ defn #_"boolean" equiv [#_"boolean" k1, #_"Object" k2]
        (ß equiv((Object)k1, k2))
    )

    (§ defn #_"boolean" equiv [#_"char" c1, #_"char" c2]
        (ß (c1 == c2))
    )

    (§ defn #_"boolean" pcequiv [#_"Object" k1, #_"Object" k2]
        (when (ß k1 instanceof IPersistentCollection)
            (§ return (ß ((IPersistentCollection)k1).equiv(k2)))
        )
        (ß ((IPersistentCollection)k2).equiv(k1))
    )

    (§ defn #_"boolean" equals [#_"Object" k1, #_"Object" k2]
        (when (ß k1 == k2)
            (§ return true)
        )
        (ß (k1 != nil && k1.equals(k2)))
    )

    (§ defn #_"boolean" identical [#_"Object" k1, #_"Object" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"Class" classOf [#_"Object" x]
        (when (some? x)
            (§ return (ß x.getClass()))
        )
        nil
    )

    (§ defn #_"int" compare [#_"Object" k1, #_"Object" k2]
        (when (ß k1 == k2)
            (§ return 0)
        )
        (when (some? k1)
            (when (nil? k2)
                (§ return 1)
            )
            (when (ß k1 instanceof Number)
                (§ return (ß Numbers.compare((Number) k1, (Number) k2)))
            )
            (§ return (ß ((Comparable) k1).compareTo(k2)))
        )
        -1
    )

    (§ defn #_"int" hash [#_"Object" o]
        (when (nil? o)
            (§ return 0)
        )
        (ß o.hashCode())
    )

    (§ defn #_"int" hasheq [#_"Object" o]
        (when (nil? o)
            (§ return 0)
        )
        (when (ß o instanceof IHashEq)
            (§ return (ß dohasheq((IHashEq) o)))
        )
        (when (ß o instanceof Number)
            (§ return (ß Numbers.hasheq((Number)o)))
        )
        (when (ß o instanceof String)
            (§ return (ß Murmur3.hashInt(o.hashCode())))
        )
        (ß o.hashCode())
    )

    (§ defn- #_"int" dohasheq [#_"IHashEq" o]
        (ß o.hasheq())
    )

    (§ defn #_"int" hashCombine [#_"int" seed, #_"int" hash]
        ;; a la boost
        (§ ass seed (ß seed :xor (hash + 0x9e3779b9 + (seed << 6) + (seed >> 2))))
        seed
    )

    (§ defn #_"boolean" isPrimitive [#_"Class" c]
        (ß (c != nil && c.isPrimitive() && !(c == Void.TYPE)))
    )

    (§ defn #_"boolean" isInteger [#_"Object" x]
        (ß (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger))
    )

    (§ defn #_"Object" ret1 [#_"Object" ret, #_"Object" nil]
        ret
    )

    (§ defn #_"ISeq" ret1 [#_"ISeq" ret, #_"Object" nil]
        ret
    )

    (§ defn #_"<K, V> void" clearCache [#_"ReferenceQueue" rq, #_"ConcurrentHashMap<K, Reference<V>>" cache]
        ;; cleanup any dead entries
        (when (ß rq.poll() != nil)
            (while (ß rq.poll() != nil)
            )
            (doseq [#_"Map.Entry<K, Reference<V>>" (ß e cache.entrySet())]
                (let [#_"Reference<V>" val (ß e.getValue())]
                    (when (ß val != nil && val.get() == nil)
                        (ß cache.remove(e.getKey(), val))
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"RuntimeException" runtimeException [#_"String" s]
        (RuntimeException. s)
    )

    (§ defn #_"RuntimeException" runtimeException [#_"String" s, #_"Throwable" e]
        (ß new RuntimeException(s, e))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (§ defn #_"RuntimeException" sneakyThrow [#_"Throwable" t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (nil? t)
            (throw (NullPointerException.))
        )
        (ß Util.<RuntimeException>sneakyThrow0(t))
        nil
    )

    (§ defn- #_"<T extends Throwable> void" sneakyThrow0 [#_"Throwable" t] (§ throws T)
        (throw (ß (T) t))
    )

    (§ defn #_"Object" loadWithClass [#_"String" scriptbase, #_"Class<?>" loadFrom] (§ throws IOException, ClassNotFoundException)
        (ß Var.pushThreadBindings(RT.map(new Object[] (§ array Compiler.LOADER, loadFrom.getClassLoader() ))))
        (try
            (ß RT.var("cloiure.core", "load").invoke(scriptbase))
            (finally
                (ß Var.popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (class-ns TBox
        (§ init
            #_volatile
            (§ field #_"Object" val nil)
            (§ field #_"Thread" thread nil)
        )

        (§ constructor #_"TBox" TBox [#_"Thread" t, #_"Object" val]
            (let [this (ß super())]
                (§ ass (ß this.thread) t)
                (§ ass (ß this.val) val)
                this
            )
        )
    )

    (class-ns Unbound (§ extends AFn)
        (§ init
            (§ field #_"Var" v nil)
        )

        (§ constructor #_"Unbound" Unbound [#_"Var" v]
            (let [this (ß super())]
                (§ ass (ß this.v) v)
                this
            )
        )

        #_method
        (§ defn #_"String" toString [#_"Unbound" this]
            (ß "Unbound: " + v)
        )

        #_method
        (§ defn #_"Object" throwArity [#_"Unbound" this, #_"int" n]
            (throw (IllegalStateException. (ß "Attempting to call unbound fn: " + v)))
        )
    )

    (class-ns Frame
        (§ def #_"Frame" TOP (ß new Frame(PersistentHashMap.EMPTY, nil)))

        (§ init
            ;; Var->TBox
            (§ field #_"Associative" bindings nil)
            ;; Var->val
            (§ field #_"Frame" prev nil)
        )

        (§ constructor #_"Frame" Frame [#_"Associative" bindings, #_"Frame" prev]
            (let [this (ß super())]
                (§ ass (ß this.bindings) bindings)
                (§ ass (ß this.prev) prev)
                this
            )
        )

        #_protected
        #_method
        (§ defn #_"Object" clone [#_"Frame" this]
            (ß new Frame(this.bindings, nil))
        )
    )

    (§ def #_"ThreadLocal<Frame>" dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_method
            (§ defn #_"Frame" initialValue [#_"ThreadLocal<Frame>" this]
                (ß Frame.TOP)
            )
        )
    )

    #_volatile
    (§ def #_"int" rev 0)

    (§ def #_"Keyword" privateKey (ß Keyword.intern(nil, "private")))
    (§ def #_"IPersistentMap" privateMeta (ß new PersistentArrayMap(new Object[] (§ array privateKey, Boolean.TRUE ))))
    (§ def #_"Keyword" macroKey (ß Keyword.intern(nil, "macro")))
    (§ def #_"Keyword" nameKey (ß Keyword.intern(nil, "name")))
    (§ def #_"Keyword" nsKey (ß Keyword.intern(nil, "ns")))

    (§ defn #_"Object" getThreadBindingFrame []
        (ß dvals.get())
    )

    (§ defn #_"Object" cloneThreadBindingFrame []
        (ß dvals.get().clone())
    )

    (§ defn #_"void" resetThreadBindingFrame [#_"Object" frame]
        (ß dvals.set((Frame) frame))
        nil
    )

    (§ defn #_"Var" intern [#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
        (ß intern(ns, sym, root, true))
    )

    (§ defn #_"Var" intern [#_"Namespace" ns, #_"Symbol" sym, #_"Object" root, #_"boolean" replaceRoot]
        (let [#_"Var" dvout (ß ns.intern(sym))]
            (when (ß !dvout.hasRoot() || replaceRoot)
                (ß dvout.bindRoot(root))
            )
            dvout
        )
    )

    (§ defn #_"Var" find [#_"Symbol" nsQualifiedSym]
        (when (ß nsQualifiedSym.ns == nil)
            (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
        )
        (let [#_"Namespace" ns (ß Namespace.find(Symbol.intern(nsQualifiedSym.ns)))]
            (when (nil? ns)
                (throw (IllegalArgumentException. (ß "No such namespace: " + nsQualifiedSym.ns)))
            )
            (ß ns.findInternedVar(Symbol.intern(nsQualifiedSym.name)))
        )
    )

    (§ defn #_"Var" intern [#_"Symbol" nsName, #_"Symbol" sym]
        (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsName))]
            (ß intern(ns, sym))
        )
    )

    (§ defn #_"Var" internPrivate [#_"String" nsName, #_"String" sym]
        (let [#_"Namespace" ns (ß Namespace.findOrCreate(Symbol.intern(nsName)))]
            (let [#_"Var" ret (ß intern(ns, Symbol.intern(sym)))]
                (ß ret.setMeta(privateMeta))
                ret
            )
        )
    )

    (§ defn #_"Var" intern [#_"Namespace" ns, #_"Symbol" sym]
        (ß ns.intern(sym))
    )

    (§ defn #_"Var" create []
        (ß new Var(nil, nil))
    )

    (§ defn #_"Var" create [#_"Object" root]
        (ß new Var(nil, nil, root))
    )

    (§ init
        #_volatile
        (§ field #_"Object" root nil)

        #_volatile
        (§ field #_"boolean" dynamic false)
        #_transient
        (§ field #_"AtomicBoolean" threadBound nil)
        (§ field #_"Symbol" sym nil)
        (§ field #_"Namespace" ns nil)
    )

    (§ constructor #_"Var" Var [#_"Namespace" ns, #_"Symbol" sym]
        (let [this (ß super())]
            (§ ass (ß this.ns) ns)
            (§ ass (ß this.sym) sym)
            (§ ass (ß this.threadBound) (AtomicBoolean. false))
            (§ ass (ß this.root) (Unbound. this))
            (ß setMeta(PersistentHashMap.EMPTY))
            this
        )
    )

    (§ constructor #_"Var" Var [#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
        (let [this (ß this(ns, sym))]
            (§ ass (ß this.root) root)
            (§ ass rev (ß rev + 1))
            this
        )
    )

    #_method
    (§ defn #_"Var" setDynamic [#_"Var" this]
        (§ ass (ß this.dynamic) true)
        this
    )

    #_method
    (§ defn #_"Var" setDynamic [#_"Var" this, #_"boolean" b]
        (§ ass (ß this.dynamic) b)
        this
    )

    #_method
    (§ defn #_"boolean" isDynamic [#_"Var" this]
        dynamic
    )

    #_method
    (§ defn #_"String" toString [#_"Var" this]
        (when (some? ns)
            (§ return (ß "#'" + ns.name + "/" + sym))
        )
        (ß "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">")
    )

    #_method
    (§ defn #_"boolean" isBound [#_"Var" this]
        (ß (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this))))
    )

    #_method
    (§ defn #_"Object" get [#_"Var" this]
        (when (ß !threadBound.get())
            (§ return root)
        )
        (ß deref())
    )

    #_method
    (§ defn #_"Object" deref [#_"Var" this]
        (let [#_"TBox" b (ß getThreadBinding())]
            (when (some? b)
                (§ return (ß b.val))
            )
            root
        )
    )

    #_method
    (§ defn #_"void" setValidator [#_"Var" this, #_"IFn" vf]
        (when (ß hasRoot())
            (ß validate(vf, root))
        )
        (§ ass validator vf)
        nil
    )

    #_method
    (§ defn #_"Object" alter [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (ß set(fn.applyTo(RT.cons(deref(), args))))
        this
    )

    #_method
    (§ defn #_"Object" set [#_"Var" this, #_"Object" val]
        (ß validate(getValidator(), val))
        (let [#_"TBox" b (ß getThreadBinding())]
            (when (some? b)
                (when (ß Thread.currentThread() != b.thread)
                    (throw (ß new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym))))
                )
                (§ ass (ß b.val) val)
                (§ return val)
            )
            (throw (ß new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym))))
        )
    )

    #_method
    (§ defn #_"Object" doSet [#_"Var" this, #_"Object" val]
        (ß set(val))
    )

    #_method
    (§ defn #_"Object" doReset [#_"Var" this, #_"Object" val]
        (ß bindRoot(val))
        val
    )

    #_method
    (§ defn #_"void" setMeta [#_"Var" this, #_"IPersistentMap" m]
        ;; ensure these basis keys
        (ß resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns)))
        nil
    )

    #_method
    (§ defn #_"void" setMacro [#_"Var" this]
        (ß alterMeta(assoc, RT.list(macroKey, RT.T)))
        nil
    )

    #_method
    (§ defn #_"boolean" isMacro [#_"Var" this]
        (ß RT.booleanCast(meta().valAt(macroKey)))
    )

    #_method
    (§ defn #_"boolean" isPublic [#_"Var" this]
        (ß !RT.booleanCast(meta().valAt(privateKey)))
    )

    #_method
    (§ defn #_"Object" getRawRoot [#_"Var" this]
        root
    )

    #_method
    (§ defn #_"Object" getTag [#_"Var" this]
        (ß meta().valAt(RT.TAG_KEY))
    )

    #_method
    (§ defn #_"void" setTag [#_"Var" this, #_"Symbol" tag]
        (ß alterMeta(assoc, RT.list(RT.TAG_KEY, tag)))
        nil
    )

    #_method
    (§ defn #_"boolean" hasRoot [#_"Var" this]
        (ß !(root instanceof Unbound))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" bindRoot [#_"Var" this, #_"Object" root]
        (§ sync this
            (ß validate(getValidator(), root))
            (let [#_"Object" oldroot (ß this.root)]
                (§ ass (ß this.root) root)
                (§ ass rev (ß rev + 1))
                (ß alterMeta(dissoc, RT.list(macroKey)))
                (ß notifyWatches(oldroot, this.root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" swapRoot [#_"Var" this, #_"Object" root]
        (§ sync this
            (ß validate(getValidator(), root))
            (let [#_"Object" oldroot (ß this.root)]
                (§ ass (ß this.root) root)
                (§ ass rev (ß rev + 1))
                (ß notifyWatches(oldroot, root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" unbindRoot [#_"Var" this]
        (§ sync this
            (§ ass (ß this.root) (Unbound. this))
            (§ ass rev (ß rev + 1))
        )
        nil
    )

    #_method
    (§ defn #_"void" commuteRoot [#_"Var" this, #_"IFn" fn]
        (§ sync this
            (let [#_"Object" newRoot (ß fn.invoke(root))]
                (ß validate(getValidator(), newRoot))
                (let [#_"Object" oldroot root]
                    (§ ass (ß this.root) newRoot)
                    (§ ass rev (ß rev + 1))
                    (ß notifyWatches(oldroot, newRoot))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" alterRoot [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (§ sync this
            (let [#_"Object" newRoot (ß fn.applyTo(RT.cons(root, args)))]
                (ß validate(getValidator(), newRoot))
                (let [#_"Object" oldroot root]
                    (§ ass (ß this.root) newRoot)
                    (§ ass rev (ß rev + 1))
                    (ß notifyWatches(oldroot, newRoot))
                    newRoot
                )
            )
        )
    )

    (§ defn #_"void" pushThreadBindings [#_"Associative" bindings]
        (let [#_"Frame" f (ß dvals.get())]
            (let [#_"Associative" bmap (ß f.bindings)]
                (loop-when-recur [(§ var #_"ISeq" bs (ß bindings.seq()))] (some? bs) [(§ ass bs (ß bs.next()))]
                    (let [#_"IMapEntry" e (ß (IMapEntry) bs.first())]
                        (let [#_"Var" v (ß (Var) e.key())]
                            (when (ß !v.dynamic)
                                (throw (ß new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym))))
                            )
                            (ß v.validate(v.getValidator(), e.val()))
                            (ß v.threadBound.set(true))
                            (§ ass bmap (ß bmap.assoc(v, new TBox(Thread.currentThread(), e.val()))))
                        )
                    )
                )
                (ß dvals.set(new Frame(bmap, f)))
                nil
            )
        )
    )

    (§ defn #_"void" popThreadBindings []
        (let [#_"Frame" f (ß dvals.get().prev)]
            (cond (nil? f)
                (do
                    (throw (IllegalStateException. "Pop without matching push"))
                )
                (ß f == Frame.TOP)
                (do
                    (ß dvals.remove())
                )
                :else
                (do
                    (ß dvals.set(f))
                )
            )
            nil
        )
    )

    (§ defn #_"Associative" getThreadBindings []
        (let [#_"Frame" f (ß dvals.get())]
            (let [#_"IPersistentMap" ret (ß PersistentHashMap.EMPTY)]
                (loop-when-recur [(§ var #_"ISeq" bs (ß f.bindings.seq()))] (some? bs) [(§ ass bs (ß bs.next()))]
                    (let [#_"IMapEntry" e (ß (IMapEntry) bs.first())]
                        (let [#_"Var" v (ß (Var) e.key())]
                            (let [#_"TBox" b (ß (TBox) e.val())]
                                (§ ass ret (ß ret.assoc(v, b.val)))
                            )
                        )
                    )
                )
                ret
            )
        )
    )

    #_method
    (§ defn #_"TBox" getThreadBinding [#_"Var" this]
        (when (ß threadBound.get())
            (let [#_"IMapEntry" e (ß dvals.get().bindings.entryAt(this))]
                (when (some? e)
                    (§ return (ß (TBox) e.val()))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IFn" fn [#_"Var" this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [#_"Var" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"Var" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil)),
                Util.ret1(arg16, (§ ass arg16 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil)),
                Util.ret1(arg16, (§ ass arg16 nil)),
                Util.ret1(arg17, (§ ass arg17 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil)),
                Util.ret1(arg16, (§ ass arg16 nil)),
                Util.ret1(arg17, (§ ass arg17 nil)),
                Util.ret1(arg18, (§ ass arg18 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil)),
                Util.ret1(arg16, (§ ass arg16 nil)),
                Util.ret1(arg17, (§ ass arg17 nil)),
                Util.ret1(arg18, (§ ass arg18 nil)),
                Util.ret1(arg19, (§ ass arg19 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil)),
                Util.ret1(arg16, (§ ass arg16 nil)),
                Util.ret1(arg17, (§ ass arg17 nil)),
                Util.ret1(arg18, (§ ass arg18 nil)),
                Util.ret1(arg19, (§ ass arg19 nil)),
                Util.ret1(arg20, (§ ass arg20 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß fn().invoke(Util.ret1(arg1, (§ ass arg1 nil)),
                Util.ret1(arg2, (§ ass arg2 nil)),
                Util.ret1(arg3, (§ ass arg3 nil)),
                Util.ret1(arg4, (§ ass arg4 nil)),
                Util.ret1(arg5, (§ ass arg5 nil)),
                Util.ret1(arg6, (§ ass arg6 nil)),
                Util.ret1(arg7, (§ ass arg7 nil)),
                Util.ret1(arg8, (§ ass arg8 nil)),
                Util.ret1(arg9, (§ ass arg9 nil)),
                Util.ret1(arg10, (§ ass arg10 nil)),
                Util.ret1(arg11, (§ ass arg11 nil)),
                Util.ret1(arg12, (§ ass arg12 nil)),
                Util.ret1(arg13, (§ ass arg13 nil)),
                Util.ret1(arg14, (§ ass arg14 nil)),
                Util.ret1(arg15, (§ ass arg15 nil)),
                Util.ret1(arg16, (§ ass arg16 nil)),
                Util.ret1(arg17, (§ ass arg17 nil)),
                Util.ret1(arg18, (§ ass arg18 nil)),
                Util.ret1(arg19, (§ ass arg19 nil)),
                Util.ret1(arg20, (§ ass arg20 nil)),
                (Object[])Util.ret1(args, (§ ass args nil))))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Var" this, #_"ISeq" arglist]
        (ß fn().applyTo(arglist))
    )

    (§ def #_"IFn" assoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" m, #_"Object" k, #_"Object" v]
                (ß RT.assoc(m, k, v))
            )
        )
    )

    (§ def #_"IFn" dissoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" c, #_"Object" k]
                (ß RT.dissoc(c, k))
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"Volatile" Volatile [#_"Object" val]
        (let [this (ß super())]
            (§ ass (ß this.val) val)
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Volatile" this]
        val
    )

    #_method
    (§ defn #_"Object" reset [#_"Volatile" this, #_"Object" newval]
        (§ ass (ß this.val) newval)
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" CLOIURE_MAIN (ß Symbol.intern("cloiure.main")))
    (§ def- #_"Var" REQUIRE (ß RT.var("cloiure.core", "require")))
    (§ def- #_"Var" MAIN (ß RT.var("cloiure.main", "main")))

    (§ defn #_"void" main [#_"String[]" args]
        (ß REQUIRE.invoke(CLOIURE_MAIN))
        (ß MAIN.applyTo(RT.seq(args)))
        nil
    )
)
)
